// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

const codes = {};
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
const _isFunctionLike = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
const kHandle = Symbol("kHandle");
const kKeyObject = Symbol("kKeyObject");
const kKeyType = Symbol("kKeyType");
function isKeyObject(obj) {
    return obj != null && obj[kKeyType] !== undefined;
}
function isCryptoKey(obj) {
    return obj != null && obj[kKeyObject] !== undefined;
}
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object";
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod;
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
const validateInteger = hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
function validateBoolean(value, name) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
}
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal = hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default1 = {
    encodings
};
const mod1 = {
    encodings: encodings,
    default: __default1
};
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default2 = {
    indexOfBuffer,
    indexOfNumber
};
const mod2 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default2
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer.from(b, b.offset, b.byteLength);
    }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer.byteLength = byteLength;
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = readUInt16BE;
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = readUInt32BE;
Buffer.prototype.readBigUint64LE = Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUint64BE = Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUint64LE = Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUint64BE = Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var yr = Object.create;
var N = Object.defineProperty;
var wr = Object.getOwnPropertyDescriptor;
var xr = Object.getOwnPropertyNames;
var Br = Object.getPrototypeOf, Er = Object.prototype.hasOwnProperty;
var dr = (i)=>N(i, "__esModule", {
        value: !0
    });
var k = (i, r)=>()=>(r || i((r = {
            exports: {}
        }).exports, r), r.exports);
var gr = (i, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of xr(r))!Er.call(i, n) && n !== "default" && N(i, n, {
        get: ()=>r[n],
        enumerable: !(t = wr(r, n)) || t.enumerable
    });
    return i;
}, H = (i)=>gr(dr(N(i != null ? yr(Br(i)) : {}, "default", i && i.__esModule && "default" in i ? {
        get: ()=>i.default,
        enumerable: !0
    } : {
        value: i,
        enumerable: !0
    })), i);
var J = k((_)=>{
    "use strict";
    _.byteLength = Ir;
    _.toByteArray = Ar;
    _.fromByteArray = Rr;
    var B = [], w = [], mr = typeof Uint8Array != "undefined" ? Uint8Array : Array, b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(m = 0, V = b.length; m < V; ++m)B[m] = b[m], w[b.charCodeAt(m)] = m;
    var m, V;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function z(i) {
        var r = i.length;
        if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = i.indexOf("=");
        t === -1 && (t = r);
        var n = t === r ? 0 : 4 - t % 4;
        return [
            t,
            n
        ];
    }
    function Ir(i) {
        var r = z(i), t = r[0], n = r[1];
        return (t + n) * 3 / 4 - n;
    }
    function Fr(i, r, t) {
        return (r + t) * 3 / 4 - t;
    }
    function Ar(i) {
        var r, t = z(i), n = t[0], e = t[1], o = new mr(Fr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
        for(c = 0; c < f; c += 4)r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
        return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Ur(i) {
        return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function Tr(i, r, t) {
        for(var n, e = [], o = r; o < t; o += 3)n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Ur(n));
        return e.join("");
    }
    function Rr(i) {
        for(var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n; u < f; u += o)e.push(Tr(i, u, u + o > f ? f : u + o));
        return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
});
var K = k((D)=>{
    D.read = function(i, r, t, n, e) {
        var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
        for(p += F, o = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o = o * 256 + i[r + p], p += F, s -= 8);
        for(u = o & (1 << -s) - 1, o >>= -s, s += n; s > 0; u = u * 256 + i[r + p], p += F, s -= 8);
        if (o === 0) o = 1 - l;
        else {
            if (o === c) return u ? NaN : (x ? -1 : 1) * (1 / 0);
            u = u + Math.pow(2, n), o = o - l;
        }
        return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    D.write = function(i, r, t, n, e, o) {
        var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, M = n ? 1 : -1, ar = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for(r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += M, f /= 256, e -= 8);
        for(u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += M, u /= 256, l -= 8);
        i[t + x - M] |= ar * 128;
    };
});
var X = k((R)=>{
    "use strict";
    var $ = J(), A = K(), Z = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    R.Buffer = h;
    R.SlowBuffer = Nr;
    R.INSPECT_MAX_BYTES = 50;
    var S = 2147483647;
    R.kMaxLength = S;
    h.TYPED_ARRAY_SUPPORT = Cr();
    !h.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Cr() {
        try {
            let i = new Uint8Array(1), r = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
        } catch (i1) {
            return !1;
        }
    }
    Object.defineProperty(h.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (!!h.isBuffer(this)) return this.buffer;
        }
    });
    Object.defineProperty(h.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (!!h.isBuffer(this)) return this.byteOffset;
        }
    });
    function d(i) {
        if (i > S) throw new RangeError('The value "' + i + '" is invalid for option "size"');
        let r = new Uint8Array(i);
        return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
        if (typeof i == "number") {
            if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return P(i);
        }
        return Q(i, r, t);
    }
    h.poolSize = 8192;
    function Q(i, r, t) {
        if (typeof i == "string") return Sr(i, r);
        if (ArrayBuffer.isView(i)) return Lr(i);
        if (i == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
        if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer))) return G(i, r, t);
        if (typeof i == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let n = i.valueOf && i.valueOf();
        if (n != null && n !== i) return h.from(n, r, t);
        let e = Mr(i);
        if (e) return e;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function") return h.from(i[Symbol.toPrimitive]("string"), r, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
        return Q(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function v(i) {
        if (typeof i != "number") throw new TypeError('"size" argument must be of type number');
        if (i < 0) throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function _r(i, r, t) {
        return v(i), i <= 0 ? d(i) : r !== void 0 ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
        return _r(i, r, t);
    };
    function P(i) {
        return v(i), d(i < 0 ? 0 : Y(i) | 0);
    }
    h.allocUnsafe = function(i) {
        return P(i);
    };
    h.allocUnsafeSlow = function(i) {
        return P(i);
    };
    function Sr(i, r) {
        if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        let t = rr(i, r) | 0, n = d(t), e = n.write(i, r);
        return e !== t && (n = n.slice(0, e)), n;
    }
    function O(i) {
        let r = i.length < 0 ? 0 : Y(i.length) | 0, t = d(r);
        for(let n = 0; n < r; n += 1)t[n] = i[n] & 255;
        return t;
    }
    function Lr(i) {
        if (E(i, Uint8Array)) {
            let r = new Uint8Array(i);
            return G(r.buffer, r.byteOffset, r.byteLength);
        }
        return O(i);
    }
    function G(i, r, t) {
        if (r < 0 || i.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
        if (i.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function Mr(i) {
        if (h.isBuffer(i)) {
            let r = Y(i.length) | 0, t = d(r);
            return t.length === 0 || i.copy(t, 0, 0, r), t;
        }
        if (i.length !== void 0) return typeof i.length != "number" || j(i.length) ? d(0) : O(i);
        if (i.type === "Buffer" && Array.isArray(i.data)) return O(i.data);
    }
    function Y(i) {
        if (i >= S) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S.toString(16) + " bytes");
        return i | 0;
    }
    function Nr(i) {
        return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
        return r != null && r._isBuffer === !0 && r !== h.prototype;
    };
    h.compare = function(r, t) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (r === t) return 0;
        let n = r.length, e = t.length;
        for(let o = 0, u = Math.min(n, e); o < u; ++o)if (r[o] !== t[o]) {
            n = r[o], e = t[o];
            break;
        }
        return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
        switch(String(r).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    };
    h.concat = function(r, t) {
        if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return h.alloc(0);
        let n;
        if (t === void 0) for(t = 0, n = 0; n < r.length; ++n)t += r[n].length;
        let e = h.allocUnsafe(t), o = 0;
        for(n = 0; n < r.length; ++n){
            let u = r[n];
            if (E(u, Uint8Array)) o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
            else if (h.isBuffer(u)) u.copy(e, o);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            o += u.length;
        }
        return e;
    };
    function rr(i, r) {
        if (h.isBuffer(i)) return i.length;
        if (ArrayBuffer.isView(i) || E(i, ArrayBuffer)) return i.byteLength;
        if (typeof i != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
        let t = i.length, n = arguments.length > 2 && arguments[2] === !0;
        if (!n && t === 0) return 0;
        let e = !1;
        for(;;)switch(r){
            case "ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return W(i).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return lr(i).length;
            default:
                if (e) return n ? -1 : W(i).length;
                r = ("" + r).toLowerCase(), e = !0;
        }
    }
    h.byteLength = rr;
    function kr(i, r, t) {
        let n = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
        for(i || (i = "utf8");;)switch(i){
            case "hex":
                return jr(this, r, t);
            case "utf8":
            case "utf-8":
                return nr(this, r, t);
            case "ascii":
                return qr(this, r, t);
            case "latin1":
            case "binary":
                return Wr(this, r, t);
            case "base64":
                return Gr(this, r, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Xr(this, r, t);
            default:
                if (n) throw new TypeError("Unknown encoding: " + i);
                i = (i + "").toLowerCase(), n = !0;
        }
    }
    h.prototype._isBuffer = !0;
    function I(i, r, t) {
        let n = i[r];
        i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
        let r = this.length;
        if (r % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let t = 0; t < r; t += 2)I(this, t, t + 1);
        return this;
    };
    h.prototype.swap32 = function() {
        let r = this.length;
        if (r % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let t = 0; t < r; t += 4)I(this, t, t + 3), I(this, t + 1, t + 2);
        return this;
    };
    h.prototype.swap64 = function() {
        let r = this.length;
        if (r % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let t = 0; t < r; t += 8)I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
        return this;
    };
    h.prototype.toString = function() {
        let r = this.length;
        return r === 0 ? "" : arguments.length === 0 ? nr(this, 0, r) : kr.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
        if (!h.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
        let r = "", t = R.INSPECT_MAX_BYTES;
        return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    Z && (h.prototype[Z] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
        if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o === void 0 && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length) throw new RangeError("out of range index");
        if (e >= o && t >= n) return 0;
        if (e >= o) return -1;
        if (t >= n) return 1;
        if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r) return 0;
        let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
        for(let p = 0; p < c; ++p)if (l[p] !== s[p]) {
            u = l[p], f = s[p];
            break;
        }
        return u < f ? -1 : f < u ? 1 : 0;
    };
    function tr(i, r, t, n, e) {
        if (i.length === 0) return -1;
        if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, j(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
            if (e) return -1;
            t = i.length - 1;
        } else if (t < 0) if (e) t = 0;
        else return -1;
        if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r)) return r.length === 0 ? -1 : ir(i, r, t, n, e);
        if (typeof r == "number") return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir(i, [
            r
        ], t, n, e);
        throw new TypeError("val must be string, number or Buffer");
    }
    function ir(i, r, t, n, e) {
        let o = 1, u = i.length, f = r.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
            if (i.length < 2 || r.length < 2) return -1;
            o = 2, u /= 2, f /= 2, t /= 2;
        }
        function c(s, p) {
            return o === 1 ? s[p] : s.readUInt16BE(p * o);
        }
        let l;
        if (e) {
            let s = -1;
            for(l = t; l < u; l++)if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
                if (s === -1 && (s = l), l - s + 1 === f) return s * o;
            } else s !== -1 && (l -= l - s), s = -1;
        } else for(t + f > u && (t = u - f), l = t; l >= 0; l--){
            let s1 = !0;
            for(let p = 0; p < f; p++)if (c(i, l + p) !== c(r, p)) {
                s1 = !1;
                break;
            }
            if (s1) return l;
        }
        return -1;
    }
    h.prototype.includes = function(r, t, n) {
        return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
        return tr(this, r, t, n, !0);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
        return tr(this, r, t, n, !1);
    };
    function br(i, r, t, n) {
        t = Number(t) || 0;
        let e = i.length - t;
        n ? (n = Number(n), n > e && (n = e)) : n = e;
        let o = r.length;
        n > o / 2 && (n = o / 2);
        let u;
        for(u = 0; u < n; ++u){
            let f = parseInt(r.substr(u * 2, 2), 16);
            if (j(f)) return u;
            i[t + u] = f;
        }
        return u;
    }
    function Dr(i, r, t, n) {
        return L(W(r, i.length - t), i, t, n);
    }
    function $r(i, r, t, n) {
        return L(Jr(r), i, t, n);
    }
    function Pr(i, r, t, n) {
        return L(lr(r), i, t, n);
    }
    function Or(i, r, t, n) {
        return L(Kr(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
        if (t === void 0) e = "utf8", n = this.length, t = 0;
        else if (n === void 0 && typeof t == "string") e = t, n = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - t;
        if ((n === void 0 || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        e || (e = "utf8");
        let u = !1;
        for(;;)switch(e){
            case "hex":
                return br(this, r, t, n);
            case "utf8":
            case "utf-8":
                return Dr(this, r, t, n);
            case "ascii":
            case "latin1":
            case "binary":
                return $r(this, r, t, n);
            case "base64":
                return Pr(this, r, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Or(this, r, t, n);
            default:
                if (u) throw new TypeError("Unknown encoding: " + e);
                e = ("" + e).toLowerCase(), u = !0;
        }
    };
    h.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function Gr(i, r, t) {
        return r === 0 && t === i.length ? $.fromByteArray(i) : $.fromByteArray(i.slice(r, t));
    }
    function nr(i, r, t) {
        t = Math.min(i.length, t);
        let n = [], e = r;
        for(; e < t;){
            let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (e + f <= t) {
                let c, l, s, p;
                switch(f){
                    case 1:
                        o < 128 && (u = o);
                        break;
                    case 2:
                        c = i[e + 1], (c & 192) == 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
                        break;
                    case 3:
                        c = i[e + 1], l = i[e + 2], (c & 192) == 128 && (l & 192) == 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
                        break;
                    case 4:
                        c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) == 128 && (l & 192) == 128 && (s & 192) == 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
                }
            }
            u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
        }
        return Yr(n);
    }
    var er = 4096;
    function Yr(i) {
        let r = i.length;
        if (r <= er) return String.fromCharCode.apply(String, i);
        let t = "", n = 0;
        for(; n < r;)t += String.fromCharCode.apply(String, i.slice(n, n += er));
        return t;
    }
    function qr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e] & 127);
        return n;
    }
    function Wr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e]);
        return n;
    }
    function jr(i, r, t) {
        let n = i.length;
        (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
        let e = "";
        for(let o = r; o < t; ++o)e += Zr[i[o]];
        return e;
    }
    function Xr(i, r, t) {
        let n = i.slice(r, t), e = "";
        for(let o = 0; o < n.length - 1; o += 2)e += String.fromCharCode(n[o] + n[o + 1] * 256);
        return e;
    }
    h.prototype.slice = function(r, t) {
        let n = this.length;
        r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
        let e = this.subarray(r, t);
        return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
        if (i % 1 != 0 || i < 0) throw new RangeError("offset is not uint");
        if (i + r > t) throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r + --t], o = 1;
        for(; t > 0 && (o *= 256);)e += this[r + --t] * o;
        return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
        return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
        return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = t, o = 1, u = this[r + --e];
        for(; e > 0 && (o *= 256);)u += this[r + --e] * o;
        return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r] | this[r + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r + 1] | this[r] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
        return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
        return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), A.read(this, r, !0, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), A.read(this, r, !1, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), A.read(this, r, !0, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), A.read(this, r, !1, 52, 8);
    };
    function y(i, r, t, n, e, o) {
        if (!h.isBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > e || r < o) throw new RangeError('"value" argument is out of bounds');
        if (t + n > i.length) throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = 1, u = 0;
        for(this[t] = r & 255; ++u < n && (o *= 256);)this[t + u] = r / o & 255;
        return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = n - 1, u = 1;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)this[t + o] = r / u & 255;
        return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function or(i, r, t, n, e) {
        sr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function ur(i, r, t, n, e) {
        sr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
        return or(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
        return ur(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = 0, u = 1, f = 0;
        for(this[t] = r & 255; ++o < n && (u *= 256);)r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = n - 1, u = 1, f = 0;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
        return or(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
        return ur(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function hr(i, r, t, n, e, o) {
        if (t + n > i.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    function fr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || hr(i, r, t, 4, 34028234663852886e22, -34028234663852886e22), A.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
        return fr(this, r, t, !0, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
        return fr(this, r, t, !1, n);
    };
    function cr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || hr(i, r, t, 8, 17976931348623157e292, -17976931348623157e292), A.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
        return cr(this, r, t, !0, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
        return cr(this, r, t, !1, n);
    };
    h.prototype.copy = function(r, t, n, e) {
        if (!h.isBuffer(r)) throw new TypeError("argument should be a Buffer");
        if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
        if (e < 0) throw new RangeError("sourceEnd out of bounds");
        e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
        let o = e - n;
        return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
        if (typeof r == "string") {
            if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string") throw new TypeError("encoding must be a string");
            if (typeof e == "string" && !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            if (r.length === 1) {
                let u = r.charCodeAt(0);
                (e === "utf8" && u < 128 || e === "latin1") && (r = u);
            }
        } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
        let o;
        if (typeof r == "number") for(o = t; o < n; ++o)this[o] = r;
        else {
            let u1 = h.isBuffer(r) ? r : h.from(r, e), f = u1.length;
            if (f === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
            for(o = 0; o < n - t; ++o)this[o + t] = u1[o % f];
        }
        return this;
    };
    var U = {};
    function q(i, r, t) {
        U[i] = class extends t {
            constructor(){
                super();
                Object.defineProperty(this, "message", {
                    value: r.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
            }
            get code() {
                return i;
            }
            set code(e) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: e,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${i}]: ${this.message}`;
            }
        };
    }
    q("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
        return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    q("ERR_INVALID_ARG_TYPE", function(i, r) {
        return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    q("ERR_OUT_OF_RANGE", function(i, r, t) {
        let n = `The value of "${i}" is out of range.`, e = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = pr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = pr(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
    }, RangeError);
    function pr(i) {
        let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
        for(; t >= n + 4; t -= 3)r = `_${i.slice(t - 3, t)}${r}`;
        return `${i.slice(0, t)}${r}`;
    }
    function Hr(i, r, t) {
        T(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && C(r, i.length - (t + 1));
    }
    function sr(i, r, t, n, e, o) {
        if (i > t || i < r) {
            let u = typeof r == "bigint" ? "n" : "", f;
            throw o > 3 ? r === 0 || r === BigInt(0) ? f = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f = `>= ${r}${u} and <= ${t}${u}`, new U.ERR_OUT_OF_RANGE("value", f, i);
        }
        Hr(n, e, o);
    }
    function T(i, r) {
        if (typeof i != "number") throw new U.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function C(i, r, t) {
        throw Math.floor(i) !== i ? (T(i, t), new U.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new U.ERR_BUFFER_OUT_OF_BOUNDS : new U.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Vr = /[^+/0-9A-Za-z-_]/g;
    function zr(i) {
        if (i = i.split("=")[0], i = i.trim().replace(Vr, ""), i.length < 2) return "";
        for(; i.length % 4 != 0;)i = i + "=";
        return i;
    }
    function W(i, r) {
        r = r || 1 / 0;
        let t, n = i.length, e = null, o = [];
        for(let u = 0; u < n; ++u){
            if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
                if (!e) {
                    if (t > 56319) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    } else if (u + 1 === n) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    }
                    e = t;
                    continue;
                }
                if (t < 56320) {
                    (r -= 3) > -1 && o.push(239, 191, 189), e = t;
                    continue;
                }
                t = (e - 55296 << 10 | t - 56320) + 65536;
            } else e && (r -= 3) > -1 && o.push(239, 191, 189);
            if (e = null, t < 128) {
                if ((r -= 1) < 0) break;
                o.push(t);
            } else if (t < 2048) {
                if ((r -= 2) < 0) break;
                o.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((r -= 3) < 0) break;
                o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((r -= 4) < 0) break;
                o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return o;
    }
    function Jr(i) {
        let r = [];
        for(let t = 0; t < i.length; ++t)r.push(i.charCodeAt(t) & 255);
        return r;
    }
    function Kr(i, r) {
        let t, n, e, o = [];
        for(let u = 0; u < i.length && !((r -= 2) < 0); ++u)t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
        return o;
    }
    function lr(i) {
        return $.toByteArray(zr(i));
    }
    function L(i, r, t, n) {
        let e;
        for(e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)r[e + t] = i[e];
        return e;
    }
    function E(i, r) {
        return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function j(i) {
        return i !== i;
    }
    var Zr = function() {
        let i = "0123456789abcdef", r = new Array(256);
        for(let t = 0; t < 16; ++t){
            let n = t * 16;
            for(let e = 0; e < 16; ++e)r[n + e] = i[t] + i[e];
        }
        return r;
    }();
    function g(i) {
        return typeof BigInt == "undefined" ? Qr : i;
    }
    function Qr() {
        throw new Error("BigInt not supported");
    }
});
var vr = H(X()), rt = H(X()), { Buffer: ut , SlowBuffer: ht , INSPECT_MAX_BYTES: ft , kMaxLength: ct  } = vr;
var export_default = rt.default;
var pi = Object.create;
var ni = Object.defineProperty;
var Mi = Object.getOwnPropertyDescriptor;
var gi = Object.getOwnPropertyNames;
var ci = Object.getPrototypeOf, wi = Object.prototype.hasOwnProperty;
((b)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(b, {
        get: (et, v)=>(typeof require != "undefined" ? require : et)[v]
    }) : b)(function(b) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + b + '" is not supported');
});
var xi = (b, et)=>()=>(et || b((et = {
            exports: {}
        }).exports, et), et.exports);
var bi = (b, et, v, nt)=>{
    if (et && typeof et == "object" || typeof et == "function") for (let l of gi(et))!wi.call(b, l) && l !== v && ni(b, l, {
        get: ()=>et[l],
        enumerable: !(nt = Mi(et, l)) || nt.enumerable
    });
    return b;
};
var si = (b, et, v)=>(v = b != null ? pi(ci(b)) : {}, bi(et || !b || !b.__esModule ? ni(v, "default", {
        value: b,
        enumerable: !0
    }) : v, b));
var zt = xi((oi, Lt)=>{
    (function(b, et) {
        "use strict";
        function v(o, t) {
            if (!o) throw new Error(t || "Assertion failed");
        }
        function nt(o, t) {
            o.super_ = t;
            var r = function() {};
            r.prototype = t.prototype, o.prototype = new r, o.prototype.constructor = o;
        }
        function l(o, t, r) {
            if (l.isBN(o)) return o;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, o !== null && ((t === "le" || t === "be") && (r = t, t = 10), this._init(o || 0, t || 10, r || "be"));
        }
        typeof b == "object" ? b.exports = l : et.BN = l, l.BN = l, l.wordSize = 26;
        var at;
        try {
            typeof document < "u" && typeof window.Buffer < "u" ? at = window.Buffer : at = export_default.Buffer;
        } catch  {}
        l.isBN = function(t) {
            return t instanceof l ? !0 : t !== null && typeof t == "object" && t.constructor.wordSize === l.wordSize && Array.isArray(t.words);
        }, l.max = function(t, r) {
            return t.cmp(r) > 0 ? t : r;
        }, l.min = function(t, r) {
            return t.cmp(r) < 0 ? t : r;
        }, l.prototype._init = function(t, r, e) {
            if (typeof t == "number") return this._initNumber(t, r, e);
            if (typeof t == "object") return this._initArray(t, r, e);
            r === "hex" && (r = 16), v(r === (r | 0) && r >= 2 && r <= 36), t = t.toString().replace(/\s+/g, "");
            var h = 0;
            t[0] === "-" && (h++, this.negative = 1), h < t.length && (r === 16 ? this._parseHex(t, h, e) : (this._parseBase(t, r, h), e === "le" && this._initArray(this.toArray(), r, e)));
        }, l.prototype._initNumber = function(t, r, e) {
            t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [
                t & 67108863
            ], this.length = 1) : t < 4503599627370496 ? (this.words = [
                t & 67108863,
                t / 67108864 & 67108863
            ], this.length = 2) : (v(t < 9007199254740992), this.words = [
                t & 67108863,
                t / 67108864 & 67108863,
                1
            ], this.length = 3), e === "le" && this._initArray(this.toArray(), r, e);
        }, l.prototype._initArray = function(t, r, e) {
            if (v(typeof t.length == "number"), t.length <= 0) return this.words = [
                0
            ], this.length = 1, this;
            this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
            for(var h = 0; h < this.length; h++)this.words[h] = 0;
            var s, a, u = 0;
            if (e === "be") for(h = t.length - 1, s = 0; h >= 0; h -= 3)a = t[h] | t[h - 1] << 8 | t[h - 2] << 16, this.words[s] |= a << u & 67108863, this.words[s + 1] = a >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, s++);
            else if (e === "le") for(h = 0, s = 0; h < t.length; h += 3)a = t[h] | t[h + 1] << 8 | t[h + 2] << 16, this.words[s] |= a << u & 67108863, this.words[s + 1] = a >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, s++);
            return this.strip();
        };
        function It(o, t) {
            var r = o.charCodeAt(t);
            return r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : r - 48 & 15;
        }
        function Nt(o, t, r) {
            var e = It(o, r);
            return r - 1 >= t && (e |= It(o, r - 1) << 4), e;
        }
        l.prototype._parseHex = function(t, r, e) {
            this.length = Math.ceil((t.length - r) / 6), this.words = new Array(this.length);
            for(var h = 0; h < this.length; h++)this.words[h] = 0;
            var s = 0, a = 0, u;
            if (e === "be") for(h = t.length - 1; h >= r; h -= 2)u = Nt(t, r, h) << s, this.words[a] |= u & 67108863, s >= 18 ? (s -= 18, a += 1, this.words[a] |= u >>> 26) : s += 8;
            else {
                var f = t.length - r;
                for(h = f % 2 === 0 ? r + 1 : r; h < t.length; h += 2)u = Nt(t, r, h) << s, this.words[a] |= u & 67108863, s >= 18 ? (s -= 18, a += 1, this.words[a] |= u >>> 26) : s += 8;
            }
            this.strip();
        };
        function Et(o, t, r, e) {
            for(var h = 0, s = Math.min(o.length, r), a = t; a < s; a++){
                var u = o.charCodeAt(a) - 48;
                h *= e, u >= 49 ? h += u - 49 + 10 : u >= 17 ? h += u - 17 + 10 : h += u;
            }
            return h;
        }
        l.prototype._parseBase = function(t, r, e) {
            this.words = [
                0
            ], this.length = 1;
            for(var h = 0, s = 1; s <= 67108863; s *= r)h++;
            h--, s = s / r | 0;
            for(var a = t.length - e, u = a % h, f = Math.min(a, a - u) + e, i = 0, n = e; n < f; n += h)i = Et(t, n, n + h, r), this.imuln(s), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
            if (u !== 0) {
                var d = 1;
                for(i = Et(t, n, t.length, r), n = 0; n < u; n++)d *= r;
                this.imuln(d), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
            }
            this.strip();
        }, l.prototype.copy = function(t) {
            t.words = new Array(this.length);
            for(var r = 0; r < this.length; r++)t.words[r] = this.words[r];
            t.length = this.length, t.negative = this.negative, t.red = this.red;
        }, l.prototype.clone = function() {
            var t = new l(null);
            return this.copy(t), t;
        }, l.prototype._expand = function(t) {
            for(; this.length < t;)this.words[this.length++] = 0;
            return this;
        }, l.prototype.strip = function() {
            for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
            return this._normSign();
        }, l.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, l.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var Ot = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000"
        ], ui = [
            0,
            0,
            25,
            16,
            12,
            11,
            10,
            9,
            8,
            8,
            7,
            7,
            7,
            7,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5
        ], vi = [
            0,
            0,
            33554432,
            43046721,
            16777216,
            48828125,
            60466176,
            40353607,
            16777216,
            43046721,
            1e7,
            19487171,
            35831808,
            62748517,
            7529536,
            11390625,
            16777216,
            24137569,
            34012224,
            47045881,
            64e6,
            4084101,
            5153632,
            6436343,
            7962624,
            9765625,
            11881376,
            14348907,
            17210368,
            20511149,
            243e5,
            28629151,
            33554432,
            39135393,
            45435424,
            52521875,
            60466176
        ];
        l.prototype.toString = function(t, r) {
            t = t || 10, r = r | 0 || 1;
            var e;
            if (t === 16 || t === "hex") {
                e = "";
                for(var h = 0, s = 0, a = 0; a < this.length; a++){
                    var u = this.words[a], f = ((u << h | s) & 16777215).toString(16);
                    s = u >>> 24 - h & 16777215, s !== 0 || a !== this.length - 1 ? e = Ot[6 - f.length] + f + e : e = f + e, h += 2, h >= 26 && (h -= 26, a--);
                }
                for(s !== 0 && (e = s.toString(16) + e); e.length % r !== 0;)e = "0" + e;
                return this.negative !== 0 && (e = "-" + e), e;
            }
            if (t === (t | 0) && t >= 2 && t <= 36) {
                var i = ui[t], n = vi[t];
                e = "";
                var d = this.clone();
                for(d.negative = 0; !d.isZero();){
                    var m = d.modn(n).toString(t);
                    d = d.idivn(n), d.isZero() ? e = m + e : e = Ot[i - m.length] + m + e;
                }
                for(this.isZero() && (e = "0" + e); e.length % r !== 0;)e = "0" + e;
                return this.negative !== 0 && (e = "-" + e), e;
            }
            v(!1, "Base should be between 2 and 36");
        }, l.prototype.toNumber = function() {
            var t = this.words[0];
            return this.length === 2 ? t += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && v(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t : t;
        }, l.prototype.toJSON = function() {
            return this.toString(16);
        }, l.prototype.toBuffer = function(t, r) {
            return v(typeof at < "u"), this.toArrayLike(at, t, r);
        }, l.prototype.toArray = function(t, r) {
            return this.toArrayLike(Array, t, r);
        }, l.prototype.toArrayLike = function(t, r, e) {
            var h = this.byteLength(), s = e || Math.max(1, h);
            v(h <= s, "byte array longer than desired length"), v(s > 0, "Requested array length <= 0"), this.strip();
            var a = r === "le", u = new t(s), f, i, n = this.clone();
            if (a) {
                for(i = 0; !n.isZero(); i++)f = n.andln(255), n.iushrn(8), u[i] = f;
                for(; i < s; i++)u[i] = 0;
            } else {
                for(i = 0; i < s - h; i++)u[i] = 0;
                for(i = 0; !n.isZero(); i++)f = n.andln(255), n.iushrn(8), u[s - i - 1] = f;
            }
            return u;
        }, Math.clz32 ? l.prototype._countBits = function(t) {
            return 32 - Math.clz32(t);
        } : l.prototype._countBits = function(t) {
            var r = t, e = 0;
            return r >= 4096 && (e += 13, r >>>= 13), r >= 64 && (e += 7, r >>>= 7), r >= 8 && (e += 4, r >>>= 4), r >= 2 && (e += 2, r >>>= 2), e + r;
        }, l.prototype._zeroBits = function(t) {
            if (t === 0) return 26;
            var r = t, e = 0;
            return (r & 8191) === 0 && (e += 13, r >>>= 13), (r & 127) === 0 && (e += 7, r >>>= 7), (r & 15) === 0 && (e += 4, r >>>= 4), (r & 3) === 0 && (e += 2, r >>>= 2), (r & 1) === 0 && e++, e;
        }, l.prototype.bitLength = function() {
            var t = this.words[this.length - 1], r = this._countBits(t);
            return (this.length - 1) * 26 + r;
        };
        function di(o) {
            for(var t = new Array(o.bitLength()), r = 0; r < t.length; r++){
                var e = r / 26 | 0, h = r % 26;
                t[r] = (o.words[e] & 1 << h) >>> h;
            }
            return t;
        }
        l.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for(var t = 0, r = 0; r < this.length; r++){
                var e = this._zeroBits(this.words[r]);
                if (t += e, e !== 26) break;
            }
            return t;
        }, l.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8);
        }, l.prototype.toTwos = function(t) {
            return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
        }, l.prototype.fromTwos = function(t) {
            return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
        }, l.prototype.isNeg = function() {
            return this.negative !== 0;
        }, l.prototype.neg = function() {
            return this.clone().ineg();
        }, l.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this;
        }, l.prototype.iuor = function(t) {
            for(; this.length < t.length;)this.words[this.length++] = 0;
            for(var r = 0; r < t.length; r++)this.words[r] = this.words[r] | t.words[r];
            return this.strip();
        }, l.prototype.ior = function(t) {
            return v((this.negative | t.negative) === 0), this.iuor(t);
        }, l.prototype.or = function(t) {
            return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this);
        }, l.prototype.uor = function(t) {
            return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this);
        }, l.prototype.iuand = function(t) {
            var r;
            this.length > t.length ? r = t : r = this;
            for(var e = 0; e < r.length; e++)this.words[e] = this.words[e] & t.words[e];
            return this.length = r.length, this.strip();
        }, l.prototype.iand = function(t) {
            return v((this.negative | t.negative) === 0), this.iuand(t);
        }, l.prototype.and = function(t) {
            return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this);
        }, l.prototype.uand = function(t) {
            return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this);
        }, l.prototype.iuxor = function(t) {
            var r, e;
            this.length > t.length ? (r = this, e = t) : (r = t, e = this);
            for(var h = 0; h < e.length; h++)this.words[h] = r.words[h] ^ e.words[h];
            if (this !== r) for(; h < r.length; h++)this.words[h] = r.words[h];
            return this.length = r.length, this.strip();
        }, l.prototype.ixor = function(t) {
            return v((this.negative | t.negative) === 0), this.iuxor(t);
        }, l.prototype.xor = function(t) {
            return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this);
        }, l.prototype.uxor = function(t) {
            return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this);
        }, l.prototype.inotn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = Math.ceil(t / 26) | 0, e = t % 26;
            this._expand(r), e > 0 && r--;
            for(var h = 0; h < r; h++)this.words[h] = ~this.words[h] & 67108863;
            return e > 0 && (this.words[h] = ~this.words[h] & 67108863 >> 26 - e), this.strip();
        }, l.prototype.notn = function(t) {
            return this.clone().inotn(t);
        }, l.prototype.setn = function(t, r) {
            v(typeof t == "number" && t >= 0);
            var e = t / 26 | 0, h = t % 26;
            return this._expand(e + 1), r ? this.words[e] = this.words[e] | 1 << h : this.words[e] = this.words[e] & ~(1 << h), this.strip();
        }, l.prototype.iadd = function(t) {
            var r;
            if (this.negative !== 0 && t.negative === 0) return this.negative = 0, r = this.isub(t), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && t.negative !== 0) return t.negative = 0, r = this.isub(t), t.negative = 1, r._normSign();
            var e, h;
            this.length > t.length ? (e = this, h = t) : (e = t, h = this);
            for(var s = 0, a = 0; a < h.length; a++)r = (e.words[a] | 0) + (h.words[a] | 0) + s, this.words[a] = r & 67108863, s = r >>> 26;
            for(; s !== 0 && a < e.length; a++)r = (e.words[a] | 0) + s, this.words[a] = r & 67108863, s = r >>> 26;
            if (this.length = e.length, s !== 0) this.words[this.length] = s, this.length++;
            else if (e !== this) for(; a < e.length; a++)this.words[a] = e.words[a];
            return this;
        }, l.prototype.add = function(t) {
            var r;
            return t.negative !== 0 && this.negative === 0 ? (t.negative = 0, r = this.sub(t), t.negative ^= 1, r) : t.negative === 0 && this.negative !== 0 ? (this.negative = 0, r = t.sub(this), this.negative = 1, r) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this);
        }, l.prototype.isub = function(t) {
            if (t.negative !== 0) {
                t.negative = 0;
                var r = this.iadd(t);
                return t.negative = 1, r._normSign();
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
            var e = this.cmp(t);
            if (e === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var h, s;
            e > 0 ? (h = this, s = t) : (h = t, s = this);
            for(var a = 0, u = 0; u < s.length; u++)r = (h.words[u] | 0) - (s.words[u] | 0) + a, a = r >> 26, this.words[u] = r & 67108863;
            for(; a !== 0 && u < h.length; u++)r = (h.words[u] | 0) + a, a = r >> 26, this.words[u] = r & 67108863;
            if (a === 0 && u < h.length && h !== this) for(; u < h.length; u++)this.words[u] = h.words[u];
            return this.length = Math.max(this.length, u), h !== this && (this.negative = 1), this.strip();
        }, l.prototype.sub = function(t) {
            return this.clone().isub(t);
        };
        function Kt(o, t, r) {
            r.negative = t.negative ^ o.negative;
            var e = o.length + t.length | 0;
            r.length = e, e = e - 1 | 0;
            var h = o.words[0] | 0, s = t.words[0] | 0, a = h * s, u = a & 67108863, f = a / 67108864 | 0;
            r.words[0] = u;
            for(var i = 1; i < e; i++){
                for(var n = f >>> 26, d = f & 67108863, m = Math.min(i, t.length - 1), p = Math.max(0, i - o.length + 1); p <= m; p++){
                    var M = i - p | 0;
                    h = o.words[M] | 0, s = t.words[p] | 0, a = h * s + d, n += a / 67108864 | 0, d = a & 67108863;
                }
                r.words[i] = d | 0, f = n | 0;
            }
            return f !== 0 ? r.words[i] = f | 0 : r.length--, r.strip();
        }
        var Ft = function(t, r, e) {
            var h = t.words, s = r.words, a = e.words, u = 0, f, i, n, d = h[0] | 0, m = d & 8191, p = d >>> 13, M = h[1] | 0, g = M & 8191, c = M >>> 13, st = h[2] | 0, w = st & 8191, y = st >>> 13, $t = h[3] | 0, _ = $t & 8191, A = $t >>> 13, Ct = h[4] | 0, B = Ct & 8191, S = Ct >>> 13, Jt = h[5] | 0, k = Jt & 8191, q = Jt >>> 13, Ut = h[6] | 0, R = Ut & 8191, Z = Ut >>> 13, Wt = h[7] | 0, T = Wt & 8191, L = Wt >>> 13, Gt = h[8] | 0, z = Gt & 8191, I = Gt >>> 13, Qt = h[9] | 0, N = Qt & 8191, E = Qt >>> 13, Vt = s[0] | 0, O = Vt & 8191, K = Vt >>> 13, Xt = s[1] | 0, F = Xt & 8191, H = Xt >>> 13, Yt = s[2] | 0, P = Yt & 8191, D = Yt >>> 13, jt = s[3] | 0, $ = jt & 8191, C = jt >>> 13, ti = s[4] | 0, J = ti & 8191, U = ti >>> 13, ii = s[5] | 0, W = ii & 8191, G = ii >>> 13, ri = s[6] | 0, Q = ri & 8191, V = ri >>> 13, ei = s[7] | 0, X = ei & 8191, Y = ei >>> 13, hi = s[8] | 0, j = hi & 8191, tt = hi >>> 13, fi = s[9] | 0, it = fi & 8191, rt = fi >>> 13;
            e.negative = t.negative ^ r.negative, e.length = 19, f = Math.imul(m, O), i = Math.imul(m, K), i = i + Math.imul(p, O) | 0, n = Math.imul(p, K);
            var dt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, f = Math.imul(g, O), i = Math.imul(g, K), i = i + Math.imul(c, O) | 0, n = Math.imul(c, K), f = f + Math.imul(m, F) | 0, i = i + Math.imul(m, H) | 0, i = i + Math.imul(p, F) | 0, n = n + Math.imul(p, H) | 0;
            var mt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, f = Math.imul(w, O), i = Math.imul(w, K), i = i + Math.imul(y, O) | 0, n = Math.imul(y, K), f = f + Math.imul(g, F) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(c, F) | 0, n = n + Math.imul(c, H) | 0, f = f + Math.imul(m, P) | 0, i = i + Math.imul(m, D) | 0, i = i + Math.imul(p, P) | 0, n = n + Math.imul(p, D) | 0;
            var pt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, f = Math.imul(_, O), i = Math.imul(_, K), i = i + Math.imul(A, O) | 0, n = Math.imul(A, K), f = f + Math.imul(w, F) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(y, F) | 0, n = n + Math.imul(y, H) | 0, f = f + Math.imul(g, P) | 0, i = i + Math.imul(g, D) | 0, i = i + Math.imul(c, P) | 0, n = n + Math.imul(c, D) | 0, f = f + Math.imul(m, $) | 0, i = i + Math.imul(m, C) | 0, i = i + Math.imul(p, $) | 0, n = n + Math.imul(p, C) | 0;
            var Mt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, f = Math.imul(B, O), i = Math.imul(B, K), i = i + Math.imul(S, O) | 0, n = Math.imul(S, K), f = f + Math.imul(_, F) | 0, i = i + Math.imul(_, H) | 0, i = i + Math.imul(A, F) | 0, n = n + Math.imul(A, H) | 0, f = f + Math.imul(w, P) | 0, i = i + Math.imul(w, D) | 0, i = i + Math.imul(y, P) | 0, n = n + Math.imul(y, D) | 0, f = f + Math.imul(g, $) | 0, i = i + Math.imul(g, C) | 0, i = i + Math.imul(c, $) | 0, n = n + Math.imul(c, C) | 0, f = f + Math.imul(m, J) | 0, i = i + Math.imul(m, U) | 0, i = i + Math.imul(p, J) | 0, n = n + Math.imul(p, U) | 0;
            var gt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, f = Math.imul(k, O), i = Math.imul(k, K), i = i + Math.imul(q, O) | 0, n = Math.imul(q, K), f = f + Math.imul(B, F) | 0, i = i + Math.imul(B, H) | 0, i = i + Math.imul(S, F) | 0, n = n + Math.imul(S, H) | 0, f = f + Math.imul(_, P) | 0, i = i + Math.imul(_, D) | 0, i = i + Math.imul(A, P) | 0, n = n + Math.imul(A, D) | 0, f = f + Math.imul(w, $) | 0, i = i + Math.imul(w, C) | 0, i = i + Math.imul(y, $) | 0, n = n + Math.imul(y, C) | 0, f = f + Math.imul(g, J) | 0, i = i + Math.imul(g, U) | 0, i = i + Math.imul(c, J) | 0, n = n + Math.imul(c, U) | 0, f = f + Math.imul(m, W) | 0, i = i + Math.imul(m, G) | 0, i = i + Math.imul(p, W) | 0, n = n + Math.imul(p, G) | 0;
            var ct = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, f = Math.imul(R, O), i = Math.imul(R, K), i = i + Math.imul(Z, O) | 0, n = Math.imul(Z, K), f = f + Math.imul(k, F) | 0, i = i + Math.imul(k, H) | 0, i = i + Math.imul(q, F) | 0, n = n + Math.imul(q, H) | 0, f = f + Math.imul(B, P) | 0, i = i + Math.imul(B, D) | 0, i = i + Math.imul(S, P) | 0, n = n + Math.imul(S, D) | 0, f = f + Math.imul(_, $) | 0, i = i + Math.imul(_, C) | 0, i = i + Math.imul(A, $) | 0, n = n + Math.imul(A, C) | 0, f = f + Math.imul(w, J) | 0, i = i + Math.imul(w, U) | 0, i = i + Math.imul(y, J) | 0, n = n + Math.imul(y, U) | 0, f = f + Math.imul(g, W) | 0, i = i + Math.imul(g, G) | 0, i = i + Math.imul(c, W) | 0, n = n + Math.imul(c, G) | 0, f = f + Math.imul(m, Q) | 0, i = i + Math.imul(m, V) | 0, i = i + Math.imul(p, Q) | 0, n = n + Math.imul(p, V) | 0;
            var wt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, f = Math.imul(T, O), i = Math.imul(T, K), i = i + Math.imul(L, O) | 0, n = Math.imul(L, K), f = f + Math.imul(R, F) | 0, i = i + Math.imul(R, H) | 0, i = i + Math.imul(Z, F) | 0, n = n + Math.imul(Z, H) | 0, f = f + Math.imul(k, P) | 0, i = i + Math.imul(k, D) | 0, i = i + Math.imul(q, P) | 0, n = n + Math.imul(q, D) | 0, f = f + Math.imul(B, $) | 0, i = i + Math.imul(B, C) | 0, i = i + Math.imul(S, $) | 0, n = n + Math.imul(S, C) | 0, f = f + Math.imul(_, J) | 0, i = i + Math.imul(_, U) | 0, i = i + Math.imul(A, J) | 0, n = n + Math.imul(A, U) | 0, f = f + Math.imul(w, W) | 0, i = i + Math.imul(w, G) | 0, i = i + Math.imul(y, W) | 0, n = n + Math.imul(y, G) | 0, f = f + Math.imul(g, Q) | 0, i = i + Math.imul(g, V) | 0, i = i + Math.imul(c, Q) | 0, n = n + Math.imul(c, V) | 0, f = f + Math.imul(m, X) | 0, i = i + Math.imul(m, Y) | 0, i = i + Math.imul(p, X) | 0, n = n + Math.imul(p, Y) | 0;
            var yt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, f = Math.imul(z, O), i = Math.imul(z, K), i = i + Math.imul(I, O) | 0, n = Math.imul(I, K), f = f + Math.imul(T, F) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(L, F) | 0, n = n + Math.imul(L, H) | 0, f = f + Math.imul(R, P) | 0, i = i + Math.imul(R, D) | 0, i = i + Math.imul(Z, P) | 0, n = n + Math.imul(Z, D) | 0, f = f + Math.imul(k, $) | 0, i = i + Math.imul(k, C) | 0, i = i + Math.imul(q, $) | 0, n = n + Math.imul(q, C) | 0, f = f + Math.imul(B, J) | 0, i = i + Math.imul(B, U) | 0, i = i + Math.imul(S, J) | 0, n = n + Math.imul(S, U) | 0, f = f + Math.imul(_, W) | 0, i = i + Math.imul(_, G) | 0, i = i + Math.imul(A, W) | 0, n = n + Math.imul(A, G) | 0, f = f + Math.imul(w, Q) | 0, i = i + Math.imul(w, V) | 0, i = i + Math.imul(y, Q) | 0, n = n + Math.imul(y, V) | 0, f = f + Math.imul(g, X) | 0, i = i + Math.imul(g, Y) | 0, i = i + Math.imul(c, X) | 0, n = n + Math.imul(c, Y) | 0, f = f + Math.imul(m, j) | 0, i = i + Math.imul(m, tt) | 0, i = i + Math.imul(p, j) | 0, n = n + Math.imul(p, tt) | 0;
            var xt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, f = Math.imul(N, O), i = Math.imul(N, K), i = i + Math.imul(E, O) | 0, n = Math.imul(E, K), f = f + Math.imul(z, F) | 0, i = i + Math.imul(z, H) | 0, i = i + Math.imul(I, F) | 0, n = n + Math.imul(I, H) | 0, f = f + Math.imul(T, P) | 0, i = i + Math.imul(T, D) | 0, i = i + Math.imul(L, P) | 0, n = n + Math.imul(L, D) | 0, f = f + Math.imul(R, $) | 0, i = i + Math.imul(R, C) | 0, i = i + Math.imul(Z, $) | 0, n = n + Math.imul(Z, C) | 0, f = f + Math.imul(k, J) | 0, i = i + Math.imul(k, U) | 0, i = i + Math.imul(q, J) | 0, n = n + Math.imul(q, U) | 0, f = f + Math.imul(B, W) | 0, i = i + Math.imul(B, G) | 0, i = i + Math.imul(S, W) | 0, n = n + Math.imul(S, G) | 0, f = f + Math.imul(_, Q) | 0, i = i + Math.imul(_, V) | 0, i = i + Math.imul(A, Q) | 0, n = n + Math.imul(A, V) | 0, f = f + Math.imul(w, X) | 0, i = i + Math.imul(w, Y) | 0, i = i + Math.imul(y, X) | 0, n = n + Math.imul(y, Y) | 0, f = f + Math.imul(g, j) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(c, j) | 0, n = n + Math.imul(c, tt) | 0, f = f + Math.imul(m, it) | 0, i = i + Math.imul(m, rt) | 0, i = i + Math.imul(p, it) | 0, n = n + Math.imul(p, rt) | 0;
            var bt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, f = Math.imul(N, F), i = Math.imul(N, H), i = i + Math.imul(E, F) | 0, n = Math.imul(E, H), f = f + Math.imul(z, P) | 0, i = i + Math.imul(z, D) | 0, i = i + Math.imul(I, P) | 0, n = n + Math.imul(I, D) | 0, f = f + Math.imul(T, $) | 0, i = i + Math.imul(T, C) | 0, i = i + Math.imul(L, $) | 0, n = n + Math.imul(L, C) | 0, f = f + Math.imul(R, J) | 0, i = i + Math.imul(R, U) | 0, i = i + Math.imul(Z, J) | 0, n = n + Math.imul(Z, U) | 0, f = f + Math.imul(k, W) | 0, i = i + Math.imul(k, G) | 0, i = i + Math.imul(q, W) | 0, n = n + Math.imul(q, G) | 0, f = f + Math.imul(B, Q) | 0, i = i + Math.imul(B, V) | 0, i = i + Math.imul(S, Q) | 0, n = n + Math.imul(S, V) | 0, f = f + Math.imul(_, X) | 0, i = i + Math.imul(_, Y) | 0, i = i + Math.imul(A, X) | 0, n = n + Math.imul(A, Y) | 0, f = f + Math.imul(w, j) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(y, j) | 0, n = n + Math.imul(y, tt) | 0, f = f + Math.imul(g, it) | 0, i = i + Math.imul(g, rt) | 0, i = i + Math.imul(c, it) | 0, n = n + Math.imul(c, rt) | 0;
            var _t = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, f = Math.imul(N, P), i = Math.imul(N, D), i = i + Math.imul(E, P) | 0, n = Math.imul(E, D), f = f + Math.imul(z, $) | 0, i = i + Math.imul(z, C) | 0, i = i + Math.imul(I, $) | 0, n = n + Math.imul(I, C) | 0, f = f + Math.imul(T, J) | 0, i = i + Math.imul(T, U) | 0, i = i + Math.imul(L, J) | 0, n = n + Math.imul(L, U) | 0, f = f + Math.imul(R, W) | 0, i = i + Math.imul(R, G) | 0, i = i + Math.imul(Z, W) | 0, n = n + Math.imul(Z, G) | 0, f = f + Math.imul(k, Q) | 0, i = i + Math.imul(k, V) | 0, i = i + Math.imul(q, Q) | 0, n = n + Math.imul(q, V) | 0, f = f + Math.imul(B, X) | 0, i = i + Math.imul(B, Y) | 0, i = i + Math.imul(S, X) | 0, n = n + Math.imul(S, Y) | 0, f = f + Math.imul(_, j) | 0, i = i + Math.imul(_, tt) | 0, i = i + Math.imul(A, j) | 0, n = n + Math.imul(A, tt) | 0, f = f + Math.imul(w, it) | 0, i = i + Math.imul(w, rt) | 0, i = i + Math.imul(y, it) | 0, n = n + Math.imul(y, rt) | 0;
            var At = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, f = Math.imul(N, $), i = Math.imul(N, C), i = i + Math.imul(E, $) | 0, n = Math.imul(E, C), f = f + Math.imul(z, J) | 0, i = i + Math.imul(z, U) | 0, i = i + Math.imul(I, J) | 0, n = n + Math.imul(I, U) | 0, f = f + Math.imul(T, W) | 0, i = i + Math.imul(T, G) | 0, i = i + Math.imul(L, W) | 0, n = n + Math.imul(L, G) | 0, f = f + Math.imul(R, Q) | 0, i = i + Math.imul(R, V) | 0, i = i + Math.imul(Z, Q) | 0, n = n + Math.imul(Z, V) | 0, f = f + Math.imul(k, X) | 0, i = i + Math.imul(k, Y) | 0, i = i + Math.imul(q, X) | 0, n = n + Math.imul(q, Y) | 0, f = f + Math.imul(B, j) | 0, i = i + Math.imul(B, tt) | 0, i = i + Math.imul(S, j) | 0, n = n + Math.imul(S, tt) | 0, f = f + Math.imul(_, it) | 0, i = i + Math.imul(_, rt) | 0, i = i + Math.imul(A, it) | 0, n = n + Math.imul(A, rt) | 0;
            var Bt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, f = Math.imul(N, J), i = Math.imul(N, U), i = i + Math.imul(E, J) | 0, n = Math.imul(E, U), f = f + Math.imul(z, W) | 0, i = i + Math.imul(z, G) | 0, i = i + Math.imul(I, W) | 0, n = n + Math.imul(I, G) | 0, f = f + Math.imul(T, Q) | 0, i = i + Math.imul(T, V) | 0, i = i + Math.imul(L, Q) | 0, n = n + Math.imul(L, V) | 0, f = f + Math.imul(R, X) | 0, i = i + Math.imul(R, Y) | 0, i = i + Math.imul(Z, X) | 0, n = n + Math.imul(Z, Y) | 0, f = f + Math.imul(k, j) | 0, i = i + Math.imul(k, tt) | 0, i = i + Math.imul(q, j) | 0, n = n + Math.imul(q, tt) | 0, f = f + Math.imul(B, it) | 0, i = i + Math.imul(B, rt) | 0, i = i + Math.imul(S, it) | 0, n = n + Math.imul(S, rt) | 0;
            var St = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, f = Math.imul(N, W), i = Math.imul(N, G), i = i + Math.imul(E, W) | 0, n = Math.imul(E, G), f = f + Math.imul(z, Q) | 0, i = i + Math.imul(z, V) | 0, i = i + Math.imul(I, Q) | 0, n = n + Math.imul(I, V) | 0, f = f + Math.imul(T, X) | 0, i = i + Math.imul(T, Y) | 0, i = i + Math.imul(L, X) | 0, n = n + Math.imul(L, Y) | 0, f = f + Math.imul(R, j) | 0, i = i + Math.imul(R, tt) | 0, i = i + Math.imul(Z, j) | 0, n = n + Math.imul(Z, tt) | 0, f = f + Math.imul(k, it) | 0, i = i + Math.imul(k, rt) | 0, i = i + Math.imul(q, it) | 0, n = n + Math.imul(q, rt) | 0;
            var kt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, f = Math.imul(N, Q), i = Math.imul(N, V), i = i + Math.imul(E, Q) | 0, n = Math.imul(E, V), f = f + Math.imul(z, X) | 0, i = i + Math.imul(z, Y) | 0, i = i + Math.imul(I, X) | 0, n = n + Math.imul(I, Y) | 0, f = f + Math.imul(T, j) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(L, j) | 0, n = n + Math.imul(L, tt) | 0, f = f + Math.imul(R, it) | 0, i = i + Math.imul(R, rt) | 0, i = i + Math.imul(Z, it) | 0, n = n + Math.imul(Z, rt) | 0;
            var qt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, f = Math.imul(N, X), i = Math.imul(N, Y), i = i + Math.imul(E, X) | 0, n = Math.imul(E, Y), f = f + Math.imul(z, j) | 0, i = i + Math.imul(z, tt) | 0, i = i + Math.imul(I, j) | 0, n = n + Math.imul(I, tt) | 0, f = f + Math.imul(T, it) | 0, i = i + Math.imul(T, rt) | 0, i = i + Math.imul(L, it) | 0, n = n + Math.imul(L, rt) | 0;
            var Rt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, f = Math.imul(N, j), i = Math.imul(N, tt), i = i + Math.imul(E, j) | 0, n = Math.imul(E, tt), f = f + Math.imul(z, it) | 0, i = i + Math.imul(z, rt) | 0, i = i + Math.imul(I, it) | 0, n = n + Math.imul(I, rt) | 0;
            var Zt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, f = Math.imul(N, it), i = Math.imul(N, rt), i = i + Math.imul(E, it) | 0, n = Math.imul(E, rt);
            var Tt = (u + f | 0) + ((i & 8191) << 13) | 0;
            return u = (n + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, a[0] = dt, a[1] = mt, a[2] = pt, a[3] = Mt, a[4] = gt, a[5] = ct, a[6] = wt, a[7] = yt, a[8] = xt, a[9] = bt, a[10] = _t, a[11] = At, a[12] = Bt, a[13] = St, a[14] = kt, a[15] = qt, a[16] = Rt, a[17] = Zt, a[18] = Tt, u !== 0 && (a[19] = u, e.length++), e;
        };
        Math.imul || (Ft = Kt);
        function mi(o, t, r) {
            r.negative = t.negative ^ o.negative, r.length = o.length + t.length;
            for(var e = 0, h = 0, s = 0; s < r.length - 1; s++){
                var a = h;
                h = 0;
                for(var u = e & 67108863, f = Math.min(s, t.length - 1), i = Math.max(0, s - o.length + 1); i <= f; i++){
                    var n = s - i, d = o.words[n] | 0, m = t.words[i] | 0, p = d * m, M = p & 67108863;
                    a = a + (p / 67108864 | 0) | 0, M = M + u | 0, u = M & 67108863, a = a + (M >>> 26) | 0, h += a >>> 26, a &= 67108863;
                }
                r.words[s] = u, e = a, a = h;
            }
            return e !== 0 ? r.words[s] = e : r.length--, r.strip();
        }
        function Ht(o, t, r) {
            var e = new ft;
            return e.mulp(o, t, r);
        }
        l.prototype.mulTo = function(t, r) {
            var e, h = this.length + t.length;
            return this.length === 10 && t.length === 10 ? e = Ft(this, t, r) : h < 63 ? e = Kt(this, t, r) : h < 1024 ? e = mi(this, t, r) : e = Ht(this, t, r), e;
        };
        function ft(o, t) {
            this.x = o, this.y = t;
        }
        ft.prototype.makeRBT = function(t) {
            for(var r = new Array(t), e = l.prototype._countBits(t) - 1, h = 0; h < t; h++)r[h] = this.revBin(h, e, t);
            return r;
        }, ft.prototype.revBin = function(t, r, e) {
            if (t === 0 || t === e - 1) return t;
            for(var h = 0, s = 0; s < r; s++)h |= (t & 1) << r - s - 1, t >>= 1;
            return h;
        }, ft.prototype.permute = function(t, r, e, h, s, a) {
            for(var u = 0; u < a; u++)h[u] = r[t[u]], s[u] = e[t[u]];
        }, ft.prototype.transform = function(t, r, e, h, s, a) {
            this.permute(a, t, r, e, h, s);
            for(var u = 1; u < s; u <<= 1)for(var f = u << 1, i = Math.cos(2 * Math.PI / f), n = Math.sin(2 * Math.PI / f), d = 0; d < s; d += f)for(var m = i, p = n, M = 0; M < u; M++){
                var g = e[d + M], c = h[d + M], st = e[d + M + u], w = h[d + M + u], y = m * st - p * w;
                w = m * w + p * st, st = y, e[d + M] = g + st, h[d + M] = c + w, e[d + M + u] = g - st, h[d + M + u] = c - w, M !== f && (y = i * m - n * p, p = i * p + n * m, m = y);
            }
        }, ft.prototype.guessLen13b = function(t, r) {
            var e = Math.max(r, t) | 1, h = e & 1, s = 0;
            for(e = e / 2 | 0; e; e = e >>> 1)s++;
            return 1 << s + 1 + h;
        }, ft.prototype.conjugate = function(t, r, e) {
            if (!(e <= 1)) for(var h = 0; h < e / 2; h++){
                var s = t[h];
                t[h] = t[e - h - 1], t[e - h - 1] = s, s = r[h], r[h] = -r[e - h - 1], r[e - h - 1] = -s;
            }
        }, ft.prototype.normalize13b = function(t, r) {
            for(var e = 0, h = 0; h < r / 2; h++){
                var s = Math.round(t[2 * h + 1] / r) * 8192 + Math.round(t[2 * h] / r) + e;
                t[h] = s & 67108863, s < 67108864 ? e = 0 : e = s / 67108864 | 0;
            }
            return t;
        }, ft.prototype.convert13b = function(t, r, e, h) {
            for(var s = 0, a = 0; a < r; a++)s = s + (t[a] | 0), e[2 * a] = s & 8191, s = s >>> 13, e[2 * a + 1] = s & 8191, s = s >>> 13;
            for(a = 2 * r; a < h; ++a)e[a] = 0;
            v(s === 0), v((s & -8192) === 0);
        }, ft.prototype.stub = function(t) {
            for(var r = new Array(t), e = 0; e < t; e++)r[e] = 0;
            return r;
        }, ft.prototype.mulp = function(t, r, e) {
            var h = 2 * this.guessLen13b(t.length, r.length), s = this.makeRBT(h), a = this.stub(h), u = new Array(h), f = new Array(h), i = new Array(h), n = new Array(h), d = new Array(h), m = new Array(h), p = e.words;
            p.length = h, this.convert13b(t.words, t.length, u, h), this.convert13b(r.words, r.length, n, h), this.transform(u, a, f, i, h, s), this.transform(n, a, d, m, h, s);
            for(var M = 0; M < h; M++){
                var g = f[M] * d[M] - i[M] * m[M];
                i[M] = f[M] * m[M] + i[M] * d[M], f[M] = g;
            }
            return this.conjugate(f, i, h), this.transform(f, i, p, a, h, s), this.conjugate(p, a, h), this.normalize13b(p, h), e.negative = t.negative ^ r.negative, e.length = t.length + r.length, e.strip();
        }, l.prototype.mul = function(t) {
            var r = new l(null);
            return r.words = new Array(this.length + t.length), this.mulTo(t, r);
        }, l.prototype.mulf = function(t) {
            var r = new l(null);
            return r.words = new Array(this.length + t.length), Ht(this, t, r);
        }, l.prototype.imul = function(t) {
            return this.clone().mulTo(t, this);
        }, l.prototype.imuln = function(t) {
            v(typeof t == "number"), v(t < 67108864);
            for(var r = 0, e = 0; e < this.length; e++){
                var h = (this.words[e] | 0) * t, s = (h & 67108863) + (r & 67108863);
                r >>= 26, r += h / 67108864 | 0, r += s >>> 26, this.words[e] = s & 67108863;
            }
            return r !== 0 && (this.words[e] = r, this.length++), this;
        }, l.prototype.muln = function(t) {
            return this.clone().imuln(t);
        }, l.prototype.sqr = function() {
            return this.mul(this);
        }, l.prototype.isqr = function() {
            return this.imul(this.clone());
        }, l.prototype.pow = function(t) {
            var r = di(t);
            if (r.length === 0) return new l(1);
            for(var e = this, h = 0; h < r.length && r[h] === 0; h++, e = e.sqr());
            if (++h < r.length) for(var s = e.sqr(); h < r.length; h++, s = s.sqr())r[h] !== 0 && (e = e.mul(s));
            return e;
        }, l.prototype.iushln = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26, h = 67108863 >>> 26 - r << 26 - r, s;
            if (r !== 0) {
                var a = 0;
                for(s = 0; s < this.length; s++){
                    var u = this.words[s] & h, f = (this.words[s] | 0) - u << r;
                    this.words[s] = f | a, a = u >>> 26 - r;
                }
                a && (this.words[s] = a, this.length++);
            }
            if (e !== 0) {
                for(s = this.length - 1; s >= 0; s--)this.words[s + e] = this.words[s];
                for(s = 0; s < e; s++)this.words[s] = 0;
                this.length += e;
            }
            return this.strip();
        }, l.prototype.ishln = function(t) {
            return v(this.negative === 0), this.iushln(t);
        }, l.prototype.iushrn = function(t, r, e) {
            v(typeof t == "number" && t >= 0);
            var h;
            r ? h = (r - r % 26) / 26 : h = 0;
            var s = t % 26, a = Math.min((t - s) / 26, this.length), u = 67108863 ^ 67108863 >>> s << s, f = e;
            if (h -= a, h = Math.max(0, h), f) {
                for(var i = 0; i < a; i++)f.words[i] = this.words[i];
                f.length = a;
            }
            if (a !== 0) if (this.length > a) for(this.length -= a, i = 0; i < this.length; i++)this.words[i] = this.words[i + a];
            else this.words[0] = 0, this.length = 1;
            var n = 0;
            for(i = this.length - 1; i >= 0 && (n !== 0 || i >= h); i--){
                var d = this.words[i] | 0;
                this.words[i] = n << 26 - s | d >>> s, n = d & u;
            }
            return f && n !== 0 && (f.words[f.length++] = n), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
        }, l.prototype.ishrn = function(t, r, e) {
            return v(this.negative === 0), this.iushrn(t, r, e);
        }, l.prototype.shln = function(t) {
            return this.clone().ishln(t);
        }, l.prototype.ushln = function(t) {
            return this.clone().iushln(t);
        }, l.prototype.shrn = function(t) {
            return this.clone().ishrn(t);
        }, l.prototype.ushrn = function(t) {
            return this.clone().iushrn(t);
        }, l.prototype.testn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26, h = 1 << r;
            if (this.length <= e) return !1;
            var s = this.words[e];
            return !!(s & h);
        }, l.prototype.imaskn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26;
            if (v(this.negative === 0, "imaskn works only with positive numbers"), this.length <= e) return this;
            if (r !== 0 && e++, this.length = Math.min(e, this.length), r !== 0) {
                var h = 67108863 ^ 67108863 >>> r << r;
                this.words[this.length - 1] &= h;
            }
            return this.strip();
        }, l.prototype.maskn = function(t) {
            return this.clone().imaskn(t);
        }, l.prototype.iaddn = function(t) {
            return v(typeof t == "number"), v(t < 67108864), t < 0 ? this.isubn(-t) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < t ? (this.words[0] = t - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t);
        }, l.prototype._iaddn = function(t) {
            this.words[0] += t;
            for(var r = 0; r < this.length && this.words[r] >= 67108864; r++)this.words[r] -= 67108864, r === this.length - 1 ? this.words[r + 1] = 1 : this.words[r + 1]++;
            return this.length = Math.max(this.length, r + 1), this;
        }, l.prototype.isubn = function(t) {
            if (v(typeof t == "number"), v(t < 67108864), t < 0) return this.iaddn(-t);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
            if (this.words[0] -= t, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else for(var r = 0; r < this.length && this.words[r] < 0; r++)this.words[r] += 67108864, this.words[r + 1] -= 1;
            return this.strip();
        }, l.prototype.addn = function(t) {
            return this.clone().iaddn(t);
        }, l.prototype.subn = function(t) {
            return this.clone().isubn(t);
        }, l.prototype.iabs = function() {
            return this.negative = 0, this;
        }, l.prototype.abs = function() {
            return this.clone().iabs();
        }, l.prototype._ishlnsubmul = function(t, r, e) {
            var h = t.length + e, s;
            this._expand(h);
            var a, u = 0;
            for(s = 0; s < t.length; s++){
                a = (this.words[s + e] | 0) + u;
                var f = (t.words[s] | 0) * r;
                a -= f & 67108863, u = (a >> 26) - (f / 67108864 | 0), this.words[s + e] = a & 67108863;
            }
            for(; s < this.length - e; s++)a = (this.words[s + e] | 0) + u, u = a >> 26, this.words[s + e] = a & 67108863;
            if (u === 0) return this.strip();
            for(v(u === -1), u = 0, s = 0; s < this.length; s++)a = -(this.words[s] | 0) + u, u = a >> 26, this.words[s] = a & 67108863;
            return this.negative = 1, this.strip();
        }, l.prototype._wordDiv = function(t, r) {
            var e = this.length - t.length, h = this.clone(), s = t, a = s.words[s.length - 1] | 0, u = this._countBits(a);
            e = 26 - u, e !== 0 && (s = s.ushln(e), h.iushln(e), a = s.words[s.length - 1] | 0);
            var f = h.length - s.length, i;
            if (r !== "mod") {
                i = new l(null), i.length = f + 1, i.words = new Array(i.length);
                for(var n = 0; n < i.length; n++)i.words[n] = 0;
            }
            var d = h.clone()._ishlnsubmul(s, 1, f);
            d.negative === 0 && (h = d, i && (i.words[f] = 1));
            for(var m = f - 1; m >= 0; m--){
                var p = (h.words[s.length + m] | 0) * 67108864 + (h.words[s.length + m - 1] | 0);
                for(p = Math.min(p / a | 0, 67108863), h._ishlnsubmul(s, p, m); h.negative !== 0;)p--, h.negative = 0, h._ishlnsubmul(s, 1, m), h.isZero() || (h.negative ^= 1);
                i && (i.words[m] = p);
            }
            return i && i.strip(), h.strip(), r !== "div" && e !== 0 && h.iushrn(e), {
                div: i || null,
                mod: h
            };
        }, l.prototype.divmod = function(t, r, e) {
            if (v(!t.isZero()), this.isZero()) return {
                div: new l(0),
                mod: new l(0)
            };
            var h, s, a;
            return this.negative !== 0 && t.negative === 0 ? (a = this.neg().divmod(t, r), r !== "mod" && (h = a.div.neg()), r !== "div" && (s = a.mod.neg(), e && s.negative !== 0 && s.iadd(t)), {
                div: h,
                mod: s
            }) : this.negative === 0 && t.negative !== 0 ? (a = this.divmod(t.neg(), r), r !== "mod" && (h = a.div.neg()), {
                div: h,
                mod: a.mod
            }) : (this.negative & t.negative) !== 0 ? (a = this.neg().divmod(t.neg(), r), r !== "div" && (s = a.mod.neg(), e && s.negative !== 0 && s.isub(t)), {
                div: a.div,
                mod: s
            }) : t.length > this.length || this.cmp(t) < 0 ? {
                div: new l(0),
                mod: this
            } : t.length === 1 ? r === "div" ? {
                div: this.divn(t.words[0]),
                mod: null
            } : r === "mod" ? {
                div: null,
                mod: new l(this.modn(t.words[0]))
            } : {
                div: this.divn(t.words[0]),
                mod: new l(this.modn(t.words[0]))
            } : this._wordDiv(t, r);
        }, l.prototype.div = function(t) {
            return this.divmod(t, "div", !1).div;
        }, l.prototype.mod = function(t) {
            return this.divmod(t, "mod", !1).mod;
        }, l.prototype.umod = function(t) {
            return this.divmod(t, "mod", !0).mod;
        }, l.prototype.divRound = function(t) {
            var r = this.divmod(t);
            if (r.mod.isZero()) return r.div;
            var e = r.div.negative !== 0 ? r.mod.isub(t) : r.mod, h = t.ushrn(1), s = t.andln(1), a = e.cmp(h);
            return a < 0 || s === 1 && a === 0 ? r.div : r.div.negative !== 0 ? r.div.isubn(1) : r.div.iaddn(1);
        }, l.prototype.modn = function(t) {
            v(t <= 67108863);
            for(var r = (1 << 26) % t, e = 0, h = this.length - 1; h >= 0; h--)e = (r * e + (this.words[h] | 0)) % t;
            return e;
        }, l.prototype.idivn = function(t) {
            v(t <= 67108863);
            for(var r = 0, e = this.length - 1; e >= 0; e--){
                var h = (this.words[e] | 0) + r * 67108864;
                this.words[e] = h / t | 0, r = h % t;
            }
            return this.strip();
        }, l.prototype.divn = function(t) {
            return this.clone().idivn(t);
        }, l.prototype.egcd = function(t) {
            v(t.negative === 0), v(!t.isZero());
            var r = this, e = t.clone();
            r.negative !== 0 ? r = r.umod(t) : r = r.clone();
            for(var h = new l(1), s = new l(0), a = new l(0), u = new l(1), f = 0; r.isEven() && e.isEven();)r.iushrn(1), e.iushrn(1), ++f;
            for(var i = e.clone(), n = r.clone(); !r.isZero();){
                for(var d = 0, m = 1; (r.words[0] & m) === 0 && d < 26; ++d, m <<= 1);
                if (d > 0) for(r.iushrn(d); d-- > 0;)(h.isOdd() || s.isOdd()) && (h.iadd(i), s.isub(n)), h.iushrn(1), s.iushrn(1);
                for(var p = 0, M = 1; (e.words[0] & M) === 0 && p < 26; ++p, M <<= 1);
                if (p > 0) for(e.iushrn(p); p-- > 0;)(a.isOdd() || u.isOdd()) && (a.iadd(i), u.isub(n)), a.iushrn(1), u.iushrn(1);
                r.cmp(e) >= 0 ? (r.isub(e), h.isub(a), s.isub(u)) : (e.isub(r), a.isub(h), u.isub(s));
            }
            return {
                a,
                b: u,
                gcd: e.iushln(f)
            };
        }, l.prototype._invmp = function(t) {
            v(t.negative === 0), v(!t.isZero());
            var r = this, e = t.clone();
            r.negative !== 0 ? r = r.umod(t) : r = r.clone();
            for(var h = new l(1), s = new l(0), a = e.clone(); r.cmpn(1) > 0 && e.cmpn(1) > 0;){
                for(var u = 0, f = 1; (r.words[0] & f) === 0 && u < 26; ++u, f <<= 1);
                if (u > 0) for(r.iushrn(u); u-- > 0;)h.isOdd() && h.iadd(a), h.iushrn(1);
                for(var i = 0, n = 1; (e.words[0] & n) === 0 && i < 26; ++i, n <<= 1);
                if (i > 0) for(e.iushrn(i); i-- > 0;)s.isOdd() && s.iadd(a), s.iushrn(1);
                r.cmp(e) >= 0 ? (r.isub(e), h.isub(s)) : (e.isub(r), s.isub(h));
            }
            var d;
            return r.cmpn(1) === 0 ? d = h : d = s, d.cmpn(0) < 0 && d.iadd(t), d;
        }, l.prototype.gcd = function(t) {
            if (this.isZero()) return t.abs();
            if (t.isZero()) return this.abs();
            var r = this.clone(), e = t.clone();
            r.negative = 0, e.negative = 0;
            for(var h = 0; r.isEven() && e.isEven(); h++)r.iushrn(1), e.iushrn(1);
            do {
                for(; r.isEven();)r.iushrn(1);
                for(; e.isEven();)e.iushrn(1);
                var s = r.cmp(e);
                if (s < 0) {
                    var a = r;
                    r = e, e = a;
                } else if (s === 0 || e.cmpn(1) === 0) break;
                r.isub(e);
            }while (!0)
            return e.iushln(h);
        }, l.prototype.invm = function(t) {
            return this.egcd(t).a.umod(t);
        }, l.prototype.isEven = function() {
            return (this.words[0] & 1) === 0;
        }, l.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1;
        }, l.prototype.andln = function(t) {
            return this.words[0] & t;
        }, l.prototype.bincn = function(t) {
            v(typeof t == "number");
            var r = t % 26, e = (t - r) / 26, h = 1 << r;
            if (this.length <= e) return this._expand(e + 1), this.words[e] |= h, this;
            for(var s = h, a = e; s !== 0 && a < this.length; a++){
                var u = this.words[a] | 0;
                u += s, s = u >>> 26, u &= 67108863, this.words[a] = u;
            }
            return s !== 0 && (this.words[a] = s, this.length++), this;
        }, l.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0;
        }, l.prototype.cmpn = function(t) {
            var r = t < 0;
            if (this.negative !== 0 && !r) return -1;
            if (this.negative === 0 && r) return 1;
            this.strip();
            var e;
            if (this.length > 1) e = 1;
            else {
                r && (t = -t), v(t <= 67108863, "Number is too big");
                var h = this.words[0] | 0;
                e = h === t ? 0 : h < t ? -1 : 1;
            }
            return this.negative !== 0 ? -e | 0 : e;
        }, l.prototype.cmp = function(t) {
            if (this.negative !== 0 && t.negative === 0) return -1;
            if (this.negative === 0 && t.negative !== 0) return 1;
            var r = this.ucmp(t);
            return this.negative !== 0 ? -r | 0 : r;
        }, l.prototype.ucmp = function(t) {
            if (this.length > t.length) return 1;
            if (this.length < t.length) return -1;
            for(var r = 0, e = this.length - 1; e >= 0; e--){
                var h = this.words[e] | 0, s = t.words[e] | 0;
                if (h !== s) {
                    h < s ? r = -1 : h > s && (r = 1);
                    break;
                }
            }
            return r;
        }, l.prototype.gtn = function(t) {
            return this.cmpn(t) === 1;
        }, l.prototype.gt = function(t) {
            return this.cmp(t) === 1;
        }, l.prototype.gten = function(t) {
            return this.cmpn(t) >= 0;
        }, l.prototype.gte = function(t) {
            return this.cmp(t) >= 0;
        }, l.prototype.ltn = function(t) {
            return this.cmpn(t) === -1;
        }, l.prototype.lt = function(t) {
            return this.cmp(t) === -1;
        }, l.prototype.lten = function(t) {
            return this.cmpn(t) <= 0;
        }, l.prototype.lte = function(t) {
            return this.cmp(t) <= 0;
        }, l.prototype.eqn = function(t) {
            return this.cmpn(t) === 0;
        }, l.prototype.eq = function(t) {
            return this.cmp(t) === 0;
        }, l.red = function(t) {
            return new x(t);
        }, l.prototype.toRed = function(t) {
            return v(!this.red, "Already a number in reduction context"), v(this.negative === 0, "red works only with positives"), t.convertTo(this)._forceRed(t);
        }, l.prototype.fromRed = function() {
            return v(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, l.prototype._forceRed = function(t) {
            return this.red = t, this;
        }, l.prototype.forceRed = function(t) {
            return v(!this.red, "Already a number in reduction context"), this._forceRed(t);
        }, l.prototype.redAdd = function(t) {
            return v(this.red, "redAdd works only with red numbers"), this.red.add(this, t);
        }, l.prototype.redIAdd = function(t) {
            return v(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t);
        }, l.prototype.redSub = function(t) {
            return v(this.red, "redSub works only with red numbers"), this.red.sub(this, t);
        }, l.prototype.redISub = function(t) {
            return v(this.red, "redISub works only with red numbers"), this.red.isub(this, t);
        }, l.prototype.redShl = function(t) {
            return v(this.red, "redShl works only with red numbers"), this.red.shl(this, t);
        }, l.prototype.redMul = function(t) {
            return v(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t);
        }, l.prototype.redIMul = function(t) {
            return v(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t);
        }, l.prototype.redSqr = function() {
            return v(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, l.prototype.redISqr = function() {
            return v(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, l.prototype.redSqrt = function() {
            return v(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, l.prototype.redInvm = function() {
            return v(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, l.prototype.redNeg = function() {
            return v(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, l.prototype.redPow = function(t) {
            return v(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t);
        };
        var ut = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function ht(o, t) {
            this.name = o, this.p = new l(t, 16), this.n = this.p.bitLength(), this.k = new l(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        ht.prototype._tmp = function() {
            var t = new l(null);
            return t.words = new Array(Math.ceil(this.n / 13)), t;
        }, ht.prototype.ireduce = function(t) {
            var r = t, e;
            do this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength();
            while (e > this.n)
            var h = e < this.n ? -1 : r.ucmp(this.p);
            return h === 0 ? (r.words[0] = 0, r.length = 1) : h > 0 ? r.isub(this.p) : r.strip !== void 0 ? r.strip() : r._strip(), r;
        }, ht.prototype.split = function(t, r) {
            t.iushrn(this.n, 0, r);
        }, ht.prototype.imulK = function(t) {
            return t.imul(this.k);
        };
        function lt() {
            ht.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        nt(lt, ht), lt.prototype.split = function(t, r) {
            for(var e = 4194303, h = Math.min(t.length, 9), s = 0; s < h; s++)r.words[s] = t.words[s];
            if (r.length = h, t.length <= 9) {
                t.words[0] = 0, t.length = 1;
                return;
            }
            var a = t.words[9];
            for(r.words[r.length++] = a & e, s = 10; s < t.length; s++){
                var u = t.words[s] | 0;
                t.words[s - 10] = (u & e) << 4 | a >>> 22, a = u;
            }
            a >>>= 22, t.words[s - 10] = a, a === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9;
        }, lt.prototype.imulK = function(t) {
            t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
            for(var r = 0, e = 0; e < t.length; e++){
                var h = t.words[e] | 0;
                r += h * 977, t.words[e] = r & 67108863, r = h * 64 + (r / 67108864 | 0);
            }
            return t.words[t.length - 1] === 0 && (t.length--, t.words[t.length - 1] === 0 && t.length--), t;
        };
        function Pt() {
            ht.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        nt(Pt, ht);
        function Dt() {
            ht.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        nt(Dt, ht);
        function vt() {
            ht.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        nt(vt, ht), vt.prototype.imulK = function(t) {
            for(var r = 0, e = 0; e < t.length; e++){
                var h = (t.words[e] | 0) * 19 + r, s = h & 67108863;
                h >>>= 26, t.words[e] = s, r = h;
            }
            return r !== 0 && (t.words[t.length++] = r), t;
        }, l._prime = function(t) {
            if (ut[t]) return ut[t];
            var r;
            if (t === "k256") r = new lt;
            else if (t === "p224") r = new Pt;
            else if (t === "p192") r = new Dt;
            else if (t === "p25519") r = new vt;
            else throw new Error("Unknown prime " + t);
            return ut[t] = r, r;
        };
        function x(o) {
            if (typeof o == "string") {
                var t = l._prime(o);
                this.m = t.p, this.prime = t;
            } else v(o.gtn(1), "modulus must be greater than 1"), this.m = o, this.prime = null;
        }
        x.prototype._verify1 = function(t) {
            v(t.negative === 0, "red works only with positives"), v(t.red, "red works only with red numbers");
        }, x.prototype._verify2 = function(t, r) {
            v((t.negative | r.negative) === 0, "red works only with positives"), v(t.red && t.red === r.red, "red works only with red numbers");
        }, x.prototype.imod = function(t) {
            return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this);
        }, x.prototype.neg = function(t) {
            return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
        }, x.prototype.add = function(t, r) {
            this._verify2(t, r);
            var e = t.add(r);
            return e.cmp(this.m) >= 0 && e.isub(this.m), e._forceRed(this);
        }, x.prototype.iadd = function(t, r) {
            this._verify2(t, r);
            var e = t.iadd(r);
            return e.cmp(this.m) >= 0 && e.isub(this.m), e;
        }, x.prototype.sub = function(t, r) {
            this._verify2(t, r);
            var e = t.sub(r);
            return e.cmpn(0) < 0 && e.iadd(this.m), e._forceRed(this);
        }, x.prototype.isub = function(t, r) {
            this._verify2(t, r);
            var e = t.isub(r);
            return e.cmpn(0) < 0 && e.iadd(this.m), e;
        }, x.prototype.shl = function(t, r) {
            return this._verify1(t), this.imod(t.ushln(r));
        }, x.prototype.imul = function(t, r) {
            return this._verify2(t, r), this.imod(t.imul(r));
        }, x.prototype.mul = function(t, r) {
            return this._verify2(t, r), this.imod(t.mul(r));
        }, x.prototype.isqr = function(t) {
            return this.imul(t, t.clone());
        }, x.prototype.sqr = function(t) {
            return this.mul(t, t);
        }, x.prototype.sqrt = function(t) {
            if (t.isZero()) return t.clone();
            var r = this.m.andln(3);
            if (v(r % 2 === 1), r === 3) {
                var e = this.m.add(new l(1)).iushrn(2);
                return this.pow(t, e);
            }
            for(var h = this.m.subn(1), s = 0; !h.isZero() && h.andln(1) === 0;)s++, h.iushrn(1);
            v(!h.isZero());
            var a = new l(1).toRed(this), u = a.redNeg(), f = this.m.subn(1).iushrn(1), i = this.m.bitLength();
            for(i = new l(2 * i * i).toRed(this); this.pow(i, f).cmp(u) !== 0;)i.redIAdd(u);
            for(var n = this.pow(i, h), d = this.pow(t, h.addn(1).iushrn(1)), m = this.pow(t, h), p = s; m.cmp(a) !== 0;){
                for(var M = m, g = 0; M.cmp(a) !== 0; g++)M = M.redSqr();
                v(g < p);
                var c = this.pow(n, new l(1).iushln(p - g - 1));
                d = d.redMul(c), n = c.redSqr(), m = m.redMul(n), p = g;
            }
            return d;
        }, x.prototype.invm = function(t) {
            var r = t._invmp(this.m);
            return r.negative !== 0 ? (r.negative = 0, this.imod(r).redNeg()) : this.imod(r);
        }, x.prototype.pow = function(t, r) {
            if (r.isZero()) return new l(1).toRed(this);
            if (r.cmpn(1) === 0) return t.clone();
            var e = 4, h = new Array(1 << e);
            h[0] = new l(1).toRed(this), h[1] = t;
            for(var s = 2; s < h.length; s++)h[s] = this.mul(h[s - 1], t);
            var a = h[0], u = 0, f = 0, i = r.bitLength() % 26;
            for(i === 0 && (i = 26), s = r.length - 1; s >= 0; s--){
                for(var n = r.words[s], d = i - 1; d >= 0; d--){
                    var m = n >> d & 1;
                    if (a !== h[0] && (a = this.sqr(a)), m === 0 && u === 0) {
                        f = 0;
                        continue;
                    }
                    u <<= 1, u |= m, f++, !(f !== e && (s !== 0 || d !== 0)) && (a = this.mul(a, h[u]), f = 0, u = 0);
                }
                i = 26;
            }
            return a;
        }, x.prototype.convertTo = function(t) {
            var r = t.umod(this.m);
            return r === t ? r.clone() : r;
        }, x.prototype.convertFrom = function(t) {
            var r = t.clone();
            return r.red = null, r;
        }, l.mont = function(t) {
            return new ot(t);
        };
        function ot(o) {
            x.call(this, o), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new l(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        nt(ot, x), ot.prototype.convertTo = function(t) {
            return this.imod(t.ushln(this.shift));
        }, ot.prototype.convertFrom = function(t) {
            var r = this.imod(t.mul(this.rinv));
            return r.red = null, r;
        }, ot.prototype.imul = function(t, r) {
            if (t.isZero() || r.isZero()) return t.words[0] = 0, t.length = 1, t;
            var e = t.imul(r), h = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s = e.isub(h).iushrn(this.shift), a = s;
            return s.cmp(this.m) >= 0 ? a = s.isub(this.m) : s.cmpn(0) < 0 && (a = s.iadd(this.m)), a._forceRed(this);
        }, ot.prototype.mul = function(t, r) {
            if (t.isZero() || r.isZero()) return new l(0)._forceRed(this);
            var e = t.mul(r), h = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s = e.isub(h).iushrn(this.shift), a = s;
            return s.cmp(this.m) >= 0 ? a = s.isub(this.m) : s.cmpn(0) < 0 && (a = s.iadd(this.m)), a._forceRed(this);
        }, ot.prototype.invm = function(t) {
            var r = this.imod(t._invmp(this.m).mul(this.r2));
            return r._forceRed(this);
        };
    })(typeof Lt > "u" || Lt, oi);
});
var ai = si(zt()), li = si(zt()), { BN: Si  } = li, { default: _i , ...Ai } = li, ki = (ai.default ?? _i) ?? Ai;
var l = Object.create;
var p = Object.defineProperty;
var c = Object.getOwnPropertyDescriptor;
var s = Object.getOwnPropertyNames;
var y = Object.getPrototypeOf, b = Object.prototype.hasOwnProperty;
var d = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var m = (t, e, o, f)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of s(e))!b.call(t, n) && n !== o && p(t, n, {
        get: ()=>e[n],
        enumerable: !(f = c(e, n)) || f.enumerable
    });
    return t;
};
var u = (t, e, o)=>(o = t != null ? l(y(t)) : {}, m(e || !t || !t.__esModule ? p(o, "default", {
        value: t,
        enumerable: !0
    }) : o, t));
var i1 = d((v, r)=>{
    typeof Object.create == "function" ? r.exports = function(e, o) {
        o && (e.super_ = o, e.prototype = Object.create(o.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    } : r.exports = function(e, o) {
        if (o) {
            e.super_ = o;
            var f = function() {};
            f.prototype = o.prototype, e.prototype = new f, e.prototype.constructor = e;
        }
    };
});
var a = u(i1()), $ = u(i1()), { default: x , ...h } = $, w = (a.default ?? x) ?? h;
var m1 = Object.create;
var a1 = Object.defineProperty;
var p1 = Object.getOwnPropertyDescriptor;
var c1 = Object.getOwnPropertyNames;
var w1 = Object.getPrototypeOf, $1 = Object.prototype.hasOwnProperty;
var q = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var x1 = (r, e, t, s)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of c1(e))!$1.call(r, o) && o !== t && a1(r, o, {
        get: ()=>e[o],
        enumerable: !(s = p1(e, o)) || s.enumerable
    });
    return r;
};
var i2 = (r, e, t)=>(t = r != null ? m1(w1(r)) : {}, x1(e || !r || !r.__esModule ? a1(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r));
var f = q((b, u)=>{
    u.exports = n;
    function n(r, e) {
        if (!r) throw new Error(e || "Assertion failed");
    }
    n.equal = function(e, t, s) {
        if (e != t) throw new Error(s || "Assertion failed: " + e + " != " + t);
    };
});
var l1 = i2(f()), d1 = i2(f()), { equal: g  } = d1, { default: E , ...h1 } = d1, j = (l1.default ?? E) ?? h1;
var er = Object.create;
var g0 = Object.defineProperty;
var tr = Object.getOwnPropertyDescriptor;
var ar = Object.getOwnPropertyNames;
var hr = Object.getPrototypeOf, ir = Object.prototype.hasOwnProperty;
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, a)=>(typeof require != "undefined" ? require : e)[a]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var p2 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var nr = (r, e, a, h)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of ar(e))!ir.call(r, t) && t !== a && g0(r, t, {
        get: ()=>e[t],
        enumerable: !(h = tr(e, t)) || h.enumerable
    });
    return r;
};
var S0 = (r, e, a)=>(a = r != null ? er(hr(r)) : {}, nr(e || !r || !r.__esModule ? g0(a, "default", {
        value: r,
        enumerable: !0
    }) : a, r));
var g1 = p2((o)=>{
    "use strict";
    var sr = j, fr = w;
    o.inherits = fr;
    function ur(r, e) {
        return (r.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= r.length ? !1 : (r.charCodeAt(e + 1) & 64512) === 56320;
    }
    function cr(r, e) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var a = [];
        if (typeof r == "string") if (e) {
            if (e === "hex") for(r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 !== 0 && (r = "0" + r), t = 0; t < r.length; t += 2)a.push(parseInt(r[t] + r[t + 1], 16));
        } else for(var h = 0, t = 0; t < r.length; t++){
            var i = r.charCodeAt(t);
            i < 128 ? a[h++] = i : i < 2048 ? (a[h++] = i >> 6 | 192, a[h++] = i & 63 | 128) : ur(r, t) ? (i = 65536 + ((i & 1023) << 10) + (r.charCodeAt(++t) & 1023), a[h++] = i >> 18 | 240, a[h++] = i >> 12 & 63 | 128, a[h++] = i >> 6 & 63 | 128, a[h++] = i & 63 | 128) : (a[h++] = i >> 12 | 224, a[h++] = i >> 6 & 63 | 128, a[h++] = i & 63 | 128);
        }
        else for(t = 0; t < r.length; t++)a[t] = r[t] | 0;
        return a;
    }
    o.toArray = cr;
    function xr(r) {
        for(var e = "", a = 0; a < r.length; a++)e += q0(r[a].toString(16));
        return e;
    }
    o.toHex = xr;
    function m0(r) {
        var e = r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (r & 255) << 24;
        return e >>> 0;
    }
    o.htonl = m0;
    function or(r, e) {
        for(var a = "", h = 0; h < r.length; h++){
            var t = r[h];
            e === "little" && (t = m0(t)), a += H0(t.toString(16));
        }
        return a;
    }
    o.toHex32 = or;
    function q0(r) {
        return r.length === 1 ? "0" + r : r;
    }
    o.zero2 = q0;
    function H0(r) {
        return r.length === 7 ? "0" + r : r.length === 6 ? "00" + r : r.length === 5 ? "000" + r : r.length === 4 ? "0000" + r : r.length === 3 ? "00000" + r : r.length === 2 ? "000000" + r : r.length === 1 ? "0000000" + r : r;
    }
    o.zero8 = H0;
    function vr(r, e, a, h) {
        var t = a - e;
        sr(t % 4 === 0);
        for(var i = new Array(t / 4), n = 0, s = e; n < i.length; n++, s += 4){
            var u;
            h === "big" ? u = r[s] << 24 | r[s + 1] << 16 | r[s + 2] << 8 | r[s + 3] : u = r[s + 3] << 24 | r[s + 2] << 16 | r[s + 1] << 8 | r[s], i[n] = u >>> 0;
        }
        return i;
    }
    o.join32 = vr;
    function dr(r, e) {
        for(var a = new Array(r.length * 4), h = 0, t = 0; h < r.length; h++, t += 4){
            var i = r[h];
            e === "big" ? (a[t] = i >>> 24, a[t + 1] = i >>> 16 & 255, a[t + 2] = i >>> 8 & 255, a[t + 3] = i & 255) : (a[t + 3] = i >>> 24, a[t + 2] = i >>> 16 & 255, a[t + 1] = i >>> 8 & 255, a[t] = i & 255);
        }
        return a;
    }
    o.split32 = dr;
    function br(r, e) {
        return r >>> e | r << 32 - e;
    }
    o.rotr32 = br;
    function lr(r, e) {
        return r << e | r >>> 32 - e;
    }
    o.rotl32 = lr;
    function _r(r, e) {
        return r + e >>> 0;
    }
    o.sum32 = _r;
    function pr(r, e, a) {
        return r + e + a >>> 0;
    }
    o.sum32_3 = pr;
    function gr(r, e, a, h) {
        return r + e + a + h >>> 0;
    }
    o.sum32_4 = gr;
    function Sr(r, e, a, h, t) {
        return r + e + a + h + t >>> 0;
    }
    o.sum32_5 = Sr;
    function mr(r, e, a, h) {
        var t = r[e], i = r[e + 1], n = h + i >>> 0, s = (n < h ? 1 : 0) + a + t;
        r[e] = s >>> 0, r[e + 1] = n;
    }
    o.sum64 = mr;
    function qr(r, e, a, h) {
        var t = e + h >>> 0, i = (t < e ? 1 : 0) + r + a;
        return i >>> 0;
    }
    o.sum64_hi = qr;
    function Hr(r, e, a, h) {
        var t = e + h;
        return t >>> 0;
    }
    o.sum64_lo = Hr;
    function Ar(r, e, a, h, t, i, n, s) {
        var u = 0, f = e;
        f = f + h >>> 0, u += f < e ? 1 : 0, f = f + i >>> 0, u += f < i ? 1 : 0, f = f + s >>> 0, u += f < s ? 1 : 0;
        var x = r + a + t + n + u;
        return x >>> 0;
    }
    o.sum64_4_hi = Ar;
    function zr(r, e, a, h, t, i, n, s) {
        var u = e + h + i + s;
        return u >>> 0;
    }
    o.sum64_4_lo = zr;
    function Br(r, e, a, h, t, i, n, s, u, f) {
        var x = 0, c = e;
        c = c + h >>> 0, x += c < e ? 1 : 0, c = c + i >>> 0, x += c < i ? 1 : 0, c = c + s >>> 0, x += c < s ? 1 : 0, c = c + f >>> 0, x += c < f ? 1 : 0;
        var v = r + a + t + n + u + x;
        return v >>> 0;
    }
    o.sum64_5_hi = Br;
    function yr(r, e, a, h, t, i, n, s, u, f) {
        var x = e + h + i + s + f;
        return x >>> 0;
    }
    o.sum64_5_lo = yr;
    function Cr(r, e, a) {
        var h = e << 32 - a | r >>> a;
        return h >>> 0;
    }
    o.rotr64_hi = Cr;
    function Lr(r, e, a) {
        var h = r << 32 - a | e >>> a;
        return h >>> 0;
    }
    o.rotr64_lo = Lr;
    function Wr(r, e, a) {
        return r >>> a;
    }
    o.shr64_hi = Wr;
    function kr(r, e, a) {
        var h = r << 32 - a | e >>> a;
        return h >>> 0;
    }
    o.shr64_lo = kr;
});
var K1 = p2((z0)=>{
    "use strict";
    var A0 = g1(), Dr = j;
    function w() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    z0.BlockHash = w;
    w.prototype.update = function(e, a) {
        if (e = A0.toArray(e, a), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
            e = this.pending;
            var h = e.length % this._delta8;
            this.pending = e.slice(e.length - h, e.length), this.pending.length === 0 && (this.pending = null), e = A0.join32(e, 0, e.length - h, this.endian);
            for(var t = 0; t < e.length; t += this._delta32)this._update(e, t, t + this._delta32);
        }
        return this;
    };
    w.prototype.digest = function(e) {
        return this.update(this._pad()), Dr(this.pending === null), this._digest(e);
    };
    w.prototype._pad = function() {
        var e = this.pendingTotal, a = this._delta8, h = a - (e + this.padLength) % a, t = new Array(h + this.padLength);
        t[0] = 128;
        for(var i = 1; i < h; i++)t[i] = 0;
        if (e <<= 3, this.endian === "big") {
            for(var n = 8; n < this.padLength; n++)t[i++] = 0;
            t[i++] = 0, t[i++] = 0, t[i++] = 0, t[i++] = 0, t[i++] = e >>> 24 & 255, t[i++] = e >>> 16 & 255, t[i++] = e >>> 8 & 255, t[i++] = e & 255;
        } else for(t[i++] = e & 255, t[i++] = e >>> 8 & 255, t[i++] = e >>> 16 & 255, t[i++] = e >>> 24 & 255, t[i++] = 0, t[i++] = 0, t[i++] = 0, t[i++] = 0, n = 8; n < this.padLength; n++)t[i++] = 0;
        return t;
    };
});
var t0 = p2((C)=>{
    "use strict";
    var Fr = g1(), q = Fr.rotr32;
    function Er(r, e, a, h) {
        if (r === 0) return B0(e, a, h);
        if (r === 1 || r === 3) return C0(e, a, h);
        if (r === 2) return y0(e, a, h);
    }
    C.ft_1 = Er;
    function B0(r, e, a) {
        return r & e ^ ~r & a;
    }
    C.ch32 = B0;
    function y0(r, e, a) {
        return r & e ^ r & a ^ e & a;
    }
    C.maj32 = y0;
    function C0(r, e, a) {
        return r ^ e ^ a;
    }
    C.p32 = C0;
    function Kr(r) {
        return q(r, 2) ^ q(r, 13) ^ q(r, 22);
    }
    C.s0_256 = Kr;
    function $r(r) {
        return q(r, 6) ^ q(r, 11) ^ q(r, 25);
    }
    C.s1_256 = $r;
    function Ir(r) {
        return q(r, 7) ^ q(r, 18) ^ r >>> 3;
    }
    C.g0_256 = Ir;
    function Pr(r) {
        return q(r, 17) ^ q(r, 19) ^ r >>> 10;
    }
    C.g1_256 = Pr;
});
var k0 = p2(($e, W0)=>{
    "use strict";
    var $ = g1(), Mr = K1(), Rr = t0(), a0 = $.rotl32, X = $.sum32, Gr = $.sum32_5, Jr = Rr.ft_1, L0 = Mr.BlockHash, Nr = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    function H() {
        if (!(this instanceof H)) return new H;
        L0.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.W = new Array(80);
    }
    $.inherits(H, L0);
    W0.exports = H;
    H.blockSize = 512;
    H.outSize = 160;
    H.hmacStrength = 80;
    H.padLength = 64;
    H.prototype._update = function(e, a) {
        for(var h = this.W, t = 0; t < 16; t++)h[t] = e[a + t];
        for(; t < h.length; t++)h[t] = a0(h[t - 3] ^ h[t - 8] ^ h[t - 14] ^ h[t - 16], 1);
        var i = this.h[0], n = this.h[1], s = this.h[2], u = this.h[3], f = this.h[4];
        for(t = 0; t < h.length; t++){
            var x = ~~(t / 20), c = Gr(a0(i, 5), Jr(x, n, s, u), f, h[t], Nr[x]);
            f = u, u = s, s = a0(n, 30), n = i, i = c;
        }
        this.h[0] = X(this.h[0], i), this.h[1] = X(this.h[1], n), this.h[2] = X(this.h[2], s), this.h[3] = X(this.h[3], u), this.h[4] = X(this.h[4], f);
    };
    H.prototype._digest = function(e) {
        return e === "hex" ? $.toHex32(this.h, "big") : $.split32(this.h, "big");
    };
});
var h0 = p2((Ie, F0)=>{
    "use strict";
    var I = g1(), Or = K1(), P = t0(), Qr = j, S = I.sum32, Ur = I.sum32_4, Vr = I.sum32_5, Xr = P.ch32, Yr = P.maj32, Zr = P.s0_256, jr = P.s1_256, wr = P.g0_256, Tr = P.g1_256, D0 = Or.BlockHash, re = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ];
    function A() {
        if (!(this instanceof A)) return new A;
        D0.call(this), this.h = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
        ], this.k = re, this.W = new Array(64);
    }
    I.inherits(A, D0);
    F0.exports = A;
    A.blockSize = 512;
    A.outSize = 256;
    A.hmacStrength = 192;
    A.padLength = 64;
    A.prototype._update = function(e, a) {
        for(var h = this.W, t = 0; t < 16; t++)h[t] = e[a + t];
        for(; t < h.length; t++)h[t] = Ur(Tr(h[t - 2]), h[t - 7], wr(h[t - 15]), h[t - 16]);
        var i = this.h[0], n = this.h[1], s = this.h[2], u = this.h[3], f = this.h[4], x = this.h[5], c = this.h[6], v = this.h[7];
        for(Qr(this.k.length === h.length), t = 0; t < h.length; t++){
            var d = Vr(v, jr(f), Xr(f, x, c), this.k[t], h[t]), _ = S(Zr(i), Yr(i, n, s));
            v = c, c = x, x = f, f = S(u, d), u = s, s = n, n = i, i = S(d, _);
        }
        this.h[0] = S(this.h[0], i), this.h[1] = S(this.h[1], n), this.h[2] = S(this.h[2], s), this.h[3] = S(this.h[3], u), this.h[4] = S(this.h[4], f), this.h[5] = S(this.h[5], x), this.h[6] = S(this.h[6], c), this.h[7] = S(this.h[7], v);
    };
    A.prototype._digest = function(e) {
        return e === "hex" ? I.toHex32(this.h, "big") : I.split32(this.h, "big");
    };
});
var $0 = p2((Pe, K0)=>{
    "use strict";
    var i0 = g1(), E0 = h0();
    function L() {
        if (!(this instanceof L)) return new L;
        E0.call(this), this.h = [
            3238371032,
            914150663,
            812702999,
            4144912697,
            4290775857,
            1750603025,
            1694076839,
            3204075428
        ];
    }
    i0.inherits(L, E0);
    K0.exports = L;
    L.blockSize = 512;
    L.outSize = 224;
    L.hmacStrength = 192;
    L.padLength = 64;
    L.prototype._digest = function(e) {
        return e === "hex" ? i0.toHex32(this.h.slice(0, 7), "big") : i0.split32(this.h.slice(0, 7), "big");
    };
});
var f0 = p2((Me, R0)=>{
    "use strict";
    var l = g1(), ee = K1(), te = j, z = l.rotr64_hi, B = l.rotr64_lo, I0 = l.shr64_hi, P0 = l.shr64_lo, k = l.sum64, n0 = l.sum64_hi, s0 = l.sum64_lo, ae = l.sum64_4_hi, he = l.sum64_4_lo, ie = l.sum64_5_hi, ne = l.sum64_5_lo, M0 = ee.BlockHash, se = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ];
    function m() {
        if (!(this instanceof m)) return new m;
        M0.call(this), this.h = [
            1779033703,
            4089235720,
            3144134277,
            2227873595,
            1013904242,
            4271175723,
            2773480762,
            1595750129,
            1359893119,
            2917565137,
            2600822924,
            725511199,
            528734635,
            4215389547,
            1541459225,
            327033209
        ], this.k = se, this.W = new Array(160);
    }
    l.inherits(m, M0);
    R0.exports = m;
    m.blockSize = 1024;
    m.outSize = 512;
    m.hmacStrength = 192;
    m.padLength = 128;
    m.prototype._prepareBlock = function(e, a) {
        for(var h = this.W, t = 0; t < 32; t++)h[t] = e[a + t];
        for(; t < h.length; t += 2){
            var i = pe(h[t - 4], h[t - 3]), n = ge(h[t - 4], h[t - 3]), s = h[t - 14], u = h[t - 13], f = le(h[t - 30], h[t - 29]), x = _e(h[t - 30], h[t - 29]), c = h[t - 32], v = h[t - 31];
            h[t] = ae(i, n, s, u, f, x, c, v), h[t + 1] = he(i, n, s, u, f, x, c, v);
        }
    };
    m.prototype._update = function(e, a) {
        this._prepareBlock(e, a);
        var h = this.W, t = this.h[0], i = this.h[1], n = this.h[2], s = this.h[3], u = this.h[4], f = this.h[5], x = this.h[6], c = this.h[7], v = this.h[8], d = this.h[9], _ = this.h[10], G = this.h[11], J = this.h[12], N = this.h[13], r0 = this.h[14], e0 = this.h[15];
        te(this.k.length === h.length);
        for(var F = 0; F < h.length; F += 2){
            var O = r0, Q = e0, U = de(v, d), V = be(v, d), x0 = fe(v, d, _, G, J, N), o0 = ue(v, d, _, G, J, N), v0 = this.k[F], d0 = this.k[F + 1], b0 = h[F], l0 = h[F + 1], Z = ie(O, Q, U, V, x0, o0, v0, d0, b0, l0), j = ne(O, Q, U, V, x0, o0, v0, d0, b0, l0);
            O = oe(t, i), Q = ve(t, i), U = ce(t, i, n, s, u, f), V = xe(t, i, n, s, u, f);
            var _0 = n0(O, Q, U, V), p0 = s0(O, Q, U, V);
            r0 = J, e0 = N, J = _, N = G, _ = v, G = d, v = n0(x, c, Z, j), d = s0(c, c, Z, j), x = u, c = f, u = n, f = s, n = t, s = i, t = n0(Z, j, _0, p0), i = s0(Z, j, _0, p0);
        }
        k(this.h, 0, t, i), k(this.h, 2, n, s), k(this.h, 4, u, f), k(this.h, 6, x, c), k(this.h, 8, v, d), k(this.h, 10, _, G), k(this.h, 12, J, N), k(this.h, 14, r0, e0);
    };
    m.prototype._digest = function(e) {
        return e === "hex" ? l.toHex32(this.h, "big") : l.split32(this.h, "big");
    };
    function fe(r, e, a, h, t) {
        var i = r & a ^ ~r & t;
        return i < 0 && (i += 4294967296), i;
    }
    function ue(r, e, a, h, t, i) {
        var n = e & h ^ ~e & i;
        return n < 0 && (n += 4294967296), n;
    }
    function ce(r, e, a, h, t) {
        var i = r & a ^ r & t ^ a & t;
        return i < 0 && (i += 4294967296), i;
    }
    function xe(r, e, a, h, t, i) {
        var n = e & h ^ e & i ^ h & i;
        return n < 0 && (n += 4294967296), n;
    }
    function oe(r, e) {
        var a = z(r, e, 28), h = z(e, r, 2), t = z(e, r, 7), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function ve(r, e) {
        var a = B(r, e, 28), h = B(e, r, 2), t = B(e, r, 7), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function de(r, e) {
        var a = z(r, e, 14), h = z(r, e, 18), t = z(e, r, 9), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function be(r, e) {
        var a = B(r, e, 14), h = B(r, e, 18), t = B(e, r, 9), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function le(r, e) {
        var a = z(r, e, 1), h = z(r, e, 8), t = I0(r, e, 7), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function _e(r, e) {
        var a = B(r, e, 1), h = B(r, e, 8), t = P0(r, e, 7), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function pe(r, e) {
        var a = z(r, e, 19), h = z(e, r, 29), t = I0(r, e, 6), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
    function ge(r, e) {
        var a = B(r, e, 19), h = B(e, r, 29), t = P0(r, e, 6), i = a ^ h ^ t;
        return i < 0 && (i += 4294967296), i;
    }
});
var N0 = p2((Re, J0)=>{
    "use strict";
    var u0 = g1(), G0 = f0();
    function W() {
        if (!(this instanceof W)) return new W;
        G0.call(this), this.h = [
            3418070365,
            3238371032,
            1654270250,
            914150663,
            2438529370,
            812702999,
            355462360,
            4144912697,
            1731405415,
            4290775857,
            2394180231,
            1750603025,
            3675008525,
            1694076839,
            1203062813,
            3204075428
        ];
    }
    u0.inherits(W, G0);
    J0.exports = W;
    W.blockSize = 1024;
    W.outSize = 384;
    W.hmacStrength = 192;
    W.padLength = 128;
    W.prototype._digest = function(e) {
        return e === "hex" ? u0.toHex32(this.h.slice(0, 12), "big") : u0.split32(this.h.slice(0, 12), "big");
    };
});
var O0 = p2((M)=>{
    "use strict";
    M.sha1 = k0();
    M.sha224 = $0();
    M.sha256 = h0();
    M.sha384 = N0();
    M.sha512 = f0();
});
var Z0 = p2((Y0)=>{
    "use strict";
    var D = g1(), Se = K1(), T = D.rotl32, Q0 = D.sum32, Y = D.sum32_3, U0 = D.sum32_4, X0 = Se.BlockHash;
    function y() {
        if (!(this instanceof y)) return new y;
        X0.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.endian = "little";
    }
    D.inherits(y, X0);
    Y0.ripemd160 = y;
    y.blockSize = 512;
    y.outSize = 160;
    y.hmacStrength = 192;
    y.padLength = 64;
    y.prototype._update = function(e, a) {
        for(var h = this.h[0], t = this.h[1], i = this.h[2], n = this.h[3], s = this.h[4], u = h, f = t, x = i, c = n, v = s, d = 0; d < 80; d++){
            var _ = Q0(T(U0(h, V0(d, t, i, n), e[He[d] + a], me(d)), ze[d]), s);
            h = s, s = n, n = T(i, 10), i = t, t = _, _ = Q0(T(U0(u, V0(79 - d, f, x, c), e[Ae[d] + a], qe(d)), Be[d]), v), u = v, v = c, c = T(x, 10), x = f, f = _;
        }
        _ = Y(this.h[1], i, c), this.h[1] = Y(this.h[2], n, v), this.h[2] = Y(this.h[3], s, u), this.h[3] = Y(this.h[4], h, f), this.h[4] = Y(this.h[0], t, x), this.h[0] = _;
    };
    y.prototype._digest = function(e) {
        return e === "hex" ? D.toHex32(this.h, "little") : D.split32(this.h, "little");
    };
    function V0(r, e, a, h) {
        return r <= 15 ? e ^ a ^ h : r <= 31 ? e & a | ~e & h : r <= 47 ? (e | ~a) ^ h : r <= 63 ? e & h | a & ~h : e ^ (a | ~h);
    }
    function me(r) {
        return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838;
    }
    function qe(r) {
        return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0;
    }
    var He = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], Ae = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], ze = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], Be = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ];
});
var w0 = p2((Ne, j0)=>{
    "use strict";
    var ye = g1(), Ce = j;
    function R(r, e, a) {
        if (!(this instanceof R)) return new R(r, e, a);
        this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(ye.toArray(e, a));
    }
    j0.exports = R;
    R.prototype._init = function(e) {
        e.length > this.blockSize && (e = new this.Hash().update(e).digest()), Ce(e.length <= this.blockSize);
        for(var a = e.length; a < this.blockSize; a++)e.push(0);
        for(a = 0; a < e.length; a++)e[a] ^= 54;
        for(this.inner = new this.Hash().update(e), a = 0; a < e.length; a++)e[a] ^= 106;
        this.outer = new this.Hash().update(e);
    };
    R.prototype.update = function(e, a) {
        return this.inner.update(e, a), this;
    };
    R.prototype.digest = function(e) {
        return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
});
var c0 = p2((T0)=>{
    var b = T0;
    b.utils = g1();
    b.common = K1();
    b.sha = O0();
    b.ripemd = Z0();
    b.hmac = w0();
    b.sha1 = b.sha.sha1;
    b.sha256 = b.sha.sha256;
    b.sha224 = b.sha.sha224;
    b.sha384 = b.sha.sha384;
    b.sha512 = b.sha.sha512;
    b.ripemd160 = b.ripemd.ripemd160;
});
var rr = S0(c0()), Le = S0(c0()), { default: We , ...ke } = Le, Qe = (rr.default ?? We) ?? ke;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick1(callback, ...args) {
    _nextTick(callback, ...args);
}
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val1 = parseInt(c);
                        if (isNaN(val1)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val1;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}
function delay(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
    const common = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i = 0; i < Math.min(A.length, B.length); i += 1){
        if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
            common.push(A[reverse ? A.length - i - 1 : i]);
        } else {
            return common;
        }
    }
    return common;
}
function diff(A, B) {
    const prefixCommon = createCommon(A, B);
    const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
    A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
    B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
    const swapped = B.length > A.length;
    [A, B] = swapped ? [
        B,
        A
    ] : [
        A,
        B
    ];
    const M = A.length;
    const N = B.length;
    if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N) {
        return [
            ...prefixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })),
            ...A.map((a)=>({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a
                })),
            ...suffixCommon.map((c)=>({
                    type: DiffType.common,
                    value: c
                })), 
        ];
    }
    const offset = N;
    const delta = M - N;
    const size = M + N + 1;
    const fp = Array.from({
        length: size
    }, ()=>({
            y: -1,
            id: -1
        }));
    const routes = new Uint32Array((M * N + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a = M - 1;
        let b = N - 1;
        let j = routes[current.id];
        let type = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type) break;
            const prev = j;
            if (type === 1) {
                result.unshift({
                    type: swapped ? DiffType.removed : DiffType.added,
                    value: B[b]
                });
                b -= 1;
            } else if (type === 3) {
                result.unshift({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: A[a]
                });
                a -= 1;
            } else {
                result.unshift({
                    type: DiffType.common,
                    value: A[a]
                });
                a -= 1;
                b -= 1;
            }
            j = routes[prev];
            type = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev1 = down.id;
            ptr++;
            routes[ptr] = prev1;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k < -N || M < k) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k, M);
        while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp[delta + offset].y < N){
        p = p + 1;
        for(let k = -p; k < delta; ++k){
            fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
        }
        for(let k1 = delta + p; k1 > delta; --k1){
            fp[k1 + offset] = snake(k1, fp[k1 - 1 + offset], fp[k1 + 1 + offset], offset, A, B);
        }
        fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    }
    return [
        ...prefixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })),
        ...backTrace(A, B, fp[delta + offset], swapped),
        ...suffixCommon.map((c)=>({
                type: DiffType.common,
                value: c
            })), 
    ];
}
function diffstr(A, B) {
    function unescape(string) {
        return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
    }
    function tokenize(string, { wordDiff =false  } = {}) {
        if (wordDiff) {
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            for(let i = 0; i < tokens.length - 1; i++){
                if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
                    tokens[i] += tokens[i + 2];
                    tokens.splice(i + 1, 2);
                    i--;
                }
            }
            return tokens.filter((token)=>token);
        } else {
            const tokens1 = [], lines = string.split(/(\n|\r\n)/);
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            for(let i1 = 0; i1 < lines.length; i1++){
                if (i1 % 2) {
                    tokens1[tokens1.length - 1] += lines[i1];
                } else {
                    tokens1.push(lines[i1]);
                }
            }
            return tokens1;
        }
    }
    function createDetails(line, tokens) {
        return tokens.filter(({ type  })=>type === line.type || type === DiffType.common).map((result, i, t)=>{
            if (result.type === DiffType.common && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
                result.type = t[i - 1].type;
            }
            return result;
        });
    }
    const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
    const added = [], removed = [];
    for (const result of diffResult){
        if (result.type === DiffType.added) {
            added.push(result);
        }
        if (result.type === DiffType.removed) {
            removed.push(result);
        }
    }
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a of aLines){
        let tokens = [], b;
        while(bLines.length){
            b = bLines.shift();
            tokens = diff(tokenize(a.value, {
                wordDiff: true
            }), tokenize(b?.value ?? "", {
                wordDiff: true
            }));
            if (tokens.some(({ type , value  })=>type === DiffType.common && value.trim().length)) {
                break;
            }
        }
        a.details = createDetails(a, tokens);
        if (b) {
            b.details = createDetails(b, tokens);
        }
    }
    return diffResult;
}
function createColor(diffType, { background =false  } = {}) {
    switch(diffType){
        case DiffType.added:
            return (s)=>background ? bgGreen(white(s)) : green(bold(s));
        case DiffType.removed:
            return (s)=>background ? bgRed(white(s)) : red(bold(s));
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType.added:
            return "+   ";
        case DiffType.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff =false  } = {}) {
    const messages = [], diffMessages = [];
    messages.push("");
    messages.push("");
    messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages.push("");
    messages.push("");
    diffResult.forEach((result)=>{
        const c = createColor(result.type);
        const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
                background: true
            })(detail.value) : detail.value).join("") ?? result.value;
        diffMessages.push(c(`${createSign(result.type)}${line}`));
    });
    messages.push(...stringDiff ? [
        diffMessages.join("")
    ] : diffMessages);
    messages.push("");
    return messages;
}
function format(v) {
    const { Deno: Deno1  } = globalThis;
    return typeof Deno1?.inspect === "function" ? Deno1.inspect(v, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity
    }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function isKeyedCollection(x) {
    return [
        Symbol.iterator,
        "size"
    ].every((k)=>k in x);
}
function equal(c, d) {
    const seen = new Map();
    return function compare(a, b) {
        if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
            return String(a) === String(b);
        }
        if (a instanceof Date && b instanceof Date) {
            const aTime = a.getTime();
            const bTime = b.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return aTime === bTime;
        }
        if (typeof a === "number" && typeof b === "number") {
            return Number.isNaN(a) && Number.isNaN(b) || a === b;
        }
        if (Object.is(a, b)) {
            return true;
        }
        if (a && typeof a === "object" && b && typeof b === "object") {
            if (a && b && !constructorsEqual(a, b)) {
                return false;
            }
            if (a instanceof WeakMap || b instanceof WeakMap) {
                if (!(a instanceof WeakMap && b instanceof WeakMap)) return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a instanceof WeakSet || b instanceof WeakSet) {
                if (!(a instanceof WeakSet && b instanceof WeakSet)) return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a) === b) {
                return true;
            }
            if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                return false;
            }
            seen.set(a, b);
            if (isKeyedCollection(a) && isKeyedCollection(b)) {
                if (a.size !== b.size) {
                    return false;
                }
                let unmatchedEntries = a.size;
                for (const [aKey, aValue] of a.entries()){
                    for (const [bKey, bValue] of b.entries()){
                        if (aKey === aValue && bKey === bValue && compare(aKey, bKey) || compare(aKey, bKey) && compare(aValue, bValue)) {
                            unmatchedEntries--;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a,
                ...b
            };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged), 
            ]){
                if (!compare(a && a[key], b && b[key])) {
                    return false;
                }
                if (key in a && !(key in b) || key in b && !(key in a)) {
                    return false;
                }
            }
            if (a instanceof WeakRef || b instanceof WeakRef) {
                if (!(a instanceof WeakRef && b instanceof WeakRef)) return false;
                return compare(a.deref(), b.deref());
            }
            return true;
        }
        return false;
    }(c, d);
}
function constructorsEqual(a, b) {
    return a.constructor === b.constructor || a.constructor === Object && !b.constructor || !a.constructor && b.constructor === Object;
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
function assertEquals(actual, expected, msg) {
    if (equal(actual, expected)) {
        return;
    }
    let message = "";
    const actualString = format(actual);
    const expectedString = format(expected);
    try {
        const stringDiff = typeof actual === "string" && typeof expected === "string";
        const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = buildMessage(diffResult, {
            stringDiff
        }).join("\n");
        message = `Values are not equal:\n${diffMsg}`;
    } catch  {
        message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
    }
    if (msg) {
        message = msg;
    }
    throw new AssertionError(message);
}
function unreachable() {
    throw new AssertionError("unreachable");
}
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    console.warn(message);
}
TextDecoder;
TextEncoder;
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function guessHandleType(_fd) {
    notImplemented("util.guessHandleType");
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod3 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol1 = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol1;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i)}${meta[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol1];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix1 = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix1}{}`;
            }
            braces = [
                `${prefix1}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size1 = value.size;
            const prefix2 = getPrefix(constructor, tag, "Map", `(${size1})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size1 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix2}{}`;
            }
            braces = [
                `${prefix2}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size2 = value.length;
            const prefix3 = getPrefix(constructor, tag, fallback, `(${size2})`);
            braces = [
                `${prefix3}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size2);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp1(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix4 = getPrefix(constructor, tag, "RegExp");
            if (prefix4 !== "RegExp ") {
                base = `${prefix4}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate1(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix5 = getPrefix(constructor, tag, "Date");
            if (prefix5 !== "Date ") {
                base = `${prefix5}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix6 = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix6 + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix6}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName1 = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName1, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction1(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction1(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name1 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name1);
            if (index !== -1 && stack.includes(err[name1])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos1 = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos1, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos1 = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos1 === 0 ? line : line.slice(pos1);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp1 = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp1, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp2 = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp2}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending1 = remaining > 1 ? "s" : "";
            const message1 = `<${remaining} empty item${ending1}>`;
            output.push(ctx.stylize(message1, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject1(value)) {
        type = "Number";
    } else if (isStringObject1(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type = "Boolean";
    } else if (isBigIntObject1(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation1 = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation1}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation1}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i1 = 0; i1 < columns; i1++){
            let lineMaxLength = 0;
            for(let j = i1; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i1] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i2 = 0; i2 < output.length; i2++){
                if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i3 = 0; i3 < outputLength; i3 += columns){
            const max = Math.min(i3 + columns, outputLength);
            let str = "";
            let j1 = i3;
            for(; j1 < max - 1; j1++){
                const padding = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1];
                str += `${output[j1]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding1 = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1] - 2;
                str += output[j1].padStart(padding1, " ");
            } else {
                str += output[j1];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos1 = i * 2;
            const res = [
                formatValue(ctx, entries[pos1], recurseTimes),
                formatValue(ctx, entries[pos1 + 1], recurseTimes), 
            ];
            output[i] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = ()=>false;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }
    let debug = (...args)=>{
        init();
        debug = debuglogImpl(enabled, set);
        if (typeof cb === "function") {
            cb(debug);
        }
        return debug(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled;
        return enabled;
    };
    const logger = (...args)=>debug(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv;
try {
    debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error) {
    if (error instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
    } else {
        throw error;
    }
}
initializeDebugEnv(debugEnv);
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const isLinux = osType === "linux";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const os = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto1 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod4 = {
    os: os,
    fs: fs,
    crypto: crypto1,
    zlib: zlib,
    trace: trace
};
const UV_EEXIST = os.errno.EEXIST;
const UV_ENOENT = os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code = uvTranslateSysError(sysErrno);
        return codeMap.get(code) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
const UV_UNKNOWN = codeMap.get("UNKNOWN");
const UV_EBADF = codeMap.get("EBADF");
const UV_EINVAL = codeMap.get("EINVAL");
const UV_ENOTSOCK = codeMap.get("ENOTSOCK");
const mod5 = {
    UV_EEXIST: UV_EEXIST,
    UV_ENOENT: UV_ENOENT,
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno,
    UV_EAI_MEMORY: UV_EAI_MEMORY,
    UV_UNKNOWN: UV_UNKNOWN,
    UV_EBADF: UV_EBADF,
    UV_EINVAL: UV_EINVAL,
    UV_ENOTSOCK: UV_ENOTSOCK
};
var valueType;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter1 = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter1);
        const keysVal2 = getOwnNonIndexProperties(val2, filter1);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i = 0;
    for(; i < aKeys.length; i++){
        if (!val2.propertyIsEnumerable(aKeys[i])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                const key = symbolKeysA[i];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB1.length !== 0 && getEnumerables(val2, symbolKeysB1).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i = 0; i < arr1.byteLength; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject1(a)) {
        return isNumberObject1(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject1(a)) {
        return isStringObject1(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject1(a)) {
        return isBooleanObject1(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject1(a)) {
        return isBigIntObject1(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject1(a)) {
        return isSymbolObject1(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i < obj1.length; i++){
            if (obj1.hasOwnProperty(i)) {
                if (!obj2.hasOwnProperty(i) || !innerDeepEqual(obj1[i], obj2[i], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i < keys1.length; i++){
                    const key = keys1[i];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i = 0; i < keys.length; i++){
        const key1 = keys[i];
        if (!innerDeepEqual(obj1[key1], obj2[key1], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item1 of set2){
            if (typeof item1 === "object" && item1 !== null) {
                if (!setHasEqualElement(set, item1, strict, memos)) return false;
            } else if (!strict && !set1.has(item1) && !setHasEqualElement(set, item1, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key1 , 1: item  } of map2){
            if (typeof key1 === "object" && key1 !== null) {
                if (!mapHasEqualEntry(set, map1, key1, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key1) || !innerDeepEqual(map1.get(key1), item, false, memos)) && !mapHasEqualEntry(set, map1, key1, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last1 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last1}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert1(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_CRYPTO_FIPS_FORCED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap = (a)=>`"${a}"`;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap).join(" or ") : wrap(a));
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert1(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert1(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key = keys[keys.length - 1];
    return key in o;
}
function parse(args, { "--": doubleDash = false , alias ={} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect =[] , negatable =[] , unknown =(i)=>i  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias !== undefined) {
        for(const key1 in alias){
            const val = getForce(alias, key1);
            if (typeof val === "string") {
                aliases[key1] = [
                    val
                ];
            } else {
                aliases[key1] = val;
            }
            for (const alias1 of getForce(aliases, key1)){
                aliases[alias1] = [
                    key1
                ].concat(aliases[key1].filter((y)=>alias1 !== y));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key2 of stringArgs.filter(Boolean)){
            flags.strings[key2] = true;
            const alias2 = get(aliases, key2);
            if (alias2) {
                for (const al of alias2){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect !== undefined) {
        const collectArgs = typeof collect === "string" ? [
            collect
        ] : collect;
        for (const key3 of collectArgs.filter(Boolean)){
            flags.collect[key3] = true;
            const alias3 = get(aliases, key3);
            if (alias3) {
                for (const al1 of alias3){
                    flags.collect[al1] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key4 of negatableArgs.filter(Boolean)){
            flags.negatable[key4] = true;
            const alias4 = get(aliases, key4);
            if (alias4) {
                for (const al2 of alias4){
                    flags.negatable[al2] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, name, value, collect = true) {
        let o = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key = keys[keys.length - 1];
        const collectable = collect && !!get(flags.collect, name);
        if (!collectable) {
            o[key] = value;
        } else if (get(o, key) === undefined) {
            o[key] = [
                value
            ];
        } else if (Array.isArray(get(o, key))) {
            o[key].push(value);
        } else {
            o[key] = [
                get(o, key),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv, key, value, collect);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean");
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert1(m != null);
            const [, key5, value] = m;
            if (flags.bools[key5]) {
                const booleanValue = value !== "false";
                setArg(key5, booleanValue, arg);
            } else {
                setArg(key5, value, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
            const m1 = arg.match(/^--no-(.+)/);
            assert1(m1 != null);
            setArg(m1[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m2 = arg.match(/^--(.+)/);
            assert1(m2 != null);
            const [, key6] = m2;
            const next = args[i + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key6) && !flags.allBools && (get(aliases, key6) ? !aliasIsBoolean(key6) : true)) {
                setArg(key6, next, arg);
                i++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key6, next === "true", arg);
                i++;
            } else {
                setArg(key6, get(flags.strings, key6) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next1 = arg.slice(j + 2);
                if (next1 === "-") {
                    setArg(letters[j], next1, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next1)) {
                    setArg(letters[j], next1.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next1)) {
                    setArg(letters[j], next1, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key7] = arg.slice(-1);
            if (!broken && key7 !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key7) && (get(aliases, key7) ? !aliasIsBoolean(key7) : true)) {
                    setArg(key7, args[i + 1], arg);
                    i++;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key7, args[i + 1] === "true", arg);
                    i++;
                } else {
                    setArg(key7, get(flags.strings, key7) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args.slice(i + 1));
                break;
            }
        }
    }
    for (const [key8, value1] of Object.entries(defaults)){
        if (!hasKey(argv, key8.split("."))) {
            setKey(argv, key8, value1);
            if (aliases[key8]) {
                for (const x of aliases[key8]){
                    setKey(argv, x, value1);
                }
            }
        }
    }
    for (const key9 of Object.keys(flags.bools)){
        if (!hasKey(argv, key9.split("."))) {
            const value2 = get(flags.collect, key9) ? [] : false;
            setKey(argv, key9, value2, false);
        }
    }
    for (const key10 of Object.keys(flags.strings)){
        if (!hasKey(argv, key10.split(".")) && get(flags.collect, key10)) {
            setKey(argv, key10, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key11 of notFlags){
            argv["--"].push(key11);
        }
    } else {
        for (const key12 of notFlags){
            argv._.push(key12);
        }
    }
    return argv;
}
function getOptions() {
    const args = parse(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const timingSafeEqual = (a, b)=>{
    if (a instanceof DataView) a = Buffer.from(a.buffer);
    if (b instanceof DataView) b = Buffer.from(b.buffer);
    if (a instanceof ArrayBuffer) a = Buffer.from(a);
    if (b instanceof ArrayBuffer) b = Buffer.from(b);
    let result = 0;
    if (a.byteLength !== b.byteLength) {
        b = a;
        result = 1;
    }
    for(let i = 0; i < a.byteLength; i++){
        result |= a[i] ^ b[i];
    }
    return result === 0;
};
function getFipsCrypto() {
    notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
    notImplemented("crypto.setFipsCrypto");
}
const mod6 = {
    timingSafeEqual: timingSafeEqual,
    getFipsCrypto: getFipsCrypto,
    setFipsCrypto: setFipsCrypto
};
const MAX_RANDOM_VALUES = 65536;
function generateRandomBytes(size) {
    if (size > 4294967295) {
        throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${4294967295}. Received ${size}`);
    }
    const bytes = Buffer.allocUnsafe(size);
    if (size > 65536) {
        for(let generated = 0; generated < size; generated += MAX_RANDOM_VALUES){
            globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
        }
    } else {
        globalThis.crypto.getRandomValues(bytes);
    }
    return bytes;
}
function randomBytes(size, cb) {
    if (typeof cb === "function") {
        let err = null, bytes;
        try {
            bytes = generateRandomBytes(size);
        } catch (e) {
            if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
                throw e;
            } else if (e instanceof Error) {
                err = e;
            } else {
                err = new Error("[non-error thrown]");
            }
        }
        setTimeout(()=>{
            if (err) {
                cb(err);
            } else {
                cb(null, bytes);
            }
        }, 0);
    } else {
        return generateRandomBytes(size);
    }
}
function assertOffset(offset, length) {
    if (offset > 4294967295 || offset < 0) {
        throw new TypeError("offset must be a uint32");
    }
    if (offset > 0x7fffffff || offset > length) {
        throw new RangeError("offset out of range");
    }
}
function assertSize1(size, offset, length) {
    if (size > 4294967295 || size < 0) {
        throw new TypeError("size must be a uint32");
    }
    if (size + offset > length || size > 0x7fffffff) {
        throw new RangeError("buffer too small");
    }
}
function randomFill(buf, offset, size, cb) {
    if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
    } else if (typeof size === "function") {
        cb = size;
        size = buf.length - Number(offset);
    }
    assertOffset(offset, buf.length);
    assertSize1(size, offset, buf.length);
    randomBytes(size, (err, bytes)=>{
        if (err) return cb(err, buf);
        bytes?.copy(buf, offset);
        cb(null, buf);
    });
}
function randomFillSync(buf, offset = 0, size) {
    assertOffset(offset, buf.length);
    if (size === undefined) size = buf.length - offset;
    assertSize1(size, offset, buf.length);
    const bytes = randomBytes(size);
    bytes.copy(buf, offset);
    return buf;
}
function randomInt(max, min, cb) {
    if (typeof max === "number" && typeof min === "number") {
        [max, min] = [
            min,
            max
        ];
    }
    if (min === undefined) min = 0;
    else if (typeof min === "function") {
        cb = min;
        min = 0;
    }
    if (!Number.isSafeInteger(min) || typeof max === "number" && !Number.isSafeInteger(max)) {
        throw new Error("max or min is not a Safe Number");
    }
    if (max - min > Math.pow(2, 48)) {
        throw new RangeError("max - min should be less than 2^48!");
    }
    if (min >= max) {
        throw new Error("Min is bigger than Max!");
    }
    const randomBuffer = new Uint32Array(1);
    globalThis.crypto.getRandomValues(randomBuffer);
    const randomNumber = randomBuffer[0] / (0xffffffff + 1);
    min = Math.ceil(min);
    max = Math.floor(max);
    const result = Math.floor(randomNumber * (max - min)) + min;
    if (cb) {
        cb(null, result);
        return;
    }
    return result;
}
function checkPrime(_candidate, _options, _callback) {
    notImplemented("crypto.checkPrime");
}
function checkPrimeSync(_candidate, _options) {
    notImplemented("crypto.checkPrimeSync");
}
function generatePrime(_size, _options, _callback) {
    notImplemented("crypto.generatePrime");
}
function generatePrimeSync(_size, _options) {
    notImplemented("crypto.generatePrimeSync");
}
const randomUUID = ()=>globalThis.crypto.randomUUID();
let wasm;
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0;
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr1 = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr1 + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr1 = realloc(ptr1, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr1 + offset, ptr1 + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr1;
}
function isLikeNone(x) {
    return x === undefined || x === null;
}
let cachedInt32Memory0;
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.digestcontext_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DigestContext.__wrap(r0);
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    update(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_reset(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
            const ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_3e250b41a8915757: function(arg0) {
            const ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
            const ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_facf0398a281c85b: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
            const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
            const ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            const ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_a7ce447f15ff496f: function(arg0) {
            const ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                digest,
                DigestContext
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fw\
F/AqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRj\
ZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAh\
hfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3\
AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNW\
RmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1\
YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbm\
d0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0\
aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbW\
Vtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5\
NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAA\
MYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193\
YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQPsgICAAGsJBwkHBxEFBwcFAw\
cHDwMHBRACBQUFBwUCCAYHBxQMCA4HBwcHBgcHCBcNBQUJCAgNBwkFCQkGBgUFBQUFBQcHBwcHAAUC\
CAoHBwMCBQ4MCwwLCxITCQUICAMGBgIFAAAGAwYAAAUFBAAFAgSFgICAAAFwARUVBYOAgIAAAQARBo\
mAgIAAAX8BQYCAwAALB7aCgIAADgZtZW1vcnkCAAZkaWdlc3QANhhfX3diZ19kaWdlc3Rjb250ZXh0\
X2ZyZWUAURFkaWdlc3Rjb250ZXh0X25ldwA9FGRpZ2VzdGNvbnRleHRfdXBkYXRlAFUUZGlnZXN0Y2\
9udGV4dF9kaWdlc3QAPhxkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZFJlc2V0AEAbZGlnZXN0Y29udGV4\
dF9kaWdlc3RBbmREcm9wADkTZGlnZXN0Y29udGV4dF9yZXNldAAhE2RpZ2VzdGNvbnRleHRfY2xvbm\
UAGh9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAG0RX193YmluZGdlbl9tYWxsb2MAVhJf\
X3diaW5kZ2VuX3JlYWxsb2MAYw9fX3diaW5kZ2VuX2ZyZWUAaQmagICAAAEAQQELFGZnbnVsWjxbXF\
lkYV1eX2B2QkNzCuXMiIAAa6B+AhJ/An4jAEGwJWsiBCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgAOGAABAgMEHBsaGR\
gXFhUUExIREA8ODQwLCgALIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZAS\
akEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZ\
ASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAE\
IAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAGoQRCAEIBY3A9ASIAUgBEGQEmpB0AEQOhpBAC\
EGQQAhAQwfCyABKAIEIQFB0AEQFiIFRQ0EIARBkBJqQThqIAFBOGopAwA3AwAgBEGQEmpBMGogAUEw\
aikDADcDACAEQZASakEoaiABQShqKQMANwMAIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBGGogAU\
EYaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQQhqIAFBCGopAwA3AwAgBCABKQMANwOQ\
EiABKQNAIRYgBEGQEmpByABqIAFByABqEEQgBCAWNwPQEiAFIARBkBJqQdABEDoaQQEhAQwbCyABKA\
IEIQFB0AEQFiIFRQ0EIARBkBJqQThqIAFBOGopAwA3AwAgBEGQEmpBMGogAUEwaikDADcDACAEQZAS\
akEoaiABQShqKQMANwMAIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBGGogAUEYaikDADcDACAEQZ\
ASakEQaiABQRBqKQMANwMAIARBkBJqQQhqIAFBCGopAwA3AwAgBCABKQMANwOQEiABKQNAIRYgBEGQ\
EmpByABqIAFByABqEEQgBCAWNwPQEiAFIARBkBJqQdABEDoaQQIhAQwaCyABKAIEIQFB8AAQFiIFRQ\
0EIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBGGogAUEYaikDADcDACAEQZASakEQaiABQRBqKQMA\
NwMAIAQgASkDCDcDmBIgASkDACEWIARBkBJqQShqIAFBKGoQOCAEIBY3A5ASIAUgBEGQEmpB8AAQOh\
pBAyEBDBkLIAEoAgQhAUH4DhAWIgVFDQQgBEGQEmpBiAFqIAFBiAFqKQMANwMAIARBkBJqQYABaiAB\
QYABaikDADcDACAEQZASakH4AGogAUH4AGopAwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASak\
EYaiABQRhqKQMANwMAIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBMGogAUEwaikDADcDACAEQZAS\
akE4aiABQThqKQMANwMAIARBkBJqQcAAaiABQcAAaikDADcDACAEQZASakHIAGogAUHIAGopAwA3Aw\
AgBEGQEmpB0ABqIAFB0ABqKQMANwMAIARBkBJqQdgAaiABQdgAaikDADcDACAEQZASakHgAGogAUHg\
AGopAwA3AwAgBCABKQNwNwOAEyAEIAEpAwg3A5gSIAQgASkDKDcDuBIgASkDACEWIAEtAGohByABLQ\
BpIQggAS0AaCEJAkAgASgCkAFBBXQiCg0AQQAhCgwbCyAEQRhqIgsgAUGUAWoiBkEYaikAADcDACAE\
QRBqIgwgBkEQaikAADcDACAEQQhqIg0gBkEIaikAADcDACAEIAYpAAA3AwAgAUHUAWohBkEAIApBYG\
pBBXZrIQ4gBEHEE2ohAUECIQoDQCABQWBqIg8gBCkDADcAACAPQRhqIAspAwA3AAAgD0EQaiAMKQMA\
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\
DQEgBEGQEmogAUHIARA6GiAEQZASakHIAWogAUHIAWoQSSAFIARBkBJqQeACEDoaQQUhAQtBACEGDA\
ILQeACQQhBACgC+NRAIgRBBCAEGxEFAAALIAQgCjYCoBMgBCAHOgD6EiAEIAg6APkSIAQgCToA+BIg\
BCAWNwOQEiAFIARBkBJqQfgOEDoaQQQhAUEBIQYLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAg\
Ag4CAQARC0EgIQIgAQ4YAQ8CDxADDwQFBgYHBwgPCQoLDwwNEBAOAQsgAUECdEGU1MAAaigCACEDDA\
8LQcAAIQIMDQtBMCECDAwLQRwhAgwLC0EwIQIMCgtBwAAhAgwJC0EQIQIMCAtBFCECDAcLQRwhAgwG\
C0EwIQIMBQtBwAAhAgwEC0EcIQIMAwtBMCECDAILQcAAIQIMAQtBGCECCyACIANGDQAgAEGtgcAANg\
IEIABBATYCACAAQQhqQTk2AgACQCAGRQ0AIAUoApABRQ0AIAVBADYCkAELIAUQHgwBCwJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEOGAABAgMEBQ\
YHCAkKCwwNDg8QERITFBUWGgALIAQgBUHQARA6IgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACAB\
QfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQfgOakE0akIANwIAIAFB+A\
5qQTxqQgA3AgAgAUIANwL8DiABQcAANgL4DiABQZASaiABQfgOakHEABA6GiABQbgiakE4aiIKIAFB\
kBJqQTxqKQIANwMAIAFBuCJqQTBqIgMgAUGQEmpBNGopAgA3AwAgAUG4ImpBKGoiDyABQZASakEsai\
kCADcDACABQbgiakEgaiILIAFBkBJqQSRqKQIANwMAIAFBuCJqQRhqIgwgAUGQEmpBHGopAgA3AwAg\
AUG4ImpBEGoiDSABQZASakEUaikCADcDACABQbgiakEIaiIQIAFBkBJqQQxqKQIANwMAIAEgASkClB\
I3A7giIAFBkBJqIAFB0AEQOhogASABKQPQEiABQdgTai0AACIGrXw3A9ASIAFB2BJqIQICQCAGQYAB\
Rg0AIAIgBmpBAEGAASAGaxA7GgsgAUEAOgDYEyABQZASaiACQn8QESABQfgOakEIaiIGIAFBkBJqQQ\
hqKQMANwMAIAFB+A5qQRBqIgIgAUGQEmpBEGopAwA3AwAgAUH4DmpBGGoiDiABQZASakEYaikDADcD\
ACABQfgOakEgaiIHIAEpA7ASNwMAIAFB+A5qQShqIgggAUGQEmpBKGopAwA3AwAgAUH4DmpBMGoiCS\
ABQZASakEwaikDADcDACABQfgOakE4aiIRIAFBkBJqQThqKQMANwMAIAEgASkDkBI3A/gOIBAgBikD\
ADcDACANIAIpAwA3AwAgDCAOKQMANwMAIAsgBykDADcDACAPIAgpAwA3AwAgAyAJKQMANwMAIAogES\
kDADcDACABIAEpA/gONwO4IkHAABAWIgZFDRwgBiABKQO4IjcAACAGQThqIAFBuCJqQThqKQMANwAA\
IAZBMGogAUG4ImpBMGopAwA3AAAgBkEoaiABQbgiakEoaikDADcAACAGQSBqIAFBuCJqQSBqKQMANw\
AAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMA\
NwAAQcAAIQMMGgsgBCAFQdABEDoiAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQg\
A3AgAgAUIANwL8DiABQSA2AvgOIAFBkBJqQRhqIgsgAUH4DmpBGGoiAikDADcDACABQZASakEQaiIM\
IAFB+A5qQRBqIgopAwA3AwAgAUGQEmpBCGoiDSABQfgOakEIaiIDKQMANwMAIAFBkBJqQSBqIAFB+A\
5qQSBqIhAoAgA2AgAgASABKQP4DjcDkBIgAUG4ImpBEGoiDiABQZASakEUaikCADcDACABQbgiakEI\
aiIHIAFBkBJqQQxqKQIANwMAIAFBuCJqQRhqIgggAUGQEmpBHGopAgA3AwAgASABKQKUEjcDuCIgAU\
GQEmogAUHQARA6GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDwJAIAZBgAFGDQAgDyAG\
akEAQYABIAZrEDsaCyABQQA6ANgTIAFBkBJqIA9CfxARIAMgDSkDADcDACAKIAwpAwA3AwAgAiALKQ\
MANwMAIBAgASkDsBI3AwAgAUH4DmpBKGogAUGQEmpBKGopAwA3AwAgAUH4DmpBMGogAUGQEmpBMGop\
AwA3AwAgAUH4DmpBOGogAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gByADKQMANwMAIA4gCikDAD\
cDACAIIAIpAwA3AwAgASABKQP4DjcDuCJBIBAWIgZFDRwgBiABKQO4IjcAACAGQRhqIAFBuCJqQRhq\
KQMANwAAIAZBEGogAUG4ImpBEGopAwA3AAAgBkEIaiABQbgiakEIaikDADcAAEEgIQMMGQsgBCAFQd\
ABEDoiAUH4DmpBLGpCADcCACABQfgOakEkakIANwIAIAFB+A5qQRxqQgA3AgAgAUH4DmpBFGpCADcC\
ACABQfgOakEMakIANwIAIAFCADcC/A4gAUEwNgL4DiABQZASakEoaiINIAFB+A5qQShqIgIpAwA3Aw\
AgAUGQEmpBIGogAUH4DmpBIGoiCikDADcDACABQZASakEYaiIQIAFB+A5qQRhqIgMpAwA3AwAgAUGQ\
EmpBEGoiDiABQfgOakEQaiIPKQMANwMAIAFBkBJqQQhqIgcgAUH4DmpBCGoiCykDADcDACABQZASak\
EwaiIIIAFB+A5qQTBqIgkoAgA2AgAgASABKQP4DjcDkBIgAUG4ImpBIGoiESABQZASakEkaikCADcD\
ACABQbgiakEYaiISIAFBkBJqQRxqKQIANwMAIAFBuCJqQRBqIhMgAUGQEmpBFGopAgA3AwAgAUG4Im\
pBCGoiFCABQZASakEMaikCADcDACABQbgiakEoaiIVIAFBkBJqQSxqKQIANwMAIAEgASkClBI3A7gi\
IAFBkBJqIAFB0AEQOhogASABKQPQEiABQdgTai0AACIGrXw3A9ASIAFB2BJqIQwCQCAGQYABRg0AIA\
wgBmpBAEGAASAGaxA7GgsgAUEAOgDYEyABQZASaiAMQn8QESALIAcpAwA3AwAgDyAOKQMANwMAIAMg\
ECkDADcDACAKIAEpA7ASNwMAIAIgDSkDADcDACAJIAgpAwA3AwAgAUH4DmpBOGogAUGQEmpBOGopAw\
A3AwAgASABKQOQEjcD+A4gFCALKQMANwMAIBMgDykDADcDACASIAMpAwA3AwAgESAKKQMANwMAIBUg\
AikDADcDACABIAEpA/gONwO4IkEwEBYiBkUNHCAGIAEpA7giNwAAIAZBKGogAUG4ImpBKGopAwA3AA\
AgBkEgaiABQbgiakEgaikDADcAACAGQRhqIAFBuCJqQRhqKQMANwAAIAZBEGogAUG4ImpBEGopAwA3\
AAAgBkEIaiABQbgiakEIaikDADcAAEEwIQMMGAsgBCAFQfAAEDoiAUH4DmpBHGpCADcCACABQfgOak\
EUakIANwIAIAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQSA2AvgOIAFBkBJqQRhqIgogAUH4DmpBGGop\
AwA3AwAgAUGQEmpBEGoiAyABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaiIPKQMANwMAIA\
FBkBJqQSBqIgsgAUH4DmpBIGooAgA2AgAgASABKQP4DjcDkBIgAUHoI2pBEGoiDCABQZASakEUaikC\
ADcDACABQegjakEIaiINIAFBkBJqQQxqKQIANwMAIAFB6CNqQRhqIhAgAUGQEmpBHGopAgA3AwAgAS\
ABKQKUEjcD6CMgAUGQEmogAUHwABA6GiABIAEpA5ASIAFB+BJqLQAAIgatfDcDkBIgAUG4EmohAgJA\
IAZBwABGDQAgAiAGakEAQcAAIAZrEDsaCyABQQA6APgSIAFBkBJqIAJBfxATIA8gAykDACIWNwMAIA\
0gFjcDACAMIAopAwA3AwAgECALKQMANwMAIAEgASkDmBIiFjcD+A4gASAWNwPoI0EgEBYiBkUNHCAG\
IAEpA+gjNwAAIAZBGGogAUHoI2pBGGopAwA3AAAgBkEQaiABQegjakEQaikDADcAACAGQQhqIAFB6C\
NqQQhqKQMANwAAQSAhAwwXCyAEIAVB+A4QOiEBIANBAEgNEgJAAkAgAw0AQQEhBgwBCyADEBYiBkUN\
HSAGQXxqLQAAQQNxRQ0AIAZBACADEDsaCyABQZASaiABQfgOEDoaIAFB+A5qIAFBkBJqECMgAUH4Dm\
ogBiADEBgMFgsgBCAFQeACEDoiCkGQEmogCkHgAhA6GiAKQZASaiAKQegUai0AACIBakHIAWohAgJA\
IAFBkAFGDQAgAkEAQZABIAFrEDsaC0EAIQYgCkEAOgDoFCACQQE6AAAgCkHnFGoiASABLQAAQYABcj\
oAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAA\
IAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQZ\
ABRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGooAgA2AgAgCkH4DmpBEGoiAiAKQZASakEQ\
aikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQRwhA0EcEBYiBkUNHC\
AGIAopA/gONwAAIAZBGGogASgCADYAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADBULIAQgBUHY\
AhA6IgpBkBJqIApB2AIQOhogCkGQEmogCkHgFGotAAAiAWpByAFqIQICQCABQYgBRg0AIAJBAEGIAS\
ABaxA7GgtBACEGIApBADoA4BQgAkEBOgAAIApB3xRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIB\
IAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQc\
oBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkGIAUcNAAsgCkGQEmoQJCAK\
QfgOakEYaiIBIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIgIgCkGQEmpBEGopAwA3AwAgCkH4DmpBCG\
oiDyAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkEgIQNBIBAWIgZFDRwgBiAKKQP4DjcAACAGQRhq\
IAEpAwA3AAAgBkEQaiACKQMANwAAIAZBCGogDykDADcAAAwUCyAEIAVBuAIQOiIKQZASaiAKQbgCED\
oaIApBkBJqIApBwBRqLQAAIgFqQcgBaiECAkAgAUHoAEYNACACQQBB6AAgAWsQOxoLQQAhBiAKQQA6\
AMAUIAJBAToAACAKQb8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAcz\
oAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oi\
AiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZB6ABHDQALIApBkBJqECQgCkH4DmpBKGoiASAKQZASak\
EoaikDADcDACAKQfgOakEgaiICIApBkBJqQSBqKQMANwMAIApB+A5qQRhqIg8gCkGQEmpBGGopAwA3\
AwAgCkH4DmpBEGoiCyAKQZASakEQaikDADcDACAKQfgOakEIaiIMIApBkBJqQQhqKQMANwMAIAogCi\
kDkBI3A/gOQTAhA0EwEBYiBkUNHCAGIAopA/gONwAAIAZBKGogASkDADcAACAGQSBqIAIpAwA3AAAg\
BkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhqIAwpAwA3AAAMEwsgBCAFQZgCEDoiCkGQEmogCk\
GYAhA6GiAKQZASaiAKQaAUai0AACIBakHIAWohAgJAIAFByABGDQAgAkEAQcgAIAFrEDsaC0EAIQYg\
CkEAOgCgFCACQQE6AAAgCkGfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai\
0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACAB\
QQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQcgARw0ACyAKQZASahAkIApB+A5qQThqIgEgCk\
GQEmpBOGopAwA3AwAgCkH4DmpBMGoiAiAKQZASakEwaikDADcDACAKQfgOakEoaiIPIApBkBJqQShq\
KQMANwMAIApB+A5qQSBqIgsgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDCAKQZASakEYaikDADcDAC\
AKQfgOakEQaiINIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIhAgCkGQEmpBCGopAwA3AwAgCiAKKQOQ\
EjcD+A5BwAAhA0HAABAWIgZFDRwgBiAKKQP4DjcAACAGQThqIAEpAwA3AAAgBkEwaiACKQMANwAAIA\
ZBKGogDykDADcAACAGQSBqIAspAwA3AAAgBkEYaiAMKQMANwAAIAZBEGogDSkDADcAACAGQQhqIBAp\
AwA3AAAMEgsgBCAFQeAAEDoiAUH4DmpBDGpCADcCACABQgA3AvwOQRAhAyABQRA2AvgOIAFBkBJqQR\
BqIAFB+A5qQRBqKAIANgIAIAFBkBJqQQhqIAFB+A5qQQhqKQMANwMAIAFB6CNqQQhqIgIgAUGQEmpB\
DGopAgA3AwAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAUGQEmogAUHgABA6GiABQZASaiABQagSai\
ABQegjahAvQRAQFiIGRQ0cIAYgASkD6CM3AAAgBkEIaiACKQMANwAADBELIAQgBUHgABA6IgFB+A5q\
QQxqQgA3AgAgAUIANwL8DkEQIQMgAUEQNgL4DiABQZASakEQaiABQfgOakEQaigCADYCACABQZASak\
EIaiABQfgOakEIaikDADcDACABQegjakEIaiICIAFBkBJqQQxqKQIANwMAIAEgASkD+A43A5ASIAEg\
ASkClBI3A+gjIAFBkBJqIAFB4AAQOhogAUGQEmogAUGoEmogAUHoI2oQLkEQEBYiBkUNHCAGIAEpA+\
gjNwAAIAZBCGogAikDADcAAAwQC0EUIQMgBCAFQegAEDoiAUH4DmpBFGpBADYCACABQfgOakEMakIA\
NwIAIAFBADYC+A4gAUIANwL8DiABQRQ2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKQMANwMAIAFBkBJqQQ\
hqIAFB+A5qQQhqKQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgAUHoI2pBEGoiCiABQZAS\
akEUaigCADYCACABIAEpA/gONwOQEiABIAEpApQSNwPoIyABQZASaiABQegAEDoaIAFBkBJqIAFBsB\
JqIAFB6CNqEC1BFBAWIgZFDRwgBiABKQPoIzcAACAGQRBqIAooAgA2AAAgBkEIaiACKQMANwAADA8L\
QRQhAyAEIAVB6AAQOiIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3AgAgAUEANgL4DiABQgA3AvwOIA\
FBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHo\
I2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKAIANgIAIAEgASkD+A43A5\
ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQOhogAUGQEmogAUGwEmogAUHoI2oQKEEUEBYiBkUNHCAG\
IAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDgsgBCAFQeACEDoiCkGQEmogCkHgAh\
A6GiAKQZASaiAKQegUai0AACIBakHIAWohAgJAIAFBkAFGDQAgAkEAQZABIAFrEDsaC0EAIQYgCkEA\
OgDoFCACQQY6AAAgCkHnFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAH\
M6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNq\
IgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQZABRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEm\
pBGGooAgA2AgAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMA\
NwMAIAogCikDkBI3A/gOQRwhA0EcEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASgCADYAACAGQRBqIA\
IpAwA3AAAgBkEIaiAPKQMANwAADA0LIAQgBUHYAhA6IgpBkBJqIApB2AIQOhogCkGQEmogCkHgFGot\
AAAiAWpByAFqIQICQCABQYgBRg0AIAJBAEGIASABaxA7GgtBACEGIApBADoA4BQgAkEGOgAAIApB3x\
RqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAA\
IAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAA\
BzOgAAIAZBBGoiBkGIAUcNAAsgCkGQEmoQJCAKQfgOakEYaiIBIApBkBJqQRhqKQMANwMAIApB+A5q\
QRBqIgIgCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiDyAKQZASakEIaikDADcDACAKIAopA5ASNwP4Dk\
EgIQNBIBAWIgZFDRwgBiAKKQP4DjcAACAGQRhqIAEpAwA3AAAgBkEQaiACKQMANwAAIAZBCGogDykD\
ADcAAAwMCyAEIAVBuAIQOiIKQZASaiAKQbgCEDoaIApBkBJqIApBwBRqLQAAIgFqQcgBaiECAkAgAU\
HoAEYNACACQQBB6AAgAWsQOxoLQQAhBiAKQQA6AMAUIAJBBjoAACAKQb8UaiIBIAEtAABBgAFyOgAA\
A0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAU\
ECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZB6ABH\
DQALIApBkBJqECQgCkH4DmpBKGoiASAKQZASakEoaikDADcDACAKQfgOakEgaiICIApBkBJqQSBqKQ\
MANwMAIApB+A5qQRhqIg8gCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiCyAKQZASakEQaikDADcDACAK\
QfgOakEIaiIMIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQTAhA0EwEBYiBkUNHCAGIAopA/gONw\
AAIAZBKGogASkDADcAACAGQSBqIAIpAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhq\
IAwpAwA3AAAMCwsgBCAFQZgCEDoiCkGQEmogCkGYAhA6GiAKQZASaiAKQaAUai0AACIBakHIAWohAg\
JAIAFByABGDQAgAkEAQcgAIAFrEDsaC0EAIQYgCkEAOgCgFCACQQY6AAAgCkGfFGoiASABLQAAQYAB\
cjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOg\
AAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIG\
QcgARw0ACyAKQZASahAkIApB+A5qQThqIgEgCkGQEmpBOGopAwA3AwAgCkH4DmpBMGoiAiAKQZASak\
EwaikDADcDACAKQfgOakEoaiIPIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgsgCkGQEmpBIGopAwA3\
AwAgCkH4DmpBGGoiDCAKQZASakEYaikDADcDACAKQfgOakEQaiINIApBkBJqQRBqKQMANwMAIApB+A\
5qQQhqIhAgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BwAAhA0HAABAWIgZFDRwgBiAKKQP4DjcA\
ACAGQThqIAEpAwA3AAAgBkEwaiACKQMANwAAIAZBKGogDykDADcAACAGQSBqIAspAwA3AAAgBkEYai\
AMKQMANwAAIAZBEGogDSkDADcAACAGQQhqIBApAwA3AAAMCgsgBCAFQfAAEDoiAUGQEmogAUHwABA6\
GkEcIQMgAUHoI2pBHGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsIyABQS\
A2AugjIAFB+A5qQRhqIgIgAUHoI2pBGGopAwA3AwAgAUH4DmpBEGoiCiABQegjakEQaikDADcDACAB\
QfgOakEIaiIPIAFB6CNqQQhqKQMANwMAIAFB+A5qQSBqIAFB6CNqQSBqKAIANgIAIAEgASkD6CM3A/\
gOIAFBuCJqQRBqIgYgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiCyABQfgOakEMaikCADcDACABQbgi\
akEYaiIMIAFB+A5qQRxqKQIANwMAIAEgASkC/A43A7giIAFBkBJqIAFBuBJqIAFBuCJqECcgAiAMKA\
IANgIAIAogBikDADcDACAPIAspAwA3AwAgASABKQO4IjcD+A5BHBAWIgZFDRwgBiABKQP4DjcAACAG\
QRhqIAIoAgA2AAAgBkEQaiAKKQMANwAAIAZBCGogDykDADcAAAwJCyAEIAVB8AAQOiIBQZASaiABQf\
AAEDoaIAFB6CNqQRxqQgA3AgAgAUHoI2pBFGpCADcCACABQegjakEMakIANwIAIAFCADcC7CNBICED\
IAFBIDYC6CMgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgAUH4DmpBGGoiAiABQegjakEYaikDADcDAC\
ABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB+A5qQQhqIg8gAUHoI2pBCGopAwA3AwAgASABKQPo\
IzcD+A4gAUG4ImpBGGoiBiABQfgOakEcaikCADcDACABQbgiakEQaiILIAFB+A5qQRRqKQIANwMAIA\
FBuCJqQQhqIgwgAUH4DmpBDGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQJyAC\
IAYpAwA3AwAgCiALKQMANwMAIA8gDCkDADcDACABIAEpA7giNwP4DkEgEBYiBkUNHCAGIAEpA/gONw\
AAIAZBGGogAikDADcAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAgLIAQgBUHYARA6IgFBkBJq\
IAFB2AEQOhogAUHoI2pBDGpCADcCACABQegjakEUakIANwIAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJG\
pCADcCACABQegjakEsakIANwIAIAFB6CNqQTRqQgA3AgAgAUHoI2pBPGpCADcCACABQgA3AuwjIAFB\
wAA2AugjIAFB+A5qIAFB6CNqQcQAEDoaIAFB8CJqIAFB+A5qQTxqKQIANwMAQTAhAyABQbgiakEwai\
ABQfgOakE0aikCADcDACABQbgiakEoaiIGIAFB+A5qQSxqKQIANwMAIAFBuCJqQSBqIgIgAUH4DmpB\
JGopAgA3AwAgAUG4ImpBGGoiCiABQfgOakEcaikCADcDACABQbgiakEQaiIPIAFB+A5qQRRqKQIANw\
MAIAFBuCJqQQhqIgsgAUH4DmpBDGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUHgEmogAUG4ImoQ\
IiABQfgOakEoaiIMIAYpAwA3AwAgAUH4DmpBIGoiDSACKQMANwMAIAFB+A5qQRhqIgIgCikDADcDAC\
ABQfgOakEQaiIKIA8pAwA3AwAgAUH4DmpBCGoiDyALKQMANwMAIAEgASkDuCI3A/gOQTAQFiIGRQ0c\
IAYgASkD+A43AAAgBkEoaiAMKQMANwAAIAZBIGogDSkDADcAACAGQRhqIAIpAwA3AAAgBkEQaiAKKQ\
MANwAAIAZBCGogDykDADcAAAwHCyAEIAVB2AEQOiIBQZASaiABQdgBEDoaIAFB6CNqQQxqQgA3AgAg\
AUHoI2pBFGpCADcCACABQegjakEcakIANwIAIAFB6CNqQSRqQgA3AgAgAUHoI2pBLGpCADcCACABQe\
gjakE0akIANwIAIAFB6CNqQTxqQgA3AgAgAUIANwLsI0HAACEDIAFBwAA2AugjIAFB+A5qIAFB6CNq\
QcQAEDoaIAFBuCJqQThqIgYgAUH4DmpBPGopAgA3AwAgAUG4ImpBMGoiAiABQfgOakE0aikCADcDAC\
ABQbgiakEoaiIKIAFB+A5qQSxqKQIANwMAIAFBuCJqQSBqIg8gAUH4DmpBJGopAgA3AwAgAUG4ImpB\
GGoiCyABQfgOakEcaikCADcDACABQbgiakEQaiIMIAFB+A5qQRRqKQIANwMAIAFBuCJqQQhqIg0gAU\
H4DmpBDGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUHgEmogAUG4ImoQIiABQfgOakE4aiIQIAYp\
AwA3AwAgAUH4DmpBMGoiDiACKQMANwMAIAFB+A5qQShqIgIgCikDADcDACABQfgOakEgaiIKIA8pAw\
A3AwAgAUH4DmpBGGoiDyALKQMANwMAIAFB+A5qQRBqIgsgDCkDADcDACABQfgOakEIaiIMIA0pAwA3\
AwAgASABKQO4IjcD+A5BwAAQFiIGRQ0cIAYgASkD+A43AAAgBkE4aiAQKQMANwAAIAZBMGogDikDAD\
cAACAGQShqIAIpAwA3AAAgBkEgaiAKKQMANwAAIAZBGGogDykDADcAACAGQRBqIAspAwA3AAAgBkEI\
aiAMKQMANwAADAYLIARB+A5qIAVB+AIQOhogA0EASA0BAkACQCADDQBBASEGDAELIAMQFiIGRQ0dIA\
ZBfGotAABBA3FFDQAgBkEAIAMQOxoLIARBkBJqIARB+A5qQfgCEDoaIAQgBEH4DmpByAEQOiIPQcgB\
aiAPQZASakHIAWpBqQEQOiEBIA9B6CNqIA9B+A5qQcgBEDoaIA9BiCFqIAFBqQEQOhogD0GIIWogDy\
0AsCIiAWohCgJAIAFBqAFGDQAgCkEAQagBIAFrEDsaC0EAIQIgD0EAOgCwIiAKQR86AAAgD0GvImoi\
ASABLQAAQYABcjoAAANAIA9B6CNqIAJqIgEgAS0AACAPQYghaiACaiIKLQAAczoAACABQQFqIgsgCy\
0AACAKQQFqLQAAczoAACABQQJqIgsgCy0AACAKQQJqLQAAczoAACABQQNqIgEgAS0AACAKQQNqLQAA\
czoAACACQQRqIgJBqAFHDQALIA9B6CNqECQgD0GQEmogD0HoI2pByAEQOhogD0EANgK4IiAPQbgiak\
EEckEAQagBEDsaIA9BqAE2ArgiIA8gD0G4ImpBrAEQOiIBQZASakHIAWogAUEEckGoARA6GiABQYAV\
akEAOgAAIAFBkBJqIAYgAxAyDAULIARB+A5qIAVB2AIQOhogA0EASA0AIAMNAUEBIQYMAgsQagALIA\
MQFiIGRQ0aIAZBfGotAABBA3FFDQAgBkEAIAMQOxoLIARBkBJqIARB+A5qQdgCEDoaIAQgBEH4DmpB\
yAEQOiIPQcgBaiAPQZASakHIAWpBiQEQOiEBIA9B6CNqIA9B+A5qQcgBEDoaIA9BiCFqIAFBiQEQOh\
ogD0GIIWogDy0AkCIiAWohCgJAIAFBiAFGDQAgCkEAQYgBIAFrEDsaC0EAIQIgD0EAOgCQIiAKQR86\
AAAgD0GPImoiASABLQAAQYABcjoAAANAIA9B6CNqIAJqIgEgAS0AACAPQYghaiACaiIKLQAAczoAAC\
ABQQFqIgsgCy0AACAKQQFqLQAAczoAACABQQJqIgsgCy0AACAKQQJqLQAAczoAACABQQNqIgEgAS0A\
ACAKQQNqLQAAczoAACACQQRqIgJBiAFHDQALIA9B6CNqECQgD0GQEmogD0HoI2pByAEQOhogD0EANg\
K4IiAPQbgiakEEckEAQYgBEDsaIA9BiAE2ArgiIA8gD0G4ImpBjAEQOiIBQZASakHIAWogAUEEckGI\
ARA6GiABQeAUakEAOgAAIAFBkBJqIAYgAxAzDAELIAQgBUHoABA6IgFB+A5qQRRqQgA3AgAgAUH4Dm\
pBDGpCADcCACABQgA3AvwOQRghAyABQRg2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKQMANwMAIAFBkBJq\
QQhqIAFB+A5qQQhqKQMANwMAIAFBkBJqQRhqIAFB+A5qQRhqKAIANgIAIAFB6CNqQQhqIgIgAUGQEm\
pBDGopAgA3AwAgAUHoI2pBEGoiCiABQZASakEUaikCADcDACABIAEpA/gONwOQEiABIAEpApQSNwPo\
IyABQZASaiABQegAEDoaIAFBkBJqIAFBsBJqIAFB6CNqEDBBGBAWIgZFDRkgBiABKQPoIzcAACAGQR\
BqIAopAwA3AAAgBkEIaiACKQMANwAACyAFEB4gAEEIaiADNgIAIAAgBjYCBCAAQQA2AgALIARBsCVq\
JAAPC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKA\
L41EAiBEEEIAQbEQUAAAtBIEEBQQAoAvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIgRBBCAEGxEF\
AAALQRxBAUEAKAL41EAiBEEEIAQbEQUAAAtBIEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EwQQFBACgC+N\
RAIgRBBCAEGxEFAAALQcAAQQFBACgC+NRAIgRBBCAEGxEFAAALQRBBAUEAKAL41EAiBEEEIAQbEQUA\
AAtBEEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EUQQFBACgC+NRAIgRBBCAEGxEFAAALQRRBAUEAKAL41E\
AiBEEEIAQbEQUAAAtBHEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAAL\
QTBBAUEAKAL41EAiBEEEIAQbEQUAAAtBwABBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEBQQAoAvjUQC\
IEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIAQbEQUAAAtB\
wABBAUEAKAL41EAiBEEEIAQbEQUAAAsgA0EBQQAoAvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIg\
RBBCAEGxEFAAALQRhBAUEAKAL41EAiBEEEIAQbEQUAAAuSWgIBfyJ+IwBBgAFrIgMkACADQQBBgAEQ\
OyEDIAApAzghBCAAKQMwIQUgACkDKCEGIAApAyAhByAAKQMYIQggACkDECEJIAApAwghCiAAKQMAIQ\
sCQCACQQd0IgJFDQAgASACaiECA0AgAyABKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCA\
gICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQj\
iIhISENwMAIAMgAUEIaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiG\
QoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhDcDCCADIA\
FBEGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGIZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQg\
DEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gODIAxCOIiEhIQ3AxAgAyABQRhqKQAAIgxCOI\
YgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+D\
IAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISENwMYIAMgAUEgaikAACIMQjiGIAxCKIZCgICAgI\
CAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeD\
hCAMQiiIQoD+A4MgDEI4iISEhDcDICADIAFBKGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGI\
ZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gOD\
IAxCOIiEhIQ3AyggAyABQcAAaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gy\
AMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIN\
NwNAIAMgAUE4aikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgI\
DwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIONwM4IAMgAUEw\
aikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQg\
iIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIPNwMwIAMpAwAhECADKQMIIREg\
AykDECESIAMpAxghEyADKQMgIRQgAykDKCEVIAMgAUHIAGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AI\
OEIAxCGIZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIo\
iEKA/gODIAxCOIiEhIQiFjcDSCADIAFB0ABqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQo\
CAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAM\
QjiIhISEIhc3A1AgAyABQdgAaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gy\
AMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIY\
NwNYIAMgAUHgAGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGIZCgICAgIDgP4MgDEIIhkKAgI\
CA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gODIAxCOIiEhIQiGTcDYCADIAFB\
6ABqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIA\
xCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIho3A2ggAyABQfAAaikAACIM\
QjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgP\
gPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIMNwNwIAMgAUH4AGopAAAiG0I4hiAbQiiG\
QoCAgICAgMD/AIOEIBtCGIZCgICAgIDgP4MgG0IIhkKAgICA8B+DhIQgG0IIiEKAgID4D4MgG0IYiE\
KAgPwHg4QgG0IoiEKA/gODIBtCOIiEhIQiGzcDeCALQiSJIAtCHomFIAtCGYmFIAogCYUgC4MgCiAJ\
g4V8IBAgBCAGIAWFIAeDIAWFfCAHQjKJIAdCLomFIAdCF4mFfHxCotyiuY3zi8XCAHwiHHwiHUIkiS\
AdQh6JhSAdQhmJhSAdIAsgCoWDIAsgCoOFfCAFIBF8IBwgCHwiHiAHIAaFgyAGhXwgHkIyiSAeQi6J\
hSAeQheJhXxCzcu9n5KS0ZvxAHwiH3wiHEIkiSAcQh6JhSAcQhmJhSAcIB0gC4WDIB0gC4OFfCAGIB\
J8IB8gCXwiICAeIAeFgyAHhXwgIEIyiSAgQi6JhSAgQheJhXxCr/a04v75vuC1f3wiIXwiH0IkiSAf\
Qh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCAHIBN8ICEgCnwiIiAgIB6FgyAehXwgIkIyiSAiQi6JhS\
AiQheJhXxCvLenjNj09tppfCIjfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8IB4gFHwg\
IyALfCIjICIgIIWDICCFfCAjQjKJICNCLomFICNCF4mFfEK46qKav8uwqzl8IiR8Ih5CJIkgHkIeiY\
UgHkIZiYUgHiAhIB+FgyAhIB+DhXwgFSAgfCAkIB18IiAgIyAihYMgIoV8ICBCMokgIEIuiYUgIEIX\
iYV8Qpmgl7CbvsT42QB8IiR8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgDyAifCAkIB\
x8IiIgICAjhYMgI4V8ICJCMokgIkIuiYUgIkIXiYV8Qpuf5fjK1OCfkn98IiR8IhxCJIkgHEIeiYUg\
HEIZiYUgHCAdIB6FgyAdIB6DhXwgDiAjfCAkIB98IiMgIiAghYMgIIV8ICNCMokgI0IuiYUgI0IXiY\
V8QpiCttPd2peOq398IiR8Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgDSAgfCAkICF8\
IiAgIyAihYMgIoV8ICBCMokgIEIuiYUgIEIXiYV8QsKEjJiK0+qDWHwiJHwiIUIkiSAhQh6JhSAhQh\
mJhSAhIB8gHIWDIB8gHIOFfCAWICJ8ICQgHnwiIiAgICOFgyAjhXwgIkIyiSAiQi6JhSAiQheJhXxC\
vt/Bq5Tg1sESfCIkfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8IBcgI3wgJCAdfCIjIC\
IgIIWDICCFfCAjQjKJICNCLomFICNCF4mFfEKM5ZL35LfhmCR8IiR8Ih1CJIkgHUIeiYUgHUIZiYUg\
HSAeICGFgyAeICGDhXwgGCAgfCAkIBx8IiAgIyAihYMgIoV8ICBCMokgIEIuiYUgIEIXiYV8QuLp/q\
+9uJ+G1QB8IiR8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgGSAifCAkIB98IiIgICAj\
hYMgI4V8ICJCMokgIkIuiYUgIkIXiYV8Qu+S7pPPrpff8gB8IiR8Ih9CJIkgH0IeiYUgH0IZiYUgHy\
AcIB2FgyAcIB2DhXwgGiAjfCAkICF8IiMgIiAghYMgIIV8ICNCMokgI0IuiYUgI0IXiYV8QrGt2tjj\
v6zvgH98IiR8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgDCAgfCAkIB58IiQgIyAihY\
MgIoV8ICRCMokgJEIuiYUgJEIXiYV8QrWknK7y1IHum398IiB8Ih5CJIkgHkIeiYUgHkIZiYUgHiAh\
IB+FgyAhIB+DhXwgGyAifCAgIB18IiUgJCAjhYMgI4V8ICVCMokgJUIuiYUgJUIXiYV8QpTNpPvMrv\
zNQXwiInwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAQIBFCP4kgEUI4iYUgEUIHiIV8\
IBZ8IAxCLYkgDEIDiYUgDEIGiIV8IiAgI3wgIiAcfCIQICUgJIWDICSFfCAQQjKJIBBCLomFIBBCF4\
mFfELSlcX3mbjazWR8IiN8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgESASQj+JIBJC\
OImFIBJCB4iFfCAXfCAbQi2JIBtCA4mFIBtCBoiFfCIiICR8ICMgH3wiESAQICWFgyAlhXwgEUIyiS\
ARQi6JhSARQheJhXxC48u8wuPwkd9vfCIkfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8\
IBIgE0I/iSATQjiJhSATQgeIhXwgGHwgIEItiSAgQgOJhSAgQgaIhXwiIyAlfCAkICF8IhIgESAQhY\
MgEIV8IBJCMokgEkIuiYUgEkIXiYV8QrWrs9zouOfgD3wiJXwiIUIkiSAhQh6JhSAhQhmJhSAhIB8g\
HIWDIB8gHIOFfCATIBRCP4kgFEI4iYUgFEIHiIV8IBl8ICJCLYkgIkIDiYUgIkIGiIV8IiQgEHwgJS\
AefCITIBIgEYWDIBGFfCATQjKJIBNCLomFIBNCF4mFfELluLK9x7mohiR8IhB8Ih5CJIkgHkIeiYUg\
HkIZiYUgHiAhIB+FgyAhIB+DhXwgFCAVQj+JIBVCOImFIBVCB4iFfCAafCAjQi2JICNCA4mFICNCBo\
iFfCIlIBF8IBAgHXwiFCATIBKFgyAShXwgFEIyiSAUQi6JhSAUQheJhXxC9YSsyfWNy/QtfCIRfCId\
QiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IBUgD0I/iSAPQjiJhSAPQgeIhXwgDHwgJEItiS\
AkQgOJhSAkQgaIhXwiECASfCARIBx8IhUgFCAThYMgE4V8IBVCMokgFUIuiYUgFUIXiYV8QoPJm/Wm\
laG6ygB8IhJ8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgDkI/iSAOQjiJhSAOQgeIhS\
APfCAbfCAlQi2JICVCA4mFICVCBoiFfCIRIBN8IBIgH3wiDyAVIBSFgyAUhXwgD0IyiSAPQi6JhSAP\
QheJhXxC1PeH6su7qtjcAHwiE3wiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCANQj+JIA\
1COImFIA1CB4iFIA58ICB8IBBCLYkgEEIDiYUgEEIGiIV8IhIgFHwgEyAhfCIOIA8gFYWDIBWFfCAO\
QjKJIA5CLomFIA5CF4mFfEK1p8WYqJvi/PYAfCIUfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHy\
Acg4V8IBZCP4kgFkI4iYUgFkIHiIUgDXwgInwgEUItiSARQgOJhSARQgaIhXwiEyAVfCAUIB58Ig0g\
DiAPhYMgD4V8IA1CMokgDUIuiYUgDUIXiYV8Qqu/m/OuqpSfmH98IhV8Ih5CJIkgHkIeiYUgHkIZiY\
UgHiAhIB+FgyAhIB+DhXwgF0I/iSAXQjiJhSAXQgeIhSAWfCAjfCASQi2JIBJCA4mFIBJCBoiFfCIU\
IA98IBUgHXwiFiANIA6FgyAOhXwgFkIyiSAWQi6JhSAWQheJhXxCkOTQ7dLN8Ziof3wiD3wiHUIkiS\
AdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAYQj+JIBhCOImFIBhCB4iFIBd8ICR8IBNCLYkgE0ID\
iYUgE0IGiIV8IhUgDnwgDyAcfCIXIBYgDYWDIA2FfCAXQjKJIBdCLomFIBdCF4mFfEK/wuzHifnJgb\
B/fCIOfCIcQiSJIBxCHomFIBxCGYmFIBwgHSAehYMgHSAeg4V8IBlCP4kgGUI4iYUgGUIHiIUgGHwg\
JXwgFEItiSAUQgOJhSAUQgaIhXwiDyANfCAOIB98IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiY\
V8QuSdvPf7+N+sv398Ig18Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgGkI/iSAaQjiJ\
hSAaQgeIhSAZfCAQfCAVQi2JIBVCA4mFIBVCBoiFfCIOIBZ8IA0gIXwiFiAYIBeFgyAXhXwgFkIyiS\
AWQi6JhSAWQheJhXxCwp+i7bP+gvBGfCIZfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8\
IAxCP4kgDEI4iYUgDEIHiIUgGnwgEXwgD0ItiSAPQgOJhSAPQgaIhXwiDSAXfCAZIB58IhcgFiAYhY\
MgGIV8IBdCMokgF0IuiYUgF0IXiYV8QqXOqpj5qOTTVXwiGXwiHkIkiSAeQh6JhSAeQhmJhSAeICEg\
H4WDICEgH4OFfCAbQj+JIBtCOImFIBtCB4iFIAx8IBJ8IA5CLYkgDkIDiYUgDkIGiIV8IgwgGHwgGS\
AdfCIYIBcgFoWDIBaFfCAYQjKJIBhCLomFIBhCF4mFfELvhI6AnuqY5QZ8Ihl8Ih1CJIkgHUIeiYUg\
HUIZiYUgHSAeICGFgyAeICGDhXwgIEI/iSAgQjiJhSAgQgeIhSAbfCATfCANQi2JIA1CA4mFIA1CBo\
iFfCIbIBZ8IBkgHHwiFiAYIBeFgyAXhXwgFkIyiSAWQi6JhSAWQheJhXxC8Ny50PCsypQUfCIZfCIc\
QiSJIBxCHomFIBxCGYmFIBwgHSAehYMgHSAeg4V8ICJCP4kgIkI4iYUgIkIHiIUgIHwgFHwgDEItiS\
AMQgOJhSAMQgaIhXwiICAXfCAZIB98IhcgFiAYhYMgGIV8IBdCMokgF0IuiYUgF0IXiYV8QvzfyLbU\
0MLbJ3wiGXwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCAjQj+JICNCOImFICNCB4iFIC\
J8IBV8IBtCLYkgG0IDiYUgG0IGiIV8IiIgGHwgGSAhfCIYIBcgFoWDIBaFfCAYQjKJIBhCLomFIBhC\
F4mFfEKmkpvhhafIjS58Ihl8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgJEI/iSAkQj\
iJhSAkQgeIhSAjfCAPfCAgQi2JICBCA4mFICBCBoiFfCIjIBZ8IBkgHnwiFiAYIBeFgyAXhXwgFkIy\
iSAWQi6JhSAWQheJhXxC7dWQ1sW/m5bNAHwiGXwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4\
OFfCAlQj+JICVCOImFICVCB4iFICR8IA58ICJCLYkgIkIDiYUgIkIGiIV8IiQgF3wgGSAdfCIXIBYg\
GIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfELf59bsuaKDnNMAfCIZfCIdQiSJIB1CHomFIB1CGYmFIB\
0gHiAhhYMgHiAhg4V8IBBCP4kgEEI4iYUgEEIHiIUgJXwgDXwgI0ItiSAjQgOJhSAjQgaIhXwiJSAY\
fCAZIBx8IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8Qt7Hvd3I6pyF5QB8Ihl8IhxCJIkgHE\
IeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgEUI/iSARQjiJhSARQgeIhSAQfCAMfCAkQi2JICRCA4mF\
ICRCBoiFfCIQIBZ8IBkgH3wiFiAYIBeFgyAXhXwgFkIyiSAWQi6JhSAWQheJhXxCqOXe47PXgrX2AH\
wiGXwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCASQj+JIBJCOImFIBJCB4iFIBF8IBt8\
ICVCLYkgJUIDiYUgJUIGiIV8IhEgF3wgGSAhfCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfE\
Lm3ba/5KWy4YF/fCIZfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8IBNCP4kgE0I4iYUg\
E0IHiIUgEnwgIHwgEEItiSAQQgOJhSAQQgaIhXwiEiAYfCAZIB58IhggFyAWhYMgFoV8IBhCMokgGE\
IuiYUgGEIXiYV8QrvqiKTRkIu5kn98Ihl8Ih5CJIkgHkIeiYUgHkIZiYUgHiAhIB+FgyAhIB+DhXwg\
FEI/iSAUQjiJhSAUQgeIhSATfCAifCARQi2JIBFCA4mFIBFCBoiFfCITIBZ8IBkgHXwiFiAYIBeFgy\
AXhXwgFkIyiSAWQi6JhSAWQheJhXxC5IbE55SU+t+if3wiGXwiHUIkiSAdQh6JhSAdQhmJhSAdIB4g\
IYWDIB4gIYOFfCAVQj+JIBVCOImFIBVCB4iFIBR8ICN8IBJCLYkgEkIDiYUgEkIGiIV8IhQgF3wgGS\
AcfCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfEKB4Ijiu8mZjah/fCIZfCIcQiSJIBxCHomF\
IBxCGYmFIBwgHSAehYMgHSAeg4V8IA9CP4kgD0I4iYUgD0IHiIUgFXwgJHwgE0ItiSATQgOJhSATQg\
aIhXwiFSAYfCAZIB98IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8QpGv4oeN7uKlQnwiGXwi\
H0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCAOQj+JIA5COImFIA5CB4iFIA98ICV8IBRCLY\
kgFEIDiYUgFEIGiIV8Ig8gFnwgGSAhfCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfEKw/NKy\
sLSUtkd8Ihl8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgDUI/iSANQjiJhSANQgeIhS\
AOfCAQfCAVQi2JIBVCA4mFIBVCBoiFfCIOIBd8IBkgHnwiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhSAX\
QheJhXxCmKS9t52DuslRfCIZfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8IAxCP4kgDE\
I4iYUgDEIHiIUgDXwgEXwgD0ItiSAPQgOJhSAPQgaIhXwiDSAYfCAZIB18IhggFyAWhYMgFoV8IBhC\
MokgGEIuiYUgGEIXiYV8QpDSlqvFxMHMVnwiGXwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIY\
OFfCAbQj+JIBtCOImFIBtCB4iFIAx8IBJ8IA5CLYkgDkIDiYUgDkIGiIV8IgwgFnwgGSAcfCIWIBgg\
F4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfEKqwMS71bCNh3R8Ihl8IhxCJIkgHEIeiYUgHEIZiYUgHC\
AdIB6FgyAdIB6DhXwgIEI/iSAgQjiJhSAgQgeIhSAbfCATfCANQi2JIA1CA4mFIA1CBoiFfCIbIBd8\
IBkgH3wiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhSAXQheJhXxCuKPvlYOOqLUQfCIZfCIfQiSJIB9CHo\
mFIB9CGYmFIB8gHCAdhYMgHCAdg4V8ICJCP4kgIkI4iYUgIkIHiIUgIHwgFHwgDEItiSAMQgOJhSAM\
QgaIhXwiICAYfCAZICF8IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8Qsihy8brorDSGXwiGX\
wiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCAjQj+JICNCOImFICNCB4iFICJ8IBV8IBtC\
LYkgG0IDiYUgG0IGiIV8IiIgFnwgGSAefCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfELT1o\
aKhYHbmx58Ihl8Ih5CJIkgHkIeiYUgHkIZiYUgHiAhIB+FgyAhIB+DhXwgJEI/iSAkQjiJhSAkQgeI\
hSAjfCAPfCAgQi2JICBCA4mFICBCBoiFfCIjIBd8IBkgHXwiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhS\
AXQheJhXxCmde7/M3pnaQnfCIZfCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8ICVCP4kg\
JUI4iYUgJUIHiIUgJHwgDnwgIkItiSAiQgOJhSAiQgaIhXwiJCAYfCAZIBx8IhggFyAWhYMgFoV8IB\
hCMokgGEIuiYUgGEIXiYV8QqiR7Yzelq/YNHwiGXwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0g\
HoOFfCAQQj+JIBBCOImFIBBCB4iFICV8IA18ICNCLYkgI0IDiYUgI0IGiIV8IiUgFnwgGSAffCIWIB\
ggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfELjtKWuvJaDjjl8Ihl8Ih9CJIkgH0IeiYUgH0IZiYUg\
HyAcIB2FgyAcIB2DhXwgEUI/iSARQjiJhSARQgeIhSAQfCAMfCAkQi2JICRCA4mFICRCBoiFfCIQIB\
d8IBkgIXwiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhSAXQheJhXxCy5WGmq7JquzOAHwiGXwiIUIkiSAh\
Qh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCASQj+JIBJCOImFIBJCB4iFIBF8IBt8ICVCLYkgJUIDiY\
UgJUIGiIV8IhEgGHwgGSAefCIYIBcgFoWDIBaFfCAYQjKJIBhCLomFIBhCF4mFfELzxo+798myztsA\
fCIZfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8IBNCP4kgE0I4iYUgE0IHiIUgEnwgIH\
wgEEItiSAQQgOJhSAQQgaIhXwiEiAWfCAZIB18IhYgGCAXhYMgF4V8IBZCMokgFkIuiYUgFkIXiYV8\
QqPxyrW9/puX6AB8Ihl8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgFEI/iSAUQjiJhS\
AUQgeIhSATfCAifCARQi2JIBFCA4mFIBFCBoiFfCITIBd8IBkgHHwiFyAWIBiFgyAYhXwgF0IyiSAX\
Qi6JhSAXQheJhXxC/OW+7+Xd4Mf0AHwiGXwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfC\
AVQj+JIBVCOImFIBVCB4iFIBR8ICN8IBJCLYkgEkIDiYUgEkIGiIV8IhQgGHwgGSAffCIYIBcgFoWD\
IBaFfCAYQjKJIBhCLomFIBhCF4mFfELg3tyY9O3Y0vgAfCIZfCIfQiSJIB9CHomFIB9CGYmFIB8gHC\
AdhYMgHCAdg4V8IA9CP4kgD0I4iYUgD0IHiIUgFXwgJHwgE0ItiSATQgOJhSATQgaIhXwiFSAWfCAZ\
ICF8IhYgGCAXhYMgF4V8IBZCMokgFkIuiYUgFkIXiYV8QvLWwo/Kgp7khH98Ihl8IiFCJIkgIUIeiY\
UgIUIZiYUgISAfIByFgyAfIByDhXwgDkI/iSAOQjiJhSAOQgeIhSAPfCAlfCAUQi2JIBRCA4mFIBRC\
BoiFfCIPIBd8IBkgHnwiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhSAXQheJhXxC7POQ04HBwOOMf3wiGX\
wiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCANQj+JIA1COImFIA1CB4iFIA58IBB8IBVC\
LYkgFUIDiYUgFUIGiIV8Ig4gGHwgGSAdfCIYIBcgFoWDIBaFfCAYQjKJIBhCLomFIBhCF4mFfEKovI\
ybov+/35B/fCIZfCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IAxCP4kgDEI4iYUgDEIH\
iIUgDXwgEXwgD0ItiSAPQgOJhSAPQgaIhXwiDSAWfCAZIBx8IhYgGCAXhYMgF4V8IBZCMokgFkIuiY\
UgFkIXiYV8Qun7ivS9nZuopH98Ihl8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgG0I/\
iSAbQjiJhSAbQgeIhSAMfCASfCAOQi2JIA5CA4mFIA5CBoiFfCIMIBd8IBkgH3wiFyAWIBiFgyAYhX\
wgF0IyiSAXQi6JhSAXQheJhXxClfKZlvv+6Py+f3wiGXwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWD\
IBwgHYOFfCAgQj+JICBCOImFICBCB4iFIBt8IBN8IA1CLYkgDUIDiYUgDUIGiIV8IhsgGHwgGSAhfC\
IYIBcgFoWDIBaFfCAYQjKJIBhCLomFIBhCF4mFfEKrpsmbrp7euEZ8Ihl8IiFCJIkgIUIeiYUgIUIZ\
iYUgISAfIByFgyAfIByDhXwgIkI/iSAiQjiJhSAiQgeIhSAgfCAUfCAMQi2JIAxCA4mFIAxCBoiFfC\
IgIBZ8IBkgHnwiFiAYIBeFgyAXhXwgFkIyiSAWQi6JhSAWQheJhXxCnMOZ0e7Zz5NKfCIafCIeQiSJ\
IB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8ICNCP4kgI0I4iYUgI0IHiIUgInwgFXwgG0ItiSAbQg\
OJhSAbQgaIhXwiGSAXfCAaIB18IiIgFiAYhYMgGIV8ICJCMokgIkIuiYUgIkIXiYV8QoeEg47ymK7D\
UXwiGnwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAkQj+JICRCOImFICRCB4iFICN8IA\
98ICBCLYkgIEIDiYUgIEIGiIV8IhcgGHwgGiAcfCIjICIgFoWDIBaFfCAjQjKJICNCLomFICNCF4mF\
fEKe1oPv7Lqf7Wp8Ihp8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgJUI/iSAlQjiJhS\
AlQgeIhSAkfCAOfCAZQi2JIBlCA4mFIBlCBoiFfCIYIBZ8IBogH3wiJCAjICKFgyAihXwgJEIyiSAk\
Qi6JhSAkQheJhXxC+KK78/7v0751fCIWfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8IB\
BCP4kgEEI4iYUgEEIHiIUgJXwgDXwgF0ItiSAXQgOJhSAXQgaIhXwiJSAifCAWICF8IiIgJCAjhYMg\
I4V8ICJCMokgIkIuiYUgIkIXiYV8Qrrf3ZCn9Zn4BnwiFnwiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHI\
WDIB8gHIOFfCARQj+JIBFCOImFIBFCB4iFIBB8IAx8IBhCLYkgGEIDiYUgGEIGiIV8IhAgI3wgFiAe\
fCIjICIgJIWDICSFfCAjQjKJICNCLomFICNCF4mFfEKmsaKW2rjfsQp8IhZ8Ih5CJIkgHkIeiYUgHk\
IZiYUgHiAhIB+FgyAhIB+DhXwgEkI/iSASQjiJhSASQgeIhSARfCAbfCAlQi2JICVCA4mFICVCBoiF\
fCIRICR8IBYgHXwiJCAjICKFgyAihXwgJEIyiSAkQi6JhSAkQheJhXxCrpvk98uA5p8RfCIWfCIdQi\
SJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IBNCP4kgE0I4iYUgE0IHiIUgEnwgIHwgEEItiSAQ\
QgOJhSAQQgaIhXwiEiAifCAWIBx8IiIgJCAjhYMgI4V8ICJCMokgIkIuiYUgIkIXiYV8QpuO8ZjR5s\
K4G3wiFnwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAUQj+JIBRCOImFIBRCB4iFIBN8\
IBl8IBFCLYkgEUIDiYUgEUIGiIV8IhMgI3wgFiAffCIjICIgJIWDICSFfCAjQjKJICNCLomFICNCF4\
mFfEKE+5GY0v7d7Sh8IhZ8Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgFUI/iSAVQjiJ\
hSAVQgeIhSAUfCAXfCASQi2JIBJCA4mFIBJCBoiFfCIUICR8IBYgIXwiJCAjICKFgyAihXwgJEIyiS\
AkQi6JhSAkQheJhXxCk8mchrTvquUyfCIWfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8\
IA9CP4kgD0I4iYUgD0IHiIUgFXwgGHwgE0ItiSATQgOJhSATQgaIhXwiFSAifCAWIB58IiIgJCAjhY\
MgI4V8ICJCMokgIkIuiYUgIkIXiYV8Qrz9pq6hwa/PPHwiFnwiHkIkiSAeQh6JhSAeQhmJhSAeICEg\
H4WDICEgH4OFfCAOQj+JIA5COImFIA5CB4iFIA98ICV8IBRCLYkgFEIDiYUgFEIGiIV8IiUgI3wgFi\
AdfCIjICIgJIWDICSFfCAjQjKJICNCLomFICNCF4mFfELMmsDgyfjZjsMAfCIUfCIdQiSJIB1CHomF\
IB1CGYmFIB0gHiAhhYMgHiAhg4V8IA1CP4kgDUI4iYUgDUIHiIUgDnwgEHwgFUItiSAVQgOJhSAVQg\
aIhXwiECAkfCAUIBx8IiQgIyAihYMgIoV8ICRCMokgJEIuiYUgJEIXiYV8QraF+dnsl/XizAB8IhR8\
IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgDEI/iSAMQjiJhSAMQgeIhSANfCARfCAlQi\
2JICVCA4mFICVCBoiFfCIlICJ8IBQgH3wiHyAkICOFgyAjhXwgH0IyiSAfQi6JhSAfQheJhXxCqvyV\
48+zyr/ZAHwiEXwiIkIkiSAiQh6JhSAiQhmJhSAiIBwgHYWDIBwgHYOFfCAMIBtCP4kgG0I4iYUgG0\
IHiIV8IBJ8IBBCLYkgEEIDiYUgEEIGiIV8ICN8IBEgIXwiDCAfICSFgyAkhXwgDEIyiSAMQi6JhSAM\
QheJhXxC7PXb1rP12+XfAHwiI3wiISAiIByFgyAiIByDhSALfCAhQiSJICFCHomFICFCGYmFfCAbIC\
BCP4kgIEI4iYUgIEIHiIV8IBN8ICVCLYkgJUIDiYUgJUIGiIV8ICR8ICMgHnwiGyAMIB+FgyAfhXwg\
G0IyiSAbQi6JhSAbQheJhXxCl7Cd0sSxhqLsAHwiHnwhCyAhIAp8IQogHSAHfCAefCEHICIgCXwhCS\
AbIAZ8IQYgHCAIfCEIIAwgBXwhBSAfIAR8IQQgAUGAAWoiASACRw0ACwsgACAENwM4IAAgBTcDMCAA\
IAY3AyggACAHNwMgIAAgCDcDGCAAIAk3AxAgACAKNwMIIAAgCzcDACADQYABaiQAC/hbAgx/BX4jAE\
GABmsiBCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDgIAAQILIAEo\
AgAiAkECdEG008AAaigCACEDDBELQSAhBSABKAIAIgIOGAEPAg8QAw8EBQYGBwcIDwkKCw8MDRAQDg\
ELIAEoAgAhAgwPC0HAACEFDA0LQTAhBQwMC0EcIQUMCwtBMCEFDAoLQcAAIQUMCQtBECEFDAgLQRQh\
BQwHC0EcIQUMBgtBMCEFDAULQcAAIQUMBAtBHCEFDAMLQTAhBQwCC0HAACEFDAELQRghBQsgBSADRg\
0AQQEhAUE5IQNBrYHAACECDAELAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAIAIOGAABAgMEBQYHCAkKCwwNDg8QERITFBUWGgALIAEoAgQhAiAEQdAEakEMakIANwIAIARB\
0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQSxqQgA3AgAgBEHQBG\
pBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1AQgBEHAADYC0AQgBEEoaiAEQdAEakHEABA6GiAE\
QaADakE4aiIGIARBKGpBPGopAgA3AwAgBEGgA2pBMGoiByAEQShqQTRqKQIANwMAIARBoANqQShqIg\
ggBEEoakEsaikCADcDACAEQaADakEgaiIJIARBKGpBJGopAgA3AwAgBEGgA2pBGGoiCiAEQShqQRxq\
KQIANwMAIARBoANqQRBqIgsgBEEoakEUaikCADcDACAEQaADakEIaiIMIARBKGpBDGopAgA3AwAgBC\
AEKQIsNwOgAyACIAIpA0AgAkHIAWoiAy0AACIBrXw3A0AgAkHIAGohBQJAIAFBgAFGDQAgBSABakEA\
QYABIAFrEDsaC0EAIQEgA0EAOgAAIAIgBUJ/EBEgBEEoakEIaiIFIAJBCGopAwAiEDcDACAEQShqQR\
BqIAJBEGopAwAiETcDACAEQShqQRhqIAJBGGopAwAiEjcDACAEQShqQSBqIAIpAyAiEzcDACAEQShq\
QShqIAJBKGopAwAiFDcDACAMIBA3AwAgCyARNwMAIAogEjcDACAJIBM3AwAgCCAUNwMAIAcgAkEwai\
kDADcDACAGIAJBOGopAwA3AwAgBCACKQMAIhA3AyggBCAQNwOgAyAFQcAAEFAgAiAFQcgAEDoaIANB\
ADoAAEHAABAWIgJFDRogAiAEKQOgAzcAACACQThqIARBoANqQThqKQMANwAAIAJBMGogBEGgA2pBMG\
opAwA3AAAgAkEoaiAEQaADakEoaikDADcAACACQSBqIARBoANqQSBqKQMANwAAIAJBGGogBEGgA2pB\
GGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIARBoANqQQhqKQMANwAAQcAAIQMMMgsgAS\
gCBCECIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEMakIANwIAIARCADcC1AQgBEEg\
NgLQBCAEQShqQRhqIgcgBEHQBGpBGGopAwA3AwAgBEEoakEQaiIIIARB0ARqQRBqKQMANwMAIARBKG\
pBCGoiAyAEQdAEakEIaikDADcDACAEQShqQSBqIgkgBEHQBGpBIGooAgA2AgAgBCAEKQPQBDcDKCAE\
QaADakEQaiIKIARBKGpBFGopAgA3AwAgBEGgA2pBCGoiCyAEQShqQQxqKQIANwMAIARBoANqQRhqIg\
wgBEEoakEcaikCADcDACAEIAQpAiw3A6ADIAIgAikDQCACQcgBaiIFLQAAIgGtfDcDQCACQcgAaiEG\
AkAgAUGAAUYNACAGIAFqQQBBgAEgAWsQOxoLQQAhASAFQQA6AAAgAiAGQn8QESADIAJBCGopAwAiED\
cDACAIIAJBEGopAwAiETcDACAHIAJBGGopAwAiEjcDACAJIAIpAyA3AwAgBEEoakEoaiACQShqKQMA\
NwMAIAsgEDcDACAKIBE3AwAgDCASNwMAIAQgAikDACIQNwMoIAQgEDcDoAMgA0EgEFAgAiADQcgAED\
oaIAVBADoAAEEgEBYiAkUNGiACIAQpA6ADNwAAIAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaAD\
akEQaikDADcAACACQQhqIARBoANqQQhqKQMANwAAQSAhAwwxCyABKAIEIQIgBEHQBGpBLGpCADcCAC\
AEQdAEakEkakIANwIAIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEMakIANwIAIARC\
ADcC1AQgBEEwNgLQBCAEQShqQShqIgcgBEHQBGpBKGopAwA3AwAgBEEoakEgaiIIIARB0ARqQSBqKQ\
MANwMAIARBKGpBGGoiCSAEQdAEakEYaikDADcDACAEQShqQRBqIgogBEHQBGpBEGopAwA3AwAgBEEo\
akEIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBMGogBEHQBGpBMGooAgA2AgAgBCAEKQPQBDcDKCAEQa\
ADakEgaiILIARBKGpBJGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIANwMAIARBoANqQRBqIg0g\
BEEoakEUaikCADcDACAEQaADakEIaiIOIARBKGpBDGopAgA3AwAgBEGgA2pBKGoiDyAEQShqQSxqKQ\
IANwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYCQCABQYABRg0A\
IAYgAWpBAEGAASABaxA7GgtBACEBIAVBADoAACACIAZCfxARIAMgAkEIaikDACIQNwMAIAogAkEQai\
kDACIRNwMAIAkgAkEYaikDACISNwMAIAggAikDICITNwMAIAcgAkEoaikDACIUNwMAIA4gEDcDACAN\
IBE3AwAgDCASNwMAIAsgEzcDACAPIBQ3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQTAQUCACIANByA\
AQOhogBUEAOgAAQTAQFiICRQ0aIAIgBCkDoAM3AAAgAkEoaiAEQaADakEoaikDADcAACACQSBqIARB\
oANqQSBqKQMANwAAIAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIA\
RBoANqQQhqKQMANwAAQTAhAwwwCyABKAIEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB\
0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGGoiByAEQdAEakEYaikDADcDACAEQShqQR\
BqIgggBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBIGoiCSAEQdAE\
akEgaigCADYCACAEIAQpA9AENwMoIARBoANqQRBqIgogBEEoakEUaikCADcDACAEQaADakEIaiILIA\
RBKGpBDGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQMAIAJB\
6ABqIgUtAAAiAa18NwMAIAJBKGohBgJAIAFBwABGDQAgBiABakEAQcAAIAFrEDsaC0EAIQEgBUEAOg\
AAIAIgBkF/EBMgAyACQRBqIgYpAgAiEDcDACALIBA3AwAgCiACQRhqIgspAgA3AwAgDCACQSBqIgop\
AgA3AwAgBCACQQhqIgwpAgAiEDcDKCAEIBA3A6ADIAMQVyAKIARBKGpBKGopAwA3AwAgCyAJKQMANw\
MAIAYgBykDADcDACAMIAgpAwA3AwAgAiAEKQMwNwMAIAVBADoAAEEgEBYiAkUNGiACIAQpA6ADNwAA\
IAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIARBoANqQQhqKQMANw\
AAQSAhAwwvCyADQQBIDRIgASgCBCEFAkACQCADDQBBASECDAELIAMQFiICRQ0bIAJBfGotAABBA3FF\
DQAgAkEAIAMQOxoLIARBKGogBRAjIAVCADcDACAFQSBqIAVBiAFqKQMANwMAIAVBGGogBUGAAWopAw\
A3AwAgBUEQaiAFQfgAaikDADcDACAFIAUpA3A3AwhBACEBIAVBKGpBAEHCABA7GgJAIAUoApABRQ0A\
IAVBADYCkAELIARBKGogAiADEBgMLgsgASgCBCIFIAVB2AJqIgYtAAAiAWpByAFqIQMCQCABQZABRg\
0AIANBAEGQASABaxA7GgtBACECIAZBADoAACADQQE6AAAgBUHXAmoiASABLQAAQYABcjoAAANAIAUg\
AmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAA\
AgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJBkAFHDQALIAUQJCAE\
QShqQRhqIgYgBUEYaigAADYCACAEQShqQRBqIgcgBUEQaikAADcDACAEQShqQQhqIgggBUEIaikAAD\
cDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdgCakEAOgAAQRwhA0EcEBYiAkUNGiACIAQpAyg3AAAg\
AkEYaiAGKAIANgAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAMLQsgASgCBCIFIAVB0AJqIgYtAA\
AiAWpByAFqIQMCQCABQYgBRg0AIANBAEGIASABaxA7GgtBACECIAZBADoAACADQQE6AAAgBUHPAmoi\
ASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai\
0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACAC\
QQRqIgJBiAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaikAADcDACAEQShqQRBqIgcgBUEQaikAADcDAC\
AEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdACakEAOgAAQSAhA0Eg\
EBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKQMANwAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAMLA\
sgASgCBCIFIAVBsAJqIgYtAAAiAWpByAFqIQMCQCABQegARg0AIANBAEHoACABaxA7GgtBACECIAZB\
ADoAACADQQE6AAAgBUGvAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAAC\
ABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyAD\
LQAAIAFBywFqLQAAczoAACACQQRqIgJB6ABHDQALIAUQJCAEQShqQShqIgYgBUEoaikAADcDACAEQS\
hqQSBqIgcgBUEgaikAADcDACAEQShqQRhqIgggBUEYaikAADcDACAEQShqQRBqIgkgBUEQaikAADcD\
ACAEQShqQQhqIgogBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QbACakEAOgAAQTAhA0\
EwEBYiAkUNGiACIAQpAyg3AAAgAkEoaiAGKQMANwAAIAJBIGogBykDADcAACACQRhqIAgpAwA3AAAg\
AkEQaiAJKQMANwAAIAJBCGogCikDADcAAAwrCyABKAIEIgUgBUGQAmoiBi0AACIBakHIAWohAwJAIA\
FByABGDQAgA0EAQcgAIAFrEDsaC0EAIQIgBkEAOgAAIANBAToAACAFQY8CaiIBIAEtAABBgAFyOgAA\
A0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIg\
MgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkHIAEcNAAsg\
BRAkIARBKGpBOGoiBiAFQThqKQAANwMAIARBKGpBMGoiByAFQTBqKQAANwMAIARBKGpBKGoiCCAFQS\
hqKQAANwMAIARBKGpBIGoiCSAFQSBqKQAANwMAIARBKGpBGGoiCiAFQRhqKQAANwMAIARBKGpBEGoi\
CyAFQRBqKQAANwMAIARBKGpBCGoiDCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDtBkA\
JqQQA6AABBwAAhA0HAABAWIgJFDRogAiAEKQMoNwAAIAJBOGogBikDADcAACACQTBqIAcpAwA3AAAg\
AkEoaiAIKQMANwAAIAJBIGogCSkDADcAACACQRhqIAopAwA3AAAgAkEQaiALKQMANwAAIAJBCGogDC\
kDADcAAAwqCyABKAIEIQIgBEHQBGpBDGpCADcCACAEQgA3AtQEQRAhAyAEQRA2AtAEIARBKGpBEGog\
BEHQBGpBEGooAgA2AgAgBEEoakEIaiAEQdAEakEIaikDADcDACAEQaADakEIaiIFIARBKGpBDGopAg\
A3AwAgBCAEKQPQBDcDKCAEIAQpAiw3A6ADIAIgAkEYaiAEQaADahAvQQAhASACQdgAakEAOgAAIAJB\
EGpC/rnrxemOlZkQNwMAIAJCgcaUupbx6uZvNwMIIAJCADcDAEEQEBYiAkUNGiACIAQpA6ADNwAAIA\
JBCGogBSkDADcAAAwpCyABKAIEIQIgBEHQBGpBDGpCADcCACAEQgA3AtQEQRAhAyAEQRA2AtAEIARB\
KGpBEGogBEHQBGpBEGooAgA2AgAgBEEoakEIaiAEQdAEakEIaikDADcDACAEQaADakEIaiIFIARBKG\
pBDGopAgA3AwAgBCAEKQPQBDcDKCAEIAQpAiw3A6ADIAIgAkEYaiAEQaADahAuQQAhASACQdgAakEA\
OgAAIAJBEGpC/rnrxemOlZkQNwMAIAJCgcaUupbx6uZvNwMIIAJCADcDAEEQEBYiAkUNGiACIAQpA6\
ADNwAAIAJBCGogBSkDADcAAAwoCyABKAIEIQJBFCEDQQAhASAEQdAEakEUakEANgIAIARB0ARqQQxq\
QgA3AgAgBEIANwLUBCAEQRQ2AtAEIARBKGpBEGogBEHQBGpBEGopAwA3AwAgBEEoakEIaiAEQdAEak\
EIaikDADcDACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBEGgA2pBEGoiBiAEQShqQRRqKAIANgIA\
IAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQLSACQgA3AwAgAkHgAGpBADoAACACQQ\
ApA9iNQDcDCCACQRBqQQApA+CNQDcDACACQRhqQQAoAuiNQDYCAEEUEBYiAkUNGiACIAQpA6ADNwAA\
IAJBEGogBigCADYAACACQQhqIAUpAwA3AAAMJwsgASgCBCECQRQhA0EAIQEgBEHQBGpBFGpBADYCAC\
AEQdAEakEMakIANwIAIARCADcC1AQgBEEUNgLQBCAEQShqQRBqIARB0ARqQRBqKQMANwMAIARBKGpB\
CGogBEHQBGpBCGopAwA3AwAgBEGgA2pBCGoiBSAEQShqQQxqKQIANwMAIARBoANqQRBqIgYgBEEoak\
EUaigCADYCACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQSBqIARBoANqECggAkHgAGpBADoAACAC\
QRhqQfDDy558NgIAIAJBEGpC/rnrxemOlZkQNwMAIAJCgcaUupbx6uZvNwMIIAJCADcDAEEUEBYiAk\
UNGiACIAQpA6ADNwAAIAJBEGogBigCADYAACACQQhqIAUpAwA3AAAMJgsgASgCBCIFIAVB2AJqIgYt\
AAAiAWpByAFqIQMCQCABQZABRg0AIANBAEGQASABaxA7GgtBACECIAZBADoAACADQQY6AAAgBUHXAm\
oiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckB\
ai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAAC\
ACQQRqIgJBkAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaigAADYCACAEQShqQRBqIgcgBUEQaikAADcD\
ACAEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdgCakEAOgAAQRwhA0\
EcEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKAIANgAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAM\
JQsgASgCBCIFIAVB0AJqIgYtAAAiAWpByAFqIQMCQCABQYgBRg0AIANBAEGIASABaxA7GgtBACECIA\
ZBADoAACADQQY6AAAgBUHPAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoA\
ACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAy\
ADLQAAIAFBywFqLQAAczoAACACQQRqIgJBiAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaikAADcDACAE\
QShqQRBqIgcgBUEQaikAADcDACAEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAE\
HIARA7QdACakEAOgAAQSAhA0EgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKQMANwAAIAJBEGogBykD\
ADcAACACQQhqIAgpAwA3AAAMJAsgASgCBCIFIAVBsAJqIgYtAAAiAWpByAFqIQMCQCABQegARg0AIA\
NBAEHoACABaxA7GgtBACECIAZBADoAACADQQY6AAAgBUGvAmoiASABLQAAQYABcjoAAANAIAUgAmoi\
ASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAU\
HKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJB6ABHDQALIAUQJCAEQShq\
QShqIgYgBUEoaikAADcDACAEQShqQSBqIgcgBUEgaikAADcDACAEQShqQRhqIgggBUEYaikAADcDAC\
AEQShqQRBqIgkgBUEQaikAADcDACAEQShqQQhqIgogBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVB\
AEHIARA7QbACakEAOgAAQTAhA0EwEBYiAkUNGiACIAQpAyg3AAAgAkEoaiAGKQMANwAAIAJBIGogBy\
kDADcAACACQRhqIAgpAwA3AAAgAkEQaiAJKQMANwAAIAJBCGogCikDADcAAAwjCyABKAIEIgUgBUGQ\
AmoiBi0AACIBakHIAWohAwJAIAFByABGDQAgA0EAQcgAIAFrEDsaC0EAIQIgBkEAOgAAIANBBjoAAC\
AFQY8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAA\
IAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAA\
BzOgAAIAJBBGoiAkHIAEcNAAsgBRAkIARBKGpBOGoiBiAFQThqKQAANwMAIARBKGpBMGoiByAFQTBq\
KQAANwMAIARBKGpBKGoiCCAFQShqKQAANwMAIARBKGpBIGoiCSAFQSBqKQAANwMAIARBKGpBGGoiCi\
AFQRhqKQAANwMAIARBKGpBEGoiCyAFQRBqKQAANwMAIARBKGpBCGoiDCAFQQhqKQAANwMAIAQgBSkA\
ADcDKEEAIQEgBUEAQcgBEDtBkAJqQQA6AABBwAAhA0HAABAWIgJFDRogAiAEKQMoNwAAIAJBOGogBi\
kDADcAACACQTBqIAcpAwA3AAAgAkEoaiAIKQMANwAAIAJBIGogCSkDADcAACACQRhqIAopAwA3AAAg\
AkEQaiALKQMANwAAIAJBCGogDCkDADcAAAwiCyABKAIEIQJBHCEDIARB0ARqQRxqQgA3AgAgBEHQBG\
pBFGpCADcCACAEQdAEakEMakIANwIAIARCADcC1AQgBEEgNgLQBCAEQShqQRhqIgUgBEHQBGpBGGop\
AwA3AwAgBEEoakEQaiIGIARB0ARqQRBqKQMANwMAIARBKGpBCGoiByAEQdAEakEIaikDADcDACAEQS\
hqQSBqIARB0ARqQSBqKAIANgIAIAQgBCkD0AQ3AyggBEGgA2pBEGoiASAEQShqQRRqKQIANwMAIARB\
oANqQQhqIgggBEEoakEMaikCADcDACAEQaADakEYaiIJIARBKGpBHGopAgA3AwAgBCAEKQIsNwOgAy\
ACIAJBKGogBEGgA2oQJyAFIAkoAgA2AgAgBiABKQMANwMAIAcgCCkDADcDACAEIAQpA6ADNwMoIAJC\
ADcDAEEAIQEgAkHoAGpBADoAACACQQApA5COQDcDCCACQRBqQQApA5iOQDcDACACQRhqQQApA6COQD\
cDACACQSBqQQApA6iOQDcDAEEcEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAFKAIANgAAIAJBEGogBikD\
ADcAACACQQhqIAcpAwA3AAAMIQsgASgCBCECIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQd\
AEakEMakIANwIAIARCADcC1ARBICEDIARBIDYC0AQgBEEoakEgaiAEQdAEakEgaigCADYCACAEQShq\
QRhqIgUgBEHQBGpBGGopAwA3AwAgBEEoakEQaiIGIARB0ARqQRBqKQMANwMAIARBKGpBCGoiByAEQd\
AEakEIaikDADcDACAEIAQpA9AENwMoIARBoANqQRhqIgEgBEEoakEcaikCADcDACAEQaADakEQaiII\
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\
AEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBE\
EEIAQbEQUAAAtBIEEBQQAoAvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIgRBBCAEGxEFAAALQRxB\
AUEAKAL41EAiBEEEIAQbEQUAAAtBIEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EwQQFBACgC+NRAIgRBBC\
AEGxEFAAALQcAAQQFBACgC+NRAIgRBBCAEGxEFAAALQRBBAUEAKAL41EAiBEEEIAQbEQUAAAtBEEEB\
QQAoAvjUQCIEQQQgBBsRBQAAC0EUQQFBACgC+NRAIgRBBCAEGxEFAAALQRRBAUEAKAL41EAiBEEEIA\
QbEQUAAAtBHEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEA\
KAL41EAiBEEEIAQbEQUAAAtBwABBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEBQQAoAvjUQCIEQQQgBB\
sRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIAQbEQUAAAtBwABBAUEA\
KAL41EAiBEEEIAQbEQUAAAsgA0EBQQAoAvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIgRBBCAEGx\
EFAAALQRhBAUEAKAL41EAiBEEEIAQbEQUAAAsgACACNgIEIAAgATYCACAAQQhqIAM2AgAgBEGABmok\
AAucVgIafwJ+IwBBsAJrIgMkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAOGAABAg\
MEBQYHCAkKCwwNDg8QERITFBUWFwALIAAoAgQiAEHIAGohBAJAQYABIABByAFqLQAAIgVrIgYgAk8N\
AAJAIAVFDQAgBCAFaiABIAYQOhogACAAKQNAQoABfDcDQCAAIARCABARIAEgBmohASACIAZrIQILIA\
IgAkEHdiIGIAJBAEcgAkH/AHFFcSIHayIFQQd0IghrIQIgBUUNRSAIRQ1FIAZBACAHa2pBB3QhBiAB\
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\
OgAAIABBAmoiAiACLQAAIAZBAmotAABzOgAAIABBA2oiACAALQAAIAZBA2otAABzOgAAIAVBBGoiBU\
GIAUcNAAsgBBAkIAghASAIIAdGDRgMAAsLIAogAGogASACEDoaIAAgAmohCQwXCyAAKAIEIgRByAFq\
IQoCQEHoACAEQbACai0AACIAayIIIAJLDQACQCAARQ0AIAogAGogASAIEDoaIAIgCGshAkEAIQUDQC\
AEIAVqIgAgAC0AACAAQcgBai0AAHM6AAAgAEEBaiIGIAYtAAAgAEHJAWotAABzOgAAIABBAmoiBiAG\
LQAAIABBygFqLQAAczoAACAAQQNqIgYgBi0AACAAQcsBai0AAHM6AAAgBUEEaiIFQegARw0ACyAEEC\
QgASAIaiEBCyABIAJB6ABuQegAbCIAaiEHIAIgAGshCSACQecATQ0TIABFDRMDQCABQegAaiEIQQAh\
BQNAIAQgBWoiACAALQAAIAEgBWoiBi0AAHM6AAAgAEEBaiICIAItAAAgBkEBai0AAHM6AAAgAEECai\
ICIAItAAAgBkECai0AAHM6AAAgAEEDaiIAIAAtAAAgBkEDai0AAHM6AAAgBUEEaiIFQegARw0ACyAE\
ECQgCCEBIAggB0YNFAwACwsgCiAAaiABIAIQOhogACACaiEJDBMLIAAoAgQiBEHIAWohCgJAQcgAIA\
RBkAJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQOhogAiAIayECQQAhBQNAIAQgBWoiACAA\
LQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAW\
otAABzOgAAIABBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVByABHDQALIAQQJCABIAhqIQEL\
IAEgAkHIAG5ByABsIgBqIQcgAiAAayEJIAJBxwBNDQ8gAEUNDwNAIAFByABqIQhBACEFA0AgBCAFai\
IAIAAtAAAgASAFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAG\
QQJqLQAAczoAACAAQQNqIgAgAC0AACAGQQNqLQAAczoAACAFQQRqIgVByABHDQALIAQQJCAIIQEgCC\
AHRg0QDAALCyAKIABqIAEgAhA6GiAAIAJqIQkMDwsgACgCBCIAQShqIQYCQAJAQcAAIABB6ABqLQAA\
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\
CjYCHCADIAFBIGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgs2AiAgAyABQR\
hqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIMNgIYIAMoAgAhDSADKAIEIQ4g\
AygCCCEPIAMoAhAhECADKAIMIREgAygCFCESIAMgAUEkaigAACICQRh0IAJBCHRBgID8B3FyIAJBCH\
ZBgP4DcSACQRh2cnIiEzYCJCADIAFBKGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEY\
dnJyIhQ2AiggAyABQTBqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIVNgIwIA\
MgAUEsaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiFjYCLCADIAFBNGooAAAi\
AkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgI2AjQgAyABQThqKAAAIhdBGHQgF0EIdE\
GAgPwHcXIgF0EIdkGA/gNxIBdBGHZyciIXNgI4IAMgAUE8aigAACIYQRh0IBhBCHRBgID8B3FyIBhB\
CHZBgP4DcSAYQRh2cnIiGDYCPCAIIBMgCnMgGHMgDCAQcyAVcyARIA5zIBNzIBdzQQF3IhlzQQF3Ih\
pzQQF3IhsgCiAScyACcyAQIA9zIBRzIBhzQQF3IhxzQQF3Ih1zIBggAnMgHXMgFSAUcyAccyAbc0EB\
dyIec0EBdyIfcyAaIBxzIB5zIBkgGHMgG3MgFyAVcyAacyAWIBNzIBlzIAsgDHMgF3MgEiARcyAWcy\
APIA1zIAtzIAJzQQF3IiBzQQF3IiFzQQF3IiJzQQF3IiNzQQF3IiRzQQF3IiVzQQF3IiZzQQF3Iicg\
HSAhcyACIBZzICFzIBQgC3MgIHMgHXNBAXciKHNBAXciKXMgHCAgcyAocyAfc0EBdyIqc0EBdyIrcy\
AfIClzICtzIB4gKHMgKnMgJ3NBAXciLHNBAXciLXMgJiAqcyAscyAlIB9zICdzICQgHnMgJnMgIyAb\
cyAlcyAiIBpzICRzICEgGXMgI3MgICAXcyAicyApc0EBdyIuc0EBdyIvc0EBdyIwc0EBdyIxc0EBdy\
Iyc0EBdyIzc0EBdyI0c0EBdyI1ICsgL3MgKSAjcyAvcyAoICJzIC5zICtzQQF3IjZzQQF3IjdzICog\
LnMgNnMgLXNBAXciOHNBAXciOXMgLSA3cyA5cyAsIDZzIDhzIDVzQQF3IjpzQQF3IjtzIDQgOHMgOn\
MgMyAtcyA1cyAyICxzIDRzIDEgJ3MgM3MgMCAmcyAycyAvICVzIDFzIC4gJHMgMHMgN3NBAXciPHNB\
AXciPXNBAXciPnNBAXciP3NBAXciQHNBAXciQXNBAXciQnNBAXciQyA5ID1zIDcgMXMgPXMgNiAwcy\
A8cyA5c0EBdyJEc0EBdyJFcyA4IDxzIERzIDtzQQF3IkZzQQF3IkdzIDsgRXMgR3MgOiBEcyBGcyBD\
c0EBdyJIc0EBdyJJcyBCIEZzIEhzIEEgO3MgQ3MgQCA6cyBCcyA/IDVzIEFzID4gNHMgQHMgPSAzcy\
A/cyA8IDJzID5zIEVzQQF3IkpzQQF3IktzQQF3IkxzQQF3Ik1zQQF3Ik5zQQF3Ik9zQQF3IlBzQQF3\
aiBGIEpzIEQgPnMgSnMgR3NBAXciUXMgSXNBAXciUiBFID9zIEtzIFFzQQF3IlMgTCBBIDogOSA8ID\
EgJiAfICggISAXIBMgECAIQR53IlRqIA4gBSAHQR53IhAgBnMgCHEgBnNqaiANIAQgCEEFd2ogBiAF\
cyAHcSAFc2pqQZnzidQFaiIOQQV3akGZ84nUBWoiVUEedyIIIA5BHnciDXMgBiAPaiAOIFQgEHNxIB\
BzaiBVQQV3akGZ84nUBWoiDnEgDXNqIBAgEWogVSANIFRzcSBUc2ogDkEFd2pBmfOJ1AVqIhBBBXdq\
QZnzidQFaiIRQR53Ig9qIAwgCGogESAQQR53IhMgDkEedyIMc3EgDHNqIBIgDWogDCAIcyAQcSAIc2\
ogEUEFd2pBmfOJ1AVqIhFBBXdqQZnzidQFaiISQR53IgggEUEedyIQcyAKIAxqIBEgDyATc3EgE3Nq\
IBJBBXdqQZnzidQFaiIKcSAQc2ogCyATaiAQIA9zIBJxIA9zaiAKQQV3akGZ84nUBWoiDEEFd2pBmf\
OJ1AVqIg9BHnciC2ogFSAKQR53IhdqIAsgDEEedyITcyAUIBBqIAwgFyAIc3EgCHNqIA9BBXdqQZnz\
idQFaiIUcSATc2ogFiAIaiAPIBMgF3NxIBdzaiAUQQV3akGZ84nUBWoiFUEFd2pBmfOJ1AVqIhYgFU\
EedyIXIBRBHnciCHNxIAhzaiACIBNqIAggC3MgFXEgC3NqIBZBBXdqQZnzidQFaiIUQQV3akGZ84nU\
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\
BHJBAEGAARA7GiACQYABNgIAIAJBsAFqIAJBhAEQOhogBEHQAGogAkGwAWpBBHJBgAEQOhogBEHIAG\
pCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA7COQDcDACAEQQhqQQApA7iOQDcDACAEQRBqQQApA8CO\
QDcDACAEQRhqQQApA8iOQDcDACAEQSBqQQApA9COQDcDACAEQShqQQApA9iOQDcDACAEQTBqQQApA+\
COQDcDACAEQThqQQApA+iOQDcDAEEUIQUMIwtB8AAQFiIERQ0MIAJBsAFqQQhqEFcgBEEgaiACQdgB\
aikDADcDACAEQRhqIAJBsAFqQSBqKQMANwMAIARBEGogAkGwAWpBGGopAwA3AwAgBEEIaiACQbABak\
EQaikDADcDACAEIAIpA7gBNwMAIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcC\
ACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAED\
oaIARB4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJBsAFqQSxq\
KQIANwAAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOGogAkGwAW\
pBFGopAgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARBADoAaEEDIQUMIgsCQAJA\
AkACQCADQbqAwABBChBSRQ0AIANBxIDAAEEKEFJFDQEgA0HOgMAAQQoQUkUNAiADQdiAwABBChBSRQ\
0DIANB6IDAAEEKEFINDEHoABAWIgRFDRYgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEk\
akIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIA\
JBxAAQOhogBEHYAGogAkGwAWpBPGopAgA3AAAgBEHQAGogAkGwAWpBNGopAgA3AAAgBEHIAGogAkGw\
AWpBLGopAgA3AAAgBEHAAGogAkGwAWpBJGopAgA3AAAgBEE4aiACQbABakEcaikCADcAACAEQTBqIA\
JBsAFqQRRqKQIANwAAIARBKGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAICAEQgA3AwAgBEEAOgBg\
IARBACkD2I1ANwMIIARBEGpBACkD4I1ANwMAIARBGGpBACgC6I1ANgIAQQshBQwlC0HgAhAWIgRFDQ\
8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQZABEDsaIAJBkAE2AgAgAkGwAWogAkGUARA6GiAFQcgB\
aiACQbABakEEckGQARA6GiAFQQA6ANgCQQUhBQwkC0HYAhAWIgRFDQ8gBEEAQcgBEDshBSACQQA2Ag\
AgAkEEckEAQYgBEDsaIAJBiAE2AgAgAkGwAWogAkGMARA6GiAFQcgBaiACQbABakEEckGIARA6GiAF\
QQA6ANACQQYhBQwjC0G4AhAWIgRFDQ8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQegAEDsaIAJB6A\
A2AgAgAkGwAWogAkHsABA6GiAFQcgBaiACQbABakEEckHoABA6GiAFQQA6ALACQQchBQwiC0GYAhAW\
IgRFDQ8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQcgAEDsaIAJByAA2AgAgAkGwAWogAkHMABA6Gi\
AFQcgBaiACQbABakEEckHIABA6GiAFQQA6AJACQQghBQwhCwJAIANB4oDAAEEDEFJFDQAgA0HlgMAA\
QQMQUg0IQeAAEBYiBEUNESACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAk\
EsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAE\
QdAAaiACQbABakE8aikCADcAACAEQcgAaiACQbABakE0aikCADcAACAEQcAAaiACQbABakEsaikCAD\
cAACAEQThqIAJBsAFqQSRqKQIANwAAIARBMGogAkGwAWpBHGopAgA3AAAgBEEoaiACQbABakEUaikC\
ADcAACAEQSBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ABggBEL+uevF6Y6VmRA3AxAgBEKBxpS6lv\
Hq5m83AwggBEIANwMAIARBADoAWEEKIQUMIQtB4AAQFiIERQ0PIAJBDGpCADcCACACQRRqQgA3AgAg\
AkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAk\
HAADYCACACQbABaiACQcQAEDoaIARB0ABqIAJBsAFqQTxqKQIANwAAIARByABqIAJBsAFqQTRqKQIA\
NwAAIARBwABqIAJBsAFqQSxqKQIANwAAIARBOGogAkGwAWpBJGopAgA3AAAgBEEwaiACQbABakEcai\
kCADcAACAEQShqIAJBsAFqQRRqKQIANwAAIARBIGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAE\
Qv6568XpjpWZEDcDECAEQoHGlLqW8ermbzcDCCAEQgA3AwAgBEEAOgBYQQkhBQwgCwJAAkACQAJAIA\
MpAABC05CFmtPFjJk0UQ0AIAMpAABC05CFmtPFzJo2UQ0BIAMpAABC05CFmtPljJw0UQ0CIAMpAABC\
05CFmtOlzZgyUQ0DIAMpAABC05CF2tSojJk4UQ0HIAMpAABC05CF2tTIzJo2Ug0KQdgCEBYiBEUNHi\
AEQQBByAEQOyEFIAJBADYCACACQQRyQQBBiAEQOxogAkGIATYCACACQbABaiACQYwBEDoaIAVByAFq\
IAJBsAFqQQRyQYgBEDoaIAVBADoA0AJBFiEFDCMLQeACEBYiBEUNFCAEQQBByAEQOyEFIAJBADYCAC\
ACQQRyQQBBkAEQOxogAkGQATYCACACQbABaiACQZQBEDoaIAVByAFqIAJBsAFqQQRyQZABEDoaIAVB\
ADoA2AJBDSEFDCILQdgCEBYiBEUNFCAEQQBByAEQOyEFIAJBADYCACACQQRyQQBBiAEQOxogAkGIAT\
YCACACQbABaiACQYwBEDoaIAVByAFqIAJBsAFqQQRyQYgBEDoaIAVBADoA0AJBDiEFDCELQbgCEBYi\
BEUNFCAEQQBByAEQOyEFIAJBADYCACACQQRyQQBB6AAQOxogAkHoADYCACACQbABaiACQewAEDoaIA\
VByAFqIAJBsAFqQQRyQegAEDoaIAVBADoAsAJBDyEFDCALQZgCEBYiBEUNFCAEQQBByAEQOyEFIAJB\
ADYCACACQQRyQQBByAAQOxogAkHIADYCACACQbABaiACQcwAEDoaIAVByAFqIAJBsAFqQQRyQcgAED\
oaIAVBADoAkAJBECEFDB8LQfAAEBYiBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACAC\
QSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAW\
ogAkHEABA6GiAEQeAAaiACQbABakE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiAC\
QbABakEsaikCADcAACAEQcgAaiACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQT\
hqIAJBsAFqQRRqKQIANwAAIARBMGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEA\
OgBoIARBACkDkI5ANwMIIARBEGpBACkDmI5ANwMAIARBGGpBACkDoI5ANwMAIARBIGpBACkDqI5ANw\
MAQREhBQweC0HwABAWIgRFDRQgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIA\
IAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOh\
ogBEHgAGogAkGwAWpBPGopAgA3AAAgBEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGop\
AgA3AAAgBEHIAGogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABak\
EUaikCADcAACAEQTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEIANwMAIARBADoAaCAEQQAp\
A/CNQDcDCCAEQRBqQQApA/iNQDcDACAEQRhqQQApA4COQDcDACAEQSBqQQApA4iOQDcDAEESIQUMHQ\
tB2AEQFiIERQ0UIAJBADYCACACQQRyQQBBgAEQOxogAkGAATYCACACQbABaiACQYQBEDoaIARB0ABq\
IAJBsAFqQQRyQYABEDoaIARByABqQgA3AwAgBEIANwNAIARBADoA0AEgBEEAKQPwjkA3AwAgBEEIak\
EAKQP4jkA3AwAgBEEQakEAKQOAj0A3AwAgBEEYakEAKQOIj0A3AwAgBEEgakEAKQOQj0A3AwAgBEEo\
akEAKQOYj0A3AwAgBEEwakEAKQOgj0A3AwAgBEE4akEAKQOoj0A3AwBBEyEFDBwLQfgCEBYiBEUNFS\
AEQQBByAEQOyEFIAJBADYCACACQQRyQQBBqAEQOxogAkGoATYCACACQbABaiACQawBEDoaIAVByAFq\
IAJBsAFqQQRyQagBEDoaIAVBADoA8AJBFSEFDBsLIANB8oDAAEEFEFJFDRcgA0GTgcAAQQUQUg0BQe\
gAEBYiBEUNFiAEQgA3AwAgBEEAKQP4kUA3AwggBEEQakEAKQOAkkA3AwAgBEEYakEAKQOIkkA3AwAg\
AkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3Ag\
AgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOhogBEHYAGogAkGwAWpBPGopAgA3\
AAAgBEHQAGogAkGwAWpBNGopAgA3AAAgBEHIAGogAkGwAWpBLGopAgA3AAAgBEHAAGogAkGwAWpBJG\
opAgA3AAAgBEE4aiACQbABakEcaikCADcAACAEQTBqIAJBsAFqQRRqKQIANwAAIARBKGogAkGwAWpB\
DGopAgA3AAAgBCACKQK0ATcAICAEQQA6AGBBFyEFDBoLIANBtIDAAEEGEFJFDRcLQQEhBEGYgcAAQR\
UQACEFDBkLQdABQQhBACgC+NRAIgJBBCACGxEFAAALQdABQQhBACgC+NRAIgJBBCACGxEFAAALQfAA\
QQhBACgC+NRAIgJBBCACGxEFAAALQeACQQhBACgC+NRAIgJBBCACGxEFAAALQdgCQQhBACgC+NRAIg\
JBBCACGxEFAAALQbgCQQhBACgC+NRAIgJBBCACGxEFAAALQZgCQQhBACgC+NRAIgJBBCACGxEFAAAL\
QeAAQQhBACgC+NRAIgJBBCACGxEFAAALQeAAQQhBACgC+NRAIgJBBCACGxEFAAALQegAQQhBACgC+N\
RAIgJBBCACGxEFAAALQeACQQhBACgC+NRAIgJBBCACGxEFAAALQdgCQQhBACgC+NRAIgJBBCACGxEF\
AAALQbgCQQhBACgC+NRAIgJBBCACGxEFAAALQZgCQQhBACgC+NRAIgJBBCACGxEFAAALQfAAQQhBAC\
gC+NRAIgJBBCACGxEFAAALQfAAQQhBACgC+NRAIgJBBCACGxEFAAALQdgBQQhBACgC+NRAIgJBBCAC\
GxEFAAALQdgBQQhBACgC+NRAIgJBBCACGxEFAAALQfgCQQhBACgC+NRAIgJBBCACGxEFAAALQdgCQQ\
hBACgC+NRAIgJBBCACGxEFAAALQegAQQhBACgC+NRAIgJBBCACGxEFAAALAkBB6AAQFiIERQ0AQQwh\
BSACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCAD\
cCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQdgAaiACQbABakE8aikC\
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\
1UBBAEG01cAANgK81UBBAEHE1cAANgLQ1UBBAEG81cAANgLE1UBBAEEANgK42EBBAEHM1cAANgLY1U\
BBAEHE1cAANgLM1UBBAEHM1cAANgLU1UBBAEHU1cAANgLg1UBBAEHU1cAANgLc1UBBAEHc1cAANgLo\
1UBBAEHc1cAANgLk1UBBAEHk1cAANgLw1UBBAEHk1cAANgLs1UBBAEHs1cAANgL41UBBAEHs1cAANg\
L01UBBAEH01cAANgKA1kBBAEH01cAANgL81UBBAEH81cAANgKI1kBBAEH81cAANgKE1kBBAEGE1sAA\
NgKQ1kBBAEGE1sAANgKM1kBBAEGM1sAANgKY1kBBAEGU1sAANgKg1kBBAEGM1sAANgKU1kBBAEGc1s\
AANgKo1kBBAEGU1sAANgKc1kBBAEGk1sAANgKw1kBBAEGc1sAANgKk1kBBAEGs1sAANgK41kBBAEGk\
1sAANgKs1kBBAEG01sAANgLA1kBBAEGs1sAANgK01kBBAEG81sAANgLI1kBBAEG01sAANgK81kBBAE\
HE1sAANgLQ1kBBAEG81sAANgLE1kBBAEHM1sAANgLY1kBBAEHE1sAANgLM1kBBAEHU1sAANgLg1kBB\
AEHM1sAANgLU1kBBAEHc1sAANgLo1kBBAEHU1sAANgLc1kBBAEHk1sAANgLw1kBBAEHc1sAANgLk1k\
BBAEHs1sAANgL41kBBAEHk1sAANgLs1kBBAEH01sAANgKA10BBAEHs1sAANgL01kBBAEH81sAANgKI\
10BBAEH01sAANgL81kBBAEGE18AANgKQ10BBAEH81sAANgKE10BBACAGNgKg2EBBAEGE18AANgKM10\
BBACAIQVhqIgA2ApjYQCAGIABBAXI2AgQgCCAGakFcakEoNgIAQQBBgICAATYCvNhAC0EAIQFBACgC\
mNhAIgAgAk0NAEEAIAAgAmsiATYCmNhAQQBBACgCoNhAIgAgAmoiBTYCoNhAIAUgAUEBcjYCBCAAIA\
JBA3I2AgQgAEEIag8LIAELuSUCA38efiMAQcAAayIDQThqQgA3AwAgA0EwakIANwMAIANBKGpCADcD\
ACADQSBqQgA3AwAgA0EYakIANwMAIANBEGpCADcDACADQQhqQgA3AwAgA0IANwMAAkAgAkUNACABIA\
JBBnRqIQQgACkDECEGIAApAwghByAAKQMAIQgDQCADIAFBGGopAAAiCSABKQAAIgogAUE4aikAACIL\
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\
ADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDAD\
cDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIAMpA0AhDyABQQhqQcgAaiADQcgAahBEIAEg\
DzcDSCACIAFBCGpB0AEQOhpBACEDDB8LIAIoAgQhA0HQARAWIgJFDQYgAUEIakE4aiADQThqKQMANw\
MAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMA\
IAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIA\
EgAykDADcDCCADKQNAIQ8gAUEIakHIAGogA0HIAGoQRCABIA83A0ggAiABQQhqQdABEDoaQQEhAwwe\
CyACKAIEIQNB0AEQFiICRQ0GIAFBCGpBOGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAU\
EIakEoaiADQShqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEI\
akEQaiADQRBqKQMANwMAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByA\
BqIANByABqEEQgASAPNwNIIAIgAUEIakHQARA6GkECIQMMHQsgAigCBCEDQfAAEBYiAkUNBiABQQhq\
QSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABIAMpAw\
g3AxAgAykDACEPIAFBCGpBKGogA0EoahA4IAEgDzcDCCACIAFBCGpB8AAQOhpBAyEDDBwLIAIoAgQh\
A0H4DhAWIgJFDQYgAUEIakGIAWogA0GIAWopAwA3AwAgAUEIakGAAWogA0GAAWopAwA3AwAgAUEIak\
H4AGogA0H4AGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhq\
QSBqIANBIGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBOGogA0E4aikDADcDACABQQhqQc\
AAaiADQcAAaikDADcDACABQQhqQcgAaiADQcgAaikDADcDACABQQhqQdAAaiADQdAAaikDADcDACAB\
QQhqQdgAaiADQdgAaikDADcDACABQQhqQeAAaiADQeAAaikDADcDACABIAMpA3A3A3ggASADKQMINw\
MQIAEgAykDKDcDMCADKQMAIQ8gAy0AaiEEIAMtAGkhBSADLQBoIQYCQCADKAKQAUEFdCIHDQBBACEH\
DBsLIAFBgA9qQRhqIgggA0GUAWoiCUEYaikAADcDACABQYAPakEQaiIKIAlBEGopAAA3AwAgAUGAD2\
pBCGoiCyAJQQhqKQAANwMAIAEgCSkAADcDgA8gA0HUAWohCUEAIAdBYGpBBXZrIQwgAUG8AWohA0EC\
IQcDQCADQWBqIg0gASkDgA83AAAgDUEYaiAIKQMANwAAIA1BEGogCikDADcAACANQQhqIAspAwA3AA\
ACQAJAIAwgB2oiDkECRg0AIAggCUFgaiINQRhqKQAANwMAIAogDUEQaikAADcDACALIA1BCGopAAA3\
AwAgASANKQAANwOADyAHQThHDQEQawALIAdBf2ohBwwcCyADIAEpA4APNwAAIANBGGogCCkDADcAAC\
ADQRBqIAopAwA3AAAgA0EIaiALKQMANwAAIA5BAUYNGyAIIAlBGGopAAA3AwAgCiAJQRBqKQAANwMA\
IAsgCUEIaikAADcDACABIAkpAAA3A4APIANBwABqIQMgB0ECaiEHIAlBwABqIQkMAAsLEG8ACxBwAA\
tB0AFBCEEAKAL41EAiAUEEIAEbEQUAAAtB0AFBCEEAKAL41EAiAUEEIAEbEQUAAAtB0AFBCEEAKAL4\
1EAiAUEEIAEbEQUAAAtB8ABBCEEAKAL41EAiAUEEIAEbEQUAAAtB+A5BCEEAKAL41EAiAUEEIAEbEQ\
UAAAsgAigCBCEDAkBB6AAQFiICRQ0AIAFBCGpBEGogA0EQaikDADcDACABQQhqQRhqIANBGGopAwA3\
AwAgASADKQMINwMQIAMpAwAhDyABQQhqQSBqIANBIGoQOCABIA83AwggAiABQQhqQegAEDoaQRchAw\
wUC0HoAEEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHYAhAWIgJFDQAgAUEIaiADQcgBEDoa\
IAFBCGpByAFqIANByAFqEEUgAiABQQhqQdgCEDoaQRYhAwwTC0HYAkEIQQAoAvjUQCIBQQQgARsRBQ\
AACyACKAIEIQMCQEH4AhAWIgJFDQAgAUEIaiADQcgBEDoaIAFBCGpByAFqIANByAFqEEYgAiABQQhq\
QfgCEDoaQRUhAwwSC0H4AkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHYARAWIgJFDQAgAU\
EIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGopAwA3AwAgAUEI\
akEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIak\
EIaiADQQhqKQMANwMAIAEgAykDADcDCCADQcgAaikDACEPIAMpA0AhECABQQhqQdAAaiADQdAAahBE\
IAFBCGpByABqIA83AwAgASAQNwNIIAIgAUEIakHYARA6GkEUIQMMEQtB2AFBCEEAKAL41EAiAUEEIA\
EbEQUAAAsgAigCBCEDAkBB2AEQFiICRQ0AIAFBCGpBOGogA0E4aikDADcDACABQQhqQTBqIANBMGop\
AwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAw\
A3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggA0HIAGop\
AwAhDyADKQNAIRAgAUEIakHQAGogA0HQAGoQRCABQQhqQcgAaiAPNwMAIAEgEDcDSCACIAFBCGpB2A\
EQOhpBEyEDDBALQdgBQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQfAAEBYiAkUNACABQQhq\
QSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABIAMpAw\
g3AxAgAykDACEPIAFBCGpBKGogA0EoahA4IAEgDzcDCCACIAFBCGpB8AAQOhpBEiEDDA8LQfAAQQhB\
ACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQfAAEBYiAkUNACABQQhqQSBqIANBIGopAwA3AwAgAU\
EIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpB\
KGogA0EoahA4IAEgDzcDCCACIAFBCGpB8AAQOhpBESEDDA4LQfAAQQhBACgC+NRAIgFBBCABGxEFAA\
ALIAIoAgQhAwJAQZgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRyACIAFBCGpB\
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\
IABBIGoiCEIANwMAIABBOGoiCUIANwMAIABBMGoiCkIANwMAIABBKGoiC0IANwMAIABBCGoiDCABKQ\
AINwMAIABBEGoiDSABKQAQNwMAIAIgASgAGCIONgIAIAggASgAICIPNgIAIAAgASkAADcDACAAIAEo\
ABwiEDYCHCAAIAEoACQiETYCJCALIAEoACgiEjYCACAAIAEoACwiCzYCLCAKIAEoADAiEzYCACAAIA\
EoADQiCjYCNCAJIAEoADgiFDYCACAAIAEoADwiCTYCPCADIAQgDSgCACINIA8gEyAAKAIAIhUgESAK\
IAAoAgQiFiAAKAIUIhcgCiARIBcgFiATIA8gDSAHIBUgBCAHIAVxaiAGIAdBf3NxampB+Miqu31qQQ\
d3aiIBaiAHIAAoAgwiGGogBSAMKAIAIgxqIAYgFmogASAHcWogBSABQX9zcWpB1u6exn5qQQx3IAFq\
IgAgAXFqIAcgAEF/c3FqQdvhgaECakERdyAAaiICIABxaiABIAJBf3NxakHunfeNfGpBFncgAmoiAS\
ACcWogACABQX9zcWpBr5/wq39qQQd3IAFqIghqIBAgAWogDiACaiAXIABqIAggAXFqIAIgCEF/c3Fq\
QaqMn7wEakEMdyAIaiIAIAhxaiABIABBf3NxakGTjMHBempBEXcgAGoiASAAcWogCCABQX9zcWpBga\
qaampBFncgAWoiAiABcWogACACQX9zcWpB2LGCzAZqQQd3IAJqIghqIAsgAmogEiABaiARIABqIAgg\
AnFqIAEgCEF/c3FqQa/vk9p4akEMdyAIaiIAIAhxaiACIABBf3NxakGxt31qQRF3IABqIgEgAHFqIA\
ggAUF/c3FqQb6v88p4akEWdyABaiICIAFxaiAAIAJBf3NxakGiosDcBmpBB3cgAmoiCGogFCABaiAK\
IABqIAggAnFqIAEgCEF/c3FqQZPj4WxqQQx3IAhqIgAgCHFqIAIgAEF/cyIZcWpBjofls3pqQRF3IA\
BqIgEgGXFqIAkgAmogASAAcWogCCABQX9zIhlxakGhkNDNBGpBFncgAWoiAiAAcWpB4sr4sH9qQQV3\
IAJqIghqIAsgAWogCCACQX9zcWogDiAAaiACIBlxaiAIIAFxakHA5oKCfGpBCXcgCGoiACACcWpB0b\
T5sgJqQQ53IABqIgEgAEF/c3FqIBUgAmogACAIQX9zcWogASAIcWpBqo/bzX5qQRR3IAFqIgIgAHFq\
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\
CGogAkEQaikDADcDACADIAIpAwg3AwAgA0HoAGpBADoAAAwUCyADKAIEIgNCADcDACADIAMpA3A3Aw\
ggA0EgaiADQYgBaikDADcDACADQRhqIANBgAFqKQMANwMAIANBEGogA0H4AGopAwA3AwAgA0EoakEA\
QcIAEDsaIAMoApABRQ0TIANBADYCkAEMEwsgAygCBEEAQcgBEDtB2AJqQQA6AAAMEgsgAygCBEEAQc\
gBEDtB0AJqQQA6AAAMEQsgAygCBEEAQcgBEDtBsAJqQQA6AAAMEAsgAygCBEEAQcgBEDtBkAJqQQA6\
AAAMDwsgAygCBCIDQoHGlLqW8ermbzcDCCADQgA3AwAgA0HYAGpBADoAACADQRBqQv6568XpjpWZED\
cDAAwOCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAAIANBEGpC/rnrxemOlZkQ\
NwMADA0LIAMoAgQiA0IANwMAIANB4ABqQQA6AAAgA0EAKQPYjUA3AwggA0EQakEAKQPgjUA3AwAgA0\
EYakEAKALojUA2AgAMDAsgAygCBCIDQoHGlLqW8ermbzcDCCADQgA3AwAgA0HgAGpBADoAACADQRhq\
QfDDy558NgIAIANBEGpC/rnrxemOlZkQNwMADAsLIAMoAgRBAEHIARA7QdgCakEAOgAADAoLIAMoAg\
RBAEHIARA7QdACakEAOgAADAkLIAMoAgRBAEHIARA7QbACakEAOgAADAgLIAMoAgRBAEHIARA7QZAC\
akEAOgAADAcLIAMoAgQiA0IANwMAIANB6ABqQQA6AAAgA0EAKQOQjkA3AwggA0EQakEAKQOYjkA3Aw\
AgA0EYakEAKQOgjkA3AwAgA0EgakEAKQOojkA3AwAMBgsgAygCBCIDQgA3AwAgA0HoAGpBADoAACAD\
QQApA/CNQDcDCCADQRBqQQApA/iNQDcDACADQRhqQQApA4COQDcDACADQSBqQQApA4iOQDcDAAwFCy\
ADKAIEIgNCADcDQCADQQApA/COQDcDACADQcgAakIANwMAIANBOGpBACkDqI9ANwMAIANBMGpBACkD\
oI9ANwMAIANBKGpBACkDmI9ANwMAIANBIGpBACkDkI9ANwMAIANBGGpBACkDiI9ANwMAIANBEGpBAC\
kDgI9ANwMAIANBCGpBACkD+I5ANwMAIANB0AFqQQA6AAAMBAsgAygCBCIDQgA3A0AgA0EAKQOwjkA3\
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\
IBM3AwAgAkHIAGogEjcDAEIAIRIgAkIANwMAIAhBBHIhCSACQQhqIQQMAQsgAkEQaiABQRBqKQMANw\
MAIAJBGGogAUEYaikDADcDACACQSBqIAFBIGopAwA3AwAgAkEwaiABQTBqKQMANwMAIAJBOGogAUE4\
aikDADcDACACQcAAaiABQcAAaikDADcDACACQcgAaiABQcgAaikDADcDACACQdAAaiABQdAAaikDAD\
cDACACQdgAaiABQdgAaikDADcDACACQeAAaiABQeAAaikDADcDACACIAEpAwg3AwggAiABKQMoNwMo\
IAEtAGohCCACIAEpAwAiEjcDACAIIARFckECciEJIAJBCGohBCADIQYLIAIgCToAaSACIAU6AGgCQA\
JAIAZFDQAgAUHwAGohCiACQShqIQdBASAGayELIAhBBHIhCCAGQQV0IAFqQfQAaiEBIAZBf2ogA08h\
DANAIAwNAiACQfAAakEYaiIGIARBGGoiDSkCADcDACACQfAAakEQaiIOIARBEGoiDykCADcDACACQf\
AAakEIaiIQIARBCGoiESkCADcDACACIAQpAgA3A3AgAkHwAGogByAFIBIgCRAZIBApAwAhEyAOKQMA\
IRQgBikDACEVIAIpA3AhFiAHQRhqIAFBGGopAgA3AgAgB0EQaiABQRBqKQIANwIAIAdBCGogAUEIai\
kCADcCACAHIAEpAgA3AgAgBCAKKQMANwMAIBEgCkEIaikDADcDACAPIApBEGopAwA3AwAgDSAKQRhq\
KQMANwMAQgAhEiACQgA3AwAgAiAVNwNgIAIgFDcDWCACIBM3A1AgAiAWNwNIIAIgCDoAaUHAACEFIA\
JBwAA6AGggAUFgaiEBIAghCSALQQFqIgtBAUcNAAsLIAAgAkHwABA6GgwCC0EAIAtrIANB0IXAABBO\
AAsgACABKQMINwMIIAAgASkDKDcDKCAAQRBqIAFBEGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBIG\
ogAUEgaikDADcDACAAQTBqIAFBMGopAwA3AwAgAEE4aiABQThqKQMANwMAIABBwABqIAFBwABqKQMA\
NwMAIABByABqIAFByABqKQMANwMAIABB0ABqIAFB0ABqKQMANwMAIABB2ABqIAFB2ABqKQMANwMAIA\
BB4ABqIAFB4ABqKQMANwMAIAFB6QBqLQAAIQQgAS0AaiEHIAAgAS0AaDoAaCAAIAEpAwA3AwAgACAH\
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\
CyAGKAIIIQcLAkACQAJAAkAgCUUNACAHQQV0IgIgBUsNASAFIAJrIgFBH00NAiAJQSBHDQMgBCACai\
ICIAAgCGoiASkAADcAACACQRhqIAFBGGopAAA3AAAgAkEQaiABQRBqKQAANwAAIAJBCGogAUEIaikA\
ADcAACAHQQFqIQcLIAZBMGokACAHDwsgAiAFQbCEwAAQSwALQSAgAUGwhMAAEEoAC0EgIAlB5IvAAB\
BNAAuBBAIDfwJ+IwBB8AFrIgMkACAAKQMAIQYgASABQcAAai0AACIEaiIFQYABOgAAIANBCGpBEGog\
AEEYaigCADYCACADQRBqIABBEGopAgA3AwAgAyAAKQIINwMIIAZCCYYhBiAErUIDhiEHAkAgBEE/cy\
IARQ0AIAVBAWpBACAAEDsaCyAGIAeEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgA0EIaiABEBIM\
AQsgA0EIaiABEBIgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAG\
pBJGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HA\
ADYCYCADQagBaiADQeAAakHEABA6GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsai\
kCADcDACADQcAAaiADQagBakEkaikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpB\
FGopAgA3AwAgA0EoaiADQagBakEMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQQhqIANBIGoQEg\
sgAiADKAIINgAAIAIgAykCDDcABCACIAMpAhQ3AAwgAUHAAGpBADoAACADQfABaiQAC/ADAgN/An4j\
AEHwAWsiAyQAIAFBwABqLQAAIQQgACkDACEGIANBEGogAEEQaikCADcDACADIAApAgg3AwggASAEai\
IAQYABOgAAIAZCCYYhBiAErUIDhiEHIAMgA0EIajYCHAJAIARBP3MiBUUNACAAQQFqQQAgBRA7Ggsg\
ByAGhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIANBHGogARAcDAELIANBHGogARAcIANB4ABqQQ\
xqQgA3AgAgA0HgAGpBFGpCADcCACADQeAAakEcakIANwIAIANB4ABqQSRqQgA3AgAgA0HgAGpBLGpC\
ADcCACADQeAAakE0akIANwIAIANBnAFqQgA3AgAgA0IANwJkIANBwAA2AmAgA0GoAWogA0HgAGpBxA\
AQOhogA0HQAGogA0GoAWpBNGopAgA3AwAgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpB\
JGopAgA3AwAgA0E4aiADQagBakEcaikCADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAW\
pBDGopAgA3AwAgAyADKQKsATcDICADIAY3A1ggA0EcaiADQSBqEBwLIAFBwABqQQA6AAAgAiADKQMI\
NwAAIAIgAykDEDcACCADQfABaiQAC9kDAgN/An4jAEHgAWsiAyQAIAApAwAhBiABIAFBwABqLQAAIg\
RqIgVBgAE6AAAgA0EIaiAAQRBqKQIANwMAIAMgACkCCDcDACAGQgmGIQYgBK1CA4YhBwJAIARBP3Mi\
AEUNACAFQQFqQQAgABA7GgsgByAGhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIAMgARAfDAELIA\
MgARAfIANB0ABqQQxqQgA3AgAgA0HQAGpBFGpCADcCACADQdAAakEcakIANwIAIANB0ABqQSRqQgA3\
AgAgA0HQAGpBLGpCADcCACADQdAAakE0akIANwIAIANBjAFqQgA3AgAgA0IANwJUIANBwAA2AlAgA0\
GYAWogA0HQAGpBxAAQOhogA0HAAGogA0GYAWpBNGopAgA3AwAgA0E4aiADQZgBakEsaikCADcDACAD\
QTBqIANBmAFqQSRqKQIANwMAIANBKGogA0GYAWpBHGopAgA3AwAgA0EgaiADQZgBakEUaikCADcDAC\
ADQRhqIANBmAFqQQxqKQIANwMAIAMgAykCnAE3AxAgAyAGNwNIIAMgA0EQahAfCyACIAMpAwA3AAAg\
AiADKQMINwAIIAFBwABqQQA6AAAgA0HgAWokAAvUAwIEfwJ+IwBB0AFrIgMkACABIAFBwABqLQAAIg\
RqIgVBAToAACAAKQMAQgmGIQcgBK1CA4YhCAJAIARBP3MiBkUNACAFQQFqQQAgBhA7GgsgByAIhCEH\
AkACQCAEQThxQThGDQAgAUE4aiAHNwAAIABBCGogAUEBEBcMAQsgAEEIaiIEIAFBARAXIANBwABqQQ\
xqQgA3AgAgA0HAAGpBFGpCADcCACADQcAAakEcakIANwIAIANBwABqQSRqQgA3AgAgA0HAAGpBLGpC\
ADcCACADQcAAakE0akIANwIAIANB/ABqQgA3AgAgA0IANwJEIANBwAA2AkAgA0GIAWogA0HAAGpBxA\
AQOhogA0EwaiADQYgBakE0aikCADcDACADQShqIANBiAFqQSxqKQIANwMAIANBIGogA0GIAWpBJGop\
AgA3AwAgA0EYaiADQYgBakEcaikCADcDACADQRBqIANBiAFqQRRqKQIANwMAIANBCGogA0GIAWpBDG\
opAgA3AwAgAyADKQKMATcDACADIAc3AzggBCADQQEQFwsgAUHAAGpBADoAACACIAApAwg3AAAgAiAA\
QRBqKQMANwAIIAIgAEEYaikDADcAECADQdABaiQAC4kDAQV/AkACQAJAIAFBCUkNAEEAIQJBzf97IA\
FBECABQRBLGyIBayAATQ0BIAFBECAAQQtqQXhxIABBC0kbIgNqQQxqEBYiAEUNASAAQXhqIQICQAJA\
IAFBf2oiBCAAcQ0AIAIhAQwBCyAAQXxqIgUoAgAiBkF4cSAEIABqQQAgAWtxQXhqIgBBACABIAAgAm\
tBEEsbaiIBIAJrIgBrIQQCQCAGQQNxRQ0AIAEgASgCBEEBcSAEckECcjYCBCAEIAFqQQRqIgQgBCgC\
AEEBcjYCACAFIAUoAgBBAXEgAHJBAnI2AgAgACACakEEaiIEIAQoAgBBAXI2AgAgAiAAECAMAQsgAi\
gCACECIAEgBDYCBCABIAIgAGo2AgALIAEoAgQiAEEDcUUNAiAAQXhxIgIgA0EQak0NAiABIABBAXEg\
A3JBAnI2AgQgASADaiIAIAIgA2siAkEDcjYCBCAAIAJBBHJqIgMgAygCAEEBcjYCACAAIAIQIAwCCy\
AAEBYhAgsgAg8LIAFBCGoLlwMBBX8jAEGQBGsiAyQAIABByAFqIQQCQAJAAkACQAJAIABB8AJqLQAA\
IgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEDogBmohASACIAZrIQILIAIgAkGoAW4iBUGoAWwiB0\
kNASACIAdrIQYCQCAFQagBbCICRQ0AIAEhBQNAIANB4AJqIABBqAEQOhogABAkIAUgA0HgAmpBqAEQ\
OkGoAWohBSACQdh+aiICDQALCwJAIAYNAEEAIQYMBAsgA0EANgKwASADQbABakEEckEAQagBEDsaIA\
NBqAE2ArABIANB4AJqIANBsAFqQawBEDoaIANBCGogA0HgAmpBBHJBqAEQOhogA0HgAmogAEGoARA6\
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\
AgAhAyABKAIYIQEgAkEsakECNgIAIAJCAjcCHCACQZiIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqEC\
shASACQTBqJAAgAQt0AQJ/IwBBkAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIA\
IANBBGoiA0GAAUcNAAsgAkGAATYCACACQYgBaiACQYQBEDoaIAAgAkGIAWpBBHJBgAEQOiABLQCAAT\
oAgAEgAkGQAmokAAt0AQJ/IwBBoAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIA\
IANBBGoiA0GIAUcNAAsgAkGIATYCACACQZABaiACQYwBEDoaIAAgAkGQAWpBBHJBiAEQOiABLQCIAT\
oAiAEgAkGgAmokAAt0AQJ/IwBB4AJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIA\
IANBBGoiA0GoAUcNAAsgAkGoATYCACACQbABaiACQawBEDoaIAAgAkGwAWpBBHJBqAEQOiABLQCoAT\
oAqAEgAkHgAmokAAtyAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIA\
IANBBGoiA0HIAEcNAAsgAkHIADYCACACQdAAaiACQcwAEDoaIAAgAkHQAGpBBHJByAAQOiABLQBIOg\
BIIAJBoAFqJAALcgECfyMAQeABayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACAD\
QQRqIgNB6ABHDQALIAJB6AA2AgAgAkHwAGogAkHsABA6GiAAIAJB8ABqQQRyQegAEDogAS0AaDoAaC\
ACQeABaiQAC3QBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgA0EE\
aiIDQZABRw0ACyACQZABNgIAIAJBmAFqIAJBlAEQOhogACACQZgBakEEckGQARA6IAEtAJABOgCQAS\
ACQbACaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANC\
AjcCDCADQciKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBYAA\
tsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0Go\
isAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQWAALbAEBfyMAQT\
BrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANB/IrAADYCCCAD\
QQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFgAC2wBAX8jAEEwayIDJAAgAy\
ABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQcyLwAA2AgggA0EDNgIkIAMg\
A0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBYAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIA\
A2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GEiMAANgIIIANBAzYCJCADIANBIGo2Ahgg\
AyADNgIoIAMgA0EEajYCICADQQhqIAIQWAALdQECf0EBIQBBAEEAKAKA1UAiAUEBajYCgNVAAkACQE\
EAKALI2EBBAUcNAEEAKALM2EBBAWohAAwBC0EAQQE2AsjYQAtBACAANgLM2EACQCABQQBIDQAgAEEC\
Sw0AQQAoAvzUQEF/TA0AIABBAUsNABB0AAsAC5oBACMAQTBrGiAAQgA3A0AgAEE4akL5wvibkaOz8N\
sANwMAIABBMGpC6/qG2r+19sEfNwMAIABBKGpCn9j52cKR2oKbfzcDACAAQtGFmu/6z5SH0QA3AyAg\
AELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7fzcDCCAAIAGtQoiS95X/zP\
mE6gCFNwMAC1UBAn8CQAJAIABFDQAgACgCAA0BIABBADYCACAAKAIIIQEgACgCBCECIAAQHgJAIAJB\
BEcNACABKAKQAUUNACABQQA2ApABCyABEB4PCxBvAAsQcAALSgEDf0EAIQMCQCACRQ0AAkADQCAALQ\
AAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLVAEBfwJA\
AkACQCABQYCAxABGDQBBASEEIAAoAhggASAAQRxqKAIAKAIQEQYADQELIAINAUEAIQQLIAQPCyAAKA\
IYIAIgAyAAQRxqKAIAKAIMEQgAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIANBoJHAADYCECADQgE3\
AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEFgACzkAAkACQCABRQ0AIAEoAgANASABQX82Ag\
AgAUEEaiACEDcgAUEANgIAIABCADcDAA8LEG8ACxBwAAsrAAJAIABBfEsNAAJAIAANAEEEDwsgACAA\
QX1JQQJ0EDEiAEUNACAADwsAC1IAIABCx8yj2NbQ67O7fzcDCCAAQgA3AwAgAEEgakKrs4/8kaOz8N\
sANwMAIABBGGpC/6S5iMWR2oKbfzcDACAAQRBqQvLmu+Ojp/2npX83AwALNAEBfyMAQRBrIgIkACAC\
IAE2AgwgAiAANgIIIAJBwIfAADYCBCACQaCRwAA2AgAgAhBoAAslAAJAIAANAEGwj8AAQTAQcQALIA\
AgAiADIAQgBSABKAIQEQwACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQoACyMAAkAg\
AA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQkACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBC\
ABKAIQEQoACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQkACyMAAkAgAA0AQbCPwABB\
MBBxAAsgACACIAMgBCABKAIQEQkACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQERUACy\
MAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQERYACyEAAkAgAA0AQbCPwABBMBBxAAsgACAC\
IAMgASgCEBEHAAseACAAQRRqKAIAGgJAIABBBGooAgAOAgAAAAsQTwALHAACQAJAIAFBfEsNACAAIA\
IQJiIBDQELAAsgAQsfAAJAIAANAEGwj8AAQTAQcQALIAAgAiABKAIQEQYACxoAAkAgAA0AQaCRwABB\
K0HokcAAEFQACyAACxQAIAAoAgAgASAAKAIEKAIMEQYACxAAIAEgACgCACAAKAIEECULDgAgACgCCB\
BlIAAQcgALDgACQCABRQ0AIAAQHgsLEQBBgoLAAEERQZSCwAAQVAALEQBBpILAAEEvQaSDwAAQVAAL\
DQAgACgCABoDfwwACwsLACAAIwBqJAAjAAsLACAANQIAIAEQNQsMAEHA0sAAQRsQcQALDQBB29LAAE\
HPABBxAAsJACAAIAEQCwALCQAgACABEGIACwwAQqXwls/l/+mlVgsDAAALAgALAgALC/7UgIAAAQBB\
gIDAAAv0VPQFEABQAAAAlQAAAAkAAABCTEFLRTJCQkxBS0UyQi0yNTZCTEFLRTJCLTM4NEJMQUtFMl\
NCTEFLRTNLRUNDQUstMjI0S0VDQ0FLLTI1NktFQ0NBSy0zODRLRUNDQUstNTEyTUQ0TUQ1UklQRU1E\
LTE2MFNIQS0xU0hBLTIyNFNIQS0yNTZTSEEtMzg0U0hBLTUxMlRJR0VSdW5zdXBwb3J0ZWQgYWxnb3\
JpdGhtbm9uLWRlZmF1bHQgbGVuZ3RoIHNwZWNpZmllZCBmb3Igbm9uLWV4dGVuZGFibGUgYWxnb3Jp\
dGhtbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AOYAEAAcAAAAMg\
IAAAUAAABBcnJheVZlYzogY2FwYWNpdHkgZXhjZWVkZWQgaW4gZXh0ZW5kL2Zyb21faXRlcn4vLmNh\
cmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2ZWMtMC43Lj\
Ivc3JjL2FycmF5dmVjLnJzAFMBEABQAAAAAQQAAAUAAABUBhAATQAAAAEGAAAJAAAAfi8uY2FyZ28v\
cmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9ibGFrZTMtMS4zLjAvc3JjL2\
xpYi5ycwAAAMQBEABJAAAAuQEAAAkAAADEARAASQAAAF8CAAAKAAAAxAEQAEkAAACNAgAACQAAAMQB\
EABJAAAA3QIAAAoAAADEARAASQAAANYCAAAJAAAAxAEQAEkAAAABAwAAGQAAAMQBEABJAAAAAwMAAA\
kAAADEARAASQAAAAMDAAA4AAAAxAEQAEkAAAD4AwAAMgAAAMQBEABJAAAAqgQAABYAAADEARAASQAA\
ALwEAAAWAAAAxAEQAEkAAADtBAAAEgAAAMQBEABJAAAA9wQAABIAAADEARAASQAAAGkFAAAhAAAAEQ\
AAAAQAAAAEAAAAEgAAABEAAAAgAAAAAQAAABMAAAARAAAABAAAAAQAAAASAAAAfi8uY2FyZ28vcmVn\
aXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9hcnJheXZlYy0wLjcuMi9zcmMvYX\
JyYXl2ZWNfaW1wbC5ycwAAACADEABVAAAAJwAAACAAAABDYXBhY2l0eUVycm9yAAAAiAMQAA0AAABp\
bnN1ZmZpY2llbnQgY2FwYWNpdHkAAACgAxAAFQAAABEAAAAAAAAAAQAAABQAAABpbmRleCBvdXQgb2\
YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAA0AMQACAAAADwAxAAEgAAADog\
AACgCBAAAAAAABQEEAACAAAAKTAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MT\
kyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4\
NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nz\
c4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5cmFuZ2Ugc3RhcnQgaW5k\
ZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIAAAAPEEEAASAAAAAwUQACIAAAByYW\
5nZSBlbmQgaW5kZXggOAUQABAAAAADBRAAIgAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdCAgYnV0IGVu\
ZHMgYXQgAFgFEAAWAAAAbgUQAA0AAABzb3VyY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMgbm90IG1hdG\
NoIGRlc3RpbmF0aW9uIHNsaWNlIGxlbmd0aCAojAUQABUAAAChBRAAKwAAACgEEAABAAAAVAYQAE0A\
AAAQDAAADQAAAH4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4Mj\
MvYmxvY2stYnVmZmVyLTAuMTAuMC9zcmMvbGliLnJz9AUQAFAAAAD8AAAAJwAAAC9ydXN0Yy9mMWVk\
ZDA0Mjk1ODJkZDI5Y2NjYWNhZjUwZmQxMzRiMDU1OTNiZDljL2xpYnJhcnkvY29yZS9zcmMvc2xpY2\
UvbW9kLnJzYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKClUBhAATQAAAB8GAAAJAAAA\
AAAAAAEjRWeJq83v/ty6mHZUMhDw4dLDAAAAAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgFm6vZgx8Zze\
Bb2J4FwQfVfDYX3XAwOVkO9zELwP8RFVhop4/5ZKRP+r4IybzzZ+YJajunyoSFrme7K/iU/nLzbjzx\
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\
VLSXhkgqvmZpjtMt3KKVK4U8kqwRLMB7qPINmbGII743Txv6CIB8A+VUTcjQcB/UV85+7K2QVDo6Bt\
knPCsAv6IwgISjrn7AAyDtbTICxoZAqWl9KKeDinr1MMtfesV55+t55ERotem83AUPtHOj4g5XiG54\
Gteg9ui9zbqchy+jZMG80WqXi9dmll7iIas8w+XlqmMQkJCNaUhEsxiYu4oePq6HZOO03DuJMfm9rx\
nVu1/coEVjymWUmyb+KIbsUZw/YAFdHrdJUKEGQORNsct29+VwbL/tK1Xv8hgSQaM2WnAIBwzLRGCY\
T3UUTecOKKgOQ9lWzWVQX1PXkSXBlu8KcvEjMsgfpWNzbzmgw251bGwgcG9pbnRlciBwYXNzZWQgdG\
8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQg\
dG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3QAAAQAAAAAAAAAQAAAACAAAAAwAAAAIAAAACAAAAAcAA\
AAIAAAADAAAABAAAAAEAAAABAAAAAUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIAAAADAAAABA\
AAAAIAAAAEAAAAAYAAAAQAAAACAAAAAwAAAAIAAAACAAAAAcAAAAIAAAADAAAABAAAAAEAAAABAAAA\
AUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIAAAADAAAABAAAAAIAAAAEAAAAAYAAAAANm3gIAA\
BG5hbWUBzreAgAB3AEVqc19zeXM6OlR5cGVFcnJvcjo6bmV3OjpfX3diZ19uZXdfYTRiNjFhMGY1ND\
gyNGNmZDo6aDVkNzhiNTczMzA4ODhkZmMBO3dhc21fYmluZGdlbjo6X193YmluZGdlbl9vYmplY3Rf\
ZHJvcF9yZWY6OmhmOGQ1NWUyOTY2MWNmMmMzAlVqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfbGVuZ3\
RoOjpfX3diZ19ieXRlTGVuZ3RoXzNlMjUwYjQxYTg5MTU3NTc6OmgzYjMxOGIxOGQ4ZjI4YmJiA1Vq\
c19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfb2Zmc2V0OjpfX3diZ19ieXRlT2Zmc2V0XzQyMDRlY2IyNG\
E2ZTVkZjk6OmgwMWMwN2M5MTZkMGRhN2UxBExqc19zeXM6OlVpbnQ4QXJyYXk6OmJ1ZmZlcjo6X193\
YmdfYnVmZmVyX2ZhY2YwMzk4YTI4MWM4NWI6OmhhMDMyM2EyMGJlYTAwZDgwBXlqc19zeXM6OlVpbn\
Q4QXJyYXk6Om5ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGg6Ol9fd2JnX25ld3dpdGhieXRl\
b2Zmc2V0YW5kbGVuZ3RoXzRiOWI4YzRlM2Y1YWRiZmY6OmhmMzFiMWFiYmIzYmMxM2JiBkxqc19zeX\
M6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzFlYjhmYzYwOGEwZDRjZGI6OmhkM2I3\
MTk5ZGY0ZDc4Y2NkBzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoODkyYTNjZGU4NG\
VhMTRmMQhVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl8z\
OTdlYWE0ZDcyZWU5NGRkOjpoMGE4NmI1ZWRiYTIxM2ZkYQlGanNfc3lzOjpVaW50OEFycmF5OjpuZX\
c6Ol9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmOjpoNjlmMDc1YzAxMzBkYjhhNQpGanNfc3lzOjpV\
aW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwOjpoMTFiZWUxMTIxZTAxZj\
cyYgsxd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoZDc3NmVjZjQ0ZjhjNmFjNQxAZGVu\
b19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0OjpoMTA1Y2Q2NGEwYzM2Y2\
QzZg0sc2hhMjo6c2hhNTEyOjpjb21wcmVzczUxMjo6aDZiMTBjMzNhZDA1YzM1ZjYOSmRlbm9fc3Rk\
X3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdF9hbmRfcmVzZXQ6OmhlMmUyZmI2Ym\
I0Yzk4ZWZiD0BkZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0Ojp1cGRhdGU6Omhm\
ZmY1NWRkZjM1M2YzOTVkECxzaGEyOjpzaGEyNTY6OmNvbXByZXNzMjU2OjpoZTg3ODAyOWNjZmRkM2\
RmNBEzYmxha2UyOjpCbGFrZTJiVmFyQ29yZTo6Y29tcHJlc3M6Omg5Zjg3YTc2YThmYmVlMjJiEily\
aXBlbWQ6OmMxNjA6OmNvbXByZXNzOjpoMTg5YzQ3OWZiZDY3YWZhZBMzYmxha2UyOjpCbGFrZTJzVm\
FyQ29yZTo6Y29tcHJlc3M6Omg5ZGRhOWMyYTJiNjE3Njg5FCtzaGExOjpjb21wcmVzczo6Y29tcHJl\
c3M6Omg1MGU1ZDgzZTkxZDY1NGFhFTtkZW5vX3N0ZF93YXNtX2NyeXB0bzo6RGlnZXN0Q29udGV4dD\
o6bmV3OjpoOTM3MDI0OThjYjZjZDE4ORY6ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6\
bWFsbG9jOjpoMmEyNzIwN2VlOWFmN2ZlORcsdGlnZXI6OmNvbXByZXNzOjpjb21wcmVzczo6aDZkMj\
U4ZmJmNzU0OGJmZTEYLWJsYWtlMzo6T3V0cHV0UmVhZGVyOjpmaWxsOjpoYTljMjcwYzliN2ZmNDFl\
ZRk2Ymxha2UzOjpwb3J0YWJsZTo6Y29tcHJlc3NfaW5fcGxhY2U6OmhjNGFkNzQ3N2NiZjUyZjBlGh\
NkaWdlc3Rjb250ZXh0X2Nsb25lG2U8ZGlnZXN0Ojpjb3JlX2FwaTo6d3JhcHBlcjo6Q29yZVdyYXBw\
ZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6Ont7Y2xvc3VyZX19OjpoNDcwNmQ4NDE5Ym\
QwMjBiZBxoPG1kNTo6TWQ1Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+\
OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjp7e2Nsb3N1cmV9fTo6aDIyZmYyYTYxYmVlOGQxMjEdMGJsYW\
tlMzo6Y29tcHJlc3Nfc3VidHJlZV93aWRlOjpoOTk1ZjkyYTA5OWQ5ODYzNB44ZGxtYWxsb2M6OmRs\
bWFsbG9jOjpEbG1hbGxvYzxBPjo6ZnJlZTo6aGNiNzk0N2E5YTdlMjgyY2EfIG1kNDo6Y29tcHJlc3\
M6Omg5MGQ1NDAzNmNhNjMzZTNjIEFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNw\
b3NlX2NodW5rOjpoMmY5MGJkZGZhYjlmZGFmOSETZGlnZXN0Y29udGV4dF9yZXNldCJyPHNoYTI6Om\
NvcmVfYXBpOjpTaGE1MTJWYXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OlZhcmlhYmxlT3V0cHV0\
Q29yZT46OmZpbmFsaXplX3ZhcmlhYmxlX2NvcmU6Omg5ZWE0YTIxNThlMDcwMzNiIy9ibGFrZTM6Ok\
hhc2hlcjo6ZmluYWxpemVfeG9mOjpoYjg4M2U2YzVjNGU1ZDQwYiQga2VjY2FrOjpmMTYwMDo6aGE4\
MjU3OTBjZjI1YTVmNWUlLGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWQ6Omg0OWQyY2ZjY2FmYmJkZT\
RkJg5fX3J1c3RfcmVhbGxvYydyPHNoYTI6OmNvcmVfYXBpOjpTaGEyNTZWYXJDb3JlIGFzIGRpZ2Vz\
dDo6Y29yZV9hcGk6OlZhcmlhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3ZhcmlhYmxlX2NvcmU6Om\
gwM2E5MzBiOGM3NGM5ZWQ1KF08c2hhMTo6U2hhMUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4\
ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGI1ZDllYzcwMjQ4ZTE4MjApMWJsYW\
tlMzo6SGFzaGVyOjptZXJnZV9jdl9zdGFjazo6aDQ3YjZlMjRlNjdlMjE2NWIqNWNvcmU6OmZtdDo6\
Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OmhjNjY5NDdiMWRlZDU3OGFhKyNjb3JlOjpmbXQ6OndyaX\
RlOjpoYmJhZjM5ZjA5YmY0OWVmYiw0Ymxha2UzOjpjb21wcmVzc19wYXJlbnRzX3BhcmFsbGVsOjpo\
YTA3MzJmYWNiMTI3NjliYi1kPHJpcGVtZDo6UmlwZW1kMTYwQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYX\
BpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoZGU4ZmMyYWY3MTFmMTg1\
Zi5bPG1kNTo6TWQ1Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW\
5hbGl6ZV9maXhlZF9jb3JlOjpoMGIzMDAzZTQ4NDI5YWMzZC9bPG1kNDo6TWQ0Q29yZSBhcyBkaWdl\
c3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoM2UyYj\
MwMDczMGFhOGFmMDBfPHRpZ2VyOjpUaWdlckNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRP\
dXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDQ1NzNhNDBlYmM1NGNhNTMxMGRsbWFsbG\
9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoMTg5ZmJjYTAzNzNhYjgyODJlPGRpZ2VzdDo6Y29yZV9h\
cGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZG\
VyPjo6cmVhZDo6aDY2ZWNhYWJkY2FlNWI2YzkzZTxkaWdlc3Q6OmNvcmVfYXBpOjp4b2ZfcmVhZGVy\
OjpYb2ZSZWFkZXJDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlhvZlJlYWRlcj46OnJlYWQ6OmgxMT\
UwZDlhNGM1NDUyNmQ5NC1ibGFrZTM6OkNodW5rU3RhdGU6OnVwZGF0ZTo6aGM1ODhhOGNkN2MyNmNl\
ZjU1L2NvcmU6OmZtdDo6bnVtOjppbXA6OmZtdF91NjQ6Omg2NjI4YTNlNzIyN2U4NTUzNgZkaWdlc3\
Q3PmRlbm9fc3RkX3dhc21fY3J5cHRvOjpEaWdlc3RDb250ZXh0Ojp1cGRhdGU6OmgyNGY5YmIzMWIw\
YzliNzkwOFs8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZT\
o6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmhhY2M4MzRjMmE0MDExODhmORtkaWdlc3Rjb250ZXh0X2Rp\
Z2VzdEFuZERyb3A6Bm1lbWNweTsGbWVtc2V0PD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cm\
VzOjppbnZva2UzX211dDo6aDdmYjEyNTEyZTA3YmQxZjc9EWRpZ2VzdGNvbnRleHRfbmV3PhRkaWdl\
c3Rjb250ZXh0X2RpZ2VzdD8tanNfc3lzOjpVaW50OEFycmF5Ojp0b192ZWM6OmhmY2JiMjgxYTc0OT\
MwNTIwQBxkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZFJlc2V0QS5jb3JlOjpyZXN1bHQ6OnVud3JhcF9m\
YWlsZWQ6OmhkNTg0ZWZiN2I4NGJmMzI2QlA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcj\
xUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOGNhMzY5Yzk4MTBjMjIyOUNQPGFycmF5dmVj\
OjplcnJvcnM6OkNhcGFjaXR5RXJyb3I8VD4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGFiZD\
JiNjQzZGQwZWNkMmNEWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBh\
cyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDY5YTI5MTg4MDk5ZmFkODhFWzxibG9ja19idW\
ZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+Ojpj\
bG9uZTo6aGI0ZTUyZDAzNjFkZGNiODlGWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2\
l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDBhZTg3YmU0ZmQxOWZiZjRH\
WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZT\
o6Q2xvbmU+OjpjbG9uZTo6aDViYjE1ZmNkMjdhMTg1ZGZIWzxibG9ja19idWZmZXI6OkJsb2NrQnVm\
ZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDczZWIxMz\
RhMzI4NzVmZjdJWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBj\
b3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDNlYzIzYzc3ODMwZDM2NjRKP2NvcmU6OnNsaWNlOj\
ppbmRleDo6c2xpY2VfZW5kX2luZGV4X2xlbl9mYWlsOjpoYzNlMGRjZjZkODY2ZTFiZUtBY29yZTo6\
c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aDZjMTA5YWM4NTg3ZjI5MT\
FMPWNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfaW5kZXhfb3JkZXJfZmFpbDo6aGQyN2RjMzg1YTdl\
YzEzYzFNTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYX\
RjaF9mYWlsOjpoZWRkMTBjNWJjYzAyNjEwY042Y29yZTo6cGFuaWNraW5nOjpwYW5pY19ib3VuZHNf\
Y2hlY2s6OmhjZTA1MDJmNjM3MTFmYWQ4TzdzdGQ6OnBhbmlja2luZzo6cnVzdF9wYW5pY193aXRoX2\
hvb2s6Omg2MDZkN2M3ZjdhNDIzYjk4UDpibGFrZTI6OkJsYWtlMmJWYXJDb3JlOjpuZXdfd2l0aF9w\
YXJhbXM6Omg1ODdmOWE3Mjc5ZjM3MTZkURhfX3diZ19kaWdlc3Rjb250ZXh0X2ZyZWVSBm1lbWNtcF\
NDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6d3JpdGVfcHJlZml4OjpoYWEwYWRm\
MDBjYjY3ZGVkN1QpY29yZTo6cGFuaWNraW5nOjpwYW5pYzo6aGVjMWZjMDU3YmQwYmFmMGJVFGRpZ2\
VzdGNvbnRleHRfdXBkYXRlVhFfX3diaW5kZ2VuX21hbGxvY1c6Ymxha2UyOjpCbGFrZTJzVmFyQ29y\
ZTo6bmV3X3dpdGhfcGFyYW1zOjpoNWZmNDU5ZjIzMWFiOGQ2OFgtY29yZTo6cGFuaWNraW5nOjpwYW\
5pY19mbXQ6Omg2MzE0YjVjOTFhYmU3MzQ5WT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVz\
OjppbnZva2U0X211dDo6aDNhOTBmNjIyOGY4N2JmMmFaP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2\
xvc3VyZXM6Omludm9rZTNfbXV0OjpoZjcyNTE0MTM3YzU4YjI1NFs/d2FzbV9iaW5kZ2VuOjpjb252\
ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzYzEzN2VhOTQ0ZThjNmMyXD93YXNtX2JpbmRnZW\
46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGIyMDMyZTIyODg3NGRlMTJdP3dhc21f\
YmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoNDU3ZmQ2MjZhOTdmMzIzZV\
4/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgyOTIwY2MxM2U4\
ODkwMjAzXz93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDQ3ZG\
FkYjQ0N2Q3NjlmODVgP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0\
OjpoYjY5NTY1MWUxNWRhMzk4N2E/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2\
tlMl9tdXQ6Omg1ODZiMzZlNDY0NDIyY2Q0YkNzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFu\
ZGxlcjo6e3tjbG9zdXJlfX06Omg5Yjk4NWEyOTNhYWM0Y2UxYxJfX3diaW5kZ2VuX3JlYWxsb2NkP3\
dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTFfbXV0OjpoZGIzMDcxOWY5NDI1\
NTZlN2UyY29yZTo6b3B0aW9uOjpPcHRpb248VD46OnVud3JhcDo6aDVhN2RmOTFiNWQ2MDkwY2JmMD\
wmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMGQ5Y2Q2MjZkYWJhYTFlZmcyPCZUIGFzIGNv\
cmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGQzMDNiYzE2YWVlNTU5MTBoEXJ1c3RfYmVnaW5fdW53aW\
5kaQ9fX3diaW5kZ2VuX2ZyZWVqNGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDRi\
NDkwMTQ4MzBjYWZlNjNrM2FycmF5dmVjOjphcnJheXZlYzo6ZXh0ZW5kX3BhbmljOjpoMzdkNTk4ZD\
c1ZDBkMmU2Zmw5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6OmgyYWI4Njc2\
N2VjMTdjNTBkbR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVybk5jb3JlOjpmbXQ6Om51bT\
o6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIHUzMj46OmZtdDo6aDA0NmVjYzVlYWFi\
MzRjZDVvMXdhc21fYmluZGdlbjo6X19ydDo6dGhyb3dfbnVsbDo6aGQyZjhkMzcwNzBlOWNhYjRwMn\
dhc21fYmluZGdlbjo6X19ydDo6Ym9ycm93X2ZhaWw6OmhkNDdlYTRlMzA4NDZkMzA5cSp3YXNtX2Jp\
bmRnZW46OnRocm93X3N0cjo6aDgwMzQ3MGFlNWVmYmIzNzlySXN0ZDo6c3lzX2NvbW1vbjo6YmFja3\
RyYWNlOjpfX3J1c3RfZW5kX3Nob3J0X2JhY2t0cmFjZTo6aGEwM2FiZWYwMmE4YjcwZmRzMTxUIGFz\
IGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGEwYzQ0OTIyMTZkNGQyZTd0CnJ1c3RfcGFuaWN1N3\
N0ZDo6YWxsb2M6OmRlZmF1bHRfYWxsb2NfZXJyb3JfaG9vazo6aGY5YzM5M2JhM2NkMjg3ZTF2b2Nv\
cmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmY29yZTo6aXRlcjo6YWRhcHRlcnM6OmNvcGllZDo6Q29waW\
VkPGNvcmU6OnNsaWNlOjppdGVyOjpJdGVyPHU4Pj4+OjpoNjNjMmUxNDk3YjUyZjNkNwD7gICAAAlw\
cm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNTcuMCAoZjFlZG\
QwNDI5IDIwMjEtMTEtMjkpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuEjAuMi44MCAoOWE2ZTc3\
ZjVlKQ==\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
const digestAlgorithms = [
    "BLAKE2B-256",
    "BLAKE2B-384",
    "BLAKE2B",
    "BLAKE2S",
    "BLAKE3",
    "KECCAK-224",
    "KECCAK-256",
    "KECCAK-384",
    "KECCAK-512",
    "SHA-384",
    "SHA3-224",
    "SHA3-256",
    "SHA3-384",
    "SHA3-512",
    "SHAKE128",
    "SHAKE256",
    "TIGER",
    "RIPEMD-160",
    "SHA-224",
    "SHA-256",
    "SHA-512",
    "MD4",
    "MD5",
    "SHA-1", 
];
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
const nextTick2 = nextTick1;
const env = new Proxy({}, {
    get (_target, prop) {
        return Deno.env.get(String(prop));
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name)=>{
        const e = Deno.env.toObject();
        if (name in Deno.env.toObject()) {
            const o = {
                enumerable: true,
                configurable: true
            };
            if (typeof name === "string") {
                o.value = e[name];
            }
            return o;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    }
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v16.11.1";
const versions = {
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
};
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick1(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick1(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal1 = (signal, name)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort));
    }
    return stream;
}
const kDestroy = Symbol("kDestroy");
const kConstruct = Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy1(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self1, err, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self1._readableState;
        const w = self1._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick1(emitErrorCloseNT, self1, err);
        } else {
            nextTick1(emitCloseNT, self1);
        }
    }
    try {
        const result = self1._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick1(onDestroy, null);
                }, function(err) {
                    nextTick1(onDestroy, err);
                });
            }
        }
    } catch (err1) {
        onDestroy(err1);
    }
}
function emitErrorCloseNT(self1, err) {
    emitErrorNT(self1, err);
    emitCloseNT(self1);
}
function emitCloseNT(self1) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self1.emit("close");
    }
}
function emitErrorNT(self1, err) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self1.emit("error", err);
}
function undestroy() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }
    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick1(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
        return;
    }
    nextTick1(constructNT, stream);
}
function constructNT(stream) {
    let called = false;
    function onConstruct(err) {
        if (called) {
            errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }
        if (s.destroyed) {
            stream.emit(kDestroy, err);
        } else if (err) {
            errorOrDestroy(stream, err, true);
        } else {
            nextTick1(emitConstructNT, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick1(onConstruct, null);
                }, function(err) {
                    nextTick1(onConstruct, err);
                });
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}
function emitConstructNT(stream) {
    stream.emit(kConstruct);
}
function isRequest1(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
    if (!stream) return;
    if (isRequest1(stream)) return stream.abort();
    if (isRequest1(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err);
    if (typeof stream.close === "function") return stream.close();
}
const __default3 = {
    construct,
    destroyer,
    destroy: destroy1,
    undestroy,
    errorOrDestroy
};
const kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded1(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const stdio = {};
function isBlob(object) {
    return object instanceof Blob;
}
function _from1(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer) {
        return new Readable({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error, cb) {
        close(error).then(()=>nextTick2(cb, error), (e)=>nextTick2(cb, e || error));
    };
    async function close(error) {
        const hadError = error !== undefined && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value: value1  } = await iterator.return();
            await value1;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
}
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i = 0; i < eventTargets.length; i++){
            const target = eventTargets[i];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i = 0; i < len; ++i){
            const result1 = listeners[i].apply(this, args);
            if (result1 !== undefined && result1 !== null) {
                addCatch(this, result1, type, args);
            }
        }
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i = 0; i < ret.length; ++i){
        const orig = ret[i].listener;
        if (typeof orig === "function") {
            ret[i] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve(args);
        };
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
            }
            if (finished) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve, reject) {
                unconsumedPromises.push({
                    resolve,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
function Stream(opts) {
    EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented;
(function(NotImplemented) {
    NotImplemented[NotImplemented["ascii"] = 0] = "ascii";
    NotImplemented[NotImplemented["latin1"] = 1] = "latin1";
    NotImplemented[NotImplemented["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding1(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self1, buf, i) {
    let j = buf.length - 1;
    if (j < i) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self1.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self1, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self1.lastNeed = 0;
        return "\ufffd";
    }
    if (self1.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self1.lastNeed = 1;
            return "\ufffd";
        }
        if (self1.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self1.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
    const total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
}
function base64Text(buf, i) {
    const n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
const PStringDecoder = new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
const __default4 = {
    StringDecoder: PStringDecoder
};
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p = this.head;
        let ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer.alloc(0);
        }
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while(p){
            ret.set(p.data, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    }
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p = this.head; p; p = p.next){
            yield p.data;
        }
    }
    _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug = debuglog("stream", (fn)=>{
    debug = fn;
});
const kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop1 = ()=>{};
const { errorOrDestroy: errorOrDestroy1  } = __default3;
function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }
    const isDuplex = this instanceof Stream.Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default3.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}
Readable.prototype.destroy = __default3.destroy;
Readable.prototype._undestroy = __default3.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
                if (addToFront && state.encoding) {
                    chunk = Buffer.from(chunk, encoding).toString(state.encoding);
                } else {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer) {
            encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err) {
        errorOrDestroy1(stream, err);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state.endEmitted) {
                errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state, chunk, true);
            }
        } else if (state.ended) {
            errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
            return false;
        } else {
            state.reading = false;
            if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) {
                    addChunk(stream, state, chunk, false);
                } else {
                    maybeReadMore(stream, state);
                }
            } else {
                addChunk(stream, state, chunk, false);
            }
        }
    } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state.buffer.unshift(chunk);
        } else {
            state.buffer.push(chunk);
        }
        if (state.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer){
        content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "") {
        buffer.push(content);
    }
    this._readableState.length = content.length;
    return this;
};
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= 0x40000000) {
        n = MAX_HWM;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) {
        return 0;
    }
    if (state.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        if (state.flowing && state.length) {
            return state.buffer.first().length;
        }
        return state.length;
    }
    if (n <= state.length) {
        return n;
    }
    return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n) {
    debug("read", n);
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark) {
        state.highWaterMark = computeNewHighWaterMark(n);
    }
    if (n !== 0) {
        state.emittedReadable = false;
    }
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
        if (state.length === 0) {
            endReadable(this);
        }
        return null;
    }
    let doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) {
            state.needReadable = true;
        }
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) {
            n = howMuchToRead(nOrig, state);
        }
    }
    let ret;
    if (n > 0) {
        ret = fromList(n, state);
    } else {
        ret = null;
    }
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
    }
    if (state.length === 0) {
        if (!state.ended) {
            state.needReadable = true;
        }
        if (nOrig !== n && state.ended) {
            endReadable(this);
        }
    }
    if (ret !== null) {
        state.dataEmitted = true;
        this.emit("data", ret);
    }
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        emitReadable(stream);
    } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
    }
}
function emitReadable(stream) {
    const state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        nextTick1(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    const state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        nextTick1(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) {
            break;
        }
    }
    state.readingMore = false;
}
Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [
                state.awaitDrainWriters
            ] : []);
        }
    }
    state.pipes.push(dest);
    debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) {
        nextTick1(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
                debug("false write response, pause", 0);
                state.awaitDrainWriters = dest;
                state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                debug("false write response, pause", state.awaitDrainWriters.size);
                state.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            pause();
        }
    }
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter.listenerCount(dest, "error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                errorOrDestroy1(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state.flowing) {
            pause();
        }
    } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
            debug("pipeOnDrain", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for(let i = 0; i < dests.length; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index = state.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            } else if (!state.reading) {
                nextTick1(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick1(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick1(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self1) {
    const state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
    } else if (self1.listenerCount("data") > 0) {
        self1.resume();
    } else if (!state.readableListening) {
        state.flowing = null;
    }
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
Readable.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state[kPaused] = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick1(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) {
        stream.read(0);
    }
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
};
function flow(stream) {
    const state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err)=>{
        errorOrDestroy1(this, err);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i = streamKeys[j];
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = stream[i].bind(stream);
        }
    }
    return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator(stream, options) {
    let callback = nop1;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve) {
        if (this === stream) {
            callback();
            callback = nop1;
        } else {
            callback = resolve;
        }
    }
    const state = stream._readableState;
    let error = state.errored;
    let errorEmitted = state.errorEmitted;
    let endEmitted = state.endEmitted;
    let closeEmitted = state.closeEmitted;
    stream.on("readable", next).on("error", function(err) {
        error = err;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            __default3.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state.autoDestroy || !endEmitted) {
                __default3.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable.prototype, {
    readable: {
        get () {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state) {
            if (this._readableState) {
                this._readableState.flowing = state;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused] !== false;
        },
        set (value) {
            this[kPaused] = !!value;
        }
    }
});
function fromList(n, state) {
    if (state.length === 0) {
        return null;
    }
    let ret;
    if (state.objectMode) {
        ret = state.buffer.shift();
    } else if (!n || n >= state.length) {
        if (state.decoder) {
            ret = state.buffer.join("");
        } else if (state.buffer.length === 1) {
            ret = state.buffer.first();
        } else {
            ret = state.buffer.concat(state.length);
        }
        state.buffer.clear();
    } else {
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    const state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        nextTick1(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick1(endWritableNT, stream);
        } else if (state.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom(iterable, opts) {
    return _from1(Readable, iterable, opts);
}
function wrap(src, options) {
    return new Readable({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err, callback) {
            __default3.destroyer(src, err);
            callback(err);
        }
    }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
const { errorOrDestroy: errorOrDestroy2  } = __default3;
function isDuplexStream(maybe_duplex) {
    const isReadable = Readable.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {}
const kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
}
function resetBuffer(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable(options) {
    const isDuplex = isDuplexStream(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default3.construct(this, ()=>{
        const state = this._writableState;
        if (!state.writing) {
            clearBuffer(this, state);
        }
        finishMaybe(this, state);
    });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
    }
});
Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop2;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state.objectMode) {
        if (typeof chunk === "string") {
            if (state.decodeStrings !== false) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer) {
            encoding = "buffer";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err;
    if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
    }
    if (err) {
        nextTick1(cb, err);
        errorOrDestroy2(stream, err, true);
        return err;
    }
    state.pendingcb++;
    return writeOrBuffer(stream, state, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing) {
            clearBuffer(this, state);
        }
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret) {
        state.needDrain = true;
    }
    if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state.allBuffers && encoding !== "buffer") {
            state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop2) {
            state.allNoop = false;
        }
    } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) {
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
    } else if (writev) {
        stream._writev(chunk, state.onwrite);
    } else {
        stream._write(chunk, encoding, state.onwrite);
    }
    state.sync = false;
}
function onwriteError(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer(state);
    errorOrDestroy2(stream, er);
}
function onwrite(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
        er.stack;
        if (!state.errored) {
            state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick1(onwriteError, stream, state, er, cb);
        } else {
            onwriteError(stream, state, er, cb);
        }
    } else {
        if (state.buffered.length > state.bufferedIndex) {
            clearBuffer(stream, state);
        }
        if (sync) {
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
                state.afterWriteTickInfo.count++;
            } else {
                state.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state
                };
                nextTick1(afterWriteTick, state.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state, 1, cb);
        }
    }
}
function afterWriteTick({ stream , state , count , cb  }) {
    state.afterWriteTickInfo = null;
    return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
    while(count-- > 0){
        state.pendingcb--;
        cb();
    }
    if (state.destroyed) {
        errorBuffer(state);
    }
    finishMaybe(stream, state);
}
function errorBuffer(state) {
    if (state.writing) {
        return;
    }
    for(let n = state.bufferedIndex; n < state.buffered.length; ++n){
        const { chunk , callback  } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for(let i = 0; i < onfinishCallbacks.length; i++){
        onfinishCallbacks[i](new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
}
function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop2 : (err)=>{
            for(let n = i; n < buffered.length; ++n){
                buffered[n].callback(err);
            }
        };
        const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
    } else {
        do {
            const { chunk , encoding , callback: callback1  } = buffered[i];
            buffered[i++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, callback1);
        }while (i < buffered.length && !state.writing)
        if (i === buffered.length) {
            resetBuffer(state);
        } else if (i > 256) {
            buffered.splice(0, i);
            state.bufferedIndex = 0;
        } else {
            state.bufferedIndex = i;
        }
    }
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    if (err) {} else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
    } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
        if (err || state.finished) {
            nextTick2(cb, err);
        } else {
            state[kOnFinished].push(cb);
        }
    }
    return this;
};
function needFinish(state) {
    return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
    let called = false;
    function onFinish(err) {
        if (called) {
            errorOrDestroy2(stream, err ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
            const onfinishCallbacks = state[kOnFinished].splice(0);
            for(let i = 0; i < onfinishCallbacks.length; i++){
                onfinishCallbacks[i](err);
            }
            errorOrDestroy2(stream, err, state.sync);
        } else if (needFinish(state)) {
            state.prefinished = true;
            stream.emit("prefinish");
            state.pendingcb++;
            nextTick1(finish, stream, state);
        }
    }
    state.sync = true;
    state.pendingcb++;
    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick1(onFinish, null);
                }, function(err) {
                    nextTick1(onFinish, err);
                });
            }
        }
    } catch (err) {
        onFinish(stream, state, err);
    }
    state.sync = false;
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.finalCalled = true;
            callFinal(stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0 && needFinish(state)) {
            state.pendingcb++;
            if (sync) {
                nextTick1(finish, stream, state);
            } else {
                finish(stream, state);
            }
        }
    }
}
function finish(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished].splice(0);
    for(let i = 0; i < onfinishCallbacks.length; i++){
        onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy2 = __default3.destroy;
Writable.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        nextTick2(errorBuffer, state);
    }
    destroy2.call(this, err, cb);
    return this;
};
Writable.prototype._undestroy = __default3.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Writable.WritableState = WritableState;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
    for (const method of Object.keys(Writable.prototype)){
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
function isReadableStream(object) {
    return object instanceof ReadableStream;
}
function isWritableStream(object) {
    return object instanceof WritableStream;
}
Duplex.fromWeb = function(pair, options) {
    validateObject(pair, "pair");
    const { readable: readableStream , writable: writableStream ,  } = pair;
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding , decodeStrings =true , highWaterMark , signal ,  } = options;
    validateBoolean(objectMode, "options.objectMode");
    if (encoding !== undefined && !Buffer.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error1) {
                    nextTick2(()=>destroy(duplex, error1));
                }
            }
            writer.ready.then(()=>Promise.All(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    destroy(duplex, error1);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick2(()=>destroy(duplex, error1));
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex.push(null);
                } else {
                    duplex.push(chunk.value);
                }
            }, (error)=>destroy(duplex, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick2(()=>{
                        throw error1;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.All([
                    closeWriter(),
                    closeReader(), 
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded(duplex)) {
            destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex, error);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded1(duplex)) {
            duplex.push(null);
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex, error);
    });
    return duplex;
};
class Duplexify extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify(body, name) {
    if (isDuplexNodeStream(body)) {
        return body;
    }
    if (isReadableNodeStream(body)) {
        return _duplexify({
            readable: body
        });
    }
    if (isWritableNodeStream(body)) {
        return _duplexify({
            writable: body
        });
    }
    if (isNodeStream(body)) {
        return _duplexify({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write , final: __final , destroy: destroy1  } = fromAsyncGen(body);
        if (isIterable(value)) {
            return _from1(Duplexify, value, {
                objectMode: true,
                write,
                final: __final,
                destroy: destroy1
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
            }, (err)=>{
                destroyer(d, err);
            });
            return d = new Duplexify({
                objectMode: true,
                readable: false,
                write,
                final (cb) {
                    __final(async ()=>{
                        try {
                            await promise;
                            nextTick2(cb, null);
                        } catch (err) {
                            nextTick2(cb, err);
                        }
                    });
                },
                destroy: destroy1
            });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
        return _from1(Duplexify, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : undefined;
        return _duplexify({
            readable,
            writable
        });
    }
    const then1 = body?.then;
    if (typeof then1 === "function") {
        let d1;
        then1.call(body, (val)=>{
            if (val != null) {
                d1.push(val);
            }
            d1.push(null);
        }, (err)=>{
            destroyer(d1, err);
        });
        return d1 = new Duplexify({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen(fn) {
    let { promise , resolve  } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick1(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError();
            ({ promise , resolve  } = createDeferredPromise());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err, cb) {
            ac.abort();
            cb(err);
        }
    };
}
function _duplexify(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable1(r);
    let writable = !!isWritable1(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    d = new Duplexify({
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos(w, (err)=>{
            writable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            w.end();
            onfinish = callback;
        };
        w.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos(r, (err)=>{
            readable = false;
            if (err) {
                destroyer(r, err);
            }
            onfinished(err);
        });
        r.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = r.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(w, err);
            destroyer(r, err);
        }
    };
    return d;
}
function duplexFrom(body) {
    return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
const kCallback = Symbol("kCallback");
function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish1);
}
function __final(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data != null) {
                this.push(data);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data)=>{
                        if (called) {
                            return;
                        }
                        if (data != null) {
                            this.push(data);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick1(cb);
                        }
                    }, (err)=>{
                        if (cb) {
                            nextTick1(cb, err);
                        } else {
                            nextTick1(()=>this.destroy(err));
                        }
                    });
                }
            } catch (err) {
                nextTick1(()=>this.destroy(err));
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish1() {
    if (this._final !== __final) {
        __final.call(this);
    }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err, val)=>{
        called = true;
        if (err) {
            callback(err);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick2(callback);
                    } else {
                        this[kCallback] = callback;
                    }
                }, (err)=>{
                    nextTick2(callback, err);
                });
            }
        } catch (err) {
            nextTick2(callback, err);
        }
    }
};
Transform.prototype._read = function() {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
    callback = once(callback);
    let finished = false;
    stream.on("close", ()=>{
        finished = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, (err)=>{
        finished = !err;
        const rState = stream._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err);
        }
    });
    return (err)=>{
        if (finished) return;
        finished = true;
        __default3.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function popCallback(streams) {
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish) {
    let error;
    let onresolve = null;
    const resume = (err)=>{
        if (err) {
            error = err;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve, reject)=>{
            if (error) {
                reject(error);
            } else {
                onresolve = ()=>{
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                };
            }
        });
    writable.on("drain", resume);
    const cleanup = eos(writable, {
        readable: false
    }, resume);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish();
    } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally{
        cleanup();
        writable.off("drain", resume);
    }
}
function pipeline(...streams) {
    const callback = once(popCallback(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError());
    }
    outerSignal?.addEventListener("abort", abort);
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
        finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, __final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error = err;
        }
        if (!error && !__final) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final) {
            callback(error, value);
        }
    }
    let ret;
    for(let i = 0; i < streams.length; i++){
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer1(stream, reading, writing, finish));
        }
        if (i === 0) {
            if (typeof stream === "function") {
                ret = stream({
                    signal
                });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === "function") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, {
                signal
            });
            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
                }
            } else {
                const pt = new PassThrough({
                    objectMode: true
                });
                const then = ret?.then;
                if (typeof then === "function") {
                    then.call(ret, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err)=>{
                        pt.destroy(err);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
                }
                ret = pt;
                finishCount++;
                destroys.push(destroyer1(ret, false, true, finish));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);
                if (stream === stdio.stdout || stream === stdio.stderr) {
                    ret.on("end", ()=>stream.end());
                }
            } else {
                ret = makeAsyncIterable(ret);
                finishCount++;
                pump(ret, stream, finish);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick1(abort);
    }
    return ret;
}
class ComposeDuplex extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }
    for(let n = 0; n < streams.length; ++n){
        if (!isNodeStream(streams[n])) {
            continue;
        }
        if (n < streams.length - 1 && !isReadable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable1(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!isWritable1(head);
    const readable = !!isReadable1(tail);
    d = new ComposeDuplex({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer(tail, err);
        }
    };
    return d;
}
function pipeline1(...streams) {
    return new Promise((resolve, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl(streams, (err, value)=>{
            if (err) {
                reject(err);
            } else {
                resolve(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished(stream, opts) {
    return new Promise((resolve, reject)=>{
        eos(stream, opts, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}
const __default5 = {
    finished,
    pipeline: pipeline1
};
const { custom: customPromisify  } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;
Object.defineProperty(Stream, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default5;
    }
});
Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get () {
        return __default5.pipeline;
    }
});
Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get () {
        return __default5.finished;
    }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
const hexTable = new TextEncoder().encode("0123456789abcdef");
function encode2(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 0x0f];
    }
    return dst;
}
const coerceToBytes = (data)=>{
    if (data instanceof Uint8Array) {
        return data;
    } else if (typeof data === "string") {
        return new TextEncoder().encode(data);
    } else if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    } else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
class Hash extends Transform {
    #context;
    constructor(algorithm, _opts){
        super({
            transform (chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush (callback) {
                this.push(context.digest(undefined));
                callback();
            }
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new (instantiate()).DigestContext(algorithm);
        } else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data, _encoding) {
        let bytes;
        if (typeof data === "string") {
            data = new TextEncoder().encode(data);
            bytes = coerceToBytes(data);
        } else {
            bytes = coerceToBytes(data);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer.from(digest);
        }
        switch(encoding){
            case "hex":
                return new TextDecoder().decode(encode2(new Uint8Array(digest)));
            case "binary":
                return String.fromCharCode(...digest);
            case "base64":
                return encode(digest);
            default:
                throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
        }
    }
}
class Hmac extends Transform {
    constructor(hmac, _key, _options){
        validateString(hmac, "hmac");
        super();
        notImplemented("crypto.Hmac");
    }
    digest(_encoding) {
        notImplemented("crypto.Hmac.prototype.digest");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Hmac.prototype.update");
    }
}
const opensslToWebCryptoDigestNames = {
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
    return new Hash(algorithm, opts);
}
const MAX_ALLOC = Math.pow(2, 30) - 1;
const createHasher = (algorithm)=>(value)=>Buffer.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros) {
    return Buffer.alloc(zeros);
}
const sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function toBuffer(bufferable) {
    if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer.from(bufferable);
    } else {
        return Buffer.from(bufferable.buffer);
    }
}
class Hmac1 {
    hash;
    ipad1;
    opad;
    alg;
    blocksize;
    size;
    ipad2;
    constructor(alg, key, saltLen){
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = this.hash(key);
        } else if (key.length < blocksize) {
            key = Buffer.concat([
                key,
                getZeroes(blocksize - key.length)
            ], blocksize);
        }
        const ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        for(let i = 0; i < blocksize; i++){
            ipad[i] = key[i] ^ 0x36;
            opad[i] = key[i] ^ 0x5c;
        }
        const ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
    }
    run(data, ipad) {
        data.copy(ipad, this.blocksize);
        const h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    }
}
function pbkdf2Sync(password, salt, iterations, keylen, digest = "sha1") {
    if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
    }
    const bufferedPassword = toBuffer(password);
    const bufferedSalt = toBuffer(salt);
    const hmac = new Hmac1(digest, bufferedPassword, bufferedSalt.length);
    const DK = Buffer.allocUnsafe(keylen);
    const block1 = Buffer.allocUnsafe(bufferedSalt.length + 4);
    bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
    let destPos = 0;
    const hLen = sizes[digest];
    const l = Math.ceil(keylen / hLen);
    for(let i = 1; i <= l; i++){
        block1.writeUInt32BE(i, bufferedSalt.length);
        const T = hmac.run(block1, hmac.ipad1);
        let U = T;
        for(let j = 1; j < iterations; j++){
            U = hmac.run(U, hmac.ipad2);
            for(let k = 0; k < hLen; k++)T[k] ^= U[k];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest = "sha1", callback) {
    setTimeout(()=>{
        let err = null, res;
        try {
            res = pbkdf2Sync(password, salt, iterations, keylen, digest);
        } catch (e) {
            err = e;
        }
        if (err) {
            callback(err instanceof Error ? err : new Error("[non-error thrown]"));
        } else {
            callback(null, res);
        }
    }, 0);
}
const fixOpts = (opts)=>{
    const out = {
        N: 16384,
        p: 1,
        r: 8,
        maxmem: 32 << 20
    };
    if (!opts) return out;
    if (opts.N) out.N = opts.N;
    else if (opts.cost) out.N = opts.cost;
    if (opts.p) out.p = opts.p;
    else if (opts.parallelization) out.p = opts.parallelization;
    if (opts.r) out.r = opts.r;
    else if (opts.blockSize) out.r = opts.blockSize;
    if (opts.maxmem) out.maxmem = opts.maxmem;
    return out;
};
function blockxor(S, Si, D, Di, len) {
    let i = -1;
    while(++i < len)D[Di + i] ^= S[Si + i];
}
function arraycopy(src, srcPos, dest, destPos, length) {
    src.copy(dest, destPos, srcPos, srcPos + length);
}
const R = (a, b)=>a << b | a >>> 32 - b;
class ScryptRom {
    B;
    r;
    N;
    p;
    XY;
    V;
    B32;
    x;
    _X;
    constructor(b, r, N, p){
        this.B = b;
        this.r = r;
        this.N = N;
        this.p = p;
        this.XY = Buffer.allocUnsafe(256 * r);
        this.V = Buffer.allocUnsafe(128 * r * N);
        this.B32 = new Int32Array(16);
        this.x = new Int32Array(16);
        this._X = Buffer.allocUnsafe(64);
    }
    run() {
        const p = this.p | 0;
        const r = this.r | 0;
        for(let i = 0; i < p; i++)this.scryptROMix(i, r);
        return this.B;
    }
    scryptROMix(i, r) {
        const blockStart = i * 128 * r;
        const offset = (2 * r - 1) * 64;
        const blockLen = 128 * r;
        const B = this.B;
        const N = this.N | 0;
        const V = this.V;
        const XY = this.XY;
        B.copy(XY, 0, blockStart, blockStart + blockLen);
        for(let i1 = 0; i1 < N; i1++){
            XY.copy(V, i1 * blockLen, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        let j;
        for(let i2 = 0; i2 < N; i2++){
            j = XY.readUInt32LE(offset) & N - 1;
            blockxor(V, j * blockLen, XY, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        XY.copy(B, blockStart, 0, blockLen);
    }
    blockmix_salsa8(blockLen) {
        const BY = this.XY;
        const r = this.r;
        const _X = this._X;
        arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
        let i;
        for(i = 0; i < 2 * r; i++){
            blockxor(BY, i * 64, _X, 0, 64);
            this.salsa20_8();
            arraycopy(_X, 0, BY, blockLen + i * 64, 64);
        }
        for(i = 0; i < r; i++){
            arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
            arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r) * 64, 64);
        }
    }
    salsa20_8() {
        const B32 = this.B32;
        const B = this._X;
        const x = this.x;
        let i;
        for(i = 0; i < 16; i++){
            B32[i] = (B[i * 4 + 0] & 0xff) << 0;
            B32[i] |= (B[i * 4 + 1] & 0xff) << 8;
            B32[i] |= (B[i * 4 + 2] & 0xff) << 16;
            B32[i] |= (B[i * 4 + 3] & 0xff) << 24;
        }
        for(i = 0; i < 16; i++)x[i] = B32[i];
        for(i = 0; i < 4; i++){
            x[4] ^= R(x[0] + x[12], 7);
            x[8] ^= R(x[4] + x[0], 9);
            x[12] ^= R(x[8] + x[4], 13);
            x[0] ^= R(x[12] + x[8], 18);
            x[9] ^= R(x[5] + x[1], 7);
            x[13] ^= R(x[9] + x[5], 9);
            x[1] ^= R(x[13] + x[9], 13);
            x[5] ^= R(x[1] + x[13], 18);
            x[14] ^= R(x[10] + x[6], 7);
            x[2] ^= R(x[14] + x[10], 9);
            x[6] ^= R(x[2] + x[14], 13);
            x[10] ^= R(x[6] + x[2], 18);
            x[3] ^= R(x[15] + x[11], 7);
            x[7] ^= R(x[3] + x[15], 9);
            x[11] ^= R(x[7] + x[3], 13);
            x[15] ^= R(x[11] + x[7], 18);
            x[1] ^= R(x[0] + x[3], 7);
            x[2] ^= R(x[1] + x[0], 9);
            x[3] ^= R(x[2] + x[1], 13);
            x[0] ^= R(x[3] + x[2], 18);
            x[6] ^= R(x[5] + x[4], 7);
            x[7] ^= R(x[6] + x[5], 9);
            x[4] ^= R(x[7] + x[6], 13);
            x[5] ^= R(x[4] + x[7], 18);
            x[11] ^= R(x[10] + x[9], 7);
            x[8] ^= R(x[11] + x[10], 9);
            x[9] ^= R(x[8] + x[11], 13);
            x[10] ^= R(x[9] + x[8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }
        for(i = 0; i < 16; i++)B32[i] += x[i];
        let bi;
        for(i = 0; i < 16; i++){
            bi = i * 4;
            B[bi + 0] = B32[i] >> 0 & 0xff;
            B[bi + 1] = B32[i] >> 8 & 0xff;
            B[bi + 2] = B32[i] >> 16 & 0xff;
            B[bi + 3] = B32[i] >> 24 & 0xff;
        }
    }
    clean() {
        this.XY.fill(0);
        this.V.fill(0);
        this._X.fill(0);
        this.B.fill(0);
        for(let i = 0; i < 16; i++){
            this.B32[i] = 0;
            this.x[i] = 0;
        }
    }
}
function scryptSync(password, salt, keylen, _opts) {
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b, r, N, p);
    const out = scryptRom.run();
    const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
    if (!cb) {
        cb = _opts;
        _opts = null;
    }
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    try {
        const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
        const scryptRom = new ScryptRom(b, r, N, p);
        const out = scryptRom.run();
        const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
        scryptRom.clean();
        cb(null, result);
    } catch (err) {
        return cb(err);
    }
}
const encrypt = function(self1, block) {
    return self1._cipher.encryptBlock(block);
};
const decrypt = function(self1, block) {
    return self1._cipher.decryptBlock(block);
};
const mod7 = {
    encrypt: encrypt,
    decrypt: decrypt
};
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const buffer = Buffer.allocUnsafe(length);
    for(let i = 0; i < length; ++i){
        buffer[i] = a[i] ^ b[i];
    }
    return buffer;
}
const encrypt1 = function(self1, block) {
    const data = xor(block, self1._prev);
    self1._prev = self1._cipher.encryptBlock(data);
    return self1._prev;
};
const decrypt1 = function(self1, block) {
    const pad = self1._prev;
    self1._prev = block;
    const out = self1._cipher.decryptBlock(block);
    return xor(out, pad);
};
const mod8 = {
    encrypt: encrypt1,
    decrypt: decrypt1
};
function encryptStart(self1, data, decrypt) {
    const len = data.length;
    const out = xor(data, self1._cache);
    self1._cache = self1._cache.slice(len);
    self1._prev = Buffer.concat([
        self1._prev,
        decrypt ? data : out
    ]);
    return out;
}
const encrypt2 = function(self1, data, decrypt) {
    let out = Buffer.allocUnsafe(0);
    let len;
    while(data.length){
        if (self1._cache.length === 0) {
            self1._cache = self1._cipher.encryptBlock(self1._prev);
            self1._prev = Buffer.allocUnsafe(0);
        }
        if (self1._cache.length <= data.length) {
            len = self1._cache.length;
            out = Buffer.concat([
                out,
                encryptStart(self1, data.slice(0, len), decrypt), 
            ]);
            data = data.slice(len);
        } else {
            out = Buffer.concat([
                out,
                encryptStart(self1, data, decrypt)
            ]);
            break;
        }
    }
    return out;
};
const mod9 = {
    encrypt: encrypt2
};
function encryptByte(self1, byteParam, decrypt) {
    const pad = self1._cipher.encryptBlock(self1._prev);
    const out = pad[0] ^ byteParam;
    self1._prev = Buffer.concat([
        self1._prev.slice(1),
        Buffer.from([
            decrypt ? byteParam : out
        ]), 
    ]);
    return out;
}
const encrypt3 = function(self1, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte(self1, chunk[i], decrypt);
    }
    return out;
};
const mod10 = {
    encrypt: encrypt3
};
function encryptByte1(self1, byteParam, decrypt) {
    let pad;
    let i = -1;
    let out = 0;
    let bit, value;
    while(++i < 8){
        pad = self1._cipher.encryptBlock(self1._prev);
        bit = byteParam & 1 << 7 - i ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i % 8;
        self1._prev = shiftIn(self1._prev, decrypt ? bit : value);
    }
    return out;
}
function shiftIn(buffer, value) {
    const len = buffer.length;
    let i = -1;
    const out = Buffer.allocUnsafe(buffer.length);
    buffer = Buffer.concat([
        buffer,
        Buffer.from([
            value
        ])
    ]);
    while(++i < len){
        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    }
    return out;
}
const encrypt4 = function(self1, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte1(self1, chunk[i], decrypt);
    }
    return out;
};
const mod11 = {
    encrypt: encrypt4
};
function getBlock(self1) {
    self1._prev = self1._cipher.encryptBlock(self1._prev);
    return self1._prev;
}
const encrypt5 = function(self1, chunk) {
    while(self1._cache.length < chunk.length){
        self1._cache = Buffer.concat([
            self1._cache,
            getBlock(self1)
        ]);
    }
    const pad = self1._cache.slice(0, chunk.length);
    self1._cache = self1._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod12 = {
    encrypt: encrypt5
};
function incr32(iv) {
    let len = iv.length;
    let item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) {
            iv.writeUInt8(0, len);
        } else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
function getBlock1(self1) {
    const out = self1._cipher.encryptBlockRaw(self1._prev);
    incr32(self1._prev);
    return out;
}
const blockSize = 16;
const encrypt6 = function(self1, chunk) {
    const chunkNum = Math.ceil(chunk.length / 16);
    const start = self1._cache.length;
    self1._cache = Buffer.concat([
        self1._cache,
        Buffer.allocUnsafe(chunkNum * blockSize), 
    ]);
    for(let i = 0; i < chunkNum; i++){
        const out = getBlock1(self1);
        const offset = start + i * 16;
        self1._cache.writeUInt32BE(out[0], offset + 0);
        self1._cache.writeUInt32BE(out[1], offset + 4);
        self1._cache.writeUInt32BE(out[2], offset + 8);
        self1._cache.writeUInt32BE(out[3], offset + 12);
    }
    const pad = self1._cache.slice(0, chunk.length);
    self1._cache = self1._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod13 = {
    encrypt: encrypt6
};
const modeModules = {
    ECB: mod7,
    CBC: mod8,
    CFB: mod9,
    CFB8: mod10,
    CFB1: mod11,
    OFB: mod12,
    CTR: mod13,
    GCM: mod13
};
const MODES = {
    "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    }
};
for (const mode of Object.values(MODES)){
    mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i = 0; i < len; i++){
        out[i] = buf.readUInt32BE(i * 4);
    }
    return out;
}
function scrubVec(v) {
    for(var i = 0; i < v.length; v++){
        v[i] = 0;
    }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
var RCON = [
    0x00,
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    0x1b,
    0x36
];
var G = function() {
    var d = new Array(256);
    for(var j = 0; j < 256; j++){
        if (j < 128) {
            d[j] = j << 1;
        } else {
            d[j] = j << 1 ^ 0x11b;
        }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var x = 0;
    var xi = 0;
    for(var i = 0; i < 256; ++i){
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
            x = xi = 1;
        } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k = 0; k < keySize; k++){
        keySchedule[k] = keyWords[k];
    }
    for(k = keySize; k < ksRows; k++){
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
            t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
        } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
        }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
    } else {
        this.final = this._finalOrDigest;
    }
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
CipherBase.prototype = Object.create(Transform.prototype, {
    constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") {
        data = Buffer.from(data, inputEnc);
    }
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) {
        outData = this._toString(outData, outputEnc);
    }
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
    var err;
    try {
        if (this.hashMode) {
            this._update(data);
        } else {
            this.push(this._update(data));
        }
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
    }
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
        out += this._decoder.end();
    }
    return out;
};
var ZEROES = Buffer.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12), 
    ];
}
function fromArray(out) {
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer.alloc(16, 0);
    this.cache = Buffer.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
    var i = -1;
    while(++i < block.length){
        this.state[i] ^= block[i];
    }
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i = -1;
    while(++i < 128){
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for(j = 3; j > 0; j--){
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
            Vi[0] = Vi[0] ^ 0xe1 << 24;
        }
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
        this.ghash(Buffer.concat([
            this.cache,
            ZEROES
        ], 16));
    }
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);
    for(var i = 0; i < len; ++i){
        out += a[i] ^ b[i];
    }
    return out;
}
function calcIv(self1, iv, ck) {
    if (iv.length === 12) {
        self1._finID = Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer.alloc(toPad, 0));
    }
    ghash.update(Buffer.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer.alloc(8);
    tail.writeUIntBE(ivBits, 2, 6);
    ghash.update(tail);
    self1._finID = ghash.state;
    var out = Buffer.from(self1._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode, key, iv, decrypt) {
    CipherBase.call(this);
    var h = Buffer.alloc(4, 0);
    this._cipher = new AES(key);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode;
    this._authTag = null;
    this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
        this._ghash.update(chunk);
    } else {
        this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    this._authTag = tag;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
};
function StreamCipher1(mode, key, iv, decrypt) {
    CipherBase.call(this);
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher1.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
    this._cipher.scrub();
};
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");
    if (salt) {
        if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
        if (salt.length !== 8) {
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
    }
    let keyLen = keyBits / 8;
    const key = Buffer.alloc(keyLen);
    const iv = Buffer.alloc(ivLen || 0);
    let tmp = Buffer.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        const hash = createHash("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
            const keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            const ivStart = iv.length - ivLen;
            const length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key,
        iv
    };
}
function Cipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter();
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Cipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
var PADDING = Buffer.alloc(16, 0x10);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
    this.cache = Buffer.concat([
        this.cache,
        data
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer.allocUnsafe(len);
    var i = -1;
    while(++i < len){
        padBuff.writeUInt8(len, i);
    }
    return Buffer.concat([
        this.cache,
        padBuff
    ]);
};
function Decipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter1();
    this._last = void 0;
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Decipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
        throw new Error("data not multiple of block length");
    }
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter1() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter1.prototype.add = function(data) {
    this.cache = Buffer.concat([
        this.cache,
        data
    ]);
};
Splitter1.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else {
        if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    }
    return null;
};
Splitter1.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
    }
    var i = -1;
    while(++i < padded){
        if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
        }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
    }
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
    }
    if (config.type === "stream") {
        return new StreamCipher1(config.module, password, iv, true);
    } else if (config.type === "auth") {
        return new StreamCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
}
function getCiphers() {
    return Object.keys(MODES);
}
let defaultEncoding = "buffer";
function getDefaultEncoding() {
    return defaultEncoding;
}
function toBuf(val, encoding) {
    if (typeof val === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer.from(val, encoding);
    }
    return val;
}
const validateByteSource = hideStackFrames((val, name)=>{
    val = toBuf(val);
    if (isAnyArrayBuffer1(val) || isArrayBufferView(val)) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "string",
        "ArrayBuffer",
        "TypedArray",
        "DataView",
        "Buffer"
    ], val);
});
function getHashes() {
    return digestAlgorithms;
}
function getCurves() {
    notImplemented("crypto.getCurves");
}
function secureHeapUsed() {
    notImplemented("crypto.secureHeapUsed");
}
function setEngine(_engine, _flags) {
    notImplemented("crypto.setEngine");
}
class KeyObject {
    [kKeyType];
    [kHandle];
    constructor(type, handle){
        if (type !== "secret" && type !== "public" && type !== "private") {
            throw new ERR_INVALID_ARG_VALUE("type", type);
        }
        if (typeof handle !== "object") {
            throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
        }
        this[kKeyType] = type;
        Object.defineProperty(this, kHandle, {
            value: handle,
            enumerable: false,
            configurable: false,
            writable: false
        });
    }
    get type() {
        return this[kKeyType];
    }
    get asymmetricKeyDetails() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
        return undefined;
    }
    get asymmetricKeyType() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
        return undefined;
    }
    get symmetricKeySize() {
        notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
        return undefined;
    }
    static from(key) {
        if (!isCryptoKey(key)) {
            throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key);
        }
        notImplemented("crypto.KeyObject.prototype.from");
    }
    equals(otherKeyObject) {
        if (!isKeyObject(otherKeyObject)) {
            throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
        }
        notImplemented("crypto.KeyObject.prototype.equals");
    }
    export(_options) {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    }
}
function createPrivateKey(_key) {
    notImplemented("crypto.createPrivateKey");
}
function createPublicKey(_key) {
    notImplemented("crypto.createPublicKey");
}
function createSecretKey(_key, _encoding) {
    notImplemented("crypto.createSecretKey");
}
const validateParameters = hideStackFrames((hash, key, salt, info, length)=>{
    key = prepareKey(key);
    salt = toBuf(salt);
    info = toBuf(info);
    validateString(hash, "digest");
    validateByteSource(salt, "salt");
    validateByteSource(info, "info");
    validateInteger(length, "length", 0, 2147483647);
    if (info.byteLength > 1024) {
        throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info.byteLength);
    }
    return {
        hash,
        key,
        salt,
        info,
        length
    };
});
function prepareKey(key) {
    if (isKeyObject(key)) {
        return key;
    }
    if (isAnyArrayBuffer1(key)) {
        return createSecretKey(new Uint8Array(key));
    }
    key = toBuf(key);
    if (!isArrayBufferView(key)) {
        throw new ERR_INVALID_ARG_TYPE("ikm", [
            "string",
            "SecretKeyObject",
            "ArrayBuffer",
            "TypedArray",
            "DataView",
            "Buffer", 
        ], key);
    }
    return createSecretKey(key);
}
function hkdf(hash, key, salt, info, length, callback) {
    ({ hash , key , salt , info , length  } = validateParameters(hash, key, salt, info, length));
    validateCallback(callback);
    notImplemented("crypto.hkdf");
}
function hkdfSync(hash, key, salt, info, length) {
    ({ hash , key , salt , info , length  } = validateParameters(hash, key, salt, info, length));
    notImplemented("crypto.hkdfSync");
}
function generateKey(_type, _options, _callback) {
    notImplemented("crypto.generateKey");
}
function generateKeyPair(_type, _options, _callback) {
    notImplemented("crypto.generateKeyPair");
}
function generateKeyPairSync(_type, _options) {
    notImplemented("crypto.generateKeyPairSync");
}
function generateKeySync(_type, _options) {
    notImplemented("crypto.generateKeySync");
}
const DH_GENERATOR = 2;
class DiffieHellman {
    verifyError;
    constructor(sizeOrKey, keyEncoding, generator, genEncoding){
        if (typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer1(sizeOrKey)) {
            throw new ERR_INVALID_ARG_TYPE("sizeOrKey", [
                "number",
                "string",
                "ArrayBuffer",
                "Buffer",
                "TypedArray",
                "DataView"
            ], sizeOrKey);
        }
        if (typeof sizeOrKey === "number") {
            validateInt32(sizeOrKey, "sizeOrKey");
        }
        if (keyEncoding && !Buffer.isEncoding(keyEncoding) && keyEncoding !== "buffer") {
            genEncoding = generator;
            generator = keyEncoding;
            keyEncoding = false;
        }
        const encoding = getDefaultEncoding();
        keyEncoding = keyEncoding || encoding;
        genEncoding = genEncoding || encoding;
        if (typeof sizeOrKey !== "number") {
            sizeOrKey = toBuf(sizeOrKey, keyEncoding);
        }
        if (!generator) {
            generator = DH_GENERATOR;
        } else if (typeof generator === "number") {
            validateInt32(generator, "generator");
        } else if (typeof generator === "string") {
            generator = toBuf(generator, genEncoding);
        } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer1(generator)) {
            throw new ERR_INVALID_ARG_TYPE("generator", [
                "number",
                "string",
                "ArrayBuffer",
                "Buffer",
                "TypedArray",
                "DataView"
            ], generator);
        }
        notImplemented("crypto.DiffieHellman");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
    }
    generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
    }
    getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
    }
    getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
    }
    getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
    }
    setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
    }
    setPublicKey(_publicKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
    }
}
class DiffieHellmanGroup {
    verifyError;
    constructor(_name){
        notImplemented("crypto.DiffieHellmanGroup");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
    }
    generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
    }
    getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
    }
    getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
    }
    getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
    }
}
class ECDH {
    constructor(curve){
        validateString(curve, "curve");
        notImplemented("crypto.ECDH");
    }
    static convertKey(_key, _curve, _inputEncoding, _outputEncoding, _format) {
        notImplemented("crypto.ECDH.prototype.convertKey");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.ECDH.prototype.computeSecret");
    }
    generateKeys(_encoding, _format) {
        notImplemented("crypto.ECDH.prototype.generateKeys");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.ECDH.prototype.getPrivateKey");
    }
    getPublicKey(_encoding, _format) {
        notImplemented("crypto.ECDH.prototype.getPublicKey");
    }
    setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.ECDH.prototype.setPrivateKey");
    }
}
function diffieHellman(_options) {
    notImplemented("crypto.diffieHellman");
}
function assert2(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
}
function BN(number, base, endian) {
    if (BN.isBN(number)) {
        return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;
    this.red = null;
    if (number !== null) {
        if (base === "le" || base === "be") {
            endian = base;
            base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
    }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
    if (num instanceof BN) {
        return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
};
BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
};
BN.prototype._init = function init(number, base, endian) {
    if (typeof number === "number") {
        return this._initNumber(number, base, endian);
    }
    if (typeof number === "object") {
        return this._initArray(number, base, endian);
    }
    if (base === "hex") {
        base = 16;
    }
    assert2(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, "");
    var start = 0;
    if (number[0] === "-") {
        start++;
        this.negative = 1;
    }
    if (start < number.length) {
        if (base === 16) {
            this._parseHex(number, start, endian);
        } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
            }
        }
    }
};
BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
        this.negative = 1;
        number = -number;
    }
    if (number < 0x4000000) {
        this.words = [
            number & 0x3ffffff
        ];
        this.length = 1;
    } else if (number < 0x10000000000000) {
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff, 
        ];
        this.length = 2;
    } else {
        assert2(number < 0x20000000000000);
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff,
            1, 
        ];
        this.length = 3;
    }
    if (endian !== "le") return;
    this._initArray(this.toArray(), base, endian);
};
BN.prototype._initArray = function _initArray(number, base, endian) {
    assert2(typeof number.length === "number");
    if (number.length <= 0) {
        this.words = [
            0
        ];
        this.length = 1;
        return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === "be") {
        for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    } else if (endian === "le") {
        for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    }
    return this._strip();
};
function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    if (c >= 48 && c <= 57) {
        return c - 48;
    } else if (c >= 65 && c <= 70) {
        return c - 55;
    } else if (c >= 97 && c <= 102) {
        return c - 87;
    } else {
        assert2(false, "Invalid character in " + string);
    }
}
function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var off = 0;
    var j = 0;
    var w;
    if (endian === "be") {
        for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    } else {
        var parseLength = number.length - start;
        for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    }
    this._strip();
};
function parseBase(str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for(var i = start; i < len; i++){
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
            b = c - 49 + 0xa;
        } else if (c >= 17) {
            b = c - 17 + 0xa;
        } else {
            b = c;
        }
        assert2(c >= 0 && b < mul, "Invalid character");
        r += b;
    }
    return r;
}
BN.prototype._parseBase = function _parseBase(number, base, start) {
    this.words = [
        0
    ];
    this.length = 1;
    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base){
        limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;
    for(var i = start; i < end; i += limbLen){
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for(i = 0; i < mod; i++){
            pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    this._strip();
};
BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
};
function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
    move(dest, this);
};
BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
};
BN.prototype._expand = function _expand(size) {
    while(this.length < size){
        this.words[this.length++] = 0;
    }
    return this;
};
BN.prototype._strip = function strip() {
    while(this.length > 1 && this.words[this.length - 1] === 0){
        this.length--;
    }
    return this._normSign();
};
BN.prototype._normSign = function _normSign() {
    if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
    }
    return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
    try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
    } catch (e) {
        BN.prototype.inspect = inspect1;
    }
} else {
    BN.prototype.inspect = inspect1;
}
function inspect1() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000", 
];
var groupSizes = [
    0,
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5, 
];
var groupBases = [
    0,
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    10000000,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64000000,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    24300000,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176, 
];
BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;
    if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
            } else {
                out = word + out;
            }
            off += 2;
            if (off >= 26) {
                off -= 26;
                i--;
            }
        }
        if (carry !== 0) {
            out = carry.toString(16) + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while(!c.isZero()){
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
            } else {
                out = r + out;
            }
        }
        if (this.isZero()) {
            out = "0" + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    assert2(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
};
if (Buffer) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
}
BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert2(byteLength <= reqLength, "byte array longer than desired length");
    assert2(reqLength > 0, "Requested array length <= 0");
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === "le" ? "LE" : "BE";
    this["_toArrayLike" + postfix](res, byteLength);
    return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position++] = word & 0xff;
        if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
        }
        if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position < res.length) {
                res[position++] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position < res.length) {
        res[position++] = carry;
        while(position < res.length){
            res[position++] = 0;
        }
    }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position--] = word & 0xff;
        if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
        }
        if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position >= 0) {
                res[position--] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position >= 0) {
        res[position--] = carry;
        while(position >= 0){
            res[position--] = 0;
        }
    }
};
if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
} else {
    BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
}
BN.prototype._zeroBits = function _zeroBits(w) {
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
    }
    if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
    }
    if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
    }
    if ((t & 0x1) === 0) {
        r++;
    }
    return r;
};
BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
    var w = new Array(num.bitLength());
    for(var bit = 0; bit < w.length; bit++){
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 0x01;
    }
    return w;
}
BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for(var i = 0; i < this.length; i++){
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
    }
    return r;
};
BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
};
BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
};
BN.prototype.neg = function neg() {
    return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
        this.negative ^= 1;
    }
    return this;
};
BN.prototype.iuor = function iuor(num) {
    while(this.length < num.length){
        this.words[this.length++] = 0;
    }
    for(var i = 0; i < num.length; i++){
        this.words[i] = this.words[i] | num.words[i];
    }
    return this._strip();
};
BN.prototype.ior = function ior(num) {
    assert2((this.negative | num.negative) === 0);
    return this.iuor(num);
};
BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
    var b;
    if (this.length > num.length) {
        b = num;
    } else {
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = this.words[i] & num.words[i];
    }
    this.length = b.length;
    return this._strip();
};
BN.prototype.iand = function iand(num) {
    assert2((this.negative | num.negative) === 0);
    return this.iuand(num);
};
BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
    var a;
    var b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = a.words[i] ^ b.words[i];
    }
    if (this !== a) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = a.length;
    return this._strip();
};
BN.prototype.ixor = function ixor(num) {
    assert2((this.negative | num.negative) === 0);
    return this.iuxor(num);
};
BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
    assert2(typeof width === "number" && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
        bytesNeeded--;
    }
    for(var i = 0; i < bytesNeeded; i++){
        this.words[i] = ~this.words[i] & 0x3ffffff;
    }
    if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }
    return this._strip();
};
BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
    assert2(typeof bit === "number" && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
    } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
};
BN.prototype.iadd = function iadd(num) {
    var r;
    if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
    }
    var a, b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
    } else if (a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    return this;
};
BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
    } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
    if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
    } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
    }
    var cmp = this.cmp(num);
    if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
    }
    var a, b;
    if (cmp > 0) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    if (carry === 0 && i < a.length && a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
        this.negative = 1;
    }
    return this._strip();
};
BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
};
function smallMulTo(self1, num, out) {
    out.negative = num.negative ^ self1.negative;
    var len = self1.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    var a = self1.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for(var k = 1; k < len; k++){
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
            var i = k - j | 0;
            a = self1.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
    }
    if (carry !== 0) {
        out.words[k] = carry | 0;
    } else {
        out.length--;
    }
    return out._strip();
}
var comb10MulTo = function comb10MulTo(self1, num, out) {
    var a = self1.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self1.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
        o[19] = c;
        out.length++;
    }
    return out;
};
if (!Math.imul) {
    comb10MulTo = smallMulTo;
}
function bigMulTo(self1, num, out) {
    out.negative = num.negative ^ self1.negative;
    out.length = self1.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for(var k = 0; k < out.length - 1; k++){
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self1.length + 1); j <= maxJ; j++){
            var i = k - j;
            var a = self1.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
    }
    if (carry !== 0) {
        out.words[k] = carry;
    } else {
        out.length--;
    }
    return out._strip();
}
function jumboMulTo(self1, num, out) {
    return bigMulTo(self1, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
    } else if (len < 63) {
        res = smallMulTo(this, num, out);
    } else if (len < 1024) {
        res = bigMulTo(this, num, out);
    } else {
        res = jumboMulTo(this, num, out);
    }
    return res;
};
function FFTM(x, y) {
    this.x = x;
    this.y = y;
}
FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for(var i = 0; i < N; i++){
        t[i] = this.revBin(i, l, N);
    }
    return t;
};
FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for(var i = 0; i < l; i++){
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
    }
    return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for(var i = 0; i < N; i++){
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
    }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for(var s = 1; s < N; s <<= 1){
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for(var p = 0; p < N; p += l){
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for(var j = 0; j < s; j++){
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                }
            }
        }
    }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for(N = N / 2 | 0; N; N = N >>> 1){
        i++;
    }
    return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for(var i = 0; i < N / 2; i++){
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
    }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for(var i = 0; i < N / 2; i++){
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 0x3ffffff;
        if (w < 0x4000000) {
            carry = 0;
        } else {
            carry = w / 0x4000000 | 0;
        }
    }
    return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for(var i = 0; i < len; i++){
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 0x1fff;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff;
        carry = carry >>> 13;
    }
    for(i = 2 * len; i < N; ++i){
        rws[i] = 0;
    }
    assert2(carry === 0);
    assert2((carry & ~0x1fff) === 0);
};
FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for(var i = 0; i < N; i++){
        ph[i] = 0;
    }
    return ph;
};
FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for(var i = 0; i < N; i++){
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
};
BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert2(typeof num === "number");
    assert2(num < 0x4000000);
    var carry = 0;
    for(var i = 0; i < this.length; i++){
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
    return this.mul(this);
};
BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);
    var res = this;
    for(var i = 0; i < w.length; i++, res = res.sqr()){
        if (w[i] !== 0) break;
    }
    if (++i < w.length) {
        for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
    }
    return res;
};
BN.prototype.iushln = function iushln(bits) {
    assert2(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;
    if (r !== 0) {
        var carry = 0;
        for(i = 0; i < this.length; i++){
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
        }
        if (carry) {
            this.words[i] = carry;
            this.length++;
        }
    }
    if (s !== 0) {
        for(i = this.length - 1; i >= 0; i--){
            this.words[i + s] = this.words[i];
        }
        for(i = 0; i < s; i++){
            this.words[i] = 0;
        }
        this.length += s;
    }
    return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
    assert2(this.negative === 0);
    return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert2(typeof bits === "number" && bits >= 0);
    var h;
    if (hint) {
        h = (hint - hint % 26) / 26;
    } else {
        h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);
    if (maskedWords) {
        for(var i = 0; i < s; i++){
            maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
    }
    if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for(i = 0; i < this.length; i++){
            this.words[i] = this.words[i + s];
        }
    } else {
        this.words[0] = 0;
        this.length = 1;
    }
    var carry = 0;
    for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
    }
    if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
    }
    return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    assert2(this.negative === 0);
    return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
    assert2(typeof bit === "number" && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) return false;
    var w = this.words[s];
    return !!(w & q);
};
BN.prototype.imaskn = function imaskn(bits) {
    assert2(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert2(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s) {
        return this;
    }
    if (r !== 0) {
        s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
    }
    return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
    assert2(typeof num === "number");
    assert2(num < 0x4000000);
    if (num < 0) return this.isubn(-num);
    if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
    }
    return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;
    for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
            this.words[i + 1] = 1;
        } else {
            this.words[i + 1]++;
        }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
};
BN.prototype.isubn = function isubn(num) {
    assert2(typeof num === "number");
    assert2(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
    } else {
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
    }
    return this._strip();
};
BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
};
BN.prototype.abs = function abs() {
    return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;
    this._expand(len);
    var w;
    var carry = 0;
    for(i = 0; i < num.length; i++){
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i + shift] = w & 0x3ffffff;
    }
    for(; i < this.length - shift; i++){
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this._strip();
    assert2(carry === -1);
    carry = 0;
    for(i = 0; i < this.length; i++){
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num;
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
    }
    var m = a.length - b.length;
    var q;
    if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for(var i = 0; i < q.length; i++){
            q.words[i] = 0;
        }
    }
    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
        a = diff;
        if (q) {
            q.words[m] = 1;
        }
    }
    for(var j = m - 1; j >= 0; j--){
        var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while(a.negative !== 0){
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
                a.negative ^= 1;
            }
        }
        if (q) {
            q.words[j] = qj;
        }
    }
    if (q) {
        q._strip();
    }
    a._strip();
    if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
    }
    return {
        div: q || null,
        mod: a
    };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
    assert2(!num.isZero());
    if (this.isZero()) {
        return {
            div: new BN(0),
            mod: new BN(0)
        };
    }
    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.iadd(num);
            }
        }
        return {
            div: div,
            mod: mod
        };
    }
    if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        return {
            div: div,
            mod: res.mod
        };
    }
    if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.isub(num);
            }
        }
        return {
            div: res.div,
            mod: mod
        };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
        return {
            div: new BN(0),
            mod: this
        };
    }
    if (num.length === 1) {
        if (mode === "div") {
            return {
                div: this.divn(num.words[0]),
                mod: null
            };
        }
        if (mode === "mod") {
            return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
        };
    }
    return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
    return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
    return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
    return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);
    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert2(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for(var i = this.length - 1; i >= 0; i--){
        acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
    return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert2(num <= 0x3ffffff);
    var carry = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = w / num | 0;
        carry = w % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p) {
    assert2(p.negative === 0);
    assert2(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
        x = x.umod(p);
    } else {
        x = x.clone();
    }
    var A = new BN(1);
    var B = new BN(0);
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while(x.isEven() && y.isEven()){
        x.iushrn(1);
        y.iushrn(1);
        ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while(!x.isZero()){
        for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            x.iushrn(i);
            while(i-- > 0){
                if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            y.iushrn(j);
            while(j-- > 0){
                if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
            }
        }
        if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
        } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
        }
    }
    return {
        a: C,
        b: D,
        gcd: y.iushln(g)
    };
};
BN.prototype._invmp = function _invmp(p) {
    assert2(p.negative === 0);
    assert2(!p.isZero());
    var a = this;
    var b = p.clone();
    if (a.negative !== 0) {
        a = a.umod(p);
    } else {
        a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();
    while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
        for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            a.iushrn(i);
            while(i-- > 0){
                if (x1.isOdd()) {
                    x1.iadd(delta);
                }
                x1.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            b.iushrn(j);
            while(j-- > 0){
                if (x2.isOdd()) {
                    x2.iadd(delta);
                }
                x2.iushrn(1);
            }
        }
        if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
        } else {
            b.isub(a);
            x2.isub(x1);
        }
    }
    var res;
    if (a.cmpn(1) === 0) {
        res = x1;
    } else {
        res = x2;
    }
    if (res.cmpn(0) < 0) {
        res.iadd(p);
    }
    return res;
};
BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;
    for(var shift = 0; a.isEven() && b.isEven(); shift++){
        a.iushrn(1);
        b.iushrn(1);
    }
    do {
        while(a.isEven()){
            a.iushrn(1);
        }
        while(b.isEven()){
            b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
            var t = a;
            a = b;
            b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
            break;
        }
        a.isub(b);
    }while (true)
    return b.iushln(shift);
};
BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
    assert2(typeof bit === "number");
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
    }
    var carry = q;
    for(var i = s; carry !== 0 && i < this.length; i++){
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return this;
};
BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
        res = 1;
    } else {
        if (negative) {
            num = -num;
        }
        assert2(num <= 0x3ffffff, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.ucmp = function ucmp(num) {
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
            res = -1;
        } else if (a > b) {
            res = 1;
        }
        break;
    }
    return res;
};
BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
};
BN.red = function red(num) {
    return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
    assert2(!this.red, "Already a number in reduction context");
    assert2(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
    assert2(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
    assert2(!this.red, "Already a number in reduction context");
    return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
    assert2(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
    assert2(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
    assert2(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
    assert2(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
    assert2(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
    assert2(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
    assert2(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
    assert2(this.red, "redSqr works only with red numbers");
    this.red._verify1(this);
    return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
    assert2(this.red, "redISqr works only with red numbers");
    this.red._verify1(this);
    return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
    assert2(this.red, "redSqrt works only with red numbers");
    this.red._verify1(this);
    return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
    assert2(this.red, "redInvm works only with red numbers");
    this.red._verify1(this);
    return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
    assert2(this.red, "redNeg works only with red numbers");
    this.red._verify1(this);
    return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
    assert2(this.red && !num.red, "redPow(normalNum)");
    this.red._verify1(this);
    return this.red.pow(this, num);
};
var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
};
function MPrime(name, p) {
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
    var r = num;
    var rlen;
    do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
    }while (rlen > this.n)
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
    } else if (cmp > 0) {
        r.isub(this.p);
    } else {
        if (r.strip !== undefined) {
            r.strip();
        } else {
            r._strip();
        }
    }
    return r;
};
MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
};
function K256() {
    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits(K256, MPrime);
K256.prototype.split = function split(input, output) {
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for(var i = 0; i < outLen; i++){
        output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
    }
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for(i = 10; i < input.length; i++){
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
        input.length -= 10;
    } else {
        input.length -= 9;
    }
};
K256.prototype.imulK = function imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    var lo = 0;
    for(var i = 0; i < num.length; i++){
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
    }
    if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
            num.length--;
        }
    }
    return num;
};
function P224() {
    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits(P224, MPrime);
function P192() {
    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits(P192, MPrime);
function P25519() {
    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits(P25519, MPrime);
P25519.prototype.imulK = function imulK(num) {
    var carry = 0;
    for(var i = 0; i < num.length; i++){
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
    }
    if (carry !== 0) {
        num.words[num.length++] = carry;
    }
    return num;
};
BN._prime = function prime(name) {
    if (primes[name]) return primes[name];
    var prime;
    if (name === "k256") {
        prime = new K256();
    } else if (name === "p224") {
        prime = new P224();
    } else if (name === "p192") {
        prime = new P192();
    } else if (name === "p25519") {
        prime = new P25519();
    } else {
        throw new Error("Unknown prime " + name);
    }
    primes[name] = prime;
    return prime;
};
function Red(m) {
    if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
    } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
    }
}
Red.prototype._verify1 = function _verify1(a) {
    assert2(a.negative === 0, "red works only with positives");
    assert2(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b) {
    assert2((a.negative | b.negative) === 0, "red works only with positives");
    assert2(a.red && a.red === b.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
};
Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
        return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add(a, b) {
    this._verify2(a, b);
    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);
    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res;
};
Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);
    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);
    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res;
};
Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
};
Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
};
Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert2(mod3 % 2 === 1);
    if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
    }
    var q = this.m.subn(1);
    var s = 0;
    while(!q.isZero() && q.andln(1) === 0){
        s++;
        q.iushrn(1);
    }
    assert2(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while(this.pow(z, lpow).cmp(nOne) !== 0){
        z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while(t.cmp(one) !== 0){
        var tmp = t;
        for(var i = 0; tmp.cmp(one) !== 0; i++){
            tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
    }
    return r;
};
Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
    } else {
        return this.imod(inv);
    }
};
Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for(var i = 2; i < wnd.length; i++){
        wnd[i] = this.mul(wnd[i - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
        start = 26;
    }
    for(i = num.length - 1; i >= 0; i--){
        var word = num.words[i];
        for(var j = start - 1; j >= 0; j--){
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
                res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
        }
        start = 26;
    }
    return res;
};
Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
};
BN.mont = function mont(num) {
    return new Mont(num);
};
function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);
Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
};
Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
    }
    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.invm = function invm(a) {
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
};
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state = this._reporterState;
    return {
        obj: state.obj,
        pathLen: state.path.length
    };
};
Reporter.prototype.restore = function restore(data) {
    const state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
    const state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    const state = this._reporterState;
    this.exitKey(index);
    if (state.obj !== null) {
        state.obj[key] = value;
    }
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state = this._reporterState;
    const prev = state.obj;
    state.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state = this._reporterState;
    const now = state.obj;
    state.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err;
    const state = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) {
        err = msg;
    } else {
        err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
    }
    if (!state.options.partial) {
        throw err;
    }
    if (!inherited) {
        state.errors.push(err);
    }
    return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state = this._reporterState;
    if (!state.options.partial) {
        return result;
    }
    return {
        result: this.isError(result) ? null : result,
        errors: state.errors
    };
};
function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
    }
    if (!this.stack) {
        try {
            throw new Error(this.message);
        } catch (e) {
            this.stack = e.stack;
        }
    }
    return this;
};
function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!Buffer.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base;
    this.offset = 0;
    this.length = base.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
    constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
    if (data instanceof DecoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && Buffer.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
    } else {
        return this.error(fail || "DecoderBuffer overrun");
    }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length)) {
        return this.error(fail || "DecoderBuffer overrun");
    }
    const res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) {
                item = new EncoderBuffer(item, reporter);
            }
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 0xff)) {
            return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer.byteLength(value);
    } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error("Unsupported type: " + typeof value);
    }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
    if (data instanceof EncoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) {
        out = Buffer.alloc(this.length);
    }
    if (!offset) {
        offset = 0;
    }
    if (this.length === 0) {
        return out;
    }
    if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === "number") {
            out[offset] = this.value;
        } else if (typeof this.value === "string") {
            out.write(this.value, offset);
        } else if (Buffer.isBuffer(this.value)) {
            this.value.copy(out, offset);
        }
        offset += this.length;
    }
    return out;
};
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr", 
];
const methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains", 
].concat(tags);
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool", 
];
function Node(enc, parent, name) {
    const state = {};
    this._baseState = state;
    state.name = name;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state["default"] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    if (!state.parent) {
        state.children = [];
        this._wrap();
    }
}
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains", 
];
Node.prototype.clone = function clone() {
    const state = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node.prototype._wrap = function wrap() {
    const state = this._baseState;
    methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node.prototype._init = function init(body) {
    const state = this._baseState;
    assert(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assertEquals(state.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
    const state = this._baseState;
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) {
                return arg;
            }
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) {
                    key |= 0;
                }
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
    };
});
tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
    };
});
Node.prototype.use = function use(item) {
    assert(item);
    const state = this._baseState;
    assert(state.use === null);
    state.use = item;
    return this;
};
Node.prototype.optional = function optional() {
    const state = this._baseState;
    state.optional = true;
    return this;
};
Node.prototype.def = function def(val) {
    const state = this._baseState;
    assert(state["default"] === null);
    state["default"] = val;
    state.optional = true;
    return this;
};
Node.prototype.explicit = function explicit(num) {
    const state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
};
Node.prototype.implicit = function implicit(num) {
    const state = this._baseState;
    assert(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
};
Node.prototype.obj = function obj() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0) {
        this._useArgs(args);
    }
    return this;
};
Node.prototype.key = function key(newKey) {
    const state = this._baseState;
    assert(state.key === null);
    state.key = newKey;
    return this;
};
Node.prototype.any = function any() {
    const state = this._baseState;
    state.any = true;
    return this;
};
Node.prototype.choice = function choice(obj) {
    const state = this._baseState;
    assert(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node.prototype.contains = function contains(item) {
    const state = this._baseState;
    assert(state.use === null);
    state.contains = item;
    return this;
};
Node.prototype._decode = function decode(input, options) {
    const state = this._baseState;
    if (state.parent === null) {
        return input.wrapResult(state.children[0]._decode(input, options));
    }
    let result = state["default"];
    let present = true;
    let prevKey = null;
    if (state.key !== null) {
        prevKey = input.enterKey(state.key);
    }
    if (state.optional) {
        let tag = null;
        if (state.explicit !== null) {
            tag = state.explicit;
        } else if (state.implicit !== null) {
            tag = state.implicit;
        } else if (state.tag !== null) {
            tag = state.tag;
        }
        if (tag === null && !state.any) {
            const save = input.save();
            try {
                if (state.choice === null) {
                    this._decodeGeneric(state.tag, input, options);
                } else {
                    this._decodeChoice(input, options);
                }
                present = true;
            } catch (_e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present)) {
                return present;
            }
        }
    }
    let prevObj;
    if (state.obj && present) {
        prevObj = input.enterObject();
    }
    if (present) {
        if (state.explicit !== null) {
            const explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit)) {
                return explicit;
            }
            input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
            let save1;
            if (state.any) {
                save1 = input.save();
            }
            const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body)) {
                return body;
            }
            if (state.any) {
                result = input.raw(save1);
            } else {
                input = body;
            }
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), start, input.length, "tagged");
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), input.offset, input.length, "content");
        }
        if (state.any) {} else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
        } else {
            result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
            return result;
        }
        if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
                child._decode(input, options);
            });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            const data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
    }
    if (state.obj && present) {
        result = input.leaveObject(prevObj);
    }
    if (state.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state.key, result);
    } else if (prevKey !== null) {
        input.exitKey(prevKey);
    }
    return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    const state = this._baseState;
    if (tag === "seq" || tag === "set") {
        return null;
    }
    if (tag === "seqof" || tag === "setof") {
        return this._decodeList(input, tag, state.args[0], options);
    } else if (/str$/.test(tag)) {
        return this._decodeStr(input, tag, options);
    } else if (tag === "objid" && state.args) {
        return this._decodeObjid(input, state.args[0], state.args[1], options);
    } else if (tag === "objid") {
        return this._decodeObjid(input, null, null, options);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._decodeTime(input, tag, options);
    } else if (tag === "null_") {
        return this._decodeNull(input, options);
    } else if (tag === "bool") {
        return this._decodeBool(input, options);
    } else if (tag === "objDesc") {
        return this._decodeStr(input, tag, options);
    } else if (tag === "int" || tag === "enum") {
        return this._decodeInt(input, state.args && state.args[0], options);
    }
    if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    } else {
        return input.error("unknown tag: " + tag);
    }
};
Node.prototype._getUse = function _getUse(entity, obj) {
    const state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
    const state = this._baseState;
    let result = null;
    let match = false;
    Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) {
                return false;
            }
            result = {
                type: key,
                value: value
            };
            match = true;
        } catch (_e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match) {
        return input.error("Choice not matched");
    }
    return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state["default"] !== null && state["default"] === data) {
        return;
    }
    const result = this._encodeValue(data, reporter, parent);
    if (result === undefined) {
        return;
    }
    if (this._skipDefault(result, reporter, parent)) {
        return;
    }
    return result;
};
Node.prototype._encodeValue = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state.parent === null) {
        return state.children[0]._encode(data, reporter || new Reporter());
    }
    let result = null;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
        if (state["default"] !== null) {
            data = state["default"];
        } else {
            return;
        }
    }
    let content = null;
    let primitive = false;
    if (state.any) {
        result = this._createEncoderBuffer(data);
    } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
    } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
    } else if (state.children) {
        content = state.children.map(function(child) {
            if (child._baseState.tag === "null_") {
                return child._encode(null, reporter, data);
            }
            if (child._baseState.key === null) {
                return reporter.error("Child should have a key");
            }
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data !== "object") {
                return reporter.error("Child expected, but input is not object");
            }
            const res = child._encode(data[child._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1)) {
                return reporter.error("Too many args for : " + state.tag);
            }
            if (!Array.isArray(data)) {
                return reporter.error("seqof/setof, but data is not Array");
            }
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
                const state = this._baseState;
                return this._getUse(state.args[0], data)._encode(item, reporter);
            }, child));
        } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
        }
    }
    if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
            if (state.use === null) {
                reporter.error("Tag could be omitted only for .use()");
            }
        } else {
            if (state.use === null) {
                result = this._encodeComposite(tag, primitive, cls, content);
            }
        }
    }
    if (state.explicit !== null) {
        result = this._encodeComposite(state.explicit, false, "context", result);
    }
    return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    const state = this._baseState;
    const node = state.choice[data.type];
    if (!node) {
        assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    const state = this._baseState;
    if (/str$/.test(tag)) {
        return this._encodeStr(data, tag);
    } else if (tag === "objid" && state.args) {
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    } else if (tag === "objid") {
        return this._encodeObjid(data, null, null);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._encodeTime(data, tag);
    } else if (tag === "null_") {
        return this._encodeNull();
    } else if (tag === "int" || tag === "enum") {
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
    } else if (tag === "bool") {
        return this._encodeBool(data);
    } else if (tag === "objDesc") {
        return this._encodeStr(data, tag);
    } else {
        throw new Error("Unsupported tag: " + tag);
    }
};
Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        if ((key | 0) == key) {
            key = key | 0;
        }
        const value = map[key];
        res[value] = key;
    });
    return res;
}
const tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
const tagClassByName = reverse(tagClass);
const tag = {
    0x00: "end",
    0x01: "bool",
    0x02: "int",
    0x03: "bitstr",
    0x04: "octstr",
    0x05: "null_",
    0x06: "objid",
    0x07: "objDesc",
    0x08: "external",
    0x09: "real",
    0x0a: "enum",
    0x0b: "embed",
    0x0c: "utf8str",
    0x0d: "relativeOid",
    0x10: "seq",
    0x11: "set",
    0x12: "numstr",
    0x13: "printstr",
    0x14: "t61str",
    0x15: "videostr",
    0x16: "ia5str",
    0x17: "utctime",
    0x18: "gentime",
    0x19: "graphstr",
    0x1a: "iso646str",
    0x1b: "genstr",
    0x1c: "unistr",
    0x1d: "charstr",
    0x1e: "bmpstr"
};
const tagByName = reverse(tag);
const mod14 = {
    tagClass: tagClass,
    tagClassByName: tagClassByName,
    tag: tag,
    tagByName: tagByName
};
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
    Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    if (content.length < 0x80) {
        const header = Buffer.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    let lenOctets = 1;
    for(let i = content.length; i >= 0x100; i >>= 8){
        lenOctets++;
    }
    const header1 = Buffer.alloc(1 + 1 + lenOctets);
    header1[0] = encodedTag;
    header1[1] = 0x80 | lenOctets;
    for(let i1 = 1 + lenOctets, j = content.length; j > 0; i1--, j >>= 8){
        header1[i1] = j & 0xff;
    }
    return this._createEncoderBuffer([
        header1,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") {
        return this._createEncoderBuffer([
            str.unused | 0,
            str.data
        ]);
    } else if (tag === "bmpstr") {
        const buf = Buffer.alloc(str.length * 2);
        for(let i = 0; i < str.length; i++){
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
        }
        return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
        }
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
    } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
    } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === "string") {
        if (!values) {
            return this.reporter.error("string objid given, but no values map found");
        }
        if (!values.hasOwnProperty(id)) {
            return this.reporter.error("objid not found in values map");
        }
        id = values[id].split(/[\s.]+/g);
        for(let i = 0; i < id.length; i++){
            id[i] |= 0;
        }
    } else if (Array.isArray(id)) {
        id = id.slice();
        for(let i1 = 0; i1 < id.length; i1++){
            id[i1] |= 0;
        }
    }
    if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
    }
    if (!relative) {
        if (id[1] >= 40) {
            return this.reporter.error("Second objid identifier OOB");
        }
        id.splice(0, 2, id[0] * 40 + id[1]);
    }
    let size = 0;
    for(let i2 = 0; i2 < id.length; i2++){
        let ident = id[i2];
        for(size++; ident >= 0x80; ident >>= 7){
            size++;
        }
    }
    const objid = Buffer.alloc(size);
    let offset = objid.length - 1;
    for(let i3 = id.length - 1; i3 >= 0; i3--){
        let ident1 = id[i3];
        objid[offset--] = ident1 & 0x7f;
        while((ident1 >>= 7) > 0){
            objid[offset--] = 0x80 | ident1 & 0x7f;
        }
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) {
        return "0" + num;
    } else {
        return num;
    }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);
    if (tag === "gentime") {
        str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else if (tag === "utctime") {
        str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === "string") {
        if (!values) {
            return this.reporter.error("String int or enum given, but no values map");
        }
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
    }
    if (typeof num !== "number" && !Buffer.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = Buffer.from(numArray);
    }
    if (Buffer.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0) {
            size++;
        }
        const out = Buffer.alloc(size);
        num.copy(out);
        if (num.length === 0) {
            out[0] = 0;
        }
        return this._createEncoderBuffer(out);
    }
    if (num < 0x80) {
        return this._createEncoderBuffer(num);
    }
    if (num < 0x100) {
        return this._createEncoderBuffer([
            0,
            num
        ]);
    }
    let size1 = 1;
    for(let i = num; i >= 0x100; i >>= 8){
        size1++;
    }
    const out1 = new Array(size1);
    for(let i1 = out1.length - 1; i1 >= 0; i1--){
        out1[i1] = num & 0xff;
        num >>= 8;
    }
    if (out1[0] & 0x80) {
        out1.unshift(0);
    }
    return this._createEncoderBuffer(Buffer.from(out1));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state["default"] === null) {
        return false;
    }
    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined) {
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
    }
    if (data.length !== state.defaultBuffer.length) {
        return false;
    }
    for(i = 0; i < data.length; i++){
        if (data[i] !== state.defaultBuffer[i]) {
            return false;
        }
    }
    return true;
};
function encodeTag(tag, primitive, cls, reporter) {
    let res;
    if (tag === "seqof") {
        tag = "seq";
    } else if (tag === "setof") {
        tag = "set";
    }
    if (tagByName.hasOwnProperty(tag)) {
        res = tagByName[tag];
    } else if (typeof tag === "number" && (tag | 0) === tag) {
        res = tag;
    } else {
        return reporter.error("Unknown tag: " + tag);
    }
    if (res >= 0x1f) {
        return reporter.error("Multi-octet tag encoding unsupported");
    }
    if (!primitive) {
        res |= 0x20;
    }
    res |= tagClassByName[cls || "universal"] << 6;
    return res;
}
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
    constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMEncoder.prototype.encode = function encode(data, options) {
    const buf = DEREncoder.prototype.encode.call(this, data);
    const p = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i = 0; i < p.length; i += 64){
        out.push(p.slice(i, i + 64));
    }
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode1();
    this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode(data, options) {
    if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
    }
    return this.tree._decode(data, options);
};
function DERNode1(parent) {
    Node.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode1.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty()) {
        return false;
    }
    const state = buffer.save();
    const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len)) {
        return len;
    }
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null) {
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    }
    const state = buffer.save();
    const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res)) {
        return res;
    }
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    for(;;){
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag)) {
            return tag;
        }
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len)) {
            return len;
        }
        let res;
        if (tag.primitive || len !== null) {
            res = buffer.skip(len);
        } else {
            res = this._skipUntilEnd(buffer, fail);
        }
        if (buffer.isError(res)) {
            return res;
        }
        if (tag.tagStr === "end") {
            break;
        }
    }
};
DERNode1.prototype._decodeList = function decodeList(buffer, _tag, decoder, options) {
    const result = [];
    while(!buffer.isEmpty()){
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd)) {
            return possibleEnd;
        }
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd) {
            break;
        }
        result.push(res);
    }
    return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused)) {
            return unused;
        }
        return {
            unused: unused,
            data: buffer.raw()
        };
    } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1) {
            return buffer.error("Decoding of string type: bmpstr length mismatch");
        }
        let str = "";
        for(let i = 0; i < raw.length / 2; i++){
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
    } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: " + "numstr unsupported characters");
        }
        return numstr;
    } else if (tag === "octstr") {
        return buffer.raw();
    } else if (tag === "objDesc") {
        return buffer.raw();
    } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: " + "printstr unsupported characters");
        }
        return printstr;
    } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
    } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
    }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    let result;
    const identifiers = [];
    let ident = 0;
    let subident = 0;
    while(!buffer.isEmpty()){
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
            identifiers.push(ident);
            ident = 0;
        }
    }
    if (subident & 0x80) {
        identifiers.push(ident);
    }
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative) {
        result = identifiers;
    } else {
        result = [
            first,
            second
        ].concat(identifiers.slice(1));
    }
    if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === undefined) {
            tmp = values[result.join(".")];
        }
        if (tmp !== undefined) {
            result = tmp;
        }
    }
    return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer, tag) {
    const str = buffer.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min;
    let sec;
    if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
            year = 2000 + year;
        } else {
            year = 1900 + year;
        }
    } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer) {
    const res = buffer.readUInt8();
    if (buffer.isError(res)) {
        return res;
    } else {
        return res !== 0;
    }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer, values) {
    const raw = buffer.raw();
    let res = new BN(raw);
    if (values) {
        res = values[res.toString(10)] || res;
    }
    return res;
};
DERNode1.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
    let tag1 = buf.readUInt8(fail);
    if (buf.isError(tag1)) {
        return tag1;
    }
    const cls = tagClass[tag1 >> 6];
    const primitive = (tag1 & 0x20) === 0;
    if ((tag1 & 0x1f) === 0x1f) {
        let oct = tag1;
        tag1 = 0;
        while((oct & 0x80) === 0x80){
            oct = buf.readUInt8(fail);
            if (buf.isError(oct)) {
                return oct;
            }
            tag1 <<= 7;
            tag1 |= oct & 0x7f;
        }
    } else {
        tag1 &= 0x1f;
    }
    const tagStr = tag[tag1];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag1,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail) {
    let len = buf.readUInt8(fail);
    if (buf.isError(len)) {
        return len;
    }
    if (!primitive && len === 0x80) {
        return null;
    }
    if ((len & 0x80) === 0) {
        return len;
    }
    const num = len & 0x7f;
    if (num > 4) {
        return buf.error("length octect is too long");
    }
    len = 0;
    for(let i = 0; i < num; i++){
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j)) {
            return j;
        }
        len |= j;
    }
    return len;
}
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
    constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for(let i = 0; i < lines.length; i++){
        const match = lines[i].match(re);
        if (match === null) {
            continue;
        }
        if (match[2] !== label) {
            continue;
        }
        if (start === -1) {
            if (match[1] !== "BEGIN") {
                break;
            }
            start = i;
        } else {
            if (match[1] !== "END") {
                break;
            }
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1) {
        throw new Error("PEM section not found for: " + label);
    }
    const base64 = lines.slice(start + 1, end).join("");
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};
const base = {
    DecoderBuffer,
    EncoderBuffer,
    Node,
    Reporter
};
const encoders = {
    der: DEREncoder,
    pem: PEMEncoder
};
const decoders = {
    der: DERDecoder,
    pem: PEMDecoder
};
const constants = {
    der: mod14
};
function define(name, body) {
    return new Entity(name, body);
}
function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name = this.name;
    function Generated(entity) {
        this._initNamed(entity, name);
    }
    Generated.prototype = Object.create(Base.prototype, {
        constructor: {
            value: Generated,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    Generated.prototype._initNamed = function _initNamed(entity, name) {
        Base.call(this, entity, name);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
    }
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
    }
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
};
const __default6 = {
    base,
    bignum: BN,
    constants,
    decoders,
    define,
    encoders
};
const Time = define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
const AttributeTypeValue = define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
const SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
const RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
const RDNSequence = define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
const Name = define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
const Validity = define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
const Extension = define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
const TBSCertificate = define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
const X509Certificate = define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
const RSAPrivateKey = __default6.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
const RSAPublicKey = __default6.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
const PublicKey = __default6.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
const AlgorithmIdentifier1 = __default6.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
const PrivateKey = __default6.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
const EncryptedPrivateKey = __default6.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
const DSAPrivateKey = __default6.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
const DSAparam = __default6.define("DSAparam", function() {
    this.int();
});
const ECPrivateKey = __default6.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
const ECParameters = __default6.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
const signature = __default6.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
const findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
const startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
const fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default7(okey, password) {
    const key = okey.toString();
    const match = key.match(findProc);
    let decrypted;
    if (!match) {
        const match2 = key.match(fullRegex);
        decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        const suite = "aes" + match[1];
        const iv = Buffer.from(match[2], "hex");
        const cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
        const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
    }
    const tag = key.match(startRegex)[1];
    return {
        tag: tag,
        data: decrypted
    };
}
const aesid = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
    let password;
    if (typeof buffer === "object" && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
    }
    if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
    }
    const stripped = __default7(buffer, password);
    const type = stripped.tag;
    let data = stripped.data;
    let subtype, ndata;
    switch(type){
        case "CERTIFICATE":
            ndata = X509Certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            if (!ndata) {
                ndata = PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "ENCRYPTED PRIVATE KEY":
            data = EncryptedPrivateKey.decode(data, "der");
            data = decrypt2(data, password);
        case "PRIVATE KEY":
            ndata = PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "RSA PUBLIC KEY":
            return RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
            return RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: DSAPrivateKey.decode(data, "der")
            };
        case "EC PRIVATE KEY":
            data = ECPrivateKey.decode(data, "der");
            return {
                curve: data.parameters.value,
                privateKey: data.privateKey
            };
        default:
            throw new Error("unknown key type " + type);
    }
}
parseKeys.signature = signature;
function decrypt2(data, password) {
    const salt = data.algorithm.decrypt.kde.kdeparams.salt;
    const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
    const iv = data.algorithm.decrypt.cipher.iv;
    const cipherText = data.subjectPrivateKey;
    const keylen = parseInt(algo.split("-")[1], 10) / 8;
    const key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    const cipher = createDecipheriv(algo, key, iv);
    const out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer.concat(out);
}
const MAX_BYTES = 65536;
function randomBytes1(size, cb) {
    if (size > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    const bytes = Buffer.allocUnsafe(size);
    if (size > 0) {
        if (size > 65536) {
            for(let generated = 0; generated < size; generated += MAX_BYTES){
                globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
            }
        } else {
            globalThis.crypto.getRandomValues(bytes);
        }
    }
    if (typeof cb === "function") {
        return nextTick1(function() {
            cb(null, bytes);
        });
    }
    return bytes;
}
function __default8(seed, len) {
    let t = Buffer.alloc(0);
    let i = 0;
    let c;
    while(t.length < len){
        c = i2ops(i++);
        t = Buffer.concat([
            t,
            createHash("sha1").update(seed).update(c).digest()
        ]);
    }
    return t.slice(0, len);
}
function i2ops(c) {
    const out = Buffer.allocUnsafe(4);
    out.writeUInt32BE(c, 0);
    return out;
}
function xor1(a, b) {
    const len = a.length;
    let i = -1;
    while(++i < len){
        a[i] ^= b[i];
    }
    return a;
}
function withPublic(paddedMsg, key) {
    return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
function blind(priv) {
    const r = getr(priv);
    const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
    };
}
function getr(priv) {
    const len = priv.modulus.byteLength();
    let r;
    do {
        r = new BN(randomBytes1(len));
    }while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
    return r;
}
function crt(msg, priv) {
    const blinds = blind(priv);
    const len = priv.modulus.byteLength();
    const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    const c1 = blinded.toRed(BN.mont(priv.prime1));
    const c2 = blinded.toRed(BN.mont(priv.prime2));
    const qinv = priv.coefficient;
    const p = priv.prime1;
    const q = priv.prime2;
    const m1 = c1.redPow(priv.exponent1).fromRed();
    const m2 = c2.redPow(priv.exponent2).fromRed();
    const h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, "be", len);
}
crt.getr = getr;
function publicEncrypt(publicKey, msg, reverse) {
    let padding;
    if (publicKey.padding) {
        padding = publicKey.padding;
    } else if (reverse) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(publicKey);
    let paddedMsg;
    if (padding === 4) {
        paddedMsg = oaep(key, msg);
    } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
    } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
        }
    } else {
        throw new Error("unknown padding");
    }
    if (reverse) {
        return crt(paddedMsg, key);
    } else {
        return withPublic(paddedMsg, key);
    }
}
function oaep(key, msg) {
    const k = key.modulus.byteLength();
    const mLen = msg.length;
    const iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    const hLen = iHash.length;
    const hLen2 = 2 * hLen;
    if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
    }
    const ps = Buffer.alloc(k - mLen - hLen2 - 2);
    const dblen = k - hLen - 1;
    const seed = randomBytes1(hLen);
    const maskedDb = xor1(Buffer.concat([
        iHash,
        ps,
        Buffer.alloc(1, 1),
        msg
    ], dblen), __default8(seed, dblen));
    const maskedSeed = xor1(seed, __default8(maskedDb, hLen));
    return new BN(Buffer.concat([
        Buffer.alloc(1),
        maskedSeed,
        maskedDb
    ], k));
}
function pkcs1(key, msg, reverse) {
    const mLen = msg.length;
    const k = key.modulus.byteLength();
    if (mLen > k - 11) {
        throw new Error("message too long");
    }
    let ps;
    if (reverse) {
        ps = Buffer.alloc(k - mLen - 3, 0xff);
    } else {
        ps = nonZero(k - mLen - 3);
    }
    return new BN(Buffer.concat([
        Buffer.from([
            0,
            reverse ? 1 : 2, 
        ]),
        ps,
        Buffer.alloc(1),
        msg, 
    ], k));
}
function nonZero(len) {
    const out = Buffer.allocUnsafe(len);
    let i = 0;
    let cache = randomBytes1(len * 2);
    let cur = 0;
    let num;
    while(i < len){
        if (cur === cache.length) {
            cache = randomBytes1(len * 2);
            cur = 0;
        }
        num = cache[cur++];
        if (num) {
            out[i++] = num;
        }
    }
    return out;
}
function privateDecrypt(privateKey, enc, reverse) {
    let padding;
    if (privateKey.padding) {
        padding = privateKey.padding;
    } else if (reverse) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(privateKey);
    const k = key.modulus.byteLength();
    if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
    }
    let msg;
    if (reverse) {
        msg = withPublic(new BN(enc), key);
    } else {
        msg = crt(enc, key);
    }
    const zBuffer = Buffer.alloc(k - msg.length);
    msg = Buffer.concat([
        zBuffer,
        msg
    ], k);
    if (padding === 4) {
        return oaep1(key, msg);
    } else if (padding === 1) {
        return pkcs11(key, msg, reverse);
    } else if (padding === 3) {
        return msg;
    } else {
        throw new Error("unknown padding");
    }
}
function oaep1(key, msg) {
    const k = key.modulus.byteLength();
    const iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    const hLen = iHash.length;
    if (msg[0] !== 0) {
        throw new Error("decryption error");
    }
    const maskedSeed = msg.slice(1, hLen + 1);
    const maskedDb = msg.slice(hLen + 1);
    const seed = xor1(maskedSeed, __default8(maskedDb, hLen));
    const db = xor1(maskedDb, __default8(seed, k - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
    }
    let i = hLen;
    while(db[i] === 0){
        i++;
    }
    if (db[i++] !== 1) {
        throw new Error("decryption error");
    }
    return db.slice(i);
}
function pkcs11(_key, msg, reverse) {
    const p1 = msg.slice(0, 2);
    let i = 2;
    let status = 0;
    while(msg[i++] !== 0){
        if (i >= msg.length) {
            status++;
            break;
        }
    }
    const ps = msg.slice(2, i - 1);
    if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
        status++;
    }
    if (ps.length < 8) {
        status++;
    }
    if (status) {
        throw new Error("decryption error");
    }
    return msg.slice(i);
}
function compare(a, b) {
    a = Buffer.from(a);
    b = Buffer.from(b);
    let dif = 0;
    let len = a.length;
    if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
    }
    let i = -1;
    while(++i < len){
        dif += a[i] ^ b[i];
    }
    return dif;
}
function privateEncrypt(key, buf) {
    return publicEncrypt(key, buf, true);
}
function publicDecrypt(key, buf) {
    return privateDecrypt(key, buf, true);
}
class Cipheriv extends Transform {
    constructor(_cipher, _key, _iv, _options){
        super();
        notImplemented("crypto.Cipheriv");
    }
    final(_outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.final");
    }
    getAuthTag() {
        notImplemented("crypto.Cipheriv.prototype.getAuthTag");
    }
    setAAD(_buffer, _options) {
        notImplemented("crypto.Cipheriv.prototype.setAAD");
    }
    setAutoPadding(_autoPadding) {
        notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
    }
    update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.update");
    }
}
class Decipheriv extends Transform {
    constructor(_cipher, _key, _iv, _options){
        super();
        notImplemented("crypto.Decipheriv");
    }
    final(_outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.final");
    }
    setAAD(_buffer, _options) {
        notImplemented("crypto.Decipheriv.prototype.setAAD");
    }
    setAuthTag(_buffer, _encoding) {
        notImplemented("crypto.Decipheriv.prototype.setAuthTag");
    }
    setAutoPadding(_autoPadding) {
        notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
    }
    update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.update");
    }
}
function getCipherInfo(nameOrNid, options) {
    if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
        throw new ERR_INVALID_ARG_TYPE("nameOrNid", [
            "string",
            "number"
        ], nameOrNid);
    }
    if (typeof nameOrNid === "number") {
        validateInt32(nameOrNid, "nameOrNid");
    }
    let keyLength, ivLength;
    if (options !== undefined) {
        validateObject(options, "options");
        ({ keyLength , ivLength  } = options);
        if (keyLength !== undefined) {
            validateInt32(keyLength, "options.keyLength");
        }
        if (ivLength !== undefined) {
            validateInt32(ivLength, "options.ivLength");
        }
    }
    notImplemented("crypto.getCipherInfo");
}
class Sign extends Writable {
    constructor(algorithm, _options){
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Sign");
    }
    sign(_privateKey, _outputEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
    }
}
class Verify extends Writable {
    constructor(algorithm, _options){
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Verify");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
    }
    verify(_object, _signature, _signatureEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
    }
}
function signOneShot(_algorithm, _data, _key, _callback) {
    notImplemented("crypto.sign");
}
function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
    notImplemented("crypto.verify");
}
class X509Certificate1 {
    constructor(buffer){
        if (typeof buffer === "string") {
            buffer = Buffer.from(buffer);
        }
        if (!isArrayBufferView(buffer)) {
            throw new ERR_INVALID_ARG_TYPE("buffer", [
                "string",
                "Buffer",
                "TypedArray",
                "DataView"
            ], buffer);
        }
        notImplemented("crypto.X509Certificate");
    }
    get ca() {
        notImplemented("crypto.X509Certificate.prototype.ca");
        return false;
    }
    checkEmail(_email, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkEmail");
    }
    checkHost(_name, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkHost");
    }
    checkIP(_ip) {
        notImplemented("crypto.X509Certificate.prototype.checkIP");
    }
    checkIssued(_otherCert) {
        notImplemented("crypto.X509Certificate.prototype.checkIssued");
    }
    checkPrivateKey(_privateKey) {
        notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
    }
    get fingerprint() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint");
        return "";
    }
    get fingerprint256() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint256");
        return "";
    }
    get fingerprint512() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint512");
        return "";
    }
    get infoAccess() {
        notImplemented("crypto.X509Certificate.prototype.infoAccess");
        return "";
    }
    get issuer() {
        notImplemented("crypto.X509Certificate.prototype.issuer");
        return "";
    }
    get issuerCertificate() {
        notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
        return {};
    }
    get keyUsage() {
        notImplemented("crypto.X509Certificate.prototype.keyUsage");
        return [];
    }
    get publicKey() {
        notImplemented("crypto.X509Certificate.prototype.publicKey");
        return {};
    }
    get raw() {
        notImplemented("crypto.X509Certificate.prototype.raw");
        return {};
    }
    get serialNumber() {
        notImplemented("crypto.X509Certificate.prototype.serialNumber");
        return "";
    }
    get subject() {
        notImplemented("crypto.X509Certificate.prototype.subject");
        return "";
    }
    get subjectAltName() {
        notImplemented("crypto.X509Certificate.prototype.subjectAltName");
        return "";
    }
    toJSON() {
        return this.toString();
    }
    toLegacyObject() {
        notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
    }
    toString() {
        notImplemented("crypto.X509Certificate.prototype.toString");
    }
    get validFrom() {
        notImplemented("crypto.X509Certificate.prototype.validFrom");
        return "";
    }
    get validTo() {
        notImplemented("crypto.X509Certificate.prototype.validTo");
        return "";
    }
    verify(_publicKey) {
        notImplemented("crypto.X509Certificate.prototype.verify");
    }
}
class Certificate {
    static exportChallenge(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportChallenge");
    }
    static exportPublicKey(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportPublicKey");
    }
    static verifySpkac(_spkac, _encoding) {
        notImplemented("crypto.Certificate.verifySpkac");
    }
}
const webcrypto = globalThis.crypto;
const fipsForced = getOptionValue("--force-fips");
function createCipheriv(cipher, key, iv, options) {
    return new Cipheriv(cipher, key, iv, options);
}
function createDecipheriv1(algorithm, key, iv, options) {
    return new Decipheriv(algorithm, key, iv, options);
}
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding);
}
function createDiffieHellmanGroup(name) {
    return new DiffieHellmanGroup(name);
}
function createECDH(curve) {
    return new ECDH(curve);
}
function createHmac(hmac, key, options) {
    return new Hmac(hmac, key, options);
}
function createSign1(algorithm, options) {
    return new Sign(algorithm, options);
}
function createVerify(algorithm, options) {
    return new Verify(algorithm, options);
}
function setFipsForced(val) {
    if (val) {
        return;
    }
    throw new ERR_CRYPTO_FIPS_FORCED();
}
function getFipsForced() {
    return 1;
}
Object.defineProperty(crypto1, "defaultCipherList", {
    value: getOptionValue("--tls-cipher-list")
});
const getDiffieHellman = createDiffieHellmanGroup;
const getFips = fipsForced ? getFipsForced : getFipsCrypto;
const setFips = fipsForced ? setFipsForced : setFipsCrypto;
const __default9 = {
    Certificate,
    checkPrime,
    checkPrimeSync,
    Cipheriv,
    constants: crypto1,
    createCipheriv,
    createDecipheriv: createDecipheriv1,
    createDiffieHellman,
    createDiffieHellmanGroup,
    createECDH,
    createHash,
    createHmac,
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    createSign: createSign1,
    createVerify,
    Decipheriv,
    DiffieHellman,
    diffieHellman,
    DiffieHellmanGroup,
    ECDH,
    generateKey,
    generateKeyPair,
    generateKeyPairSync,
    generateKeySync,
    generatePrime,
    generatePrimeSync,
    getCipherInfo,
    getCiphers,
    getCurves,
    getDiffieHellman,
    getFips,
    getHashes,
    Hash,
    hkdf,
    hkdfSync,
    Hmac,
    KeyObject,
    pbkdf2,
    pbkdf2Sync,
    privateDecrypt,
    privateEncrypt,
    publicDecrypt,
    publicEncrypt,
    randomBytes,
    randomFill,
    randomFillSync,
    randomInt,
    randomUUID,
    scrypt,
    scryptSync,
    secureHeapUsed,
    setEngine,
    setFips,
    Sign,
    sign: signOneShot,
    timingSafeEqual,
    Verify,
    verify: verifyOneShot,
    webcrypto,
    X509Certificate: X509Certificate1
};
var m2 = Object.create;
var p3 = Object.defineProperty;
var c2 = Object.getOwnPropertyDescriptor;
var g2 = Object.getOwnPropertyNames;
var w2 = Object.getPrototypeOf, _ = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var R1 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var v = (e, r, t, o)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let a of g2(r))!_.call(e, a) && a !== t && p3(e, a, {
        get: ()=>r[a],
        enumerable: !(o = c2(r, a)) || o.enumerable
    });
    return e;
};
var u1 = (e, r, t)=>(t = e != null ? m2(w2(e)) : {}, v(r || !e || !e.__esModule ? p3(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var i3 = R1(($, d)=>{
    var s;
    d.exports = function(r) {
        return s || (s = new n(null)), s.generate(r);
    };
    function n(e) {
        this.rand = e;
    }
    d.exports.Rand = n;
    n.prototype.generate = function(r) {
        return this._rand(r);
    };
    n.prototype._rand = function(r) {
        if (this.rand.getBytes) return this.rand.getBytes(r);
        for(var t = new Uint8Array(r), o = 0; o < t.length; o++)t[o] = this.rand.getByte();
        return t;
    };
    if (typeof self == "object") self.crypto && self.crypto.getRandomValues ? n.prototype._rand = function(r) {
        var t = new Uint8Array(r);
        return self.crypto.getRandomValues(t), t;
    } : self.msCrypto && self.msCrypto.getRandomValues ? n.prototype._rand = function(r) {
        var t = new Uint8Array(r);
        return self.msCrypto.getRandomValues(t), t;
    } : typeof window == "object" && (n.prototype._rand = function() {
        throw new Error("Not implemented yet");
    });
    else try {
        if (f = __default9, typeof f.randomBytes != "function") throw new Error("Not supported");
        n.prototype._rand = function(r) {
            return f.randomBytes(r);
        };
    } catch  {}
    var f;
});
var l2 = u1(i3()), y1 = u1(i3()), { Rand: A  } = y1, { default: B , ...x2 } = y1, C = (l2.default ?? B) ?? x2;
var x3 = Object.create;
var l3 = Object.defineProperty;
var y2 = Object.getOwnPropertyDescriptor;
var A1 = Object.getOwnPropertyNames;
var $2 = Object.getPrototypeOf, s1 = Object.prototype.hasOwnProperty;
var z = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var H1 = (r, e, t, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let f of A1(e))!s1.call(r, f) && f !== t && l3(r, f, {
        get: ()=>e[f],
        enumerable: !(n = y2(e, f)) || n.enumerable
    });
    return r;
};
var h2 = (r, e, t)=>(t = r != null ? x3($2(r)) : {}, H1(e || !r || !r.__esModule ? l3(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r));
var u2 = z((p)=>{
    "use strict";
    var o = p;
    function C(r, e) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var t = [];
        if (typeof r != "string") {
            for(var n = 0; n < r.length; n++)t[n] = r[n] | 0;
            return t;
        }
        if (e === "hex") {
            r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 !== 0 && (r = "0" + r);
            for(var n = 0; n < r.length; n += 2)t.push(parseInt(r[n] + r[n + 1], 16));
        } else for(var n = 0; n < r.length; n++){
            var f = r.charCodeAt(n), a = f >> 8, i = f & 255;
            a ? t.push(a, i) : t.push(i);
        }
        return t;
    }
    o.toArray = C;
    function c(r) {
        return r.length === 1 ? "0" + r : r;
    }
    o.zero2 = c;
    function v(r) {
        for(var e = "", t = 0; t < r.length; t++)e += c(r[t].toString(16));
        return e;
    }
    o.toHex = v;
    o.encode = function(e, t) {
        return t === "hex" ? v(e) : e;
    };
});
var d2 = h2(u2()), I = h2(u2()), { default: S , ...b1 } = I, q1 = (d2.default ?? S) ?? b1;
var _1 = Object.create;
var p4 = Object.defineProperty;
var g3 = Object.getOwnPropertyDescriptor;
var d3 = Object.getOwnPropertyNames;
var v1 = Object.getPrototypeOf, V = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (e, i)=>(typeof require != "undefined" ? require : e)[i]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var x4 = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var A2 = (t, e, i, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let s of d3(e))!V.call(t, s) && s !== i && p4(t, s, {
        get: ()=>e[s],
        enumerable: !(r = g3(e, s)) || r.enumerable
    });
    return t;
};
var c3 = (t, e, i)=>(i = t != null ? _1(v1(t)) : {}, A2(e || !t || !t.__esModule ? p4(i, "default", {
        value: t,
        enumerable: !0
    }) : i, t));
var o = x4(($, l)=>{
    "use strict";
    var w = Qe, a = q1, m = j;
    function n(t) {
        if (!(this instanceof n)) return new n(t);
        this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var e = a.toArray(t.entropy, t.entropyEnc || "hex"), i = a.toArray(t.nonce, t.nonceEnc || "hex"), r = a.toArray(t.pers, t.persEnc || "hex");
        m(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, i, r);
    }
    l.exports = n;
    n.prototype._init = function(e, i, r) {
        var s = e.concat(i).concat(r);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for(var h = 0; h < this.V.length; h++)this.K[h] = 0, this.V[h] = 1;
        this._update(s), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    n.prototype._hmac = function() {
        return new w.hmac(this.hash, this.K);
    };
    n.prototype._update = function(e) {
        var i = this._hmac().update(this.V).update([
            0
        ]);
        e && (i = i.update(e)), this.K = i.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([
            1
        ]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    n.prototype.reseed = function(e, i, r, s) {
        typeof i != "string" && (s = r, r = i, i = null), e = a.toArray(e, i), r = a.toArray(r, s), m(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(r || [])), this._reseed = 1;
    };
    n.prototype.generate = function(e, i, r, s) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        typeof i != "string" && (s = r, r = i, i = null), r && (r = a.toArray(r, s || "hex"), this._update(r));
        for(var h = []; h.length < e;)this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
        var y = h.slice(0, e);
        return this._update(r), this._reseed++, a.encode(y, i);
    };
});
var f1 = c3(o()), K2 = c3(o()), { default: E1 , ...q2 } = K2, I1 = (f1.default ?? E1) ?? q2;
var pf = Object.create;
var Pe = Object.defineProperty;
var yf = Object.getOwnPropertyDescriptor;
var mf = Object.getOwnPropertyNames;
var Sf = Object.getPrototypeOf, gf = Object.prototype.hasOwnProperty;
((d)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(d, {
        get: (e, f)=>(typeof require != "undefined" ? require : e)[f]
    }) : d)(function(d) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + d + '" is not supported');
});
var M = (d, e)=>()=>(e || d((e = {
            exports: {}
        }).exports, e), e.exports);
var Af = (d, e, f, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let a of mf(e))!gf.call(d, a) && a !== f && Pe(d, a, {
        get: ()=>e[a],
        enumerable: !(r = yf(e, a)) || r.enumerable
    });
    return d;
};
var ze = (d, e, f)=>(f = d != null ? pf(Sf(d)) : {}, Af(e || !d || !d.__esModule ? Pe(f, "default", {
        value: d,
        enumerable: !0
    }) : f, d));
var Re = M((Qf, xf)=>{
    xf.exports = {
        name: "elliptic",
        version: "6.5.4",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
            "lib"
        ],
        scripts: {
            lint: "eslint lib test",
            "lint:fix": "npm run lint -- --fix",
            unit: "istanbul test _mocha --reporter=spec test/index.js",
            test: "npm run lint && npm run unit",
            version: "grunt dist && git add dist/"
        },
        repository: {
            type: "git",
            url: "git@github.com:indutny/elliptic"
        },
        keywords: [
            "EC",
            "Elliptic",
            "curve",
            "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
            url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
            brfs: "^2.0.2",
            coveralls: "^3.1.0",
            eslint: "^7.6.0",
            grunt: "^1.2.1",
            "grunt-browserify": "^5.3.0",
            "grunt-cli": "^1.3.2",
            "grunt-contrib-connect": "^3.0.0",
            "grunt-contrib-copy": "^1.0.0",
            "grunt-contrib-uglify": "^5.0.0",
            "grunt-mocha-istanbul": "^5.0.2",
            "grunt-saucelabs": "^9.0.1",
            istanbul: "^0.4.5",
            mocha: "^8.0.1"
        },
        dependencies: {
            "bn.js": "^4.11.9",
            brorand: "^1.1.0",
            "hash.js": "^1.0.0",
            "hmac-drbg": "^1.0.1",
            inherits: "^2.0.4",
            "minimalistic-assert": "^1.0.1",
            "minimalistic-crypto-utils": "^1.0.1"
        }
    };
});
var z1 = M((Ne)=>{
    "use strict";
    var B = Ne, If = ki, wf = j, fe = q1;
    B.assert = wf;
    B.toArray = fe.toArray;
    B.zero2 = fe.zero2;
    B.toHex = fe.toHex;
    B.encode = fe.encode;
    function Mf(d, e, f) {
        var r = new Array(Math.max(d.bitLength(), f) + 1);
        r.fill(0);
        for(var a = 1 << e + 1, c = d.clone(), b = 0; b < r.length; b++){
            var t, i = c.andln(a - 1);
            c.isOdd() ? (i > (a >> 1) - 1 ? t = (a >> 1) - i : t = i, c.isubn(t)) : t = 0, r[b] = t, c.iushrn(1);
        }
        return r;
    }
    B.getNAF = Mf;
    function qf(d, e) {
        var f = [
            [],
            []
        ];
        d = d.clone(), e = e.clone();
        for(var r = 0, a = 0, c; d.cmpn(-r) > 0 || e.cmpn(-a) > 0;){
            var b = d.andln(3) + r & 3, t = e.andln(3) + a & 3;
            b === 3 && (b = -1), t === 3 && (t = -1);
            var i;
            (b & 1) === 0 ? i = 0 : (c = d.andln(7) + r & 7, (c === 3 || c === 5) && t === 2 ? i = -b : i = b), f[0].push(i);
            var s;
            (t & 1) === 0 ? s = 0 : (c = e.andln(7) + a & 7, (c === 3 || c === 5) && b === 2 ? s = -t : s = t), f[1].push(s), 2 * r === i + 1 && (r = 1 - r), 2 * a === s + 1 && (a = 1 - a), d.iushrn(1), e.iushrn(1);
        }
        return f;
    }
    B.getJSF = qf;
    function _f(d, e, f) {
        var r = "_" + e;
        d.prototype[e] = function() {
            return this[r] !== void 0 ? this[r] : this[r] = f.call(this);
        };
    }
    B.cachedProperty = _f;
    function Pf(d) {
        return typeof d == "string" ? B.toArray(d, "hex") : d;
    }
    B.parseBytes = Pf;
    function zf(d) {
        return new If(d, "hex", "le");
    }
    B.intFromLE = zf;
});
var Q = M((fd, Ee)=>{
    "use strict";
    var X = ki, Z = z1(), de = Z.getNAF, Rf = Z.getJSF, re = Z.assert;
    function L(d, e) {
        this.type = d, this.p = new X(e.p, 16), this.red = e.prime ? X.red(e.prime) : X.mont(this.p), this.zero = new X(0).toRed(this.red), this.one = new X(1).toRed(this.red), this.two = new X(2).toRed(this.red), this.n = e.n && new X(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var f = this.n && this.p.div(this.n);
        !f || f.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
    }
    Ee.exports = L;
    L.prototype.point = function() {
        throw new Error("Not implemented");
    };
    L.prototype.validate = function() {
        throw new Error("Not implemented");
    };
    L.prototype._fixedNafMul = function(e, f) {
        re(e.precomputed);
        var r = e._getDoubles(), a = de(f, 1, this._bitLength), c = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
        c /= 3;
        var b = [], t, i;
        for(t = 0; t < a.length; t += r.step){
            i = 0;
            for(var s = t + r.step - 1; s >= t; s--)i = (i << 1) + a[s];
            b.push(i);
        }
        for(var n = this.jpoint(null, null, null), u = this.jpoint(null, null, null), o = c; o > 0; o--){
            for(t = 0; t < b.length; t++)i = b[t], i === o ? u = u.mixedAdd(r.points[t]) : i === -o && (u = u.mixedAdd(r.points[t].neg()));
            n = n.add(u);
        }
        return n.toP();
    };
    L.prototype._wnafMul = function(e, f) {
        var r = 4, a = e._getNAFPoints(r);
        r = a.wnd;
        for(var c = a.points, b = de(f, r, this._bitLength), t = this.jpoint(null, null, null), i = b.length - 1; i >= 0; i--){
            for(var s = 0; i >= 0 && b[i] === 0; i--)s++;
            if (i >= 0 && s++, t = t.dblp(s), i < 0) break;
            var n = b[i];
            re(n !== 0), e.type === "affine" ? n > 0 ? t = t.mixedAdd(c[n - 1 >> 1]) : t = t.mixedAdd(c[-n - 1 >> 1].neg()) : n > 0 ? t = t.add(c[n - 1 >> 1]) : t = t.add(c[-n - 1 >> 1].neg());
        }
        return e.type === "affine" ? t.toP() : t;
    };
    L.prototype._wnafMulAdd = function(e, f, r, a, c) {
        var b = this._wnafT1, t = this._wnafT2, i = this._wnafT3, s = 0, n, u, o;
        for(n = 0; n < a; n++){
            o = f[n];
            var v = o._getNAFPoints(e);
            b[n] = v.wnd, t[n] = v.points;
        }
        for(n = a - 1; n >= 1; n -= 2){
            var h = n - 1, l = n;
            if (b[h] !== 1 || b[l] !== 1) {
                i[h] = de(r[h], b[h], this._bitLength), i[l] = de(r[l], b[l], this._bitLength), s = Math.max(i[h].length, s), s = Math.max(i[l].length, s);
                continue;
            }
            var S = [
                f[h],
                null,
                null,
                f[l]
            ];
            f[h].y.cmp(f[l].y) === 0 ? (S[1] = f[h].add(f[l]), S[2] = f[h].toJ().mixedAdd(f[l].neg())) : f[h].y.cmp(f[l].y.redNeg()) === 0 ? (S[1] = f[h].toJ().mixedAdd(f[l]), S[2] = f[h].add(f[l].neg())) : (S[1] = f[h].toJ().mixedAdd(f[l]), S[2] = f[h].toJ().mixedAdd(f[l].neg()));
            var p = [
                -3,
                -1,
                -5,
                -7,
                0,
                7,
                5,
                1,
                3
            ], P = Rf(r[h], r[l]);
            for(s = Math.max(P[0].length, s), i[h] = new Array(s), i[l] = new Array(s), u = 0; u < s; u++){
                var D = P[0][u] | 0, he = P[1][u] | 0;
                i[h][u] = p[(D + 1) * 3 + (he + 1)], i[l][u] = 0, t[h] = S;
            }
        }
        var F = this.jpoint(null, null, null), G = this._wnafT4;
        for(n = s; n >= 0; n--){
            for(var ve = 0; n >= 0;){
                var _e = !0;
                for(u = 0; u < a; u++)G[u] = i[u][n] | 0, G[u] !== 0 && (_e = !1);
                if (!_e) break;
                ve++, n--;
            }
            if (n >= 0 && ve++, F = F.dblp(ve), n < 0) break;
            for(u = 0; u < a; u++){
                var V = G[u];
                V !== 0 && (V > 0 ? o = t[u][V - 1 >> 1] : V < 0 && (o = t[u][-V - 1 >> 1].neg()), o.type === "affine" ? F = F.mixedAdd(o) : F = F.add(o));
            }
        }
        for(n = 0; n < a; n++)t[n] = null;
        return c ? F : F.toP();
    };
    function R(d, e) {
        this.curve = d, this.type = e, this.precomputed = null;
    }
    L.BasePoint = R;
    R.prototype.eq = function() {
        throw new Error("Not implemented");
    };
    R.prototype.validate = function() {
        return this.curve.validate(this);
    };
    L.prototype.decodePoint = function(e, f) {
        e = Z.toArray(e, f);
        var r = this.p.byteLength();
        if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
            e[0] === 6 ? re(e[e.length - 1] % 2 === 0) : e[0] === 7 && re(e[e.length - 1] % 2 === 1);
            var a = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
            return a;
        } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
        throw new Error("Unknown point format");
    };
    R.prototype.encodeCompressed = function(e) {
        return this.encode(e, !0);
    };
    R.prototype._encode = function(e) {
        var f = this.curve.p.byteLength(), r = this.getX().toArray("be", f);
        return e ? [
            this.getY().isEven() ? 2 : 3
        ].concat(r) : [
            4
        ].concat(r, this.getY().toArray("be", f));
    };
    R.prototype.encode = function(e, f) {
        return Z.encode(this._encode(f), e);
    };
    R.prototype.precompute = function(e) {
        if (this.precomputed) return this;
        var f = {
            doubles: null,
            naf: null,
            beta: null
        };
        return f.naf = this._getNAFPoints(8), f.doubles = this._getDoubles(4, e), f.beta = this._getBeta(), this.precomputed = f, this;
    };
    R.prototype._hasDoubles = function(e) {
        if (!this.precomputed) return !1;
        var f = this.precomputed.doubles;
        return f ? f.points.length >= Math.ceil((e.bitLength() + 1) / f.step) : !1;
    };
    R.prototype._getDoubles = function(e, f) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        for(var r = [
            this
        ], a = this, c = 0; c < f; c += e){
            for(var b = 0; b < e; b++)a = a.dbl();
            r.push(a);
        }
        return {
            step: e,
            points: r
        };
    };
    R.prototype._getNAFPoints = function(e) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        for(var f = [
            this
        ], r = (1 << e) - 1, a = r === 1 ? null : this.dbl(), c = 1; c < r; c++)f[c] = f[c - 1].add(a);
        return {
            wnd: e,
            points: f
        };
    };
    R.prototype._getBeta = function() {
        return null;
    };
    R.prototype.dblp = function(e) {
        for(var f = this, r = 0; r < e; r++)f = f.dbl();
        return f;
    };
});
var Fe = M((dd, Be)=>{
    "use strict";
    var Nf = z1(), m = ki, le = w, W = Q(), Ef = Nf.assert;
    function N(d) {
        W.call(this, "short", d), this.a = new m(d.a, 16).toRed(this.red), this.b = new m(d.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(d), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    le(N, W);
    Be.exports = N;
    N.prototype._getEndomorphism = function(e) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var f, r;
            if (e.beta) f = new m(e.beta, 16).toRed(this.red);
            else {
                var a = this._getEndoRoots(this.p);
                f = a[0].cmp(a[1]) < 0 ? a[0] : a[1], f = f.toRed(this.red);
            }
            if (e.lambda) r = new m(e.lambda, 16);
            else {
                var c = this._getEndoRoots(this.n);
                this.g.mul(c[0]).x.cmp(this.g.x.redMul(f)) === 0 ? r = c[0] : (r = c[1], Ef(this.g.mul(r).x.cmp(this.g.x.redMul(f)) === 0));
            }
            var b;
            return e.basis ? b = e.basis.map(function(t) {
                return {
                    a: new m(t.a, 16),
                    b: new m(t.b, 16)
                };
            }) : b = this._getEndoBasis(r), {
                beta: f,
                lambda: r,
                basis: b
            };
        }
    };
    N.prototype._getEndoRoots = function(e) {
        var f = e === this.p ? this.red : m.mont(e), r = new m(2).toRed(f).redInvm(), a = r.redNeg(), c = new m(3).toRed(f).redNeg().redSqrt().redMul(r), b = a.redAdd(c).fromRed(), t = a.redSub(c).fromRed();
        return [
            b,
            t
        ];
    };
    N.prototype._getEndoBasis = function(e) {
        for(var f = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, a = this.n.clone(), c = new m(1), b = new m(0), t = new m(0), i = new m(1), s, n, u, o, v, h, l, S = 0, p, P; r.cmpn(0) !== 0;){
            var D = a.div(r);
            p = a.sub(D.mul(r)), P = t.sub(D.mul(c));
            var he = i.sub(D.mul(b));
            if (!u && p.cmp(f) < 0) s = l.neg(), n = c, u = p.neg(), o = P;
            else if (u && ++S === 2) break;
            l = p, a = r, r = p, t = c, c = P, i = b, b = he;
        }
        v = p.neg(), h = P;
        var F = u.sqr().add(o.sqr()), G = v.sqr().add(h.sqr());
        return G.cmp(F) >= 0 && (v = s, h = n), u.negative && (u = u.neg(), o = o.neg()), v.negative && (v = v.neg(), h = h.neg()), [
            {
                a: u,
                b: o
            },
            {
                a: v,
                b: h
            }
        ];
    };
    N.prototype._endoSplit = function(e) {
        var f = this.endo.basis, r = f[0], a = f[1], c = a.b.mul(e).divRound(this.n), b = r.b.neg().mul(e).divRound(this.n), t = c.mul(r.a), i = b.mul(a.a), s = c.mul(r.b), n = b.mul(a.b), u = e.sub(t).sub(i), o = s.add(n).neg();
        return {
            k1: u,
            k2: o
        };
    };
    N.prototype.pointFromX = function(e, f) {
        e = new m(e, 16), e.red || (e = e.toRed(this.red));
        var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), a = r.redSqrt();
        if (a.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error("invalid point");
        var c = a.fromRed().isOdd();
        return (f && !c || !f && c) && (a = a.redNeg()), this.point(e, a);
    };
    N.prototype.validate = function(e) {
        if (e.inf) return !0;
        var f = e.x, r = e.y, a = this.a.redMul(f), c = f.redSqr().redMul(f).redIAdd(a).redIAdd(this.b);
        return r.redSqr().redISub(c).cmpn(0) === 0;
    };
    N.prototype._endoWnafMulAdd = function(e, f, r) {
        for(var a = this._endoWnafT1, c = this._endoWnafT2, b = 0; b < e.length; b++){
            var t = this._endoSplit(f[b]), i = e[b], s = i._getBeta();
            t.k1.negative && (t.k1.ineg(), i = i.neg(!0)), t.k2.negative && (t.k2.ineg(), s = s.neg(!0)), a[b * 2] = i, a[b * 2 + 1] = s, c[b * 2] = t.k1, c[b * 2 + 1] = t.k2;
        }
        for(var n = this._wnafMulAdd(1, a, c, b * 2, r), u = 0; u < b * 2; u++)a[u] = null, c[u] = null;
        return n;
    };
    function A(d, e, f, r) {
        W.BasePoint.call(this, d, "affine"), e === null && f === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new m(e, 16), this.y = new m(f, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
    }
    le(A, W.BasePoint);
    N.prototype.point = function(e, f, r) {
        return new A(this, e, f, r);
    };
    N.prototype.pointFromJSON = function(e, f) {
        return A.fromJSON(this, e, f);
    };
    A.prototype._getBeta = function() {
        if (!!this.curve.endo) {
            var e = this.precomputed;
            if (e && e.beta) return e.beta;
            var f = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (e) {
                var r = this.curve, a = function(c) {
                    return r.point(c.x.redMul(r.endo.beta), c.y);
                };
                e.beta = f, f.precomputed = {
                    beta: null,
                    naf: e.naf && {
                        wnd: e.naf.wnd,
                        points: e.naf.points.map(a)
                    },
                    doubles: e.doubles && {
                        step: e.doubles.step,
                        points: e.doubles.points.map(a)
                    }
                };
            }
            return f;
        }
    };
    A.prototype.toJSON = function() {
        return this.precomputed ? [
            this.x,
            this.y,
            this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }
        ] : [
            this.x,
            this.y
        ];
    };
    A.fromJSON = function(e, f, r) {
        typeof f == "string" && (f = JSON.parse(f));
        var a = e.point(f[0], f[1], r);
        if (!f[2]) return a;
        function c(t) {
            return e.point(t[0], t[1], r);
        }
        var b = f[2];
        return a.precomputed = {
            beta: null,
            doubles: b.doubles && {
                step: b.doubles.step,
                points: [
                    a
                ].concat(b.doubles.points.map(c))
            },
            naf: b.naf && {
                wnd: b.naf.wnd,
                points: [
                    a
                ].concat(b.naf.points.map(c))
            }
        }, a;
    };
    A.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    A.prototype.isInfinity = function() {
        return this.inf;
    };
    A.prototype.add = function(e) {
        if (this.inf) return e;
        if (e.inf) return this;
        if (this.eq(e)) return this.dbl();
        if (this.neg().eq(e)) return this.curve.point(null, null);
        if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
        var f = this.y.redSub(e.y);
        f.cmpn(0) !== 0 && (f = f.redMul(this.x.redSub(e.x).redInvm()));
        var r = f.redSqr().redISub(this.x).redISub(e.x), a = f.redMul(this.x.redSub(r)).redISub(this.y);
        return this.curve.point(r, a);
    };
    A.prototype.dbl = function() {
        if (this.inf) return this;
        var e = this.y.redAdd(this.y);
        if (e.cmpn(0) === 0) return this.curve.point(null, null);
        var f = this.curve.a, r = this.x.redSqr(), a = e.redInvm(), c = r.redAdd(r).redIAdd(r).redIAdd(f).redMul(a), b = c.redSqr().redISub(this.x.redAdd(this.x)), t = c.redMul(this.x.redSub(b)).redISub(this.y);
        return this.curve.point(b, t);
    };
    A.prototype.getX = function() {
        return this.x.fromRed();
    };
    A.prototype.getY = function() {
        return this.y.fromRed();
    };
    A.prototype.mul = function(e) {
        return e = new m(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([
            this
        ], [
            e
        ]) : this.curve._wnafMul(this, e);
    };
    A.prototype.mulAdd = function(e, f, r) {
        var a = [
            this,
            f
        ], c = [
            e,
            r
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(a, c) : this.curve._wnafMulAdd(1, a, c, 2);
    };
    A.prototype.jmulAdd = function(e, f, r) {
        var a = [
            this,
            f
        ], c = [
            e,
            r
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(a, c, !0) : this.curve._wnafMulAdd(1, a, c, 2, !0);
    };
    A.prototype.eq = function(e) {
        return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    A.prototype.neg = function(e) {
        if (this.inf) return this;
        var f = this.curve.point(this.x, this.y.redNeg());
        if (e && this.precomputed) {
            var r = this.precomputed, a = function(c) {
                return c.neg();
            };
            f.precomputed = {
                naf: r.naf && {
                    wnd: r.naf.wnd,
                    points: r.naf.points.map(a)
                },
                doubles: r.doubles && {
                    step: r.doubles.step,
                    points: r.doubles.points.map(a)
                }
            };
        }
        return f;
    };
    A.prototype.toJ = function() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var e = this.curve.jpoint(this.x, this.y, this.curve.one);
        return e;
    };
    function w1(d, e, f, r) {
        W.BasePoint.call(this, d, "jacobian"), e === null && f === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new m(0)) : (this.x = new m(e, 16), this.y = new m(f, 16), this.z = new m(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    le(w1, W.BasePoint);
    N.prototype.jpoint = function(e, f, r) {
        return new w1(this, e, f, r);
    };
    w1.prototype.toP = function() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var e = this.z.redInvm(), f = e.redSqr(), r = this.x.redMul(f), a = this.y.redMul(f).redMul(e);
        return this.curve.point(r, a);
    };
    w1.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    w1.prototype.add = function(e) {
        if (this.isInfinity()) return e;
        if (e.isInfinity()) return this;
        var f = e.z.redSqr(), r = this.z.redSqr(), a = this.x.redMul(f), c = e.x.redMul(r), b = this.y.redMul(f.redMul(e.z)), t = e.y.redMul(r.redMul(this.z)), i = a.redSub(c), s = b.redSub(t);
        if (i.cmpn(0) === 0) return s.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var n = i.redSqr(), u = n.redMul(i), o = a.redMul(n), v = s.redSqr().redIAdd(u).redISub(o).redISub(o), h = s.redMul(o.redISub(v)).redISub(b.redMul(u)), l = this.z.redMul(e.z).redMul(i);
        return this.curve.jpoint(v, h, l);
    };
    w1.prototype.mixedAdd = function(e) {
        if (this.isInfinity()) return e.toJ();
        if (e.isInfinity()) return this;
        var f = this.z.redSqr(), r = this.x, a = e.x.redMul(f), c = this.y, b = e.y.redMul(f).redMul(this.z), t = r.redSub(a), i = c.redSub(b);
        if (t.cmpn(0) === 0) return i.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var s = t.redSqr(), n = s.redMul(t), u = r.redMul(s), o = i.redSqr().redIAdd(n).redISub(u).redISub(u), v = i.redMul(u.redISub(o)).redISub(c.redMul(n)), h = this.z.redMul(t);
        return this.curve.jpoint(o, v, h);
    };
    w1.prototype.dblp = function(e) {
        if (e === 0) return this;
        if (this.isInfinity()) return this;
        if (!e) return this.dbl();
        var f;
        if (this.curve.zeroA || this.curve.threeA) {
            var r = this;
            for(f = 0; f < e; f++)r = r.dbl();
            return r;
        }
        var a = this.curve.a, c = this.curve.tinv, b = this.x, t = this.y, i = this.z, s = i.redSqr().redSqr(), n = t.redAdd(t);
        for(f = 0; f < e; f++){
            var u = b.redSqr(), o = n.redSqr(), v = o.redSqr(), h = u.redAdd(u).redIAdd(u).redIAdd(a.redMul(s)), l = b.redMul(o), S = h.redSqr().redISub(l.redAdd(l)), p = l.redISub(S), P = h.redMul(p);
            P = P.redIAdd(P).redISub(v);
            var D = n.redMul(i);
            f + 1 < e && (s = s.redMul(v)), b = S, i = D, n = P;
        }
        return this.curve.jpoint(b, n.redMul(c), i);
    };
    w1.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    w1.prototype._zeroDbl = function() {
        var e, f, r;
        if (this.zOne) {
            var a = this.x.redSqr(), c = this.y.redSqr(), b = c.redSqr(), t = this.x.redAdd(c).redSqr().redISub(a).redISub(b);
            t = t.redIAdd(t);
            var i = a.redAdd(a).redIAdd(a), s = i.redSqr().redISub(t).redISub(t), n = b.redIAdd(b);
            n = n.redIAdd(n), n = n.redIAdd(n), e = s, f = i.redMul(t.redISub(s)).redISub(n), r = this.y.redAdd(this.y);
        } else {
            var u = this.x.redSqr(), o = this.y.redSqr(), v = o.redSqr(), h = this.x.redAdd(o).redSqr().redISub(u).redISub(v);
            h = h.redIAdd(h);
            var l = u.redAdd(u).redIAdd(u), S = l.redSqr(), p = v.redIAdd(v);
            p = p.redIAdd(p), p = p.redIAdd(p), e = S.redISub(h).redISub(h), f = l.redMul(h.redISub(e)).redISub(p), r = this.y.redMul(this.z), r = r.redIAdd(r);
        }
        return this.curve.jpoint(e, f, r);
    };
    w1.prototype._threeDbl = function() {
        var e, f, r;
        if (this.zOne) {
            var a = this.x.redSqr(), c = this.y.redSqr(), b = c.redSqr(), t = this.x.redAdd(c).redSqr().redISub(a).redISub(b);
            t = t.redIAdd(t);
            var i = a.redAdd(a).redIAdd(a).redIAdd(this.curve.a), s = i.redSqr().redISub(t).redISub(t);
            e = s;
            var n = b.redIAdd(b);
            n = n.redIAdd(n), n = n.redIAdd(n), f = i.redMul(t.redISub(s)).redISub(n), r = this.y.redAdd(this.y);
        } else {
            var u = this.z.redSqr(), o = this.y.redSqr(), v = this.x.redMul(o), h = this.x.redSub(u).redMul(this.x.redAdd(u));
            h = h.redAdd(h).redIAdd(h);
            var l = v.redIAdd(v);
            l = l.redIAdd(l);
            var S = l.redAdd(l);
            e = h.redSqr().redISub(S), r = this.y.redAdd(this.z).redSqr().redISub(o).redISub(u);
            var p = o.redSqr();
            p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p), f = h.redMul(l.redISub(e)).redISub(p);
        }
        return this.curve.jpoint(e, f, r);
    };
    w1.prototype._dbl = function() {
        var e = this.curve.a, f = this.x, r = this.y, a = this.z, c = a.redSqr().redSqr(), b = f.redSqr(), t = r.redSqr(), i = b.redAdd(b).redIAdd(b).redIAdd(e.redMul(c)), s = f.redAdd(f);
        s = s.redIAdd(s);
        var n = s.redMul(t), u = i.redSqr().redISub(n.redAdd(n)), o = n.redISub(u), v = t.redSqr();
        v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
        var h = i.redMul(o).redISub(v), l = r.redAdd(r).redMul(a);
        return this.curve.jpoint(u, h, l);
    };
    w1.prototype.trpl = function() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var e = this.x.redSqr(), f = this.y.redSqr(), r = this.z.redSqr(), a = f.redSqr(), c = e.redAdd(e).redIAdd(e), b = c.redSqr(), t = this.x.redAdd(f).redSqr().redISub(e).redISub(a);
        t = t.redIAdd(t), t = t.redAdd(t).redIAdd(t), t = t.redISub(b);
        var i = t.redSqr(), s = a.redIAdd(a);
        s = s.redIAdd(s), s = s.redIAdd(s), s = s.redIAdd(s);
        var n = c.redIAdd(t).redSqr().redISub(b).redISub(i).redISub(s), u = f.redMul(n);
        u = u.redIAdd(u), u = u.redIAdd(u);
        var o = this.x.redMul(i).redISub(u);
        o = o.redIAdd(o), o = o.redIAdd(o);
        var v = this.y.redMul(n.redMul(s.redISub(n)).redISub(t.redMul(i)));
        v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
        var h = this.z.redAdd(t).redSqr().redISub(r).redISub(i);
        return this.curve.jpoint(o, v, h);
    };
    w1.prototype.mul = function(e, f) {
        return e = new m(e, f), this.curve._wnafMul(this, e);
    };
    w1.prototype.eq = function(e) {
        if (e.type === "affine") return this.eq(e.toJ());
        if (this === e) return !0;
        var f = this.z.redSqr(), r = e.z.redSqr();
        if (this.x.redMul(r).redISub(e.x.redMul(f)).cmpn(0) !== 0) return !1;
        var a = f.redMul(this.z), c = r.redMul(e.z);
        return this.y.redMul(c).redISub(e.y.redMul(a)).cmpn(0) === 0;
    };
    w1.prototype.eqXToP = function(e) {
        var f = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(f);
        if (this.x.cmp(r) === 0) return !0;
        for(var a = e.clone(), c = this.curve.redN.redMul(f);;){
            if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0) return !1;
            if (r.redIAdd(c), this.x.cmp(r) === 0) return !0;
        }
    };
    w1.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    w1.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    };
});
var Le1 = M((rd, je)=>{
    "use strict";
    var k = ki, Oe = w, ae = Q(), Bf = z1();
    function H(d) {
        ae.call(this, "mont", d), this.a = new k(d.a, 16).toRed(this.red), this.b = new k(d.b, 16).toRed(this.red), this.i4 = new k(4).toRed(this.red).redInvm(), this.two = new k(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    Oe(H, ae);
    je.exports = H;
    H.prototype.validate = function(e) {
        var f = e.normalize().x, r = f.redSqr(), a = r.redMul(f).redAdd(r.redMul(this.a)).redAdd(f), c = a.redSqrt();
        return c.redSqr().cmp(a) === 0;
    };
    function x(d, e, f) {
        ae.BasePoint.call(this, d, "projective"), e === null && f === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new k(e, 16), this.z = new k(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    Oe(x, ae.BasePoint);
    H.prototype.decodePoint = function(e, f) {
        return this.point(Bf.toArray(e, f), 1);
    };
    H.prototype.point = function(e, f) {
        return new x(this, e, f);
    };
    H.prototype.pointFromJSON = function(e) {
        return x.fromJSON(this, e);
    };
    x.prototype.precompute = function() {};
    x.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    };
    x.fromJSON = function(e, f) {
        return new x(e, f[0], f[1] || e.one);
    };
    x.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    x.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    };
    x.prototype.dbl = function() {
        var e = this.x.redAdd(this.z), f = e.redSqr(), r = this.x.redSub(this.z), a = r.redSqr(), c = f.redSub(a), b = f.redMul(a), t = c.redMul(a.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(b, t);
    };
    x.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
    };
    x.prototype.diffAdd = function(e, f) {
        var r = this.x.redAdd(this.z), a = this.x.redSub(this.z), c = e.x.redAdd(e.z), b = e.x.redSub(e.z), t = b.redMul(r), i = c.redMul(a), s = f.z.redMul(t.redAdd(i).redSqr()), n = f.x.redMul(t.redISub(i).redSqr());
        return this.curve.point(s, n);
    };
    x.prototype.mul = function(e) {
        for(var f = e.clone(), r = this, a = this.curve.point(null, null), c = this, b = []; f.cmpn(0) !== 0; f.iushrn(1))b.push(f.andln(1));
        for(var t = b.length - 1; t >= 0; t--)b[t] === 0 ? (r = r.diffAdd(a, c), a = a.dbl()) : (a = r.diffAdd(a, c), r = r.dbl());
        return a;
    };
    x.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    };
    x.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    };
    x.prototype.eq = function(e) {
        return this.getX().cmp(e.getX()) === 0;
    };
    x.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    x.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    };
});
var De = M((ad, Je)=>{
    "use strict";
    var Ff = z1(), j = ki, Ce = w, te = Q(), Of = Ff.assert;
    function O(d) {
        this.twisted = (d.a | 0) !== 1, this.mOneA = this.twisted && (d.a | 0) === -1, this.extended = this.mOneA, te.call(this, "edwards", d), this.a = new j(d.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new j(d.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new j(d.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Of(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (d.c | 0) === 1;
    }
    Ce(O, te);
    Je.exports = O;
    O.prototype._mulA = function(e) {
        return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    O.prototype._mulC = function(e) {
        return this.oneC ? e : this.c.redMul(e);
    };
    O.prototype.jpoint = function(e, f, r, a) {
        return this.point(e, f, r, a);
    };
    O.prototype.pointFromX = function(e, f) {
        e = new j(e, 16), e.red || (e = e.toRed(this.red));
        var r = e.redSqr(), a = this.c2.redSub(this.a.redMul(r)), c = this.one.redSub(this.c2.redMul(this.d).redMul(r)), b = a.redMul(c.redInvm()), t = b.redSqrt();
        if (t.redSqr().redSub(b).cmp(this.zero) !== 0) throw new Error("invalid point");
        var i = t.fromRed().isOdd();
        return (f && !i || !f && i) && (t = t.redNeg()), this.point(e, t);
    };
    O.prototype.pointFromY = function(e, f) {
        e = new j(e, 16), e.red || (e = e.toRed(this.red));
        var r = e.redSqr(), a = r.redSub(this.c2), c = r.redMul(this.d).redMul(this.c2).redSub(this.a), b = a.redMul(c.redInvm());
        if (b.cmp(this.zero) === 0) {
            if (f) throw new Error("invalid point");
            return this.point(this.zero, e);
        }
        var t = b.redSqrt();
        if (t.redSqr().redSub(b).cmp(this.zero) !== 0) throw new Error("invalid point");
        return t.fromRed().isOdd() !== f && (t = t.redNeg()), this.point(t, e);
    };
    O.prototype.validate = function(e) {
        if (e.isInfinity()) return !0;
        e.normalize();
        var f = e.x.redSqr(), r = e.y.redSqr(), a = f.redMul(this.a).redAdd(r), c = this.c2.redMul(this.one.redAdd(this.d.redMul(f).redMul(r)));
        return a.cmp(c) === 0;
    };
    function y(d, e, f, r, a) {
        te.BasePoint.call(this, d, "projective"), e === null && f === null && r === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new j(e, 16), this.y = new j(f, 16), this.z = r ? new j(r, 16) : this.curve.one, this.t = a && new j(a, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    Ce(y, te.BasePoint);
    O.prototype.pointFromJSON = function(e) {
        return y.fromJSON(this, e);
    };
    O.prototype.point = function(e, f, r, a) {
        return new y(this, e, f, r, a);
    };
    y.fromJSON = function(e, f) {
        return new y(e, f[0], f[1], f[2]);
    };
    y.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    y.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    y.prototype._extDbl = function() {
        var e = this.x.redSqr(), f = this.y.redSqr(), r = this.z.redSqr();
        r = r.redIAdd(r);
        var a = this.curve._mulA(e), c = this.x.redAdd(this.y).redSqr().redISub(e).redISub(f), b = a.redAdd(f), t = b.redSub(r), i = a.redSub(f), s = c.redMul(t), n = b.redMul(i), u = c.redMul(i), o = t.redMul(b);
        return this.curve.point(s, n, o, u);
    };
    y.prototype._projDbl = function() {
        var e = this.x.redAdd(this.y).redSqr(), f = this.x.redSqr(), r = this.y.redSqr(), a, c, b, t, i, s;
        if (this.curve.twisted) {
            t = this.curve._mulA(f);
            var n = t.redAdd(r);
            this.zOne ? (a = e.redSub(f).redSub(r).redMul(n.redSub(this.curve.two)), c = n.redMul(t.redSub(r)), b = n.redSqr().redSub(n).redSub(n)) : (i = this.z.redSqr(), s = n.redSub(i).redISub(i), a = e.redSub(f).redISub(r).redMul(s), c = n.redMul(t.redSub(r)), b = n.redMul(s));
        } else t = f.redAdd(r), i = this.curve._mulC(this.z).redSqr(), s = t.redSub(i).redSub(i), a = this.curve._mulC(e.redISub(t)).redMul(s), c = this.curve._mulC(t).redMul(f.redISub(r)), b = t.redMul(s);
        return this.curve.point(a, c, b);
    };
    y.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    y.prototype._extAdd = function(e) {
        var f = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), r = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), a = this.t.redMul(this.curve.dd).redMul(e.t), c = this.z.redMul(e.z.redAdd(e.z)), b = r.redSub(f), t = c.redSub(a), i = c.redAdd(a), s = r.redAdd(f), n = b.redMul(t), u = i.redMul(s), o = b.redMul(s), v = t.redMul(i);
        return this.curve.point(n, u, v, o);
    };
    y.prototype._projAdd = function(e) {
        var f = this.z.redMul(e.z), r = f.redSqr(), a = this.x.redMul(e.x), c = this.y.redMul(e.y), b = this.curve.d.redMul(a).redMul(c), t = r.redSub(b), i = r.redAdd(b), s = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(a).redISub(c), n = f.redMul(t).redMul(s), u, o;
        return this.curve.twisted ? (u = f.redMul(i).redMul(c.redSub(this.curve._mulA(a))), o = t.redMul(i)) : (u = f.redMul(i).redMul(c.redSub(a)), o = this.curve._mulC(t).redMul(i)), this.curve.point(n, u, o);
    };
    y.prototype.add = function(e) {
        return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    y.prototype.mul = function(e) {
        return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    y.prototype.mulAdd = function(e, f, r) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            e,
            r
        ], 2, !1);
    };
    y.prototype.jmulAdd = function(e, f, r) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            e,
            r
        ], 2, !0);
    };
    y.prototype.normalize = function() {
        if (this.zOne) return this;
        var e = this.z.redInvm();
        return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
    };
    y.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    y.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    };
    y.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
    };
    y.prototype.eq = function(e) {
        return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    y.prototype.eqXToP = function(e) {
        var f = e.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(f) === 0) return !0;
        for(var r = e.clone(), a = this.curve.redN.redMul(this.z);;){
            if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
            if (f.redIAdd(a), this.x.cmp(f) === 0) return !0;
        }
    };
    y.prototype.toP = y.prototype.normalize;
    y.prototype.mixedAdd = y.prototype.add;
});
var pe = M((Xe)=>{
    "use strict";
    var ce = Xe;
    ce.base = Q();
    ce.short = Fe();
    ce.mont = Le1();
    ce.edwards = De();
});
var Ye = M((cd, Te)=>{
    Te.exports = {
        doubles: {
            step: 4,
            points: [
                [
                    "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                    "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
                ],
                [
                    "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                    "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
                ],
                [
                    "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                    "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
                ],
                [
                    "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                    "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
                ],
                [
                    "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                    "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
                ],
                [
                    "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                    "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
                ],
                [
                    "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                    "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
                ],
                [
                    "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                    "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
                ],
                [
                    "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                    "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
                ],
                [
                    "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                    "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
                ],
                [
                    "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                    "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
                ],
                [
                    "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                    "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
                ],
                [
                    "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                    "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
                ],
                [
                    "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                    "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
                ],
                [
                    "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                    "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
                ],
                [
                    "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                    "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
                ],
                [
                    "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                    "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
                ],
                [
                    "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                    "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
                ],
                [
                    "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                    "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
                ],
                [
                    "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                    "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
                ],
                [
                    "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                    "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
                ],
                [
                    "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                    "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
                ],
                [
                    "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                    "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
                ],
                [
                    "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                    "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
                ],
                [
                    "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                    "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
                ],
                [
                    "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                    "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
                ],
                [
                    "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                    "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
                ],
                [
                    "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                    "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
                ],
                [
                    "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                    "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
                ],
                [
                    "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                    "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
                ],
                [
                    "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                    "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
                ],
                [
                    "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                    "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
                ],
                [
                    "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                    "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
                ],
                [
                    "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                    "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
                ],
                [
                    "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                    "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
                ],
                [
                    "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                    "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
                ],
                [
                    "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                    "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
                ],
                [
                    "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                    "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
                ],
                [
                    "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                    "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
                ],
                [
                    "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                    "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
                ],
                [
                    "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                    "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
                ],
                [
                    "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                    "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
                ],
                [
                    "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                    "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
                ],
                [
                    "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                    "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
                ],
                [
                    "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                    "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
                ],
                [
                    "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                    "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
                ],
                [
                    "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                    "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
                ],
                [
                    "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                    "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
                ],
                [
                    "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                    "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
                ],
                [
                    "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                    "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
                ],
                [
                    "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                    "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
                ],
                [
                    "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                    "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
                ],
                [
                    "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                    "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
                ],
                [
                    "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                    "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
                ],
                [
                    "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                    "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
                ],
                [
                    "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                    "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
                ],
                [
                    "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                    "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
                ],
                [
                    "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                    "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
                ],
                [
                    "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                    "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
                ],
                [
                    "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                    "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
                ],
                [
                    "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                    "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
                ],
                [
                    "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                    "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
                ],
                [
                    "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                    "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
                ],
                [
                    "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                    "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
                ],
                [
                    "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                    "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
                ]
            ]
        },
        naf: {
            wnd: 7,
            points: [
                [
                    "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                    "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
                ],
                [
                    "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                    "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
                ],
                [
                    "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                    "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
                ],
                [
                    "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                    "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
                ],
                [
                    "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                    "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
                ],
                [
                    "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                    "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
                ],
                [
                    "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                    "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
                ],
                [
                    "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                    "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
                ],
                [
                    "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                    "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
                ],
                [
                    "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                    "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
                ],
                [
                    "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                    "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
                ],
                [
                    "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                    "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
                ],
                [
                    "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                    "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
                ],
                [
                    "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                    "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
                ],
                [
                    "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                    "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
                ],
                [
                    "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                    "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
                ],
                [
                    "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                    "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
                ],
                [
                    "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                    "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
                ],
                [
                    "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                    "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
                ],
                [
                    "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                    "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
                ],
                [
                    "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                    "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
                ],
                [
                    "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                    "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
                ],
                [
                    "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                    "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
                ],
                [
                    "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                    "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
                ],
                [
                    "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                    "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
                ],
                [
                    "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                    "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
                ],
                [
                    "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                    "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
                ],
                [
                    "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                    "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
                ],
                [
                    "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                    "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
                ],
                [
                    "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                    "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
                ],
                [
                    "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                    "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
                ],
                [
                    "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                    "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
                ],
                [
                    "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                    "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
                ],
                [
                    "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                    "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
                ],
                [
                    "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                    "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
                ],
                [
                    "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                    "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
                ],
                [
                    "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                    "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
                ],
                [
                    "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                    "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
                ],
                [
                    "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                    "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
                ],
                [
                    "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                    "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
                ],
                [
                    "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                    "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
                ],
                [
                    "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                    "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
                ],
                [
                    "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                    "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
                ],
                [
                    "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                    "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
                ],
                [
                    "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                    "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
                ],
                [
                    "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                    "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
                ],
                [
                    "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                    "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
                ],
                [
                    "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                    "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
                ],
                [
                    "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                    "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
                ],
                [
                    "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                    "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
                ],
                [
                    "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                    "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
                ],
                [
                    "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                    "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
                ],
                [
                    "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                    "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
                ],
                [
                    "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                    "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
                ],
                [
                    "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                    "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
                ],
                [
                    "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                    "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
                ],
                [
                    "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                    "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
                ],
                [
                    "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                    "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
                ],
                [
                    "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                    "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
                ],
                [
                    "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                    "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
                ],
                [
                    "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                    "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
                ],
                [
                    "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                    "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
                ],
                [
                    "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                    "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
                ],
                [
                    "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                    "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
                ],
                [
                    "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                    "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
                ],
                [
                    "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                    "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
                ],
                [
                    "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                    "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
                ],
                [
                    "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                    "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
                ],
                [
                    "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                    "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
                ],
                [
                    "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                    "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
                ],
                [
                    "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                    "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
                ],
                [
                    "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                    "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
                ],
                [
                    "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                    "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
                ],
                [
                    "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                    "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
                ],
                [
                    "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                    "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
                ],
                [
                    "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                    "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
                ],
                [
                    "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                    "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
                ],
                [
                    "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                    "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
                ],
                [
                    "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                    "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
                ],
                [
                    "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                    "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
                ],
                [
                    "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                    "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
                ],
                [
                    "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                    "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
                ],
                [
                    "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                    "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
                ],
                [
                    "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                    "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
                ],
                [
                    "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                    "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
                ],
                [
                    "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                    "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
                ],
                [
                    "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                    "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
                ],
                [
                    "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                    "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
                ],
                [
                    "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                    "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
                ],
                [
                    "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                    "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
                ],
                [
                    "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                    "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
                ],
                [
                    "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                    "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
                ],
                [
                    "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                    "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
                ],
                [
                    "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                    "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
                ],
                [
                    "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                    "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
                ],
                [
                    "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                    "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
                ],
                [
                    "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                    "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
                ],
                [
                    "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                    "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
                ],
                [
                    "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                    "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
                ],
                [
                    "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                    "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
                ],
                [
                    "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                    "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
                ],
                [
                    "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                    "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
                ],
                [
                    "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                    "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
                ],
                [
                    "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                    "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
                ],
                [
                    "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                    "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
                ],
                [
                    "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                    "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
                ],
                [
                    "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                    "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
                ],
                [
                    "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                    "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
                ],
                [
                    "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                    "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
                ],
                [
                    "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                    "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
                ],
                [
                    "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                    "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
                ],
                [
                    "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                    "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
                ],
                [
                    "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                    "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
                ],
                [
                    "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                    "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
                ],
                [
                    "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                    "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
                ],
                [
                    "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                    "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
                ],
                [
                    "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                    "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
                ],
                [
                    "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                    "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
                ],
                [
                    "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                    "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
                ],
                [
                    "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                    "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
                ],
                [
                    "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                    "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
                ],
                [
                    "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                    "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
                ],
                [
                    "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                    "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
                ],
                [
                    "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                    "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
                ],
                [
                    "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                    "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
                ],
                [
                    "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                    "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
                ],
                [
                    "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                    "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
                ]
            ]
        }
    };
});
var be = M((ke)=>{
    "use strict";
    var me = ke, C = Qe, ye = pe(), jf = z1(), Ke = jf.assert;
    function We(d) {
        d.type === "short" ? this.curve = new ye.short(d) : d.type === "edwards" ? this.curve = new ye.edwards(d) : this.curve = new ye.mont(d), this.g = this.curve.g, this.n = this.curve.n, this.hash = d.hash, Ke(this.g.validate(), "Invalid curve"), Ke(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    me.PresetCurve = We;
    function J(d, e) {
        Object.defineProperty(me, d, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                var f = new We(e);
                return Object.defineProperty(me, d, {
                    configurable: !0,
                    enumerable: !0,
                    value: f
                }), f;
            }
        });
    }
    J("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: C.sha256,
        gRed: !1,
        g: [
            "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
            "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
    });
    J("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: C.sha256,
        gRed: !1,
        g: [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
            "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
    });
    J("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: C.sha256,
        gRed: !1,
        g: [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
    });
    J("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: C.sha384,
        gRed: !1,
        g: [
            "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
            "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
    });
    J("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: C.sha512,
        gRed: !1,
        g: [
            "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
            "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
    });
    J("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: C.sha256,
        gRed: !1,
        g: [
            "9"
        ]
    });
    J("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: C.sha256,
        gRed: !1,
        g: [
            "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
            "6666666666666666666666666666666666666666666666666666666666666658"
        ]
    });
    var Se;
    try {
        Se = Ye();
    } catch  {
        Se = void 0;
    }
    J("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: C.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
            {
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }
        ],
        gRed: !1,
        g: [
            "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
            Se
        ]
    });
});
var Ue = M((id, He)=>{
    "use strict";
    var Lf = ki, Cf = z1(), ge = Cf.assert;
    function q(d, e) {
        this.ec = d, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    He.exports = q;
    q.fromPublic = function(e, f, r) {
        return f instanceof q ? f : new q(e, {
            pub: f,
            pubEnc: r
        });
    };
    q.fromPrivate = function(e, f, r) {
        return f instanceof q ? f : new q(e, {
            priv: f,
            privEnc: r
        });
    };
    q.prototype.validate = function() {
        var e = this.getPublic();
        return e.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        };
    };
    q.prototype.getPublic = function(e, f) {
        return typeof e == "string" && (f = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), f ? this.pub.encode(f, e) : this.pub;
    };
    q.prototype.getPrivate = function(e) {
        return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    q.prototype._importPrivate = function(e, f) {
        this.priv = new Lf(e, f || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    q.prototype._importPublic = function(e, f) {
        if (e.x || e.y) {
            this.ec.curve.type === "mont" ? ge(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ge(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(e, f);
    };
    q.prototype.derive = function(e) {
        return e.validate() || ge(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    q.prototype.sign = function(e, f, r) {
        return this.ec.sign(e, this, f, r);
    };
    q.prototype.verify = function(e, f) {
        return this.ec.verify(e, f, this);
    };
    q.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
});
var Ve = M((nd, Ge)=>{
    "use strict";
    var ie = ki, Ie = z1(), Jf = Ie.assert;
    function ne(d, e) {
        if (d instanceof ne) return d;
        this._importDER(d, e) || (Jf(d.r && d.s, "Signature without r or s"), this.r = new ie(d.r, 16), this.s = new ie(d.s, 16), d.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = d.recoveryParam);
    }
    Ge.exports = ne;
    function Df() {
        this.place = 0;
    }
    function Ae(d, e) {
        var f = d[e.place++];
        if (!(f & 128)) return f;
        var r = f & 15;
        if (r === 0 || r > 4) return !1;
        for(var a = 0, c = 0, b = e.place; c < r; c++, b++)a <<= 8, a |= d[b], a >>>= 0;
        return a <= 127 ? !1 : (e.place = b, a);
    }
    function $e(d) {
        for(var e = 0, f = d.length - 1; !d[e] && !(d[e + 1] & 128) && e < f;)e++;
        return e === 0 ? d : d.slice(e);
    }
    ne.prototype._importDER = function(e, f) {
        e = Ie.toArray(e, f);
        var r = new Df;
        if (e[r.place++] !== 48) return !1;
        var a = Ae(e, r);
        if (a === !1 || a + r.place !== e.length || e[r.place++] !== 2) return !1;
        var c = Ae(e, r);
        if (c === !1) return !1;
        var b = e.slice(r.place, c + r.place);
        if (r.place += c, e[r.place++] !== 2) return !1;
        var t = Ae(e, r);
        if (t === !1 || e.length !== t + r.place) return !1;
        var i = e.slice(r.place, t + r.place);
        if (b[0] === 0) if (b[1] & 128) b = b.slice(1);
        else return !1;
        if (i[0] === 0) if (i[1] & 128) i = i.slice(1);
        else return !1;
        return this.r = new ie(b), this.s = new ie(i), this.recoveryParam = null, !0;
    };
    function xe(d, e) {
        if (e < 128) {
            d.push(e);
            return;
        }
        var f = 1 + (Math.log(e) / Math.LN2 >>> 3);
        for(d.push(f | 128); --f;)d.push(e >>> (f << 3) & 255);
        d.push(e);
    }
    ne.prototype.toDER = function(e) {
        var f = this.r.toArray(), r = this.s.toArray();
        for(f[0] & 128 && (f = [
            0
        ].concat(f)), r[0] & 128 && (r = [
            0
        ].concat(r)), f = $e(f), r = $e(r); !r[0] && !(r[1] & 128);)r = r.slice(1);
        var a = [
            2
        ];
        xe(a, f.length), a = a.concat(f), a.push(2), xe(a, r.length);
        var c = a.concat(r), b = [
            48
        ];
        return xe(b, c.length), b = b.concat(c), Ie.encode(b, e);
    };
});
var ff = M((sd, ef)=>{
    "use strict";
    var T = ki, Ze = I1, Xf = z1(), we = be(), Tf = C, Qe = Xf.assert, Me = Ue(), se = Ve();
    function E(d) {
        if (!(this instanceof E)) return new E(d);
        typeof d == "string" && (Qe(Object.prototype.hasOwnProperty.call(we, d), "Unknown curve " + d), d = we[d]), d instanceof we.PresetCurve && (d = {
            curve: d
        }), this.curve = d.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = d.curve.g, this.g.precompute(d.curve.n.bitLength() + 1), this.hash = d.hash || d.curve.hash;
    }
    ef.exports = E;
    E.prototype.keyPair = function(e) {
        return new Me(this, e);
    };
    E.prototype.keyFromPrivate = function(e, f) {
        return Me.fromPrivate(this, e, f);
    };
    E.prototype.keyFromPublic = function(e, f) {
        return Me.fromPublic(this, e, f);
    };
    E.prototype.genKeyPair = function(e) {
        e || (e = {});
        for(var f = new Ze({
            hash: this.hash,
            pers: e.pers,
            persEnc: e.persEnc || "utf8",
            entropy: e.entropy || Tf(this.hash.hmacStrength),
            entropyEnc: e.entropy && e.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), r = this.n.byteLength(), a = this.n.sub(new T(2));;){
            var c = new T(f.generate(r));
            if (!(c.cmp(a) > 0)) return c.iaddn(1), this.keyFromPrivate(c);
        }
    };
    E.prototype._truncateToN = function(e, f) {
        var r = e.byteLength() * 8 - this.n.bitLength();
        return r > 0 && (e = e.ushrn(r)), !f && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    E.prototype.sign = function(e, f, r, a) {
        typeof r == "object" && (a = r, r = null), a || (a = {}), f = this.keyFromPrivate(f, r), e = this._truncateToN(new T(e, 16));
        for(var c = this.n.byteLength(), b = f.getPrivate().toArray("be", c), t = e.toArray("be", c), i = new Ze({
            hash: this.hash,
            entropy: b,
            nonce: t,
            pers: a.pers,
            persEnc: a.persEnc || "utf8"
        }), s = this.n.sub(new T(1)), n = 0;; n++){
            var u = a.k ? a.k(n) : new T(i.generate(this.n.byteLength()));
            if (u = this._truncateToN(u, !0), !(u.cmpn(1) <= 0 || u.cmp(s) >= 0)) {
                var o = this.g.mul(u);
                if (!o.isInfinity()) {
                    var v = o.getX(), h = v.umod(this.n);
                    if (h.cmpn(0) !== 0) {
                        var l = u.invm(this.n).mul(h.mul(f.getPrivate()).iadd(e));
                        if (l = l.umod(this.n), l.cmpn(0) !== 0) {
                            var S = (o.getY().isOdd() ? 1 : 0) | (v.cmp(h) !== 0 ? 2 : 0);
                            return a.canonical && l.cmp(this.nh) > 0 && (l = this.n.sub(l), S ^= 1), new se({
                                r: h,
                                s: l,
                                recoveryParam: S
                            });
                        }
                    }
                }
            }
        }
    };
    E.prototype.verify = function(e, f, r, a) {
        e = this._truncateToN(new T(e, 16)), r = this.keyFromPublic(r, a), f = new se(f, "hex");
        var c = f.r, b = f.s;
        if (c.cmpn(1) < 0 || c.cmp(this.n) >= 0 || b.cmpn(1) < 0 || b.cmp(this.n) >= 0) return !1;
        var t = b.invm(this.n), i = t.mul(e).umod(this.n), s = t.mul(c).umod(this.n), n;
        return this.curve._maxwellTrick ? (n = this.g.jmulAdd(i, r.getPublic(), s), n.isInfinity() ? !1 : n.eqXToP(c)) : (n = this.g.mulAdd(i, r.getPublic(), s), n.isInfinity() ? !1 : n.getX().umod(this.n).cmp(c) === 0);
    };
    E.prototype.recoverPubKey = function(d, e, f, r) {
        Qe((3 & f) === f, "The recovery param is more than two bits"), e = new se(e, r);
        var a = this.n, c = new T(d), b = e.r, t = e.s, i = f & 1, s = f >> 1;
        if (b.cmp(this.curve.p.umod(this.curve.n)) >= 0 && s) throw new Error("Unable to find sencond key candinate");
        s ? b = this.curve.pointFromX(b.add(this.curve.n), i) : b = this.curve.pointFromX(b, i);
        var n = e.r.invm(a), u = a.sub(c).mul(n).umod(a), o = t.mul(n).umod(a);
        return this.g.mulAdd(u, b, o);
    };
    E.prototype.getKeyRecoveryParam = function(d, e, f, r) {
        if (e = new se(e, r), e.recoveryParam !== null) return e.recoveryParam;
        for(var a = 0; a < 4; a++){
            var c;
            try {
                c = this.recoverPubKey(d, e, a);
            } catch  {
                continue;
            }
            if (c.eq(f)) return a;
        }
        throw new Error("Unable to find valid recovery factor");
    };
});
var tf = M((ud, af)=>{
    "use strict";
    var ee = z1(), rf = ee.assert, df = ee.parseBytes, U = ee.cachedProperty;
    function I(d, e) {
        this.eddsa = d, this._secret = df(e.secret), d.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = df(e.pub);
    }
    I.fromPublic = function(e, f) {
        return f instanceof I ? f : new I(e, {
            pub: f
        });
    };
    I.fromSecret = function(e, f) {
        return f instanceof I ? f : new I(e, {
            secret: f
        });
    };
    I.prototype.secret = function() {
        return this._secret;
    };
    U(I, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
    });
    U(I, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    U(I, "privBytes", function() {
        var e = this.eddsa, f = this.hash(), r = e.encodingLength - 1, a = f.slice(0, e.encodingLength);
        return a[0] &= 248, a[r] &= 127, a[r] |= 64, a;
    });
    U(I, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
    });
    U(I, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
    });
    U(I, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
    });
    I.prototype.sign = function(e) {
        return rf(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    I.prototype.verify = function(e, f) {
        return this.eddsa.verify(e, f, this);
    };
    I.prototype.getSecret = function(e) {
        return rf(this._secret, "KeyPair is public only"), ee.encode(this.secret(), e);
    };
    I.prototype.getPublic = function(e) {
        return ee.encode(this.pubBytes(), e);
    };
    af.exports = I;
});
var bf = M((od, cf)=>{
    "use strict";
    var Yf = ki, ue = z1(), Kf = ue.assert, oe = ue.cachedProperty, Wf = ue.parseBytes;
    function Y(d, e) {
        this.eddsa = d, typeof e != "object" && (e = Wf(e)), Array.isArray(e) && (e = {
            R: e.slice(0, d.encodingLength),
            S: e.slice(d.encodingLength)
        }), Kf(e.R && e.S, "Signature without R or S"), d.isPoint(e.R) && (this._R = e.R), e.S instanceof Yf && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    oe(Y, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
    });
    oe(Y, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
    });
    oe(Y, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
    });
    oe(Y, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
    });
    Y.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
    };
    Y.prototype.toHex = function() {
        return ue.encode(this.toBytes(), "hex").toUpperCase();
    };
    cf.exports = Y;
});
var hf = M((hd, of)=>{
    "use strict";
    var kf = Qe, Hf = be(), $ = z1(), Uf = $.assert, sf = $.parseBytes, uf = tf(), nf = bf();
    function _(d) {
        if (Uf(d === "ed25519", "only tested with ed25519 so far"), !(this instanceof _)) return new _(d);
        d = Hf[d].curve, this.curve = d, this.g = d.g, this.g.precompute(d.n.bitLength() + 1), this.pointClass = d.point().constructor, this.encodingLength = Math.ceil(d.n.bitLength() / 8), this.hash = kf.sha512;
    }
    of.exports = _;
    _.prototype.sign = function(e, f) {
        e = sf(e);
        var r = this.keyFromSecret(f), a = this.hashInt(r.messagePrefix(), e), c = this.g.mul(a), b = this.encodePoint(c), t = this.hashInt(b, r.pubBytes(), e).mul(r.priv()), i = a.add(t).umod(this.curve.n);
        return this.makeSignature({
            R: c,
            S: i,
            Rencoded: b
        });
    };
    _.prototype.verify = function(e, f, r) {
        e = sf(e), f = this.makeSignature(f);
        var a = this.keyFromPublic(r), c = this.hashInt(f.Rencoded(), a.pubBytes(), e), b = this.g.mul(f.S()), t = f.R().add(a.pub().mul(c));
        return t.eq(b);
    };
    _.prototype.hashInt = function() {
        for(var e = this.hash(), f = 0; f < arguments.length; f++)e.update(arguments[f]);
        return $.intFromLE(e.digest()).umod(this.curve.n);
    };
    _.prototype.keyFromPublic = function(e) {
        return uf.fromPublic(this, e);
    };
    _.prototype.keyFromSecret = function(e) {
        return uf.fromSecret(this, e);
    };
    _.prototype.makeSignature = function(e) {
        return e instanceof nf ? e : new nf(this, e);
    };
    _.prototype.encodePoint = function(e) {
        var f = e.getY().toArray("le", this.encodingLength);
        return f[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, f;
    };
    _.prototype.decodePoint = function(e) {
        e = $.parseBytes(e);
        var f = e.length - 1, r = e.slice(0, f).concat(e[f] & -129), a = (e[f] & 128) !== 0, c = $.intFromLE(r);
        return this.curve.pointFromY(c, a);
    };
    _.prototype.encodeInt = function(e) {
        return e.toArray("le", this.encodingLength);
    };
    _.prototype.decodeInt = function(e) {
        return $.intFromLE(e);
    };
    _.prototype.isPoint = function(e) {
        return e instanceof this.pointClass;
    };
});
var qe = M((vf)=>{
    "use strict";
    var K = vf;
    K.version = Re().version;
    K.utils = z1();
    K.rand = C;
    K.curve = pe();
    K.curves = be();
    K.ec = ff();
    K.eddsa = hf();
});
var lf = ze(qe()), $f = ze(qe()), { default: Gf , ...Vf } = $f, ld = (lf.default ?? Gf) ?? Vf;
var v2 = Object.create;
var y3 = Object.defineProperty;
var g4 = Object.getOwnPropertyDescriptor;
var m3 = Object.getOwnPropertyNames;
var l4 = Object.getPrototypeOf, P = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (t, r)=>(typeof require != "undefined" ? require : t)[r]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var B1 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var b2 = (e, t, r, u)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let s of m3(t))!P.call(e, s) && s !== r && y3(e, s, {
        get: ()=>t[s],
        enumerable: !(u = g4(t, s)) || u.enumerable
    });
    return e;
};
var o1 = (e, t, r)=>(r = e != null ? v2(l4(e)) : {}, b2(t || !e || !e.__esModule ? y3(r, "default", {
        value: e,
        enumerable: !0
    }) : r, e));
var p5 = B1(($, c)=>{
    var k = ld, d = ki;
    c.exports = function(t) {
        return new f(t);
    };
    var i = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    i.p224 = i.secp224r1;
    i.p256 = i.secp256r1 = i.prime256v1;
    i.p192 = i.secp192r1 = i.prime192v1;
    i.p384 = i.secp384r1;
    i.p521 = i.secp521r1;
    function f(e) {
        this.curveType = i[e], this.curveType || (this.curveType = {
            name: e
        }), this.curve = new k.ec(this.curveType.name), this.keys = void 0;
    }
    f.prototype.generateKeys = function(e, t) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(e, t);
    };
    f.prototype.computeSecret = function(e, t, r) {
        t = t || "utf8", Buffer.isBuffer(e) || (e = new Buffer(e, t));
        var u = this.curve.keyFromPublic(e).getPublic(), s = u.mul(this.keys.getPrivate()).getX();
        return n(s, r, this.curveType.byteLength);
    };
    f.prototype.getPublicKey = function(e, t) {
        var r = this.keys.getPublic(t === "compressed", !0);
        return t === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), n(r, e);
    };
    f.prototype.getPrivateKey = function(e) {
        return n(this.keys.getPrivate(), e);
    };
    f.prototype.setPublicKey = function(e, t) {
        return t = t || "utf8", Buffer.isBuffer(e) || (e = new Buffer(e, t)), this.keys._importPublic(e), this;
    };
    f.prototype.setPrivateKey = function(e, t) {
        t = t || "utf8", Buffer.isBuffer(e) || (e = new Buffer(e, t));
        var r = new d(e);
        return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function n(e, t, r) {
        Array.isArray(e) || (e = e.toArray());
        var u = new Buffer(e);
        if (r && u.length < r) {
            var s = new Buffer(r - u.length);
            s.fill(0), u = Buffer.concat([
                s,
                u
            ]);
        }
        return t ? u.toString(t) : u;
    }
});
var h3 = o1(p5()), w3 = o1(p5()), { default: K3 , ...L } = w3, A3 = (h3.default ?? K3) ?? L;
var y4 = Object.create;
var p6 = Object.defineProperty;
var B2 = Object.getOwnPropertyDescriptor;
var S1 = Object.getOwnPropertyNames;
var d4 = Object.getPrototypeOf, g5 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var E2 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var T = (e, r, t, f)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let u of S1(r))!g5.call(e, u) && u !== t && p6(e, u, {
        get: ()=>r[u],
        enumerable: !(f = B2(r, u)) || f.enumerable
    });
    return e;
};
var b3 = (e, r, t)=>(t = e != null ? y4(d4(e)) : {}, T(r || !e || !e.__esModule ? p6(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var m4 = E2((l, s)=>{
    var a = export_default, o = a.Buffer;
    function c(e, r) {
        for(var t in e)r[t] = e[t];
    }
    o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? s.exports = a : (c(a, l), l.Buffer = n);
    function n(e, r, t) {
        return o(e, r, t);
    }
    n.prototype = Object.create(o.prototype);
    c(o, n);
    n.from = function(e, r, t) {
        if (typeof e == "number") throw new TypeError("Argument must not be a number");
        return o(e, r, t);
    };
    n.alloc = function(e, r, t) {
        if (typeof e != "number") throw new TypeError("Argument must be a number");
        var f = o(e);
        return r !== void 0 ? typeof t == "string" ? f.fill(r, t) : f.fill(r) : f.fill(0), f;
    };
    n.allocUnsafe = function(e) {
        if (typeof e != "number") throw new TypeError("Argument must be a number");
        return o(e);
    };
    n.allocUnsafeSlow = function(e) {
        if (typeof e != "number") throw new TypeError("Argument must be a number");
        return a.SlowBuffer(e);
    };
});
var i4 = b3(m4()), w4 = b3(m4()), { Blob: U , resolveObjectURL: $3 , Buffer: L1 , SlowBuffer: M1 , transcode: j1 , kMaxLength: O , kStringMaxLength: P1 , btoa: _2 , atob: k1 , constants: q3 , INSPECT_MAX_BYTES: C1  } = w4, { default: v3 , ...x5 } = w4, I2 = (i4.default ?? v3) ?? x5;
function addSignalListener(...args) {
    if (typeof Deno.addSignalListener == "function") {
        return Deno.addSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function removeSignalListener(...args) {
    if (typeof Deno.removeSignalListener == "function") {
        return Deno.removeSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function setRaw(...args) {
    if (typeof Deno.setRaw == "function") {
        return Deno.setRaw(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
async function connect(options) {
    return await Deno.connect(options);
}
function listen(options) {
    return Deno.listen(options);
}
function listenDatagram(options) {
    return Deno.listenDatagram(options);
}
function ListenerRef(listener, ...args) {
    if (typeof listener.ref == "function") {
        return listener.ref(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function ListenerUnref(listener, ...args) {
    if (typeof listener.unref == "function") {
        return listener.unref(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join1(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod15 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join1,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join2(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format2(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse2(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod16 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join2,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format2,
    parse: parse2,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod15 : mod16;
const { join: join3 , normalize: normalize2  } = path;
const path1 = isWindows ? mod15 : mod16;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format3 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join4 , normalize: normalize3 , parse: parse3 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function createWritableStdioStream(writer, name) {
    const stream = new Writable({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close"));
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close());
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : undefined
        }
    });
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Readable({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p = Buffer.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p).then((length)=>{
            this.push(length === null ? null : p.slice(0, length));
        }, (error)=>{
            this.destroy(error);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    setRaw?.(Deno.stdin?.rid, enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants1;
(function(constants) {
    constants[constants["kInit"] = 0] = "kInit";
    constants[constants["kBefore"] = 1] = "kBefore";
    constants[constants["kAfter"] = 2] = "kAfter";
    constants[constants["kDestroy"] = 3] = "kDestroy";
    constants[constants["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants[constants["kTotals"] = 5] = "kTotals";
    constants[constants["kCheck"] = 6] = "kCheck";
    constants[constants["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants[constants["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants[constants["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants[constants["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants[constants["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants[constants["kStackLength"] = 12] = "kStackLength";
})(constants1 || (constants1 = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants1).length);
function newAsyncId() {
    return ++asyncIdFields[constants1.kAsyncIdCounter];
}
var UidFields;
(function(UidFields) {
    UidFields[UidFields["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields[UidFields["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields[UidFields["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields[UidFields["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields[UidFields["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType) {
    providerType[providerType["NONE"] = 0] = "NONE";
    providerType[providerType["DIRHANDLE"] = 1] = "DIRHANDLE";
    providerType[providerType["DNSCHANNEL"] = 2] = "DNSCHANNEL";
    providerType[providerType["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
    providerType[providerType["FILEHANDLE"] = 4] = "FILEHANDLE";
    providerType[providerType["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
    providerType[providerType["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
    providerType[providerType["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
    providerType[providerType["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
    providerType[providerType["FSREQPROMISE"] = 9] = "FSREQPROMISE";
    providerType[providerType["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
    providerType[providerType["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
    providerType[providerType["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
    providerType[providerType["HTTP2SESSION"] = 13] = "HTTP2SESSION";
    providerType[providerType["HTTP2STREAM"] = 14] = "HTTP2STREAM";
    providerType[providerType["HTTP2PING"] = 15] = "HTTP2PING";
    providerType[providerType["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
    providerType[providerType["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
    providerType[providerType["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
    providerType[providerType["JSSTREAM"] = 19] = "JSSTREAM";
    providerType[providerType["JSUDPWRAP"] = 20] = "JSUDPWRAP";
    providerType[providerType["MESSAGEPORT"] = 21] = "MESSAGEPORT";
    providerType[providerType["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
    providerType[providerType["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
    providerType[providerType["PIPEWRAP"] = 24] = "PIPEWRAP";
    providerType[providerType["PROCESSWRAP"] = 25] = "PROCESSWRAP";
    providerType[providerType["PROMISE"] = 26] = "PROMISE";
    providerType[providerType["QUERYWRAP"] = 27] = "QUERYWRAP";
    providerType[providerType["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
    providerType[providerType["SIGNALWRAP"] = 29] = "SIGNALWRAP";
    providerType[providerType["STATWATCHER"] = 30] = "STATWATCHER";
    providerType[providerType["STREAMPIPE"] = 31] = "STREAMPIPE";
    providerType[providerType["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
    providerType[providerType["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
    providerType[providerType["TCPWRAP"] = 34] = "TCPWRAP";
    providerType[providerType["TTYWRAP"] = 35] = "TTYWRAP";
    providerType[providerType["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
    providerType[providerType["UDPWRAP"] = 37] = "UDPWRAP";
    providerType[providerType["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
    providerType[providerType["WORKER"] = 39] = "WORKER";
    providerType[providerType["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
    providerType[providerType["WRITEWRAP"] = 41] = "WRITEWRAP";
    providerType[providerType["ZLIB"] = 42] = "ZLIB";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod17 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants1,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod18 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
function ares_strerror(code) {
    const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled", 
    ];
    if (code >= 0 && code < errorText.length) {
        return errorText[code];
    } else {
        return "unknown";
    }
}
class GetAddrInfoReqWrap extends AsyncWrap {
    family;
    hostname;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname, family, _hints, verbatim) {
    let addresses = [];
    const recordTypes = [];
    if (family === 0 || family === 4) {
        recordTypes.push("A");
    }
    if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
    }
    (async ()=>{
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record));
            })));
        const error = addresses.length ? 0 : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (isWindows && hostname === "localhost") {
            addresses = addresses.filter((address)=>isIPv4(address));
        }
        req.oncomplete(error, addresses);
    })();
    return 0;
}
class QueryReqWrap extends AsyncWrap {
    bindingName;
    hostname;
    ttl;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.QUERYWRAP);
    }
}
function fqdnToHostname(fqdn) {
    return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
    const formatted = address.replace(/\b(?:0+:){2,}/, ":");
    const finalAddress = formatted.split(":").map((octet)=>{
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
    }).join(":");
    return finalAddress;
}
class ChannelWrap extends AsyncWrap {
    #servers = [];
    #timeout;
    #tries;
    constructor(timeout, tries){
        super(providerType.DNSCHANNEL);
        this.#timeout = timeout;
        this.#tries = tries;
    }
    async #query(query, recordType) {
        let code1;
        let ret;
        if (this.#servers.length) {
            for (const [ipAddr, port] of this.#servers){
                const resolveOptions = {
                    nameServer: {
                        ipAddr,
                        port
                    }
                };
                ({ code: code1 , ret  } = await this.#resolve(query, recordType, resolveOptions));
                if (code1 === 0 || code1 === codeMap.get("EAI_NODATA")) {
                    break;
                }
            }
        } else {
            ({ code: code1 , ret  } = await this.#resolve(query, recordType));
        }
        return {
            code: code1,
            ret: ret
        };
    }
    async #resolve(query1, recordType1, resolveOptions1) {
        let ret1 = [];
        let code11 = 0;
        try {
            ret1 = await Deno.resolveDns(query1, recordType1, resolveOptions1);
        } catch (e1) {
            if (e1 instanceof Deno.errors.NotFound) {
                code11 = codeMap.get("EAI_NODATA");
            } else {
                code11 = codeMap.get("UNKNOWN");
            }
        }
        return {
            code: code11,
            ret: ret1
        };
    }
    queryAny(req, name) {
        (async ()=>{
            const records = [];
            await Promise.allSettled([
                this.#query(name, "A").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "A",
                            address: record
                        }));
                }),
                this.#query(name, "AAAA").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "AAAA",
                            address: compressIPv6(record)
                        }));
                }),
                this.#query(name, "CAA").then(({ ret  })=>{
                    ret.forEach(({ critical , tag , value  })=>records.push({
                            type: "CAA",
                            [tag]: value,
                            critical: +critical && 128
                        }));
                }),
                this.#query(name, "CNAME").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "CNAME",
                            value: record
                        }));
                }),
                this.#query(name, "MX").then(({ ret  })=>{
                    ret.forEach(({ preference , exchange  })=>records.push({
                            type: "MX",
                            priority: preference,
                            exchange: fqdnToHostname(exchange)
                        }));
                }),
                this.#query(name, "NAPTR").then(({ ret  })=>{
                    ret.forEach(({ order , preference , flags , services , regexp , replacement  })=>records.push({
                            type: "NAPTR",
                            order,
                            preference,
                            flags,
                            service: services,
                            regexp,
                            replacement
                        }));
                }),
                this.#query(name, "NS").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "NS",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "PTR").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "PTR",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "SOA").then(({ ret  })=>{
                    ret.forEach(({ mname , rname , serial , refresh , retry , expire , minimum  })=>records.push({
                            type: "SOA",
                            nsname: fqdnToHostname(mname),
                            hostmaster: fqdnToHostname(rname),
                            serial,
                            refresh,
                            retry,
                            expire,
                            minttl: minimum
                        }));
                }),
                this.#query(name, "SRV").then(({ ret  })=>{
                    ret.forEach(({ priority , weight , port , target  })=>records.push({
                            type: "SRV",
                            priority,
                            weight,
                            port,
                            name: target
                        }));
                }),
                this.#query(name, "TXT").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "TXT",
                            entries: record
                        }));
                }), 
            ]);
            const err = records.length ? 0 : codeMap.get("EAI_NODATA");
            req.oncomplete(err, records);
        })();
        return 0;
    }
    queryA(req, name) {
        this.#query(name, "A").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryAaaa(req, name) {
        this.#query(name, "AAAA").then(({ code , ret  })=>{
            const records = ret.map((record)=>compressIPv6(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCaa(req, name) {
        this.#query(name, "CAA").then(({ code , ret  })=>{
            const records = ret.map(({ critical , tag , value  })=>({
                    [tag]: value,
                    critical: +critical && 128
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCname(req, name) {
        this.#query(name, "CNAME").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryMx(req, name) {
        this.#query(name, "MX").then(({ code , ret  })=>{
            const records = ret.map(({ preference , exchange  })=>({
                    priority: preference,
                    exchange: fqdnToHostname(exchange)
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNaptr(req, name) {
        this.#query(name, "NAPTR").then(({ code , ret  })=>{
            const records = ret.map(({ order , preference , flags , services , regexp , replacement  })=>({
                    flags,
                    service: services,
                    regexp,
                    replacement,
                    order,
                    preference
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNs(req, name) {
        this.#query(name, "NS").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryPtr(req, name) {
        this.#query(name, "PTR").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    querySoa(req, name) {
        this.#query(name, "SOA").then(({ code , ret  })=>{
            let record = {};
            if (ret.length) {
                const { mname , rname , serial , refresh , retry , expire , minimum  } = ret[0];
                record = {
                    nsname: fqdnToHostname(mname),
                    hostmaster: fqdnToHostname(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum
                };
            }
            req.oncomplete(code, record);
        });
        return 0;
    }
    querySrv(req, name) {
        this.#query(name, "SRV").then(({ code , ret  })=>{
            const records = ret.map(({ priority , weight , port , target  })=>({
                    priority,
                    weight,
                    port,
                    name: target
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryTxt(req, name) {
        this.#query(name, "TXT").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    getHostByAddr(_req, _name) {
        notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
    }
    getServers() {
        return this.#servers;
    }
    setServers(servers) {
        if (typeof servers === "string") {
            const tuples = [];
            for(let i = 0; i < servers.length; i += 2){
                tuples.push([
                    servers[i],
                    parseInt(servers[i + 1])
                ]);
            }
            this.#servers = tuples;
        } else {
            this.#servers = servers.map(([_ipVersion, ip, port])=>[
                    ip,
                    port
                ]);
        }
        return 0;
    }
    setLocalAddress(_addr0, _addr1) {
        notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
    }
    cancel() {
        notImplemented("cares.ChannelWrap.prototype.cancel");
    }
}
const DNS_ESETSRVPENDING = -1000;
const EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code) {
    return code === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code);
}
const mod19 = {
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo,
    QueryReqWrap: QueryReqWrap,
    ChannelWrap: ChannelWrap,
    strerror: strerror
};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
const mod29 = {};
const mod30 = {};
const mod31 = {};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    close(cb = ()=>{}) {
        this._onClose();
        cb();
    }
    ref() {
        unreachable();
    }
    unref() {
        unreachable();
    }
    _onClose() {}
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert1(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr1 = await this.#rd.read(p);
                const nread = rr1 ?? 0;
                assert1(nread >= 0, "negative read");
                return rr1;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert1(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert1(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert1(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
var StreamBaseStateFields;
(function(StreamBaseStateFields) {
    StreamBaseStateFields[StreamBaseStateFields["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields[StreamBaseStateFields["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields[StreamBaseStateFields["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields[StreamBaseStateFields["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields[StreamBaseStateFields["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            this.#read();
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        const status = this._onClose();
        try {
            req.oncomplete(status);
        } catch  {}
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
    }
    writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
    }
    writev(req, chunks, allBuffers) {
        const count = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count);
        if (!allBuffers) {
            for(let i = 0; i < count; i++){
                const chunk = chunks[i * 2];
                if (Buffer.isBuffer(chunk)) {
                    buffers[i] = chunk;
                }
                const encoding = chunks[i * 2 + 1];
                buffers[i] = Buffer.from(chunk, encoding);
            }
        } else {
            for(let i1 = 0; i1 < count; i1++){
                buffers[i1] = chunks[i1];
            }
        }
        return this.writeBuffer(req, Buffer.concat(buffers));
    }
    writeAsciiString(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
    }
    writeLatin1String(req, data) {
        const buffer = Buffer.from(data, "latin1");
        return this.writeBuffer(req, buffer);
    }
    _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        return status;
    }
     #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e2) {
            if (e2 instanceof Deno.errors.Interrupted || e2 instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else if (e2 instanceof Deno.errors.ConnectionReset || e2 instanceof Deno.errors.ConnectionAborted) {
                nread = codeMap.get("ECONNRESET");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            this.#read();
        }
    }
    async #write(req, data) {
        const { byteLength: byteLength1  } = data;
        try {
            await writeAll(this[kStreamBaseField], data);
        } catch (e11) {
            let status;
            if (e11 instanceof Deno.errors.BadResource || e11 instanceof Deno.errors.BrokenPipe) {
                status = codeMap.get("EBADF");
            } else {
                status = codeMap.get("UNKNOWN");
            }
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength1;
        this.bytesWritten += byteLength1;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod37 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req.oncomplete(status, this, req, readable, writable);
        } catch  {}
        return;
    }
}
function ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
var socketType;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
    socketType[socketType["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    #pendingInstances = 4;
    #address;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        let ipc;
        switch(type){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        this.ipc = ipc;
        if (conn && provider === providerType.PIPEWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.path;
        }
    }
    open(_fd) {
        notImplemented("Pipe.prototype.open");
    }
    bind(name) {
        this.#address = name;
        return 0;
    }
    connect(req, address) {
        if (isWindows) {
            notImplemented("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
            path: address,
            transport: "unix"
        };
        connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req.address = localAddr.path;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req, 0);
            } catch  {}
        }, (e)=>{
            let code;
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                code = codeMap.get("EACCES");
            } else {
                code = codeMap.get("ECONNREFUSED");
            }
            try {
                this.afterConnect(req, code);
            } catch  {}
        });
        return 0;
    }
    listen(backlog) {
        if (isWindows) {
            notImplemented("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
        const listenOptions = {
            path: this.#address,
            transport: "unix"
        };
        let listener;
        try {
            listener = listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            ListenerRef(this.#listener);
        }
    }
    unref() {
        if (this.#listener) {
            ListenerUnref(this.#listener);
        }
    }
    setPendingInstances(instances) {
        this.#pendingInstances = instances;
    }
    fchmod(mode) {
        if (mode != constants2.UV_READABLE && mode != constants2.UV_WRITABLE && mode != (constants2.UV_WRITABLE | constants2.UV_READABLE)) {
            return codeMap.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants2.UV_READABLE) {
            desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
        }
        if (mode & constants2.UV_WRITABLE) {
            desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
        }
        try {
            Deno.chmodSync(this.#address, desired_mode);
        } catch  {
            return codeMap.get("UNKNOWN");
        }
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e3) {
            if (e3 instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new Pipe(socketType.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.PIPESERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants2;
(function(constants) {
    constants[constants["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType.SERVER] = "SERVER";
    constants[constants["IPC"] = socketType.IPC] = "IPC";
    constants[constants["UV_READABLE"] = 1] = "UV_READABLE";
    constants[constants["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants2 || (constants2 = {}));
const mod38 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants2
};
const mod39 = {};
const mod40 = {};
const mod41 = {};
const mod42 = {};
const mod43 = {};
const mod44 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod45 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod46 = {};
var socketType1;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants3;
(function(constants) {
    constants[constants["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType1.SERVER] = "SERVER";
    constants[constants["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants3 || (constants3 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        switch(type){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname);
        }
    }
    open(_fd) {
        notImplemented("TCP.prototype.open");
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req, address, port) {
        return this.#connect(req, address, port);
    }
    connect6(req, address, port) {
        return this.#connect(req, address, port);
    }
    listen(backlog) {
        this.#backlog = ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            ListenerRef(this.#listener);
        }
    }
    unref() {
        if (this.#listener) {
            ListenerUnref(this.#listener);
        }
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address);
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented("TCP.prototype.setSimultaneousAccepts");
    }
     #bind(address, port1, _flags) {
        this.#address = address;
        this.#port = port1;
        return 0;
    }
     #connect(req1, address1, port11) {
        this.#remoteAddress = address1;
        this.#remotePort = port11;
        this.#remoteFamily = isIP(address1);
        const connectOptions = {
            hostname: address1,
            port: port11,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req1.localAddress = localAddr.hostname;
            this.#port = req1.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req1, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req1, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection1;
        try {
            connection1 = await this.#listener.accept();
        } catch (e4) {
            if (e4 instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle1 = new TCP(socketType1.SOCKET, connection1);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle1);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod47 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants3,
    TCP: TCP
};
const mod48 = {};
const mod49 = {};
const mod50 = {};
const mod51 = {};
const AF_INET6 = 10;
const UDP_DGRAM_MAXSIZE = 64 * 1024;
class SendWrap extends AsyncWrap {
    list;
    address;
    port;
    callback;
    oncomplete;
    constructor(){
        super(providerType.UDPSENDWRAP);
    }
}
class UDP extends HandleWrap {
    [ownerSymbol] = null;
    #address;
    #family;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #listener;
    #receiving = false;
    #recvBufferSize = UDP_DGRAM_MAXSIZE;
    #sendBufferSize = UDP_DGRAM_MAXSIZE;
    onmessage;
    lookup;
    constructor(){
        super(providerType.UDPWRAP);
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addMembership");
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
    }
    bind(ip, port, flags) {
        return this.#doBind(ip, port, flags, 2);
    }
    bind6(ip, port, flags) {
        return this.#doBind(ip, port, flags, 10);
    }
    bufferSize(size, buffer, ctx) {
        let err;
        if (size > UDP_DGRAM_MAXSIZE) {
            err = "EINVAL";
        } else if (!this.#address) {
            err = isWindows ? "ENOTSOCK" : "EBADF";
        }
        if (err) {
            ctx.errno = codeMap.get(err);
            ctx.code = err;
            ctx.message = errorMap.get(ctx.errno)[1];
            ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
            return;
        }
        if (size !== 0) {
            size = isLinux ? size * 2 : size;
            if (buffer) {
                return this.#recvBufferSize = size;
            }
            return this.#sendBufferSize = size;
        }
        return buffer ? this.#recvBufferSize : this.#sendBufferSize;
    }
    connect(ip, port) {
        return this.#doConnect(ip, port, 2);
    }
    connect6(ip, port) {
        return this.#doConnect(ip, port, 10);
    }
    disconnect() {
        this.#remoteAddress = undefined;
        this.#remotePort = undefined;
        this.#remoteFamily = undefined;
        return 0;
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropMembership");
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
    }
    getpeername(peername) {
        if (this.#remoteAddress === undefined) {
            return codeMap.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    getsockname(sockname) {
        if (this.#address === undefined) {
            return codeMap.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
    }
    open(_fd) {
        notImplemented("udp.UDP.prototype.open");
    }
    recvStart() {
        if (!this.#receiving) {
            this.#receiving = true;
            this.#receive();
        }
        return 0;
    }
    recvStop() {
        this.#receiving = false;
        return 0;
    }
    ref() {
        notImplemented("udp.UDP.prototype.ref");
    }
    send(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 2);
    }
    send6(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 10);
    }
    setBroadcast(_bool) {
        notImplemented("udp.UDP.prototype.setBroadcast");
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented("udp.UDP.prototype.setMulticastInterface");
    }
    setMulticastLoopback(_bool) {
        notImplemented("udp.UDP.prototype.setMulticastLoopback");
    }
    setMulticastTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setMulticastTTL");
    }
    setTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setTTL");
    }
    unref() {
        notImplemented("udp.UDP.prototype.unref");
    }
     #doBind(ip, port2, _flags1, family) {
        const listenOptions = {
            port: port2,
            hostname: ip,
            transport: "udp"
        };
        let listener;
        try {
            listener = listenDatagram(listenOptions);
        } catch (e5) {
            if (e5 instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e5 instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address2 = listener.addr;
        this.#address = address2.hostname;
        this.#port = address2.port;
        this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
        this.#listener = listener;
        return 0;
    }
     #doConnect(ip1, port12, family1) {
        this.#remoteAddress = ip1;
        this.#remotePort = port12;
        this.#remoteFamily = family1 === AF_INET6 ? "IPv6" : "IPv4";
        return 0;
    }
     #doSend(req2, bufs, _count, args, _family) {
        let hasCallback;
        if (args.length === 3) {
            this.#remotePort = args[0];
            this.#remoteAddress = args[1];
            hasCallback = args[2];
        } else {
            hasCallback = args[0];
        }
        const addr = {
            hostname: this.#remoteAddress,
            port: this.#remotePort,
            transport: "udp"
        };
        const payload = new Uint8Array(Buffer.concat(bufs.map((buf)=>{
            if (typeof buf === "string") {
                return Buffer.from(buf);
            }
            return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        })));
        (async ()=>{
            let sent;
            let err = null;
            try {
                sent = await this.#listener.send(payload, addr);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    err = codeMap.get("EBADF");
                } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
                    err = codeMap.get("EMSGSIZE");
                } else {
                    err = codeMap.get("UNKNOWN");
                }
                sent = 0;
            }
            if (hasCallback) {
                try {
                    req2.oncomplete(err, sent);
                } catch  {}
            }
        })();
        return 0;
    }
    async #receive() {
        if (!this.#receiving) {
            return;
        }
        const p7 = new Uint8Array(this.#recvBufferSize);
        let buf1;
        let remoteAddr;
        let nread1;
        try {
            [buf1, remoteAddr] = await this.#listener.receive(p7);
            nread1 = buf1.length;
        } catch (e12) {
            if (e12 instanceof Deno.errors.Interrupted || e12 instanceof Deno.errors.BadResource) {
                nread1 = 0;
            } else {
                nread1 = codeMap.get("UNKNOWN");
            }
            buf1 = new Uint8Array(0);
            remoteAddr = null;
        }
        nread1 ??= 0;
        const rinfo = remoteAddr ? {
            address: remoteAddr.hostname,
            port: remoteAddr.port,
            family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
        } : undefined;
        try {
            this.onmessage(nread1, this, Buffer.from(buf1), rinfo);
        } catch  {}
        this.#receive();
    }
    _onClose() {
        this.#receiving = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#family = undefined;
        try {
            this.#listener.close();
        } catch  {}
        this.#listener = undefined;
        return 0;
    }
}
const mod52 = {
    SendWrap: SendWrap,
    UDP: UDP
};
const mod53 = {};
const mod54 = {};
const mod55 = {};
const mod56 = {};
const modules = {
    "async_wrap": mod17,
    buffer: mod2,
    "cares_wrap": mod19,
    config: mod18,
    constants: mod4,
    contextify: mod20,
    credentials: mod21,
    crypto: mod6,
    errors: mod22,
    fs: mod23,
    "fs_dir": mod24,
    "fs_event_wrap": mod25,
    "heap_utils": mod26,
    "http_parser": mod27,
    icu: mod28,
    inspector: mod29,
    "js_stream": mod30,
    messaging: mod31,
    "module_wrap": mod32,
    "native_module": mod33,
    natives: mod34,
    options: mod35,
    os: mod36,
    performance: mod39,
    "pipe_wrap": mod38,
    "process_methods": mod40,
    report: mod41,
    serdes: mod42,
    "signal_wrap": mod43,
    "spawn_sync": mod44,
    "stream_wrap": mod37,
    "string_decoder": mod1,
    symbols: mod45,
    "task_queue": mod46,
    "tcp_wrap": mod47,
    timers: mod48,
    "tls_wrap": mod49,
    "trace_events": mod50,
    "tty_wrap": mod51,
    types: mod,
    "udp_wrap": mod52,
    url: mod53,
    util: mod3,
    uv: mod5,
    v8: mod54,
    worker: mod55,
    zlib: mod56
};
function getBinding(name) {
    const mod = modules[name];
    if (!mod) {
        throw new Error(`No such module: ${name}`);
    }
    return mod;
}
const kInternal = Symbol("internal properties");
const replaceUnderscoresRegex = /_/g;
const leadingDashesRegex = /^--?/;
const trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled", 
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex, "");
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex, "-");
                if (leadingDashesRegex.test(key)) {
                    key = key.replace(trailingValuesRegex, "");
                    return this[kInternal].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ]));
        }
        get size() {
            return this[kInternal].array.length;
        }
        values() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const notImplementedEvents = [
    "beforeExit",
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "uncaughtException",
    "uncaughtExceptionMonitor",
    "unhandledRejection",
    "worker", 
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>fromFileUrl2(Deno.mainModule)
});
const exit = (code)=>{
    if (code || code === 0) {
        if (typeof code === "string") {
            const parsedCode = parseInt(code);
            process1.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process1.exitCode = code;
        }
    }
    if (!process1._exiting) {
        process1._exiting = true;
        process1.emit("exit", process1.exitCode || 0);
    }
    Deno.exit(process1.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process1, name, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type, code, ctor, detail) {
    assert1(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type || "Warning");
    if (code !== undefined) {
        warningErr.code = code;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process1.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process1.emit("warning", warning);
}
function emitWarning(warning, type, code, ctor) {
    let detail;
    if (type !== null && typeof type === "object" && !Array.isArray(type)) {
        ctor = type.ctor;
        code = type.code;
        if (typeof type.detail === "string") {
            detail = type.detail;
        }
        type = type.type || "Warning";
    } else if (typeof type === "function") {
        ctor = type;
        code = undefined;
        type = "Warning";
    }
    if (type !== undefined) {
        validateString(type, "type");
    }
    if (typeof code === "function") {
        ctor = code;
        code = undefined;
    } else if (code !== undefined) {
        validateString(code, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type, code, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process1.noDeprecation) {
            return;
        }
        if (process1.throwDeprecation) {
            return process1.nextTick(()=>{
                throw warning;
            });
        }
    }
    process1.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function kill(pid, sig = "SIGTERM") {
    if (pid != (pid | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid);
    }
    if (typeof sig === "string") {
        try {
            Deno.kill(pid, sig);
        } catch (e) {
            if (e instanceof TypeError) {
                throw new ERR_UNKNOWN_SIGNAL(sig);
            }
            throw e;
        }
    } else {
        throw new ERR_UNKNOWN_SIGNAL(sig.toString());
    }
    return true;
}
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unload", ()=>{
            if (!process1._exiting) {
                process1._exiting = true;
                super.emit("exit", process1.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick1;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime;
    kill = kill;
    memoryUsage = memoryUsage;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name) {
        return getBinding(name);
    }
    umask() {
        return 0o22;
    }
    getuid() {
        return NaN;
    }
    getgid() {
        return NaN;
    }
    _eval = undefined;
    get execPath() {
        return argv[0];
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
}
const process1 = new Process();
Object.defineProperty(process1, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process1.removeListener;
process1.removeAllListeners;
var H0 = Object.create;
var X1 = Object.defineProperty;
var U0 = Object.getOwnPropertyDescriptor;
var z0 = Object.getOwnPropertyNames;
var G0 = Object.getPrototypeOf, $01 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (r, h)=>(typeof require != "undefined" ? require : r)[h]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var w5 = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var K0 = (t, r, h, e)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of z0(r))!$01.call(t, i) && i !== h && X1(t, i, {
        get: ()=>r[i],
        enumerable: !(e = U0(r, i)) || e.enumerable
    });
    return t;
};
var Y = (t, r, h)=>(h = t != null ? H0(G0(t)) : {}, K0(r || !t || !t.__esModule ? X1(h, "default", {
        value: t,
        enumerable: !0
    }) : h, t));
var I3 = w5((St, T)=>{
    var Z = L1;
    function z(t, r) {
        this._block = Z.alloc(t), this._finalSize = r, this._blockSize = t, this._len = 0;
    }
    z.prototype.update = function(t, r) {
        typeof t == "string" && (r = r || "utf8", t = Z.from(t, r));
        for(var h = this._block, e = this._blockSize, i = t.length, _ = this._len, s = 0; s < i;){
            for(var a = _ % e, x = Math.min(i - s, e - a), c = 0; c < x; c++)h[a + c] = t[s + c];
            _ += x, s += x, _ % e === 0 && this._update(h);
        }
        return this._len += i, this;
    };
    z.prototype.digest = function(t) {
        var r = this._len % this._blockSize;
        this._block[r] = 128, this._block.fill(0, r + 1), r >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var h = this._len * 8;
        if (h <= 4294967295) this._block.writeUInt32BE(h, this._blockSize - 4);
        else {
            var e = (h & 4294967295) >>> 0, i = (h - e) / 4294967296;
            this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(e, this._blockSize - 4);
        }
        this._update(this._block);
        var _ = this._hash();
        return t ? _.toString(t) : _;
    };
    z.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    };
    T.exports = z;
});
var t01 = w5((kt, j)=>{
    var L0 = w, W = I3(), J0 = L1, M0 = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], N0 = new Array(80);
    function k() {
        this.init(), this._w = N0, W.call(this, 64, 56);
    }
    L0(k, W);
    k.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function O0(t) {
        return t << 5 | t >>> 27;
    }
    function P0(t) {
        return t << 30 | t >>> 2;
    }
    function Q0(t, r, h, e) {
        return t === 0 ? r & h | ~r & e : t === 2 ? r & h | r & e | h & e : r ^ h ^ e;
    }
    k.prototype._update = function(t) {
        for(var r = this._w, h = this._a | 0, e = this._b | 0, i = this._c | 0, _ = this._d | 0, s = this._e | 0, a = 0; a < 16; ++a)r[a] = t.readInt32BE(a * 4);
        for(; a < 80; ++a)r[a] = r[a - 3] ^ r[a - 8] ^ r[a - 14] ^ r[a - 16];
        for(var x = 0; x < 80; ++x){
            var c = ~~(x / 20), f = O0(h) + Q0(c, e, i, _) + s + r[x] + M0[c] | 0;
            s = _, _ = i, i = P0(e), e = h, h = f;
        }
        this._a = h + this._a | 0, this._b = e + this._b | 0, this._c = i + this._c | 0, this._d = _ + this._d | 0, this._e = s + this._e | 0;
    };
    k.prototype._hash = function() {
        var t = J0.allocUnsafe(20);
        return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    j.exports = k;
});
var e0 = w5((mt, h0)=>{
    var R0 = w, r0 = I3(), V0 = L1, X0 = [
        1518500249,
        1859775393,
        -1894007588,
        -899497514
    ], Y0 = new Array(80);
    function m() {
        this.init(), this._w = Y0, r0.call(this, 64, 56);
    }
    R0(m, r0);
    m.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function Z0(t) {
        return t << 1 | t >>> 31;
    }
    function T0(t) {
        return t << 5 | t >>> 27;
    }
    function W0(t) {
        return t << 30 | t >>> 2;
    }
    function j0(t, r, h, e) {
        return t === 0 ? r & h | ~r & e : t === 2 ? r & h | r & e | h & e : r ^ h ^ e;
    }
    m.prototype._update = function(t) {
        for(var r = this._w, h = this._a | 0, e = this._b | 0, i = this._c | 0, _ = this._d | 0, s = this._e | 0, a = 0; a < 16; ++a)r[a] = t.readInt32BE(a * 4);
        for(; a < 80; ++a)r[a] = Z0(r[a - 3] ^ r[a - 8] ^ r[a - 14] ^ r[a - 16]);
        for(var x = 0; x < 80; ++x){
            var c = ~~(x / 20), f = T0(h) + j0(c, e, i, _) + s + r[x] + X0[c] | 0;
            s = _, _ = i, i = W0(e), e = h, h = f;
        }
        this._a = h + this._a | 0, this._b = e + this._b | 0, this._c = i + this._c | 0, this._d = _ + this._d | 0, this._e = s + this._e | 0;
    };
    m.prototype._hash = function() {
        var t = V0.allocUnsafe(20);
        return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    h0.exports = m;
});
var K4 = w5((Ht, a0)=>{
    var tt = w, i0 = I3(), rt = L1, ht = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ], et = new Array(64);
    function H() {
        this.init(), this._w = et, i0.call(this, 64, 56);
    }
    tt(H, i0);
    H.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function it(t, r, h) {
        return h ^ t & (r ^ h);
    }
    function at(t, r, h) {
        return t & r | h & (t | r);
    }
    function st(t) {
        return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function _t(t) {
        return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function ft(t) {
        return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function xt(t) {
        return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    H.prototype._update = function(t) {
        for(var r = this._w, h = this._a | 0, e = this._b | 0, i = this._c | 0, _ = this._d | 0, s = this._e | 0, a = this._f | 0, x = this._g | 0, c = this._h | 0, f = 0; f < 16; ++f)r[f] = t.readInt32BE(f * 4);
        for(; f < 64; ++f)r[f] = xt(r[f - 2]) + r[f - 7] + ft(r[f - 15]) + r[f - 16] | 0;
        for(var v = 0; v < 64; ++v){
            var B = c + _t(s) + it(s, a, x) + ht[v] + r[v] | 0, C = st(h) + at(h, e, i) | 0;
            c = x, x = a, a = s, s = _ + B | 0, _ = i, i = e, e = h, h = B + C | 0;
        }
        this._a = h + this._a | 0, this._b = e + this._b | 0, this._c = i + this._c | 0, this._d = _ + this._d | 0, this._e = s + this._e | 0, this._f = a + this._f | 0, this._g = x + this._g | 0, this._h = c + this._h | 0;
    };
    H.prototype._hash = function() {
        var t = rt.allocUnsafe(32);
        return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    a0.exports = H;
});
var _0 = w5((Ut, s0)=>{
    var ct = w, nt = K4(), bt = I3(), ot = L1, ut = new Array(64);
    function G() {
        this.init(), this._w = ut, bt.call(this, 64, 56);
    }
    ct(G, nt);
    G.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    G.prototype._hash = function() {
        var t = ot.allocUnsafe(28);
        return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    s0.exports = G;
});
var L2 = w5((zt, u0)=>{
    var dt = w, o0 = I3(), vt = L1, f0 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ], lt = new Array(160);
    function U() {
        this.init(), this._w = lt, o0.call(this, 128, 112);
    }
    dt(U, o0);
    U.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function x0(t, r, h) {
        return h ^ t & (r ^ h);
    }
    function c0(t, r, h) {
        return t & r | h & (t | r);
    }
    function n0(t, r) {
        return (t >>> 28 | r << 4) ^ (r >>> 2 | t << 30) ^ (r >>> 7 | t << 25);
    }
    function b0(t, r) {
        return (t >>> 14 | r << 18) ^ (t >>> 18 | r << 14) ^ (r >>> 9 | t << 23);
    }
    function Bt(t, r) {
        return (t >>> 1 | r << 31) ^ (t >>> 8 | r << 24) ^ t >>> 7;
    }
    function pt(t, r) {
        return (t >>> 1 | r << 31) ^ (t >>> 8 | r << 24) ^ (t >>> 7 | r << 25);
    }
    function Et(t, r) {
        return (t >>> 19 | r << 13) ^ (r >>> 29 | t << 3) ^ t >>> 6;
    }
    function wt(t, r) {
        return (t >>> 19 | r << 13) ^ (r >>> 29 | t << 3) ^ (t >>> 6 | r << 26);
    }
    function b(t, r) {
        return t >>> 0 < r >>> 0 ? 1 : 0;
    }
    U.prototype._update = function(t) {
        for(var r = this._w, h = this._ah | 0, e = this._bh | 0, i = this._ch | 0, _ = this._dh | 0, s = this._eh | 0, a = this._fh | 0, x = this._gh | 0, c = this._hh | 0, f = this._al | 0, v = this._bl | 0, B = this._cl | 0, C = this._dl | 0, p = this._el | 0, F = this._fl | 0, q = this._gl | 0, y = this._hl | 0, n = 0; n < 32; n += 2)r[n] = t.readInt32BE(n * 4), r[n + 1] = t.readInt32BE(n * 4 + 4);
        for(; n < 160; n += 2){
            var D = r[n - 30], S = r[n - 15 * 2 + 1], E0 = Bt(D, S), M = pt(S, D);
            D = r[n - 2 * 2], S = r[n - 2 * 2 + 1];
            var w0 = Et(D, S), N = wt(S, D), C0 = r[n - 7 * 2], A0 = r[n - 7 * 2 + 1], I0 = r[n - 16 * 2], O = r[n - 16 * 2 + 1], d = M + A0 | 0, A = E0 + C0 + b(d, M) | 0;
            d = d + N | 0, A = A + w0 + b(d, N) | 0, d = d + O | 0, A = A + I0 + b(d, O) | 0, r[n] = A, r[n + 1] = d;
        }
        for(var g = 0; g < 160; g += 2){
            A = r[g], d = r[g + 1];
            var g0 = c0(h, e, i), F0 = c0(f, v, B), q0 = n0(h, f), P = n0(f, h), y0 = b0(s, p), D0 = b0(p, s), S0 = f0[g], Q = f0[g + 1], k0 = x0(s, a, x), R = x0(p, F, q), o = y + D0 | 0, E = c + y0 + b(o, y) | 0;
            o = o + R | 0, E = E + k0 + b(o, R) | 0, o = o + Q | 0, E = E + S0 + b(o, Q) | 0, o = o + d | 0, E = E + A + b(o, d) | 0;
            var V = P + F0 | 0, m0 = q0 + g0 + b(V, P) | 0;
            c = x, y = q, x = a, q = F, a = s, F = p, p = C + o | 0, s = _ + E + b(p, C) | 0, _ = i, C = B, i = e, B = v, e = h, v = f, f = o + V | 0, h = E + m0 + b(f, o) | 0;
        }
        this._al = this._al + f | 0, this._bl = this._bl + v | 0, this._cl = this._cl + B | 0, this._dl = this._dl + C | 0, this._el = this._el + p | 0, this._fl = this._fl + F | 0, this._gl = this._gl + q | 0, this._hl = this._hl + y | 0, this._ah = this._ah + h + b(this._al, f) | 0, this._bh = this._bh + e + b(this._bl, v) | 0, this._ch = this._ch + i + b(this._cl, B) | 0, this._dh = this._dh + _ + b(this._dl, C) | 0, this._eh = this._eh + s + b(this._el, p) | 0, this._fh = this._fh + a + b(this._fl, F) | 0, this._gh = this._gh + x + b(this._gl, q) | 0, this._hh = this._hh + c + b(this._hl, y) | 0;
    };
    U.prototype._hash = function() {
        var t = vt.allocUnsafe(64);
        function r(h, e, i) {
            t.writeInt32BE(h, i), t.writeInt32BE(e, i + 4);
        }
        return r(this._ah, this._al, 0), r(this._bh, this._bl, 8), r(this._ch, this._cl, 16), r(this._dh, this._dl, 24), r(this._eh, this._el, 32), r(this._fh, this._fl, 40), r(this._gh, this._gl, 48), r(this._hh, this._hl, 56), t;
    };
    u0.exports = U;
});
var v0 = w5((Gt, d0)=>{
    var Ct = w, At = L2(), It = I3(), gt = L1, Ft = new Array(160);
    function $() {
        this.init(), this._w = Ft, It.call(this, 128, 112);
    }
    Ct($, At);
    $.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    $.prototype._hash = function() {
        var t = gt.allocUnsafe(48);
        function r(h, e, i) {
            t.writeInt32BE(h, i), t.writeInt32BE(e, i + 4);
        }
        return r(this._ah, this._al, 0), r(this._bh, this._bl, 8), r(this._ch, this._cl, 16), r(this._dh, this._dl, 24), r(this._eh, this._el, 32), r(this._fh, this._fl, 40), t;
    };
    d0.exports = $;
});
var J1 = w5((l, l0)=>{
    var l = l0.exports = function(r) {
        r = r.toLowerCase();
        var h = l[r];
        if (!h) throw new Error(r + " is not supported (we accept pull requests)");
        return new h;
    };
    l.sha = t01();
    l.sha1 = e0();
    l.sha224 = _0();
    l.sha256 = K4();
    l.sha384 = v0();
    l.sha512 = L2();
});
var B0 = Y(J1()), p0 = Y(J1()), { sha: $t , sha1: Kt , sha224: Lt , sha256: Jt , sha384: Mt , sha512: Nt  } = p0, { default: qt , ...yt } = p0, Ot = (B0.default ?? qt) ?? yt;
function addSignalListener1(...args) {
    if (typeof Deno.addSignalListener == "function") {
        return Deno.addSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function removeSignalListener1(...args) {
    if (typeof Deno.removeSignalListener == "function") {
        return Deno.removeSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function setRaw1(...args) {
    if (typeof Deno.setRaw == "function") {
        return Deno.setRaw(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
async function connect1(options) {
    return await Deno.connect(options);
}
function listen1(options) {
    return Deno.listen(options);
}
function listenDatagram1(options) {
    return Deno.listenDatagram(options);
}
function ListenerRef1(listener, ...args) {
    if (typeof listener.ref == "function") {
        return listener.ref(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function ListenerUnref1(listener, ...args) {
    if (typeof listener.unref == "function") {
        return listener.unref(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function delay1(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const { Deno: Deno2  } = globalThis;
typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType1;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType1 || (DiffType1 = {}));
class AssertionError1 extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function unreachable1() {
    throw new AssertionError1("unreachable");
}
function notImplemented1(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented1(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    console.warn(message);
}
const _TextDecoder = TextDecoder;
const _TextEncoder = TextEncoder;
function spliceOne1(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding3(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases2(enc);
}
function slowCases2(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
const _toString2 = Object.prototype.toString;
const _isObjectLike2 = (value)=>value !== null && typeof value === "object";
const _isFunctionLike1 = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer2(value) {
    return _isObjectLike2(value) && (_toString2.call(value) === "[object ArrayBuffer]" || _toString2.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Arguments]";
}
function isArrayBuffer2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction2(value) {
    return _isFunctionLike1(value) && _toString2.call(value) === "[object AsyncFunction]";
}
function isBooleanObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Boolean]";
}
function isBoxedPrimitive2(value) {
    return isBooleanObject2(value) || isStringObject2(value) || isNumberObject2(value) || isSymbolObject2(value) || isBigIntObject2(value);
}
function isDataView2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object DataView]";
}
function isDate2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Date]";
}
function isGeneratorFunction2(value) {
    return _isFunctionLike1(value) && _toString2.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Generator]";
}
function isMap2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Map]";
}
function isMapIterator2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Module]";
}
function isNativeError2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Error]";
}
function isNumberObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Number]";
}
function isBigIntObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object BigInt]";
}
function isPromise2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Promise]";
}
function isRegExp2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object RegExp]";
}
function isSet2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Set]";
}
function isSetIterator2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object String]";
}
function isSymbolObject2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object Symbol]";
}
function isWeakMap2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object WeakMap]";
}
function isWeakSet2(value) {
    return _isObjectLike2(value) && _toString2.call(value) === "[object WeakSet]";
}
const __default10 = {
    isAsyncFunction: isAsyncFunction2,
    isGeneratorFunction: isGeneratorFunction2,
    isAnyArrayBuffer: isAnyArrayBuffer2,
    isArrayBuffer: isArrayBuffer2,
    isArgumentsObject: isArgumentsObject2,
    isBoxedPrimitive: isBoxedPrimitive2,
    isDataView: isDataView2,
    isMap: isMap2,
    isMapIterator: isMapIterator2,
    isModuleNamespaceObject: isModuleNamespaceObject2,
    isNativeError: isNativeError2,
    isPromise: isPromise2,
    isSet: isSet2,
    isSetIterator: isSetIterator2,
    isWeakMap: isWeakMap2,
    isWeakSet: isWeakSet2,
    isRegExp: isRegExp2,
    isDate: isDate2,
    isStringObject: isStringObject2,
    isNumberObject: isNumberObject2,
    isBooleanObject: isBooleanObject2,
    isBigIntObject: isBigIntObject2
};
const mod57 = {
    isAnyArrayBuffer: isAnyArrayBuffer2,
    isArgumentsObject: isArgumentsObject2,
    isArrayBuffer: isArrayBuffer2,
    isAsyncFunction: isAsyncFunction2,
    isBooleanObject: isBooleanObject2,
    isBoxedPrimitive: isBoxedPrimitive2,
    isDataView: isDataView2,
    isDate: isDate2,
    isGeneratorFunction: isGeneratorFunction2,
    isGeneratorObject: isGeneratorObject2,
    isMap: isMap2,
    isMapIterator: isMapIterator2,
    isModuleNamespaceObject: isModuleNamespaceObject2,
    isNativeError: isNativeError2,
    isNumberObject: isNumberObject2,
    isBigIntObject: isBigIntObject2,
    isPromise: isPromise2,
    isRegExp: isRegExp2,
    isSet: isSet2,
    isSetIterator: isSetIterator2,
    isSharedArrayBuffer: isSharedArrayBuffer2,
    isStringObject: isStringObject2,
    isSymbolObject: isSymbolObject2,
    isWeakMap: isWeakMap2,
    isWeakSet: isWeakSet2,
    default: __default10
};
Symbol("kHandle");
const kKeyObject1 = Symbol("kKeyObject");
const kKeyType1 = Symbol("kKeyType");
function isKeyObject1(obj) {
    return obj != null && obj[kKeyType1] !== undefined;
}
function isCryptoKey1(obj) {
    return obj != null && obj[kKeyObject1] !== undefined;
}
const _toString3 = Object.prototype.toString;
const _isObjectLike3 = (value)=>value !== null && typeof value === "object";
function isArrayBufferView1(value) {
    return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object BigUint64Array]";
}
function isFloat32Array1(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Float32Array]";
}
function isFloat64Array1(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Int32Array]";
}
function isTypedArray1(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike3(value) && reTypedTag.test(_toString3.call(value));
}
function isUint8Array1(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
    return _isObjectLike3(value) && _toString3.call(value) === "[object Uint32Array]";
}
const { isDate: isDate3 , isArgumentsObject: isArgumentsObject3 , isBigIntObject: isBigIntObject3 , isBooleanObject: isBooleanObject3 , isNumberObject: isNumberObject3 , isStringObject: isStringObject3 , isSymbolObject: isSymbolObject3 , isNativeError: isNativeError3 , isRegExp: isRegExp3 , isAsyncFunction: isAsyncFunction3 , isGeneratorFunction: isGeneratorFunction3 , isGeneratorObject: isGeneratorObject3 , isPromise: isPromise3 , isMap: isMap3 , isSet: isSet3 , isMapIterator: isMapIterator3 , isSetIterator: isSetIterator3 , isWeakMap: isWeakMap3 , isWeakSet: isWeakSet3 , isArrayBuffer: isArrayBuffer3 , isDataView: isDataView3 , isSharedArrayBuffer: isSharedArrayBuffer3 , isModuleNamespaceObject: isModuleNamespaceObject3 , isAnyArrayBuffer: isAnyArrayBuffer3 , isBoxedPrimitive: isBoxedPrimitive3 ,  } = mod57;
const mod58 = {
    isCryptoKey: isCryptoKey1,
    isKeyObject: isKeyObject1,
    isArrayBufferView: isArrayBufferView1,
    isBigInt64Array: isBigInt64Array,
    isBigUint64Array: isBigUint64Array,
    isFloat32Array: isFloat32Array1,
    isFloat64Array: isFloat64Array1,
    isInt8Array: isInt8Array,
    isInt16Array: isInt16Array,
    isInt32Array: isInt32Array,
    isTypedArray: isTypedArray1,
    isUint8Array: isUint8Array1,
    isUint8ClampedArray: isUint8ClampedArray,
    isUint16Array: isUint16Array,
    isUint32Array: isUint32Array,
    isDate: isDate3,
    isArgumentsObject: isArgumentsObject3,
    isBigIntObject: isBigIntObject3,
    isBooleanObject: isBooleanObject3,
    isNumberObject: isNumberObject3,
    isStringObject: isStringObject3,
    isSymbolObject: isSymbolObject3,
    isNativeError: isNativeError3,
    isRegExp: isRegExp3,
    isAsyncFunction: isAsyncFunction3,
    isGeneratorFunction: isGeneratorFunction3,
    isGeneratorObject: isGeneratorObject3,
    isPromise: isPromise3,
    isMap: isMap3,
    isSet: isSet3,
    isMapIterator: isMapIterator3,
    isSetIterator: isSetIterator3,
    isWeakMap: isWeakMap3,
    isWeakSet: isWeakSet3,
    isArrayBuffer: isArrayBuffer3,
    isDataView: isDataView3,
    isSharedArrayBuffer: isSharedArrayBuffer3,
    isModuleNamespaceObject: isModuleNamespaceObject3,
    isAnyArrayBuffer: isAnyArrayBuffer3,
    isBoxedPrimitive: isBoxedPrimitive3
};
const codes1 = {};
function hideStackFrames1(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding4(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases3(enc);
}
function slowCases3(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt321(value) {
    return value === (value | 0);
}
function isUint321(value) {
    return value === value >>> 0;
}
const validateBuffer1 = hideStackFrames1((buffer, name = "buffer")=>{
    if (!isArrayBufferView1(buffer)) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames1((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject1 = hideStackFrames1((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames1((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt321(value)) {
        if (typeof value !== "number") {
            throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames1((value, name, positive)=>{
    if (!isUint321(value)) {
        if (typeof value !== "number") {
            throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes1.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString1(value, name) {
    if (typeof value !== "string") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
function validateBoolean1(value, name) {
    if (typeof value !== "boolean") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
}
hideStackFrames1((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes1.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
const validateCallback1 = hideStackFrames1((callback)=>{
    if (typeof callback !== "function") {
        throw new codes1.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal2 = hideStackFrames1((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction1 = hideStackFrames1((value, name)=>{
    if (typeof value !== "function") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames1((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes1.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
function guessHandleType1(_fd) {
    notImplemented1("util.guessHandleType");
}
const isNumericLookup1 = {};
function isArrayIndex1(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup1[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup1[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup1[value] = false;
                    }
                }
                return isNumericLookup1[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties1(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex1(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod59 = function() {
    return {
        guessHandleType: guessHandleType1,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex1,
        getOwnNonIndexProperties: getOwnNonIndexProperties1
    };
}();
const kObjectType1 = 0;
const kArrayExtrasType1 = 2;
const kRejected1 = 2;
const meta1 = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject1 = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp1 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer1 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle1 = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle1 = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp1 = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp1 = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp1 = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp2 = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp1 = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions1 = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions1(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect2(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor1,
        showHidden: inspectDefaultOptions1.showHidden,
        depth: inspectDefaultOptions1.depth,
        colors: inspectDefaultOptions1.colors,
        customInspect: inspectDefaultOptions1.customInspect,
        showProxy: inspectDefaultOptions1.showProxy,
        maxArrayLength: inspectDefaultOptions1.maxArrayLength,
        maxStringLength: inspectDefaultOptions1.maxStringLength,
        breakLength: inspectDefaultOptions1.breakLength,
        compact: inspectDefaultOptions1.compact,
        sorted: inspectDefaultOptions1.sorted,
        getters: inspectDefaultOptions1.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions1.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor1;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue1(ctx, value, 0);
}
const customInspectSymbol2 = Symbol.for("nodejs.util.inspect.custom");
inspect2.custom = customInspectSymbol2;
Object.defineProperty(inspect2, "defaultOptions", {
    get () {
        return inspectDefaultOptions1;
    },
    set (options) {
        validateObject1(options, "options");
        return Object.assign(inspectDefaultOptions1, options);
    }
});
const defaultFG1 = 39;
const defaultBG1 = 49;
inspect2.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG1
    ],
    red: [
        31,
        defaultFG1
    ],
    green: [
        32,
        defaultFG1
    ],
    yellow: [
        33,
        defaultFG1
    ],
    blue: [
        34,
        defaultFG1
    ],
    magenta: [
        35,
        defaultFG1
    ],
    cyan: [
        36,
        defaultFG1
    ],
    white: [
        37,
        defaultFG1
    ],
    bgBlack: [
        40,
        defaultBG1
    ],
    bgRed: [
        41,
        defaultBG1
    ],
    bgGreen: [
        42,
        defaultBG1
    ],
    bgYellow: [
        43,
        defaultBG1
    ],
    bgBlue: [
        44,
        defaultBG1
    ],
    bgMagenta: [
        45,
        defaultBG1
    ],
    bgCyan: [
        46,
        defaultBG1
    ],
    bgWhite: [
        47,
        defaultBG1
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG1
    ],
    redBright: [
        91,
        defaultFG1
    ],
    greenBright: [
        92,
        defaultFG1
    ],
    yellowBright: [
        93,
        defaultFG1
    ],
    blueBright: [
        94,
        defaultFG1
    ],
    magentaBright: [
        95,
        defaultFG1
    ],
    cyanBright: [
        96,
        defaultFG1
    ],
    whiteBright: [
        97,
        defaultFG1
    ],
    bgGray: [
        100,
        defaultBG1
    ],
    bgRedBright: [
        101,
        defaultBG1
    ],
    bgGreenBright: [
        102,
        defaultBG1
    ],
    bgYellowBright: [
        103,
        defaultBG1
    ],
    bgBlueBright: [
        104,
        defaultBG1
    ],
    bgMagentaBright: [
        105,
        defaultBG1
    ],
    bgCyanBright: [
        106,
        defaultBG1
    ],
    bgWhiteBright: [
        107,
        defaultBG1
    ]
});
function defineColorAlias1(target, alias) {
    Object.defineProperty(inspect2.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias1("gray", "grey");
defineColorAlias1("gray", "blackBright");
defineColorAlias1("bgGray", "bgGrey");
defineColorAlias1("bgGray", "bgBlackBright");
defineColorAlias1("dim", "faint");
defineColorAlias1("strikethrough", "crossedout");
defineColorAlias1("strikethrough", "strikeThrough");
defineColorAlias1("strikethrough", "crossedOut");
defineColorAlias1("hidden", "conceal");
defineColorAlias1("inverse", "swapColors");
defineColorAlias1("inverse", "swapcolors");
defineColorAlias1("doubleunderline", "doubleUnderline");
inspect2.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes1(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn1 = (str)=>meta1[str.charCodeAt(0)];
function strEscape1(str) {
    let escapeTest = strEscapeSequencesRegExp1;
    let escapeReplace = strEscapeSequencesReplacer1;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle1;
            escapeReplace = strEscapeSequencesReplacerSingle1;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes1(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn1);
        return addQuotes1(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta1[point];
            } else {
                result += `${str.slice(last, i)}${meta1[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes1(result, singleQuote);
}
function stylizeWithColor1(str, styleType) {
    const style = inspect2.styles[styleType];
    if (style !== undefined) {
        const color = inspect2.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor1(str) {
    return str;
}
function formatValue1(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject1(value)) {
        return formatPrimitive1(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol2];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions1(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue1(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw1(ctx, value, recurseTimes, typedArray);
}
function formatRaw1(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName1(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray1;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix1(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties1(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType1;
            formatter = formatArray1;
        } else if (isSet3(value)) {
            const size = value.size;
            const prefix1 = getPrefix1(constructor, tag, "Set", `(${size})`);
            keys = getKeys1(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet1.bind(null, value) : formatSet1.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix1}{}`;
            }
            braces = [
                `${prefix1}{`,
                "}"
            ];
        } else if (isMap3(value)) {
            const size1 = value.size;
            const prefix2 = getPrefix1(constructor, tag, "Map", `(${size1})`);
            keys = getKeys1(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap1.bind(null, value) : formatMap1.bind(null, value.entries());
            if (size1 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix2}{}`;
            }
            braces = [
                `${prefix2}{`,
                "}"
            ];
        } else if (isTypedArray1(value)) {
            keys = getOwnNonIndexProperties1(value, filter);
            const bound = value;
            const fallback = "";
            const size2 = value.length;
            const prefix3 = getPrefix1(constructor, tag, fallback, `(${size2})`);
            braces = [
                `${prefix3}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray1.bind(null, bound, size2);
            extrasType = kArrayExtrasType1;
        } else if (isMapIterator3(value)) {
            keys = getKeys1(value, ctx.showHidden);
            braces = getIteratorBraces1("Map", tag);
            formatter = formatIterator1.bind(null, braces);
        } else if (isSetIterator3(value)) {
            keys = getKeys1(value, ctx.showHidden);
            braces = getIteratorBraces1("Set", tag);
            formatter = formatIterator1.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys1(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject3(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix1(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase1(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp3(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix4 = getPrefix1(constructor, tag, "RegExp");
            if (prefix4 !== "RegExp ") {
                base = `${prefix4}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate3(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix5 = getPrefix1(constructor, tag, "Date");
            if (prefix5 !== "Date ") {
                base = `${prefix5}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError1(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer3(value)) {
            const arrayType = isArrayBuffer3(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix6 = getPrefix1(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer1;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix6 + `{ byteLength: ${formatNumber1(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix6}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView3(value)) {
            braces[0] = `${getPrefix1(constructor, tag, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise3(value)) {
            braces[0] = `${getPrefix1(constructor, tag, "Promise")}{`;
            formatter = formatPromise1;
        } else if (isWeakSet3(value)) {
            braces[0] = `${getPrefix1(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet1 : formatWeakCollection1;
        } else if (isWeakMap3(value)) {
            braces[0] = `${getPrefix1(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap1 : formatWeakCollection1;
        } else if (isModuleNamespaceObject3(value)) {
            braces[0] = `${getPrefix1(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject1.bind(null, keys);
        } else if (isBoxedPrimitive3(value)) {
            base = getBoxedBase1(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle1(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle1(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle1(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty1(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName1 = getCtxStyle1(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize1(ctx, err, constructorName1, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString1(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects1 = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties1(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects1.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty1(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName1(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject1(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof1(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects1.has(descriptor.value.name))) {
                addPrototypeProperties1(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName1(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect2(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive1(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape1(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape1(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber1(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt1(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray1() {
    return [];
}
function isInstanceof1(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix1(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray1(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray1(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty1(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle1(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix1(constructor, tag, fallback);
}
function getKeys1(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet1(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push(output, formatValue1(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap1(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue1(ctx, k, recurseTimes)} => ${formatValue1(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray1(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber1 : formatBigInt1;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue1(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces1(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator1(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner1(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner1(ctx, recurseTimes, entries, 1);
}
function getFunctionBase1(value, constructor, tag) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp2.test(slice.replace(stripCommentsRegExp1)))) {
            return getClassBase1(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction3(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction3(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError1(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name1 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name1);
            if (index !== -1 && stack.includes(err[name1])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix1(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos1 = 0;
            while(nodeModule = nodeModulesRegExp1.exec(line)){
                newStack += line.slice(pos1, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos1 = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos1 === 0 ? line : line.slice(pos1);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice1;
function formatArrayBuffer1(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice1(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber1(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise1(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue1(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected1 ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection1(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet1(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner1(ctx, recurseTimes, entries, 0);
}
function formatWeakMap1(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner1(ctx, recurseTimes, entries, 0);
}
function formatProperty1(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue1(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth1(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue1(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive1(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp1 = key.toString().replace(strEscapeSequencesReplacer1, escapeFn1);
        name = `[${ctx.stylize(tmp1, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp2 = key.replace(strEscapeSequencesReplacer1, escapeFn1);
        name = `[${tmp2}]`;
    } else if (keyStrRegExp1.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape1(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize1(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp1 = /\u001b\[\d\d?m/g;
function removeColors1(str) {
    return str.replace(colorRegExp1, "");
}
function isBelowBreakLength1(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors1(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt1(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject1(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty1(ctx, value, recurseTimes, keys[i], kObjectType1);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty1(ctx, tmp, recurseTimes, keys[i], kObjectType1);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray1(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp1.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty1(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending1 = remaining > 1 ? "s" : "";
            const message1 = `<${remaining} empty item${ending1}>`;
            output.push(ctx.stylize(message1, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase1(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject3(value)) {
        type = "Number";
    } else if (isStringObject3(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject3(value)) {
        type = "Boolean";
    } else if (isBigIntObject3(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive1(stylizeNoColor1, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor1) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase1(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString1(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements1(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength1(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join5(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join5(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength1(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join5(output, ", ")} ` + braces[1];
    }
    const indentation1 = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation1}  `;
    return `${braces[0]}${ln}${join5(output, `,\n${indentation1}  `)} ${braces[1]}`;
}
function join5(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements1(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth1(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i1 = 0; i1 < columns; i1++){
            let lineMaxLength = 0;
            for(let j = i1; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i1] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i2 = 0; i2 < output.length; i2++){
                if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i3 = 0; i3 < outputLength; i3 += columns){
            const max = Math.min(i3 + columns, outputLength);
            let str = "";
            let j1 = i3;
            for(; j1 < max - 1; j1++){
                const padding = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1];
                str += `${output[j1]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding1 = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1] - 2;
                str += output[j1].padStart(padding1, " ");
            } else {
                str += output[j1];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner1(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue1(ctx, entries[pos], recurseTimes)} => ${formatValue1(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos1 = i * 2;
            const res = [
                formatValue1(ctx, entries[pos1], recurseTimes),
                formatValue1(ctx, entries[pos1 + 1], recurseTimes), 
            ];
            output[i] = reduceToSingleString1(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType1, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner1(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue1(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern1 = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi1 = new RegExp(ansiPattern1, "g");
function getStringWidth1(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters1(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint1(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint1(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint1 = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint1 = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function hasBuiltInToString(value) {
    const proxyTarget = undefined;
    if (proxyTarget !== undefined) {
        value = proxyTarget;
    }
    if (typeof value.toString !== "function") {
        return true;
    }
    if (Object.prototype.hasOwnProperty.call(value, "toString")) {
        return false;
    }
    let pointer = value;
    do {
        pointer = Object.getPrototypeOf(pointer);
    }while (!Object.prototype.hasOwnProperty.call(pointer, "toString"))
    const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
    return descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects1.has(descriptor.value.name);
}
const firstErrorLine = (error)=>error.message.split("\n", 1)[0];
let CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
    try {
        return JSON.stringify(arg);
    } catch (err) {
        if (!CIRCULAR_ERROR_MESSAGE) {
            try {
                const a = {};
                a.a = a;
                JSON.stringify(a);
            } catch (circularError) {
                CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
            }
        }
        if (err.name === "TypeError" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
            return "[Circular]";
        }
        throw err;
    }
}
function format4(...args) {
    return formatWithOptionsInternal(undefined, args);
}
function formatWithOptions(inspectOptions, ...args) {
    if (typeof inspectOptions !== "object" || inspectOptions === null) {
        throw new codes1.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
    }
    return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
    return formatNumber1(stylizeNoColor1, number, options?.numericSeparator ?? inspectDefaultOptions1.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
    return formatBigInt1(stylizeNoColor1, bigint, options?.numericSeparator ?? inspectDefaultOptions1.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
    const first = args[0];
    let a = 0;
    let str = "";
    let join = "";
    if (typeof first === "string") {
        if (args.length === 1) {
            return first;
        }
        let tempStr;
        let lastPos = 0;
        for(let i = 0; i < first.length - 1; i++){
            if (first.charCodeAt(i) === 37) {
                const nextChar = first.charCodeAt(++i);
                if (a + 1 !== args.length) {
                    switch(nextChar){
                        case 115:
                            const tempArg = args[++a];
                            if (typeof tempArg === "number") {
                                tempStr = formatNumberNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg === "bigint") {
                                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                                tempStr = String(tempArg);
                            } else {
                                tempStr = inspect2(tempArg, {
                                    ...inspectOptions,
                                    compact: 3,
                                    colors: false,
                                    depth: 0
                                });
                            }
                            break;
                        case 106:
                            tempStr = tryStringify(args[++a]);
                            break;
                        case 100:
                            const tempNum = args[++a];
                            if (typeof tempNum === "bigint") {
                                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
                            } else if (typeof tempNum === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
                            }
                            break;
                        case 79:
                            tempStr = inspect2(args[++a], inspectOptions);
                            break;
                        case 111:
                            tempStr = inspect2(args[++a], {
                                ...inspectOptions,
                                showHidden: true,
                                showProxy: true,
                                depth: 4
                            });
                            break;
                        case 105:
                            const tempInteger = args[++a];
                            if (typeof tempInteger === "bigint") {
                                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
                            } else if (typeof tempInteger === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
                            }
                            break;
                        case 102:
                            const tempFloat = args[++a];
                            if (typeof tempFloat === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
                            }
                            break;
                        case 99:
                            a += 1;
                            tempStr = "";
                            break;
                        case 37:
                            str += first.slice(lastPos, i);
                            lastPos = i + 1;
                            continue;
                        default:
                            continue;
                    }
                    if (lastPos !== i - 1) {
                        str += first.slice(lastPos, i - 1);
                    }
                    str += tempStr;
                    lastPos = i + 1;
                } else if (nextChar === 37) {
                    str += first.slice(lastPos, i);
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos !== 0) {
            a++;
            join = " ";
            if (lastPos < first.length) {
                str += first.slice(lastPos);
            }
        }
    }
    while(a < args.length){
        const value = args[a];
        str += join;
        str += typeof value !== "string" ? inspect2(value, inspectOptions) : value;
        join = " ";
        a++;
    }
    return str;
}
function stripVTControlCharacters1(str) {
    validateString1(str, "str");
    return str.replace(ansi1, "");
}
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty1 = Object.create(null);
kEnumerableProperty1.enumerable = true;
function once2(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise1() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
const codesWarned = new Set();
function deprecate(fn, msg, code) {
    if (code !== undefined) {
        validateString1(code, "code");
    }
    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned.has(code)) {
                    process.emitWarning(msg, "DeprecationWarning", code, deprecated);
                    codesWarned.add(code);
                }
            } else {
                process.emitWarning(msg, "DeprecationWarning", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
const kCustomPromisifiedSymbol1 = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol1 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify1(original) {
    validateFunction1(original, "original");
    if (original[kCustomPromisifiedSymbol1]) {
        const fn = original[kCustomPromisifiedSymbol1];
        validateFunction1(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol1, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol1];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol1, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify1.custom = kCustomPromisifiedSymbol1;
let core1;
if (Deno?.core) {
    core1 = Deno.core;
} else {
    core1 = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting1 = false;
const kSize1 = 2048;
const kMask1 = 2048 - 1;
class FixedCircularBuffer1 {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize1);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask1) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask1;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask1;
        return nextItem;
    }
}
class FixedQueue1 {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer1();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer1();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue1 = new FixedQueue1();
let _nextTick1;
if (typeof core1.setNextTickCallback !== "undefined") {
    function runNextTicks1() {
        if (!core1.hasTickScheduled()) {
            core1.runMicrotasks();
        }
        if (!core1.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections1();
        return true;
    }
    function processTicksAndRejections1() {
        let tock;
        do {
            while(tock = queue1.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core1.runMicrotasks();
        }while (!queue1.isEmpty())
        core1.setHasTickScheduled(false);
    }
    core1.setNextTickCallback(processTicksAndRejections1);
    core1.setMacrotaskCallback(runNextTicks1);
    function __nextTickNative1(callback, ...args) {
        validateCallback1(callback);
        if (_exiting1) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue1.isEmpty()) {
            core1.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue1.push(tickObject);
    }
    _nextTick1 = __nextTickNative1;
} else {
    function __nextTickQueueMicrotask1(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick1 = __nextTickQueueMicrotask1;
}
function nextTick3(callback, ...args) {
    _nextTick1(callback, ...args);
}
class NodeFalsyValueRejectionError extends Error {
    reason;
    code = "ERR_FALSY_VALUE_REJECTION";
    constructor(reason){
        super("Promise was rejected with falsy value");
        this.reason = reason;
    }
}
class NodeInvalidArgTypeError extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName){
        super(`The ${argumentName} argument must be of type function.`);
    }
}
function callbackify(original) {
    if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError('"original"');
    }
    const callbackified = function(...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
            throw new NodeInvalidArgTypeError("last");
        }
        const cb = (...args)=>{
            maybeCb.apply(this, args);
        };
        original.apply(this, args).then((ret)=>{
            nextTick3(cb.bind(this, null, ret));
        }, (rej)=>{
            rej = rej || new NodeFalsyValueRejectionError(rej);
            nextTick3(cb.bind(this, rej));
        });
    };
    const descriptors = Object.getOwnPropertyDescriptors(original);
    if (typeof descriptors.length.value === "number") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === "string") {
        descriptors.name.value += "Callbackified";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}
var State1;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State1 || (State1 = {}));
var WorP1;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP1 || (WorP1 = {}));
class Flags1 {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min1 = Math.min;
const UNICODE_REPLACEMENT_CHARACTER1 = "\ufffd";
const FLOAT_REGEXP1 = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F1;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F1 || (F1 = {}));
class Printf1 {
    format;
    args;
    i;
    state = State1.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags1();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State1.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State1.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State1.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State1.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags1();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State1.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State1.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State1.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State1.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State1.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP1.WIDTH : WorP1.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State1.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP1.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP1.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State1.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State1.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP1.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State1.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State1.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP1.PRECISION);
                            break;
                        }
                        const val1 = parseInt(c);
                        if (isNaN(val1)) {
                            this.i--;
                            this.state = State1.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val1;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State1.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER1;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP1);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F1.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F1.exponent];
        let esign = m[F1.esign];
        let mantissa = parseInt(m[F1.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP1);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F1.exponent]) * (m[F1.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min1(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf1(format, ...args) {
    const printf = new Printf1(format, ...args);
    return printf.doPrintf();
}
let debugImpls1;
let testEnabled1;
function initializeDebugEnv1(debugEnv) {
    debugImpls1 = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled1 = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled1 = ()=>false;
    }
}
function emitWarningIfNeeded1(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop1 = ()=>{};
function debuglogImpl1(enabled, set) {
    if (debugImpls1[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded1(set);
            debugImpls1[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect2(arg)).join(" ");
                console.error(sprintf1("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls1[set] = noop1;
        }
    }
    return debugImpls1[set];
}
function debuglog1(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled1(set);
    }
    let debug = (...args)=>{
        init();
        debug = debuglogImpl1(enabled, set);
        if (typeof cb === "function") {
            cb(debug);
        }
        return debug(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled;
        return enabled;
    };
    const logger = (...args)=>debug(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv1;
try {
    debugEnv1 = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error1) {
    if (error1 instanceof Deno.errors.PermissionDenied) {
        debugEnv1 = "";
    } else {
        throw error1;
    }
}
initializeDebugEnv1(debugEnv1);
const osType1 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const isLinux1 = osType1 === "linux";
function uvTranslateSysError1(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const os1 = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs1 = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto2 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib1 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace1 = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod60 = {
    os: os1,
    fs: fs1,
    crypto: crypto2,
    zlib: zlib1,
    trace: trace1
};
const UV_EEXIST1 = os1.errno.EEXIST;
const UV_ENOENT1 = os1.errno.ENOENT;
const codeToErrorWindows1 = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows1 = codeToErrorWindows1.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin1 = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin1 = codeToErrorDarwin1.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux1 = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux1 = codeToErrorLinux1.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap1 = new Map(osType1 === "windows" ? codeToErrorWindows1 : osType1 === "darwin" ? codeToErrorDarwin1 : osType1 === "linux" ? codeToErrorLinux1 : unreachable1());
const codeMap1 = new Map(osType1 === "windows" ? errorToCodeWindows1 : osType1 === "darwin" ? errorToCodeDarwin1 : osType1 === "linux" ? errorToCodeLinux1 : unreachable1());
function mapSysErrnoToUvErrno1(sysErrno) {
    if (osType1 === "windows") {
        const code = uvTranslateSysError1(sysErrno);
        return codeMap1.get(code) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const UV_EAI_MEMORY1 = codeMap1.get("EAI_MEMORY");
const UV_UNKNOWN1 = codeMap1.get("UNKNOWN");
const UV_EBADF1 = codeMap1.get("EBADF");
const UV_EINVAL1 = codeMap1.get("EINVAL");
const UV_ENOTSOCK1 = codeMap1.get("ENOTSOCK");
const mod61 = {
    UV_EEXIST: UV_EEXIST1,
    UV_ENOENT: UV_ENOENT1,
    errorMap: errorMap1,
    codeMap: codeMap1,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno1,
    UV_EAI_MEMORY: UV_EAI_MEMORY1,
    UV_UNKNOWN: UV_UNKNOWN1,
    UV_EBADF: UV_EBADF1,
    UV_EINVAL: UV_EINVAL1,
    UV_ENOTSOCK: UV_ENOTSOCK1
};
const __default11 = {
    ...mod58
};
var Encodings1;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings1 || (Encodings1 = {}));
const encodings1 = [];
encodings1[Encodings1.ASCII] = "ascii";
encodings1[Encodings1.BASE64] = "base64";
encodings1[Encodings1.BASE64URL] = "base64url";
encodings1[Encodings1.BUFFER] = "buffer";
encodings1[Encodings1.HEX] = "hex";
encodings1[Encodings1.LATIN1] = "latin1";
encodings1[Encodings1.UCS2] = "utf16le";
encodings1[Encodings1.UTF8] = "utf8";
const __default12 = {
    encodings: encodings1
};
const mod62 = {
    encodings: encodings1,
    default: __default12
};
function indexOfNeedle1(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy1(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
function numberToBytes1(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex1(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer1(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings1[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex1(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle1(targetBuffer, buffer, byteOffset);
}
function indexOfNumber1(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes1(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer1(targetBuffer, numberToBytes1(number), byteOffset, Encodings1.UTF8, forwardDirection);
}
const __default13 = {
    indexOfBuffer: indexOfBuffer1,
    indexOfNumber: indexOfNumber1
};
const mod63 = {
    indexOfBuffer: indexOfBuffer1,
    indexOfNumber: indexOfNumber1,
    numberToBytes: numberToBytes1,
    default: __default13
};
const base64abc1 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode3(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc1[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc1[uint8[i - 2] >> 2];
        result += base64abc1[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc1[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode2(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url1(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase641(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url1(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url1(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode4(data) {
    return convertBase64ToBase64url1(encode3(data));
}
function decode3(b64url) {
    return decode2(convertBase64urlToBase641(b64url));
}
function asciiToBytes1(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes1(str) {
    str = base64clean1(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode2(str);
}
const INVALID_BASE64_RE1 = /[^+/0-9A-Za-z-_]/g;
function base64clean1(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE1, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes1(str) {
    str = base64clean1(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode3(str);
}
function hexToBytes1(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes1(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii1(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le1(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder1 = new TextEncoder();
const float32Array1 = new Float32Array(1);
const uInt8Float32Array1 = new Uint8Array(float32Array1.buffer);
const float64Array1 = new Float64Array(1);
const uInt8Float64Array1 = new Uint8Array(float64Array1.buffer);
float32Array1[0] = -1;
const bigEndian1 = uInt8Float32Array1[3] === 0;
function readUInt48LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE1(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE1(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 8);
    }
    uInt8Float64Array1[7] = first;
    uInt8Float64Array1[6] = buffer[++offset];
    uInt8Float64Array1[5] = buffer[++offset];
    uInt8Float64Array1[4] = buffer[++offset];
    uInt8Float64Array1[3] = buffer[++offset];
    uInt8Float64Array1[2] = buffer[++offset];
    uInt8Float64Array1[1] = buffer[++offset];
    uInt8Float64Array1[0] = last;
    return float64Array1[0];
}
function readDoubleForwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 8);
    }
    uInt8Float64Array1[0] = first;
    uInt8Float64Array1[1] = buffer[++offset];
    uInt8Float64Array1[2] = buffer[++offset];
    uInt8Float64Array1[3] = buffer[++offset];
    uInt8Float64Array1[4] = buffer[++offset];
    uInt8Float64Array1[5] = buffer[++offset];
    uInt8Float64Array1[6] = buffer[++offset];
    uInt8Float64Array1[7] = last;
    return float64Array1[0];
}
function writeDoubleForwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 7);
    float64Array1[0] = val;
    buffer[offset++] = uInt8Float64Array1[0];
    buffer[offset++] = uInt8Float64Array1[1];
    buffer[offset++] = uInt8Float64Array1[2];
    buffer[offset++] = uInt8Float64Array1[3];
    buffer[offset++] = uInt8Float64Array1[4];
    buffer[offset++] = uInt8Float64Array1[5];
    buffer[offset++] = uInt8Float64Array1[6];
    buffer[offset++] = uInt8Float64Array1[7];
    return offset;
}
function writeDoubleBackwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 7);
    float64Array1[0] = val;
    buffer[offset++] = uInt8Float64Array1[7];
    buffer[offset++] = uInt8Float64Array1[6];
    buffer[offset++] = uInt8Float64Array1[5];
    buffer[offset++] = uInt8Float64Array1[4];
    buffer[offset++] = uInt8Float64Array1[3];
    buffer[offset++] = uInt8Float64Array1[2];
    buffer[offset++] = uInt8Float64Array1[1];
    buffer[offset++] = uInt8Float64Array1[0];
    return offset;
}
function readFloatBackwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 4);
    }
    uInt8Float32Array1[3] = first;
    uInt8Float32Array1[2] = buffer[++offset];
    uInt8Float32Array1[1] = buffer[++offset];
    uInt8Float32Array1[0] = last;
    return float32Array1[0];
}
function readFloatForwards1(buffer, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buffer.length - 4);
    }
    uInt8Float32Array1[0] = first;
    uInt8Float32Array1[1] = buffer[++offset];
    uInt8Float32Array1[2] = buffer[++offset];
    uInt8Float32Array1[3] = last;
    return float32Array1[0];
}
function writeFloatForwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 3);
    float32Array1[0] = val;
    buffer[offset++] = uInt8Float32Array1[0];
    buffer[offset++] = uInt8Float32Array1[1];
    buffer[offset++] = uInt8Float32Array1[2];
    buffer[offset++] = uInt8Float32Array1[3];
    return offset;
}
function writeFloatBackwards1(buffer, val, offset = 0) {
    val = +val;
    checkBounds2(buffer, offset, 3);
    float32Array1[0] = val;
    buffer[offset++] = uInt8Float32Array1[3];
    buffer[offset++] = uInt8Float32Array1[2];
    buffer[offset++] = uInt8Float32Array1[1];
    buffer[offset++] = uInt8Float32Array1[0];
    return offset;
}
function readInt24LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE1(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError1(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf81(str) {
    return utf8Encoder1.encode(str).length;
}
function base64ByteLength1(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap1 = Object.create(null);
for(let i5 = 0; i5 < encodings1.length; ++i5){
    encodingsMap1[encodings1[i5]] = i5;
}
const encodingOps1 = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap1.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, asciiToBytes1(val), byteOffset, encodingsMap1.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength1(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap1.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, base64ToBytes1(val), byteOffset, encodingsMap1.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength1(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap1.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, base64UrlToBytes1(val), byteOffset, encodingsMap1.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap1.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, hexToBytes1(val), byteOffset, encodingsMap1.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap1.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, asciiToBytes1(val), byteOffset, encodingsMap1.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap1.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, utf16leToBytes1(val), byteOffset, encodingsMap1.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf81,
        encoding: "utf8",
        encodingVal: encodingsMap1.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, utf8Encoder1.encode(val), byteOffset, encodingsMap1.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap1.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer1(buf, utf16leToBytes1(val), byteOffset, encodingsMap1.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps1(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps1.utf8;
            if (encoding === "ucs2") return encodingOps1.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps1.utf8;
            if (encoding === "ascii") return encodingOps1.ascii;
            if (encoding === "ucs-2") return encodingOps1.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps1.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps1.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps1.latin1;
            }
            if (encoding === "base64") return encodingOps1.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps1.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps1.base64url;
            }
            break;
    }
}
function _copyActual1(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError1(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber1(value, type);
        throw new codes1.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes1.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber1(value, name) {
    if (typeof value !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds2(buf, offset, byteLength) {
    validateNumber1(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError1(offset, buf.length - (byteLength + 1));
    }
}
function checkInt1(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes1.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds2(buf, offset, byteLength);
}
function toInteger1(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int81(buf, value, offset, min, max) {
    value = +value;
    validateNumber1(offset, "offset");
    if (value > max || value < min) {
        throw new codes1.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError1(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset1(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE1(buf, value, offset, min, max) {
    value = +value;
    checkInt1(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength1 = 2147483647;
const MAX_UINT321 = 2 ** 32;
const customInspectSymbol3 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES1 = 50;
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer1(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes1.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe1(arg);
    }
    return _from2(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from2(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString1(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer3(value)) {
            return fromArrayBuffer1(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from2(valueOf, encodingOrOffset, length);
        }
        const b = fromObject1(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString1(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes1.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from2(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize2(size) {
    validateNumber1(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes1.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc1(size, fill, encoding) {
    assertSize2(size);
    const buffer = createBuffer1(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes1.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc1(size, fill, encoding);
};
function _allocUnsafe1(size) {
    assertSize2(size);
    return createBuffer1(size < 0 ? 0 : checked1(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe1(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe1(size);
};
function fromString1(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer1(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike1(array) {
    const length = array.length < 0 ? 0 : checked1(array.length) | 0;
    const buf = createBuffer1(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject1(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer3(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer1(0);
        }
        return fromArrayLike1(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike1(obj.data);
    }
}
function checked1(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer1(length) {
    assertSize2(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer1, Uint8Array);
Buffer1.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer1.prototype;
};
Buffer1.compare = function compare(a, b) {
    if (isInstance1(a, Uint8Array)) {
        a = Buffer1.from(a, a.offset, a.byteLength);
    }
    if (isInstance1(b, Uint8Array)) {
        b = Buffer1.from(b, b.offset, b.byteLength);
    }
    if (!Buffer1.isBuffer(a) || !Buffer1.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding4(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset1(length, "length");
    }
    const buffer = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array1(buf)) {
            throw new codes1.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual1(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength2(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView1(string) || isAnyArrayBuffer3(string)) {
            return string.byteLength;
        }
        throw new codes1.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf81(string);
    }
    const ops = getEncodingOps1(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf81(string);
    }
    return ops.byteLength(string);
}
Buffer1.byteLength = byteLength2;
Buffer1.prototype._isBuffer = true;
function swap1(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap1(this, i, i + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap1(this, i, i + 3);
        swap1(this, i + 1, i + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap1(this, i, i + 7);
        swap1(this, i + 1, i + 6);
        swap1(this, i + 2, i + 5);
        swap1(this, i + 3, i + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps1(encoding);
    if (ops === undefined) {
        throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b) {
    if (!isUint8Array1(b)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer1.compare(this, b) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES1;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol3) {
    Buffer1.prototype[customInspectSymbol3] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance1(target, Uint8Array)) {
        target = Buffer1.from(target, target.offset, target.byteLength);
    }
    if (!Buffer1.isBuffer(target)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset1(start, "targetStart", 0, kMaxLength1);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset1(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset1(start, "sourceStart", 0, kMaxLength1);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset1(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes1.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf1(buffer, val, byteOffset, encoding, dir) {
    validateBuffer1(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber1(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps1.utf8;
    } else {
        ops = getEncodingOps1(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array1(val)) {
        const encodingVal = ops === undefined ? encodingsMap1.utf8 : ops.encodingVal;
        return indexOfBuffer1(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes1.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf1(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf1(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii1(this);
    } else {
        return bytesToAscii1(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer1(asciiToBytes1(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode3(this);
    } else {
        return encode3(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer1(base64ToBytes1(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode4(this);
    } else {
        return encode4(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer1(base64UrlToBytes1(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer1(hexToBytes1(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice1(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice1(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer1(asciiToBytes1(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le1(this);
    } else {
        return bytesToUtf16le1(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer1(utf16leToBytes1(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice1(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer1(utf8ToBytes1(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset1(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset1(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps1(encoding);
    if (ops === undefined) {
        throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer1(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer1.prototype);
    return buffer;
}
function _utf8Slice1(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray1(res);
}
const MAX_ARGUMENTS_LENGTH1 = 4096;
function decodeCodePointsArray1(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH1));
    }
    return res;
}
function _latin1Slice1(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice1(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable1[buf[i]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE1(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE1(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE1(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE1(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError1(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE1;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE1;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod1(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod1(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE1(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE1(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE1(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE1(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE1(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError1(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError1(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod1(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod1(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError1(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian1 ? readFloatBackwards1(this, offset) : readFloatForwards1(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian1 ? readFloatForwards1(this, offset) : readFloatBackwards1(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian1 ? readDoubleBackwards1(this, offset) : readDoubleForwards1(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian1 ? readDoubleForwards1(this, offset) : readDoubleBackwards1(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE1(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE1(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE1(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE1(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE1(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, 0, 0xff);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE1(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE1(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE1(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE1(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE1(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, 0, 0xff);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int81(this, value, offset, 0, 0xff);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE1(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE1(this, value, offset, 0, 0xffff);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE1(this, value, offset, 0, 0xffffffff);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE1(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE1(buf, value, offset, min, max) {
    checkIntBI1(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE1(buf, value, offset, min, max) {
    checkIntBI1(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod1(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE1(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod1(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE1(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE1(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE1(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE1(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE1(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE1(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, -0x80, 0x7f);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE1(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE1(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE1(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE1(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE1(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int81(this, value, offset, -0x80, 0x7f);
    }
    boundsError1(byteLength, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int81(this, value, offset, -0x80, 0x7f);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE1(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE1(this, value, offset, -0x8000, 0x7fff);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE1(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE1(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod1(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE1(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod1(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE1(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian1 ? writeFloatBackwards1(this, value, offset) : writeFloatForwards1(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian1 ? writeFloatForwards1(this, value, offset) : writeFloatBackwards1(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian1 ? writeDoubleBackwards1(this, value, offset) : writeDoubleForwards1(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian1 ? writeDoubleForwards1(this, value, offset) : writeDoubleBackwards1(this, value, offset);
};
Buffer1.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array1(this)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array1(target)) {
        throw new codes1.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger1(targetStart, 0);
        if (targetStart < 0) {
            throw new codes1.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger1(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT321) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT321}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger1(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT321) {
            throw new codes1.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT321}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes1.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds3(buf, offset, byteLength2) {
    validateNumber1(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError1(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI1(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes1.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds3(buf, offset, byteLength2);
}
function utf8ToBytes1(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer1(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance1(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable1 = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod1(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined1 : fn;
}
function BufferBigIntNotDefined1() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType1;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType1 || (valueType1 = {}));
let memo1;
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual1(val1, val2, true);
}
function innerDeepEqual1(val1, val2, strict, memos = memo1) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties1(val1, filter);
        const keys2 = getOwnNonIndexProperties1(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck1(val1, val2, strict, memos, valueType1.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck1(val1, val2, strict, memos, valueType1.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps1(val1, val2)) {
            return false;
        }
    } else if (isNativeError3(val1) || val1 instanceof Error) {
        if (!isNativeError3(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView1(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray1(val1) && isTypedArray1(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array1(val1) || isFloat64Array1(val1))) {
            if (!areSimilarFloatArrays1(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays1(val1, val2)) {
            return false;
        }
        const filter1 = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties1(val1, filter1);
        const keysVal2 = getOwnNonIndexProperties1(val2, filter1);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck1(val1, val2, strict, memos, valueType1.noIterator, keysVal1);
    } else if (isSet3(val1)) {
        if (!isSet3(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck1(val1, val2, strict, memos, valueType1.isSet);
    } else if (isMap3(val1)) {
        if (!isMap3(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck1(val1, val2, strict, memos, valueType1.isMap);
    } else if (isAnyArrayBuffer3(val1)) {
        if (!isAnyArrayBuffer3(val2) || !areEqualArrayBuffers1(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive3(val1)) {
        if (!isEqualBoxedPrimitive1(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView1(val2) || isSet3(val2) || isMap3(val2) || isDate3(val2) || isRegExp3(val2) || isAnyArrayBuffer3(val2) || isBoxedPrimitive3(val2) || isNativeError3(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck1(val1, val2, strict, memos, valueType1.noIterator);
}
function keyCheck1(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i = 0;
    for(; i < aKeys.length; i++){
        if (!val2.propertyIsEnumerable(aKeys[i])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                const key = symbolKeysA[i];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables1(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB1.length !== 0 && getEnumerables1(val2, symbolKeysB1).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType1.noIterator || iterationType === valueType1.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv1(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps1(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays1(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i = 0; i < arr1.byteLength; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays1(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers1(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive1(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject3(a)) {
        return isNumberObject3(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject3(a)) {
        return isStringObject3(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject3(a)) {
        return isBooleanObject3(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject3(a)) {
        return isBigIntObject3(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject3(a)) {
        return isSymbolObject3(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables1(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv1(obj1, obj2, strict, keys, memos, iterationType) {
    let i = 0;
    if (iterationType === valueType1.isSet) {
        if (!setEquiv1(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType1.isMap) {
        if (!mapEquiv1(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType1.isArray) {
        for(; i < obj1.length; i++){
            if (obj1.hasOwnProperty(i)) {
                if (!obj2.hasOwnProperty(i) || !innerDeepEqual1(obj1[i], obj2[i], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i < keys1.length; i++){
                    const key = keys1[i];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual1(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i = 0; i < keys.length; i++){
        const key1 = keys[i];
        if (!innerDeepEqual1(obj1[key1], obj2[key1], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives1(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim1(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives1(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement1(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual1(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv1(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim1(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item1 of set2){
            if (typeof item1 === "object" && item1 !== null) {
                if (!setHasEqualElement1(set, item1, strict, memos)) return false;
            } else if (!strict && !set1.has(item1) && !setHasEqualElement1(set, item1, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive1(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives1(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual1(item, curB, false, memo1)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual1(item, curB, false, memos);
}
function mapEquiv1(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual1(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive1(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key1 , 1: item  } of map2){
            if (typeof key1 === "object" && key1 !== null) {
                if (!mapHasEqualEntry1(set, map1, key1, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key1) || !innerDeepEqual1(map1.get(key1), item, false, memos)) && !mapHasEqualEntry1(set, map1, key1, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry1(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual1(key1, key2, strict, memos) && innerDeepEqual1(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger1 = Number.isSafeInteger;
function isArray(value) {
    return Array.isArray(value);
}
function isBoolean(value) {
    return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
    return value === null;
}
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
function isNumber1(value) {
    return typeof value === "number" || value instanceof Number;
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
    return typeof value === "symbol";
}
function isUndefined(value) {
    return value === undefined;
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isError(e) {
    return e instanceof Error;
}
function isFunction(value) {
    return typeof value === "function";
}
function isRegExp4(value) {
    return __default11.isRegExp(value);
}
function isDate4(value) {
    return __default11.isDate(value);
}
function isPrimitive(value) {
    return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer(value) {
    return Buffer1.isBuffer(value);
}
function _extend(target, source) {
    if (source === null || typeof source !== "object") return target;
    const keys = Object.keys(source);
    let i = keys.length;
    while(i--){
        target[keys[i]] = source[keys[i]];
    }
    return target;
}
function getSystemErrorName1(code) {
    if (typeof code !== "number") {
        throw new codes1.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger1(code)) {
        throw new codes1.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap1.get(code)?.[0];
}
function inherits1(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new codes1.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
    }
    if (superCtor === undefined || superCtor === null) {
        throw new codes1.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
    }
    if (superCtor.prototype === undefined) {
        throw new codes1.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
    }
    Object.defineProperty(ctor, "super_", {
        value: superCtor,
        writable: true,
        configurable: true
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad(n) {
    return n.toString().padStart(2, "0");
}
const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec", 
];
function timestamp() {
    const d = new Date();
    const t = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds()), 
    ].join(":");
    return `${d.getDate()} ${months[d.getMonth()]} ${t}`;
}
function log(...args) {
    console.log("%s - %s", timestamp(), format4(...args));
}
const __default14 = {
    format: format4,
    formatWithOptions,
    inspect: inspect2,
    isArray,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber: isNumber1,
    isString,
    isSymbol,
    isUndefined,
    isObject,
    isError,
    isFunction,
    isRegExp: isRegExp4,
    isDate: isDate4,
    isPrimitive,
    isBuffer,
    _extend,
    getSystemErrorName: getSystemErrorName1,
    deprecate,
    callbackify,
    promisify: promisify1,
    inherits: inherits1,
    types: __default11,
    stripVTControlCharacters: stripVTControlCharacters1,
    TextDecoder: _TextDecoder,
    TextEncoder: _TextEncoder,
    log,
    debuglog: debuglog1,
    isDeepStrictEqual
};
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert3(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
const { errno: { ENOTDIR: ENOTDIR1 , ENOENT: ENOENT1  } ,  } = os1;
const kIsNodeError1 = Symbol("kIsNodeError");
const classRegExp3 = /^([A-Z][a-z0-9]*)+$/;
const kTypes1 = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError1 extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator1(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace1 = hideStackFrames1(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames1(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet1(err) || uvUnmappedError1;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace1(ex);
});
hideStackFrames1(function errnoException(err, syscall, original) {
    const code = getSystemErrorName1(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace1(ex);
});
function uvErrmapGet1(name) {
    return errorMap1.get(name);
}
const uvUnmappedError1 = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames1(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet1(ctx.errno) || uvUnmappedError1;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace1(err);
});
hideStackFrames1(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName1(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace1(ex);
});
hideStackFrames1(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap1.get("EAI_NODATA") || code === codeMap1.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName1(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace1(ex);
});
class NodeErrorAbstraction1 extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError1 extends NodeErrorAbstraction1 {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError1 extends NodeErrorAbstraction1 {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError1 extends NodeErrorAbstraction1 {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError1 extends NodeErrorAbstraction1 {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace1(this);
        Object.defineProperties(this, {
            [kIsNodeError1]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode1(key, msgPrfix) {
    return class NodeError extends NodeSystemError1 {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode1("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType1(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes1.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp3.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last1 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last1}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE1 extends NodeRangeError1 {
    constructor(name, expected, actual){
        const msg = createInvalidArgType1(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper1(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE1 extends NodeTypeError1 {
    constructor(name, expected, actual){
        const msg = createInvalidArgType1(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper1(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE1;
}
class ERR_INVALID_ARG_VALUE_RANGE1 extends NodeRangeError1 {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect2(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE1 extends NodeTypeError1 {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect2(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE1;
}
function invalidArgTypeHelper1(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect2(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect2(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE1 extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert3(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator1(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator1(received);
            }
            received += "n";
        } else {
            received = inspect2(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS1 extends NodeRangeError1 {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CALLBACK1 extends NodeTypeError1 {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect2(object)}`);
    }
}
class ERR_IPC_CHANNEL_CLOSED1 extends NodeError1 {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED1 extends NodeError1 {
    constructor(x){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
    }
}
class ERR_MISSING_ARGS1 extends NodeTypeError1 {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap = (a)=>`"${a}"`;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap).join(" or ") : wrap(a));
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK1 extends NodeError1 {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SOCKET_BAD_PORT1 extends NodeRangeError1 {
    constructor(name, port, allowZero = true){
        assert3(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_ALREADY_FINISHED1 extends NodeError1 {
    constructor(x){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE1 extends NodeError1 {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED1 extends NodeError1 {
    constructor(x){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES1 extends NodeTypeError1 {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE1 extends NodeError1 {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF1 extends NodeError1 {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT1 extends NodeError1 {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END1 extends NodeError1 {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR1 extends NodeError1 {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING1 extends NodeTypeError1 {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL1 extends NodeTypeError1 {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
function buildReturnPropertyType1(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE1 extends NodeTypeError1 {
    constructor(input, name, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType1(value)}.`);
    }
}
function aggregateTwoErrors1(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes1.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED1;
codes1.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE1;
codes1.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE1;
codes1.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK1;
codes1.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE1;
codes1.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT1;
codes1.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS1;
codes1.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING1;
hideStackFrames1(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
"use strict";
const kRejection1 = Symbol.for("nodejs.rejection");
const kCapture1 = Symbol("kCapture");
const kErrorMonitor1 = Symbol("events.errorMonitor");
const kMaxEventTargetListeners1 = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned1 = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter1(opts) {
    EventEmitter1.init.call(this, opts);
}
EventEmitter1.on = on1;
EventEmitter1.once = once3;
EventEmitter1.getEventListeners = getEventListeners1;
EventEmitter1.EventEmitter = EventEmitter1;
EventEmitter1.usingDomains = false;
EventEmitter1.captureRejectionSymbol = kRejection1;
EventEmitter1.captureRejectionSymbol;
EventEmitter1.errorMonitor;
Object.defineProperty(EventEmitter1, "captureRejections", {
    get () {
        return EventEmitter1.prototype[kCapture1];
    },
    set (value) {
        validateBoolean1(value, "EventEmitter.captureRejections");
        EventEmitter1.prototype[kCapture1] = value;
    },
    enumerable: true
});
EventEmitter1.errorMonitor = kErrorMonitor1;
Object.defineProperty(EventEmitter1.prototype, kCapture1, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter1.prototype._events = undefined;
EventEmitter1.prototype._eventsCount = 0;
EventEmitter1.prototype._maxListeners = undefined;
let defaultMaxListeners1 = 10;
function checkListener1(listener) {
    validateFunction1(listener, "listener");
}
Object.defineProperty(EventEmitter1, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners1;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE1("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners1 = arg;
    }
});
Object.defineProperties(EventEmitter1, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners1,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned1,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter1.setMaxListeners = function(n = defaultMaxListeners1, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE1("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners1 = n;
    } else {
        for(let i = 0; i < eventTargets.length; i++){
            const target = eventTargets[i];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners1] = n;
                target[kMaxEventTargetListenersWarned1] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE1("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter1.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean1(opts.captureRejections, "options.captureRejections");
        this[kCapture1] = Boolean(opts.captureRejections);
    } else {
        this[kCapture1] = EventEmitter1.prototype[kCapture1];
    }
};
function addCatch1(that, promise, type, args) {
    if (!that[kCapture1]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr1, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr1(ee, err, type, args) {
    if (typeof ee[kRejection1] === "function") {
        ee[kRejection1](err, type, ...args);
    } else {
        const prev = ee[kCapture1];
        try {
            ee[kCapture1] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture1] = prev;
        }
    }
}
EventEmitter1.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE1("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners1(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter1.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter1.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners1(this);
};
EventEmitter1.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor1] !== undefined) {
            this.emit(kErrorMonitor1, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter1.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect2(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR1(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch1(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone1(handler);
        for(let i = 0; i < len; ++i){
            const result1 = listeners[i].apply(this, args);
            if (result1 !== undefined && result1 !== null) {
                addCatch1(this, result1, type, args);
            }
        }
    }
    return true;
};
function _addListener1(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener1(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners1(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect2(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter1.prototype.addListener = function addListener(type, listener) {
    return _addListener1(this, type, listener, false);
};
EventEmitter1.prototype.on = EventEmitter1.prototype.addListener;
EventEmitter1.prototype.prependListener = function prependListener(type, listener) {
    return _addListener1(this, type, listener, true);
};
function onceWrapper1() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap1(target, type, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper1.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter1.prototype.once = function once(type, listener) {
    checkListener1(listener);
    this.on(type, _onceWrap1(this, type, listener));
    return this;
};
EventEmitter1.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener1(listener);
    this.prependListener(type, _onceWrap1(this, type, listener));
    return this;
};
EventEmitter1.prototype.removeListener = function removeListener(type, listener) {
    checkListener1(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne1(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter1.prototype.off = EventEmitter1.prototype.removeListener;
EventEmitter1.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners1(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners1(evlistener) : arrayClone1(evlistener);
}
EventEmitter1.prototype.listeners = function listeners(type) {
    return _listeners1(this, type, true);
};
EventEmitter1.prototype.rawListeners = function rawListeners(type) {
    return _listeners1(this, type, false);
};
EventEmitter1.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return listenerCount1.call(emitter, type);
};
EventEmitter1.prototype.listenerCount = listenerCount1;
function listenerCount1(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter1.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone1(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners1(arr) {
    const ret = arrayClone1(arr);
    for(let i = 0; i < ret.length; ++i){
        const orig = ret[i].listener;
        if (typeof orig === "function") {
            ret[i] = orig;
        }
    }
    return ret;
}
function getEventListeners1(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE1("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once3(emitter, name, options = {}) {
    const signal = options?.signal;
    validateAbortSignal2(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError1();
    }
    return new Promise((resolve, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener1(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener1(signal, "abort", abortListener);
            }
            resolve(args);
        };
        eventTargetAgnosticAddListener1(emitter, name, resolver, {
            once: true
        });
        if (name !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener1(emitter, name, resolver);
            eventTargetAgnosticRemoveListener1(emitter, "error", errorListener);
            reject(new AbortError1());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener1(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype1 = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult1(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener1(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE1("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener1(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE1("emitter", "EventEmitter", emitter);
    }
}
function on1(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal2(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError1();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult1(value, false));
            }
            if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
            }
            if (finished) {
                return Promise.resolve(createIterResult1(undefined, true));
            }
            return new Promise(function(resolve, reject) {
                unconsumedPromises.push({
                    resolve,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener1(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener1(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener1(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult1(undefined, true));
            }
            return Promise.resolve(createIterResult1(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE1("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener1(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener1(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype1);
    eventTargetAgnosticAddListener1(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener1(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError1());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult1(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
const { hasOwn: hasOwn1  } = Object;
function get1(obj, key) {
    if (hasOwn1(obj, key)) {
        return obj[key];
    }
}
function getForce1(obj, key) {
    const v = get1(obj, key);
    assert3(v != null);
    return v;
}
function isNumber2(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey1(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get1(o, key) ?? {};
    });
    const key = keys[keys.length - 1];
    return key in o;
}
function parse4(args, { "--": doubleDash = false , alias ={} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect =[] , unknown =(i)=>i  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {}
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias !== undefined) {
        for(const key1 in alias){
            const val = getForce1(alias, key1);
            if (typeof val === "string") {
                aliases[key1] = [
                    val
                ];
            } else {
                aliases[key1] = val;
            }
            for (const alias1 of getForce1(aliases, key1)){
                aliases[alias1] = [
                    key1
                ].concat(aliases[key1].filter((y)=>alias1 !== y));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key2 of stringArgs.filter(Boolean)){
            flags.strings[key2] = true;
            const alias2 = get1(aliases, key2);
            if (alias2) {
                for (const al of alias2){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect !== undefined) {
        const collectArgs = typeof collect === "string" ? [
            collect
        ] : collect;
        for (const key3 of collectArgs.filter(Boolean)){
            flags.collect[key3] = true;
            const alias3 = get1(aliases, key3);
            if (alias3) {
                for (const al1 of alias3){
                    flags.collect[al1] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get1(flags.bools, key) || !!get1(flags.strings, key) || !!get1(aliases, key);
    }
    function setKey(obj, name, value, collect = true) {
        let o = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get1(o, key) === undefined) {
                o[key] = {};
            }
            o = get1(o, key);
        });
        const key = keys[keys.length - 1];
        const collectable = collect && !!get1(flags.collect, name);
        if (!collectable) {
            o[key] = value;
        } else if (get1(o, key) === undefined) {
            o[key] = [
                value
            ];
        } else if (Array.isArray(get1(o, key))) {
            o[key].push(value);
        } else {
            o[key] = [
                get1(o, key),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get1(flags.strings, key) && isNumber2(val) ? Number(val) : val;
        setKey(argv, key, value, collect);
        const alias = get1(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce1(aliases, key).some((x)=>typeof get1(flags.bools, x) === "boolean");
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert3(m != null);
            const [, key4, value] = m;
            if (flags.bools[key4]) {
                const booleanValue = value !== "false";
                setArg(key4, booleanValue, arg);
            } else {
                setArg(key4, value, arg);
            }
        } else if (/^--no-.+/.test(arg)) {
            const m1 = arg.match(/^--no-(.+)/);
            assert3(m1 != null);
            setArg(m1[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m2 = arg.match(/^--(.+)/);
            assert3(m2 != null);
            const [, key5] = m2;
            const next = args[i + 1];
            if (next !== undefined && !/^-/.test(next) && !get1(flags.bools, key5) && !flags.allBools && (get1(aliases, key5) ? !aliasIsBoolean(key5) : true)) {
                setArg(key5, next, arg);
                i++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key5, next === "true", arg);
                i++;
            } else {
                setArg(key5, get1(flags.strings, key5) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next1 = arg.slice(j + 2);
                if (next1 === "-") {
                    setArg(letters[j], next1, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next1)) {
                    setArg(letters[j], next1.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next1)) {
                    setArg(letters[j], next1, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get1(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key6] = arg.slice(-1);
            if (!broken && key6 !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get1(flags.bools, key6) && (get1(aliases, key6) ? !aliasIsBoolean(key6) : true)) {
                    setArg(key6, args[i + 1], arg);
                    i++;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key6, args[i + 1] === "true", arg);
                    i++;
                } else {
                    setArg(key6, get1(flags.strings, key6) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(flags.strings["_"] ?? !isNumber2(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args.slice(i + 1));
                break;
            }
        }
    }
    for (const [key7, value1] of Object.entries(defaults)){
        if (!hasKey1(argv, key7.split("."))) {
            setKey(argv, key7, value1);
            if (aliases[key7]) {
                for (const x of aliases[key7]){
                    setKey(argv, x, value1);
                }
            }
        }
    }
    for (const key8 of Object.keys(flags.bools)){
        if (!hasKey1(argv, key8.split("."))) {
            const value2 = get1(flags.collect, key8) ? [] : false;
            setKey(argv, key8, value2, false);
        }
    }
    for (const key9 of Object.keys(flags.strings)){
        if (!hasKey1(argv, key9.split(".")) && get1(flags.collect, key9)) {
            setKey(argv, key9, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key10 of notFlags){
            argv["--"].push(key10);
        }
    } else {
        for (const key11 of notFlags){
            argv._.push(key11);
        }
    }
    return argv;
}
function getOptions1() {
    const args = parse4(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap1;
function getOptionsFromBinding1() {
    if (!optionsMap1) {
        ({ options: optionsMap1  } = getOptions1());
    }
    return optionsMap1;
}
function getOptionValue1(optionName) {
    const options = getOptionsFromBinding1();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
const sep3 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join6(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert3(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve3(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename3(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator1(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator1(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format5(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse5(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod64 = {
    sep: sep3,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join6,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format5,
    parse: parse5,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep4 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join7(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename4(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath1(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse6(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod65 = {
    sep: sep4,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join7,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format6,
    parse: parse6,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const path2 = isWindows1 ? mod64 : mod65;
const { join: join8 , normalize: normalize6  } = path2;
const path3 = isWindows1 ? mod64 : mod65;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format7 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join9 , normalize: normalize7 , parse: parse7 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path3;
function _arch1() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch1 = _arch1();
const chdir1 = Deno.chdir;
const cwd1 = Deno.cwd;
const nextTick4 = nextTick3;
const env1 = new Proxy({}, {
    get (_target, prop) {
        return Deno.env.get(String(prop));
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name)=>{
        const e = Deno.env.toObject();
        if (name in Deno.env.toObject()) {
            const o = {
                enumerable: true,
                configurable: true
            };
            if (typeof name === "string") {
                o.value = e[name];
            }
            return o;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    }
});
const pid1 = Deno.pid;
const platform1 = isWindows1 ? "win32" : Deno.build.os;
const version1 = "v16.11.1";
const versions1 = {
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
};
function _uint8ArrayToBuffer1(chunk) {
    return Buffer1.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function isRequest2(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse1(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable2(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable2(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished1(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop3 = ()=>{};
function isReadableEnded2(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos1(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject1(options, "options");
    }
    validateFunction1(callback, "callback");
    validateAbortSignal2(options.signal, "options.signal");
    callback = once2(callback);
    const readable = options.readable || options.readable !== false && isReadable2(stream);
    const writable = options.writable || options.writable !== false && isWritable2(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse1(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable2(stream) === readable && isWritable2(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded2(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE1());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished1(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE1());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest2(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick3(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop3;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError1());
        };
        if (options.signal.aborted) {
            nextTick3(abort);
        } else {
            const originalCallback = callback;
            callback = once2((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal3 = (signal, name)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE1(name, "AbortSignal", signal);
    }
};
function isStream1(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal1(signal, stream) {
    validateAbortSignal3(signal, "signal");
    if (!isStream1(stream)) {
        throw new ERR_INVALID_ARG_TYPE1("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate1(signal, stream);
}
function addAbortSignalNoValidate1(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError1());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos1(stream, ()=>signal.removeEventListener("abort", onAbort));
    }
    return stream;
}
const kDestroy1 = Symbol("kDestroy");
const kConstruct1 = Symbol("kConstruct");
function checkError1(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy3(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError1(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy1, function(er) {
            _destroy1(this, aggregateTwoErrors1(er, err), cb);
        });
    } else {
        _destroy1(this, err, cb);
    }
    return this;
}
function _destroy1(self1, err, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self1._readableState;
        const w = self1._writableState;
        checkError1(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick3(emitErrorCloseNT1, self1, err);
        } else {
            nextTick3(emitCloseNT1, self1);
        }
    }
    try {
        const result = self1._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick3(onDestroy, null);
                }, function(err) {
                    nextTick3(onDestroy, err);
                });
            }
        }
    } catch (err1) {
        onDestroy(err1);
    }
}
function emitErrorCloseNT1(self1, err) {
    emitErrorNT1(self1, err);
    emitCloseNT1(self1);
}
function emitCloseNT1(self1) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self1.emit("close");
    }
}
function emitErrorNT1(self1, err) {
    const r = self1._readableState;
    const w = self1._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self1.emit("error", err);
}
function undestroy1() {
    const r = this._readableState;
    const w = this._writableState;
    if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = false;
        r.endEmitted = false;
    }
    if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.ended = false;
        w.ending = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.finished = false;
    }
}
function errorOrDestroy3(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick3(emitErrorNT1, stream, err);
        } else {
            emitErrorNT1(stream, err);
        }
    }
}
function construct1(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r = stream._readableState;
    const w = stream._writableState;
    if (r) {
        r.constructed = false;
    }
    if (w) {
        w.constructed = false;
    }
    stream.once(kConstruct1, cb);
    if (stream.listenerCount(kConstruct1) > 1) {
        return;
    }
    nextTick3(constructNT1, stream);
}
function constructNT1(stream) {
    let called = false;
    function onConstruct(err) {
        if (called) {
            errorOrDestroy3(stream, err ?? new ERR_MULTIPLE_CALLBACK1());
            return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
            r.constructed = true;
        }
        if (w) {
            w.constructed = true;
        }
        if (s.destroyed) {
            stream.emit(kDestroy1, err);
        } else if (err) {
            errorOrDestroy3(stream, err, true);
        } else {
            nextTick3(emitConstructNT1, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick3(onConstruct, null);
                }, function(err) {
                    nextTick3(onConstruct, err);
                });
            }
        }
    } catch (err) {
        onConstruct(err);
    }
}
function emitConstructNT1(stream) {
    stream.emit(kConstruct1);
}
function isRequest3(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer2(stream, err) {
    if (!stream) return;
    if (isRequest3(stream)) return stream.abort();
    if (isRequest3(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err);
    if (typeof stream.close === "function") return stream.close();
}
const __default15 = {
    construct: construct1,
    destroyer: destroyer2,
    destroy: destroy3,
    undestroy: undestroy1,
    errorOrDestroy: errorOrDestroy3
};
const kIsDisturbed1 = Symbol("kIsDisturbed");
function isReadableNodeStream1(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream1(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream1(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream1(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable1(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed1(stream) {
    if (!isNodeStream1(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded1(stream) {
    if (!isWritableNodeStream1(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded3(stream) {
    if (!isReadableNodeStream1(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished1(stream, strict) {
    if (!isReadableNodeStream1(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed1(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed1]));
}
function isReadable3(stream) {
    const r = isReadableNodeStream1(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed1(stream)) return false;
    return r && stream.readable && !isReadableFinished1(stream);
}
function isWritable3(stream) {
    const r = isWritableNodeStream1(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed1(stream)) return false;
    return r && stream.writable && !isWritableEnded1(stream);
}
const stdio1 = {};
function isBlob1(object) {
    return object instanceof Blob;
}
function _from3(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer1) {
        return new Readable({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE1("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error, cb) {
        close(error).then(()=>nextTick4(cb, error), (e)=>nextTick4(cb, e || error));
    };
    async function close(error) {
        const hadError = error !== undefined && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value: value1  } = await iterator.return();
            await value1;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES1();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err) {
                readable.destroy(err);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom1(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark1(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark1(state, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom1(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE1(name, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark1(state.objectMode);
}
function Stream1(opts) {
    EventEmitter1.call(this, opts);
}
Object.setPrototypeOf(Stream1.prototype, EventEmitter1.prototype);
Object.setPrototypeOf(Stream1, EventEmitter1);
Stream1.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter1.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener1(source, "error", onerror);
    prependListener1(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener1(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented1;
(function(NotImplemented) {
    NotImplemented[NotImplemented["ascii"] = 0] = "ascii";
    NotImplemented[NotImplemented["latin1"] = 1] = "latin1";
    NotImplemented[NotImplemented["utf16le"] = 2] = "utf16le";
})(NotImplemented1 || (NotImplemented1 = {}));
function normalizeEncoding5(enc) {
    const encoding = normalizeEncoding3(enc ?? null);
    if (encoding && encoding in NotImplemented1) notImplemented1(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte1(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete1(self1, buf, i) {
    let j = buf.length - 1;
    if (j < i) return 0;
    let nb = utf8CheckByte1(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte1(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self1.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte1(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self1.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes1(self1, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self1.lastNeed = 0;
        return "\ufffd";
    }
    if (self1.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self1.lastNeed = 1;
            return "\ufffd";
        }
        if (self1.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self1.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete1(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes1(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete1(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text1(buf, i) {
    const total = utf8CheckIncomplete1(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
function utf8End1(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write1(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
}
function base64Text1(buf, i) {
    const n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End1(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite1(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd1(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase1 {
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer1.allocUnsafe(nb);
    }
    encoding;
}
class Base64Decoder1 extends StringDecoderBase1 {
    end = base64End1;
    fillLast = utf8FillLastIncomplete1;
    text = base64Text1;
    write = utf8Write1;
    constructor(encoding){
        super(normalizeEncoding5(encoding), 3);
    }
}
class GenericDecoder1 extends StringDecoderBase1 {
    end = simpleEnd1;
    fillLast = undefined;
    text = utf8Text1;
    write = simpleWrite1;
    constructor(encoding){
        super(normalizeEncoding5(encoding), 4);
    }
}
class Utf8Decoder1 extends StringDecoderBase1 {
    end = utf8End1;
    fillLast = utf8FillLastComplete1;
    text = utf8Text1;
    write = utf8Write1;
    constructor(encoding){
        super(normalizeEncoding5(encoding), 4);
    }
}
class StringDecoder1 {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder1(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder1(encoding);
                break;
            default:
                decoder = new GenericDecoder1(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
const PStringDecoder1 = new Proxy(StringDecoder1, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder1(...args));
    }
});
const __default16 = {
    StringDecoder: PStringDecoder1
};
class BufferList1 {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v) {
        const entry = {
            data: v,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v) {
        const entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s) {
        if (this.length === 0) {
            return "";
        }
        let p = this.head;
        let ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    }
    concat(n) {
        if (this.length === 0) {
            return Buffer1.alloc(0);
        }
        const ret = Buffer1.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while(p){
            ret.set(p.data, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    }
    consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
            const slice = data.slice(0, n);
            this.head.data = data.slice(n);
            return slice;
        }
        if (n === data.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p = this.head; p; p = p.next){
            yield p.data;
        }
    }
    _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
            const str = p.data;
            if (n > str.length) {
                ret += str;
                n -= str.length;
            } else {
                if (n === str.length) {
                    ret += str;
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n);
                    this.head = p;
                    p.data = str.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    _getBuffer(n) {
        const ret = Buffer1.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
            const buf = p.data;
            if (n > buf.length) {
                ret.set(buf, retLen - n);
                n -= buf.length;
            } else {
                if (n === buf.length) {
                    ret.set(buf, retLen - n);
                    ++c;
                    if (p.next) {
                        this.head = p.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
                    this.head = p;
                    p.data = buf.slice(n);
                }
                break;
            }
            ++c;
        }while (p = p.next)
        this.length -= c;
        return ret;
    }
    [inspect2.custom](_, options) {
        return inspect2(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug1 = debuglog1("stream", (fn)=>{
    debug1 = fn;
});
const kPaused1 = Symbol("kPaused");
Object.setPrototypeOf(Readable1.prototype, Stream1.prototype);
Object.setPrototypeOf(Readable1, Stream1);
const nop4 = ()=>{};
const { errorOrDestroy: errorOrDestroy4  } = __default15;
function ReadableState1(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream1.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark1(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark1(false);
    this.buffer = new BufferList1();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused1] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder1(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable1(options) {
    if (!(this instanceof Readable1)) {
        return new Readable1(options);
    }
    const isDuplex = this instanceof Stream1.Duplex;
    this._readableState = new ReadableState1(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate1(options.signal, this);
        }
    }
    Stream1.call(this, options);
    __default15.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore1(this, this._readableState);
        }
    });
}
Readable1.prototype.destroy = __default15.destroy;
Readable1.prototype._undestroy = __default15.undestroy;
Readable1.prototype._destroy = function(err, cb) {
    cb(err);
};
Readable1.prototype[EventEmitter1.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Readable1.prototype.push = function(chunk, encoding) {
    return readableAddChunk1(this, chunk, encoding, false);
};
Readable1.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk1(this, chunk, encoding, true);
};
function readableAddChunk1(stream, chunk, encoding, addToFront) {
    debug1("readableAddChunk", chunk);
    const state = stream._readableState;
    let err;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (state.encoding !== encoding) {
                if (addToFront && state.encoding) {
                    chunk = Buffer1.from(chunk, encoding).toString(state.encoding);
                } else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "";
        } else if (Stream1._isUint8Array(chunk)) {
            chunk = Stream1._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err = new ERR_INVALID_ARG_TYPE1("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err) {
        errorOrDestroy4(stream, err);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk1(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state.endEmitted) {
                errorOrDestroy4(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT1());
            } else {
                addChunk1(stream, state, chunk, true);
            }
        } else if (state.ended) {
            errorOrDestroy4(stream, new ERR_STREAM_PUSH_AFTER_EOF1());
        } else if (state.destroyed || state.errored) {
            return false;
        } else {
            state.reading = false;
            if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) {
                    addChunk1(stream, state, chunk, false);
                } else {
                    maybeReadMore1(stream, state);
                }
            } else {
                addChunk1(stream, state, chunk, false);
            }
        }
    } else if (!addToFront) {
        state.reading = false;
        maybeReadMore1(stream, state);
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk1(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state.buffer.unshift(chunk);
        } else {
            state.buffer.push(chunk);
        }
        if (state.needReadable) {
            emitReadable1(stream);
        }
    }
    maybeReadMore1(stream, state);
}
Readable1.prototype.isPaused = function() {
    const state = this._readableState;
    return state[kPaused1] === true || state.flowing === false;
};
Readable1.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder1(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer = this._readableState.buffer;
    let content = "";
    for (const data of buffer){
        content += decoder.write(data);
    }
    buffer.clear();
    if (content !== "") {
        buffer.push(content);
    }
    this._readableState.length = content.length;
    return this;
};
const MAX_HWM1 = 0x40000000;
function computeNewHighWaterMark1(n) {
    if (n >= 0x40000000) {
        n = MAX_HWM1;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead1(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) {
        return 0;
    }
    if (state.objectMode) {
        return 1;
    }
    if (Number.isNaN(n)) {
        if (state.flowing && state.length) {
            return state.buffer.first().length;
        }
        return state.length;
    }
    if (n <= state.length) {
        return n;
    }
    return state.ended ? state.length : 0;
}
Readable1.prototype.read = function(n) {
    debug1("read", n);
    if (n === undefined) {
        n = NaN;
    } else if (!Number.isInteger(n)) {
        n = Number.parseInt(n, 10);
    }
    const state = this._readableState;
    const nOrig = n;
    if (n > state.highWaterMark) {
        state.highWaterMark = computeNewHighWaterMark1(n);
    }
    if (n !== 0) {
        state.emittedReadable = false;
    }
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug1("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) {
            endReadable1(this);
        } else {
            emitReadable1(this);
        }
        return null;
    }
    n = howMuchToRead1(n, state);
    if (n === 0 && state.ended) {
        if (state.length === 0) {
            endReadable1(this);
        }
        return null;
    }
    let doRead = state.needReadable;
    debug1("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug1("length less than watermark", doRead);
    }
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug1("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug1("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) {
            state.needReadable = true;
        }
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) {
            n = howMuchToRead1(nOrig, state);
        }
    }
    let ret;
    if (n > 0) {
        ret = fromList1(n, state);
    } else {
        ret = null;
    }
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
            state.awaitDrainWriters.clear();
        } else {
            state.awaitDrainWriters = null;
        }
    }
    if (state.length === 0) {
        if (!state.ended) {
            state.needReadable = true;
        }
        if (nOrig !== n && state.ended) {
            endReadable1(this);
        }
    }
    if (ret !== null) {
        state.dataEmitted = true;
        this.emit("data", ret);
    }
    return ret;
};
function onEofChunk1(stream, state) {
    debug1("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        emitReadable1(stream);
    } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_1(stream);
    }
}
function emitReadable1(stream) {
    const state = stream._readableState;
    debug1("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug1("emitReadable", state.flowing);
        state.emittedReadable = true;
        nextTick3(emitReadable_1, stream);
    }
}
function emitReadable_1(stream) {
    const state = stream._readableState;
    debug1("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow1(stream);
}
function maybeReadMore1(stream, state) {
    if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        nextTick3(maybeReadMore_1, stream, state);
    }
}
function maybeReadMore_1(stream, state) {
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        const len = state.length;
        debug1("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) {
            break;
        }
    }
    state.readingMore = false;
}
Readable1.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED1("_read()");
};
Readable1.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state = this._readableState;
    if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
            state.multiAwaitDrain = true;
            state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [
                state.awaitDrainWriters
            ] : []);
        }
    }
    state.pipes.push(dest);
    debug1("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio1.stdout && dest !== stdio1.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) {
        nextTick3(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug1("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug1("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug1("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest) {
                debug1("false write response, pause", 0);
                state.awaitDrainWriters = dest;
                state.multiAwaitDrain = false;
            } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
                debug1("false write response, pause", state.awaitDrainWriters.size);
                state.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain1(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug1("ondata");
        const ret = dest.write(chunk);
        debug1("dest.write", ret);
        if (ret === false) {
            pause();
        }
    }
    function onerror(er) {
        debug1("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter1.listenerCount(dest, "error") === 0) {
            const s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted) {
                errorOrDestroy4(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener1(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug1("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug1("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state.flowing) {
            pause();
        }
    } else if (!state.flowing) {
        debug1("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain1(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
            debug1("pipeOnDrain", 1);
            state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
            debug1("pipeOnDrain", state.awaitDrainWriters.size);
            state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EventEmitter1.listenerCount(src, "data")) {
            state.flowing = true;
            flow1(src);
        }
    };
}
Readable1.prototype.unpipe = function(dest) {
    const state = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for(let i = 0; i < dests.length; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index = state.pipes.indexOf(dest);
    if (index === -1) {
        return this;
    }
    state.pipes.splice(index, 1);
    if (state.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable1.prototype.on = function(ev, fn) {
    const res = Stream1.prototype.on.call(this, ev, fn);
    const state = this._readableState;
    if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug1("on readable", state.length, state.reading);
            if (state.length) {
                emitReadable1(this);
            } else if (!state.reading) {
                nextTick3(nReadingNextTick1, this);
            }
        }
    }
    return res;
};
Readable1.prototype.addListener = Readable1.prototype.on;
Readable1.prototype.removeListener = function(ev, fn) {
    const res = Stream1.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick3(updateReadableListening1, this);
    }
    return res;
};
Readable1.prototype.off = Readable1.prototype.removeListener;
Readable1.prototype.removeAllListeners = function(ev) {
    const res = Stream1.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick3(updateReadableListening1, this);
    }
    return res;
};
function updateReadableListening1(self1) {
    const state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && state[kPaused1] === false) {
        state.flowing = true;
    } else if (self1.listenerCount("data") > 0) {
        self1.resume();
    } else if (!state.readableListening) {
        state.flowing = null;
    }
}
function nReadingNextTick1(self1) {
    debug1("readable nexttick read 0");
    self1.read(0);
}
Readable1.prototype.resume = function() {
    const state = this._readableState;
    if (!state.flowing) {
        debug1("resume");
        state.flowing = !state.readableListening;
        resume1(this, state);
    }
    state[kPaused1] = false;
    return this;
};
function resume1(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick3(resume_1, stream, state);
    }
}
function resume_1(stream, state) {
    debug1("resume", state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow1(stream);
    if (state.flowing && !state.reading) {
        stream.read(0);
    }
}
Readable1.prototype.pause = function() {
    debug1("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug1("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused1] = true;
    return this;
};
function flow1(stream) {
    const state = stream._readableState;
    debug1("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
Readable1.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err)=>{
        errorOrDestroy4(this, err);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i = streamKeys[j];
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = stream[i].bind(stream);
        }
    }
    return this;
};
Readable1.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator1(this);
};
Readable1.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject1(options, "options");
    }
    return streamToAsyncIterator1(this, options);
};
function streamToAsyncIterator1(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable1.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator1(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator1(stream, options) {
    let callback = nop4;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve) {
        if (this === stream) {
            callback();
            callback = nop4;
        } else {
            callback = resolve;
        }
    }
    const state = stream._readableState;
    let error = state.errored;
    let errorEmitted = state.errorEmitted;
    let endEmitted = state.endEmitted;
    let closeEmitted = state.closeEmitted;
    stream.on("readable", next).on("error", function(err) {
        error = err;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err) {
        if (opts.destroyOnError) {
            __default15.destroyer(stream, err);
        }
        errorThrown = true;
        throw err;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state.autoDestroy || !endEmitted) {
                __default15.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable1.prototype, {
    readable: {
        get () {
            const r = this._readableState;
            return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state) {
            if (this._readableState) {
                this._readableState.flowing = state;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState1.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused1] !== false;
        },
        set (value) {
            this[kPaused1] = !!value;
        }
    }
});
function fromList1(n, state) {
    if (state.length === 0) {
        return null;
    }
    let ret;
    if (state.objectMode) {
        ret = state.buffer.shift();
    } else if (!n || n >= state.length) {
        if (state.decoder) {
            ret = state.buffer.join("");
        } else if (state.buffer.length === 1) {
            ret = state.buffer.first();
        } else {
            ret = state.buffer.concat(state.length);
        }
        state.buffer.clear();
    } else {
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable1(stream) {
    const state = stream._readableState;
    debug1("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        nextTick3(endReadableNT1, state, stream);
    }
}
function endReadableNT1(state, stream) {
    debug1("endReadableNT", state.endEmitted, state.length);
    if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick3(endWritableNT1, stream);
        } else if (state.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT1(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom1(iterable, opts) {
    return _from3(Readable1, iterable, opts);
}
function wrap1(src, options) {
    return new Readable1({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err, callback) {
            __default15.destroyer(src, err);
            callback(err);
        }
    }).wrap(src);
}
Readable1._fromList = fromList1;
Readable1.ReadableState = ReadableState1;
Readable1.from = readableFrom1;
Readable1.wrap = wrap1;
const { errorOrDestroy: errorOrDestroy5  } = __default15;
function isDuplexStream1(maybe_duplex) {
    const isReadable = Readable1.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable && isDuplex;
}
Object.setPrototypeOf(Writable1.prototype, Stream1.prototype);
Object.setPrototypeOf(Writable1, Stream1);
function nop5() {}
const kOnFinished1 = Symbol("kOnFinished");
function WritableState1(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream1(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark1(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark1(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite1.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer1(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished1] = [];
}
function resetBuffer1(state) {
    state.buffered = [];
    state.bufferedIndex = 0;
    state.allBuffers = true;
    state.allNoop = true;
}
WritableState1.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState1.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable1(options) {
    const isDuplex = isDuplexStream1(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable1, this)) {
        return new Writable1(options);
    }
    this._writableState = new WritableState1(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate1(options.signal, this);
        }
    }
    Stream1.call(this, options);
    __default15.construct(this, ()=>{
        const state = this._writableState;
        if (!state.writing) {
            clearBuffer1(this, state);
        }
        finishMaybe1(this, state);
    });
}
Object.defineProperty(Writable1, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable1) return false;
        return object && object._writableState instanceof WritableState1;
    }
});
Writable1.prototype.pipe = function() {
    errorOrDestroy5(this, new ERR_STREAM_CANNOT_PIPE1());
};
function _write1(stream, chunk, encoding, cb) {
    const state = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer1.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING1(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop5;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES1();
    } else if (!state.objectMode) {
        if (typeof chunk === "string") {
            if (state.decodeStrings !== false) {
                chunk = Buffer1.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "buffer";
        } else if (isUint8Array1(chunk)) {
            chunk = _uint8ArrayToBuffer1(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE1("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err;
    if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END1();
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED1("write");
    }
    if (err) {
        nextTick3(cb, err);
        errorOrDestroy5(stream, err, true);
        return err;
    }
    state.pendingcb++;
    return writeOrBuffer1(stream, state, chunk, encoding, cb);
}
Writable1.prototype.write = function(chunk, encoding, cb) {
    return _write1(this, chunk, encoding, cb) === true;
};
Writable1.prototype.cork = function() {
    this._writableState.corked++;
};
Writable1.prototype.uncork = function() {
    const state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing) {
            clearBuffer1(this, state);
        }
    }
};
Writable1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING1(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer1(stream, state, chunk, encoding, callback) {
    const len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    const ret = state.length < state.highWaterMark;
    if (!ret) {
        state.needDrain = true;
    }
    if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state.allBuffers && encoding !== "buffer") {
            state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop5) {
            state.allNoop = false;
        }
    } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
    }
    return ret && !state.errored && !state.destroyed;
}
function doWrite1(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) {
        state.onwrite(new ERR_STREAM_DESTROYED1("write"));
    } else if (writev) {
        stream._writev(chunk, state.onwrite);
    } else {
        stream._write(chunk, encoding, state.onwrite);
    }
    state.sync = false;
}
function onwriteError1(stream, state, er, cb) {
    --state.pendingcb;
    cb(er);
    errorBuffer1(state);
    errorOrDestroy5(stream, er);
}
function onwrite1(stream, er) {
    const state = stream._writableState;
    const sync = state.sync;
    const cb = state.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy5(stream, new ERR_MULTIPLE_CALLBACK1());
        return;
    }
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
    if (er) {
        er.stack;
        if (!state.errored) {
            state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick3(onwriteError1, stream, state, er, cb);
        } else {
            onwriteError1(stream, state, er, cb);
        }
    } else {
        if (state.buffered.length > state.bufferedIndex) {
            clearBuffer1(stream, state);
        }
        if (sync) {
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
                state.afterWriteTickInfo.count++;
            } else {
                state.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state
                };
                nextTick3(afterWriteTick1, state.afterWriteTickInfo);
            }
        } else {
            afterWrite1(stream, state, 1, cb);
        }
    }
}
function afterWriteTick1({ stream , state , count , cb  }) {
    state.afterWriteTickInfo = null;
    return afterWrite1(stream, state, count, cb);
}
function afterWrite1(stream, state, count, cb) {
    const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
    if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
    while(count-- > 0){
        state.pendingcb--;
        cb();
    }
    if (state.destroyed) {
        errorBuffer1(state);
    }
    finishMaybe1(stream, state);
}
function errorBuffer1(state) {
    if (state.writing) {
        return;
    }
    for(let n = state.bufferedIndex; n < state.buffered.length; ++n){
        const { chunk , callback  } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(new ERR_STREAM_DESTROYED1("write"));
    }
    const onfinishCallbacks = state[kOnFinished1].splice(0);
    for(let i = 0; i < onfinishCallbacks.length; i++){
        onfinishCallbacks[i](new ERR_STREAM_DESTROYED1("end"));
    }
    resetBuffer1(state);
}
function clearBuffer1(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i = bufferedIndex;
    state.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop5 : (err)=>{
            for(let n = i; n < buffered.length; ++n){
                buffered[n].callback(err);
            }
        };
        const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
        chunks.allBuffers = state.allBuffers;
        doWrite1(stream, state, true, state.length, chunks, "", callback);
        resetBuffer1(state);
    } else {
        do {
            const { chunk , encoding , callback: callback1  } = buffered[i];
            buffered[i++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite1(stream, state, false, len, chunk, encoding, callback1);
        }while (i < buffered.length && !state.writing)
        if (i === buffered.length) {
            resetBuffer1(state);
        } else if (i > 256) {
            buffered.splice(0, i);
            state.bufferedIndex = 0;
        } else {
            state.bufferedIndex = i;
        }
    }
    state.bufferProcessing = false;
}
Writable1.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED1("_write()");
    }
};
Writable1.prototype._writev = null;
Writable1.prototype.end = function(chunk, encoding, cb) {
    const state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err;
    if (chunk !== null && chunk !== undefined) {
        const ret = _write1(this, chunk, encoding);
        if (ret instanceof Error) {
            err = ret;
        }
    }
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    if (err) {} else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe1(this, state, true);
        state.ended = true;
    } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED1("end");
    } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED1("end");
    }
    if (typeof cb === "function") {
        if (err || state.finished) {
            nextTick4(cb, err);
        } else {
            state[kOnFinished1].push(cb);
        }
    }
    return this;
};
function needFinish1(state) {
    return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal1(stream, state) {
    let called = false;
    function onFinish(err) {
        if (called) {
            errorOrDestroy5(stream, err ?? ERR_MULTIPLE_CALLBACK1());
            return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
            const onfinishCallbacks = state[kOnFinished1].splice(0);
            for(let i = 0; i < onfinishCallbacks.length; i++){
                onfinishCallbacks[i](err);
            }
            errorOrDestroy5(stream, err, state.sync);
        } else if (needFinish1(state)) {
            state.prefinished = true;
            stream.emit("prefinish");
            state.pendingcb++;
            nextTick3(finish1, stream, state);
        }
    }
    state.sync = true;
    state.pendingcb++;
    try {
        const result = stream._final(onFinish);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick3(onFinish, null);
                }, function(err) {
                    nextTick3(onFinish, err);
                });
            }
        }
    } catch (err) {
        onFinish(stream, state, err);
    }
    state.sync = false;
}
function prefinish2(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.finalCalled = true;
            callFinal1(stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe1(stream, state, sync) {
    if (needFinish1(state)) {
        prefinish2(stream, state);
        if (state.pendingcb === 0 && needFinish1(state)) {
            state.pendingcb++;
            if (sync) {
                nextTick3(finish1, stream, state);
            } else {
                finish1(stream, state);
            }
        }
    }
}
function finish1(stream, state) {
    state.pendingcb--;
    state.finished = true;
    const onfinishCallbacks = state[kOnFinished1].splice(0);
    for(let i = 0; i < onfinishCallbacks.length; i++){
        onfinishCallbacks[i]();
    }
    stream.emit("finish");
    if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable1.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w = this._writableState;
            return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy4 = __default15.destroy;
Writable1.prototype.destroy = function(err, cb) {
    const state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished1].length)) {
        nextTick4(errorBuffer1, state);
    }
    destroy4.call(this, err, cb);
    return this;
};
Writable1.prototype._undestroy = __default15.undestroy;
Writable1.prototype._destroy = function(err, cb) {
    cb(err);
};
Writable1.prototype[EventEmitter1.captureRejectionSymbol] = function(err) {
    this.destroy(err);
};
Writable1.WritableState = WritableState1;
Object.setPrototypeOf(Duplex1.prototype, Readable1.prototype);
Object.setPrototypeOf(Duplex1, Readable1);
{
    for (const method1 of Object.keys(Writable1.prototype)){
        if (!Duplex1.prototype[method1]) {
            Duplex1.prototype[method1] = Writable1.prototype[method1];
        }
    }
}function Duplex1(options) {
    if (!(this instanceof Duplex1)) {
        return new Duplex1(options);
    }
    Readable1.call(this, options);
    Writable1.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex1.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable1.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
function isReadableStream1(object) {
    return object instanceof ReadableStream;
}
function isWritableStream1(object) {
    return object instanceof WritableStream;
}
Duplex1.fromWeb = function(pair, options) {
    validateObject1(pair, "pair");
    const { readable: readableStream , writable: writableStream ,  } = pair;
    if (!isReadableStream1(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE1("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream1(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE1("pair.writable", "WritableStream", writableStream);
    }
    validateObject1(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding , decodeStrings =true , highWaterMark , signal ,  } = options;
    validateBoolean1(objectMode, "options.objectMode");
    if (encoding !== undefined && !Buffer1.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE1(encoding, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex = new Duplex1({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error1) {
                    nextTick4(()=>destroy(duplex, error1));
                }
            }
            writer.ready.then(()=>Promise.All(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer1.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    destroy(duplex, error1);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick4(()=>destroy(duplex, error1));
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex.push(null);
                } else {
                    duplex.push(chunk.value);
                }
            }, (error)=>destroy(duplex, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error1) {
                    nextTick4(()=>{
                        throw error1;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.All([
                    closeWriter(),
                    closeReader(), 
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded1(duplex)) {
            destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE1());
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex, error);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded3(duplex)) {
            duplex.push(null);
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex, error);
    });
    return duplex;
};
class Duplexify1 extends Duplex1 {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify1(body, name) {
    if (isDuplexNodeStream1(body)) {
        return body;
    }
    if (isReadableNodeStream1(body)) {
        return _duplexify1({
            readable: body
        });
    }
    if (isWritableNodeStream1(body)) {
        return _duplexify1({
            writable: body
        });
    }
    if (isNodeStream1(body)) {
        return _duplexify1({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write , final: __final , destroy: destroy1  } = fromAsyncGen1(body);
        if (isIterable1(value)) {
            return _from3(Duplexify1, value, {
                objectMode: true,
                write,
                final: __final,
                destroy: destroy1
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE1("nully", "body", val);
                }
            }, (err)=>{
                destroyer2(d, err);
            });
            return d = new Duplexify1({
                objectMode: true,
                readable: false,
                write,
                final (cb) {
                    __final(async ()=>{
                        try {
                            await promise;
                            nextTick4(cb, null);
                        } catch (err) {
                            nextTick4(cb, err);
                        }
                    });
                },
                destroy: destroy1
            });
        }
        throw new ERR_INVALID_RETURN_VALUE1("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob1(body)) {
        return duplexify1(body.arrayBuffer());
    }
    if (isIterable1(body)) {
        return _from3(Duplexify1, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream1(body?.readable) ? body?.readable : duplexify1(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream1(body?.writable) ? body?.writable : duplexify1(body.writable) : undefined;
        return _duplexify1({
            readable,
            writable
        });
    }
    const then1 = body?.then;
    if (typeof then1 === "function") {
        let d1;
        then1.call(body, (val)=>{
            if (val != null) {
                d1.push(val);
            }
            d1.push(null);
        }, (err)=>{
            destroyer2(d1, err);
        });
        return d1 = new Duplexify1({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE1(name, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen1(fn) {
    let { promise , resolve  } = createDeferredPromise1();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick3(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError1();
            ({ promise , resolve  } = createDeferredPromise1());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve;
            resolve = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err, cb) {
            ac.abort();
            cb(err);
        }
    };
}
function _duplexify1(pair) {
    const r = pair.readable && typeof pair.readable.read !== "function" ? Readable1.wrap(pair.readable) : pair.readable;
    const w = pair.writable;
    let readable = !!isReadable3(r);
    let writable = !!isWritable3(w);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    d = new Duplexify1({
        readableObjectMode: !!r?.readableObjectMode,
        writableObjectMode: !!w?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos1(w, (err)=>{
            writable = false;
            if (err) {
                destroyer2(r, err);
            }
            onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
            if (w.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            w.end();
            onfinish = callback;
        };
        w.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos1(r, (err)=>{
            readable = false;
            if (err) {
                destroyer2(r, err);
            }
            onfinished(err);
        });
        r.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = r.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError1();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer2(w, err);
            destroyer2(r, err);
        }
    };
    return d;
}
function duplexFrom1(body) {
    return duplexify1(body, "body");
}
Duplex1.from = duplexFrom1;
Object.setPrototypeOf(Transform1.prototype, Duplex1.prototype);
Object.setPrototypeOf(Transform1, Duplex1);
const kCallback1 = Symbol("kCallback");
function Transform1(options) {
    if (!(this instanceof Transform1)) {
        return new Transform1(options);
    }
    Duplex1.call(this, options);
    this._readableState.sync = false;
    this[kCallback1] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish3);
}
function __final1(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data != null) {
                this.push(data);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data)=>{
                        if (called) {
                            return;
                        }
                        if (data != null) {
                            this.push(data);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick3(cb);
                        }
                    }, (err)=>{
                        if (cb) {
                            nextTick3(cb, err);
                        } else {
                            nextTick3(()=>this.destroy(err));
                        }
                    });
                }
            } catch (err) {
                nextTick3(()=>this.destroy(err));
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish3() {
    if (this._final !== __final1) {
        __final1.call(this);
    }
}
Transform1.prototype._final = __final1;
Transform1.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED1("_transform()");
};
Transform1.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err, val)=>{
        called = true;
        if (err) {
            callback(err);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback1] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick4(callback);
                    } else {
                        this[kCallback1] = callback;
                    }
                }, (err)=>{
                    nextTick4(callback, err);
                });
            }
        } catch (err) {
            nextTick4(callback, err);
        }
    }
};
Transform1.prototype._read = function() {
    if (this[kCallback1]) {
        const callback = this[kCallback1];
        this[kCallback1] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough1.prototype, Transform1.prototype);
Object.setPrototypeOf(PassThrough1, Transform1);
function PassThrough1(options) {
    if (!(this instanceof PassThrough1)) {
        return new PassThrough1(options);
    }
    Transform1.call(this, options);
}
PassThrough1.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer3(stream, reading, writing, callback) {
    callback = once2(callback);
    let finished = false;
    stream.on("close", ()=>{
        finished = true;
    });
    eos1(stream, {
        readable: reading,
        writable: writing
    }, (err)=>{
        finished = !err;
        const rState = stream._readableState;
        if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err);
        }
    });
    return (err)=>{
        if (finished) return;
        finished = true;
        __default15.destroyer(stream, err);
        callback(err || new ERR_STREAM_DESTROYED1("pipe"));
    };
}
function popCallback1(streams) {
    validateCallback1(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable1(val) {
    if (isIterable1(val)) {
        return val;
    } else if (isReadableNodeStream1(val)) {
        return fromReadable1(val);
    }
    throw new ERR_INVALID_ARG_TYPE1("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable1(val) {
    yield* Readable1.prototype[Symbol.asyncIterator].call(val);
}
async function pump1(iterable, writable, finish) {
    let error;
    let onresolve = null;
    const resume = (err)=>{
        if (err) {
            error = err;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve, reject)=>{
            if (error) {
                reject(error);
            } else {
                onresolve = ()=>{
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                };
            }
        });
    writable.on("drain", resume);
    const cleanup = eos1(writable, {
        readable: false
    }, resume);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish();
    } catch (err) {
        finish(error !== err ? aggregateTwoErrors1(error, err) : err);
    } finally{
        cleanup();
        writable.off("drain", resume);
    }
}
function pipeline2(...streams) {
    const callback = once2(popCallback1(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl1(streams, callback);
}
function pipelineImpl1(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS1("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal2(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError1());
    }
    outerSignal?.addEventListener("abort", abort);
    let error;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish(err) {
        finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, __final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error = err;
        }
        if (!error && !__final) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final) {
            callback(error, value);
        }
    }
    let ret;
    for(let i = 0; i < streams.length; i++){
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        if (isNodeStream1(stream)) {
            finishCount++;
            destroys.push(destroyer3(stream, reading, writing, finish));
        }
        if (i === 0) {
            if (typeof stream === "function") {
                ret = stream({
                    signal
                });
                if (!isIterable1(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE1("Iterable, AsyncIterable or Stream", "source", ret);
                }
            } else if (isIterable1(stream) || isReadableNodeStream1(stream)) {
                ret = stream;
            } else {
                ret = Duplex1.from(stream);
            }
        } else if (typeof stream === "function") {
            ret = makeAsyncIterable1(ret);
            ret = stream(ret, {
                signal
            });
            if (reading) {
                if (!isIterable1(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE1("AsyncIterable", `transform[${i - 1}]`, ret);
                }
            } else {
                const pt = new PassThrough1({
                    objectMode: true
                });
                const then = ret?.then;
                if (typeof then === "function") {
                    then.call(ret, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err)=>{
                        pt.destroy(err);
                    });
                } else if (isIterable1(ret, true)) {
                    finishCount++;
                    pump1(ret, pt, finish);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE1("AsyncIterable or Promise", "destination", ret);
                }
                ret = pt;
                finishCount++;
                destroys.push(destroyer3(ret, false, true, finish));
            }
        } else if (isNodeStream1(stream)) {
            if (isReadableNodeStream1(ret)) {
                ret.pipe(stream);
                if (stream === stdio1.stdout || stream === stdio1.stderr) {
                    ret.on("end", ()=>stream.end());
                }
            } else {
                ret = makeAsyncIterable1(ret);
                finishCount++;
                pump1(ret, stream, finish);
            }
            ret = stream;
        } else {
            ret = Duplex1.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick3(abort);
    }
    return ret;
}
class ComposeDuplex1 extends Duplex1 {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose1(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS1("streams");
    }
    if (streams.length === 1) {
        return Duplex1.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex1.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex1.from(streams[idx]);
    }
    for(let n = 0; n < streams.length; ++n){
        if (!isNodeStream1(streams[n])) {
            continue;
        }
        if (n < streams.length - 1 && !isReadable3(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE1(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable3(streams[n])) {
            throw new ERR_INVALID_ARG_VALUE1(`streams[${n}]`, orgStreams[n], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d;
    function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err);
        } else if (err) {
            d.destroy(err);
        } else if (!readable && !writable) {
            d.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline2(streams, onfinished);
    const writable = !!isWritable3(head);
    const readable = !!isReadable3(tail);
    d = new ComposeDuplex1({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d.push(null);
        });
        d._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d._read;
                    return;
                }
                if (!d.push(buf)) {
                    return;
                }
            }
        };
    }
    d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
            err = new AbortError1();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err);
        } else {
            onclose = callback;
            destroyer2(tail, err);
        }
    };
    return d;
}
function pipeline3(...streams) {
    return new Promise((resolve, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream1(lastArg) && !isIterable1(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl1(streams, (err, value)=>{
            if (err) {
                reject(err);
            } else {
                resolve(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished1(stream, opts) {
    return new Promise((resolve, reject)=>{
        eos1(stream, opts, (err)=>{
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}
const __default17 = {
    finished: finished1,
    pipeline: pipeline3
};
const { custom: customPromisify1  } = promisify1;
Stream1.isDisturbed = isDisturbed1;
Stream1.Readable = Readable1;
Stream1.Writable = Writable1;
Stream1.Duplex = Duplex1;
Stream1.Transform = Transform1;
Stream1.PassThrough = PassThrough1;
Stream1.pipeline = pipeline2;
Stream1.addAbortSignal = addAbortSignal1;
Stream1.finished = eos1;
Stream1.destroy = destroyer2;
Stream1.compose = compose1;
Object.defineProperty(Stream1, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default17;
    }
});
Object.defineProperty(pipeline2, customPromisify1, {
    enumerable: true,
    get () {
        return __default17.pipeline;
    }
});
Object.defineProperty(eos1, customPromisify1, {
    enumerable: true,
    get () {
        return __default17.finished;
    }
});
Stream1.Stream = Stream1;
Stream1._isUint8Array = isUint8Array1;
Stream1._uint8ArrayToBuffer = _uint8ArrayToBuffer1;
function createWritableStdioStream1(writer, name) {
    const stream = new Writable1({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer1.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close"));
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close());
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : undefined
        }
    });
    return stream;
}
const stderr1 = stdio1.stderr = createWritableStdioStream1(Deno.stderr, "stderr");
const stdout1 = stdio1.stdout = createWritableStdioStream1(Deno.stdout, "stdout");
const stdin1 = stdio1.stdin = new Readable1({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p = Buffer1.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p).then((length)=>{
            this.push(length === null ? null : p.slice(0, length));
        }, (error)=>{
            this.destroy(error);
        });
    }
});
stdin1.on("close", ()=>Deno.stdin?.close());
stdin1.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin1, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin1._isRawMode = false;
stdin1.setRawMode = (enable)=>{
    setRaw1?.(Deno.stdin?.rid, enable);
    stdin1._isRawMode = enable;
    return stdin1;
};
Object.defineProperty(stdin1, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin1._isRawMode;
    }
});
function registerDestroyHook1(_target, _asyncId, _prop) {}
var constants4;
(function(constants) {
    constants[constants["kInit"] = 0] = "kInit";
    constants[constants["kBefore"] = 1] = "kBefore";
    constants[constants["kAfter"] = 2] = "kAfter";
    constants[constants["kDestroy"] = 3] = "kDestroy";
    constants[constants["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants[constants["kTotals"] = 5] = "kTotals";
    constants[constants["kCheck"] = 6] = "kCheck";
    constants[constants["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants[constants["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants[constants["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants[constants["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants[constants["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants[constants["kStackLength"] = 12] = "kStackLength";
})(constants4 || (constants4 = {}));
const asyncHookFields1 = new Uint32Array(Object.keys(constants4).length);
function newAsyncId1() {
    return ++asyncIdFields1[constants4.kAsyncIdCounter];
}
var UidFields1;
(function(UidFields) {
    UidFields[UidFields["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields[UidFields["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields[UidFields["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields[UidFields["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields[UidFields["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields1 || (UidFields1 = {}));
const asyncIdFields1 = new Float64Array(Object.keys(UidFields1).length);
asyncIdFields1[UidFields1.kAsyncIdCounter] = 1;
asyncIdFields1[UidFields1.kDefaultTriggerAsyncId] = -1;
var providerType1;
(function(providerType) {
    providerType[providerType["NONE"] = 0] = "NONE";
    providerType[providerType["DIRHANDLE"] = 1] = "DIRHANDLE";
    providerType[providerType["DNSCHANNEL"] = 2] = "DNSCHANNEL";
    providerType[providerType["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
    providerType[providerType["FILEHANDLE"] = 4] = "FILEHANDLE";
    providerType[providerType["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
    providerType[providerType["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
    providerType[providerType["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
    providerType[providerType["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
    providerType[providerType["FSREQPROMISE"] = 9] = "FSREQPROMISE";
    providerType[providerType["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
    providerType[providerType["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
    providerType[providerType["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
    providerType[providerType["HTTP2SESSION"] = 13] = "HTTP2SESSION";
    providerType[providerType["HTTP2STREAM"] = 14] = "HTTP2STREAM";
    providerType[providerType["HTTP2PING"] = 15] = "HTTP2PING";
    providerType[providerType["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
    providerType[providerType["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
    providerType[providerType["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
    providerType[providerType["JSSTREAM"] = 19] = "JSSTREAM";
    providerType[providerType["JSUDPWRAP"] = 20] = "JSUDPWRAP";
    providerType[providerType["MESSAGEPORT"] = 21] = "MESSAGEPORT";
    providerType[providerType["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
    providerType[providerType["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
    providerType[providerType["PIPEWRAP"] = 24] = "PIPEWRAP";
    providerType[providerType["PROCESSWRAP"] = 25] = "PROCESSWRAP";
    providerType[providerType["PROMISE"] = 26] = "PROMISE";
    providerType[providerType["QUERYWRAP"] = 27] = "QUERYWRAP";
    providerType[providerType["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
    providerType[providerType["SIGNALWRAP"] = 29] = "SIGNALWRAP";
    providerType[providerType["STATWATCHER"] = 30] = "STATWATCHER";
    providerType[providerType["STREAMPIPE"] = 31] = "STREAMPIPE";
    providerType[providerType["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
    providerType[providerType["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
    providerType[providerType["TCPWRAP"] = 34] = "TCPWRAP";
    providerType[providerType["TTYWRAP"] = 35] = "TTYWRAP";
    providerType[providerType["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
    providerType[providerType["UDPWRAP"] = 37] = "UDPWRAP";
    providerType[providerType["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
    providerType[providerType["WORKER"] = 39] = "WORKER";
    providerType[providerType["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
    providerType[providerType["WRITEWRAP"] = 41] = "WRITEWRAP";
    providerType[providerType["ZLIB"] = 42] = "ZLIB";
})(providerType1 || (providerType1 = {}));
const kInvalidAsyncId1 = -1;
class AsyncWrap1 {
    provider = providerType1.NONE;
    asyncId = kInvalidAsyncId1;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId1 ? newAsyncId1() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod66 = {
    async_hook_fields: asyncHookFields1,
    asyncIdFields: asyncIdFields1,
    registerDestroyHook: registerDestroyHook1,
    constants: constants4,
    newAsyncId: newAsyncId1,
    UidFields: UidFields1,
    providerType: providerType1,
    AsyncWrap: AsyncWrap1
};
const mod67 = {};
const v4Seg1 = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str1 = `(${v4Seg1}[.]){3}${v4Seg1}`;
const IPv4Reg1 = new RegExp(`^${v4Str1}$`);
const v6Seg1 = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg1 = new RegExp("^(" + `(?:${v6Seg1}:){7}(?:${v6Seg1}|:)|` + `(?:${v6Seg1}:){6}(?:${v4Str1}|:${v6Seg1}|:)|` + `(?:${v6Seg1}:){5}(?::${v4Str1}|(:${v6Seg1}){1,2}|:)|` + `(?:${v6Seg1}:){4}(?:(:${v6Seg1}){0,1}:${v4Str1}|(:${v6Seg1}){1,3}|:)|` + `(?:${v6Seg1}:){3}(?:(:${v6Seg1}){0,2}:${v4Str1}|(:${v6Seg1}){1,4}|:)|` + `(?:${v6Seg1}:){2}(?:(:${v6Seg1}){0,3}:${v4Str1}|(:${v6Seg1}){1,5}|:)|` + `(?:${v6Seg1}:){1}(?:(:${v6Seg1}){0,4}:${v4Str1}|(:${v6Seg1}){1,6}|:)|` + `(?::((?::${v6Seg1}){0,5}:${v4Str1}|(?::${v6Seg1}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv41(ip) {
    return RegExp.prototype.test.call(IPv4Reg1, ip);
}
function isIPv61(ip) {
    return RegExp.prototype.test.call(IPv6Reg1, ip);
}
function isIP1(ip) {
    if (isIPv41(ip)) {
        return 4;
    }
    if (isIPv61(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
function ares_strerror1(code) {
    const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled", 
    ];
    if (code >= 0 && code < errorText.length) {
        return errorText[code];
    } else {
        return "unknown";
    }
}
class GetAddrInfoReqWrap1 extends AsyncWrap1 {
    family;
    hostname;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType1.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo1(req, hostname, family, _hints, verbatim) {
    let addresses = [];
    const recordTypes = [];
    if (family === 0 || family === 4) {
        recordTypes.push("A");
    }
    if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
    }
    (async ()=>{
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record));
            })));
        const error = addresses.length ? 0 : codeMap1.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv41(a)) {
                    return -1;
                } else if (isIPv41(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (isWindows1 && hostname === "localhost") {
            addresses = addresses.filter((address)=>isIPv41(address));
        }
        req.oncomplete(error, addresses);
    })();
    return 0;
}
class QueryReqWrap1 extends AsyncWrap1 {
    bindingName;
    hostname;
    ttl;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType1.QUERYWRAP);
    }
}
function fqdnToHostname1(fqdn) {
    return fqdn.replace(/\.$/, "");
}
function compressIPv61(address) {
    const formatted = address.replace(/\b(?:0+:){2,}/, ":");
    const finalAddress = formatted.split(":").map((octet)=>{
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
    }).join(":");
    return finalAddress;
}
class ChannelWrap1 extends AsyncWrap1 {
    #servers = [];
    #timeout;
    #tries;
    constructor(timeout, tries){
        super(providerType1.DNSCHANNEL);
        this.#timeout = timeout;
        this.#tries = tries;
    }
    async #query(query2, recordType2) {
        let code2;
        let ret2;
        if (this.#servers.length) {
            for (const [ipAddr1, port3] of this.#servers){
                const resolveOptions2 = {
                    nameServer: {
                        ipAddr: ipAddr1,
                        port: port3
                    }
                };
                ({ code: code2 , ret: ret2  } = await this.#resolve(query2, recordType2, resolveOptions2));
                if (code2 === 0 || code2 === codeMap1.get("EAI_NODATA")) {
                    break;
                }
            }
        } else {
            ({ code: code2 , ret: ret2  } = await this.#resolve(query2, recordType2));
        }
        return {
            code: code2,
            ret: ret2
        };
    }
    async #resolve(query11, recordType11, resolveOptions11) {
        let ret11 = [];
        let code12 = 0;
        try {
            ret11 = await Deno.resolveDns(query11, recordType11, resolveOptions11);
        } catch (e6) {
            if (e6 instanceof Deno.errors.NotFound) {
                code12 = codeMap1.get("EAI_NODATA");
            } else {
                code12 = codeMap1.get("UNKNOWN");
            }
        }
        return {
            code: code12,
            ret: ret11
        };
    }
    queryAny(req, name) {
        (async ()=>{
            const records = [];
            await Promise.allSettled([
                this.#query(name, "A").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "A",
                            address: record
                        }));
                }),
                this.#query(name, "AAAA").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "AAAA",
                            address: compressIPv61(record)
                        }));
                }),
                this.#query(name, "CAA").then(({ ret  })=>{
                    ret.forEach(({ critical , tag , value  })=>records.push({
                            type: "CAA",
                            [tag]: value,
                            critical: +critical && 128
                        }));
                }),
                this.#query(name, "CNAME").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "CNAME",
                            value: record
                        }));
                }),
                this.#query(name, "MX").then(({ ret  })=>{
                    ret.forEach(({ preference , exchange  })=>records.push({
                            type: "MX",
                            priority: preference,
                            exchange: fqdnToHostname1(exchange)
                        }));
                }),
                this.#query(name, "NAPTR").then(({ ret  })=>{
                    ret.forEach(({ order , preference , flags , services , regexp , replacement  })=>records.push({
                            type: "NAPTR",
                            order,
                            preference,
                            flags,
                            service: services,
                            regexp,
                            replacement
                        }));
                }),
                this.#query(name, "NS").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "NS",
                            value: fqdnToHostname1(record)
                        }));
                }),
                this.#query(name, "PTR").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "PTR",
                            value: fqdnToHostname1(record)
                        }));
                }),
                this.#query(name, "SOA").then(({ ret  })=>{
                    ret.forEach(({ mname , rname , serial , refresh , retry , expire , minimum  })=>records.push({
                            type: "SOA",
                            nsname: fqdnToHostname1(mname),
                            hostmaster: fqdnToHostname1(rname),
                            serial,
                            refresh,
                            retry,
                            expire,
                            minttl: minimum
                        }));
                }),
                this.#query(name, "SRV").then(({ ret  })=>{
                    ret.forEach(({ priority , weight , port , target  })=>records.push({
                            type: "SRV",
                            priority,
                            weight,
                            port,
                            name: target
                        }));
                }),
                this.#query(name, "TXT").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "TXT",
                            entries: record
                        }));
                }), 
            ]);
            const err = records.length ? 0 : codeMap1.get("EAI_NODATA");
            req.oncomplete(err, records);
        })();
        return 0;
    }
    queryA(req, name) {
        this.#query(name, "A").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryAaaa(req, name) {
        this.#query(name, "AAAA").then(({ code , ret  })=>{
            const records = ret.map((record)=>compressIPv61(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCaa(req, name) {
        this.#query(name, "CAA").then(({ code , ret  })=>{
            const records = ret.map(({ critical , tag , value  })=>({
                    [tag]: value,
                    critical: +critical && 128
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCname(req, name) {
        this.#query(name, "CNAME").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryMx(req, name) {
        this.#query(name, "MX").then(({ code , ret  })=>{
            const records = ret.map(({ preference , exchange  })=>({
                    priority: preference,
                    exchange: fqdnToHostname1(exchange)
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNaptr(req, name) {
        this.#query(name, "NAPTR").then(({ code , ret  })=>{
            const records = ret.map(({ order , preference , flags , services , regexp , replacement  })=>({
                    flags,
                    service: services,
                    regexp,
                    replacement,
                    order,
                    preference
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNs(req, name) {
        this.#query(name, "NS").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname1(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryPtr(req, name) {
        this.#query(name, "PTR").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname1(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    querySoa(req, name) {
        this.#query(name, "SOA").then(({ code , ret  })=>{
            let record = {};
            if (ret.length) {
                const { mname , rname , serial , refresh , retry , expire , minimum  } = ret[0];
                record = {
                    nsname: fqdnToHostname1(mname),
                    hostmaster: fqdnToHostname1(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum
                };
            }
            req.oncomplete(code, record);
        });
        return 0;
    }
    querySrv(req, name) {
        this.#query(name, "SRV").then(({ code , ret  })=>{
            const records = ret.map(({ priority , weight , port , target  })=>({
                    priority,
                    weight,
                    port,
                    name: target
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryTxt(req, name) {
        this.#query(name, "TXT").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    getHostByAddr(_req, _name) {
        notImplemented1("cares.ChannelWrap.prototype.getHostByAddr");
    }
    getServers() {
        return this.#servers;
    }
    setServers(servers) {
        if (typeof servers === "string") {
            const tuples = [];
            for(let i = 0; i < servers.length; i += 2){
                tuples.push([
                    servers[i],
                    parseInt(servers[i + 1])
                ]);
            }
            this.#servers = tuples;
        } else {
            this.#servers = servers.map(([_ipVersion, ip, port])=>[
                    ip,
                    port
                ]);
        }
        return 0;
    }
    setLocalAddress(_addr0, _addr1) {
        notImplemented1("cares.ChannelWrap.prototype.setLocalAddress");
    }
    cancel() {
        notImplemented1("cares.ChannelWrap.prototype.cancel");
    }
}
const DNS_ESETSRVPENDING1 = -1000;
const EMSG_ESETSRVPENDING1 = "There are pending queries.";
function strerror1(code) {
    return code === DNS_ESETSRVPENDING1 ? EMSG_ESETSRVPENDING1 : ares_strerror1(code);
}
const mod68 = {
    GetAddrInfoReqWrap: GetAddrInfoReqWrap1,
    getaddrinfo: getaddrinfo1,
    QueryReqWrap: QueryReqWrap1,
    ChannelWrap: ChannelWrap1,
    strerror: strerror1
};
const mod69 = {};
const timingSafeEqual1 = (a, b)=>{
    if (a instanceof DataView) a = Buffer1.from(a.buffer);
    if (b instanceof DataView) b = Buffer1.from(b.buffer);
    if (a instanceof ArrayBuffer) a = Buffer1.from(a);
    if (b instanceof ArrayBuffer) b = Buffer1.from(b);
    let result = 0;
    if (a.byteLength !== b.byteLength) {
        b = a;
        result = 1;
    }
    for(let i = 0; i < a.byteLength; i++){
        result |= a[i] ^ b[i];
    }
    return result === 0;
};
function getFipsCrypto1() {
    notImplemented1("crypto.getFipsCrypto");
}
function setFipsCrypto1(_fips) {
    notImplemented1("crypto.setFipsCrypto");
}
const mod70 = {
    timingSafeEqual: timingSafeEqual1,
    getFipsCrypto: getFipsCrypto1,
    setFipsCrypto: setFipsCrypto1
};
const mod71 = {};
const mod72 = {};
const mod73 = {};
const mod74 = {};
const mod75 = {};
const mod76 = {};
const mod77 = {};
const mod78 = {};
const mod79 = {};
const mod80 = {};
const mod81 = {};
const mod82 = {};
const mod83 = {};
const mod84 = {};
const mod85 = {};
const mod86 = {};
class HandleWrap1 extends AsyncWrap1 {
    constructor(provider){
        super(provider);
    }
    close(cb = ()=>{}) {
        this._onClose();
        cb();
    }
    ref() {
        unreachable1();
    }
    unref() {
        unreachable1();
    }
    _onClose() {}
}
const MIN_BUF_SIZE1 = 16;
const CR1 = "\r".charCodeAt(0);
const LF1 = "\n".charCodeAt(0);
class BufferFullError1 extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError1 extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader1 {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader1 ? r : new BufReader1(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE1;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert3(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr1 = await this.#rd.read(p);
                const nread = rr1 ?? 0;
                assert3(nread >= 0, "negative read");
                return rr1;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert3(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy1(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError1();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError1) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError1();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF1);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError1) {
                partial = err.partial;
                assert3(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError1)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR1) {
                assert3(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF1) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR1) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError1(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError1) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError1();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError1) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError1();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError1(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
class AbstractBufBase1 {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter1 extends AbstractBufBase1 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter1 ? writer : new BufWriter1(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync1 extends AbstractBufBase1 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync1 ? writer : new BufWriterSync1(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy1(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy1(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
async function writeAll1(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
var StreamBaseStateFields1;
(function(StreamBaseStateFields) {
    StreamBaseStateFields[StreamBaseStateFields["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields[StreamBaseStateFields["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields[StreamBaseStateFields["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields[StreamBaseStateFields["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields[StreamBaseStateFields["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields1 || (StreamBaseStateFields1 = {}));
const kReadBytesOrError1 = StreamBaseStateFields1.kReadBytesOrError;
const kArrayBufferOffset1 = StreamBaseStateFields1.kArrayBufferOffset;
const kBytesWritten1 = StreamBaseStateFields1.kBytesWritten;
const kLastWriteWasAsync1 = StreamBaseStateFields1.kLastWriteWasAsync;
const kNumStreamBaseStateFields1 = StreamBaseStateFields1.kNumStreamBaseStateFields;
const streamBaseState1 = new Uint8Array(5);
streamBaseState1[kLastWriteWasAsync1] = 1;
class WriteWrap1 extends AsyncWrap1 {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType1.WRITEWRAP);
    }
}
class ShutdownWrap1 extends AsyncWrap1 {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType1.SHUTDOWNWRAP);
    }
}
const kStreamBaseField1 = Symbol("kStreamBaseField");
const SUGGESTED_SIZE1 = 64 * 1024;
class LibuvStreamWrap1 extends HandleWrap1 {
    [kStreamBaseField1];
    reading;
    #reading = false;
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            this.#read();
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        const status = this._onClose();
        try {
            req.oncomplete(status);
        } catch  {}
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented1("LibuvStreamWrap.prototype.useUserBuffer");
    }
    writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
    }
    writev(req, chunks, allBuffers) {
        const count = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count);
        if (!allBuffers) {
            for(let i = 0; i < count; i++){
                const chunk = chunks[i * 2];
                if (Buffer1.isBuffer(chunk)) {
                    buffers[i] = chunk;
                }
                const encoding = chunks[i * 2 + 1];
                buffers[i] = Buffer1.from(chunk, encoding);
            }
        } else {
            for(let i1 = 0; i1 < count; i1++){
                buffers[i1] = chunks[i1];
            }
        }
        return this.writeBuffer(req, Buffer1.concat(buffers));
    }
    writeAsciiString(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented1("LibuvStreamWrap.prototype.writeUcs2String");
    }
    writeLatin1String(req, data) {
        const buffer = Buffer1.from(data, "latin1");
        return this.writeBuffer(req, buffer);
    }
    _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField1]?.close();
        } catch  {
            status = codeMap1.get("ENOTCONN");
        }
        return status;
    }
     #attachToObject(stream1) {
        this[kStreamBaseField1] = stream1;
    }
    async #read() {
        let buf2 = new Uint8Array(SUGGESTED_SIZE1);
        let nread2;
        try {
            nread2 = await this[kStreamBaseField1].read(buf2);
        } catch (e7) {
            if (e7 instanceof Deno.errors.Interrupted || e7 instanceof Deno.errors.BadResource) {
                nread2 = codeMap1.get("EOF");
            } else if (e7 instanceof Deno.errors.ConnectionReset || e7 instanceof Deno.errors.ConnectionAborted) {
                nread2 = codeMap1.get("ECONNRESET");
            } else {
                nread2 = codeMap1.get("UNKNOWN");
            }
            buf2 = new Uint8Array(0);
        }
        nread2 ??= codeMap1.get("EOF");
        streamBaseState1[kReadBytesOrError1] = nread2;
        if (nread2 > 0) {
            this.bytesRead += nread2;
        }
        buf2 = buf2.slice(0, nread2);
        streamBaseState1[kArrayBufferOffset1] = 0;
        try {
            this.onread(buf2, nread2);
        } catch  {}
        if (nread2 >= 0 && this.#reading) {
            this.#read();
        }
    }
    async #write(req3, data1) {
        const { byteLength: byteLength3  } = data1;
        try {
            await writeAll1(this[kStreamBaseField1], data1);
        } catch (e13) {
            let status1;
            if (e13 instanceof Deno.errors.BadResource || e13 instanceof Deno.errors.BrokenPipe) {
                status1 = codeMap1.get("EBADF");
            } else {
                status1 = codeMap1.get("UNKNOWN");
            }
            try {
                req3.oncomplete(status1);
            } catch  {}
            return;
        }
        streamBaseState1[kBytesWritten1] = byteLength3;
        this.bytesWritten += byteLength3;
        try {
            req3.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod87 = {
    kReadBytesOrError: kReadBytesOrError1,
    kArrayBufferOffset: kArrayBufferOffset1,
    kBytesWritten: kBytesWritten1,
    kLastWriteWasAsync: kLastWriteWasAsync1,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields1,
    streamBaseState: streamBaseState1,
    WriteWrap: WriteWrap1,
    ShutdownWrap: ShutdownWrap1,
    kStreamBaseField: kStreamBaseField1,
    LibuvStreamWrap: LibuvStreamWrap1
};
class ConnectionWrap1 extends LibuvStreamWrap1 {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req.oncomplete(status, this, req, readable, writable);
        } catch  {}
        return;
    }
}
function ceilPowOf21(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
const INITIAL_ACCEPT_BACKOFF_DELAY1 = 5;
const MAX_ACCEPT_BACKOFF_DELAY1 = 1000;
var socketType2;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
    socketType[socketType["IPC"] = 2] = "IPC";
})(socketType2 || (socketType2 = {}));
class Pipe1 extends ConnectionWrap1 {
    reading = false;
    ipc;
    #pendingInstances = 4;
    #address;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        let ipc;
        switch(type){
            case socketType2.SOCKET:
                {
                    provider = providerType1.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType2.SERVER:
                {
                    provider = providerType1.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType2.IPC:
                {
                    provider = providerType1.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable1();
                }
        }
        super(provider, conn);
        this.ipc = ipc;
        if (conn && provider === providerType1.PIPEWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.path;
        }
    }
    open(_fd) {
        notImplemented1("Pipe.prototype.open");
    }
    bind(name) {
        this.#address = name;
        return 0;
    }
    connect(req, address) {
        if (isWindows1) {
            notImplemented1("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
            path: address,
            transport: "unix"
        };
        connect1(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req.address = localAddr.path;
            this[kStreamBaseField1] = conn;
            try {
                this.afterConnect(req, 0);
            } catch  {}
        }, (e)=>{
            let code;
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap1.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                code = codeMap1.get("EACCES");
            } else {
                code = codeMap1.get("ECONNREFUSED");
            }
            try {
                this.afterConnect(req, code);
            } catch  {}
        });
        return 0;
    }
    listen(backlog) {
        if (isWindows1) {
            notImplemented1("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows1 ? this.#pendingInstances : ceilPowOf21(backlog + 1);
        const listenOptions = {
            path: this.#address,
            transport: "unix"
        };
        let listener;
        try {
            listener = listen1(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap1.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap1.get("EADDRNOTAVAIL");
            }
            return codeMap1.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            ListenerRef1(this.#listener);
        }
    }
    unref() {
        if (this.#listener) {
            ListenerUnref1(this.#listener);
        }
    }
    setPendingInstances(instances) {
        this.#pendingInstances = instances;
    }
    fchmod(mode) {
        if (mode != constants5.UV_READABLE && mode != constants5.UV_WRITABLE && mode != (constants5.UV_WRITABLE | constants5.UV_READABLE)) {
            return codeMap1.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants5.UV_READABLE) {
            desired_mode |= fs1.S_IRUSR | fs1.S_IRGRP | fs1.S_IROTH;
        }
        if (mode & constants5.UV_WRITABLE) {
            desired_mode |= fs1.S_IWUSR | fs1.S_IWGRP | fs1.S_IWOTH;
        }
        try {
            Deno.chmodSync(this.#address, desired_mode);
        } catch  {
            return codeMap1.get("UNKNOWN");
        }
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY1;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY1;
        }
        await delay1(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection2;
        try {
            connection2 = await this.#listener.accept();
        } catch (e8) {
            if (e8 instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap1.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle2 = new Pipe1(socketType2.SOCKET, connection2);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle2);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType1.PIPESERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap1.prototype._onClose.call(this);
    }
}
class PipeConnectWrap1 extends AsyncWrap1 {
    oncomplete;
    address;
    constructor(){
        super(providerType1.PIPECONNECTWRAP);
    }
}
var constants5;
(function(constants) {
    constants[constants["SOCKET"] = socketType2.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType2.SERVER] = "SERVER";
    constants[constants["IPC"] = socketType2.IPC] = "IPC";
    constants[constants["UV_READABLE"] = 1] = "UV_READABLE";
    constants[constants["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants5 || (constants5 = {}));
const mod88 = {
    socketType: socketType2,
    Pipe: Pipe1,
    PipeConnectWrap: PipeConnectWrap1,
    constants: constants5
};
const mod89 = {};
const mod90 = {};
const mod91 = {};
const mod92 = {};
const mod93 = {};
const mod94 = {};
const asyncIdSymbol1 = Symbol("asyncIdSymbol");
const ownerSymbol1 = Symbol("ownerSymbol");
const mod95 = {
    asyncIdSymbol: asyncIdSymbol1,
    ownerSymbol: ownerSymbol1
};
const mod96 = {};
var socketType3;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
})(socketType3 || (socketType3 = {}));
class TCPConnectWrap1 extends AsyncWrap1 {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType1.TCPCONNECTWRAP);
    }
}
var constants6;
(function(constants) {
    constants[constants["SOCKET"] = socketType3.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType3.SERVER] = "SERVER";
    constants[constants["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants6 || (constants6 = {}));
class TCP1 extends ConnectionWrap1 {
    [ownerSymbol1] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        switch(type){
            case socketType3.SOCKET:
                {
                    provider = providerType1.TCPWRAP;
                    break;
                }
            case socketType3.SERVER:
                {
                    provider = providerType1.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable1();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType1.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP1(remoteAddr.hostname);
        }
    }
    open(_fd) {
        notImplemented1("TCP.prototype.open");
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req, address, port) {
        return this.#connect(req, address, port);
    }
    connect6(req, address, port) {
        return this.#connect(req, address, port);
    }
    listen(backlog) {
        this.#backlog = ceilPowOf21(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap1.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap1.get("EADDRNOTAVAIL");
            }
            return codeMap1.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            ListenerRef1(this.#listener);
        }
    }
    unref() {
        if (this.#listener) {
            ListenerUnref1(this.#listener);
        }
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap1.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP1(this.#address);
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap1.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented1("TCP.prototype.setSimultaneousAccepts");
    }
     #bind(address3, port4, _flags2) {
        this.#address = address3;
        this.#port = port4;
        return 0;
    }
     #connect(req4, address11, port13) {
        this.#remoteAddress = address11;
        this.#remotePort = port13;
        this.#remoteFamily = isIP1(address11);
        const connectOptions1 = {
            hostname: address11,
            port: port13,
            transport: "tcp"
        };
        Deno.connect(connectOptions1).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req4.localAddress = localAddr.hostname;
            this.#port = req4.localPort = localAddr.port;
            this[kStreamBaseField1] = conn;
            try {
                this.afterConnect(req4, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req4, codeMap1.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY1;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY1;
        }
        await delay1(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection3;
        try {
            connection3 = await this.#listener.accept();
        } catch (e9) {
            if (e9 instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap1.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle3 = new TCP1(socketType3.SOCKET, connection3);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle3);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType1.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap1.prototype._onClose.call(this);
    }
}
const mod97 = {
    TCPConnectWrap: TCPConnectWrap1,
    constants: constants6,
    TCP: TCP1
};
const mod98 = {};
const mod99 = {};
const mod100 = {};
const mod101 = {};
const AF_INET61 = 10;
const UDP_DGRAM_MAXSIZE1 = 64 * 1024;
class SendWrap1 extends AsyncWrap1 {
    list;
    address;
    port;
    callback;
    oncomplete;
    constructor(){
        super(providerType1.UDPSENDWRAP);
    }
}
class UDP1 extends HandleWrap1 {
    [ownerSymbol1] = null;
    #address;
    #family;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #listener;
    #receiving = false;
    #recvBufferSize = UDP_DGRAM_MAXSIZE1;
    #sendBufferSize = UDP_DGRAM_MAXSIZE1;
    onmessage;
    lookup;
    constructor(){
        super(providerType1.UDPWRAP);
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented1("udp.UDP.prototype.addMembership");
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented1("udp.UDP.prototype.addSourceSpecificMembership");
    }
    bind(ip, port, flags) {
        return this.#doBind(ip, port, flags, 2);
    }
    bind6(ip, port, flags) {
        return this.#doBind(ip, port, flags, 10);
    }
    bufferSize(size, buffer, ctx) {
        let err;
        if (size > UDP_DGRAM_MAXSIZE1) {
            err = "EINVAL";
        } else if (!this.#address) {
            err = isWindows1 ? "ENOTSOCK" : "EBADF";
        }
        if (err) {
            ctx.errno = codeMap1.get(err);
            ctx.code = err;
            ctx.message = errorMap1.get(ctx.errno)[1];
            ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
            return;
        }
        if (size !== 0) {
            size = isLinux1 ? size * 2 : size;
            if (buffer) {
                return this.#recvBufferSize = size;
            }
            return this.#sendBufferSize = size;
        }
        return buffer ? this.#recvBufferSize : this.#sendBufferSize;
    }
    connect(ip, port) {
        return this.#doConnect(ip, port, 2);
    }
    connect6(ip, port) {
        return this.#doConnect(ip, port, 10);
    }
    disconnect() {
        this.#remoteAddress = undefined;
        this.#remotePort = undefined;
        this.#remoteFamily = undefined;
        return 0;
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented1("udp.UDP.prototype.dropMembership");
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented1("udp.UDP.prototype.dropSourceSpecificMembership");
    }
    getpeername(peername) {
        if (this.#remoteAddress === undefined) {
            return codeMap1.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    getsockname(sockname) {
        if (this.#address === undefined) {
            return codeMap1.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
    }
    open(_fd) {
        notImplemented1("udp.UDP.prototype.open");
    }
    recvStart() {
        if (!this.#receiving) {
            this.#receiving = true;
            this.#receive();
        }
        return 0;
    }
    recvStop() {
        this.#receiving = false;
        return 0;
    }
    ref() {
        notImplemented1("udp.UDP.prototype.ref");
    }
    send(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 2);
    }
    send6(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 10);
    }
    setBroadcast(_bool) {
        notImplemented1("udp.UDP.prototype.setBroadcast");
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented1("udp.UDP.prototype.setMulticastInterface");
    }
    setMulticastLoopback(_bool) {
        notImplemented1("udp.UDP.prototype.setMulticastLoopback");
    }
    setMulticastTTL(_ttl) {
        notImplemented1("udp.UDP.prototype.setMulticastTTL");
    }
    setTTL(_ttl) {
        notImplemented1("udp.UDP.prototype.setTTL");
    }
    unref() {
        notImplemented1("udp.UDP.prototype.unref");
    }
     #doBind(ip2, port5, _flags3, family2) {
        const listenOptions1 = {
            port: port5,
            hostname: ip2,
            transport: "udp"
        };
        let listener1;
        try {
            listener1 = listenDatagram1(listenOptions1);
        } catch (e10) {
            if (e10 instanceof Deno.errors.AddrInUse) {
                return codeMap1.get("EADDRINUSE");
            } else if (e10 instanceof Deno.errors.AddrNotAvailable) {
                return codeMap1.get("EADDRNOTAVAIL");
            }
            return codeMap1.get("UNKNOWN");
        }
        const address4 = listener1.addr;
        this.#address = address4.hostname;
        this.#port = address4.port;
        this.#family = family2 === AF_INET61 ? "IPv6" : "IPv4";
        this.#listener = listener1;
        return 0;
    }
     #doConnect(ip11, port14, family11) {
        this.#remoteAddress = ip11;
        this.#remotePort = port14;
        this.#remoteFamily = family11 === AF_INET61 ? "IPv6" : "IPv4";
        return 0;
    }
     #doSend(req5, bufs1, _count1, args1, _family1) {
        let hasCallback1;
        if (args1.length === 3) {
            this.#remotePort = args1[0];
            this.#remoteAddress = args1[1];
            hasCallback1 = args1[2];
        } else {
            hasCallback1 = args1[0];
        }
        const addr1 = {
            hostname: this.#remoteAddress,
            port: this.#remotePort,
            transport: "udp"
        };
        const payload1 = new Uint8Array(Buffer1.concat(bufs1.map((buf)=>{
            if (typeof buf === "string") {
                return Buffer1.from(buf);
            }
            return Buffer1.from(buf.buffer, buf.byteOffset, buf.byteLength);
        })));
        (async ()=>{
            let sent;
            let err = null;
            try {
                sent = await this.#listener.send(payload1, addr1);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    err = codeMap1.get("EBADF");
                } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
                    err = codeMap1.get("EMSGSIZE");
                } else {
                    err = codeMap1.get("UNKNOWN");
                }
                sent = 0;
            }
            if (hasCallback1) {
                try {
                    req5.oncomplete(err, sent);
                } catch  {}
            }
        })();
        return 0;
    }
    async #receive() {
        if (!this.#receiving) {
            return;
        }
        const p8 = new Uint8Array(this.#recvBufferSize);
        let buf3;
        let remoteAddr1;
        let nread3;
        try {
            [buf3, remoteAddr1] = await this.#listener.receive(p8);
            nread3 = buf3.length;
        } catch (e14) {
            if (e14 instanceof Deno.errors.Interrupted || e14 instanceof Deno.errors.BadResource) {
                nread3 = 0;
            } else {
                nread3 = codeMap1.get("UNKNOWN");
            }
            buf3 = new Uint8Array(0);
            remoteAddr1 = null;
        }
        nread3 ??= 0;
        const rinfo1 = remoteAddr1 ? {
            address: remoteAddr1.hostname,
            port: remoteAddr1.port,
            family: isIP1(remoteAddr1.hostname) === 6 ? "IPv6" : "IPv4"
        } : undefined;
        try {
            this.onmessage(nread3, this, Buffer1.from(buf3), rinfo1);
        } catch  {}
        this.#receive();
    }
    _onClose() {
        this.#receiving = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#family = undefined;
        try {
            this.#listener.close();
        } catch  {}
        this.#listener = undefined;
        return 0;
    }
}
const mod102 = {
    SendWrap: SendWrap1,
    UDP: UDP1
};
const mod103 = {};
const mod104 = {};
const mod105 = {};
const mod106 = {};
const modules1 = {
    "async_wrap": mod66,
    buffer: mod63,
    "cares_wrap": mod68,
    config: mod67,
    constants: mod60,
    contextify: mod69,
    credentials: mod71,
    crypto: mod70,
    errors: mod72,
    fs: mod73,
    "fs_dir": mod74,
    "fs_event_wrap": mod75,
    "heap_utils": mod76,
    "http_parser": mod77,
    icu: mod78,
    inspector: mod79,
    "js_stream": mod80,
    messaging: mod81,
    "module_wrap": mod82,
    "native_module": mod83,
    natives: mod84,
    options: mod85,
    os: mod86,
    performance: mod89,
    "pipe_wrap": mod88,
    "process_methods": mod90,
    report: mod91,
    serdes: mod92,
    "signal_wrap": mod93,
    "spawn_sync": mod94,
    "stream_wrap": mod87,
    "string_decoder": mod62,
    symbols: mod95,
    "task_queue": mod96,
    "tcp_wrap": mod97,
    timers: mod98,
    "tls_wrap": mod99,
    "trace_events": mod100,
    "tty_wrap": mod101,
    types: mod57,
    "udp_wrap": mod102,
    url: mod103,
    util: mod59,
    uv: mod61,
    v8: mod104,
    worker: mod105,
    zlib: mod106
};
function getBinding1(name) {
    const mod = modules1[name];
    if (!mod) {
        throw new Error(`No such module: ${name}`);
    }
    return mod;
}
const kInternal1 = Symbol("internal properties");
const replaceUnderscoresRegex1 = /_/g;
const leadingDashesRegex1 = /^--?/;
const trailingValuesRegex1 = /=.*$/;
function buildAllowedFlags1() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled", 
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex1, "");
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal1] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex1, "-");
                if (leadingDashesRegex1.test(key)) {
                    key = key.replace(trailingValuesRegex1, "");
                    return this[kInternal1].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal1].set ??= new Set(this[kInternal1].array);
            return this[kInternal1].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal1].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ]));
        }
        get size() {
            return this[kInternal1].array.length;
        }
        values() {
            this[kInternal1].set ??= new Set(this[kInternal1].array);
            return this[kInternal1].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const notImplementedEvents1 = [
    "beforeExit",
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "uncaughtException",
    "uncaughtExceptionMonitor",
    "unhandledRejection",
    "worker", 
];
const argv1 = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv1, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv1, "1", {
    get: ()=>fromFileUrl5(Deno.mainModule)
});
const exit1 = (code)=>{
    if (code || code === 0) {
        if (typeof code === "string") {
            const parsedCode = parseInt(code);
            process2.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process2.exitCode = code;
        }
    }
    if (!process2._exiting) {
        process2._exiting = true;
        process2.emit("exit", process2.exitCode || 0);
    }
    Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias1(name, option, enumerable = true) {
    const value = getOptionValue1(option);
    if (value) {
        Object.defineProperty(process2, name, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject1(warning, type, code, ctor, detail) {
    assert3(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type || "Warning");
    if (code !== undefined) {
        warningErr.code = code;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
    return warningErr;
}
function doEmitWarning1(warning) {
    process2.emit("warning", warning);
}
function emitWarning1(warning, type, code, ctor) {
    let detail;
    if (type !== null && typeof type === "object" && !Array.isArray(type)) {
        ctor = type.ctor;
        code = type.code;
        if (typeof type.detail === "string") {
            detail = type.detail;
        }
        type = type.type || "Warning";
    } else if (typeof type === "function") {
        ctor = type;
        code = undefined;
        type = "Warning";
    }
    if (type !== undefined) {
        validateString1(type, "type");
    }
    if (typeof code === "function") {
        ctor = code;
        code = undefined;
    } else if (code !== undefined) {
        validateString1(code, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject1(warning, type, code, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE1("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process2.noDeprecation) {
            return;
        }
        if (process2.throwDeprecation) {
            return process2.nextTick(()=>{
                throw warning;
            });
        }
    }
    process2.nextTick(doEmitWarning1, warning);
}
function hrtime1(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime1.bigint = function() {
    const [sec, nano] = hrtime1();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage1() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage1.rss = function() {
    return memoryUsage1().rss;
};
function kill1(pid, sig = "SIGTERM") {
    if (pid != (pid | 0)) {
        throw new ERR_INVALID_ARG_TYPE1("pid", "number", pid);
    }
    if (typeof sig === "string") {
        try {
            Deno.kill(pid, sig);
        } catch (e) {
            if (e instanceof TypeError) {
                throw new ERR_UNKNOWN_SIGNAL1(sig);
            }
            throw e;
        }
    } else {
        throw new ERR_UNKNOWN_SIGNAL1(sig.toString());
    }
    return true;
}
class Process1 extends EventEmitter1 {
    constructor(){
        super();
        globalThis.addEventListener("unload", ()=>{
            if (!process2._exiting) {
                process2._exiting = true;
                super.emit("exit", process2.exitCode || 0);
            }
        });
    }
    arch = arch1;
    argv = argv1;
    chdir = chdir1;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd1;
    env = env1;
    execArgv = [];
    exit = exit1;
    _exiting = _exiting1;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick3;
    on(event, listener) {
        if (notImplementedEvents1.includes(event)) {
            warnNotImplemented1(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener1(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents1.includes(event)) {
            warnNotImplemented1(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                removeSignalListener1(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents1.includes(event)) {
            warnNotImplemented1(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener1(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid1;
    platform = platform1;
    addListener(event, listener) {
        if (notImplementedEvents1.includes(event)) {
            warnNotImplemented1(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents1.includes(event)) {
            warnNotImplemented1(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime1;
    kill = kill1;
    memoryUsage = memoryUsage1;
    stderr = stderr1;
    stdin = stdin1;
    stdout = stdout1;
    version = version1;
    versions = versions1;
    emitWarning = emitWarning1;
    binding(name) {
        return getBinding1(name);
    }
    umask() {
        return 0o22;
    }
    getuid() {
        return NaN;
    }
    getgid() {
        return NaN;
    }
    _eval = undefined;
    get execPath() {
        return argv1[0];
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags1();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
}
const process2 = new Process1();
Object.defineProperty(process2, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias1("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias1("throwDeprecation", "--throw-deprecation");
process2.removeListener;
process2.removeAllListeners;
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
var s2 = Object.create;
var f2 = Object.defineProperty;
var p9 = Object.getOwnPropertyDescriptor;
var d5 = Object.getOwnPropertyNames;
var w6 = Object.getPrototypeOf, g6 = Object.prototype.hasOwnProperty;
var h4 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var m5 = (r, e, t, a)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of d5(e))!g6.call(r, o) && o !== t && f2(r, o, {
        get: ()=>e[o],
        enumerable: !(a = p9(e, o)) || a.enumerable
    });
    return r;
};
var c4 = (r, e, t)=>(t = r != null ? s2(w6(r)) : {}, m5(e || !r || !r.__esModule ? f2(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r));
var l5 = h4((x, u)=>{
    u.exports = $;
    function $(r, e) {
        if (n("noDeprecation")) return r;
        var t = !1;
        function a() {
            if (!t) {
                if (n("throwDeprecation")) throw new Error(e);
                n("traceDeprecation") ? console.trace(e) : console.warn(e), t = !0;
            }
            return r.apply(this, arguments);
        }
        return a;
    }
    function n(r) {
        try {
            if (!__global$.localStorage) return !1;
        } catch  {
            return !1;
        }
        var e = __global$.localStorage[r];
        return e == null ? !1 : String(e).toLowerCase() === "true";
    }
});
var i6 = c4(l5()), v4 = c4(l5()), { default: D , ...S2 } = v4, y5 = (i6.default ?? D) ?? S2;
var __global$1 = globalThis || (typeof window !== "undefined" ? window : self);
var At = Object.create;
var De1 = Object.defineProperty;
var Ot1 = Object.getOwnPropertyDescriptor;
var Lt1 = Object.getOwnPropertyNames;
var Dt = Object.getPrototypeOf, qt1 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (t, r)=>(typeof require != "undefined" ? require : t)[r]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var c5 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var Pt = (e, t, r, i)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let n of Lt1(t))!qt1.call(e, n) && n !== r && De1(e, n, {
        get: ()=>t[n],
        enumerable: !(i = Ot1(t, n)) || i.enumerable
    });
    return e;
};
var qe1 = (e, t, r)=>(r = e != null ? At(Dt(e)) : {}, Pt(t || !e || !e.__esModule ? De1(r, "default", {
        value: e,
        enumerable: !0
    }) : r, e));
var fe = c5((wi, Pe)=>{
    Pe.exports = EventEmitter1.EventEmitter;
});
var xe = c5((Ri, Ie)=>{
    "use strict";
    function Ne(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function Nt(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Ne(Object(r), !0).forEach(function(i) {
                Ct(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ne(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function Ct(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function It(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Ce(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function xt(e, t, r) {
        return t && Ce(e.prototype, t), r && Ce(e, r), e;
    }
    var kt = export_default, Y = kt.Buffer, jt = __default14, oe = jt.inspect, Wt = oe && oe.custom || "inspect";
    function Ut(e, t, r) {
        Y.prototype.copy.call(e, t, r);
    }
    Ie.exports = function() {
        function e() {
            It(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return xt(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return Y.alloc(0);
                    for(var i = Y.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)Ut(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, o = r > f.length ? f.length : r;
                        if (o === f.length ? a += f : a += f.slice(0, r), r -= o, r === 0) {
                            o === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(o));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = Y.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, o = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, o), r -= o, r === 0) {
                            o === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(o));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: Wt,
                value: function(r, i) {
                    return oe(this, Nt({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var ue = c5((Ei, je)=>{
    "use strict";
    function Bt(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process2.nextTick(le, this, e)) : process2.nextTick(le, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? process2.nextTick($, r) : (r._writableState.errorEmitted = !0, process2.nextTick(ke, r, a)) : process2.nextTick(ke, r, a) : t ? (process2.nextTick($, r), t(a)) : process2.nextTick($, r);
        }), this);
    }
    function ke(e, t) {
        le(e, t), $(e);
    }
    function $(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Ft() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function le(e, t) {
        e.emit("error", t);
    }
    function Ht(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    je.exports = {
        destroy: Bt,
        undestroy: Ft,
        errorOrDestroy: Ht
    };
});
var O1 = c5((Si, Be)=>{
    "use strict";
    function Gt(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var Ue = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, o) {
            return typeof t == "string" ? t : t(a, f, o);
        }
        var n = function(a) {
            Gt(f, a);
            function f(o, d, p) {
                return a.call(this, i(o, d, p)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, Ue[e] = n;
    }
    function We(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function Vt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Yt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function $t(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && Vt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (Yt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(We(t, "type"));
        else {
            var a = $t(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(We(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Be.exports.codes = Ue;
});
var se = c5((Ti, Fe)=>{
    "use strict";
    var Kt = O1().codes.ERR_INVALID_OPT_VALUE;
    function Xt(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function zt(e, t, r, i) {
        var n = Xt(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new Kt(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    Fe.exports = {
        getHighWaterMark: zt
    };
});
var ce = c5((Mi, Ke)=>{
    "use strict";
    Ke.exports = s;
    function Ge(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            Sr(t, e);
        };
    }
    var I;
    s.WritableState = B;
    var Jt = {
        deprecate: y5
    }, Ve = fe(), X = export_default.Buffer, Qt = __global$1.Uint8Array || function() {};
    function Zt(e) {
        return X.from(e);
    }
    function er(e) {
        return X.isBuffer(e) || e instanceof Qt;
    }
    var he = ue(), tr = se(), rr = tr.getHighWaterMark, S = O1().codes, ir = S.ERR_INVALID_ARG_TYPE, nr = S.ERR_METHOD_NOT_IMPLEMENTED, ar = S.ERR_MULTIPLE_CALLBACK, fr = S.ERR_STREAM_CANNOT_PIPE, or = S.ERR_STREAM_DESTROYED, lr = S.ERR_STREAM_NULL_VALUES, ur = S.ERR_STREAM_WRITE_AFTER_END, sr = S.ERR_UNKNOWN_ENCODING, x = he.errorOrDestroy;
    w(s, Ve);
    function dr() {}
    function B(e, t, r) {
        I = I || L3(), e = e || {}, typeof r != "boolean" && (r = t instanceof I), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = rr(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            yr(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ge(this);
    }
    B.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(B.prototype, "buffer", {
                get: Jt.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch  {}
    })();
    var K;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (K = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return K.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof B;
        }
    })) : K = function(t) {
        return t instanceof this;
    };
    function s(e) {
        I = I || L3();
        var t = this instanceof I;
        if (!t && !K.call(s, this)) return new s(e);
        this._writableState = new B(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), Ve.call(this);
    }
    s.prototype.pipe = function() {
        x(this, new fr);
    };
    function hr(e, t) {
        var r = new ur;
        x(e, r), process2.nextTick(t, r);
    }
    function cr(e, t, r, i) {
        var n;
        return r === null ? n = new lr : typeof r != "string" && !t.objectMode && (n = new ir("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (x(e, n), process2.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && er(e);
        return a && !X.isBuffer(e) && (e = Zt(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = dr), i.ending ? hr(this, r) : (a || cr(this, i, e, r)) && (i.pendingcb++, n = br(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Ye(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new sr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function pr(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = X.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function br(e, t, r, i, n, a) {
        if (!r) {
            var f = pr(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var o = t.objectMode ? 1 : i.length;
        t.length += o;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var p = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, p ? p.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else de(e, t, !1, o, i, n, a);
        return d;
    }
    function de(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new or("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function _r(e, t, r, i, n) {
        --t.pendingcb, r ? (process2.nextTick(n, i), process2.nextTick(U, e, t), e._writableState.errorEmitted = !0, x(e, i)) : (n(i), e._writableState.errorEmitted = !0, x(e, i), U(e, t));
    }
    function gr(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function yr(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new ar;
        if (gr(r), t) _r(e, r, i, t, n);
        else {
            var a = $e(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ye(e, r), i ? process2.nextTick(He, e, r, a, n) : He(e, r, a, n);
        }
    }
    function He(e, t, r, i) {
        r || vr(e, t), t.pendingcb--, i(), U(e, t);
    }
    function vr(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function Ye(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, o = !0; r;)n[f] = r, r.isBuf || (o = !1), r = r.next, f += 1;
            n.allBuffers = o, de(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new Ge(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, p = r.encoding, v = r.callback, w = t.objectMode ? 1 : d.length;
                if (de(e, t, !1, w, d, p, v), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new nr("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || Er(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function $e(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function wr(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && x(e, r), t.prefinished = !0, e.emit("prefinish"), U(e, t);
        });
    }
    function Rr(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, process2.nextTick(wr, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function U(e, t) {
        var r = $e(t);
        if (r && (Rr(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function Er(e, t, r) {
        t.ending = !0, U(e, t), r && (t.finished ? process2.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function Sr(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = he.destroy;
    s.prototype._undestroy = he.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var L3 = c5((mi, ze)=>{
    "use strict";
    var Tr = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    ze.exports = y;
    var Xe = _e(), be = ce();
    w(y, Xe);
    for(pe = Tr(be.prototype), z = 0; z < pe.length; z++)J = pe[z], y.prototype[J] || (y.prototype[J] = be.prototype[J]);
    var pe, J, z;
    function y(e) {
        if (!(this instanceof y)) return new y(e);
        Xe.call(this, e), be.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", Mr)));
    }
    Object.defineProperty(y.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(y.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(y.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function Mr() {
        this._writableState.ended || process2.nextTick(mr, this);
    }
    function mr(e) {
        e.end();
    }
    Object.defineProperty(y.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var Q1 = c5((Ai, Ze)=>{
    "use strict";
    var Je = O1().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Ar(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function Or() {}
    function Lr(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function Qe(e, t, r) {
        if (typeof t == "function") return Qe(e, null, t);
        t || (t = {}), r = Ar(r || Or);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || o();
        }, f = e._writableState && e._writableState.finished, o = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, p = function() {
            i = !1, d = !0, n || r.call(e);
        }, v = function(g) {
            r.call(e, g);
        }, w = function() {
            var g;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (g = new Je), r.call(e, g);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (g = new Je), r.call(e, g);
        }, A = function() {
            e.req.on("finish", o);
        };
        return Lr(e) ? (e.on("complete", o), e.on("abort", w), e.req ? A() : e.on("request", A)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", p), e.on("finish", o), t.error !== !1 && e.on("error", v), e.on("close", w), function() {
            e.removeListener("complete", o), e.removeListener("abort", w), e.removeListener("request", A), e.req && e.req.removeListener("finish", o), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", o), e.removeListener("end", p), e.removeListener("error", v), e.removeListener("close", w);
        };
    }
    Ze.exports = Qe;
});
var tt = c5((Oi, et)=>{
    "use strict";
    var Z;
    function T(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var Dr = Q1(), M = Symbol("lastResolve"), D = Symbol("lastReject"), F = Symbol("error"), ee = Symbol("ended"), q = Symbol("lastPromise"), ge = Symbol("handlePromise"), P = Symbol("stream");
    function m(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function qr(e) {
        var t = e[M];
        if (t !== null) {
            var r = e[P].read();
            r !== null && (e[q] = null, e[M] = null, e[D] = null, t(m(r, !1)));
        }
    }
    function Pr(e) {
        process2.nextTick(qr, e);
    }
    function Nr(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[ee]) {
                    r(m(void 0, !0));
                    return;
                }
                t[ge](r, i);
            }, i);
        };
    }
    var Cr = Object.getPrototypeOf(function() {}), Ir = Object.setPrototypeOf((Z = {
        get stream () {
            return this[P];
        },
        next: function() {
            var t = this, r = this[F];
            if (r !== null) return Promise.reject(r);
            if (this[ee]) return Promise.resolve(m(void 0, !0));
            if (this[P].destroyed) return new Promise(function(f, o) {
                process2.nextTick(function() {
                    t[F] ? o(t[F]) : f(m(void 0, !0));
                });
            });
            var i = this[q], n;
            if (i) n = new Promise(Nr(i, this));
            else {
                var a = this[P].read();
                if (a !== null) return Promise.resolve(m(a, !1));
                n = new Promise(this[ge]);
            }
            return this[q] = n, n;
        }
    }, T(Z, Symbol.asyncIterator, function() {
        return this;
    }), T(Z, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[P].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(m(void 0, !0));
            });
        });
    }), Z), Cr), xr = function(t) {
        var r, i = Object.create(Ir, (r = {}, T(r, P, {
            value: t,
            writable: !0
        }), T(r, M, {
            value: null,
            writable: !0
        }), T(r, D, {
            value: null,
            writable: !0
        }), T(r, F, {
            value: null,
            writable: !0
        }), T(r, ee, {
            value: t._readableState.endEmitted,
            writable: !0
        }), T(r, ge, {
            value: function(a, f) {
                var o = i[P].read();
                o ? (i[q] = null, i[M] = null, i[D] = null, a(m(o, !1))) : (i[M] = a, i[D] = f);
            },
            writable: !0
        }), r));
        return i[q] = null, Dr(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[D];
                a !== null && (i[q] = null, i[M] = null, i[D] = null, a(n)), i[F] = n;
                return;
            }
            var f = i[M];
            f !== null && (i[q] = null, i[M] = null, i[D] = null, f(m(void 0, !0))), i[ee] = !0;
        }), t.on("readable", Pr.bind(null, i)), i;
    };
    et.exports = xr;
});
var it = c5((Li, rt)=>{
    rt.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var _e = c5((qi, ct)=>{
    "use strict";
    ct.exports = u;
    var k;
    u.ReadableState = ot;
    var Di = EventEmitter1.EventEmitter, ft = function(t, r) {
        return t.listeners(r).length;
    }, G = fe(), te = export_default.Buffer, kr = __global$1.Uint8Array || function() {};
    function jr(e) {
        return te.from(e);
    }
    function Wr(e) {
        return te.isBuffer(e) || e instanceof kr;
    }
    var ye = __default14, l;
    ye && ye.debuglog ? l = ye.debuglog("stream") : l = function() {};
    var Ur = xe(), Me = ue(), Br = se(), Fr = Br.getHighWaterMark, re = O1().codes, Hr = re.ERR_INVALID_ARG_TYPE, Gr = re.ERR_STREAM_PUSH_AFTER_EOF, Vr = re.ERR_METHOD_NOT_IMPLEMENTED, Yr = re.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, j, ve, we;
    w(u, G);
    var H = Me.errorOrDestroy, Re = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function $r(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function ot(e, t, r) {
        k = k || L3(), e = e || {}, typeof r != "boolean" && (r = t instanceof k), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Fr(this, e, "readableHighWaterMark", r), this.buffer = new Ur, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (j || (j = __default16.StringDecoder), this.decoder = new j(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (k = k || L3(), !(this instanceof u)) return new u(e);
        var t = this instanceof k;
        this._readableState = new ot(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), G.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = Me.destroy;
    u.prototype._undestroy = Me.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = te.from(e, t), t = ""), i = !0), lt(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return lt(this, e, null, !0, !1);
    };
    function lt(e, t, r, i, n) {
        l("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, zr(e, a);
        else {
            var f;
            if (n || (f = Kr(a, t)), f) H(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== te.prototype && (t = jr(t)), i) a.endEmitted ? H(e, new Yr) : Ee(e, a, t, !0);
            else if (a.ended) H(e, new Gr);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? Ee(e, a, t, !1) : Te(e, a)) : Ee(e, a, t, !1);
            }
            else i || (a.reading = !1, Te(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function Ee(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ie(e)), Te(e, t);
    }
    function Kr(e, t) {
        var r;
        return !Wr(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Hr("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        j || (j = __default16.StringDecoder);
        var t = new j(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var nt = 1073741824;
    function Xr(e) {
        return e >= nt ? e = nt : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function at(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = Xr(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        l("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return l("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Se(this) : ie(this), null;
        if (e = at(e, t), e === 0 && t.ended) return t.length === 0 && Se(this), null;
        var i = t.needReadable;
        l("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, l("length less than watermark", i)), t.ended || t.reading ? (i = !1, l("reading or ended", i)) : i && (l("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = at(r, t)));
        var n;
        return e > 0 ? n = dt(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && Se(this)), n !== null && this.emit("data", n), n;
    };
    function zr(e, t) {
        if (l("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? ie(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, ut(e)));
        }
    }
    function ie(e) {
        var t = e._readableState;
        l("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (l("emitReadable", t.flowing), t.emittedReadable = !0, process2.nextTick(ut, e));
    }
    function ut(e) {
        var t = e._readableState;
        l("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, me(e);
    }
    function Te(e, t) {
        t.readingMore || (t.readingMore = !0, process2.nextTick(Jr, e, t));
    }
    function Jr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (l("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        H(this, new Vr("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== process2.stdout && e !== process2.stderr, a = n ? o : W;
        i.endEmitted ? process2.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(N, C) {
            l("onunpipe"), N === r && C && C.hasUnpiped === !1 && (C.hasUnpiped = !0, v());
        }
        function o() {
            l("onend"), e.end();
        }
        var d = Qr(r);
        e.on("drain", d);
        var p = !1;
        function v() {
            l("cleanup"), e.removeListener("close", R), e.removeListener("finish", g), e.removeListener("drain", d), e.removeListener("error", A), e.removeListener("unpipe", f), r.removeListener("end", o), r.removeListener("end", W), r.removeListener("data", w), p = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", w);
        function w(N) {
            l("ondata");
            var C = e.write(N);
            l("dest.write", C), C === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && ht(i.pipes, e) !== -1) && !p && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function A(N) {
            l("onerror", N), W(), e.removeListener("error", A), ft(e, "error") === 0 && H(e, N);
        }
        $r(e, "error", A);
        function R() {
            e.removeListener("finish", g), W();
        }
        e.once("close", R);
        function g() {
            l("onfinish"), e.removeListener("close", R), W();
        }
        e.once("finish", g);
        function W() {
            l("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (l("pipe resume"), r.resume()), e;
    };
    function Qr(e) {
        return function() {
            var r = e._readableState;
            l("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && ft(e, "data") && (r.flowing = !0, me(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = ht(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = G.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, l("on readable", i.length, i.reading), i.length ? ie(this) : i.reading || process2.nextTick(Zr, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = G.prototype.removeListener.call(this, e, t);
        return e === "readable" && process2.nextTick(st, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = G.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && process2.nextTick(st, this), t;
    };
    function st(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function Zr(e) {
        l("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (l("resume"), e.flowing = !e.readableListening, ei(this, e)), e.paused = !1, this;
    };
    function ei(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, process2.nextTick(ti, e, t));
    }
    function ti(e, t) {
        l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), me(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function me(e) {
        var t = e._readableState;
        for(l("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (l("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (l("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var o = t.push(f);
                o || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(o) {
            return function() {
                return e[o].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < Re.length; a++)e.on(Re[a], this.emit.bind(this, Re[a]));
        return this._read = function(f) {
            l("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return ve === void 0 && (ve = tt()), ve(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = dt;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function dt(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function Se(e) {
        var t = e._readableState;
        l("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, process2.nextTick(ri, t, e));
    }
    function ri(e, t) {
        if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return we === void 0 && (we = it()), we(u, e, t);
    });
    function ht(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var Ae = c5((Pi, bt)=>{
    "use strict";
    bt.exports = E;
    var ne = O1().codes, ii = ne.ERR_METHOD_NOT_IMPLEMENTED, ni = ne.ERR_MULTIPLE_CALLBACK, ai = ne.ERR_TRANSFORM_ALREADY_TRANSFORMING, fi = ne.ERR_TRANSFORM_WITH_LENGTH_0, ae = L3();
    w(E, ae);
    function oi(e, t) {
        var r = this._transformState;
        r.transforming = !1;
        var i = r.writecb;
        if (i === null) return this.emit("error", new ni);
        r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
    function E(e) {
        if (!(this instanceof E)) return new E(e);
        ae.call(this, e), this._transformState = {
            afterTransform: oi.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", li);
    }
    function li() {
        var e = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
            pt(e, t, r);
        }) : pt(this, null, null);
    }
    E.prototype.push = function(e, t) {
        return this._transformState.needTransform = !1, ae.prototype.push.call(this, e, t);
    };
    E.prototype._transform = function(e, t, r) {
        r(new ii("_transform()"));
    };
    E.prototype._write = function(e, t, r) {
        var i = this._transformState;
        if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
            var n = this._readableState;
            (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
        }
    };
    E.prototype._read = function(e) {
        var t = this._transformState;
        t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
    };
    E.prototype._destroy = function(e, t) {
        ae.prototype._destroy.call(this, e, function(r) {
            t(r);
        });
    };
    function pt(e, t, r) {
        if (t) return e.emit("error", t);
        if (r != null && e.push(r), e._writableState.length) throw new fi;
        if (e._transformState.transforming) throw new ai;
        return e.push(null);
    }
});
var yt1 = c5((Ni, gt)=>{
    "use strict";
    gt.exports = V;
    var _t = Ae();
    w(V, _t);
    function V(e) {
        if (!(this instanceof V)) return new V(e);
        _t.call(this, e);
    }
    V.prototype._transform = function(e, t, r) {
        r(null, e);
    };
});
var St = c5((Ci, Et)=>{
    "use strict";
    var Oe;
    function ui(e) {
        var t = !1;
        return function() {
            t || (t = !0, e.apply(void 0, arguments));
        };
    }
    var Rt = O1().codes, si = Rt.ERR_MISSING_ARGS, di = Rt.ERR_STREAM_DESTROYED;
    function vt(e) {
        if (e) throw e;
    }
    function hi(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function ci(e, t, r, i) {
        i = ui(i);
        var n = !1;
        e.on("close", function() {
            n = !0;
        }), Oe === void 0 && (Oe = Q1()), Oe(e, {
            readable: t,
            writable: r
        }, function(f) {
            if (f) return i(f);
            n = !0, i();
        });
        var a = !1;
        return function(f) {
            if (!n && !a) {
                if (a = !0, hi(e)) return e.abort();
                if (typeof e.destroy == "function") return e.destroy();
                i(f || new di("pipe"));
            }
        };
    }
    function wt(e) {
        e();
    }
    function pi(e, t) {
        return e.pipe(t);
    }
    function bi(e) {
        return !e.length || typeof e[e.length - 1] != "function" ? vt : e.pop();
    }
    function _i() {
        for(var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r];
        var i = bi(t);
        if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new si("streams");
        var n, a = t.map(function(f, o) {
            var d = o < t.length - 1, p = o > 0;
            return ci(f, d, p, function(v) {
                n || (n = v), v && a.forEach(wt), !d && (a.forEach(wt), i(n));
            });
        });
        return t.reduce(pi);
    }
    Et.exports = _i;
});
var Le2 = c5((_, Tt)=>{
    _ = Tt.exports = _e();
    _.Stream = _;
    _.Readable = _;
    _.Writable = ce();
    _.Duplex = L3();
    _.Transform = Ae();
    _.PassThrough = yt1();
    _.finished = Q1();
    _.pipeline = St();
});
var Mt1 = qe1(Le2()), mt = qe1(Le2()), { Stream: Ii , Readable: xi1 , Writable: ki1 , Duplex: ji , Transform: Wi , PassThrough: Ui , finished: Bi , pipeline: Fi  } = mt, { default: gi1 , ...yi } = mt, Hi = (Mt1.default ?? gi1) ?? yi;
var g7 = Object.create;
var _3 = Object.defineProperty;
var b4 = Object.getOwnPropertyDescriptor;
var m6 = Object.getOwnPropertyNames;
var w7 = Object.getPrototypeOf, k2 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (e, r)=>(typeof require != "undefined" ? require : e)[r]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var v5 = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var y6 = (t, e, r, i)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of m6(e))!k2.call(t, o) && o !== r && _3(t, o, {
        get: ()=>e[o],
        enumerable: !(i = b4(e, o)) || i.enumerable
    });
    return t;
};
var p10 = (t, e, r)=>(r = t != null ? g7(w7(t)) : {}, y6(e || !t || !t.__esModule ? _3(r, "default", {
        value: t,
        enumerable: !0
    }) : r, t));
var u3 = v5(($, a)=>{
    "use strict";
    var h = L1, c = Wi, O = w;
    function z(t, e) {
        if (!h.isBuffer(t) && typeof t != "string") throw new TypeError(e + " must be a string or a buffer");
    }
    function s(t) {
        c.call(this), this._block = h.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [
            0,
            0,
            0,
            0
        ], this._finalized = !1;
    }
    O(s, c);
    s.prototype._transform = function(t, e, r) {
        var i = null;
        try {
            this.update(t, e);
        } catch (o) {
            i = o;
        }
        r(i);
    };
    s.prototype._flush = function(t) {
        var e = null;
        try {
            this.push(this.digest());
        } catch (r) {
            e = r;
        }
        t(e);
    };
    s.prototype.update = function(t, e) {
        if (z(t, "Data"), this._finalized) throw new Error("Digest already called");
        h.isBuffer(t) || (t = h.from(t, e));
        for(var r = this._block, i = 0; this._blockOffset + t.length - i >= this._blockSize;){
            for(var o = this._blockOffset; o < this._blockSize;)r[o++] = t[i++];
            this._update(), this._blockOffset = 0;
        }
        for(; i < t.length;)r[this._blockOffset++] = t[i++];
        for(var n = 0, f = t.length * 8; f > 0; ++n)this._length[n] += f, f = this._length[n] / 4294967296 | 0, f > 0 && (this._length[n] -= 4294967296 * f);
        return this;
    };
    s.prototype._update = function() {
        throw new Error("_update is not implemented");
    };
    s.prototype.digest = function(t) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = !0;
        var e = this._digest();
        t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
        for(var r = 0; r < 4; ++r)this._length[r] = 0;
        return e;
    };
    s.prototype._digest = function() {
        throw new Error("_digest is not implemented");
    };
    a.exports = s;
});
var d6 = p10(u3()), B3 = p10(u3()), { default: E3 , ...x6 } = B3, q4 = (d6.default ?? E3) ?? x6;
var M2 = Object.create;
var $4 = Object.defineProperty;
var P2 = Object.getOwnPropertyDescriptor;
var Y1 = Object.getOwnPropertyNames;
var C2 = Object.getPrototypeOf, F2 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (r, s)=>(typeof require != "undefined" ? require : r)[s]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var G1 = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var J2 = (t, r, s, i)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let a of Y1(r))!F2.call(t, a) && a !== s && $4(t, a, {
        get: ()=>r[a],
        enumerable: !(i = P2(r, a)) || i.enumerable
    });
    return t;
};
var g8 = (t, r, s)=>(s = t != null ? M2(C2(t)) : {}, J2(r || !t || !t.__esModule ? $4(s, "default", {
        value: t,
        enumerable: !0
    }) : s, t));
var O2 = G1((W, U)=>{
    "use strict";
    var m = export_default.Buffer, K = w, z = q4, N = new Array(16), b = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], x = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], k = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], p = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ], w1 = [
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
    ], E = [
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
    ];
    function I() {
        z.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    K(I, z);
    I.prototype._update = function() {
        for(var t = N, r = 0; r < 16; ++r)t[r] = this._block.readInt32LE(r * 4);
        for(var s = this._a | 0, i = this._b | 0, a = this._c | 0, h = this._d | 0, f = this._e | 0, _ = this._a | 0, n = this._b | 0, c = this._c | 0, o = this._d | 0, l = this._e | 0, e = 0; e < 80; e += 1){
            var d, v;
            e < 16 ? (d = q(s, i, a, h, f, t[b[e]], w1[0], k[e]), v = R(_, n, c, o, l, t[x[e]], E[0], p[e])) : e < 32 ? (d = y(s, i, a, h, f, t[b[e]], w1[1], k[e]), v = B(_, n, c, o, l, t[x[e]], E[1], p[e])) : e < 48 ? (d = A(s, i, a, h, f, t[b[e]], w1[2], k[e]), v = A(_, n, c, o, l, t[x[e]], E[2], p[e])) : e < 64 ? (d = B(s, i, a, h, f, t[b[e]], w1[3], k[e]), v = y(_, n, c, o, l, t[x[e]], E[3], p[e])) : (d = R(s, i, a, h, f, t[b[e]], w1[4], k[e]), v = q(_, n, c, o, l, t[x[e]], E[4], p[e])), s = f, f = h, h = u(a, 10), a = i, i = d, _ = l, l = o, o = u(c, 10), c = n, n = v;
        }
        var H = this._b + a + o | 0;
        this._b = this._c + h + l | 0, this._c = this._d + f + _ | 0, this._d = this._e + s + n | 0, this._e = this._a + i + c | 0, this._a = H;
    };
    I.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t = m.alloc ? m.alloc(20) : new m(20);
        return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function u(t, r) {
        return t << r | t >>> 32 - r;
    }
    function q(t, r, s, i, a, h, f, _) {
        return u(t + (r ^ s ^ i) + h + f | 0, _) + a | 0;
    }
    function y(t, r, s, i, a, h, f, _) {
        return u(t + (r & s | ~r & i) + h + f | 0, _) + a | 0;
    }
    function A(t, r, s, i, a, h, f, _) {
        return u(t + ((r | ~s) ^ i) + h + f | 0, _) + a | 0;
    }
    function B(t, r, s, i, a, h, f, _) {
        return u(t + (r & i | s & ~i) + h + f | 0, _) + a | 0;
    }
    function R(t, r, s, i, a, h, f, _) {
        return u(t + (r ^ (s | ~i)) + h + f | 0, _) + a | 0;
    }
    U.exports = I;
});
var D1 = g8(O2()), Q2 = g8(O2()), { default: S3 , ...T1 } = Q2, X2 = (D1.default ?? S3) ?? T1;
var I4 = Object.create;
var u4 = Object.defineProperty;
var w8 = Object.getOwnPropertyDescriptor;
var E4 = Object.getOwnPropertyNames;
var L4 = Object.getPrototypeOf, m7 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (i, f)=>(typeof require != "undefined" ? require : i)[f]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var O3 = (t, i)=>()=>(i || t((i = {
            exports: {}
        }).exports, i), i.exports);
var $5 = (t, i, f, x)=>{
    if (i && typeof i == "object" || typeof i == "function") for (let e of E4(i))!m7.call(t, e) && e !== f && u4(t, e, {
        get: ()=>i[e],
        enumerable: !(x = w8(i, e)) || x.enumerable
    });
    return t;
};
var l6 = (t, i, f)=>(f = t != null ? I4(L4(t)) : {}, $5(i || !t || !t.__esModule ? u4(f, "default", {
        value: t,
        enumerable: !0
    }) : f, t));
var o2 = O3((M, p)=>{
    "use strict";
    var g = w, k = q4, q = L1, y = new Array(16);
    function h() {
        k.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    g(h, k);
    h.prototype._update = function() {
        for(var t = y, i = 0; i < 16; ++i)t[i] = this._block.readInt32LE(i * 4);
        var f = this._a, x = this._b, e = this._c, a = this._d;
        f = c(f, x, e, a, t[0], 3614090360, 7), a = c(a, f, x, e, t[1], 3905402710, 12), e = c(e, a, f, x, t[2], 606105819, 17), x = c(x, e, a, f, t[3], 3250441966, 22), f = c(f, x, e, a, t[4], 4118548399, 7), a = c(a, f, x, e, t[5], 1200080426, 12), e = c(e, a, f, x, t[6], 2821735955, 17), x = c(x, e, a, f, t[7], 4249261313, 22), f = c(f, x, e, a, t[8], 1770035416, 7), a = c(a, f, x, e, t[9], 2336552879, 12), e = c(e, a, f, x, t[10], 4294925233, 17), x = c(x, e, a, f, t[11], 2304563134, 22), f = c(f, x, e, a, t[12], 1804603682, 7), a = c(a, f, x, e, t[13], 4254626195, 12), e = c(e, a, f, x, t[14], 2792965006, 17), x = c(x, e, a, f, t[15], 1236535329, 22), f = r(f, x, e, a, t[1], 4129170786, 5), a = r(a, f, x, e, t[6], 3225465664, 9), e = r(e, a, f, x, t[11], 643717713, 14), x = r(x, e, a, f, t[0], 3921069994, 20), f = r(f, x, e, a, t[5], 3593408605, 5), a = r(a, f, x, e, t[10], 38016083, 9), e = r(e, a, f, x, t[15], 3634488961, 14), x = r(x, e, a, f, t[4], 3889429448, 20), f = r(f, x, e, a, t[9], 568446438, 5), a = r(a, f, x, e, t[14], 3275163606, 9), e = r(e, a, f, x, t[3], 4107603335, 14), x = r(x, e, a, f, t[8], 1163531501, 20), f = r(f, x, e, a, t[13], 2850285829, 5), a = r(a, f, x, e, t[2], 4243563512, 9), e = r(e, a, f, x, t[7], 1735328473, 14), x = r(x, e, a, f, t[12], 2368359562, 20), f = d(f, x, e, a, t[5], 4294588738, 4), a = d(a, f, x, e, t[8], 2272392833, 11), e = d(e, a, f, x, t[11], 1839030562, 16), x = d(x, e, a, f, t[14], 4259657740, 23), f = d(f, x, e, a, t[1], 2763975236, 4), a = d(a, f, x, e, t[4], 1272893353, 11), e = d(e, a, f, x, t[7], 4139469664, 16), x = d(x, e, a, f, t[10], 3200236656, 23), f = d(f, x, e, a, t[13], 681279174, 4), a = d(a, f, x, e, t[0], 3936430074, 11), e = d(e, a, f, x, t[3], 3572445317, 16), x = d(x, e, a, f, t[6], 76029189, 23), f = d(f, x, e, a, t[9], 3654602809, 4), a = d(a, f, x, e, t[12], 3873151461, 11), e = d(e, a, f, x, t[15], 530742520, 16), x = d(x, e, a, f, t[2], 3299628645, 23), f = s(f, x, e, a, t[0], 4096336452, 6), a = s(a, f, x, e, t[7], 1126891415, 10), e = s(e, a, f, x, t[14], 2878612391, 15), x = s(x, e, a, f, t[5], 4237533241, 21), f = s(f, x, e, a, t[12], 1700485571, 6), a = s(a, f, x, e, t[3], 2399980690, 10), e = s(e, a, f, x, t[10], 4293915773, 15), x = s(x, e, a, f, t[1], 2240044497, 21), f = s(f, x, e, a, t[8], 1873313359, 6), a = s(a, f, x, e, t[15], 4264355552, 10), e = s(e, a, f, x, t[6], 2734768916, 15), x = s(x, e, a, f, t[13], 1309151649, 21), f = s(f, x, e, a, t[4], 4149444226, 6), a = s(a, f, x, e, t[11], 3174756917, 10), e = s(e, a, f, x, t[2], 718787259, 15), x = s(x, e, a, f, t[9], 3951481745, 21), this._a = this._a + f | 0, this._b = this._b + x | 0, this._c = this._c + e | 0, this._d = this._d + a | 0;
    };
    h.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t = q.allocUnsafe(16);
        return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function n(t, i) {
        return t << i | t >>> 32 - i;
    }
    function c(t, i, f, x, e, a, b) {
        return n(t + (i & f | ~i & x) + e + a | 0, b) + i | 0;
    }
    function r(t, i, f, x, e, a, b) {
        return n(t + (i & x | f & ~x) + e + a | 0, b) + i | 0;
    }
    function d(t, i, f, x, e, a, b) {
        return n(t + (i ^ f ^ x) + e + a | 0, b) + i | 0;
    }
    function s(t, i, f, x, e, a, b) {
        return n(t + (f ^ (i | ~x)) + e + a | 0, b) + i | 0;
    }
    p.exports = h;
});
var v6 = l6(o2()), A4 = l6(o2()), { default: B4 , ...U1 } = A4, R2 = (v6.default ?? B4) ?? U1;
var n = Object.create;
var f3 = Object.defineProperty;
var p11 = Object.getOwnPropertyDescriptor;
var s3 = Object.getOwnPropertyNames;
var l7 = Object.getPrototypeOf, $6 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (t, r)=>(typeof require != "undefined" ? require : t)[r]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var x7 = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var g9 = (e, t, r, d)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let o of s3(t))!$6.call(e, o) && o !== r && f3(e, o, {
        get: ()=>t[o],
        enumerable: !(d = p11(t, o)) || d.enumerable
    });
    return e;
};
var a2 = (e, t, r)=>(r = e != null ? n(l7(e)) : {}, g9(t || !e || !e.__esModule ? f3(r, "default", {
        value: e,
        enumerable: !0
    }) : r, e));
var u5 = x7((b, i)=>{
    var q = R2;
    i.exports = function(e) {
        return new q().update(e).digest();
    };
});
var m8 = a2(u5()), v7 = a2(u5()), { default: w9 , ...D2 } = v7, h5 = (m8.default ?? w9) ?? D2;
var __global$2 = globalThis || (typeof window !== "undefined" ? window : self);
var __setImmediate$ = (cb, ...args)=>setTimeout(cb, 0, ...args);
var Y2 = Object.create;
var I5 = Object.defineProperty;
var j2 = Object.getOwnPropertyDescriptor;
var rr1 = Object.getOwnPropertyNames;
var er1 = Object.getPrototypeOf, or = Object.prototype.hasOwnProperty;
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, t)=>(typeof require != "undefined" ? require : e)[t]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var l8 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var tr1 = (r, e, t, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of rr1(e))!or.call(r, o) && o !== t && I5(r, o, {
        get: ()=>e[o],
        enumerable: !(n = j2(e, o)) || n.enumerable
    });
    return r;
};
var K5 = (r, e, t)=>(t = r != null ? Y2(er1(r)) : {}, tr1(e || !r || !r.__esModule ? I5(t, "default", {
        value: r,
        enumerable: !0
    }) : t, r));
var S4 = l8((wr, F)=>{
    var nr = Math.pow(2, 30) - 1;
    F.exports = function(r, e) {
        if (typeof r != "number") throw new TypeError("Iterations not a number");
        if (r < 0) throw new TypeError("Bad iterations");
        if (typeof e != "number") throw new TypeError("Key length not a number");
        if (e < 0 || e > nr || e !== e) throw new TypeError("Bad key length");
    };
});
var x8 = l8((qr, L)=>{
    var d;
    process1 && process1.browser ? d = "utf-8" : process1 && process1.version ? (U = parseInt(process1.version.split(".")[0].slice(1), 10), d = U >= 6 ? "utf-8" : "binary") : d = "utf-8";
    var U;
    L.exports = d;
});
var P3 = l8((yr, M)=>{
    var E = L1;
    M.exports = function(r, e, t) {
        if (E.isBuffer(r)) return r;
        if (typeof r == "string") return E.from(r, e);
        if (ArrayBuffer.isView(r)) return E.from(r.buffer);
        throw new TypeError(t + " must be a string, a Buffer, a typed array or a DataView");
    };
});
var A5 = l8((Sr, O)=>{
    var ar = h5, fr = X2, ur = Ot, s = L1, ir = S4(), $ = x8(), C = P3(), sr = s.alloc(128), m = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function N(r, e, t) {
        var n = cr(r), o = r === "sha512" || r === "sha384" ? 128 : 64;
        e.length > o ? e = n(e) : e.length < o && (e = s.concat([
            e,
            sr
        ], o));
        for(var a = s.allocUnsafe(o + m[r]), u = s.allocUnsafe(o + m[r]), f = 0; f < o; f++)a[f] = e[f] ^ 54, u[f] = e[f] ^ 92;
        var i = s.allocUnsafe(o + t + 4);
        a.copy(i, 0, 0, o), this.ipad1 = i, this.ipad2 = a, this.opad = u, this.alg = r, this.blocksize = o, this.hash = n, this.size = m[r];
    }
    N.prototype.run = function(r, e) {
        r.copy(e, this.blocksize);
        var t = this.hash(e);
        return t.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function cr(r) {
        function e(n) {
            return ur(r).update(n).digest();
        }
        function t(n) {
            return new fr().update(n).digest();
        }
        return r === "rmd160" || r === "ripemd160" ? t : r === "md5" ? ar : e;
    }
    function hr(r, e, t, n, o) {
        ir(t, n), r = C(r, $, "Password"), e = C(e, $, "Salt"), o = o || "sha1";
        var a = new N(o, r, e.length), u = s.allocUnsafe(n), f = s.allocUnsafe(e.length + 4);
        e.copy(f, 0, 0, e.length);
        for(var i = 0, B = m[o], W = Math.ceil(n / B), w = 1; w <= W; w++){
            f.writeUInt32BE(w, e.length);
            for(var q = a.run(f, a.ipad1), y = q, D = 1; D < t; D++){
                y = a.run(y, a.ipad2);
                for(var v = 0; v < B; v++)q[v] ^= y[v];
            }
            q.copy(u, i), i += B;
        }
        return u;
    }
    O.exports = hr;
});
var J3 = l8((xr, G)=>{
    var X = L1, lr = S4(), R = x8(), Z = A5(), _ = P3(), b, p = __global$2.crypto && __global$2.crypto.subtle, pr = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, g = [];
    function vr(r) {
        if (process1 && !process1.browser || !p || !p.importKey || !p.deriveBits) return Promise.resolve(!1);
        if (g[r] !== void 0) return g[r];
        b = b || X.alloc(8);
        var e = k(b, b, 10, 128, r).then(function() {
            return !0;
        }).catch(function() {
            return !1;
        });
        return g[r] = e, e;
    }
    var c;
    function H() {
        return c || (process1 && process1.nextTick ? c = process1.nextTick : __global$2.queueMicrotask ? c = __global$2.queueMicrotask : __setImmediate$ ? c = __setImmediate$ : c = __global$2.setTimeout, c);
    }
    function k(r, e, t, n, o) {
        return p.importKey("raw", r, {
            name: "PBKDF2"
        }, !1, [
            "deriveBits"
        ]).then(function(a) {
            return p.deriveBits({
                name: "PBKDF2",
                salt: e,
                iterations: t,
                hash: {
                    name: o
                }
            }, a, n << 3);
        }).then(function(a) {
            return X.from(a);
        });
    }
    function dr(r, e) {
        r.then(function(t) {
            H()(function() {
                e(null, t);
            });
        }, function(t) {
            H()(function() {
                e(t);
            });
        });
    }
    G.exports = function(r, e, t, n, o, a) {
        typeof o == "function" && (a = o, o = void 0), o = o || "sha1";
        var u = pr[o.toLowerCase()];
        if (!u || typeof __global$2.Promise != "function") {
            H()(function() {
                var f;
                try {
                    f = Z(r, e, t, n, o);
                } catch (i) {
                    return a(i);
                }
                a(null, f);
            });
            return;
        }
        if (lr(t, n), r = _(r, R, "Password"), e = _(e, R, "Salt"), typeof a != "function") throw new Error("No callback provided to pbkdf2");
        dr(vr(u).then(function(f) {
            return f ? k(r, e, t, n, u) : Z(r, e, t, n, o);
        }), a);
    };
});
var z2 = l8((T)=>{
    T.pbkdf2 = J3();
    T.pbkdf2Sync = A5();
});
var Q3 = K5(z2()), V1 = K5(z2()), { pbkdf2Sync: Pr , pbkdf2: Ar  } = V1, { default: mr , ...br } = V1, gr1 = (Q3.default ?? mr) ?? br;
var h6 = Object.create;
var a3 = Object.defineProperty;
var p12 = Object.getOwnPropertyDescriptor;
var s4 = Object.getOwnPropertyNames;
var $7 = Object.getPrototypeOf, g10 = Object.prototype.hasOwnProperty;
var v8 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var x9 = (e, r, t, o)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let f of s4(r))!g10.call(e, f) && f !== t && a3(e, f, {
        get: ()=>r[f],
        enumerable: !(o = p12(r, f)) || o.enumerable
    });
    return e;
};
var l9 = (e, r, t)=>(t = e != null ? h6($7(e)) : {}, x9(r || !e || !e.__esModule ? a3(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var u6 = v8((b, m)=>{
    m.exports = function(r, t) {
        for(var o = Math.min(r.length, t.length), f = new Buffer(o), n = 0; n < o; ++n)f[n] = r[n] ^ t[n];
        return f;
    };
});
var d7 = l9(u6()), c6 = l9(u6()), { default: w10 , ...B5 } = c6, i7 = (d7.default ?? w10) ?? B5;
var k3 = Object.create;
var v9 = Object.defineProperty;
var M3 = Object.getOwnPropertyDescriptor;
var q5 = Object.getOwnPropertyNames;
var w11 = Object.getPrototypeOf, x10 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var E5 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var d8 = (e, r, t, i)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let f of q5(r))!x10.call(e, f) && f !== t && v9(e, f, {
        get: ()=>r[f],
        enumerable: !(i = M3(r, f)) || i.enumerable
    });
    return e;
};
var p13 = (e, r, t)=>(t = e != null ? k3(w11(e)) : {}, d8(r || !e || !e.__esModule ? v9(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var y7 = E5((_, h)=>{
    var l = L1, D = R2;
    function K(e, r, t, i) {
        if (l.isBuffer(e) || (e = l.from(e, "binary")), r && (l.isBuffer(r) || (r = l.from(r, "binary")), r.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
        for(var f = t / 8, u = l.alloc(f), m = l.alloc(i || 0), o = l.alloc(0); f > 0 || i > 0;){
            var n = new D;
            n.update(o), n.update(e), r && n.update(r), o = n.digest();
            var a = 0;
            if (f > 0) {
                var b = u.length - f;
                a = Math.min(f, o.length), o.copy(u, b, 0, a), f -= a;
            }
            if (a < o.length && i > 0) {
                var $ = m.length - i, g = Math.min(i, o.length - a);
                o.copy(m, $, a, a + g), i -= g;
            }
        }
        return o.fill(0), {
            key: u,
            iv: m
        };
    }
    h.exports = K;
});
var B6 = p13(y7()), P4 = p13(y7()), { default: R3 , ...T2 } = P4, j3 = (B6.default ?? R3) ?? T2;
var _4 = Object.create;
var a4 = Object.defineProperty;
var c7 = Object.getOwnPropertyDescriptor;
var g11 = Object.getOwnPropertyNames;
var y8 = Object.getPrototypeOf, w12 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (r, i)=>(typeof require != "undefined" ? require : r)[i]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var m9 = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var v10 = (t, r, i, e)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of g11(r))!w12.call(t, n) && n !== i && a4(t, n, {
        get: ()=>r[n],
        enumerable: !(e = c7(r, n)) || e.enumerable
    });
    return t;
};
var f4 = (t, r, i)=>(i = t != null ? _4(y8(t)) : {}, v10(r || !t || !t.__esModule ? a4(i, "default", {
        value: t,
        enumerable: !0
    }) : i, t));
var h7 = m9((B, d)=>{
    var u = L1, p = Stream.Transform, D = __default4.StringDecoder, A = w;
    function o(t) {
        p.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A(o, p);
    o.prototype.update = function(t, r, i) {
        typeof t == "string" && (t = u.from(t, r));
        var e = this._update(t);
        return this.hashMode ? this : (i && (e = this._toString(e, i)), e);
    };
    o.prototype.setAutoPadding = function() {};
    o.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
    };
    o.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
    };
    o.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
    };
    o.prototype._transform = function(t, r, i) {
        var e;
        try {
            this.hashMode ? this._update(t) : this.push(this._update(t));
        } catch (n) {
            e = n;
        } finally{
            i(e);
        }
    };
    o.prototype._flush = function(t) {
        var r;
        try {
            this.push(this.__final());
        } catch (i) {
            r = i;
        }
        t(r);
    };
    o.prototype._finalOrDigest = function(t) {
        var r = this.__final() || u.alloc(0);
        return t && (r = this._toString(r, t, !0)), r;
    };
    o.prototype._toString = function(t, r, i) {
        if (this._decoder || (this._decoder = new D(r), this._encoding = r), this._encoding !== r) throw new Error("can't switch encodings");
        var e = this._decoder.write(t);
        return i && (e += this._decoder.end()), e;
    };
    d.exports = o;
});
var l10 = f4(h7()), S5 = f4(h7()), { default: q6 , ...T3 } = S5, M4 = (l10.default ?? q6) ?? T3;
var He = Object.create;
var ie = Object.defineProperty;
var Ke = Object.getOwnPropertyDescriptor;
var Le3 = Object.getOwnPropertyNames;
var $e = Object.getPrototypeOf, Pe1 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var l11 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var Ze = (e, r, t, i)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let a of Le3(r))!Pe1.call(e, a) && a !== t && ie(e, a, {
        get: ()=>r[a],
        enumerable: !(i = Ke(r, a)) || i.enumerable
    });
    return e;
};
var ae = (e, r, t)=>(t = e != null ? He($e(e)) : {}, Ze(r || !e || !e.__esModule ? ie(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var ce1 = l11((O)=>{
    O.encrypt = function(e, r) {
        return e._cipher.encryptBlock(r);
    };
    O.decrypt = function(e, r) {
        return e._cipher.decryptBlock(r);
    };
});
var he = l11((M)=>{
    var ne = i7;
    M.encrypt = function(e, r) {
        var t = ne(r, e._prev);
        return e._prev = e._cipher.encryptBlock(t), e._prev;
    };
    M.decrypt = function(e, r) {
        var t = e._prev;
        e._prev = r;
        var i = e._cipher.decryptBlock(r);
        return ne(i, t);
    };
});
var ue1 = l11((pe)=>{
    var I = L1, We = i7;
    function oe(e, r, t) {
        var i = r.length, a = We(r, e._cache);
        return e._cache = e._cache.slice(i), e._prev = I.concat([
            e._prev,
            t ? r : a
        ]), a;
    }
    pe.encrypt = function(e, r, t) {
        for(var i = I.allocUnsafe(0), a; r.length;)if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = I.allocUnsafe(0)), e._cache.length <= r.length) a = e._cache.length, i = I.concat([
            i,
            oe(e, r.slice(0, a), t)
        ]), r = r.slice(a);
        else {
            i = I.concat([
                i,
                oe(e, r, t)
            ]);
            break;
        }
        return i;
    };
});
var fe1 = l11((se)=>{
    var G = L1;
    function Je(e, r, t) {
        var i = e._cipher.encryptBlock(e._prev), a = i[0] ^ r;
        return e._prev = G.concat([
            e._prev.slice(1),
            G.from([
                t ? r : a
            ])
        ]), a;
    }
    se.encrypt = function(e, r, t) {
        for(var i = r.length, a = G.allocUnsafe(i), c = -1; ++c < i;)a[c] = Je(e, r[c], t);
        return a;
    };
});
var le = l11((ve)=>{
    var D = L1;
    function Qe(e, r, t) {
        for(var i, a = -1, c = 8, n = 0, h, u; ++a < c;)i = e._cipher.encryptBlock(e._prev), h = r & 1 << 7 - a ? 128 : 0, u = i[0] ^ h, n += (u & 128) >> a % 8, e._prev = Ye(e._prev, t ? h : u);
        return n;
    }
    function Ye(e, r) {
        var t = e.length, i = -1, a = D.allocUnsafe(e.length);
        for(e = D.concat([
            e,
            D.from([
                r
            ])
        ]); ++i < t;)a[i] = e[i] << 1 | e[i + 1] >> 7;
        return a;
    }
    ve.encrypt = function(e, r, t) {
        for(var i = r.length, a = D.allocUnsafe(i), c = -1; ++c < i;)a[c] = Qe(e, r[c], t);
        return a;
    };
});
var ye = l11((_e)=>{
    var je = i7;
    function er(e) {
        return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
    }
    _e.encrypt = function(e, r) {
        for(; e._cache.length < r.length;)e._cache = Buffer.concat([
            e._cache,
            er(e)
        ]);
        var t = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), je(r, t);
    };
});
var z3 = l11((Hr, de)=>{
    function rr(e) {
        for(var r = e.length, t; r--;)if (t = e.readUInt8(r), t === 255) e.writeUInt8(0, r);
        else {
            t++, e.writeUInt8(t, r);
            break;
        }
    }
    de.exports = rr;
});
var K6 = l11((Be)=>{
    var tr = i7, ge = L1, ir = z3();
    function ar(e) {
        var r = e._cipher.encryptBlockRaw(e._prev);
        return ir(e._prev), r;
    }
    var H = 16;
    Be.encrypt = function(e, r) {
        var t = Math.ceil(r.length / H), i = e._cache.length;
        e._cache = ge.concat([
            e._cache,
            ge.allocUnsafe(t * H)
        ]);
        for(var a = 0; a < t; a++){
            var c = ar(e), n = i + a * H;
            e._cache.writeUInt32BE(c[0], n + 0), e._cache.writeUInt32BE(c[1], n + 4), e._cache.writeUInt32BE(c[2], n + 8), e._cache.writeUInt32BE(c[3], n + 12);
        }
        var h = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), tr(r, h);
    };
});
var L5 = l11((Lr, cr)=>{
    cr.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
});
var P5 = l11(($r, me)=>{
    var nr = {
        ECB: ce1(),
        CBC: he(),
        CFB: ue1(),
        CFB8: fe1(),
        CFB1: le(),
        OFB: ye(),
        CTR: K6(),
        GCM: K6()
    }, F = L5();
    for($ in F)F[$].module = nr[F[$].mode];
    var $;
    me.exports = F;
});
var k4 = l11((Pr, we)=>{
    var R = L1;
    function W(e) {
        R.isBuffer(e) || (e = R.from(e));
        for(var r = e.length / 4 | 0, t = new Array(r), i = 0; i < r; i++)t[i] = e.readUInt32BE(i * 4);
        return t;
    }
    function Z(e) {
        for(var r = 0; r < e.length; e++)e[r] = 0;
    }
    function Ee(e, r, t, i, a) {
        for(var c = t[0], n = t[1], h = t[2], u = t[3], p = e[0] ^ r[0], f = e[1] ^ r[1], y = e[2] ^ r[2], d = e[3] ^ r[3], s, C, S, x, E = 4, te = 1; te < a; te++)s = c[p >>> 24] ^ n[f >>> 16 & 255] ^ h[y >>> 8 & 255] ^ u[d & 255] ^ r[E++], C = c[f >>> 24] ^ n[y >>> 16 & 255] ^ h[d >>> 8 & 255] ^ u[p & 255] ^ r[E++], S = c[y >>> 24] ^ n[d >>> 16 & 255] ^ h[p >>> 8 & 255] ^ u[f & 255] ^ r[E++], x = c[d >>> 24] ^ n[p >>> 16 & 255] ^ h[f >>> 8 & 255] ^ u[y & 255] ^ r[E++], p = s, f = C, y = S, d = x;
        return s = (i[p >>> 24] << 24 | i[f >>> 16 & 255] << 16 | i[y >>> 8 & 255] << 8 | i[d & 255]) ^ r[E++], C = (i[f >>> 24] << 24 | i[y >>> 16 & 255] << 16 | i[d >>> 8 & 255] << 8 | i[p & 255]) ^ r[E++], S = (i[y >>> 24] << 24 | i[d >>> 16 & 255] << 16 | i[p >>> 8 & 255] << 8 | i[f & 255]) ^ r[E++], x = (i[d >>> 24] << 24 | i[p >>> 16 & 255] << 16 | i[f >>> 8 & 255] << 8 | i[y & 255]) ^ r[E++], s = s >>> 0, C = C >>> 0, S = S >>> 0, x = x >>> 0, [
            s,
            C,
            S,
            x
        ];
    }
    var hr = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], v = function() {
        for(var e = new Array(256), r = 0; r < 256; r++)r < 128 ? e[r] = r << 1 : e[r] = r << 1 ^ 283;
        for(var t = [], i = [], a = [
            [],
            [],
            [],
            []
        ], c = [
            [],
            [],
            [],
            []
        ], n = 0, h = 0, u = 0; u < 256; ++u){
            var p = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;
            p = p >>> 8 ^ p & 255 ^ 99, t[n] = p, i[p] = n;
            var f = e[n], y = e[f], d = e[y], s = e[p] * 257 ^ p * 16843008;
            a[0][n] = s << 24 | s >>> 8, a[1][n] = s << 16 | s >>> 16, a[2][n] = s << 8 | s >>> 24, a[3][n] = s, s = d * 16843009 ^ y * 65537 ^ f * 257 ^ n * 16843008, c[0][p] = s << 24 | s >>> 8, c[1][p] = s << 16 | s >>> 16, c[2][p] = s << 8 | s >>> 24, c[3][p] = s, n === 0 ? n = h = 1 : (n = f ^ e[e[e[d ^ f]]], h ^= e[e[h]]);
        }
        return {
            SBOX: t,
            INV_SBOX: i,
            SUB_MIX: a,
            INV_SUB_MIX: c
        };
    }();
    function g(e) {
        this._key = W(e), this._reset();
    }
    g.blockSize = 4 * 4;
    g.keySize = 256 / 8;
    g.prototype.blockSize = g.blockSize;
    g.prototype.keySize = g.keySize;
    g.prototype._reset = function() {
        for(var e = this._key, r = e.length, t = r + 6, i = (t + 1) * 4, a = [], c = 0; c < r; c++)a[c] = e[c];
        for(c = r; c < i; c++){
            var n = a[c - 1];
            c % r === 0 ? (n = n << 8 | n >>> 24, n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255], n ^= hr[c / r | 0] << 24) : r > 6 && c % r === 4 && (n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255]), a[c] = a[c - r] ^ n;
        }
        for(var h = [], u = 0; u < i; u++){
            var p = i - u, f = a[p - (u % 4 ? 0 : 4)];
            u < 4 || p <= 4 ? h[u] = f : h[u] = v.INV_SUB_MIX[0][v.SBOX[f >>> 24]] ^ v.INV_SUB_MIX[1][v.SBOX[f >>> 16 & 255]] ^ v.INV_SUB_MIX[2][v.SBOX[f >>> 8 & 255]] ^ v.INV_SUB_MIX[3][v.SBOX[f & 255]];
        }
        this._nRounds = t, this._keySchedule = a, this._invKeySchedule = h;
    };
    g.prototype.encryptBlockRaw = function(e) {
        return e = W(e), Ee(e, this._keySchedule, v.SUB_MIX, v.SBOX, this._nRounds);
    };
    g.prototype.encryptBlock = function(e) {
        var r = this.encryptBlockRaw(e), t = R.allocUnsafe(16);
        return t.writeUInt32BE(r[0], 0), t.writeUInt32BE(r[1], 4), t.writeUInt32BE(r[2], 8), t.writeUInt32BE(r[3], 12), t;
    };
    g.prototype.decryptBlock = function(e) {
        e = W(e);
        var r = e[1];
        e[1] = e[3], e[3] = r;
        var t = Ee(e, this._invKeySchedule, v.INV_SUB_MIX, v.INV_SBOX, this._nRounds), i = R.allocUnsafe(16);
        return i.writeUInt32BE(t[0], 0), i.writeUInt32BE(t[3], 4), i.writeUInt32BE(t[2], 8), i.writeUInt32BE(t[1], 12), i;
    };
    g.prototype.scrub = function() {
        Z(this._keySchedule), Z(this._invKeySchedule), Z(this._key);
    };
    we.exports.AES = g;
});
var xe1 = l11((Zr, Se)=>{
    var A = L1, or = A.alloc(16, 0);
    function pr(e) {
        return [
            e.readUInt32BE(0),
            e.readUInt32BE(4),
            e.readUInt32BE(8),
            e.readUInt32BE(12)
        ];
    }
    function Ce(e) {
        var r = A.allocUnsafe(16);
        return r.writeUInt32BE(e[0] >>> 0, 0), r.writeUInt32BE(e[1] >>> 0, 4), r.writeUInt32BE(e[2] >>> 0, 8), r.writeUInt32BE(e[3] >>> 0, 12), r;
    }
    function q(e) {
        this.h = e, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
    }
    q.prototype.ghash = function(e) {
        for(var r = -1; ++r < e.length;)this.state[r] ^= e[r];
        this._multiply();
    };
    q.prototype._multiply = function() {
        for(var e = pr(this.h), r = [
            0,
            0,
            0,
            0
        ], t, i, a, c = -1; ++c < 128;){
            for(i = (this.state[~~(c / 8)] & 1 << 7 - c % 8) !== 0, i && (r[0] ^= e[0], r[1] ^= e[1], r[2] ^= e[2], r[3] ^= e[3]), a = (e[3] & 1) !== 0, t = 3; t > 0; t--)e[t] = e[t] >>> 1 | (e[t - 1] & 1) << 31;
            e[0] = e[0] >>> 1, a && (e[0] = e[0] ^ 225 << 24);
        }
        this.state = Ce(r);
    };
    q.prototype.update = function(e) {
        this.cache = A.concat([
            this.cache,
            e
        ]);
        for(var r; this.cache.length >= 16;)r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(r);
    };
    q.prototype.final = function(e, r) {
        return this.cache.length && this.ghash(A.concat([
            this.cache,
            or
        ], 16)), this.ghash(Ce([
            0,
            e,
            0,
            r
        ])), this.state;
    };
    Se.exports = q;
});
var J4 = l11((Wr, Ie)=>{
    var ur = k4(), _ = L1, Ae = M4, sr = w, Ue = xe1(), fr = i7, vr = z3();
    function lr(e, r) {
        var t = 0;
        e.length !== r.length && t++;
        for(var i = Math.min(e.length, r.length), a = 0; a < i; ++a)t += e[a] ^ r[a];
        return t;
    }
    function _r(e, r, t) {
        if (r.length === 12) return e._finID = _.concat([
            r,
            _.from([
                0,
                0,
                0,
                1
            ])
        ]), _.concat([
            r,
            _.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var i = new Ue(t), a = r.length, c = a % 16;
        i.update(r), c && (c = 16 - c, i.update(_.alloc(c, 0))), i.update(_.alloc(8, 0));
        var n = a * 8, h = _.alloc(8);
        h.writeUIntBE(n, 0, 8), i.update(h), e._finID = i.state;
        var u = _.from(e._finID);
        return vr(u), u;
    }
    function w1(e, r, t, i) {
        Ae.call(this);
        var a = _.alloc(4, 0);
        this._cipher = new ur.AES(r);
        var c = this._cipher.encryptBlock(a);
        this._ghash = new Ue(c), t = _r(this, t, c), this._prev = _.from(t), this._cache = _.allocUnsafe(0), this._secCache = _.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
    }
    sr(w1, Ae);
    w1.prototype._update = function(e) {
        if (!this._called && this._alen) {
            var r = 16 - this._alen % 16;
            r < 16 && (r = _.alloc(r, 0), this._ghash.update(r));
        }
        this._called = !0;
        var t = this._mode.encrypt(this, e);
        return this._decrypt ? this._ghash.update(e) : this._ghash.update(t), this._len += e.length, t;
    };
    w1.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var e = fr(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && lr(e, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = e, this._cipher.scrub();
    };
    w1.prototype.getAuthTag = function() {
        if (this._decrypt || !_.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    };
    w1.prototype.setAuthTag = function(r) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = r;
    };
    w1.prototype.setAAD = function(r) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(r), this._alen += r.length;
    };
    Ie.exports = w1;
});
var Y3 = l11((Jr, qe)=>{
    var yr = k4(), Q = L1, ke = M4, dr = w;
    function X(e, r, t, i) {
        ke.call(this), this._cipher = new yr.AES(r), this._prev = Q.from(t), this._cache = Q.allocUnsafe(0), this._secCache = Q.allocUnsafe(0), this._decrypt = i, this._mode = e;
    }
    dr(X, ke);
    X.prototype._update = function(e) {
        return this._mode.encrypt(this, e, this._decrypt);
    };
    X.prototype._final = function() {
        this._cipher.scrub();
    };
    qe.exports = X;
});
var Fe1 = l11((j)=>{
    var be = P5(), gr = J4(), m = L1, Br = Y3(), Te = M4, mr = k4(), Er = j3, wr = w;
    function b(e, r, t) {
        Te.call(this), this._cache = new N, this._cipher = new mr.AES(r), this._prev = m.from(t), this._mode = e, this._autopadding = !0;
    }
    wr(b, Te);
    b.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get();)t = this._mode.encrypt(this, r), i.push(t);
        return m.concat(i);
    };
    var Cr = m.alloc(16, 16);
    b.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
        if (!e.equals(Cr)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    b.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function N() {
        this.cache = m.allocUnsafe(0);
    }
    N.prototype.add = function(e) {
        this.cache = m.concat([
            this.cache,
            e
        ]);
    };
    N.prototype.get = function() {
        if (this.cache.length > 15) {
            var e = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), e;
        }
        return null;
    };
    N.prototype.flush = function() {
        for(var e = 16 - this.cache.length, r = m.allocUnsafe(e), t = -1; ++t < e;)r.writeUInt8(e, t);
        return m.concat([
            this.cache,
            r
        ]);
    };
    function De(e, r, t) {
        var i = be[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof r == "string" && (r = m.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        if (typeof t == "string" && (t = m.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        return i.type === "stream" ? new Br(i.module, r, t) : i.type === "auth" ? new gr(i.module, r, t) : new b(i.module, r, t);
    }
    function Sr(e, r) {
        var t = be[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Er(r, !1, t.key, t.iv);
        return De(e, i.key, i.iv);
    }
    j.createCipheriv = De;
    j.createCipher = Sr;
});
var Ve1 = l11((ee)=>{
    var xr = J4(), U = L1, Re = P5(), Ar = Y3(), Xe = M4, Ur = k4(), Ir = j3, kr = w;
    function T(e, r, t) {
        Xe.call(this), this._cache = new V, this._last = void 0, this._cipher = new Ur.AES(r), this._prev = U.from(t), this._mode = e, this._autopadding = !0;
    }
    kr(T, Xe);
    T.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get(this._autopadding);)t = this._mode.decrypt(this, r), i.push(t);
        return U.concat(i);
    };
    T.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return qr(this._mode.decrypt(this, e));
        if (e) throw new Error("data not multiple of block length");
    };
    T.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function V() {
        this.cache = U.allocUnsafe(0);
    }
    V.prototype.add = function(e) {
        this.cache = U.concat([
            this.cache,
            e
        ]);
    };
    V.prototype.get = function(e) {
        var r;
        if (e) {
            if (this.cache.length > 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        } else if (this.cache.length >= 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        return null;
    };
    V.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function qr(e) {
        var r = e[15];
        if (r < 1 || r > 16) throw new Error("unable to decrypt data");
        for(var t = -1; ++t < r;)if (e[t + (16 - r)] !== r) throw new Error("unable to decrypt data");
        if (r !== 16) return e.slice(0, 16 - r);
    }
    function Ne(e, r, t) {
        var i = Re[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof t == "string" && (t = U.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        if (typeof r == "string" && (r = U.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        return i.type === "stream" ? new Ar(i.module, r, t, !0) : i.type === "auth" ? new xr(i.module, r, t, !0) : new T(i.module, r, t);
    }
    function br(e, r) {
        var t = Re[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Ir(r, !1, t.key, t.iv);
        return Ne(e, i.key, i.iv);
    }
    ee.createDecipher = br;
    ee.createDecipheriv = Ne;
});
var re = l11((B)=>{
    var Oe = Fe1(), Me = Ve1(), Tr = L5();
    function Dr() {
        return Object.keys(Tr);
    }
    B.createCipher = B.Cipher = Oe.createCipher;
    B.createCipheriv = B.Cipheriv = Oe.createCipheriv;
    B.createDecipher = B.Decipher = Me.createDecipher;
    B.createDecipheriv = B.Decipheriv = Me.createDecipheriv;
    B.listCiphers = B.getCiphers = Dr;
});
var Ge = ae(re()), ze1 = ae(re()), { createCipher: et , Cipher: rt1 , createCipheriv: tt1 , Cipheriv: it1 , createDecipher: at , Decipher: ct1 , createDecipheriv: nt , Decipheriv: ht1 , listCiphers: ot , getCiphers: pt  } = ze1, { default: Fr , ...Rr } = ze1, ut1 = (Ge.default ?? Fr) ?? Rr;
var l12 = Object.create;
var y9 = Object.defineProperty;
var b5 = Object.getOwnPropertyDescriptor;
var w13 = Object.getOwnPropertyNames;
var d9 = Object.getPrototypeOf, T4 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var S6 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var k5 = (e, r, t, o)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let u of w13(r))!T4.call(e, u) && u !== t && y9(e, u, {
        get: ()=>r[u],
        enumerable: !(o = b5(r, u)) || o.enumerable
    });
    return e;
};
var c8 = (e, r, t)=>(t = e != null ? l12(d9(e)) : {}, k5(r || !e || !e.__esModule ? y9(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var s5 = S6((v, g)=>{
    "use strict";
    var p = export_default, i = p.Buffer, f = {}, n;
    for(n in p)!p.hasOwnProperty(n) || n === "SlowBuffer" || n === "Buffer" || (f[n] = p[n]);
    var a = f.Buffer = {};
    for(n in i)!i.hasOwnProperty(n) || n === "allocUnsafe" || n === "allocUnsafeSlow" || (a[n] = i[n]);
    f.Buffer.prototype = i.prototype;
    (!a.from || a.from === Uint8Array.from) && (a.from = function(e, r, t) {
        if (typeof e == "number") throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
        if (e && typeof e.length > "u") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
        return i(e, r, t);
    });
    a.alloc || (a.alloc = function(e, r, t) {
        if (typeof e != "number") throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
        if (e < 0 || e >= 2 * (1 << 30)) throw new RangeError('The value "' + e + '" is invalid for option "size"');
        var o = i(e);
        return !r || r.length === 0 ? o.fill(0) : typeof t == "string" ? o.fill(r, t) : o.fill(r), o;
    });
    if (!f.kStringMaxLength) try {
        f.kStringMaxLength = process2.binding("buffer").kStringMaxLength;
    } catch  {}
    f.constants || (f.constants = {
        MAX_LENGTH: f.kMaxLength
    }, f.kStringMaxLength && (f.constants.MAX_STRING_LENGTH = f.kStringMaxLength));
    g.exports = f;
});
var h8 = c8(s5()), m10 = c8(s5()), { constants: A6  } = m10, { default: B7 , ...L6 } = m10, E6 = (h8.default ?? B7) ?? L6;
var Be = Object.create;
var J5 = Object.defineProperty;
var we = Object.getOwnPropertyDescriptor;
var De2 = Object.getOwnPropertyNames;
var ve = Object.getPrototypeOf, qe2 = Object.prototype.hasOwnProperty;
((o)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(o, {
        get: (e, t)=>(typeof require != "undefined" ? require : e)[t]
    }) : o)(function(o) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + o + '" is not supported');
});
var h9 = (o, e)=>()=>(e || o((e = {
            exports: {}
        }).exports, e), e.exports);
var ke1 = (o, e, t, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of De2(e))!qe2.call(o, n) && n !== t && J5(o, n, {
        get: ()=>e[n],
        enumerable: !(r = we(e, n)) || r.enumerable
    });
    return o;
};
var V2 = (o, e, t)=>(t = o != null ? Be(ve(o)) : {}, ke1(e || !o || !o.__esModule ? J5(t, "default", {
        value: o,
        enumerable: !0
    }) : t, o));
var k6 = h9((Z)=>{
    "use strict";
    var Ce = w;
    function y(o) {
        this._reporterState = {
            obj: null,
            path: [],
            options: o || {},
            errors: []
        };
    }
    Z.Reporter = y;
    y.prototype.isError = function(e) {
        return e instanceof S;
    };
    y.prototype.save = function() {
        let e = this._reporterState;
        return {
            obj: e.obj,
            pathLen: e.path.length
        };
    };
    y.prototype.restore = function(e) {
        let t = this._reporterState;
        t.obj = e.obj, t.path = t.path.slice(0, e.pathLen);
    };
    y.prototype.enterKey = function(e) {
        return this._reporterState.path.push(e);
    };
    y.prototype.exitKey = function(e) {
        let t = this._reporterState;
        t.path = t.path.slice(0, e - 1);
    };
    y.prototype.leaveKey = function(e, t, r) {
        let n = this._reporterState;
        this.exitKey(e), n.obj !== null && (n.obj[t] = r);
    };
    y.prototype.path = function() {
        return this._reporterState.path.join("/");
    };
    y.prototype.enterObject = function() {
        let e = this._reporterState, t = e.obj;
        return e.obj = {}, t;
    };
    y.prototype.leaveObject = function(e) {
        let t = this._reporterState, r = t.obj;
        return t.obj = e, r;
    };
    y.prototype.error = function(e) {
        let t, r = this._reporterState, n = e instanceof S;
        if (n ? t = e : t = new S(r.path.map(function(i) {
            return "[" + JSON.stringify(i) + "]";
        }).join(""), e.message || e, e.stack), !r.options.partial) throw t;
        return n || r.errors.push(t), t;
    };
    y.prototype.wrapResult = function(e) {
        let t = this._reporterState;
        return t.options.partial ? {
            result: this.isError(e) ? null : e,
            errors: t.errors
        } : e;
    };
    function S(o, e) {
        this.path = o, this.rethrow(e);
    }
    Ce(S, Error);
    S.prototype.rethrow = function(e) {
        if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, S), !this.stack) try {
            throw new Error(this.message);
        } catch (t) {
            this.stack = t.stack;
        }
        return this;
    };
});
var w14 = h9((O)=>{
    "use strict";
    var Ue = w, C = k6().Reporter, j = E6.Buffer;
    function g(o, e) {
        if (C.call(this, e), !j.isBuffer(o)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = o, this.offset = 0, this.length = o.length;
    }
    Ue(g, C);
    O.DecoderBuffer = g;
    g.isDecoderBuffer = function(e) {
        return e instanceof g ? !0 : typeof e == "object" && j.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    g.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: C.prototype.save.call(this)
        };
    };
    g.prototype.restore = function(e) {
        let t = new g(this.base);
        return t.offset = e.offset, t.length = this.offset, this.offset = e.offset, C.prototype.restore.call(this, e.reporter), t;
    };
    g.prototype.isEmpty = function() {
        return this.offset === this.length;
    };
    g.prototype.readUInt8 = function(e) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun");
    };
    g.prototype.skip = function(e, t) {
        if (!(this.offset + e <= this.length)) return this.error(t || "DecoderBuffer overrun");
        let r = new g(this.base);
        return r._reporterState = this._reporterState, r.offset = this.offset, r.length = this.offset + e, this.offset += e, r;
    };
    g.prototype.raw = function(e) {
        return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function B(o, e) {
        if (Array.isArray(o)) this.length = 0, this.value = o.map(function(t) {
            return B.isEncoderBuffer(t) || (t = new B(t, e)), this.length += t.length, t;
        }, this);
        else if (typeof o == "number") {
            if (!(0 <= o && o <= 255)) return e.error("non-byte EncoderBuffer value");
            this.value = o, this.length = 1;
        } else if (typeof o == "string") this.value = o, this.length = j.byteLength(o);
        else if (j.isBuffer(o)) this.value = o, this.length = o.length;
        else return e.error("Unsupported type: " + typeof o);
    }
    O.EncoderBuffer = B;
    B.isEncoderBuffer = function(e) {
        return e instanceof B ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    B.prototype.join = function(e, t) {
        return e || (e = j.alloc(this.length)), t || (t = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(r) {
            r.join(e, t), t += r.length;
        }) : (typeof this.value == "number" ? e[t] = this.value : typeof this.value == "string" ? e.write(this.value, t) : j.isBuffer(this.value) && this.value.copy(e, t), t += this.length)), e;
    };
});
var U2 = h9((tt, Y)=>{
    "use strict";
    var Ne = k6().Reporter, Te = w14().EncoderBuffer, Oe = w14().DecoderBuffer, d = j, H = [
        "seq",
        "seqof",
        "set",
        "setof",
        "objid",
        "bool",
        "gentime",
        "utctime",
        "null_",
        "enum",
        "int",
        "objDesc",
        "bitstr",
        "bmpstr",
        "charstr",
        "genstr",
        "graphstr",
        "ia5str",
        "iso646str",
        "numstr",
        "octstr",
        "printstr",
        "t61str",
        "unistr",
        "utf8str",
        "videostr"
    ], Ae = [
        "key",
        "obj",
        "use",
        "optional",
        "explicit",
        "implicit",
        "def",
        "choice",
        "any",
        "contains"
    ].concat(H), Ie = [
        "_peekTag",
        "_decodeTag",
        "_use",
        "_decodeStr",
        "_decodeObjid",
        "_decodeTime",
        "_decodeNull",
        "_decodeInt",
        "_decodeBool",
        "_decodeList",
        "_encodeComposite",
        "_encodeStr",
        "_encodeObjid",
        "_encodeTime",
        "_encodeNull",
        "_encodeInt",
        "_encodeBool"
    ];
    function f(o, e, t) {
        let r = {};
        this._baseState = r, r.name = t, r.enc = o, r.parent = e || null, r.children = null, r.tag = null, r.args = null, r.reverseArgs = null, r.choice = null, r.optional = !1, r.any = !1, r.obj = !1, r.use = null, r.useDecoder = null, r.key = null, r.default = null, r.explicit = null, r.implicit = null, r.contains = null, r.parent || (r.children = [], this._wrap());
    }
    Y.exports = f;
    var Re = [
        "enc",
        "parent",
        "children",
        "tag",
        "args",
        "reverseArgs",
        "choice",
        "optional",
        "any",
        "obj",
        "use",
        "alteredUse",
        "key",
        "default",
        "explicit",
        "implicit",
        "contains"
    ];
    f.prototype.clone = function() {
        let e = this._baseState, t = {};
        Re.forEach(function(n) {
            t[n] = e[n];
        });
        let r = new this.constructor(t.parent);
        return r._baseState = t, r;
    };
    f.prototype._wrap = function() {
        let e = this._baseState;
        Ae.forEach(function(t) {
            this[t] = function() {
                let n = new this.constructor(this);
                return e.children.push(n), n[t].apply(n, arguments);
            };
        }, this);
    };
    f.prototype._init = function(e) {
        let t = this._baseState;
        d(t.parent === null), e.call(this), t.children = t.children.filter(function(r) {
            return r._baseState.parent === this;
        }, this), d.equal(t.children.length, 1, "Root node can have only one child");
    };
    f.prototype._useArgs = function(e) {
        let t = this._baseState, r = e.filter(function(n) {
            return n instanceof this.constructor;
        }, this);
        e = e.filter(function(n) {
            return !(n instanceof this.constructor);
        }, this), r.length !== 0 && (d(t.children === null), t.children = r, r.forEach(function(n) {
            n._baseState.parent = this;
        }, this)), e.length !== 0 && (d(t.args === null), t.args = e, t.reverseArgs = e.map(function(n) {
            if (typeof n != "object" || n.constructor !== Object) return n;
            let i = {};
            return Object.keys(n).forEach(function(s) {
                s == (s | 0) && (s |= 0);
                let c = n[s];
                i[c] = s;
            }), i;
        }));
    };
    Ie.forEach(function(o) {
        f.prototype[o] = function() {
            let t = this._baseState;
            throw new Error(o + " not implemented for encoding: " + t.enc);
        };
    });
    H.forEach(function(o) {
        f.prototype[o] = function() {
            let t = this._baseState, r = Array.prototype.slice.call(arguments);
            return d(t.tag === null), t.tag = o, this._useArgs(r), this;
        };
    });
    f.prototype.use = function(e) {
        d(e);
        let t = this._baseState;
        return d(t.use === null), t.use = e, this;
    };
    f.prototype.optional = function() {
        let e = this._baseState;
        return e.optional = !0, this;
    };
    f.prototype.def = function(e) {
        let t = this._baseState;
        return d(t.default === null), t.default = e, t.optional = !0, this;
    };
    f.prototype.explicit = function(e) {
        let t = this._baseState;
        return d(t.explicit === null && t.implicit === null), t.explicit = e, this;
    };
    f.prototype.implicit = function(e) {
        let t = this._baseState;
        return d(t.explicit === null && t.implicit === null), t.implicit = e, this;
    };
    f.prototype.obj = function() {
        let e = this._baseState, t = Array.prototype.slice.call(arguments);
        return e.obj = !0, t.length !== 0 && this._useArgs(t), this;
    };
    f.prototype.key = function(e) {
        let t = this._baseState;
        return d(t.key === null), t.key = e, this;
    };
    f.prototype.any = function() {
        let e = this._baseState;
        return e.any = !0, this;
    };
    f.prototype.choice = function(e) {
        let t = this._baseState;
        return d(t.choice === null), t.choice = e, this._useArgs(Object.keys(e).map(function(r) {
            return e[r];
        })), this;
    };
    f.prototype.contains = function(e) {
        let t = this._baseState;
        return d(t.use === null), t.contains = e, this;
    };
    f.prototype._decode = function(e, t) {
        let r = this._baseState;
        if (r.parent === null) return e.wrapResult(r.children[0]._decode(e, t));
        let n = r.default, i = !0, s = null;
        if (r.key !== null && (s = e.enterKey(r.key)), r.optional) {
            let l = null;
            if (r.explicit !== null ? l = r.explicit : r.implicit !== null ? l = r.implicit : r.tag !== null && (l = r.tag), l === null && !r.any) {
                let u = e.save();
                try {
                    r.choice === null ? this._decodeGeneric(r.tag, e, t) : this._decodeChoice(e, t), i = !0;
                } catch  {
                    i = !1;
                }
                e.restore(u);
            } else if (i = this._peekTag(e, l, r.any), e.isError(i)) return i;
        }
        let c;
        if (r.obj && i && (c = e.enterObject()), i) {
            if (r.explicit !== null) {
                let u1 = this._decodeTag(e, r.explicit);
                if (e.isError(u1)) return u1;
                e = u1;
            }
            let l1 = e.offset;
            if (r.use === null && r.choice === null) {
                let u2;
                r.any && (u2 = e.save());
                let a = this._decodeTag(e, r.implicit !== null ? r.implicit : r.tag, r.any);
                if (e.isError(a)) return a;
                r.any ? n = e.raw(u2) : e = a;
            }
            if (t && t.track && r.tag !== null && t.track(e.path(), l1, e.length, "tagged"), t && t.track && r.tag !== null && t.track(e.path(), e.offset, e.length, "content"), r.any || (r.choice === null ? n = this._decodeGeneric(r.tag, e, t) : n = this._decodeChoice(e, t)), e.isError(n)) return n;
            if (!r.any && r.choice === null && r.children !== null && r.children.forEach(function(a) {
                a._decode(e, t);
            }), r.contains && (r.tag === "octstr" || r.tag === "bitstr")) {
                let u3 = new Oe(n);
                n = this._getUse(r.contains, e._reporterState.obj)._decode(u3, t);
            }
        }
        return r.obj && i && (n = e.leaveObject(c)), r.key !== null && (n !== null || i === !0) ? e.leaveKey(s, r.key, n) : s !== null && e.exitKey(s), n;
    };
    f.prototype._decodeGeneric = function(e, t, r) {
        let n = this._baseState;
        return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(t, e, n.args[0], r) : /str$/.test(e) ? this._decodeStr(t, e, r) : e === "objid" && n.args ? this._decodeObjid(t, n.args[0], n.args[1], r) : e === "objid" ? this._decodeObjid(t, null, null, r) : e === "gentime" || e === "utctime" ? this._decodeTime(t, e, r) : e === "null_" ? this._decodeNull(t, r) : e === "bool" ? this._decodeBool(t, r) : e === "objDesc" ? this._decodeStr(t, e, r) : e === "int" || e === "enum" ? this._decodeInt(t, n.args && n.args[0], r) : n.use !== null ? this._getUse(n.use, t._reporterState.obj)._decode(t, r) : t.error("unknown tag: " + e);
    };
    f.prototype._getUse = function(e, t) {
        let r = this._baseState;
        return r.useDecoder = this._use(e, t), d(r.useDecoder._baseState.parent === null), r.useDecoder = r.useDecoder._baseState.children[0], r.implicit !== r.useDecoder._baseState.implicit && (r.useDecoder = r.useDecoder.clone(), r.useDecoder._baseState.implicit = r.implicit), r.useDecoder;
    };
    f.prototype._decodeChoice = function(e, t) {
        let r = this._baseState, n = null, i = !1;
        return Object.keys(r.choice).some(function(s) {
            let c = e.save(), l = r.choice[s];
            try {
                let u = l._decode(e, t);
                if (e.isError(u)) return !1;
                n = {
                    type: s,
                    value: u
                }, i = !0;
            } catch  {
                return e.restore(c), !1;
            }
            return !0;
        }, this), i ? n : e.error("Choice not matched");
    };
    f.prototype._createEncoderBuffer = function(e) {
        return new Te(e, this.reporter);
    };
    f.prototype._encode = function(e, t, r) {
        let n = this._baseState;
        if (n.default !== null && n.default === e) return;
        let i = this._encodeValue(e, t, r);
        if (i !== void 0 && !this._skipDefault(i, t, r)) return i;
    };
    f.prototype._encodeValue = function(e, t, r) {
        let n = this._baseState;
        if (n.parent === null) return n.children[0]._encode(e, t || new Ne);
        let i = null;
        if (this.reporter = t, n.optional && e === void 0) if (n.default !== null) e = n.default;
        else return;
        let s = null, c = !1;
        if (n.any) i = this._createEncoderBuffer(e);
        else if (n.choice) i = this._encodeChoice(e, t);
        else if (n.contains) s = this._getUse(n.contains, r)._encode(e, t), c = !0;
        else if (n.children) s = n.children.map(function(l) {
            if (l._baseState.tag === "null_") return l._encode(null, t, e);
            if (l._baseState.key === null) return t.error("Child should have a key");
            let u = t.enterKey(l._baseState.key);
            if (typeof e != "object") return t.error("Child expected, but input is not object");
            let a = l._encode(e[l._baseState.key], t, e);
            return t.leaveKey(u), a;
        }, this).filter(function(l) {
            return l;
        }), s = this._createEncoderBuffer(s);
        else if (n.tag === "seqof" || n.tag === "setof") {
            if (!(n.args && n.args.length === 1)) return t.error("Too many args for : " + n.tag);
            if (!Array.isArray(e)) return t.error("seqof/setof, but data is not Array");
            let l = this.clone();
            l._baseState.implicit = null, s = this._createEncoderBuffer(e.map(function(u) {
                let a = this._baseState;
                return this._getUse(a.args[0], e)._encode(u, t);
            }, l));
        } else n.use !== null ? i = this._getUse(n.use, r)._encode(e, t) : (s = this._encodePrimitive(n.tag, e), c = !0);
        if (!n.any && n.choice === null) {
            let l1 = n.implicit !== null ? n.implicit : n.tag, u = n.implicit === null ? "universal" : "context";
            l1 === null ? n.use === null && t.error("Tag could be omitted only for .use()") : n.use === null && (i = this._encodeComposite(l1, c, u, s));
        }
        return n.explicit !== null && (i = this._encodeComposite(n.explicit, !1, "context", i)), i;
    };
    f.prototype._encodeChoice = function(e, t) {
        let r = this._baseState, n = r.choice[e.type];
        return n || d(!1, e.type + " not found in " + JSON.stringify(Object.keys(r.choice))), n._encode(e.value, t);
    };
    f.prototype._encodePrimitive = function(e, t) {
        let r = this._baseState;
        if (/str$/.test(e)) return this._encodeStr(t, e);
        if (e === "objid" && r.args) return this._encodeObjid(t, r.reverseArgs[0], r.args[1]);
        if (e === "objid") return this._encodeObjid(t, null, null);
        if (e === "gentime" || e === "utctime") return this._encodeTime(t, e);
        if (e === "null_") return this._encodeNull();
        if (e === "int" || e === "enum") return this._encodeInt(t, r.args && r.reverseArgs[0]);
        if (e === "bool") return this._encodeBool(t);
        if (e === "objDesc") return this._encodeStr(t, e);
        throw new Error("Unsupported tag: " + e);
    };
    f.prototype._isNumstr = function(e) {
        return /^[0-9 ]*$/.test(e);
    };
    f.prototype._isPrintstr = function(e) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
});
var N1 = h9((x)=>{
    "use strict";
    function Q(o) {
        let e = {};
        return Object.keys(o).forEach(function(t) {
            (t | 0) == t && (t = t | 0);
            let r = o[t];
            e[r] = t;
        }), e;
    }
    x.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
    };
    x.tagClassByName = Q(x.tagClass);
    x.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
    };
    x.tagByName = Q(x.tag);
});
var I6 = h9((nt, ee)=>{
    "use strict";
    var Pe = w, E = E6.Buffer, W = U2(), A = N1();
    function X(o) {
        this.enc = "der", this.name = o.name, this.entity = o, this.tree = new b, this.tree._init(o.body);
    }
    ee.exports = X;
    X.prototype.encode = function(e, t) {
        return this.tree._encode(e, t).join();
    };
    function b(o) {
        W.call(this, "der", o);
    }
    Pe(b, W);
    b.prototype._encodeComposite = function(e, t, r, n) {
        let i = Ke(e, t, r, this.reporter);
        if (n.length < 128) {
            let l = E.alloc(2);
            return l[0] = i, l[1] = n.length, this._createEncoderBuffer([
                l,
                n
            ]);
        }
        let s = 1;
        for(let l1 = n.length; l1 >= 256; l1 >>= 8)s++;
        let c = E.alloc(1 + 1 + s);
        c[0] = i, c[1] = 128 | s;
        for(let l2 = 1 + s, u = n.length; u > 0; l2--, u >>= 8)c[l2] = u & 255;
        return this._createEncoderBuffer([
            c,
            n
        ]);
    };
    b.prototype._encodeStr = function(e, t) {
        if (t === "bitstr") return this._createEncoderBuffer([
            e.unused | 0,
            e.data
        ]);
        if (t === "bmpstr") {
            let r = E.alloc(e.length * 2);
            for(let n = 0; n < e.length; n++)r.writeUInt16BE(e.charCodeAt(n), n * 2);
            return this._createEncoderBuffer(r);
        } else return t === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : t === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t) ? this._createEncoderBuffer(e) : t === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + t + " unsupported");
    };
    b.prototype._encodeObjid = function(e, t, r) {
        if (typeof e == "string") {
            if (!t) return this.reporter.error("string objid given, but no values map found");
            if (!t.hasOwnProperty(e)) return this.reporter.error("objid not found in values map");
            e = t[e].split(/[\s.]+/g);
            for(let c = 0; c < e.length; c++)e[c] |= 0;
        } else if (Array.isArray(e)) {
            e = e.slice();
            for(let c1 = 0; c1 < e.length; c1++)e[c1] |= 0;
        }
        if (!Array.isArray(e)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
        if (!r) {
            if (e[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            e.splice(0, 2, e[0] * 40 + e[1]);
        }
        let n = 0;
        for(let c2 = 0; c2 < e.length; c2++){
            let l = e[c2];
            for(n++; l >= 128; l >>= 7)n++;
        }
        let i = E.alloc(n), s = i.length - 1;
        for(let c3 = e.length - 1; c3 >= 0; c3--){
            let l1 = e[c3];
            for(i[s--] = l1 & 127; (l1 >>= 7) > 0;)i[s--] = 128 | l1 & 127;
        }
        return this._createEncoderBuffer(i);
    };
    function m(o) {
        return o < 10 ? "0" + o : o;
    }
    b.prototype._encodeTime = function(e, t) {
        let r, n = new Date(e);
        return t === "gentime" ? r = [
            m(n.getUTCFullYear()),
            m(n.getUTCMonth() + 1),
            m(n.getUTCDate()),
            m(n.getUTCHours()),
            m(n.getUTCMinutes()),
            m(n.getUTCSeconds()),
            "Z"
        ].join("") : t === "utctime" ? r = [
            m(n.getUTCFullYear() % 100),
            m(n.getUTCMonth() + 1),
            m(n.getUTCDate()),
            m(n.getUTCHours()),
            m(n.getUTCMinutes()),
            m(n.getUTCSeconds()),
            "Z"
        ].join("") : this.reporter.error("Encoding " + t + " time is not supported yet"), this._encodeStr(r, "octstr");
    };
    b.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
    };
    b.prototype._encodeInt = function(e, t) {
        if (typeof e == "string") {
            if (!t) return this.reporter.error("String int or enum given, but no values map");
            if (!t.hasOwnProperty(e)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
            e = t[e];
        }
        if (typeof e != "number" && !E.isBuffer(e)) {
            let i = e.toArray();
            !e.sign && i[0] & 128 && i.unshift(0), e = E.from(i);
        }
        if (E.isBuffer(e)) {
            let i1 = e.length;
            e.length === 0 && i1++;
            let s = E.alloc(i1);
            return e.copy(s), e.length === 0 && (s[0] = 0), this._createEncoderBuffer(s);
        }
        if (e < 128) return this._createEncoderBuffer(e);
        if (e < 256) return this._createEncoderBuffer([
            0,
            e
        ]);
        let r = 1;
        for(let i2 = e; i2 >= 256; i2 >>= 8)r++;
        let n = new Array(r);
        for(let i3 = n.length - 1; i3 >= 0; i3--)n[i3] = e & 255, e >>= 8;
        return n[0] & 128 && n.unshift(0), this._createEncoderBuffer(E.from(n));
    };
    b.prototype._encodeBool = function(e) {
        return this._createEncoderBuffer(e ? 255 : 0);
    };
    b.prototype._use = function(e, t) {
        return typeof e == "function" && (e = e(t)), e._getEncoder("der").tree;
    };
    b.prototype._skipDefault = function(e, t, r) {
        let n = this._baseState, i;
        if (n.default === null) return !1;
        let s = e.join();
        if (n.defaultBuffer === void 0 && (n.defaultBuffer = this._encodeValue(n.default, t, r).join()), s.length !== n.defaultBuffer.length) return !1;
        for(i = 0; i < s.length; i++)if (s[i] !== n.defaultBuffer[i]) return !1;
        return !0;
    };
    function Ke(o, e, t, r) {
        let n;
        if (o === "seqof" ? o = "seq" : o === "setof" && (o = "set"), A.tagByName.hasOwnProperty(o)) n = A.tagByName[o];
        else if (typeof o == "number" && (o | 0) === o) n = o;
        else return r.error("Unknown tag: " + o);
        return n >= 31 ? r.error("Multi-octet tag encoding unsupported") : (e || (n |= 32), n |= A.tagClassByName[t || "universal"] << 6, n);
    }
});
var re1 = h9((ot, te)=>{
    "use strict";
    var $e = w, R = I6();
    function P(o) {
        R.call(this, o), this.enc = "pem";
    }
    $e(P, R);
    te.exports = P;
    P.prototype.encode = function(e, t) {
        let n = R.prototype.encode.call(this, e).toString("base64"), i = [
            "-----BEGIN " + t.label + "-----"
        ];
        for(let s = 0; s < n.length; s += 64)i.push(n.slice(s, s + 64));
        return i.push("-----END " + t.label + "-----"), i.join(`
`);
    };
});
var K7 = h9((oe)=>{
    "use strict";
    var ne = oe;
    ne.der = I6();
    ne.pem = re1();
});
var M5 = h9((st, fe)=>{
    "use strict";
    var Me = w, Fe = ki, ie = w14().DecoderBuffer, ce = U2(), se = N1();
    function le(o) {
        this.enc = "der", this.name = o.name, this.entity = o, this.tree = new _, this.tree._init(o.body);
    }
    fe.exports = le;
    le.prototype.decode = function(e, t) {
        return ie.isDecoderBuffer(e) || (e = new ie(e, t)), this.tree._decode(e, t);
    };
    function _(o) {
        ce.call(this, "der", o);
    }
    Me(_, ce);
    _.prototype._peekTag = function(e, t, r) {
        if (e.isEmpty()) return !1;
        let n = e.save(), i = $(e, 'Failed to peek tag: "' + t + '"');
        return e.isError(i) ? i : (e.restore(n), i.tag === t || i.tagStr === t || i.tagStr + "of" === t || r);
    };
    _.prototype._decodeTag = function(e, t, r) {
        let n = $(e, 'Failed to decode tag of "' + t + '"');
        if (e.isError(n)) return n;
        let i = ue(e, n.primitive, 'Failed to get length of "' + t + '"');
        if (e.isError(i)) return i;
        if (!r && n.tag !== t && n.tagStr !== t && n.tagStr + "of" !== t) return e.error('Failed to match tag: "' + t + '"');
        if (n.primitive || i !== null) return e.skip(i, 'Failed to match body of: "' + t + '"');
        let s = e.save(), c = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return e.isError(c) ? c : (i = e.offset - s.offset, e.restore(s), e.skip(i, 'Failed to match body of: "' + t + '"'));
    };
    _.prototype._skipUntilEnd = function(e, t) {
        for(;;){
            let r = $(e, t);
            if (e.isError(r)) return r;
            let n = ue(e, r.primitive, t);
            if (e.isError(n)) return n;
            let i;
            if (r.primitive || n !== null ? i = e.skip(n) : i = this._skipUntilEnd(e, t), e.isError(i)) return i;
            if (r.tagStr === "end") break;
        }
    };
    _.prototype._decodeList = function(e, t, r, n) {
        let i = [];
        for(; !e.isEmpty();){
            let s = this._peekTag(e, "end");
            if (e.isError(s)) return s;
            let c = r.decode(e, "der", n);
            if (e.isError(c) && s) break;
            i.push(c);
        }
        return i;
    };
    _.prototype._decodeStr = function(e, t) {
        if (t === "bitstr") {
            let r = e.readUInt8();
            return e.isError(r) ? r : {
                unused: r,
                data: e.raw()
            };
        } else if (t === "bmpstr") {
            let r1 = e.raw();
            if (r1.length % 2 === 1) return e.error("Decoding of string type: bmpstr length mismatch");
            let n = "";
            for(let i = 0; i < r1.length / 2; i++)n += String.fromCharCode(r1.readUInt16BE(i * 2));
            return n;
        } else if (t === "numstr") {
            let r2 = e.raw().toString("ascii");
            return this._isNumstr(r2) ? r2 : e.error("Decoding of string type: numstr unsupported characters");
        } else {
            if (t === "octstr") return e.raw();
            if (t === "objDesc") return e.raw();
            if (t === "printstr") {
                let r3 = e.raw().toString("ascii");
                return this._isPrintstr(r3) ? r3 : e.error("Decoding of string type: printstr unsupported characters");
            } else return /str$/.test(t) ? e.raw().toString() : e.error("Decoding of string type: " + t + " unsupported");
        }
    };
    _.prototype._decodeObjid = function(e, t, r) {
        let n, i = [], s = 0, c = 0;
        for(; !e.isEmpty();)c = e.readUInt8(), s <<= 7, s |= c & 127, (c & 128) === 0 && (i.push(s), s = 0);
        c & 128 && i.push(s);
        let l = i[0] / 40 | 0, u = i[0] % 40;
        if (r ? n = i : n = [
            l,
            u
        ].concat(i.slice(1)), t) {
            let a = t[n.join(" ")];
            a === void 0 && (a = t[n.join(".")]), a !== void 0 && (n = a);
        }
        return n;
    };
    _.prototype._decodeTime = function(e, t) {
        let r = e.raw().toString(), n, i, s, c, l, u;
        if (t === "gentime") n = r.slice(0, 4) | 0, i = r.slice(4, 6) | 0, s = r.slice(6, 8) | 0, c = r.slice(8, 10) | 0, l = r.slice(10, 12) | 0, u = r.slice(12, 14) | 0;
        else if (t === "utctime") n = r.slice(0, 2) | 0, i = r.slice(2, 4) | 0, s = r.slice(4, 6) | 0, c = r.slice(6, 8) | 0, l = r.slice(8, 10) | 0, u = r.slice(10, 12) | 0, n < 70 ? n = 2e3 + n : n = 1900 + n;
        else return e.error("Decoding " + t + " time is not supported yet");
        return Date.UTC(n, i - 1, s, c, l, u, 0);
    };
    _.prototype._decodeNull = function() {
        return null;
    };
    _.prototype._decodeBool = function(e) {
        let t = e.readUInt8();
        return e.isError(t) ? t : t !== 0;
    };
    _.prototype._decodeInt = function(e, t) {
        let r = e.raw(), n = new Fe(r);
        return t && (n = t[n.toString(10)] || n), n;
    };
    _.prototype._use = function(e, t) {
        return typeof e == "function" && (e = e(t)), e._getDecoder("der").tree;
    };
    function $(o, e) {
        let t = o.readUInt8(e);
        if (o.isError(t)) return t;
        let r = se.tagClass[t >> 6], n = (t & 32) === 0;
        if ((t & 31) === 31) {
            let s = t;
            for(t = 0; (s & 128) === 128;){
                if (s = o.readUInt8(e), o.isError(s)) return s;
                t <<= 7, t |= s & 127;
            }
        } else t &= 31;
        let i = se.tag[t];
        return {
            cls: r,
            primitive: n,
            tag: t,
            tagStr: i
        };
    }
    function ue(o, e, t) {
        let r = o.readUInt8(t);
        if (o.isError(r)) return r;
        if (!e && r === 128) return null;
        if ((r & 128) === 0) return r;
        let n = r & 127;
        if (n > 4) return o.error("length octect is too long");
        r = 0;
        for(let i = 0; i < n; i++){
            r <<= 8;
            let s = o.readUInt8(t);
            if (o.isError(s)) return s;
            r |= s;
        }
        return r;
    }
});
var de = h9((ct, ae)=>{
    "use strict";
    var Ge = w, Le = E6.Buffer, F = M5();
    function G(o) {
        F.call(this, o), this.enc = "pem";
    }
    Ge(G, F);
    ae.exports = G;
    G.prototype.decode = function(e, t) {
        let r = e.toString().split(/[\r\n]+/g), n = t.label.toUpperCase(), i = /^-----(BEGIN|END) ([^-]+)-----$/, s = -1, c = -1;
        for(let a = 0; a < r.length; a++){
            let q = r[a].match(i);
            if (q !== null && q[2] === n) if (s === -1) {
                if (q[1] !== "BEGIN") break;
                s = a;
            } else {
                if (q[1] !== "END") break;
                c = a;
                break;
            }
        }
        if (s === -1 || c === -1) throw new Error("PEM section not found for: " + n);
        let l = r.slice(s + 1, c).join("");
        l.replace(/[^a-z0-9+/=]+/gi, "");
        let u = Le.from(l, "base64");
        return F.prototype.decode.call(this, u, t);
    };
});
var L7 = h9((pe)=>{
    "use strict";
    var he = pe;
    he.der = M5();
    he.pem = de();
});
var ye1 = h9((_e)=>{
    "use strict";
    var ze = K7(), Je = L7(), Ve = w, Ze = _e;
    Ze.define = function(e, t) {
        return new D(e, t);
    };
    function D(o, e) {
        this.name = o, this.body = e, this.decoders = {}, this.encoders = {};
    }
    D.prototype._createNamed = function(e) {
        let t = this.name;
        function r(n) {
            this._initNamed(n, t);
        }
        return Ve(r, e), r.prototype._initNamed = function(i, s) {
            e.call(this, i, s);
        }, new r(this);
    };
    D.prototype._getDecoder = function(e) {
        return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(Je[e])), this.decoders[e];
    };
    D.prototype.decode = function(e, t, r) {
        return this._getDecoder(t).decode(e, r);
    };
    D.prototype._getEncoder = function(e) {
        return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(ze[e])), this.encoders[e];
    };
    D.prototype.encode = function(e, t, r) {
        return this._getEncoder(t).encode(e, r);
    };
});
var me = h9((ge)=>{
    "use strict";
    var T = ge;
    T.Reporter = k6().Reporter;
    T.DecoderBuffer = w14().DecoderBuffer;
    T.EncoderBuffer = w14().EncoderBuffer;
    T.Node = U2();
});
var xe2 = h9((Ee)=>{
    "use strict";
    var be = Ee;
    be._reverse = function(e) {
        let t = {};
        return Object.keys(e).forEach(function(r) {
            (r | 0) == r && (r = r | 0);
            let n = e[r];
            t[n] = r;
        }), t;
    };
    be.der = N1();
});
var z4 = h9((Se)=>{
    "use strict";
    var v = Se;
    v.bignum = ki;
    v.define = ye1().define;
    v.base = me();
    v.constants = xe2();
    v.decoders = L7();
    v.encoders = K7();
});
var je = V2(z4()), He1 = V2(z4()), { default: Ye1 , ...Qe1 } = He1, ht2 = (je.default ?? Ye1) ?? Qe1;
var Y4 = Object.create;
var j4 = Object.defineProperty;
var _5 = Object.getOwnPropertyDescriptor;
var $8 = Object.getOwnPropertyNames;
var U3 = Object.getPrototypeOf, F3 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (i, s)=>(typeof require != "undefined" ? require : i)[s]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var v11 = (e, i)=>()=>(i || e((i = {
            exports: {}
        }).exports, i), i.exports);
var z5 = (e, i, s, n)=>{
    if (i && typeof i == "object" || typeof i == "function") for (let t of $8(i))!F3.call(e, t) && t !== s && j4(e, t, {
        get: ()=>i[t],
        enumerable: !(n = _5(i, t)) || n.enumerable
    });
    return e;
};
var g12 = (e, i, s)=>(s = e != null ? Y4(U3(e)) : {}, z5(i || !e || !e.__esModule ? j4(s, "default", {
        value: e,
        enumerable: !0
    }) : s, e));
var I7 = v11((Ke, A)=>{
    "use strict";
    var o = ht2, E = o.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        });
    }), G = o.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), k = o.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), L = o.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(k), this.key("subjectPublicKey").bitstr());
    }), X = o.define("RelativeDistinguishedName", function() {
        this.setof(G);
    }), H = o.define("RDNSequence", function() {
        this.seqof(X);
    }), q = o.define("Name", function() {
        this.choice({
            rdnSequence: this.use(H)
        });
    }), J = o.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(E), this.key("notAfter").use(E));
    }), M = o.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
    }), O = o.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(k), this.key("issuer").use(q), this.key("validity").use(J), this.key("subject").use(q), this.key("subjectPublicKeyInfo").use(L), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(M).optional());
    }), Q = o.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(O), this.key("signatureAlgorithm").use(k), this.key("signatureValue").bitstr());
    });
    A.exports = Q;
});
var R4 = v11((y)=>{
    "use strict";
    var c = ht2;
    y.certificate = I7();
    var W = c.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    y.RSAPrivateKey = W;
    var Z = c.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    y.RSAPublicKey = Z;
    var ee = c.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(S), this.key("subjectPublicKey").bitstr());
    });
    y.PublicKey = ee;
    var S = c.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), te = c.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(S), this.key("subjectPrivateKey").octstr());
    });
    y.PrivateKey = te;
    var ie = c.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    y.EncryptedPrivateKey = ie;
    var re = c.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    y.DSAPrivateKey = re;
    y.DSAparam = c.define("DSAparam", function() {
        this.int();
    });
    var se = c.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ae), this.key("publicKey").optional().explicit(1).bitstr());
    });
    y.ECPrivateKey = se;
    var ae = c.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        });
    });
    y.signature = c.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
    });
});
var C3 = v11((je, ne)=>{
    ne.exports = {
        "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
        "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
        "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
        "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
        "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
        "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
        "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
        "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
        "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
        "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
        "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
        "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
});
var T5 = v11((ge, x)=>{
    var oe = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, ce = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, ye = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, ue = j3, he = ut1, f = L1;
    x.exports = function(e, i) {
        var s = e.toString(), n = s.match(oe), t;
        if (n) {
            var r = "aes" + n[1], p = f.from(n[2], "hex"), b = f.from(n[3].replace(/[\r\n]/g, ""), "base64"), l = ue(i, p.slice(0, 8), parseInt(n[1], 10)).key, d = [], P = he.createDecipheriv(r, l, p);
            d.push(P.update(b)), d.push(P.final()), t = f.concat(d);
        } else {
            var u = s.match(ye);
            t = f.from(u[2].replace(/[\r\n]/g, ""), "base64");
        }
        var V = s.match(ce)[1];
        return {
            tag: V,
            data: t
        };
    };
});
var K8 = v11((Ee, w)=>{
    var a = R4(), de = C3(), ve = T5(), pe = ut1, le = gr1, m = L1;
    w.exports = D;
    function D(e) {
        var i;
        typeof e == "object" && !m.isBuffer(e) && (i = e.passphrase, e = e.key), typeof e == "string" && (e = m.from(e));
        var s = ve(e, i), n = s.tag, t = s.data, u, r;
        switch(n){
            case "CERTIFICATE":
                r = a.certificate.decode(t, "der").tbsCertificate.subjectPublicKeyInfo;
            case "PUBLIC KEY":
                switch(r || (r = a.PublicKey.decode(t, "der")), u = r.algorithm.algorithm.join("."), u){
                    case "1.2.840.113549.1.1.1":
                        return a.RSAPublicKey.decode(r.subjectPublicKey.data, "der");
                    case "1.2.840.10045.2.1":
                        return r.subjectPrivateKey = r.subjectPublicKey, {
                            type: "ec",
                            data: r
                        };
                    case "1.2.840.10040.4.1":
                        return r.algorithm.params.pub_key = a.DSAparam.decode(r.subjectPublicKey.data, "der"), {
                            type: "dsa",
                            data: r.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + u);
                }
            case "ENCRYPTED PRIVATE KEY":
                t = a.EncryptedPrivateKey.decode(t, "der"), t = fe(t, i);
            case "PRIVATE KEY":
                switch(r = a.PrivateKey.decode(t, "der"), u = r.algorithm.algorithm.join("."), u){
                    case "1.2.840.113549.1.1.1":
                        return a.RSAPrivateKey.decode(r.subjectPrivateKey, "der");
                    case "1.2.840.10045.2.1":
                        return {
                            curve: r.algorithm.curve,
                            privateKey: a.ECPrivateKey.decode(r.subjectPrivateKey, "der").privateKey
                        };
                    case "1.2.840.10040.4.1":
                        return r.algorithm.params.priv_key = a.DSAparam.decode(r.subjectPrivateKey, "der"), {
                            type: "dsa",
                            params: r.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + u);
                }
            case "RSA PUBLIC KEY":
                return a.RSAPublicKey.decode(t, "der");
            case "RSA PRIVATE KEY":
                return a.RSAPrivateKey.decode(t, "der");
            case "DSA PRIVATE KEY":
                return {
                    type: "dsa",
                    params: a.DSAPrivateKey.decode(t, "der")
                };
            case "EC PRIVATE KEY":
                return t = a.ECPrivateKey.decode(t, "der"), {
                    curve: t.parameters.value,
                    privateKey: t.privateKey
                };
            default:
                throw new Error("unknown key type " + n);
        }
    }
    D.signature = a.signature;
    function fe(e, i) {
        var s = e.algorithm.decrypt.kde.kdeparams.salt, n = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), t = de[e.algorithm.decrypt.cipher.algo.join(".")], u = e.algorithm.decrypt.cipher.iv, r = e.subjectPrivateKey, p = parseInt(t.split("-")[1], 10) / 8, b = le.pbkdf2Sync(i, s, n, p, "sha1"), l = pe.createDecipheriv(t, b, u), d = [];
        return d.push(l.update(r)), d.push(l.final()), m.concat(d);
    }
});
var B8 = g12(K8()), N2 = g12(K8()), { signature: qe3  } = N2, { default: be1 , ...ke2 } = N2, Ae1 = (B8.default ?? be1) ?? ke2;
var C4 = Object.create;
var l13 = Object.defineProperty;
var E7 = Object.getOwnPropertyDescriptor;
var H2 = Object.getOwnPropertyNames;
var R5 = Object.getPrototypeOf, b6 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (r, a)=>(typeof require != "undefined" ? require : r)[a]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var v12 = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var z6 = (t, r, a, h)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of H2(r))!b6.call(t, e) && e !== a && l13(t, e, {
        get: ()=>r[e],
        enumerable: !(h = E7(r, e)) || h.enumerable
    });
    return t;
};
var m11 = (t, r, a)=>(a = t != null ? C4(R5(t)) : {}, z6(r || !t || !t.__esModule ? l13(a, "default", {
        value: t,
        enumerable: !0
    }) : a, t));
var x11 = v12((F, w1)=>{
    "use strict";
    var L = w, i = L1, q = M4, O = i.alloc(128), n = 64;
    function d(t, r) {
        q.call(this, "digest"), typeof r == "string" && (r = i.from(r)), this._alg = t, this._key = r, r.length > n ? r = t(r) : r.length < n && (r = i.concat([
            r,
            O
        ], n));
        for(var a = this._ipad = i.allocUnsafe(n), h = this._opad = i.allocUnsafe(n), e = 0; e < n; e++)a[e] = r[e] ^ 54, h[e] = r[e] ^ 92;
        this._hash = [
            a
        ];
    }
    L(d, q);
    d.prototype._update = function(t) {
        this._hash.push(t);
    };
    d.prototype._final = function() {
        var t = this._alg(i.concat(this._hash));
        return this._alg(i.concat([
            this._opad,
            t
        ]));
    };
    w1.exports = d;
});
var _6 = v12((G, B)=>{
    "use strict";
    var S = w, Z = x11(), g = M4, f = L1, D = h5, p = X2, c = Ot, I = f.alloc(128);
    function u(t, r) {
        g.call(this, "digest"), typeof r == "string" && (r = f.from(r));
        var a = t === "sha512" || t === "sha384" ? 128 : 64;
        if (this._alg = t, this._key = r, r.length > a) {
            var h = t === "rmd160" ? new p : c(t);
            r = h.update(r).digest();
        } else r.length < a && (r = f.concat([
            r,
            I
        ], a));
        for(var e = this._ipad = f.allocUnsafe(a), $ = this._opad = f.allocUnsafe(a), o = 0; o < a; o++)e[o] = r[o] ^ 54, $[o] = r[o] ^ 92;
        this._hash = t === "rmd160" ? new p : c(t), this._hash.update(e);
    }
    S(u, g);
    u.prototype._update = function(t) {
        this._hash.update(t);
    };
    u.prototype._final = function() {
        var t = this._hash.digest(), r = this._alg === "rmd160" ? new p : c(this._alg);
        return r.update(this._opad).update(t).digest();
    };
    B.exports = function(r, a) {
        return r = r.toLowerCase(), r === "rmd160" || r === "ripemd160" ? new u("rmd160", a) : r === "md5" ? new Z(D, a) : new u(r, a);
    };
});
var U4 = m11(_6()), M6 = m11(_6()), { default: P6 , ...j5 } = M6, J6 = (U4.default ?? P6) ?? j5;
var __global$3 = globalThis || (typeof window !== "undefined" ? window : self);
var p14 = Object.create;
var l14 = Object.defineProperty;
var c9 = Object.getOwnPropertyDescriptor;
var d10 = Object.getOwnPropertyNames;
var y10 = Object.getPrototypeOf, b7 = Object.prototype.hasOwnProperty;
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (o, e)=>(typeof require != "undefined" ? require : o)[e]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var w15 = (r, o)=>()=>(o || r((o = {
            exports: {}
        }).exports, o), o.exports);
var x12 = (r, o, e, t)=>{
    if (o && typeof o == "object" || typeof o == "function") for (let n of d10(o))!b7.call(r, n) && n !== e && l14(r, n, {
        get: ()=>o[n],
        enumerable: !(t = c9(o, n)) || t.enumerable
    });
    return r;
};
var i8 = (r, o, e)=>(e = r != null ? p14(y10(r)) : {}, x12(o || !r || !r.__esModule ? l14(e, "default", {
        value: r,
        enumerable: !0
    }) : e, r));
var u7 = w15((V, s)=>{
    "use strict";
    var f = 65536, B = 4294967295;
    function g() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var h = L1, a = __global$3.crypto || __global$3.msCrypto;
    a && a.getRandomValues ? s.exports = E : s.exports = g;
    function E(r, o) {
        if (r > B) throw new RangeError("requested too many random bytes");
        var e = h.allocUnsafe(r);
        if (r > 0) if (r > f) for(var t = 0; t < r; t += f)a.getRandomValues(e.slice(t, t + f));
        else a.getRandomValues(e);
        return typeof o == "function" ? process1.nextTick(function() {
            o(null, e);
        }) : e;
    }
});
var m12 = i8(u7()), R6 = i8(u7()), { default: $9 , ...T6 } = R6, q7 = (m12.default ?? $9) ?? T6;
var ci1 = Object.create;
var ai1 = Object.defineProperty;
var wi1 = Object.getOwnPropertyDescriptor;
var yi1 = Object.getOwnPropertyNames;
var xi2 = Object.getPrototypeOf, _i1 = Object.prototype.hasOwnProperty;
((_)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(_, {
        get: (et, v)=>(typeof require != "undefined" ? require : et)[v]
    }) : _)(function(_) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + _ + '" is not supported');
});
var Ai1 = (_, et)=>()=>(et || _((et = {
            exports: {}
        }).exports, et), et.exports);
var Bi1 = (_, et, v, nt)=>{
    if (et && typeof et == "object" || typeof et == "function") for (let l of yi1(et))!_i1.call(_, l) && l !== v && ai1(_, l, {
        get: ()=>et[l],
        enumerable: !(nt = wi1(et, l)) || nt.enumerable
    });
    return _;
};
var li1 = (_, et, v)=>(v = _ != null ? ci1(xi2(_)) : {}, Bi1(et || !_ || !_.__esModule ? ai1(v, "default", {
        value: _,
        enumerable: !0
    }) : v, _));
var It = Ai1((ui, Tt)=>{
    (function(_, et) {
        "use strict";
        function v(s, t) {
            if (!s) throw new Error(t || "Assertion failed");
        }
        function nt(s, t) {
            s.super_ = t;
            var r = function() {};
            r.prototype = t.prototype, s.prototype = new r, s.prototype.constructor = s;
        }
        function l(s, t, r) {
            if (l.isBN(s)) return s;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, s !== null && ((t === "le" || t === "be") && (r = t, t = 10), this._init(s || 0, t || 10, r || "be"));
        }
        typeof _ == "object" ? _.exports = l : et.BN = l, l.BN = l, l.wordSize = 26;
        var at;
        try {
            typeof document < "u" && typeof window.Buffer < "u" ? at = window.Buffer : at = export_default.Buffer;
        } catch  {}
        l.isBN = function(t) {
            return t instanceof l ? !0 : t !== null && typeof t == "object" && t.constructor.wordSize === l.wordSize && Array.isArray(t.words);
        }, l.max = function(t, r) {
            return t.cmp(r) > 0 ? t : r;
        }, l.min = function(t, r) {
            return t.cmp(r) < 0 ? t : r;
        }, l.prototype._init = function(t, r, e) {
            if (typeof t == "number") return this._initNumber(t, r, e);
            if (typeof t == "object") return this._initArray(t, r, e);
            r === "hex" && (r = 16), v(r === (r | 0) && r >= 2 && r <= 36), t = t.toString().replace(/\s+/g, "");
            var h = 0;
            t[0] === "-" && (h++, this.negative = 1), h < t.length && (r === 16 ? this._parseHex(t, h, e) : (this._parseBase(t, r, h), e === "le" && this._initArray(this.toArray(), r, e)));
        }, l.prototype._initNumber = function(t, r, e) {
            t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [
                t & 67108863
            ], this.length = 1) : t < 4503599627370496 ? (this.words = [
                t & 67108863,
                t / 67108864 & 67108863
            ], this.length = 2) : (v(t < 9007199254740992), this.words = [
                t & 67108863,
                t / 67108864 & 67108863,
                1
            ], this.length = 3), e === "le" && this._initArray(this.toArray(), r, e);
        }, l.prototype._initArray = function(t, r, e) {
            if (v(typeof t.length == "number"), t.length <= 0) return this.words = [
                0
            ], this.length = 1, this;
            this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
            for(var h = 0; h < this.length; h++)this.words[h] = 0;
            var n, a, u = 0;
            if (e === "be") for(h = t.length - 1, n = 0; h >= 0; h -= 3)a = t[h] | t[h - 1] << 8 | t[h - 2] << 16, this.words[n] |= a << u & 67108863, this.words[n + 1] = a >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, n++);
            else if (e === "le") for(h = 0, n = 0; h < t.length; h += 3)a = t[h] | t[h + 1] << 8 | t[h + 2] << 16, this.words[n] |= a << u & 67108863, this.words[n + 1] = a >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, n++);
            return this._strip();
        };
        function zt(s, t) {
            var r = s.charCodeAt(t);
            if (r >= 48 && r <= 57) return r - 48;
            if (r >= 65 && r <= 70) return r - 55;
            if (r >= 97 && r <= 102) return r - 87;
            v(!1, "Invalid character in " + s);
        }
        function Et(s, t, r) {
            var e = zt(s, r);
            return r - 1 >= t && (e |= zt(s, r - 1) << 4), e;
        }
        l.prototype._parseHex = function(t, r, e) {
            this.length = Math.ceil((t.length - r) / 6), this.words = new Array(this.length);
            for(var h = 0; h < this.length; h++)this.words[h] = 0;
            var n = 0, a = 0, u;
            if (e === "be") for(h = t.length - 1; h >= r; h -= 2)u = Et(t, r, h) << n, this.words[a] |= u & 67108863, n >= 18 ? (n -= 18, a += 1, this.words[a] |= u >>> 26) : n += 8;
            else {
                var f = t.length - r;
                for(h = f % 2 === 0 ? r + 1 : r; h < t.length; h += 2)u = Et(t, r, h) << n, this.words[a] |= u & 67108863, n >= 18 ? (n -= 18, a += 1, this.words[a] |= u >>> 26) : n += 8;
            }
            this._strip();
        };
        function Ot(s, t, r, e) {
            for(var h = 0, n = 0, a = Math.min(s.length, r), u = t; u < a; u++){
                var f = s.charCodeAt(u) - 48;
                h *= e, f >= 49 ? n = f - 49 + 10 : f >= 17 ? n = f - 17 + 10 : n = f, v(f >= 0 && n < e, "Invalid character"), h += n;
            }
            return h;
        }
        l.prototype._parseBase = function(t, r, e) {
            this.words = [
                0
            ], this.length = 1;
            for(var h = 0, n = 1; n <= 67108863; n *= r)h++;
            h--, n = n / r | 0;
            for(var a = t.length - e, u = a % h, f = Math.min(a, a - u) + e, i = 0, o = e; o < f; o += h)i = Ot(t, o, o + h, r), this.imuln(n), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
            if (u !== 0) {
                var d = 1;
                for(i = Ot(t, o, t.length, r), o = 0; o < u; o++)d *= r;
                this.imuln(d), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
            }
            this._strip();
        }, l.prototype.copy = function(t) {
            t.words = new Array(this.length);
            for(var r = 0; r < this.length; r++)t.words[r] = this.words[r];
            t.length = this.length, t.negative = this.negative, t.red = this.red;
        };
        function Kt(s, t) {
            s.words = t.words, s.length = t.length, s.negative = t.negative, s.red = t.red;
        }
        if (l.prototype._move = function(t) {
            Kt(t, this);
        }, l.prototype.clone = function() {
            var t = new l(null);
            return this.copy(t), t;
        }, l.prototype._expand = function(t) {
            for(; this.length < t;)this.words[this.length++] = 0;
            return this;
        }, l.prototype._strip = function() {
            for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
            return this._normSign();
        }, l.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
            l.prototype[Symbol.for("nodejs.util.inspect.custom")] = ut;
        } catch  {
            l.prototype.inspect = ut;
        }
        else l.prototype.inspect = ut;
        function ut() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var Ft = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000"
        ], mi = [
            0,
            0,
            25,
            16,
            12,
            11,
            10,
            9,
            8,
            8,
            7,
            7,
            7,
            7,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5
        ], pi = [
            0,
            0,
            33554432,
            43046721,
            16777216,
            48828125,
            60466176,
            40353607,
            16777216,
            43046721,
            1e7,
            19487171,
            35831808,
            62748517,
            7529536,
            11390625,
            16777216,
            24137569,
            34012224,
            47045881,
            64e6,
            4084101,
            5153632,
            6436343,
            7962624,
            9765625,
            11881376,
            14348907,
            17210368,
            20511149,
            243e5,
            28629151,
            33554432,
            39135393,
            45435424,
            52521875,
            60466176
        ];
        l.prototype.toString = function(t, r) {
            t = t || 10, r = r | 0 || 1;
            var e;
            if (t === 16 || t === "hex") {
                e = "";
                for(var h = 0, n = 0, a = 0; a < this.length; a++){
                    var u = this.words[a], f = ((u << h | n) & 16777215).toString(16);
                    n = u >>> 24 - h & 16777215, h += 2, h >= 26 && (h -= 26, a--), n !== 0 || a !== this.length - 1 ? e = Ft[6 - f.length] + f + e : e = f + e;
                }
                for(n !== 0 && (e = n.toString(16) + e); e.length % r !== 0;)e = "0" + e;
                return this.negative !== 0 && (e = "-" + e), e;
            }
            if (t === (t | 0) && t >= 2 && t <= 36) {
                var i = mi[t], o = pi[t];
                e = "";
                var d = this.clone();
                for(d.negative = 0; !d.isZero();){
                    var m = d.modrn(o).toString(t);
                    d = d.idivn(o), d.isZero() ? e = m + e : e = Ft[i - m.length] + m + e;
                }
                for(this.isZero() && (e = "0" + e); e.length % r !== 0;)e = "0" + e;
                return this.negative !== 0 && (e = "-" + e), e;
            }
            v(!1, "Base should be between 2 and 36");
        }, l.prototype.toNumber = function() {
            var t = this.words[0];
            return this.length === 2 ? t += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && v(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t : t;
        }, l.prototype.toJSON = function() {
            return this.toString(16, 2);
        }, at && (l.prototype.toBuffer = function(t, r) {
            return this.toArrayLike(at, t, r);
        }), l.prototype.toArray = function(t, r) {
            return this.toArrayLike(Array, t, r);
        };
        var Mi = function(t, r) {
            return t.allocUnsafe ? t.allocUnsafe(r) : new t(r);
        };
        l.prototype.toArrayLike = function(t, r, e) {
            this._strip();
            var h = this.byteLength(), n = e || Math.max(1, h);
            v(h <= n, "byte array longer than desired length"), v(n > 0, "Requested array length <= 0");
            var a = Mi(t, n), u = r === "le" ? "LE" : "BE";
            return this["_toArrayLike" + u](a, h), a;
        }, l.prototype._toArrayLikeLE = function(t, r) {
            for(var e = 0, h = 0, n = 0, a = 0; n < this.length; n++){
                var u = this.words[n] << a | h;
                t[e++] = u & 255, e < t.length && (t[e++] = u >> 8 & 255), e < t.length && (t[e++] = u >> 16 & 255), a === 6 ? (e < t.length && (t[e++] = u >> 24 & 255), h = 0, a = 0) : (h = u >>> 24, a += 2);
            }
            if (e < t.length) for(t[e++] = h; e < t.length;)t[e++] = 0;
        }, l.prototype._toArrayLikeBE = function(t, r) {
            for(var e = t.length - 1, h = 0, n = 0, a = 0; n < this.length; n++){
                var u = this.words[n] << a | h;
                t[e--] = u & 255, e >= 0 && (t[e--] = u >> 8 & 255), e >= 0 && (t[e--] = u >> 16 & 255), a === 6 ? (e >= 0 && (t[e--] = u >> 24 & 255), h = 0, a = 0) : (h = u >>> 24, a += 2);
            }
            if (e >= 0) for(t[e--] = h; e >= 0;)t[e--] = 0;
        }, Math.clz32 ? l.prototype._countBits = function(t) {
            return 32 - Math.clz32(t);
        } : l.prototype._countBits = function(t) {
            var r = t, e = 0;
            return r >= 4096 && (e += 13, r >>>= 13), r >= 64 && (e += 7, r >>>= 7), r >= 8 && (e += 4, r >>>= 4), r >= 2 && (e += 2, r >>>= 2), e + r;
        }, l.prototype._zeroBits = function(t) {
            if (t === 0) return 26;
            var r = t, e = 0;
            return (r & 8191) === 0 && (e += 13, r >>>= 13), (r & 127) === 0 && (e += 7, r >>>= 7), (r & 15) === 0 && (e += 4, r >>>= 4), (r & 3) === 0 && (e += 2, r >>>= 2), (r & 1) === 0 && e++, e;
        }, l.prototype.bitLength = function() {
            var t = this.words[this.length - 1], r = this._countBits(t);
            return (this.length - 1) * 26 + r;
        };
        function gi(s) {
            for(var t = new Array(s.bitLength()), r = 0; r < t.length; r++){
                var e = r / 26 | 0, h = r % 26;
                t[r] = s.words[e] >>> h & 1;
            }
            return t;
        }
        l.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for(var t = 0, r = 0; r < this.length; r++){
                var e = this._zeroBits(this.words[r]);
                if (t += e, e !== 26) break;
            }
            return t;
        }, l.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8);
        }, l.prototype.toTwos = function(t) {
            return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
        }, l.prototype.fromTwos = function(t) {
            return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
        }, l.prototype.isNeg = function() {
            return this.negative !== 0;
        }, l.prototype.neg = function() {
            return this.clone().ineg();
        }, l.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this;
        }, l.prototype.iuor = function(t) {
            for(; this.length < t.length;)this.words[this.length++] = 0;
            for(var r = 0; r < t.length; r++)this.words[r] = this.words[r] | t.words[r];
            return this._strip();
        }, l.prototype.ior = function(t) {
            return v((this.negative | t.negative) === 0), this.iuor(t);
        }, l.prototype.or = function(t) {
            return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this);
        }, l.prototype.uor = function(t) {
            return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this);
        }, l.prototype.iuand = function(t) {
            var r;
            this.length > t.length ? r = t : r = this;
            for(var e = 0; e < r.length; e++)this.words[e] = this.words[e] & t.words[e];
            return this.length = r.length, this._strip();
        }, l.prototype.iand = function(t) {
            return v((this.negative | t.negative) === 0), this.iuand(t);
        }, l.prototype.and = function(t) {
            return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this);
        }, l.prototype.uand = function(t) {
            return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this);
        }, l.prototype.iuxor = function(t) {
            var r, e;
            this.length > t.length ? (r = this, e = t) : (r = t, e = this);
            for(var h = 0; h < e.length; h++)this.words[h] = r.words[h] ^ e.words[h];
            if (this !== r) for(; h < r.length; h++)this.words[h] = r.words[h];
            return this.length = r.length, this._strip();
        }, l.prototype.ixor = function(t) {
            return v((this.negative | t.negative) === 0), this.iuxor(t);
        }, l.prototype.xor = function(t) {
            return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this);
        }, l.prototype.uxor = function(t) {
            return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this);
        }, l.prototype.inotn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = Math.ceil(t / 26) | 0, e = t % 26;
            this._expand(r), e > 0 && r--;
            for(var h = 0; h < r; h++)this.words[h] = ~this.words[h] & 67108863;
            return e > 0 && (this.words[h] = ~this.words[h] & 67108863 >> 26 - e), this._strip();
        }, l.prototype.notn = function(t) {
            return this.clone().inotn(t);
        }, l.prototype.setn = function(t, r) {
            v(typeof t == "number" && t >= 0);
            var e = t / 26 | 0, h = t % 26;
            return this._expand(e + 1), r ? this.words[e] = this.words[e] | 1 << h : this.words[e] = this.words[e] & ~(1 << h), this._strip();
        }, l.prototype.iadd = function(t) {
            var r;
            if (this.negative !== 0 && t.negative === 0) return this.negative = 0, r = this.isub(t), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && t.negative !== 0) return t.negative = 0, r = this.isub(t), t.negative = 1, r._normSign();
            var e, h;
            this.length > t.length ? (e = this, h = t) : (e = t, h = this);
            for(var n = 0, a = 0; a < h.length; a++)r = (e.words[a] | 0) + (h.words[a] | 0) + n, this.words[a] = r & 67108863, n = r >>> 26;
            for(; n !== 0 && a < e.length; a++)r = (e.words[a] | 0) + n, this.words[a] = r & 67108863, n = r >>> 26;
            if (this.length = e.length, n !== 0) this.words[this.length] = n, this.length++;
            else if (e !== this) for(; a < e.length; a++)this.words[a] = e.words[a];
            return this;
        }, l.prototype.add = function(t) {
            var r;
            return t.negative !== 0 && this.negative === 0 ? (t.negative = 0, r = this.sub(t), t.negative ^= 1, r) : t.negative === 0 && this.negative !== 0 ? (this.negative = 0, r = t.sub(this), this.negative = 1, r) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this);
        }, l.prototype.isub = function(t) {
            if (t.negative !== 0) {
                t.negative = 0;
                var r = this.iadd(t);
                return t.negative = 1, r._normSign();
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
            var e = this.cmp(t);
            if (e === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var h, n;
            e > 0 ? (h = this, n = t) : (h = t, n = this);
            for(var a = 0, u = 0; u < n.length; u++)r = (h.words[u] | 0) - (n.words[u] | 0) + a, a = r >> 26, this.words[u] = r & 67108863;
            for(; a !== 0 && u < h.length; u++)r = (h.words[u] | 0) + a, a = r >> 26, this.words[u] = r & 67108863;
            if (a === 0 && u < h.length && h !== this) for(; u < h.length; u++)this.words[u] = h.words[u];
            return this.length = Math.max(this.length, u), h !== this && (this.negative = 1), this._strip();
        }, l.prototype.sub = function(t) {
            return this.clone().isub(t);
        };
        function Ht(s, t, r) {
            r.negative = t.negative ^ s.negative;
            var e = s.length + t.length | 0;
            r.length = e, e = e - 1 | 0;
            var h = s.words[0] | 0, n = t.words[0] | 0, a = h * n, u = a & 67108863, f = a / 67108864 | 0;
            r.words[0] = u;
            for(var i = 1; i < e; i++){
                for(var o = f >>> 26, d = f & 67108863, m = Math.min(i, t.length - 1), p = Math.max(0, i - s.length + 1); p <= m; p++){
                    var M = i - p | 0;
                    h = s.words[M] | 0, n = t.words[p] | 0, a = h * n + d, o += a / 67108864 | 0, d = a & 67108863;
                }
                r.words[i] = d | 0, f = o | 0;
            }
            return f !== 0 ? r.words[i] = f | 0 : r.length--, r._strip();
        }
        var Pt = function(t, r, e) {
            var h = t.words, n = r.words, a = e.words, u = 0, f, i, o, d = h[0] | 0, m = d & 8191, p = d >>> 13, M = h[1] | 0, g = M & 8191, c = M >>> 13, ot = h[2] | 0, w = ot & 8191, y = ot >>> 13, Jt = h[3] | 0, b = Jt & 8191, A = Jt >>> 13, Wt = h[4] | 0, B = Wt & 8191, S = Wt >>> 13, Gt = h[5] | 0, k = Gt & 8191, q = Gt >>> 13, Qt = h[6] | 0, R = Qt & 8191, L = Qt >>> 13, Vt = h[7] | 0, Z = Vt & 8191, N = Vt >>> 13, Xt = h[8] | 0, T = Xt & 8191, I = Xt >>> 13, Yt = h[9] | 0, z = Yt & 8191, E = Yt >>> 13, jt = n[0] | 0, O = jt & 8191, K = jt >>> 13, ti = n[1] | 0, F = ti & 8191, H = ti >>> 13, ii = n[2] | 0, P = ii & 8191, D = ii >>> 13, ri = n[3] | 0, $ = ri & 8191, U = ri >>> 13, ei = n[4] | 0, C = ei & 8191, J = ei >>> 13, hi = n[5] | 0, W = hi & 8191, G = hi >>> 13, fi = n[6] | 0, Q = fi & 8191, V = fi >>> 13, ni = n[7] | 0, X = ni & 8191, Y = ni >>> 13, oi = n[8] | 0, j = oi & 8191, tt = oi >>> 13, si = n[9] | 0, it = si & 8191, rt = si >>> 13;
            e.negative = t.negative ^ r.negative, e.length = 19, f = Math.imul(m, O), i = Math.imul(m, K), i = i + Math.imul(p, O) | 0, o = Math.imul(p, K);
            var mt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, f = Math.imul(g, O), i = Math.imul(g, K), i = i + Math.imul(c, O) | 0, o = Math.imul(c, K), f = f + Math.imul(m, F) | 0, i = i + Math.imul(m, H) | 0, i = i + Math.imul(p, F) | 0, o = o + Math.imul(p, H) | 0;
            var pt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, f = Math.imul(w, O), i = Math.imul(w, K), i = i + Math.imul(y, O) | 0, o = Math.imul(y, K), f = f + Math.imul(g, F) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(c, F) | 0, o = o + Math.imul(c, H) | 0, f = f + Math.imul(m, P) | 0, i = i + Math.imul(m, D) | 0, i = i + Math.imul(p, P) | 0, o = o + Math.imul(p, D) | 0;
            var Mt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, f = Math.imul(b, O), i = Math.imul(b, K), i = i + Math.imul(A, O) | 0, o = Math.imul(A, K), f = f + Math.imul(w, F) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(y, F) | 0, o = o + Math.imul(y, H) | 0, f = f + Math.imul(g, P) | 0, i = i + Math.imul(g, D) | 0, i = i + Math.imul(c, P) | 0, o = o + Math.imul(c, D) | 0, f = f + Math.imul(m, $) | 0, i = i + Math.imul(m, U) | 0, i = i + Math.imul(p, $) | 0, o = o + Math.imul(p, U) | 0;
            var gt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, f = Math.imul(B, O), i = Math.imul(B, K), i = i + Math.imul(S, O) | 0, o = Math.imul(S, K), f = f + Math.imul(b, F) | 0, i = i + Math.imul(b, H) | 0, i = i + Math.imul(A, F) | 0, o = o + Math.imul(A, H) | 0, f = f + Math.imul(w, P) | 0, i = i + Math.imul(w, D) | 0, i = i + Math.imul(y, P) | 0, o = o + Math.imul(y, D) | 0, f = f + Math.imul(g, $) | 0, i = i + Math.imul(g, U) | 0, i = i + Math.imul(c, $) | 0, o = o + Math.imul(c, U) | 0, f = f + Math.imul(m, C) | 0, i = i + Math.imul(m, J) | 0, i = i + Math.imul(p, C) | 0, o = o + Math.imul(p, J) | 0;
            var ct = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, f = Math.imul(k, O), i = Math.imul(k, K), i = i + Math.imul(q, O) | 0, o = Math.imul(q, K), f = f + Math.imul(B, F) | 0, i = i + Math.imul(B, H) | 0, i = i + Math.imul(S, F) | 0, o = o + Math.imul(S, H) | 0, f = f + Math.imul(b, P) | 0, i = i + Math.imul(b, D) | 0, i = i + Math.imul(A, P) | 0, o = o + Math.imul(A, D) | 0, f = f + Math.imul(w, $) | 0, i = i + Math.imul(w, U) | 0, i = i + Math.imul(y, $) | 0, o = o + Math.imul(y, U) | 0, f = f + Math.imul(g, C) | 0, i = i + Math.imul(g, J) | 0, i = i + Math.imul(c, C) | 0, o = o + Math.imul(c, J) | 0, f = f + Math.imul(m, W) | 0, i = i + Math.imul(m, G) | 0, i = i + Math.imul(p, W) | 0, o = o + Math.imul(p, G) | 0;
            var wt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, f = Math.imul(R, O), i = Math.imul(R, K), i = i + Math.imul(L, O) | 0, o = Math.imul(L, K), f = f + Math.imul(k, F) | 0, i = i + Math.imul(k, H) | 0, i = i + Math.imul(q, F) | 0, o = o + Math.imul(q, H) | 0, f = f + Math.imul(B, P) | 0, i = i + Math.imul(B, D) | 0, i = i + Math.imul(S, P) | 0, o = o + Math.imul(S, D) | 0, f = f + Math.imul(b, $) | 0, i = i + Math.imul(b, U) | 0, i = i + Math.imul(A, $) | 0, o = o + Math.imul(A, U) | 0, f = f + Math.imul(w, C) | 0, i = i + Math.imul(w, J) | 0, i = i + Math.imul(y, C) | 0, o = o + Math.imul(y, J) | 0, f = f + Math.imul(g, W) | 0, i = i + Math.imul(g, G) | 0, i = i + Math.imul(c, W) | 0, o = o + Math.imul(c, G) | 0, f = f + Math.imul(m, Q) | 0, i = i + Math.imul(m, V) | 0, i = i + Math.imul(p, Q) | 0, o = o + Math.imul(p, V) | 0;
            var yt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, f = Math.imul(Z, O), i = Math.imul(Z, K), i = i + Math.imul(N, O) | 0, o = Math.imul(N, K), f = f + Math.imul(R, F) | 0, i = i + Math.imul(R, H) | 0, i = i + Math.imul(L, F) | 0, o = o + Math.imul(L, H) | 0, f = f + Math.imul(k, P) | 0, i = i + Math.imul(k, D) | 0, i = i + Math.imul(q, P) | 0, o = o + Math.imul(q, D) | 0, f = f + Math.imul(B, $) | 0, i = i + Math.imul(B, U) | 0, i = i + Math.imul(S, $) | 0, o = o + Math.imul(S, U) | 0, f = f + Math.imul(b, C) | 0, i = i + Math.imul(b, J) | 0, i = i + Math.imul(A, C) | 0, o = o + Math.imul(A, J) | 0, f = f + Math.imul(w, W) | 0, i = i + Math.imul(w, G) | 0, i = i + Math.imul(y, W) | 0, o = o + Math.imul(y, G) | 0, f = f + Math.imul(g, Q) | 0, i = i + Math.imul(g, V) | 0, i = i + Math.imul(c, Q) | 0, o = o + Math.imul(c, V) | 0, f = f + Math.imul(m, X) | 0, i = i + Math.imul(m, Y) | 0, i = i + Math.imul(p, X) | 0, o = o + Math.imul(p, Y) | 0;
            var xt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, f = Math.imul(T, O), i = Math.imul(T, K), i = i + Math.imul(I, O) | 0, o = Math.imul(I, K), f = f + Math.imul(Z, F) | 0, i = i + Math.imul(Z, H) | 0, i = i + Math.imul(N, F) | 0, o = o + Math.imul(N, H) | 0, f = f + Math.imul(R, P) | 0, i = i + Math.imul(R, D) | 0, i = i + Math.imul(L, P) | 0, o = o + Math.imul(L, D) | 0, f = f + Math.imul(k, $) | 0, i = i + Math.imul(k, U) | 0, i = i + Math.imul(q, $) | 0, o = o + Math.imul(q, U) | 0, f = f + Math.imul(B, C) | 0, i = i + Math.imul(B, J) | 0, i = i + Math.imul(S, C) | 0, o = o + Math.imul(S, J) | 0, f = f + Math.imul(b, W) | 0, i = i + Math.imul(b, G) | 0, i = i + Math.imul(A, W) | 0, o = o + Math.imul(A, G) | 0, f = f + Math.imul(w, Q) | 0, i = i + Math.imul(w, V) | 0, i = i + Math.imul(y, Q) | 0, o = o + Math.imul(y, V) | 0, f = f + Math.imul(g, X) | 0, i = i + Math.imul(g, Y) | 0, i = i + Math.imul(c, X) | 0, o = o + Math.imul(c, Y) | 0, f = f + Math.imul(m, j) | 0, i = i + Math.imul(m, tt) | 0, i = i + Math.imul(p, j) | 0, o = o + Math.imul(p, tt) | 0;
            var _t = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, f = Math.imul(z, O), i = Math.imul(z, K), i = i + Math.imul(E, O) | 0, o = Math.imul(E, K), f = f + Math.imul(T, F) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(I, F) | 0, o = o + Math.imul(I, H) | 0, f = f + Math.imul(Z, P) | 0, i = i + Math.imul(Z, D) | 0, i = i + Math.imul(N, P) | 0, o = o + Math.imul(N, D) | 0, f = f + Math.imul(R, $) | 0, i = i + Math.imul(R, U) | 0, i = i + Math.imul(L, $) | 0, o = o + Math.imul(L, U) | 0, f = f + Math.imul(k, C) | 0, i = i + Math.imul(k, J) | 0, i = i + Math.imul(q, C) | 0, o = o + Math.imul(q, J) | 0, f = f + Math.imul(B, W) | 0, i = i + Math.imul(B, G) | 0, i = i + Math.imul(S, W) | 0, o = o + Math.imul(S, G) | 0, f = f + Math.imul(b, Q) | 0, i = i + Math.imul(b, V) | 0, i = i + Math.imul(A, Q) | 0, o = o + Math.imul(A, V) | 0, f = f + Math.imul(w, X) | 0, i = i + Math.imul(w, Y) | 0, i = i + Math.imul(y, X) | 0, o = o + Math.imul(y, Y) | 0, f = f + Math.imul(g, j) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(c, j) | 0, o = o + Math.imul(c, tt) | 0, f = f + Math.imul(m, it) | 0, i = i + Math.imul(m, rt) | 0, i = i + Math.imul(p, it) | 0, o = o + Math.imul(p, rt) | 0;
            var bt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, f = Math.imul(z, F), i = Math.imul(z, H), i = i + Math.imul(E, F) | 0, o = Math.imul(E, H), f = f + Math.imul(T, P) | 0, i = i + Math.imul(T, D) | 0, i = i + Math.imul(I, P) | 0, o = o + Math.imul(I, D) | 0, f = f + Math.imul(Z, $) | 0, i = i + Math.imul(Z, U) | 0, i = i + Math.imul(N, $) | 0, o = o + Math.imul(N, U) | 0, f = f + Math.imul(R, C) | 0, i = i + Math.imul(R, J) | 0, i = i + Math.imul(L, C) | 0, o = o + Math.imul(L, J) | 0, f = f + Math.imul(k, W) | 0, i = i + Math.imul(k, G) | 0, i = i + Math.imul(q, W) | 0, o = o + Math.imul(q, G) | 0, f = f + Math.imul(B, Q) | 0, i = i + Math.imul(B, V) | 0, i = i + Math.imul(S, Q) | 0, o = o + Math.imul(S, V) | 0, f = f + Math.imul(b, X) | 0, i = i + Math.imul(b, Y) | 0, i = i + Math.imul(A, X) | 0, o = o + Math.imul(A, Y) | 0, f = f + Math.imul(w, j) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(y, j) | 0, o = o + Math.imul(y, tt) | 0, f = f + Math.imul(g, it) | 0, i = i + Math.imul(g, rt) | 0, i = i + Math.imul(c, it) | 0, o = o + Math.imul(c, rt) | 0;
            var At = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, f = Math.imul(z, P), i = Math.imul(z, D), i = i + Math.imul(E, P) | 0, o = Math.imul(E, D), f = f + Math.imul(T, $) | 0, i = i + Math.imul(T, U) | 0, i = i + Math.imul(I, $) | 0, o = o + Math.imul(I, U) | 0, f = f + Math.imul(Z, C) | 0, i = i + Math.imul(Z, J) | 0, i = i + Math.imul(N, C) | 0, o = o + Math.imul(N, J) | 0, f = f + Math.imul(R, W) | 0, i = i + Math.imul(R, G) | 0, i = i + Math.imul(L, W) | 0, o = o + Math.imul(L, G) | 0, f = f + Math.imul(k, Q) | 0, i = i + Math.imul(k, V) | 0, i = i + Math.imul(q, Q) | 0, o = o + Math.imul(q, V) | 0, f = f + Math.imul(B, X) | 0, i = i + Math.imul(B, Y) | 0, i = i + Math.imul(S, X) | 0, o = o + Math.imul(S, Y) | 0, f = f + Math.imul(b, j) | 0, i = i + Math.imul(b, tt) | 0, i = i + Math.imul(A, j) | 0, o = o + Math.imul(A, tt) | 0, f = f + Math.imul(w, it) | 0, i = i + Math.imul(w, rt) | 0, i = i + Math.imul(y, it) | 0, o = o + Math.imul(y, rt) | 0;
            var Bt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, f = Math.imul(z, $), i = Math.imul(z, U), i = i + Math.imul(E, $) | 0, o = Math.imul(E, U), f = f + Math.imul(T, C) | 0, i = i + Math.imul(T, J) | 0, i = i + Math.imul(I, C) | 0, o = o + Math.imul(I, J) | 0, f = f + Math.imul(Z, W) | 0, i = i + Math.imul(Z, G) | 0, i = i + Math.imul(N, W) | 0, o = o + Math.imul(N, G) | 0, f = f + Math.imul(R, Q) | 0, i = i + Math.imul(R, V) | 0, i = i + Math.imul(L, Q) | 0, o = o + Math.imul(L, V) | 0, f = f + Math.imul(k, X) | 0, i = i + Math.imul(k, Y) | 0, i = i + Math.imul(q, X) | 0, o = o + Math.imul(q, Y) | 0, f = f + Math.imul(B, j) | 0, i = i + Math.imul(B, tt) | 0, i = i + Math.imul(S, j) | 0, o = o + Math.imul(S, tt) | 0, f = f + Math.imul(b, it) | 0, i = i + Math.imul(b, rt) | 0, i = i + Math.imul(A, it) | 0, o = o + Math.imul(A, rt) | 0;
            var St = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, f = Math.imul(z, C), i = Math.imul(z, J), i = i + Math.imul(E, C) | 0, o = Math.imul(E, J), f = f + Math.imul(T, W) | 0, i = i + Math.imul(T, G) | 0, i = i + Math.imul(I, W) | 0, o = o + Math.imul(I, G) | 0, f = f + Math.imul(Z, Q) | 0, i = i + Math.imul(Z, V) | 0, i = i + Math.imul(N, Q) | 0, o = o + Math.imul(N, V) | 0, f = f + Math.imul(R, X) | 0, i = i + Math.imul(R, Y) | 0, i = i + Math.imul(L, X) | 0, o = o + Math.imul(L, Y) | 0, f = f + Math.imul(k, j) | 0, i = i + Math.imul(k, tt) | 0, i = i + Math.imul(q, j) | 0, o = o + Math.imul(q, tt) | 0, f = f + Math.imul(B, it) | 0, i = i + Math.imul(B, rt) | 0, i = i + Math.imul(S, it) | 0, o = o + Math.imul(S, rt) | 0;
            var kt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, f = Math.imul(z, W), i = Math.imul(z, G), i = i + Math.imul(E, W) | 0, o = Math.imul(E, G), f = f + Math.imul(T, Q) | 0, i = i + Math.imul(T, V) | 0, i = i + Math.imul(I, Q) | 0, o = o + Math.imul(I, V) | 0, f = f + Math.imul(Z, X) | 0, i = i + Math.imul(Z, Y) | 0, i = i + Math.imul(N, X) | 0, o = o + Math.imul(N, Y) | 0, f = f + Math.imul(R, j) | 0, i = i + Math.imul(R, tt) | 0, i = i + Math.imul(L, j) | 0, o = o + Math.imul(L, tt) | 0, f = f + Math.imul(k, it) | 0, i = i + Math.imul(k, rt) | 0, i = i + Math.imul(q, it) | 0, o = o + Math.imul(q, rt) | 0;
            var qt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, f = Math.imul(z, Q), i = Math.imul(z, V), i = i + Math.imul(E, Q) | 0, o = Math.imul(E, V), f = f + Math.imul(T, X) | 0, i = i + Math.imul(T, Y) | 0, i = i + Math.imul(I, X) | 0, o = o + Math.imul(I, Y) | 0, f = f + Math.imul(Z, j) | 0, i = i + Math.imul(Z, tt) | 0, i = i + Math.imul(N, j) | 0, o = o + Math.imul(N, tt) | 0, f = f + Math.imul(R, it) | 0, i = i + Math.imul(R, rt) | 0, i = i + Math.imul(L, it) | 0, o = o + Math.imul(L, rt) | 0;
            var Rt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, f = Math.imul(z, X), i = Math.imul(z, Y), i = i + Math.imul(E, X) | 0, o = Math.imul(E, Y), f = f + Math.imul(T, j) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(I, j) | 0, o = o + Math.imul(I, tt) | 0, f = f + Math.imul(Z, it) | 0, i = i + Math.imul(Z, rt) | 0, i = i + Math.imul(N, it) | 0, o = o + Math.imul(N, rt) | 0;
            var Lt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, f = Math.imul(z, j), i = Math.imul(z, tt), i = i + Math.imul(E, j) | 0, o = Math.imul(E, tt), f = f + Math.imul(T, it) | 0, i = i + Math.imul(T, rt) | 0, i = i + Math.imul(I, it) | 0, o = o + Math.imul(I, rt) | 0;
            var Zt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (o + (i >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, f = Math.imul(z, it), i = Math.imul(z, rt), i = i + Math.imul(E, it) | 0, o = Math.imul(E, rt);
            var Nt = (u + f | 0) + ((i & 8191) << 13) | 0;
            return u = (o + (i >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, a[0] = mt, a[1] = pt, a[2] = Mt, a[3] = gt, a[4] = ct, a[5] = wt, a[6] = yt, a[7] = xt, a[8] = _t, a[9] = bt, a[10] = At, a[11] = Bt, a[12] = St, a[13] = kt, a[14] = qt, a[15] = Rt, a[16] = Lt, a[17] = Zt, a[18] = Nt, u !== 0 && (a[19] = u, e.length++), e;
        };
        Math.imul || (Pt = Ht);
        function Dt(s, t, r) {
            r.negative = t.negative ^ s.negative, r.length = s.length + t.length;
            for(var e = 0, h = 0, n = 0; n < r.length - 1; n++){
                var a = h;
                h = 0;
                for(var u = e & 67108863, f = Math.min(n, t.length - 1), i = Math.max(0, n - s.length + 1); i <= f; i++){
                    var o = n - i, d = s.words[o] | 0, m = t.words[i] | 0, p = d * m, M = p & 67108863;
                    a = a + (p / 67108864 | 0) | 0, M = M + u | 0, u = M & 67108863, a = a + (M >>> 26) | 0, h += a >>> 26, a &= 67108863;
                }
                r.words[n] = u, e = a, a = h;
            }
            return e !== 0 ? r.words[n] = e : r.length--, r._strip();
        }
        function $t(s, t, r) {
            return Dt(s, t, r);
        }
        l.prototype.mulTo = function(t, r) {
            var e, h = this.length + t.length;
            return this.length === 10 && t.length === 10 ? e = Pt(this, t, r) : h < 63 ? e = Ht(this, t, r) : h < 1024 ? e = Dt(this, t, r) : e = $t(this, t, r), e;
        };
        function ft(s, t) {
            this.x = s, this.y = t;
        }
        ft.prototype.makeRBT = function(t) {
            for(var r = new Array(t), e = l.prototype._countBits(t) - 1, h = 0; h < t; h++)r[h] = this.revBin(h, e, t);
            return r;
        }, ft.prototype.revBin = function(t, r, e) {
            if (t === 0 || t === e - 1) return t;
            for(var h = 0, n = 0; n < r; n++)h |= (t & 1) << r - n - 1, t >>= 1;
            return h;
        }, ft.prototype.permute = function(t, r, e, h, n, a) {
            for(var u = 0; u < a; u++)h[u] = r[t[u]], n[u] = e[t[u]];
        }, ft.prototype.transform = function(t, r, e, h, n, a) {
            this.permute(a, t, r, e, h, n);
            for(var u = 1; u < n; u <<= 1)for(var f = u << 1, i = Math.cos(2 * Math.PI / f), o = Math.sin(2 * Math.PI / f), d = 0; d < n; d += f)for(var m = i, p = o, M = 0; M < u; M++){
                var g = e[d + M], c = h[d + M], ot = e[d + M + u], w = h[d + M + u], y = m * ot - p * w;
                w = m * w + p * ot, ot = y, e[d + M] = g + ot, h[d + M] = c + w, e[d + M + u] = g - ot, h[d + M + u] = c - w, M !== f && (y = i * m - o * p, p = i * p + o * m, m = y);
            }
        }, ft.prototype.guessLen13b = function(t, r) {
            var e = Math.max(r, t) | 1, h = e & 1, n = 0;
            for(e = e / 2 | 0; e; e = e >>> 1)n++;
            return 1 << n + 1 + h;
        }, ft.prototype.conjugate = function(t, r, e) {
            if (!(e <= 1)) for(var h = 0; h < e / 2; h++){
                var n = t[h];
                t[h] = t[e - h - 1], t[e - h - 1] = n, n = r[h], r[h] = -r[e - h - 1], r[e - h - 1] = -n;
            }
        }, ft.prototype.normalize13b = function(t, r) {
            for(var e = 0, h = 0; h < r / 2; h++){
                var n = Math.round(t[2 * h + 1] / r) * 8192 + Math.round(t[2 * h] / r) + e;
                t[h] = n & 67108863, n < 67108864 ? e = 0 : e = n / 67108864 | 0;
            }
            return t;
        }, ft.prototype.convert13b = function(t, r, e, h) {
            for(var n = 0, a = 0; a < r; a++)n = n + (t[a] | 0), e[2 * a] = n & 8191, n = n >>> 13, e[2 * a + 1] = n & 8191, n = n >>> 13;
            for(a = 2 * r; a < h; ++a)e[a] = 0;
            v(n === 0), v((n & -8192) === 0);
        }, ft.prototype.stub = function(t) {
            for(var r = new Array(t), e = 0; e < t; e++)r[e] = 0;
            return r;
        }, ft.prototype.mulp = function(t, r, e) {
            var h = 2 * this.guessLen13b(t.length, r.length), n = this.makeRBT(h), a = this.stub(h), u = new Array(h), f = new Array(h), i = new Array(h), o = new Array(h), d = new Array(h), m = new Array(h), p = e.words;
            p.length = h, this.convert13b(t.words, t.length, u, h), this.convert13b(r.words, r.length, o, h), this.transform(u, a, f, i, h, n), this.transform(o, a, d, m, h, n);
            for(var M = 0; M < h; M++){
                var g = f[M] * d[M] - i[M] * m[M];
                i[M] = f[M] * m[M] + i[M] * d[M], f[M] = g;
            }
            return this.conjugate(f, i, h), this.transform(f, i, p, a, h, n), this.conjugate(p, a, h), this.normalize13b(p, h), e.negative = t.negative ^ r.negative, e.length = t.length + r.length, e._strip();
        }, l.prototype.mul = function(t) {
            var r = new l(null);
            return r.words = new Array(this.length + t.length), this.mulTo(t, r);
        }, l.prototype.mulf = function(t) {
            var r = new l(null);
            return r.words = new Array(this.length + t.length), $t(this, t, r);
        }, l.prototype.imul = function(t) {
            return this.clone().mulTo(t, this);
        }, l.prototype.imuln = function(t) {
            var r = t < 0;
            r && (t = -t), v(typeof t == "number"), v(t < 67108864);
            for(var e = 0, h = 0; h < this.length; h++){
                var n = (this.words[h] | 0) * t, a = (n & 67108863) + (e & 67108863);
                e >>= 26, e += n / 67108864 | 0, e += a >>> 26, this.words[h] = a & 67108863;
            }
            return e !== 0 && (this.words[h] = e, this.length++), r ? this.ineg() : this;
        }, l.prototype.muln = function(t) {
            return this.clone().imuln(t);
        }, l.prototype.sqr = function() {
            return this.mul(this);
        }, l.prototype.isqr = function() {
            return this.imul(this.clone());
        }, l.prototype.pow = function(t) {
            var r = gi(t);
            if (r.length === 0) return new l(1);
            for(var e = this, h = 0; h < r.length && r[h] === 0; h++, e = e.sqr());
            if (++h < r.length) for(var n = e.sqr(); h < r.length; h++, n = n.sqr())r[h] !== 0 && (e = e.mul(n));
            return e;
        }, l.prototype.iushln = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26, h = 67108863 >>> 26 - r << 26 - r, n;
            if (r !== 0) {
                var a = 0;
                for(n = 0; n < this.length; n++){
                    var u = this.words[n] & h, f = (this.words[n] | 0) - u << r;
                    this.words[n] = f | a, a = u >>> 26 - r;
                }
                a && (this.words[n] = a, this.length++);
            }
            if (e !== 0) {
                for(n = this.length - 1; n >= 0; n--)this.words[n + e] = this.words[n];
                for(n = 0; n < e; n++)this.words[n] = 0;
                this.length += e;
            }
            return this._strip();
        }, l.prototype.ishln = function(t) {
            return v(this.negative === 0), this.iushln(t);
        }, l.prototype.iushrn = function(t, r, e) {
            v(typeof t == "number" && t >= 0);
            var h;
            r ? h = (r - r % 26) / 26 : h = 0;
            var n = t % 26, a = Math.min((t - n) / 26, this.length), u = 67108863 ^ 67108863 >>> n << n, f = e;
            if (h -= a, h = Math.max(0, h), f) {
                for(var i = 0; i < a; i++)f.words[i] = this.words[i];
                f.length = a;
            }
            if (a !== 0) if (this.length > a) for(this.length -= a, i = 0; i < this.length; i++)this.words[i] = this.words[i + a];
            else this.words[0] = 0, this.length = 1;
            var o = 0;
            for(i = this.length - 1; i >= 0 && (o !== 0 || i >= h); i--){
                var d = this.words[i] | 0;
                this.words[i] = o << 26 - n | d >>> n, o = d & u;
            }
            return f && o !== 0 && (f.words[f.length++] = o), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
        }, l.prototype.ishrn = function(t, r, e) {
            return v(this.negative === 0), this.iushrn(t, r, e);
        }, l.prototype.shln = function(t) {
            return this.clone().ishln(t);
        }, l.prototype.ushln = function(t) {
            return this.clone().iushln(t);
        }, l.prototype.shrn = function(t) {
            return this.clone().ishrn(t);
        }, l.prototype.ushrn = function(t) {
            return this.clone().iushrn(t);
        }, l.prototype.testn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26, h = 1 << r;
            if (this.length <= e) return !1;
            var n = this.words[e];
            return !!(n & h);
        }, l.prototype.imaskn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26;
            if (v(this.negative === 0, "imaskn works only with positive numbers"), this.length <= e) return this;
            if (r !== 0 && e++, this.length = Math.min(e, this.length), r !== 0) {
                var h = 67108863 ^ 67108863 >>> r << r;
                this.words[this.length - 1] &= h;
            }
            return this._strip();
        }, l.prototype.maskn = function(t) {
            return this.clone().imaskn(t);
        }, l.prototype.iaddn = function(t) {
            return v(typeof t == "number"), v(t < 67108864), t < 0 ? this.isubn(-t) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= t ? (this.words[0] = t - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t);
        }, l.prototype._iaddn = function(t) {
            this.words[0] += t;
            for(var r = 0; r < this.length && this.words[r] >= 67108864; r++)this.words[r] -= 67108864, r === this.length - 1 ? this.words[r + 1] = 1 : this.words[r + 1]++;
            return this.length = Math.max(this.length, r + 1), this;
        }, l.prototype.isubn = function(t) {
            if (v(typeof t == "number"), v(t < 67108864), t < 0) return this.iaddn(-t);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
            if (this.words[0] -= t, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else for(var r = 0; r < this.length && this.words[r] < 0; r++)this.words[r] += 67108864, this.words[r + 1] -= 1;
            return this._strip();
        }, l.prototype.addn = function(t) {
            return this.clone().iaddn(t);
        }, l.prototype.subn = function(t) {
            return this.clone().isubn(t);
        }, l.prototype.iabs = function() {
            return this.negative = 0, this;
        }, l.prototype.abs = function() {
            return this.clone().iabs();
        }, l.prototype._ishlnsubmul = function(t, r, e) {
            var h = t.length + e, n;
            this._expand(h);
            var a, u = 0;
            for(n = 0; n < t.length; n++){
                a = (this.words[n + e] | 0) + u;
                var f = (t.words[n] | 0) * r;
                a -= f & 67108863, u = (a >> 26) - (f / 67108864 | 0), this.words[n + e] = a & 67108863;
            }
            for(; n < this.length - e; n++)a = (this.words[n + e] | 0) + u, u = a >> 26, this.words[n + e] = a & 67108863;
            if (u === 0) return this._strip();
            for(v(u === -1), u = 0, n = 0; n < this.length; n++)a = -(this.words[n] | 0) + u, u = a >> 26, this.words[n] = a & 67108863;
            return this.negative = 1, this._strip();
        }, l.prototype._wordDiv = function(t, r) {
            var e = this.length - t.length, h = this.clone(), n = t, a = n.words[n.length - 1] | 0, u = this._countBits(a);
            e = 26 - u, e !== 0 && (n = n.ushln(e), h.iushln(e), a = n.words[n.length - 1] | 0);
            var f = h.length - n.length, i;
            if (r !== "mod") {
                i = new l(null), i.length = f + 1, i.words = new Array(i.length);
                for(var o = 0; o < i.length; o++)i.words[o] = 0;
            }
            var d = h.clone()._ishlnsubmul(n, 1, f);
            d.negative === 0 && (h = d, i && (i.words[f] = 1));
            for(var m = f - 1; m >= 0; m--){
                var p = (h.words[n.length + m] | 0) * 67108864 + (h.words[n.length + m - 1] | 0);
                for(p = Math.min(p / a | 0, 67108863), h._ishlnsubmul(n, p, m); h.negative !== 0;)p--, h.negative = 0, h._ishlnsubmul(n, 1, m), h.isZero() || (h.negative ^= 1);
                i && (i.words[m] = p);
            }
            return i && i._strip(), h._strip(), r !== "div" && e !== 0 && h.iushrn(e), {
                div: i || null,
                mod: h
            };
        }, l.prototype.divmod = function(t, r, e) {
            if (v(!t.isZero()), this.isZero()) return {
                div: new l(0),
                mod: new l(0)
            };
            var h, n, a;
            return this.negative !== 0 && t.negative === 0 ? (a = this.neg().divmod(t, r), r !== "mod" && (h = a.div.neg()), r !== "div" && (n = a.mod.neg(), e && n.negative !== 0 && n.iadd(t)), {
                div: h,
                mod: n
            }) : this.negative === 0 && t.negative !== 0 ? (a = this.divmod(t.neg(), r), r !== "mod" && (h = a.div.neg()), {
                div: h,
                mod: a.mod
            }) : (this.negative & t.negative) !== 0 ? (a = this.neg().divmod(t.neg(), r), r !== "div" && (n = a.mod.neg(), e && n.negative !== 0 && n.isub(t)), {
                div: a.div,
                mod: n
            }) : t.length > this.length || this.cmp(t) < 0 ? {
                div: new l(0),
                mod: this
            } : t.length === 1 ? r === "div" ? {
                div: this.divn(t.words[0]),
                mod: null
            } : r === "mod" ? {
                div: null,
                mod: new l(this.modrn(t.words[0]))
            } : {
                div: this.divn(t.words[0]),
                mod: new l(this.modrn(t.words[0]))
            } : this._wordDiv(t, r);
        }, l.prototype.div = function(t) {
            return this.divmod(t, "div", !1).div;
        }, l.prototype.mod = function(t) {
            return this.divmod(t, "mod", !1).mod;
        }, l.prototype.umod = function(t) {
            return this.divmod(t, "mod", !0).mod;
        }, l.prototype.divRound = function(t) {
            var r = this.divmod(t);
            if (r.mod.isZero()) return r.div;
            var e = r.div.negative !== 0 ? r.mod.isub(t) : r.mod, h = t.ushrn(1), n = t.andln(1), a = e.cmp(h);
            return a < 0 || n === 1 && a === 0 ? r.div : r.div.negative !== 0 ? r.div.isubn(1) : r.div.iaddn(1);
        }, l.prototype.modrn = function(t) {
            var r = t < 0;
            r && (t = -t), v(t <= 67108863);
            for(var e = (1 << 26) % t, h = 0, n = this.length - 1; n >= 0; n--)h = (e * h + (this.words[n] | 0)) % t;
            return r ? -h : h;
        }, l.prototype.modn = function(t) {
            return this.modrn(t);
        }, l.prototype.idivn = function(t) {
            var r = t < 0;
            r && (t = -t), v(t <= 67108863);
            for(var e = 0, h = this.length - 1; h >= 0; h--){
                var n = (this.words[h] | 0) + e * 67108864;
                this.words[h] = n / t | 0, e = n % t;
            }
            return this._strip(), r ? this.ineg() : this;
        }, l.prototype.divn = function(t) {
            return this.clone().idivn(t);
        }, l.prototype.egcd = function(t) {
            v(t.negative === 0), v(!t.isZero());
            var r = this, e = t.clone();
            r.negative !== 0 ? r = r.umod(t) : r = r.clone();
            for(var h = new l(1), n = new l(0), a = new l(0), u = new l(1), f = 0; r.isEven() && e.isEven();)r.iushrn(1), e.iushrn(1), ++f;
            for(var i = e.clone(), o = r.clone(); !r.isZero();){
                for(var d = 0, m = 1; (r.words[0] & m) === 0 && d < 26; ++d, m <<= 1);
                if (d > 0) for(r.iushrn(d); d-- > 0;)(h.isOdd() || n.isOdd()) && (h.iadd(i), n.isub(o)), h.iushrn(1), n.iushrn(1);
                for(var p = 0, M = 1; (e.words[0] & M) === 0 && p < 26; ++p, M <<= 1);
                if (p > 0) for(e.iushrn(p); p-- > 0;)(a.isOdd() || u.isOdd()) && (a.iadd(i), u.isub(o)), a.iushrn(1), u.iushrn(1);
                r.cmp(e) >= 0 ? (r.isub(e), h.isub(a), n.isub(u)) : (e.isub(r), a.isub(h), u.isub(n));
            }
            return {
                a,
                b: u,
                gcd: e.iushln(f)
            };
        }, l.prototype._invmp = function(t) {
            v(t.negative === 0), v(!t.isZero());
            var r = this, e = t.clone();
            r.negative !== 0 ? r = r.umod(t) : r = r.clone();
            for(var h = new l(1), n = new l(0), a = e.clone(); r.cmpn(1) > 0 && e.cmpn(1) > 0;){
                for(var u = 0, f = 1; (r.words[0] & f) === 0 && u < 26; ++u, f <<= 1);
                if (u > 0) for(r.iushrn(u); u-- > 0;)h.isOdd() && h.iadd(a), h.iushrn(1);
                for(var i = 0, o = 1; (e.words[0] & o) === 0 && i < 26; ++i, o <<= 1);
                if (i > 0) for(e.iushrn(i); i-- > 0;)n.isOdd() && n.iadd(a), n.iushrn(1);
                r.cmp(e) >= 0 ? (r.isub(e), h.isub(n)) : (e.isub(r), n.isub(h));
            }
            var d;
            return r.cmpn(1) === 0 ? d = h : d = n, d.cmpn(0) < 0 && d.iadd(t), d;
        }, l.prototype.gcd = function(t) {
            if (this.isZero()) return t.abs();
            if (t.isZero()) return this.abs();
            var r = this.clone(), e = t.clone();
            r.negative = 0, e.negative = 0;
            for(var h = 0; r.isEven() && e.isEven(); h++)r.iushrn(1), e.iushrn(1);
            do {
                for(; r.isEven();)r.iushrn(1);
                for(; e.isEven();)e.iushrn(1);
                var n = r.cmp(e);
                if (n < 0) {
                    var a = r;
                    r = e, e = a;
                } else if (n === 0 || e.cmpn(1) === 0) break;
                r.isub(e);
            }while (!0)
            return e.iushln(h);
        }, l.prototype.invm = function(t) {
            return this.egcd(t).a.umod(t);
        }, l.prototype.isEven = function() {
            return (this.words[0] & 1) === 0;
        }, l.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1;
        }, l.prototype.andln = function(t) {
            return this.words[0] & t;
        }, l.prototype.bincn = function(t) {
            v(typeof t == "number");
            var r = t % 26, e = (t - r) / 26, h = 1 << r;
            if (this.length <= e) return this._expand(e + 1), this.words[e] |= h, this;
            for(var n = h, a = e; n !== 0 && a < this.length; a++){
                var u = this.words[a] | 0;
                u += n, n = u >>> 26, u &= 67108863, this.words[a] = u;
            }
            return n !== 0 && (this.words[a] = n, this.length++), this;
        }, l.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0;
        }, l.prototype.cmpn = function(t) {
            var r = t < 0;
            if (this.negative !== 0 && !r) return -1;
            if (this.negative === 0 && r) return 1;
            this._strip();
            var e;
            if (this.length > 1) e = 1;
            else {
                r && (t = -t), v(t <= 67108863, "Number is too big");
                var h = this.words[0] | 0;
                e = h === t ? 0 : h < t ? -1 : 1;
            }
            return this.negative !== 0 ? -e | 0 : e;
        }, l.prototype.cmp = function(t) {
            if (this.negative !== 0 && t.negative === 0) return -1;
            if (this.negative === 0 && t.negative !== 0) return 1;
            var r = this.ucmp(t);
            return this.negative !== 0 ? -r | 0 : r;
        }, l.prototype.ucmp = function(t) {
            if (this.length > t.length) return 1;
            if (this.length < t.length) return -1;
            for(var r = 0, e = this.length - 1; e >= 0; e--){
                var h = this.words[e] | 0, n = t.words[e] | 0;
                if (h !== n) {
                    h < n ? r = -1 : h > n && (r = 1);
                    break;
                }
            }
            return r;
        }, l.prototype.gtn = function(t) {
            return this.cmpn(t) === 1;
        }, l.prototype.gt = function(t) {
            return this.cmp(t) === 1;
        }, l.prototype.gten = function(t) {
            return this.cmpn(t) >= 0;
        }, l.prototype.gte = function(t) {
            return this.cmp(t) >= 0;
        }, l.prototype.ltn = function(t) {
            return this.cmpn(t) === -1;
        }, l.prototype.lt = function(t) {
            return this.cmp(t) === -1;
        }, l.prototype.lten = function(t) {
            return this.cmpn(t) <= 0;
        }, l.prototype.lte = function(t) {
            return this.cmp(t) <= 0;
        }, l.prototype.eqn = function(t) {
            return this.cmpn(t) === 0;
        }, l.prototype.eq = function(t) {
            return this.cmp(t) === 0;
        }, l.red = function(t) {
            return new x(t);
        }, l.prototype.toRed = function(t) {
            return v(!this.red, "Already a number in reduction context"), v(this.negative === 0, "red works only with positives"), t.convertTo(this)._forceRed(t);
        }, l.prototype.fromRed = function() {
            return v(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, l.prototype._forceRed = function(t) {
            return this.red = t, this;
        }, l.prototype.forceRed = function(t) {
            return v(!this.red, "Already a number in reduction context"), this._forceRed(t);
        }, l.prototype.redAdd = function(t) {
            return v(this.red, "redAdd works only with red numbers"), this.red.add(this, t);
        }, l.prototype.redIAdd = function(t) {
            return v(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t);
        }, l.prototype.redSub = function(t) {
            return v(this.red, "redSub works only with red numbers"), this.red.sub(this, t);
        }, l.prototype.redISub = function(t) {
            return v(this.red, "redISub works only with red numbers"), this.red.isub(this, t);
        }, l.prototype.redShl = function(t) {
            return v(this.red, "redShl works only with red numbers"), this.red.shl(this, t);
        }, l.prototype.redMul = function(t) {
            return v(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t);
        }, l.prototype.redIMul = function(t) {
            return v(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t);
        }, l.prototype.redSqr = function() {
            return v(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, l.prototype.redISqr = function() {
            return v(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, l.prototype.redSqrt = function() {
            return v(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, l.prototype.redInvm = function() {
            return v(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, l.prototype.redNeg = function() {
            return v(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, l.prototype.redPow = function(t) {
            return v(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t);
        };
        var vt = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function ht(s, t) {
            this.name = s, this.p = new l(t, 16), this.n = this.p.bitLength(), this.k = new l(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        ht.prototype._tmp = function() {
            var t = new l(null);
            return t.words = new Array(Math.ceil(this.n / 13)), t;
        }, ht.prototype.ireduce = function(t) {
            var r = t, e;
            do this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength();
            while (e > this.n)
            var h = e < this.n ? -1 : r.ucmp(this.p);
            return h === 0 ? (r.words[0] = 0, r.length = 1) : h > 0 ? r.isub(this.p) : r.strip !== void 0 ? r.strip() : r._strip(), r;
        }, ht.prototype.split = function(t, r) {
            t.iushrn(this.n, 0, r);
        }, ht.prototype.imulK = function(t) {
            return t.imul(this.k);
        };
        function lt() {
            ht.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        nt(lt, ht), lt.prototype.split = function(t, r) {
            for(var e = 4194303, h = Math.min(t.length, 9), n = 0; n < h; n++)r.words[n] = t.words[n];
            if (r.length = h, t.length <= 9) {
                t.words[0] = 0, t.length = 1;
                return;
            }
            var a = t.words[9];
            for(r.words[r.length++] = a & e, n = 10; n < t.length; n++){
                var u = t.words[n] | 0;
                t.words[n - 10] = (u & e) << 4 | a >>> 22, a = u;
            }
            a >>>= 22, t.words[n - 10] = a, a === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9;
        }, lt.prototype.imulK = function(t) {
            t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
            for(var r = 0, e = 0; e < t.length; e++){
                var h = t.words[e] | 0;
                r += h * 977, t.words[e] = r & 67108863, r = h * 64 + (r / 67108864 | 0);
            }
            return t.words[t.length - 1] === 0 && (t.length--, t.words[t.length - 1] === 0 && t.length--), t;
        };
        function Ut() {
            ht.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        nt(Ut, ht);
        function Ct() {
            ht.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        nt(Ct, ht);
        function dt() {
            ht.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        nt(dt, ht), dt.prototype.imulK = function(t) {
            for(var r = 0, e = 0; e < t.length; e++){
                var h = (t.words[e] | 0) * 19 + r, n = h & 67108863;
                h >>>= 26, t.words[e] = n, r = h;
            }
            return r !== 0 && (t.words[t.length++] = r), t;
        }, l._prime = function(t) {
            if (vt[t]) return vt[t];
            var r;
            if (t === "k256") r = new lt;
            else if (t === "p224") r = new Ut;
            else if (t === "p192") r = new Ct;
            else if (t === "p25519") r = new dt;
            else throw new Error("Unknown prime " + t);
            return vt[t] = r, r;
        };
        function x(s) {
            if (typeof s == "string") {
                var t = l._prime(s);
                this.m = t.p, this.prime = t;
            } else v(s.gtn(1), "modulus must be greater than 1"), this.m = s, this.prime = null;
        }
        x.prototype._verify1 = function(t) {
            v(t.negative === 0, "red works only with positives"), v(t.red, "red works only with red numbers");
        }, x.prototype._verify2 = function(t, r) {
            v((t.negative | r.negative) === 0, "red works only with positives"), v(t.red && t.red === r.red, "red works only with red numbers");
        }, x.prototype.imod = function(t) {
            return this.prime ? this.prime.ireduce(t)._forceRed(this) : (Kt(t, t.umod(this.m)._forceRed(this)), t);
        }, x.prototype.neg = function(t) {
            return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
        }, x.prototype.add = function(t, r) {
            this._verify2(t, r);
            var e = t.add(r);
            return e.cmp(this.m) >= 0 && e.isub(this.m), e._forceRed(this);
        }, x.prototype.iadd = function(t, r) {
            this._verify2(t, r);
            var e = t.iadd(r);
            return e.cmp(this.m) >= 0 && e.isub(this.m), e;
        }, x.prototype.sub = function(t, r) {
            this._verify2(t, r);
            var e = t.sub(r);
            return e.cmpn(0) < 0 && e.iadd(this.m), e._forceRed(this);
        }, x.prototype.isub = function(t, r) {
            this._verify2(t, r);
            var e = t.isub(r);
            return e.cmpn(0) < 0 && e.iadd(this.m), e;
        }, x.prototype.shl = function(t, r) {
            return this._verify1(t), this.imod(t.ushln(r));
        }, x.prototype.imul = function(t, r) {
            return this._verify2(t, r), this.imod(t.imul(r));
        }, x.prototype.mul = function(t, r) {
            return this._verify2(t, r), this.imod(t.mul(r));
        }, x.prototype.isqr = function(t) {
            return this.imul(t, t.clone());
        }, x.prototype.sqr = function(t) {
            return this.mul(t, t);
        }, x.prototype.sqrt = function(t) {
            if (t.isZero()) return t.clone();
            var r = this.m.andln(3);
            if (v(r % 2 === 1), r === 3) {
                var e = this.m.add(new l(1)).iushrn(2);
                return this.pow(t, e);
            }
            for(var h = this.m.subn(1), n = 0; !h.isZero() && h.andln(1) === 0;)n++, h.iushrn(1);
            v(!h.isZero());
            var a = new l(1).toRed(this), u = a.redNeg(), f = this.m.subn(1).iushrn(1), i = this.m.bitLength();
            for(i = new l(2 * i * i).toRed(this); this.pow(i, f).cmp(u) !== 0;)i.redIAdd(u);
            for(var o = this.pow(i, h), d = this.pow(t, h.addn(1).iushrn(1)), m = this.pow(t, h), p = n; m.cmp(a) !== 0;){
                for(var M = m, g = 0; M.cmp(a) !== 0; g++)M = M.redSqr();
                v(g < p);
                var c = this.pow(o, new l(1).iushln(p - g - 1));
                d = d.redMul(c), o = c.redSqr(), m = m.redMul(o), p = g;
            }
            return d;
        }, x.prototype.invm = function(t) {
            var r = t._invmp(this.m);
            return r.negative !== 0 ? (r.negative = 0, this.imod(r).redNeg()) : this.imod(r);
        }, x.prototype.pow = function(t, r) {
            if (r.isZero()) return new l(1).toRed(this);
            if (r.cmpn(1) === 0) return t.clone();
            var e = 4, h = new Array(1 << e);
            h[0] = new l(1).toRed(this), h[1] = t;
            for(var n = 2; n < h.length; n++)h[n] = this.mul(h[n - 1], t);
            var a = h[0], u = 0, f = 0, i = r.bitLength() % 26;
            for(i === 0 && (i = 26), n = r.length - 1; n >= 0; n--){
                for(var o = r.words[n], d = i - 1; d >= 0; d--){
                    var m = o >> d & 1;
                    if (a !== h[0] && (a = this.sqr(a)), m === 0 && u === 0) {
                        f = 0;
                        continue;
                    }
                    u <<= 1, u |= m, f++, !(f !== e && (n !== 0 || d !== 0)) && (a = this.mul(a, h[u]), f = 0, u = 0);
                }
                i = 26;
            }
            return a;
        }, x.prototype.convertTo = function(t) {
            var r = t.umod(this.m);
            return r === t ? r.clone() : r;
        }, x.prototype.convertFrom = function(t) {
            var r = t.clone();
            return r.red = null, r;
        }, l.mont = function(t) {
            return new st(t);
        };
        function st(s) {
            x.call(this, s), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new l(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        nt(st, x), st.prototype.convertTo = function(t) {
            return this.imod(t.ushln(this.shift));
        }, st.prototype.convertFrom = function(t) {
            var r = this.imod(t.mul(this.rinv));
            return r.red = null, r;
        }, st.prototype.imul = function(t, r) {
            if (t.isZero() || r.isZero()) return t.words[0] = 0, t.length = 1, t;
            var e = t.imul(r), h = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n = e.isub(h).iushrn(this.shift), a = n;
            return n.cmp(this.m) >= 0 ? a = n.isub(this.m) : n.cmpn(0) < 0 && (a = n.iadd(this.m)), a._forceRed(this);
        }, st.prototype.mul = function(t, r) {
            if (t.isZero() || r.isZero()) return new l(0)._forceRed(this);
            var e = t.mul(r), h = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n = e.isub(h).iushrn(this.shift), a = n;
            return n.cmp(this.m) >= 0 ? a = n.isub(this.m) : n.cmpn(0) < 0 && (a = n.iadd(this.m)), a._forceRed(this);
        }, st.prototype.invm = function(t) {
            var r = this.imod(t._invmp(this.m).mul(this.r2));
            return r._forceRed(this);
        };
    })(typeof Tt > "u" || Tt, ui);
});
var vi = li1(It()), di = li1(It()), { BN: Ri  } = di, { default: Si1 , ...ki2 } = di, Li = (vi.default ?? Si1) ?? ki2;
var v13 = Object.create;
var l15 = Object.defineProperty;
var B9 = Object.getOwnPropertyDescriptor;
var L8 = Object.getOwnPropertyNames;
var P7 = Object.getPrototypeOf, k7 = Object.prototype.hasOwnProperty;
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (e, o)=>(typeof require != "undefined" ? require : e)[o]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var p15 = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var A7 = (r, e, o, d)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of L8(e))!k7.call(r, n) && n !== o && l15(r, n, {
        get: ()=>e[n],
        enumerable: !(d = B9(e, n)) || d.enumerable
    });
    return r;
};
var i9 = (r, e, o)=>(o = r != null ? v13(P7(r)) : {}, A7(e || !r || !r.__esModule ? l15(o, "default", {
        value: r,
        enumerable: !0
    }) : o, r));
var m13 = p15((D, b)=>{
    var u = Li, E = q7;
    function N(r) {
        var e = f(r), o = e.toRed(u.mont(r.modulus)).redPow(new u(r.publicExponent)).fromRed();
        return {
            blinder: o,
            unblinder: e.invm(r.modulus)
        };
    }
    function f(r) {
        var e = r.modulus.byteLength(), o;
        do o = new u(E(e));
        while (o.cmp(r.modulus) >= 0 || !o.umod(r.prime1) || !o.umod(r.prime2))
        return o;
    }
    function s(r, e) {
        var o = N(e), d = e.modulus.byteLength(), n = new u(r).mul(o.blinder).umod(e.modulus), x = n.toRed(u.mont(e.prime1)), R = n.toRed(u.mont(e.prime2)), g = e.coefficient, h = e.prime1, q = e.prime2, y = x.redPow(e.exponent1).fromRed(), t = R.redPow(e.exponent2).fromRed(), $ = y.isub(t).imul(g).umod(h).imul(q);
        return t.iadd($).imul(o.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", d);
    }
    s.getr = f;
    b.exports = s;
});
var c10 = i9(m13()), w16 = i9(m13()), { getr: F4  } = w16, { default: j6 , ...z7 } = w16, G2 = (c10.default ?? j6) ?? z7;
var c11 = Object.create;
var a5 = Object.defineProperty;
var m14 = Object.getOwnPropertyDescriptor;
var q8 = Object.getOwnPropertyNames;
var v14 = Object.getPrototypeOf, _7 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var w17 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var $10 = (e, r, t, o)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of q8(r))!_7.call(e, i) && i !== t && a5(e, i, {
        get: ()=>r[i],
        enumerable: !(o = m14(r, i)) || o.enumerable
    });
    return e;
};
var h10 = (e, r, t)=>(t = e != null ? c11(v14(e)) : {}, $10(r || !e || !e.__esModule ? a5(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var n1 = w17((E, d)=>{
    "use strict";
    var l = w, x = R2, y = X2, D = Ot, f = M4;
    function u(e) {
        f.call(this, "digest"), this._hash = e;
    }
    l(u, f);
    u.prototype._update = function(e) {
        this._hash.update(e);
    };
    u.prototype._final = function() {
        return this._hash.digest();
    };
    d.exports = function(r) {
        return r = r.toLowerCase(), r === "md5" ? new x : r === "rmd160" || r === "ripemd160" ? new y : new u(D(r));
    };
});
var p16 = h10(n1()), H3 = h10(n1()), { default: M7 , ...B10 } = H3, I8 = (p16.default ?? M7) ?? B10;
var O4 = Object.create;
var D3 = Object.defineProperty;
var z8 = Object.getOwnPropertyDescriptor;
var G3 = Object.getOwnPropertyNames;
var J7 = Object.getPrototypeOf, Q4 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, a)=>(typeof require != "undefined" ? require : r)[a]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var l16 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var X3 = (e, r, a, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of G3(r))!Q4.call(e, i) && i !== a && D3(e, i, {
        get: ()=>r[i],
        enumerable: !(t = z8(r, i)) || t.enumerable
    });
    return e;
};
var q9 = (e, r, a)=>(a = e != null ? O4(J7(e)) : {}, X3(r || !e || !e.__esModule ? D3(a, "default", {
        value: e,
        enumerable: !0
    }) : a, e));
var E8 = l16((Sr, Y)=>{
    Y.exports = {
        "1.3.132.0.10": "secp256k1",
        "1.3.132.0.33": "p224",
        "1.2.840.10045.3.1.1": "p192",
        "1.2.840.10045.3.1.7": "p256",
        "1.3.132.0.34": "p384",
        "1.3.132.0.35": "p521"
    };
});
var L9 = l16((Ar, A)=>{
    var d = L1, p = J6, Z = G2, rr = ld.ec, S = ki, er = Ae1, ar = E8();
    function tr(e, r, a, t, i) {
        var s = er(r);
        if (s.curve) {
            if (t !== "ecdsa" && t !== "ecdsa/rsa") throw new Error("wrong private key type");
            return ir(e, s);
        } else if (s.type === "dsa") {
            if (t !== "dsa") throw new Error("wrong private key type");
            return nr(e, s, a);
        } else if (t !== "rsa" && t !== "ecdsa/rsa") throw new Error("wrong private key type");
        e = d.concat([
            i,
            e
        ]);
        for(var c = s.modulus.byteLength(), n = [
            0,
            1
        ]; e.length + n.length + 1 < c;)n.push(255);
        n.push(0);
        for(var h = -1; ++h < e.length;)n.push(e[h]);
        var o = Z(n, s);
        return o;
    }
    function ir(e, r) {
        var a = ar[r.curve.join(".")];
        if (!a) throw new Error("unknown curve " + r.curve.join("."));
        var t = new rr(a), i = t.keyFromPrivate(r.privateKey), s = i.sign(e);
        return d.from(s.toDER());
    }
    function nr(e, r, a) {
        for(var t = r.params.priv_key, i = r.params.p, s = r.params.q, c = r.params.g, n = new S(0), h, o = H(e, s).mod(s), f = !1, v = W(t, s, e, a); f === !1;)h = x(s, v, a), n = dr(c, h, i, s), f = h.invm(s).imul(o.add(t.mul(n))).mod(s), f.cmpn(0) === 0 && (f = !1, n = new S(0));
        return sr(n, f);
    }
    function sr(e, r) {
        e = e.toArray(), r = r.toArray(), e[0] & 128 && (e = [
            0
        ].concat(e)), r[0] & 128 && (r = [
            0
        ].concat(r));
        var a = e.length + r.length + 4, t = [
            48,
            a,
            2,
            e.length
        ];
        return t = t.concat(e, [
            2,
            r.length
        ], r), d.from(t);
    }
    function W(e, r, a, t) {
        if (e = d.from(e.toArray()), e.length < r.byteLength()) {
            var i = d.alloc(r.byteLength() - e.length);
            e = d.concat([
                i,
                e
            ]);
        }
        var s = a.length, c = hr(a, r), n = d.alloc(s);
        n.fill(1);
        var h = d.alloc(s);
        return h = p(t, h).update(n).update(d.from([
            0
        ])).update(e).update(c).digest(), n = p(t, h).update(n).digest(), h = p(t, h).update(n).update(d.from([
            1
        ])).update(e).update(c).digest(), n = p(t, h).update(n).digest(), {
            k: h,
            v: n
        };
    }
    function H(e, r) {
        var a = new S(e), t = (e.length << 3) - r.bitLength();
        return t > 0 && a.ishrn(t), a;
    }
    function hr(e, r) {
        e = H(e, r), e = e.mod(r);
        var a = d.from(e.toArray());
        if (a.length < r.byteLength()) {
            var t = d.alloc(r.byteLength() - a.length);
            a = d.concat([
                t,
                a
            ]);
        }
        return a;
    }
    function x(e, r, a) {
        var t, i;
        do {
            for(t = d.alloc(0); t.length * 8 < e.bitLength();)r.v = p(a, r.k).update(r.v).digest(), t = d.concat([
                t,
                r.v
            ]);
            i = H(t, e), r.k = p(a, r.k).update(r.v).update(d.from([
                0
            ])).digest(), r.v = p(a, r.k).update(r.v).digest();
        }while (i.cmp(e) !== -1)
        return i;
    }
    function dr(e, r, a, t) {
        return e.toRed(S.mont(a)).redPow(r).fromRed().mod(t);
    }
    A.exports = tr;
    A.exports.getKey = W;
    A.exports.makeKey = x;
});
var K9 = l16((Rr, I)=>{
    var k = L1, m = ki, or = ld.ec, B = Ae1, ur = E8();
    function cr(e, r, a, t, i) {
        var s = B(a);
        if (s.type === "ec") {
            if (t !== "ecdsa" && t !== "ecdsa/rsa") throw new Error("wrong public key type");
            return fr(e, r, s);
        } else if (s.type === "dsa") {
            if (t !== "dsa") throw new Error("wrong public key type");
            return vr(e, r, s);
        } else if (t !== "rsa" && t !== "ecdsa/rsa") throw new Error("wrong public key type");
        r = k.concat([
            i,
            r
        ]);
        for(var c = s.modulus.byteLength(), n = [
            1
        ], h = 0; r.length + n.length + 2 < c;)n.push(255), h++;
        n.push(0);
        for(var o = -1; ++o < r.length;)n.push(r[o]);
        n = k.from(n);
        var f = m.mont(s.modulus);
        e = new m(e).toRed(f), e = e.redPow(new m(s.publicExponent)), e = k.from(e.fromRed().toArray());
        var v = h < 8 ? 1 : 0;
        for(c = Math.min(e.length, n.length), e.length !== n.length && (v = 1), o = -1; ++o < c;)v |= e[o] ^ n[o];
        return v === 0;
    }
    function fr(e, r, a) {
        var t = ur[a.data.algorithm.curve.join(".")];
        if (!t) throw new Error("unknown curve " + a.data.algorithm.curve.join("."));
        var i = new or(t), s = a.data.subjectPrivateKey.data;
        return i.verify(r, e, s);
    }
    function vr(e, r, a) {
        var t = a.data.p, i = a.data.q, s = a.data.g, c = a.data.pub_key, n = B.signature.decode(e, "der"), h = n.s, o = n.r;
        V(h, i), V(o, i);
        var f = m.mont(t), v = h.invm(i), F = s.toRed(f).redPow(new m(r).mul(v).mod(i)).fromRed().mul(c.toRed(f).redPow(o.mul(v).mod(i)).fromRed()).mod(t).mod(i);
        return F.cmp(o) === 0;
    }
    function V(e, r) {
        if (e.cmpn(0) <= 0) throw new Error("invalid sig");
        if (e.cmp(r) >= r) throw new Error("invalid sig");
    }
    I.exports = cr;
});
var P8 = l16((_r, pr)=>{
    pr.exports = {
        sha224WithRSAEncryption: {
            sign: "rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        "RSA-SHA224": {
            sign: "ecdsa/rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        sha256WithRSAEncryption: {
            sign: "rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        "RSA-SHA256": {
            sign: "ecdsa/rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        sha384WithRSAEncryption: {
            sign: "rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        "RSA-SHA384": {
            sign: "ecdsa/rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        sha512WithRSAEncryption: {
            sign: "rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA512": {
            sign: "ecdsa/rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA1": {
            sign: "rsa",
            hash: "sha1",
            id: "3021300906052b0e03021a05000414"
        },
        "ecdsa-with-SHA1": {
            sign: "ecdsa",
            hash: "sha1",
            id: ""
        },
        sha256: {
            sign: "ecdsa",
            hash: "sha256",
            id: ""
        },
        sha224: {
            sign: "ecdsa",
            hash: "sha224",
            id: ""
        },
        sha384: {
            sign: "ecdsa",
            hash: "sha384",
            id: ""
        },
        sha512: {
            sign: "ecdsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-SHA1": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        DSA: {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-WITH-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-WITH-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-WITH-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-WITH-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-RIPEMD160": {
            sign: "dsa",
            hash: "rmd160",
            id: ""
        },
        ripemd160WithRSA: {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        "RSA-RIPEMD160": {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        md5WithRSAEncryption: {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        },
        "RSA-MD5": {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        }
    };
});
var b8 = l16((Er, N)=>{
    var R = L1, $ = I8, _ = Hi, C = w, gr = L9(), lr = K9(), g = P8();
    Object.keys(g).forEach(function(e) {
        g[e].id = R.from(g[e].id, "hex"), g[e.toLowerCase()] = g[e];
    });
    function w1(e) {
        _.Writable.call(this);
        var r = g[e];
        if (!r) throw new Error("Unknown message digest");
        this._hashType = r.hash, this._hash = $(r.hash), this._tag = r.id, this._signType = r.sign;
    }
    C(w1, _.Writable);
    w1.prototype._write = function(r, a, t) {
        this._hash.update(r), t();
    };
    w1.prototype.update = function(r, a) {
        return typeof r == "string" && (r = R.from(r, a)), this._hash.update(r), this;
    };
    w1.prototype.sign = function(r, a) {
        this.end();
        var t = this._hash.digest(), i = gr(t, r, this._hashType, this._signType, this._tag);
        return a ? i.toString(a) : i;
    };
    function y(e) {
        _.Writable.call(this);
        var r = g[e];
        if (!r) throw new Error("Unknown message digest");
        this._hash = $(r.hash), this._tag = r.id, this._signType = r.sign;
    }
    C(y, _.Writable);
    y.prototype._write = function(r, a, t) {
        this._hash.update(r), t();
    };
    y.prototype.update = function(r, a) {
        return typeof r == "string" && (r = R.from(r, a)), this._hash.update(r), this;
    };
    y.prototype.verify = function(r, a, t) {
        typeof a == "string" && (a = R.from(a, t)), this.end();
        var i = this._hash.digest();
        return lr(a, i, r, this._signType, this._tag);
    };
    function j(e) {
        return new w1(e);
    }
    function M(e) {
        return new y(e);
    }
    N.exports = {
        Sign: j,
        Verify: M,
        createSign: j,
        createVerify: M
    };
});
var T7 = q9(b8()), U5 = q9(b8()), { createSign: Hr , Sign: kr , createVerify: br1 , Verify: Dr  } = U5, { default: mr1 , ...wr1 } = U5, qr = (T7.default ?? mr1) ?? wr1;
var M8 = Object.create;
var w18 = Object.defineProperty;
var $11 = Object.getOwnPropertyDescriptor;
var L10 = Object.getOwnPropertyNames;
var S7 = Object.getPrototypeOf, D4 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var P9 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var z9 = (e, r, t, o)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of L10(r))!D4.call(e, n) && n !== t && w18(e, n, {
        get: ()=>r[n],
        enumerable: !(o = $11(r, n)) || o.enumerable
    });
    return e;
};
var R7 = (e, r, t)=>(t = e != null ? M8(S7(e)) : {}, z9(r || !e || !e.__esModule ? w18(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var h11 = P9((E, _)=>{
    var u = ki, j = C;
    function v(e) {
        this.rand = e || new j.Rand;
    }
    _.exports = v;
    v.create = function(r) {
        return new v(r);
    };
    v.prototype._randbelow = function(r) {
        var t = r.bitLength(), o = Math.ceil(t / 8);
        do var n = new u(this.rand.generate(o));
        while (n.cmp(r) >= 0)
        return n;
    };
    v.prototype._randrange = function(r, t) {
        var o = t.sub(r);
        return r.add(this._randbelow(o));
    };
    v.prototype.test = function(r, t, o) {
        var n = r.bitLength(), c = u.mont(r), p = new u(1).toRed(c);
        t || (t = Math.max(1, n / 48 | 0));
        for(var i = r.subn(1), f = 0; !i.testn(f); f++);
        for(var s = r.shrn(f), m = i.toRed(c), l = !0; t > 0; t--){
            var a = this._randrange(new u(2), i);
            o && o(a);
            var d = a.toRed(c).redPow(s);
            if (!(d.cmp(p) === 0 || d.cmp(m) === 0)) {
                for(var b = 1; b < f; b++){
                    if (d = d.redSqr(), d.cmp(p) === 0) return !1;
                    if (d.cmp(m) === 0) break;
                }
                if (b === f) return !1;
            }
        }
        return l;
    };
    v.prototype.getDivisor = function(r, t) {
        var o = r.bitLength(), n = u.mont(r), c = new u(1).toRed(n);
        t || (t = Math.max(1, o / 48 | 0));
        for(var p = r.subn(1), i = 0; !p.testn(i); i++);
        for(var f = r.shrn(i), s = p.toRed(n); t > 0; t--){
            var m = this._randrange(new u(2), p), l = r.gcd(m);
            if (l.cmpn(1) !== 0) return l;
            var a = m.toRed(n).redPow(f);
            if (!(a.cmp(c) === 0 || a.cmp(s) === 0)) {
                for(var d = 1; d < i; d++){
                    if (a = a.redSqr(), a.cmp(c) === 0) return a.fromRed().subn(1).gcd(r);
                    if (a.cmp(s) === 0) break;
                }
                if (d === i) return a = a.redSqr(), a.fromRed().subn(1).gcd(r);
            }
        }
        return !1;
    };
});
var q10 = R7(h11()), y11 = R7(h11()), { create: F5  } = y11, { default: A8 , ...B11 } = y11, G4 = (q10.default ?? A8) ?? B11;
var O5 = Object.create;
var B12 = Object.defineProperty;
var V3 = Object.getOwnPropertyDescriptor;
var L11 = Object.getOwnPropertyNames;
var M9 = Object.getPrototypeOf, F6 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (f, a)=>(typeof require != "undefined" ? require : f)[a]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var s6 = (e, f)=>()=>(f || e((f = {
            exports: {}
        }).exports, f), f.exports);
var I9 = (e, f, a, c)=>{
    if (f && typeof f == "object" || typeof f == "function") for (let d of L11(f))!F6.call(e, d) && d !== a && B12(e, d, {
        get: ()=>f[d],
        enumerable: !(c = V3(f, d)) || c.enumerable
    });
    return e;
};
var g13 = (e, f, a)=>(a = e != null ? O5(M9(e)) : {}, I9(f || !e || !e.__esModule ? B12(a, "default", {
        value: e,
        enumerable: !0
    }) : a, e));
var _8 = s6((we, R)=>{
    var W = q7;
    R.exports = w;
    w.simpleSieve = v;
    w.fermatTest = h;
    var b = ki, $ = new b(24), U = G4, P = new U, A = new b(1), p = new b(2), Y = new b(5), le = new b(16), pe = new b(8), X = new b(10), k = new b(3), ve = new b(7), z = new b(11), H = new b(4), he = new b(12), l = null;
    function J() {
        if (l !== null) return l;
        var e = 1048576, f = [];
        f[0] = 2;
        for(var a = 1, c = 3; c < e; c += 2){
            for(var d = Math.ceil(Math.sqrt(c)), i = 0; i < a && f[i] <= d && c % f[i] !== 0; i++);
            a !== i && f[i] <= d || (f[a++] = c);
        }
        return l = f, f;
    }
    function v(e) {
        for(var f = J(), a = 0; a < f.length; a++)if (e.modn(f[a]) === 0) return e.cmpn(f[a]) === 0;
        return !0;
    }
    function h(e) {
        var f = b.mont(e);
        return p.toRed(f).redPow(e.subn(1)).fromRed().cmpn(1) === 0;
    }
    function w(e, f) {
        if (e < 16) return f === 2 || f === 5 ? new b([
            140,
            123
        ]) : new b([
            140,
            39
        ]);
        f = new b(f);
        for(var a, c;;){
            for(a = new b(W(Math.ceil(e / 8))); a.bitLength() > e;)a.ishrn(1);
            if (a.isEven() && a.iadd(A), a.testn(1) || a.iadd(p), f.cmp(p)) {
                if (!f.cmp(Y)) for(; a.mod(X).cmp(k);)a.iadd(H);
            } else for(; a.mod($).cmp(z);)a.iadd(H);
            if (c = a.shrn(1), v(c) && v(a) && h(c) && h(a) && P.test(c) && P.test(a)) return a;
        }
    }
});
var D5 = s6((_e, Q)=>{
    Q.exports = {
        modp1: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
        },
        modp2: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
        },
        modp5: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
        },
        modp14: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
        },
        modp15: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
        },
        modp16: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
        },
        modp17: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
        },
        modp18: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
        }
    };
});
var S8 = s6((ye, N)=>{
    var r = ki, Z = G4, T = new Z, j = new r(24), ee = new r(11), fe = new r(10), ae = new r(3), ce = new r(7), x = _8(), de = q7;
    N.exports = t;
    function be(e, f) {
        return f = f || "utf8", Buffer.isBuffer(e) || (e = new Buffer(e, f)), this._pub = new r(e), this;
    }
    function re(e, f) {
        return f = f || "utf8", Buffer.isBuffer(e) || (e = new Buffer(e, f)), this._priv = new r(e), this;
    }
    var o = {};
    function ie(e, f) {
        var a = f.toString("hex"), c = [
            a,
            e.toString(16)
        ].join("_");
        if (c in o) return o[c];
        var d = 0;
        if (e.isEven() || !x.simpleSieve || !x.fermatTest(e) || !T.test(e)) return d += 1, a === "02" || a === "05" ? d += 8 : d += 4, o[c] = d, d;
        T.test(e.shrn(1)) || (d += 2);
        var i;
        switch(a){
            case "02":
                e.mod(j).cmp(ee) && (d += 8);
                break;
            case "05":
                i = e.mod(fe), i.cmp(ae) && i.cmp(ce) && (d += 8);
                break;
            default:
                d += 4;
        }
        return o[c] = d, d;
    }
    function t(e, f, a) {
        this.setGenerator(f), this.__prime = new r(e), this._prime = r.mont(this.__prime), this._primeLen = e.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, a ? (this.setPublicKey = be, this.setPrivateKey = re) : this._primeCode = 8;
    }
    Object.defineProperty(t.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = ie(this.__prime, this.__gen)), this._primeCode;
        }
    });
    t.prototype.generateKeys = function() {
        return this._priv || (this._priv = new r(de(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    t.prototype.computeSecret = function(e) {
        e = new r(e), e = e.toRed(this._prime);
        var f = e.redPow(this._priv).fromRed(), a = new Buffer(f.toArray()), c = this.getPrime();
        if (a.length < c.length) {
            var d = new Buffer(c.length - a.length);
            d.fill(0), a = Buffer.concat([
                d,
                a
            ]);
        }
        return a;
    };
    t.prototype.getPublicKey = function(f) {
        return m(this._pub, f);
    };
    t.prototype.getPrivateKey = function(f) {
        return m(this._priv, f);
    };
    t.prototype.getPrime = function(e) {
        return m(this.__prime, e);
    };
    t.prototype.getGenerator = function(e) {
        return m(this._gen, e);
    };
    t.prototype.setGenerator = function(e, f) {
        return f = f || "utf8", Buffer.isBuffer(e) || (e = new Buffer(e, f)), this.__gen = e, this._gen = new r(e), this;
    };
    function m(e, f) {
        var a = new Buffer(e.toArray());
        return f ? a.toString(f) : a;
    }
});
var E9 = s6((u)=>{
    var te = _8(), q = D5(), y = S8();
    function ne(e) {
        var f = new Buffer(q[e].prime, "hex"), a = new Buffer(q[e].gen, "hex");
        return new y(f, a);
    }
    var ue = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function K(e, f, a, c) {
        return Buffer.isBuffer(f) || ue[f] === void 0 ? K(e, "binary", f, a) : (f = f || "binary", c = c || "binary", a = a || new Buffer([
            2
        ]), Buffer.isBuffer(a) || (a = new Buffer(a, c)), typeof e == "number" ? new y(te(e, a), a, !0) : (Buffer.isBuffer(e) || (e = new Buffer(e, f)), new y(e, a, !0)));
    }
    u.DiffieHellmanGroup = u.createDiffieHellmanGroup = u.getDiffieHellman = ne;
    u.createDiffieHellman = u.DiffieHellman = K;
});
var G5 = g13(E9()), C5 = g13(E9()), { DiffieHellmanGroup: Be1 , createDiffieHellmanGroup: ge , getDiffieHellman: Pe2 , createDiffieHellman: He2 , DiffieHellman: Re1  } = C5, { default: se1 , ...oe } = C5, De3 = (G5.default ?? se1) ?? oe;
var y12 = Object.create;
var r = Object.defineProperty;
var m15 = Object.getOwnPropertyDescriptor;
var a6 = Object.getOwnPropertyNames;
var b9 = Object.getPrototypeOf, l17 = Object.prototype.hasOwnProperty;
var p17 = (d, e)=>()=>(e || d((e = {
            exports: {}
        }).exports, e), e.exports);
var u8 = (d, e, t, i)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let c of a6(e))!l17.call(d, c) && c !== t && r(d, c, {
        get: ()=>e[c],
        enumerable: !(i = m15(e, c)) || i.enumerable
    });
    return d;
};
var f5 = (d, e, t)=>(t = d != null ? y12(b9(d)) : {}, u8(e || !d || !d.__esModule ? r(t, "default", {
        value: d,
        enumerable: !0
    }) : t, d));
var o3 = p17((s)=>{
    s["des-ecb"] = {
        key: 8,
        iv: 0
    };
    s["des-cbc"] = s.des = {
        key: 8,
        iv: 8
    };
    s["des-ede3-cbc"] = s.des3 = {
        key: 24,
        iv: 8
    };
    s["des-ede3"] = {
        key: 24,
        iv: 0
    };
    s["des-ede-cbc"] = {
        key: 16,
        iv: 8
    };
    s["des-ede"] = {
        key: 16,
        iv: 0
    };
});
var k8 = f5(o3()), v15 = f5(o3()), { des: h12 , des3: j7  } = v15, { default: $12 , ...n2 } = v15, q11 = (k8.default ?? $12) ?? n2;
var H4 = Object.create;
var S9 = Object.defineProperty;
var J8 = Object.getOwnPropertyDescriptor;
var K10 = Object.getOwnPropertyNames;
var L12 = Object.getPrototypeOf, Q5 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, c)=>(typeof require != "undefined" ? require : r)[c]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var p18 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var V4 = (e, r, c, a)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of K10(r))!Q5.call(e, t) && t !== c && S9(e, t, {
        get: ()=>r[t],
        enumerable: !(a = J8(r, t)) || a.enumerable
    });
    return e;
};
var A9 = (e, r, c)=>(c = e != null ? H4(L12(e)) : {}, V4(r || !e || !e.__esModule ? S9(c, "default", {
        value: e,
        enumerable: !0
    }) : c, e));
var b10 = p18((B)=>{
    B.encrypt = function(e, r) {
        return e._cipher.encryptBlock(r);
    };
    B.decrypt = function(e, r) {
        return e._cipher.decryptBlock(r);
    };
});
var s7 = p18((_)=>{
    var g = i7;
    _.encrypt = function(e, r) {
        var c = g(r, e._prev);
        return e._prev = e._cipher.encryptBlock(c), e._prev;
    };
    _.decrypt = function(e, r) {
        var c = e._prev;
        e._prev = r;
        var a = e._cipher.decryptBlock(r);
        return g(a, c);
    };
});
var w19 = p18((F)=>{
    var h = L1, W = i7;
    function q(e, r, c) {
        var a = r.length, t = W(r, e._cache);
        return e._cache = e._cache.slice(a), e._prev = h.concat([
            e._prev,
            c ? r : t
        ]), t;
    }
    F.encrypt = function(e, r, c) {
        for(var a = h.allocUnsafe(0), t; r.length;)if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = h.allocUnsafe(0)), e._cache.length <= r.length) t = e._cache.length, a = h.concat([
            a,
            q(e, r.slice(0, t), c)
        ]), r = r.slice(t);
        else {
            a = h.concat([
                a,
                q(e, r, c)
            ]);
            break;
        }
        return a;
    };
});
var x13 = p18((U)=>{
    var d = L1;
    function X(e, r, c) {
        var a = e._cipher.encryptBlock(e._prev), t = a[0] ^ r;
        return e._prev = d.concat([
            e._prev.slice(1),
            d.from([
                c ? r : t
            ])
        ]), t;
    }
    U.encrypt = function(e, r, c) {
        for(var a = r.length, t = d.allocUnsafe(a), i = -1; ++i < a;)t[i] = X(e, r[i], c);
        return t;
    };
});
var f6 = p18((I)=>{
    var y = L1;
    function Y(e, r, c) {
        for(var a, t = -1, i = 8, o = 0, v, m; ++t < i;)a = e._cipher.encryptBlock(e._prev), v = r & 1 << 7 - t ? 128 : 0, m = a[0] ^ v, o += (m & 128) >> t % 8, e._prev = Z(e._prev, c ? v : m);
        return o;
    }
    function Z(e, r) {
        var c = e.length, a = -1, t = y.allocUnsafe(e.length);
        for(e = y.concat([
            e,
            y.from([
                r
            ])
        ]); ++a < c;)t[a] = e[a] << 1 | e[a + 1] >> 7;
        return t;
    }
    I.encrypt = function(e, r, c) {
        for(var a = r.length, t = y.allocUnsafe(a), i = -1; ++i < a;)t[i] = Y(e, r[i], c);
        return t;
    };
});
var R8 = p18((M)=>{
    var P = i7;
    function ee(e) {
        return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
    }
    M.encrypt = function(e, r) {
        for(; e._cache.length < r.length;)e._cache = Buffer.concat([
            e._cache,
            ee(e)
        ]);
        var c = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), P(r, c);
    };
});
var O6 = p18((de, G)=>{
    function re(e) {
        for(var r = e.length, c; r--;)if (c = e.readUInt8(r), c === 255) e.writeUInt8(0, r);
        else {
            c++, e.writeUInt8(c, r);
            break;
        }
    }
    G.exports = re;
});
var l18 = p18(($)=>{
    var ce = i7, T = L1, te = O6();
    function ae(e) {
        var r = e._cipher.encryptBlockRaw(e._prev);
        return te(e._prev), r;
    }
    var k = 16;
    $.encrypt = function(e, r) {
        var c = Math.ceil(r.length / k), a = e._cache.length;
        e._cache = T.concat([
            e._cache,
            T.allocUnsafe(c * k)
        ]);
        for(var t = 0; t < c; t++){
            var i = ae(e), o = a + t * k;
            e._cache.writeUInt32BE(i[0], o + 0), e._cache.writeUInt32BE(i[1], o + 4), e._cache.writeUInt32BE(i[2], o + 8), e._cache.writeUInt32BE(i[3], o + 12);
        }
        var v = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), ce(r, v);
    };
});
var z10 = p18((le, ie)=>{
    ie.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
});
var E10 = p18((Ce, N)=>{
    var pe = {
        ECB: b10(),
        CBC: s7(),
        CFB: w19(),
        CFB8: x13(),
        CFB1: f6(),
        OFB: R8(),
        CTR: l18(),
        GCM: l18()
    }, u = z10();
    for(C in u)u[C].module = pe[u[C].mode];
    var C;
    N.exports = u;
});
var j8 = A9(E10()), D6 = A9(E10()), { aes128: Ee , aes192: Se , aes256: Ae2  } = D6, { default: ne , ...oe1 } = D6, be2 = (j8.default ?? ne) ?? oe1;
var He3 = Object.create;
var ie1 = Object.defineProperty;
var Ke1 = Object.getOwnPropertyDescriptor;
var Le4 = Object.getOwnPropertyNames;
var $e1 = Object.getPrototypeOf, Pe3 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, t)=>(typeof require != "undefined" ? require : r)[t]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var l19 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var Ze1 = (e, r, t, i)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let a of Le4(r))!Pe3.call(e, a) && a !== t && ie1(e, a, {
        get: ()=>r[a],
        enumerable: !(i = Ke1(r, a)) || i.enumerable
    });
    return e;
};
var ae1 = (e, r, t)=>(t = e != null ? He3($e1(e)) : {}, Ze1(r || !e || !e.__esModule ? ie1(t, "default", {
        value: e,
        enumerable: !0
    }) : t, e));
var ce2 = l19((O)=>{
    O.encrypt = function(e, r) {
        return e._cipher.encryptBlock(r);
    };
    O.decrypt = function(e, r) {
        return e._cipher.decryptBlock(r);
    };
});
var he1 = l19((M)=>{
    var ne = i7;
    M.encrypt = function(e, r) {
        var t = ne(r, e._prev);
        return e._prev = e._cipher.encryptBlock(t), e._prev;
    };
    M.decrypt = function(e, r) {
        var t = e._prev;
        e._prev = r;
        var i = e._cipher.decryptBlock(r);
        return ne(i, t);
    };
});
var ue2 = l19((pe)=>{
    var I = L1, We = i7;
    function oe(e, r, t) {
        var i = r.length, a = We(r, e._cache);
        return e._cache = e._cache.slice(i), e._prev = I.concat([
            e._prev,
            t ? r : a
        ]), a;
    }
    pe.encrypt = function(e, r, t) {
        for(var i = I.allocUnsafe(0), a; r.length;)if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = I.allocUnsafe(0)), e._cache.length <= r.length) a = e._cache.length, i = I.concat([
            i,
            oe(e, r.slice(0, a), t)
        ]), r = r.slice(a);
        else {
            i = I.concat([
                i,
                oe(e, r, t)
            ]);
            break;
        }
        return i;
    };
});
var fe2 = l19((se)=>{
    var G = L1;
    function Je(e, r, t) {
        var i = e._cipher.encryptBlock(e._prev), a = i[0] ^ r;
        return e._prev = G.concat([
            e._prev.slice(1),
            G.from([
                t ? r : a
            ])
        ]), a;
    }
    se.encrypt = function(e, r, t) {
        for(var i = r.length, a = G.allocUnsafe(i), c = -1; ++c < i;)a[c] = Je(e, r[c], t);
        return a;
    };
});
var le1 = l19((ve)=>{
    var D = L1;
    function Qe(e, r, t) {
        for(var i, a = -1, c = 8, n = 0, h, u; ++a < c;)i = e._cipher.encryptBlock(e._prev), h = r & 1 << 7 - a ? 128 : 0, u = i[0] ^ h, n += (u & 128) >> a % 8, e._prev = Ye(e._prev, t ? h : u);
        return n;
    }
    function Ye(e, r) {
        var t = e.length, i = -1, a = D.allocUnsafe(e.length);
        for(e = D.concat([
            e,
            D.from([
                r
            ])
        ]); ++i < t;)a[i] = e[i] << 1 | e[i + 1] >> 7;
        return a;
    }
    ve.encrypt = function(e, r, t) {
        for(var i = r.length, a = D.allocUnsafe(i), c = -1; ++c < i;)a[c] = Qe(e, r[c], t);
        return a;
    };
});
var ye2 = l19((_e)=>{
    var je = i7;
    function er(e) {
        return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
    }
    _e.encrypt = function(e, r) {
        for(; e._cache.length < r.length;)e._cache = Buffer.concat([
            e._cache,
            er(e)
        ]);
        var t = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), je(r, t);
    };
});
var z11 = l19((Hr, de)=>{
    function rr(e) {
        for(var r = e.length, t; r--;)if (t = e.readUInt8(r), t === 255) e.writeUInt8(0, r);
        else {
            t++, e.writeUInt8(t, r);
            break;
        }
    }
    de.exports = rr;
});
var K11 = l19((Be)=>{
    var tr = i7, ge = L1, ir = z11();
    function ar(e) {
        var r = e._cipher.encryptBlockRaw(e._prev);
        return ir(e._prev), r;
    }
    var H = 16;
    Be.encrypt = function(e, r) {
        var t = Math.ceil(r.length / H), i = e._cache.length;
        e._cache = ge.concat([
            e._cache,
            ge.allocUnsafe(t * H)
        ]);
        for(var a = 0; a < t; a++){
            var c = ar(e), n = i + a * H;
            e._cache.writeUInt32BE(c[0], n + 0), e._cache.writeUInt32BE(c[1], n + 4), e._cache.writeUInt32BE(c[2], n + 8), e._cache.writeUInt32BE(c[3], n + 12);
        }
        var h = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), tr(r, h);
    };
});
var L13 = l19((Lr, cr)=>{
    cr.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
});
var P10 = l19(($r, me)=>{
    var nr = {
        ECB: ce2(),
        CBC: he1(),
        CFB: ue2(),
        CFB8: fe2(),
        CFB1: le1(),
        OFB: ye2(),
        CTR: K11(),
        GCM: K11()
    }, F = L13();
    for($ in F)F[$].module = nr[F[$].mode];
    var $;
    me.exports = F;
});
var k9 = l19((Pr, we)=>{
    var R = L1;
    function W(e) {
        R.isBuffer(e) || (e = R.from(e));
        for(var r = e.length / 4 | 0, t = new Array(r), i = 0; i < r; i++)t[i] = e.readUInt32BE(i * 4);
        return t;
    }
    function Z(e) {
        for(var r = 0; r < e.length; e++)e[r] = 0;
    }
    function Ee(e, r, t, i, a) {
        for(var c = t[0], n = t[1], h = t[2], u = t[3], p = e[0] ^ r[0], f = e[1] ^ r[1], y = e[2] ^ r[2], d = e[3] ^ r[3], s, C, S, x, E = 4, te = 1; te < a; te++)s = c[p >>> 24] ^ n[f >>> 16 & 255] ^ h[y >>> 8 & 255] ^ u[d & 255] ^ r[E++], C = c[f >>> 24] ^ n[y >>> 16 & 255] ^ h[d >>> 8 & 255] ^ u[p & 255] ^ r[E++], S = c[y >>> 24] ^ n[d >>> 16 & 255] ^ h[p >>> 8 & 255] ^ u[f & 255] ^ r[E++], x = c[d >>> 24] ^ n[p >>> 16 & 255] ^ h[f >>> 8 & 255] ^ u[y & 255] ^ r[E++], p = s, f = C, y = S, d = x;
        return s = (i[p >>> 24] << 24 | i[f >>> 16 & 255] << 16 | i[y >>> 8 & 255] << 8 | i[d & 255]) ^ r[E++], C = (i[f >>> 24] << 24 | i[y >>> 16 & 255] << 16 | i[d >>> 8 & 255] << 8 | i[p & 255]) ^ r[E++], S = (i[y >>> 24] << 24 | i[d >>> 16 & 255] << 16 | i[p >>> 8 & 255] << 8 | i[f & 255]) ^ r[E++], x = (i[d >>> 24] << 24 | i[p >>> 16 & 255] << 16 | i[f >>> 8 & 255] << 8 | i[y & 255]) ^ r[E++], s = s >>> 0, C = C >>> 0, S = S >>> 0, x = x >>> 0, [
            s,
            C,
            S,
            x
        ];
    }
    var hr = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], v = function() {
        for(var e = new Array(256), r = 0; r < 256; r++)r < 128 ? e[r] = r << 1 : e[r] = r << 1 ^ 283;
        for(var t = [], i = [], a = [
            [],
            [],
            [],
            []
        ], c = [
            [],
            [],
            [],
            []
        ], n = 0, h = 0, u = 0; u < 256; ++u){
            var p = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;
            p = p >>> 8 ^ p & 255 ^ 99, t[n] = p, i[p] = n;
            var f = e[n], y = e[f], d = e[y], s = e[p] * 257 ^ p * 16843008;
            a[0][n] = s << 24 | s >>> 8, a[1][n] = s << 16 | s >>> 16, a[2][n] = s << 8 | s >>> 24, a[3][n] = s, s = d * 16843009 ^ y * 65537 ^ f * 257 ^ n * 16843008, c[0][p] = s << 24 | s >>> 8, c[1][p] = s << 16 | s >>> 16, c[2][p] = s << 8 | s >>> 24, c[3][p] = s, n === 0 ? n = h = 1 : (n = f ^ e[e[e[d ^ f]]], h ^= e[e[h]]);
        }
        return {
            SBOX: t,
            INV_SBOX: i,
            SUB_MIX: a,
            INV_SUB_MIX: c
        };
    }();
    function g(e) {
        this._key = W(e), this._reset();
    }
    g.blockSize = 4 * 4;
    g.keySize = 256 / 8;
    g.prototype.blockSize = g.blockSize;
    g.prototype.keySize = g.keySize;
    g.prototype._reset = function() {
        for(var e = this._key, r = e.length, t = r + 6, i = (t + 1) * 4, a = [], c = 0; c < r; c++)a[c] = e[c];
        for(c = r; c < i; c++){
            var n = a[c - 1];
            c % r === 0 ? (n = n << 8 | n >>> 24, n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255], n ^= hr[c / r | 0] << 24) : r > 6 && c % r === 4 && (n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255]), a[c] = a[c - r] ^ n;
        }
        for(var h = [], u = 0; u < i; u++){
            var p = i - u, f = a[p - (u % 4 ? 0 : 4)];
            u < 4 || p <= 4 ? h[u] = f : h[u] = v.INV_SUB_MIX[0][v.SBOX[f >>> 24]] ^ v.INV_SUB_MIX[1][v.SBOX[f >>> 16 & 255]] ^ v.INV_SUB_MIX[2][v.SBOX[f >>> 8 & 255]] ^ v.INV_SUB_MIX[3][v.SBOX[f & 255]];
        }
        this._nRounds = t, this._keySchedule = a, this._invKeySchedule = h;
    };
    g.prototype.encryptBlockRaw = function(e) {
        return e = W(e), Ee(e, this._keySchedule, v.SUB_MIX, v.SBOX, this._nRounds);
    };
    g.prototype.encryptBlock = function(e) {
        var r = this.encryptBlockRaw(e), t = R.allocUnsafe(16);
        return t.writeUInt32BE(r[0], 0), t.writeUInt32BE(r[1], 4), t.writeUInt32BE(r[2], 8), t.writeUInt32BE(r[3], 12), t;
    };
    g.prototype.decryptBlock = function(e) {
        e = W(e);
        var r = e[1];
        e[1] = e[3], e[3] = r;
        var t = Ee(e, this._invKeySchedule, v.INV_SUB_MIX, v.INV_SBOX, this._nRounds), i = R.allocUnsafe(16);
        return i.writeUInt32BE(t[0], 0), i.writeUInt32BE(t[3], 4), i.writeUInt32BE(t[2], 8), i.writeUInt32BE(t[1], 12), i;
    };
    g.prototype.scrub = function() {
        Z(this._keySchedule), Z(this._invKeySchedule), Z(this._key);
    };
    we.exports.AES = g;
});
var xe3 = l19((Zr, Se)=>{
    var A = L1, or = A.alloc(16, 0);
    function pr(e) {
        return [
            e.readUInt32BE(0),
            e.readUInt32BE(4),
            e.readUInt32BE(8),
            e.readUInt32BE(12)
        ];
    }
    function Ce(e) {
        var r = A.allocUnsafe(16);
        return r.writeUInt32BE(e[0] >>> 0, 0), r.writeUInt32BE(e[1] >>> 0, 4), r.writeUInt32BE(e[2] >>> 0, 8), r.writeUInt32BE(e[3] >>> 0, 12), r;
    }
    function q(e) {
        this.h = e, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
    }
    q.prototype.ghash = function(e) {
        for(var r = -1; ++r < e.length;)this.state[r] ^= e[r];
        this._multiply();
    };
    q.prototype._multiply = function() {
        for(var e = pr(this.h), r = [
            0,
            0,
            0,
            0
        ], t, i, a, c = -1; ++c < 128;){
            for(i = (this.state[~~(c / 8)] & 1 << 7 - c % 8) !== 0, i && (r[0] ^= e[0], r[1] ^= e[1], r[2] ^= e[2], r[3] ^= e[3]), a = (e[3] & 1) !== 0, t = 3; t > 0; t--)e[t] = e[t] >>> 1 | (e[t - 1] & 1) << 31;
            e[0] = e[0] >>> 1, a && (e[0] = e[0] ^ 225 << 24);
        }
        this.state = Ce(r);
    };
    q.prototype.update = function(e) {
        this.cache = A.concat([
            this.cache,
            e
        ]);
        for(var r; this.cache.length >= 16;)r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(r);
    };
    q.prototype.final = function(e, r) {
        return this.cache.length && this.ghash(A.concat([
            this.cache,
            or
        ], 16)), this.ghash(Ce([
            0,
            e,
            0,
            r
        ])), this.state;
    };
    Se.exports = q;
});
var J9 = l19((Wr, Ie)=>{
    var ur = k9(), _ = L1, Ae = M4, sr = w, Ue = xe3(), fr = i7, vr = z11();
    function lr(e, r) {
        var t = 0;
        e.length !== r.length && t++;
        for(var i = Math.min(e.length, r.length), a = 0; a < i; ++a)t += e[a] ^ r[a];
        return t;
    }
    function _r(e, r, t) {
        if (r.length === 12) return e._finID = _.concat([
            r,
            _.from([
                0,
                0,
                0,
                1
            ])
        ]), _.concat([
            r,
            _.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var i = new Ue(t), a = r.length, c = a % 16;
        i.update(r), c && (c = 16 - c, i.update(_.alloc(c, 0))), i.update(_.alloc(8, 0));
        var n = a * 8, h = _.alloc(8);
        h.writeUIntBE(n, 0, 8), i.update(h), e._finID = i.state;
        var u = _.from(e._finID);
        return vr(u), u;
    }
    function w1(e, r, t, i) {
        Ae.call(this);
        var a = _.alloc(4, 0);
        this._cipher = new ur.AES(r);
        var c = this._cipher.encryptBlock(a);
        this._ghash = new Ue(c), t = _r(this, t, c), this._prev = _.from(t), this._cache = _.allocUnsafe(0), this._secCache = _.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
    }
    sr(w1, Ae);
    w1.prototype._update = function(e) {
        if (!this._called && this._alen) {
            var r = 16 - this._alen % 16;
            r < 16 && (r = _.alloc(r, 0), this._ghash.update(r));
        }
        this._called = !0;
        var t = this._mode.encrypt(this, e);
        return this._decrypt ? this._ghash.update(e) : this._ghash.update(t), this._len += e.length, t;
    };
    w1.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var e = fr(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && lr(e, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = e, this._cipher.scrub();
    };
    w1.prototype.getAuthTag = function() {
        if (this._decrypt || !_.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    };
    w1.prototype.setAuthTag = function(r) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = r;
    };
    w1.prototype.setAAD = function(r) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(r), this._alen += r.length;
    };
    Ie.exports = w1;
});
var Y5 = l19((Jr, qe)=>{
    var yr = k9(), Q = L1, ke = M4, dr = w;
    function X(e, r, t, i) {
        ke.call(this), this._cipher = new yr.AES(r), this._prev = Q.from(t), this._cache = Q.allocUnsafe(0), this._secCache = Q.allocUnsafe(0), this._decrypt = i, this._mode = e;
    }
    dr(X, ke);
    X.prototype._update = function(e) {
        return this._mode.encrypt(this, e, this._decrypt);
    };
    X.prototype._final = function() {
        this._cipher.scrub();
    };
    qe.exports = X;
});
var Fe2 = l19((j)=>{
    var be = P10(), gr = J9(), m = L1, Br = Y5(), Te = M4, mr = k9(), Er = j3, wr = w;
    function b(e, r, t) {
        Te.call(this), this._cache = new N, this._cipher = new mr.AES(r), this._prev = m.from(t), this._mode = e, this._autopadding = !0;
    }
    wr(b, Te);
    b.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get();)t = this._mode.encrypt(this, r), i.push(t);
        return m.concat(i);
    };
    var Cr = m.alloc(16, 16);
    b.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
        if (!e.equals(Cr)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    b.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function N() {
        this.cache = m.allocUnsafe(0);
    }
    N.prototype.add = function(e) {
        this.cache = m.concat([
            this.cache,
            e
        ]);
    };
    N.prototype.get = function() {
        if (this.cache.length > 15) {
            var e = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), e;
        }
        return null;
    };
    N.prototype.flush = function() {
        for(var e = 16 - this.cache.length, r = m.allocUnsafe(e), t = -1; ++t < e;)r.writeUInt8(e, t);
        return m.concat([
            this.cache,
            r
        ]);
    };
    function De(e, r, t) {
        var i = be[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof r == "string" && (r = m.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        if (typeof t == "string" && (t = m.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        return i.type === "stream" ? new Br(i.module, r, t) : i.type === "auth" ? new gr(i.module, r, t) : new b(i.module, r, t);
    }
    function Sr(e, r) {
        var t = be[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Er(r, !1, t.key, t.iv);
        return De(e, i.key, i.iv);
    }
    j.createCipheriv = De;
    j.createCipher = Sr;
});
var Ve2 = l19((ee)=>{
    var xr = J9(), U = L1, Re = P10(), Ar = Y5(), Xe = M4, Ur = k9(), Ir = j3, kr = w;
    function T(e, r, t) {
        Xe.call(this), this._cache = new V, this._last = void 0, this._cipher = new Ur.AES(r), this._prev = U.from(t), this._mode = e, this._autopadding = !0;
    }
    kr(T, Xe);
    T.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get(this._autopadding);)t = this._mode.decrypt(this, r), i.push(t);
        return U.concat(i);
    };
    T.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return qr(this._mode.decrypt(this, e));
        if (e) throw new Error("data not multiple of block length");
    };
    T.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function V() {
        this.cache = U.allocUnsafe(0);
    }
    V.prototype.add = function(e) {
        this.cache = U.concat([
            this.cache,
            e
        ]);
    };
    V.prototype.get = function(e) {
        var r;
        if (e) {
            if (this.cache.length > 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        } else if (this.cache.length >= 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        return null;
    };
    V.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function qr(e) {
        var r = e[15];
        if (r < 1 || r > 16) throw new Error("unable to decrypt data");
        for(var t = -1; ++t < r;)if (e[t + (16 - r)] !== r) throw new Error("unable to decrypt data");
        if (r !== 16) return e.slice(0, 16 - r);
    }
    function Ne(e, r, t) {
        var i = Re[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof t == "string" && (t = U.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        if (typeof r == "string" && (r = U.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        return i.type === "stream" ? new Ar(i.module, r, t, !0) : i.type === "auth" ? new xr(i.module, r, t, !0) : new T(i.module, r, t);
    }
    function br(e, r) {
        var t = Re[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Ir(r, !1, t.key, t.iv);
        return Ne(e, i.key, i.iv);
    }
    ee.createDecipher = br;
    ee.createDecipheriv = Ne;
});
var re2 = l19((B)=>{
    var Oe = Fe2(), Me = Ve2(), Tr = L13();
    function Dr() {
        return Object.keys(Tr);
    }
    B.createCipher = B.Cipher = Oe.createCipher;
    B.createCipheriv = B.Cipheriv = Oe.createCipheriv;
    B.createDecipher = B.Decipher = Me.createDecipher;
    B.createDecipheriv = B.Decipheriv = Me.createDecipheriv;
    B.listCiphers = B.getCiphers = Dr;
});
var Ge1 = ae1(re2()), ze2 = ae1(re2()), { createCipher: et1 , Cipher: rt2 , createCipheriv: tt2 , Cipheriv: it2 , createDecipher: at1 , Decipher: ct2 , createDecipheriv: nt1 , Decipheriv: ht3 , listCiphers: ot1 , getCiphers: pt1  } = ze2, { default: Fr1 , ...Rr1 } = ze2, ut2 = (Ge1.default ?? Fr1) ?? Rr1;
var G6 = Object.create;
var I10 = Object.defineProperty;
var H5 = Object.getOwnPropertyDescriptor;
var J10 = Object.getOwnPropertyNames;
var L14 = Object.getPrototypeOf, Q6 = Object.prototype.hasOwnProperty;
((u)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(u, {
        get: (t, r)=>(typeof require != "undefined" ? require : t)[r]
    }) : u)(function(u) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + u + '" is not supported');
});
var _9 = (u, t)=>()=>(t || u((t = {
            exports: {}
        }).exports, t), t.exports);
var R9 = (u, t, r, e)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of J10(t))!Q6.call(u, i) && i !== r && I10(u, i, {
        get: ()=>t[i],
        enumerable: !(e = H5(t, i)) || e.enumerable
    });
    return u;
};
var D7 = (u, t, r)=>(r = u != null ? G6(L14(u)) : {}, R9(t || !u || !u.__esModule ? I10(r, "default", {
        value: u,
        enumerable: !0
    }) : r, u));
var w20 = _9((f)=>{
    "use strict";
    f.readUInt32BE = function(t, r) {
        var e = t[0 + r] << 24 | t[1 + r] << 16 | t[2 + r] << 8 | t[3 + r];
        return e >>> 0;
    };
    f.writeUInt32BE = function(t, r, e) {
        t[0 + e] = r >>> 24, t[1 + e] = r >>> 16 & 255, t[2 + e] = r >>> 8 & 255, t[3 + e] = r & 255;
    };
    f.ip = function(t, r, e, i) {
        for(var a = 0, p = 0, s = 6; s >= 0; s -= 2){
            for(var n = 0; n <= 24; n += 8)a <<= 1, a |= r >>> n + s & 1;
            for(var n = 0; n <= 24; n += 8)a <<= 1, a |= t >>> n + s & 1;
        }
        for(var s = 6; s >= 0; s -= 2){
            for(var n = 1; n <= 25; n += 8)p <<= 1, p |= r >>> n + s & 1;
            for(var n = 1; n <= 25; n += 8)p <<= 1, p |= t >>> n + s & 1;
        }
        e[i + 0] = a >>> 0, e[i + 1] = p >>> 0;
    };
    f.rip = function(t, r, e, i) {
        for(var a = 0, p = 0, s = 0; s < 4; s++)for(var n = 24; n >= 0; n -= 8)a <<= 1, a |= r >>> n + s & 1, a <<= 1, a |= t >>> n + s & 1;
        for(var s = 4; s < 8; s++)for(var n = 24; n >= 0; n -= 8)p <<= 1, p |= r >>> n + s & 1, p <<= 1, p |= t >>> n + s & 1;
        e[i + 0] = a >>> 0, e[i + 1] = p >>> 0;
    };
    f.pc1 = function(t, r, e, i) {
        for(var a = 0, p = 0, s = 7; s >= 5; s--){
            for(var n = 0; n <= 24; n += 8)a <<= 1, a |= r >> n + s & 1;
            for(var n = 0; n <= 24; n += 8)a <<= 1, a |= t >> n + s & 1;
        }
        for(var n = 0; n <= 24; n += 8)a <<= 1, a |= r >> n + s & 1;
        for(var s = 1; s <= 3; s++){
            for(var n = 0; n <= 24; n += 8)p <<= 1, p |= r >> n + s & 1;
            for(var n = 0; n <= 24; n += 8)p <<= 1, p |= t >> n + s & 1;
        }
        for(var n = 0; n <= 24; n += 8)p <<= 1, p |= t >> n + s & 1;
        e[i + 0] = a >>> 0, e[i + 1] = p >>> 0;
    };
    f.r28shl = function(t, r) {
        return t << r & 268435455 | t >>> 28 - r;
    };
    var S = [
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
    ];
    f.pc2 = function(t, r, e, i) {
        for(var a = 0, p = 0, s = S.length >>> 1, n = 0; n < s; n++)a <<= 1, a |= t >>> S[n] & 1;
        for(var n = s; n < S.length; n++)p <<= 1, p |= r >>> S[n] & 1;
        e[i + 0] = a >>> 0, e[i + 1] = p >>> 0;
    };
    f.expand = function(t, r, e) {
        var i = 0, a = 0;
        i = (t & 1) << 5 | t >>> 27;
        for(var p = 23; p >= 15; p -= 4)i <<= 6, i |= t >>> p & 63;
        for(var p = 11; p >= 3; p -= 4)a |= t >>> p & 63, a <<= 6;
        a |= (t & 31) << 1 | t >>> 31, r[e + 0] = i >>> 0, r[e + 1] = a >>> 0;
    };
    var C = [
        14,
        0,
        4,
        15,
        13,
        7,
        1,
        4,
        2,
        14,
        15,
        2,
        11,
        13,
        8,
        1,
        3,
        10,
        10,
        6,
        6,
        12,
        12,
        11,
        5,
        9,
        9,
        5,
        0,
        3,
        7,
        8,
        4,
        15,
        1,
        12,
        14,
        8,
        8,
        2,
        13,
        4,
        6,
        9,
        2,
        1,
        11,
        7,
        15,
        5,
        12,
        11,
        9,
        3,
        7,
        14,
        3,
        10,
        10,
        0,
        5,
        6,
        0,
        13,
        15,
        3,
        1,
        13,
        8,
        4,
        14,
        7,
        6,
        15,
        11,
        2,
        3,
        8,
        4,
        14,
        9,
        12,
        7,
        0,
        2,
        1,
        13,
        10,
        12,
        6,
        0,
        9,
        5,
        11,
        10,
        5,
        0,
        13,
        14,
        8,
        7,
        10,
        11,
        1,
        10,
        3,
        4,
        15,
        13,
        4,
        1,
        2,
        5,
        11,
        8,
        6,
        12,
        7,
        6,
        12,
        9,
        0,
        3,
        5,
        2,
        14,
        15,
        9,
        10,
        13,
        0,
        7,
        9,
        0,
        14,
        9,
        6,
        3,
        3,
        4,
        15,
        6,
        5,
        10,
        1,
        2,
        13,
        8,
        12,
        5,
        7,
        14,
        11,
        12,
        4,
        11,
        2,
        15,
        8,
        1,
        13,
        1,
        6,
        10,
        4,
        13,
        9,
        0,
        8,
        6,
        15,
        9,
        3,
        8,
        0,
        7,
        11,
        4,
        1,
        15,
        2,
        14,
        12,
        3,
        5,
        11,
        10,
        5,
        14,
        2,
        7,
        12,
        7,
        13,
        13,
        8,
        14,
        11,
        3,
        5,
        0,
        6,
        6,
        15,
        9,
        0,
        10,
        3,
        1,
        4,
        2,
        7,
        8,
        2,
        5,
        12,
        11,
        1,
        12,
        10,
        4,
        14,
        15,
        9,
        10,
        3,
        6,
        15,
        9,
        0,
        0,
        6,
        12,
        10,
        11,
        1,
        7,
        13,
        13,
        8,
        15,
        9,
        1,
        4,
        3,
        5,
        14,
        11,
        5,
        12,
        2,
        7,
        8,
        2,
        4,
        14,
        2,
        14,
        12,
        11,
        4,
        2,
        1,
        12,
        7,
        4,
        10,
        7,
        11,
        13,
        6,
        1,
        8,
        5,
        5,
        0,
        3,
        15,
        15,
        10,
        13,
        3,
        0,
        9,
        14,
        8,
        9,
        6,
        4,
        11,
        2,
        8,
        1,
        12,
        11,
        7,
        10,
        1,
        13,
        14,
        7,
        2,
        8,
        13,
        15,
        6,
        9,
        15,
        12,
        0,
        5,
        9,
        6,
        10,
        3,
        4,
        0,
        5,
        14,
        3,
        12,
        10,
        1,
        15,
        10,
        4,
        15,
        2,
        9,
        7,
        2,
        12,
        6,
        9,
        8,
        5,
        0,
        6,
        13,
        1,
        3,
        13,
        4,
        14,
        14,
        0,
        7,
        11,
        5,
        3,
        11,
        8,
        9,
        4,
        14,
        3,
        15,
        2,
        5,
        12,
        2,
        9,
        8,
        5,
        12,
        15,
        3,
        10,
        7,
        11,
        0,
        14,
        4,
        1,
        10,
        7,
        1,
        6,
        13,
        0,
        11,
        8,
        6,
        13,
        4,
        13,
        11,
        0,
        2,
        11,
        14,
        7,
        15,
        4,
        0,
        9,
        8,
        1,
        13,
        10,
        3,
        14,
        12,
        3,
        9,
        5,
        7,
        12,
        5,
        2,
        10,
        15,
        6,
        8,
        1,
        6,
        1,
        6,
        4,
        11,
        11,
        13,
        13,
        8,
        12,
        1,
        3,
        4,
        7,
        10,
        14,
        7,
        10,
        9,
        15,
        5,
        6,
        0,
        8,
        15,
        0,
        14,
        5,
        2,
        9,
        3,
        2,
        12,
        13,
        1,
        2,
        15,
        8,
        13,
        4,
        8,
        6,
        10,
        15,
        3,
        11,
        7,
        1,
        4,
        10,
        12,
        9,
        5,
        3,
        6,
        14,
        11,
        5,
        0,
        0,
        14,
        12,
        9,
        7,
        2,
        7,
        2,
        11,
        1,
        4,
        14,
        1,
        7,
        9,
        4,
        12,
        10,
        14,
        8,
        2,
        13,
        0,
        15,
        6,
        12,
        10,
        9,
        13,
        0,
        15,
        3,
        3,
        5,
        5,
        6,
        8,
        11
    ];
    f.substitute = function(t, r) {
        for(var e = 0, i = 0; i < 4; i++){
            var a = t >>> 18 - i * 6 & 63, p = C[i * 64 + a];
            e <<= 4, e |= p;
        }
        for(var i = 0; i < 4; i++){
            var a = r >>> 18 - i * 6 & 63, p = C[4 * 64 + i * 64 + a];
            e <<= 4, e |= p;
        }
        return e >>> 0;
    };
    var U = [
        16,
        25,
        12,
        11,
        3,
        20,
        4,
        15,
        31,
        17,
        9,
        6,
        27,
        14,
        1,
        22,
        30,
        24,
        8,
        18,
        0,
        5,
        29,
        23,
        13,
        19,
        2,
        26,
        10,
        21,
        28,
        7
    ];
    f.permute = function(t) {
        for(var r = 0, e = 0; e < U.length; e++)r <<= 1, r |= t >>> U[e] & 1;
        return r >>> 0;
    };
    f.padSplit = function(t, r, e) {
        for(var i = t.toString(2); i.length < r;)i = "0" + i;
        for(var a = [], p = 0; p < r; p += e)a.push(i.slice(p, p + e));
        return a.join(" ");
    };
});
var g14 = _9((ct, A)=>{
    "use strict";
    var W = j;
    function c(u) {
        this.options = u, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    A.exports = c;
    c.prototype._init = function() {};
    c.prototype.update = function(t) {
        return t.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(t) : this._updateEncrypt(t);
    };
    c.prototype._buffer = function(t, r) {
        for(var e = Math.min(this.buffer.length - this.bufferOff, t.length - r), i = 0; i < e; i++)this.buffer[this.bufferOff + i] = t[r + i];
        return this.bufferOff += e, e;
    };
    c.prototype._flushBuffer = function(t, r) {
        return this._update(this.buffer, 0, t, r), this.bufferOff = 0, this.blockSize;
    };
    c.prototype._updateEncrypt = function(t) {
        var r = 0, e = 0, i = (this.bufferOff + t.length) / this.blockSize | 0, a = new Array(i * this.blockSize);
        this.bufferOff !== 0 && (r += this._buffer(t, r), this.bufferOff === this.buffer.length && (e += this._flushBuffer(a, e)));
        for(var p = t.length - (t.length - r) % this.blockSize; r < p; r += this.blockSize)this._update(t, r, a, e), e += this.blockSize;
        for(; r < t.length; r++, this.bufferOff++)this.buffer[this.bufferOff] = t[r];
        return a;
    };
    c.prototype._updateDecrypt = function(t) {
        for(var r = 0, e = 0, i = Math.ceil((this.bufferOff + t.length) / this.blockSize) - 1, a = new Array(i * this.blockSize); i > 0; i--)r += this._buffer(t, r), e += this._flushBuffer(a, e);
        return r += this._buffer(t, r), a;
    };
    c.prototype.final = function(t) {
        var r;
        t && (r = this.update(t));
        var e;
        return this.type === "encrypt" ? e = this._finalEncrypt() : e = this._finalDecrypt(), r ? r.concat(e) : e;
    };
    c.prototype._pad = function(t, r) {
        if (r === 0) return !1;
        for(; r < t.length;)t[r++] = 0;
        return !0;
    };
    c.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff)) return [];
        var t = new Array(this.blockSize);
        return this._update(this.buffer, 0, t, 0), t;
    };
    c.prototype._unpad = function(t) {
        return t;
    };
    c.prototype._finalDecrypt = function() {
        W.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var t = new Array(this.blockSize);
        return this._flushBuffer(t, 0), this._unpad(t);
    };
});
var B13 = _9((ht, $)=>{
    "use strict";
    var O = j, X = w, o = w20(), j1 = g14();
    function Y() {
        this.tmp = new Array(2), this.keys = null;
    }
    function h(u) {
        j1.call(this, u);
        var t = new Y;
        this._desState = t, this.deriveKeys(t, u.key);
    }
    X(h, j1);
    $.exports = h;
    h.create = function(t) {
        return new h(t);
    };
    var Z = [
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1
    ];
    h.prototype.deriveKeys = function(t, r) {
        t.keys = new Array(16 * 2), O.equal(r.length, this.blockSize, "Invalid key length");
        var e = o.readUInt32BE(r, 0), i = o.readUInt32BE(r, 4);
        o.pc1(e, i, t.tmp, 0), e = t.tmp[0], i = t.tmp[1];
        for(var a = 0; a < t.keys.length; a += 2){
            var p = Z[a >>> 1];
            e = o.r28shl(e, p), i = o.r28shl(i, p), o.pc2(e, i, t.keys, a);
        }
    };
    h.prototype._update = function(t, r, e, i) {
        var a = this._desState, p = o.readUInt32BE(t, r), s = o.readUInt32BE(t, r + 4);
        o.ip(p, s, a.tmp, 0), p = a.tmp[0], s = a.tmp[1], this.type === "encrypt" ? this._encrypt(a, p, s, a.tmp, 0) : this._decrypt(a, p, s, a.tmp, 0), p = a.tmp[0], s = a.tmp[1], o.writeUInt32BE(e, p, i), o.writeUInt32BE(e, s, i + 4);
    };
    h.prototype._pad = function(t, r) {
        for(var e = t.length - r, i = r; i < t.length; i++)t[i] = e;
        return !0;
    };
    h.prototype._unpad = function(t) {
        for(var r = t[t.length - 1], e = t.length - r; e < t.length; e++)O.equal(t[e], r);
        return t.slice(0, t.length - r);
    };
    h.prototype._encrypt = function(t, r, e, i, a) {
        for(var p = r, s = e, n = 0; n < t.keys.length; n += 2){
            var b = t.keys[n], k = t.keys[n + 1];
            o.expand(s, t.tmp, 0), b ^= t.tmp[0], k ^= t.tmp[1];
            var E = o.substitute(b, k), x = o.permute(E), q = s;
            s = (p ^ x) >>> 0, p = q;
        }
        o.rip(s, p, i, a);
    };
    h.prototype._decrypt = function(t, r, e, i, a) {
        for(var p = e, s = r, n = t.keys.length - 2; n >= 0; n -= 2){
            var b = t.keys[n], k = t.keys[n + 1];
            o.expand(p, t.tmp, 0), b ^= t.tmp[0], k ^= t.tmp[1];
            var E = o.substitute(b, k), x = o.permute(E), q = p;
            p = (s ^ x) >>> 0, s = q;
        }
        o.rip(p, s, i, a);
    };
});
var T8 = _9((K)=>{
    "use strict";
    var tt = j, rt = w, m = {};
    function et(u) {
        tt.equal(u.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for(var t = 0; t < this.iv.length; t++)this.iv[t] = u[t];
    }
    function nt(u) {
        function t(a) {
            u.call(this, a), this._cbcInit();
        }
        rt(t, u);
        for(var r = Object.keys(m), e = 0; e < r.length; e++){
            var i = r[e];
            t.prototype[i] = m[i];
        }
        return t.create = function(p) {
            return new t(p);
        }, t;
    }
    K.instantiate = nt;
    m._cbcInit = function() {
        var t = new et(this.options.iv);
        this._cbcState = t;
    };
    m._update = function(t, r, e, i) {
        var a = this._cbcState, p = this.constructor.super_.prototype, s = a.iv;
        if (this.type === "encrypt") {
            for(var n = 0; n < this.blockSize; n++)s[n] ^= t[r + n];
            p._update.call(this, s, 0, e, i);
            for(var n = 0; n < this.blockSize; n++)s[n] = e[i + n];
        } else {
            p._update.call(this, t, r, e, i);
            for(var n = 0; n < this.blockSize; n++)e[i + n] ^= s[n];
            for(var n = 0; n < this.blockSize; n++)s[n] = t[r + n];
        }
    };
});
var P11 = _9((lt, N)=>{
    "use strict";
    var it = j, at = w, M = g14(), v = B13();
    function pt(u, t) {
        it.equal(t.length, 24, "Invalid key length");
        var r = t.slice(0, 8), e = t.slice(8, 16), i = t.slice(16, 24);
        u === "encrypt" ? this.ciphers = [
            v.create({
                type: "encrypt",
                key: r
            }),
            v.create({
                type: "decrypt",
                key: e
            }),
            v.create({
                type: "encrypt",
                key: i
            })
        ] : this.ciphers = [
            v.create({
                type: "decrypt",
                key: i
            }),
            v.create({
                type: "encrypt",
                key: e
            }),
            v.create({
                type: "decrypt",
                key: r
            })
        ];
    }
    function y(u) {
        M.call(this, u);
        var t = new pt(this.type, this.options.key);
        this._edeState = t;
    }
    at(y, M);
    N.exports = y;
    y.create = function(t) {
        return new y(t);
    };
    y.prototype._update = function(t, r, e, i) {
        var a = this._edeState;
        a.ciphers[0]._update(t, r, e, i), a.ciphers[1]._update(e, i, e, i), a.ciphers[2]._update(e, i, e, i);
    };
    y.prototype._pad = v.prototype._pad;
    y.prototype._unpad = v.prototype._unpad;
});
var z12 = _9((d)=>{
    "use strict";
    d.utils = w20();
    d.Cipher = g14();
    d.DES = B13();
    d.CBC = T8();
    d.EDE = P11();
});
var V5 = D7(z12()), F7 = D7(z12()), { utils: _t , Cipher: dt , DES: bt , CBC: kt , EDE: St1  } = F7, { default: ut3 , ...st } = F7, gt = (V5.default ?? ut3) ?? st;
var y13 = Object.create;
var m16 = Object.defineProperty;
var B14 = Object.getOwnPropertyDescriptor;
var C6 = Object.getOwnPropertyNames;
var b11 = Object.getPrototypeOf, D8 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, d)=>(typeof require != "undefined" ? require : r)[d]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var h13 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var _10 = (e, r, d, a)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of C6(r))!D8.call(e, t) && t !== d && m16(e, t, {
        get: ()=>r[t],
        enumerable: !(a = B14(r, t)) || a.enumerable
    });
    return e;
};
var p19 = (e, r, d)=>(d = e != null ? y13(b11(e)) : {}, _10(r || !e || !e.__esModule ? m16(d, "default", {
        value: e,
        enumerable: !0
    }) : d, e));
var u9 = h13((w1, E)=>{
    var v = M4, i = gt, q = w, s = L1, f = {
        "des-ede3-cbc": i.CBC.instantiate(i.EDE),
        "des-ede3": i.EDE,
        "des-ede-cbc": i.CBC.instantiate(i.EDE),
        "des-ede": i.EDE,
        "des-cbc": i.CBC.instantiate(i.DES),
        "des-ecb": i.DES
    };
    f.des = f["des-cbc"];
    f.des3 = f["des-ede3-cbc"];
    E.exports = n;
    q(n, v);
    function n(e) {
        v.call(this);
        var r = e.mode.toLowerCase(), d = f[r], a;
        e.decrypt ? a = "decrypt" : a = "encrypt";
        var t = e.key;
        s.isBuffer(t) || (t = s.from(t)), (r === "des-ede" || r === "des-ede-cbc") && (t = s.concat([
            t,
            t.slice(0, 8)
        ]));
        var c = e.iv;
        s.isBuffer(c) || (c = s.from(c)), this._des = d.create({
            key: t,
            iv: c,
            type: a
        });
    }
    n.prototype._update = function(e) {
        return s.from(this._des.update(e));
    };
    n.prototype._final = function() {
        return s.from(this._des.final());
    };
});
var l20 = p19(u9()), $13 = p19(u9()), { default: k10 , ...S10 } = $13, L15 = (l20.default ?? k10) ?? S10;
var s8 = Object.create;
var f7 = Object.defineProperty;
var L16 = Object.getOwnPropertyDescriptor;
var m17 = Object.getOwnPropertyNames;
var q12 = Object.getPrototypeOf, E11 = Object.prototype.hasOwnProperty;
((e)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
        get: (r, i)=>(typeof require != "undefined" ? require : r)[i]
    }) : e)(function(e) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var g15 = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var T9 = (e, r, i, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let p of m17(r))!E11.call(e, p) && p !== i && f7(e, p, {
        get: ()=>r[p],
        enumerable: !(t = L16(r, p)) || t.enumerable
    });
    return e;
};
var C7 = (e, r, i)=>(i = e != null ? s8(q12(e)) : {}, T9(r || !e || !e.__esModule ? f7(i, "default", {
        value: e,
        enumerable: !0
    }) : i, e));
var h14 = g15((a)=>{
    var y = L15, v = ut2, o = be2, c = q11, l = j3;
    function $(e, r) {
        e = e.toLowerCase();
        var i, t;
        if (o[e]) i = o[e].key, t = o[e].iv;
        else if (c[e]) i = c[e].key * 8, t = c[e].iv;
        else throw new TypeError("invalid suite type");
        var p = l(r, !1, i, t);
        return d(e, p.key, p.iv);
    }
    function b(e, r) {
        e = e.toLowerCase();
        var i, t;
        if (o[e]) i = o[e].key, t = o[e].iv;
        else if (c[e]) i = c[e].key * 8, t = c[e].iv;
        else throw new TypeError("invalid suite type");
        var p = l(r, !1, i, t);
        return w(e, p.key, p.iv);
    }
    function d(e, r, i) {
        if (e = e.toLowerCase(), o[e]) return v.createCipheriv(e, r, i);
        if (c[e]) return new y({
            key: r,
            iv: i,
            mode: e
        });
        throw new TypeError("invalid suite type");
    }
    function w(e, r, i) {
        if (e = e.toLowerCase(), o[e]) return v.createDecipheriv(e, r, i);
        if (c[e]) return new y({
            key: r,
            iv: i,
            mode: e,
            decrypt: !0
        });
        throw new TypeError("invalid suite type");
    }
    function x() {
        return Object.keys(c).concat(v.getCiphers());
    }
    a.createCipher = a.Cipher = $;
    a.createCipheriv = a.Cipheriv = d;
    a.createDecipher = a.Decipher = b;
    a.createDecipheriv = a.Decipheriv = w;
    a.listCiphers = a.getCiphers = x;
});
var k11 = C7(h14()), D9 = C7(h14()), { createCipher: u10 , Cipher: z13 , createCipheriv: A10 , Cipheriv: B15 , createDecipher: F8 , Decipher: G7 , createDecipheriv: H6 , Decipheriv: I11 , listCiphers: J11 , getCiphers: K12  } = D9, { default: M10 , ...j9 } = D9, N3 = (k11.default ?? M10) ?? j9;
var __global$4 = globalThis || (typeof window !== "undefined" ? window : self);
var A11 = Object.create;
var m18 = Object.defineProperty;
var S11 = Object.getOwnPropertyDescriptor;
var k12 = Object.getOwnPropertyNames;
var M11 = Object.getPrototypeOf, R10 = Object.prototype.hasOwnProperty;
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (n, e)=>(typeof require != "undefined" ? require : n)[e]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var $14 = (r, n)=>()=>(n || r((n = {
            exports: {}
        }).exports, n), n.exports);
var b12 = (r, n, e, t)=>{
    if (n && typeof n == "object" || typeof n == "function") for (let o of k12(n))!R10.call(r, o) && o !== e && m18(r, o, {
        get: ()=>n[o],
        enumerable: !(t = S11(n, o)) || t.enumerable
    });
    return r;
};
var p20 = (r, n, e)=>(e = r != null ? A11(M11(r)) : {}, b12(n || !r || !r.__esModule ? m18(e, "default", {
        value: r,
        enumerable: !0
    }) : e, r));
var i10 = $14((a)=>{
    "use strict";
    function c() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var d = I2, w = q7, f = d.Buffer, g = d.kMaxLength, l = __global$4.crypto || __global$4.msCrypto, h = Math.pow(2, 32) - 1;
    function s(r, n) {
        if (typeof r != "number" || r !== r) throw new TypeError("offset must be a number");
        if (r > h || r < 0) throw new TypeError("offset must be a uint32");
        if (r > g || r > n) throw new RangeError("offset out of range");
    }
    function E(r, n, e) {
        if (typeof r != "number" || r !== r) throw new TypeError("size must be a number");
        if (r > h || r < 0) throw new TypeError("size must be a uint32");
        if (r + n > e || r > g) throw new RangeError("buffer too small");
    }
    l && l.getRandomValues || !process1.browser ? (a.randomFill = q, a.randomFillSync = L) : (a.randomFill = c, a.randomFillSync = c);
    function q(r, n, e, t) {
        if (!f.isBuffer(r) && !(r instanceof __global$4.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof n == "function") t = n, n = 0, e = r.length;
        else if (typeof e == "function") t = e, e = r.length - n;
        else if (typeof t != "function") throw new TypeError('"cb" argument must be a function');
        return s(n, r.length), E(e, n, r.length), F(r, n, e, t);
    }
    function F(r, n, e, t) {
        if (process1.browser) {
            var o = r.buffer, x = new Uint8Array(o, n, e);
            if (l.getRandomValues(x), t) {
                process1.nextTick(function() {
                    t(null, r);
                });
                return;
            }
            return r;
        }
        if (t) {
            w(e, function(u, U) {
                if (u) return t(u);
                U.copy(r, n), t(null, r);
            });
            return;
        }
        var T = w(e);
        return T.copy(r, n), r;
    }
    function L(r, n, e) {
        if (typeof n > "u" && (n = 0), !f.isBuffer(r) && !(r instanceof __global$4.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return s(n, r.length), e === void 0 && (e = r.length - n), E(e, n, r.length), F(r, n, e);
    }
});
var v16 = p20(i10()), B16 = p20(i10()), { randomFill: j10 , randomFillSync: D10  } = B16, { default: V6 , ...C8 } = B16, G8 = (v16.default ?? V6) ?? C8;
var C9 = Object.create;
var b13 = Object.defineProperty;
var F9 = Object.getOwnPropertyDescriptor;
var G9 = Object.getOwnPropertyNames;
var J12 = Object.getPrototypeOf, O7 = Object.prototype.hasOwnProperty;
((t)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: (r, a)=>(typeof require != "undefined" ? require : r)[a]
    }) : t)(function(t) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + t + '" is not supported');
});
var d11 = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var Q7 = (t, r, a, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of G9(r))!O7.call(t, e) && e !== a && b13(t, e, {
        get: ()=>r[e],
        enumerable: !(n = F9(r, e)) || n.enumerable
    });
    return t;
};
var x14 = (t, r, a)=>(a = t != null ? C9(J12(t)) : {}, Q7(r || !t || !t.__esModule ? b13(a, "default", {
        value: t,
        enumerable: !0
    }) : a, t));
var w21 = d11((sr, B)=>{
    var T = I8, h = L1;
    B.exports = function(t, r) {
        for(var a = h.alloc(0), n = 0, e; a.length < r;)e = V(n++), a = h.concat([
            a,
            T("sha1").update(t).update(e).digest()
        ]);
        return a.slice(0, r);
    };
    function V(t) {
        var r = h.allocUnsafe(4);
        return r.writeUInt32BE(t, 0), r;
    }
});
var g16 = d11((hr, D)=>{
    D.exports = function(r, a) {
        for(var n = r.length, e = -1; ++e < n;)r[e] ^= a[e];
        return r;
    };
});
var m19 = d11((wr, H)=>{
    var L = ki, W = L1;
    function X(t, r) {
        return W.from(t.toRed(L.mont(r.modulus)).redPow(new L(r.publicExponent)).fromRed().toArray());
    }
    H.exports = X;
});
var N4 = d11((gr, $)=>{
    var Y = Ae1, y = q7, _ = I8, P = w21(), S = g16(), q = ki, K = m19(), rr = G2, c = L1;
    $.exports = function(r, a, n) {
        var e;
        r.padding ? e = r.padding : n ? e = 1 : e = 4;
        var i = Y(r), o;
        if (e === 4) o = er(i, a);
        else if (e === 1) o = tr(i, a, n);
        else if (e === 3) {
            if (o = new q(a), o.cmp(i.modulus) >= 0) throw new Error("data too long for modulus");
        } else throw new Error("unknown padding");
        return n ? rr(o, i) : K(o, i);
    };
    function er(t, r) {
        var a = t.modulus.byteLength(), n = r.length, e = _("sha1").update(c.alloc(0)).digest(), i = e.length, o = 2 * i;
        if (n > a - o - 2) throw new Error("message too long");
        var l = c.alloc(a - n - o - 2), f = a - i - 1, p = y(i), k = S(c.concat([
            e,
            l,
            c.alloc(1, 1),
            r
        ], f), P(p, f)), j = S(p, P(k, i));
        return new q(c.concat([
            c.alloc(1),
            j,
            k
        ], a));
    }
    function tr(t, r, a) {
        var n = r.length, e = t.modulus.byteLength();
        if (n > e - 11) throw new Error("message too long");
        var i;
        return a ? i = c.alloc(e - n - 3, 255) : i = ar(e - n - 3), new q(c.concat([
            c.from([
                0,
                a ? 1 : 2
            ]),
            i,
            c.alloc(1),
            r
        ], e));
    }
    function ar(t) {
        for(var r = c.allocUnsafe(t), a = 0, n = y(t * 2), e = 0, i; a < t;)e === n.length && (n = y(t * 2), e = 0), i = n[e++], i && (r[a++] = i);
        return r;
    }
});
var A12 = d11((mr, z)=>{
    var nr = Ae1, U = w21(), M = g16(), R = ki, ir = G2, or = I8, ur = m19(), s = L1;
    z.exports = function(r, a, n) {
        var e;
        r.padding ? e = r.padding : n ? e = 1 : e = 4;
        var i = nr(r), o = i.modulus.byteLength();
        if (a.length > o || new R(a).cmp(i.modulus) >= 0) throw new Error("decryption error");
        var l;
        n ? l = ur(new R(a), i) : l = ir(a, i);
        var f = s.alloc(o - l.length);
        if (l = s.concat([
            f,
            l
        ], o), e === 4) return lr(i, l);
        if (e === 1) return cr(i, l, n);
        if (e === 3) return l;
        throw new Error("unknown padding");
    };
    function lr(t, r) {
        var a = t.modulus.byteLength(), n = or("sha1").update(s.alloc(0)).digest(), e = n.length;
        if (r[0] !== 0) throw new Error("decryption error");
        var i = r.slice(1, e + 1), o = r.slice(e + 1), l = M(i, U(o, e)), f = M(o, U(l, a - e - 1));
        if (fr(n, f.slice(0, e))) throw new Error("decryption error");
        for(var p = e; f[p] === 0;)p++;
        if (f[p++] !== 1) throw new Error("decryption error");
        return f.slice(p);
    }
    function cr(t, r, a) {
        for(var n = r.slice(0, 2), e = 2, i = 0; r[e++] !== 0;)if (e >= r.length) {
            i++;
            break;
        }
        var o = r.slice(2, e - 1);
        if ((n.toString("hex") !== "0002" && !a || n.toString("hex") !== "0001" && a) && i++, o.length < 8 && i++, i) throw new Error("decryption error");
        return r.slice(e);
    }
    function fr(t, r) {
        t = s.from(t), r = s.from(r);
        var a = 0, n = t.length;
        t.length !== r.length && (a++, n = Math.min(t.length, r.length));
        for(var e = -1; ++e < n;)a += t[e] ^ r[e];
        return a;
    }
});
var E12 = d11((v)=>{
    v.publicEncrypt = N4();
    v.privateDecrypt = A12();
    v.privateEncrypt = function(r, a) {
        return v.publicEncrypt(r, a, !0);
    };
    v.publicDecrypt = function(r, a) {
        return v.privateDecrypt(r, a, !0);
    };
});
var I12 = x14(E12()), Z = x14(E12()), { publicEncrypt: qr1 , privateDecrypt: Er1 , privateEncrypt: kr1 , publicDecrypt: br2  } = Z, { default: pr , ...vr1 } = Z, xr1 = (I12.default ?? pr) ?? vr1;
var R11 = Object.create;
var A13 = Object.defineProperty;
var o4 = Object.getOwnPropertyDescriptor;
var H7 = Object.getOwnPropertyNames;
var p21 = Object.getPrototypeOf, D11 = Object.prototype.hasOwnProperty;
var S12 = (h, s)=>()=>(s || h((s = {
            exports: {}
        }).exports, s), s.exports);
var W = (h, s, a, n)=>{
    if (s && typeof s == "object" || typeof s == "function") for (let i of H7(s))!D11.call(h, i) && i !== a && A13(h, i, {
        get: ()=>s[i],
        enumerable: !(n = o4(s, i)) || n.enumerable
    });
    return h;
};
var r1 = (h, s, a)=>(a = h != null ? R11(p21(h)) : {}, W(s || !h || !h.__esModule ? A13(a, "default", {
        value: h,
        enumerable: !0
    }) : a, h));
var t = S12((I, m)=>{
    m.exports = {
        sha224WithRSAEncryption: {
            sign: "rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        "RSA-SHA224": {
            sign: "ecdsa/rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        sha256WithRSAEncryption: {
            sign: "rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        "RSA-SHA256": {
            sign: "ecdsa/rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        sha384WithRSAEncryption: {
            sign: "rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        "RSA-SHA384": {
            sign: "ecdsa/rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        sha512WithRSAEncryption: {
            sign: "rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA512": {
            sign: "ecdsa/rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA1": {
            sign: "rsa",
            hash: "sha1",
            id: "3021300906052b0e03021a05000414"
        },
        "ecdsa-with-SHA1": {
            sign: "ecdsa",
            hash: "sha1",
            id: ""
        },
        sha256: {
            sign: "ecdsa",
            hash: "sha256",
            id: ""
        },
        sha224: {
            sign: "ecdsa",
            hash: "sha224",
            id: ""
        },
        sha384: {
            sign: "ecdsa",
            hash: "sha384",
            id: ""
        },
        sha512: {
            sign: "ecdsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-SHA1": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        DSA: {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-WITH-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-WITH-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-WITH-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-WITH-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-RIPEMD160": {
            sign: "dsa",
            hash: "rmd160",
            id: ""
        },
        ripemd160WithRSA: {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        "RSA-RIPEMD160": {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        md5WithRSAEncryption: {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        },
        "RSA-MD5": {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        }
    };
});
var d12 = S12((u, g)=>{
    g.exports = t();
});
var c12 = r1(d12()), e15 = r1(d12()), { sha224WithRSAEncryption: l21 , sha256WithRSAEncryption: T10 , sha384WithRSAEncryption: $15 , sha512WithRSAEncryption: b14 , sha256: x15 , sha224: M12 , sha384: P12 , sha512: q13 , DSA: w22 , ripemd160WithRSA: j11 , md5WithRSAEncryption: k13  } = e15, { default: E13 , ...y14 } = e15, v17 = (c12.default ?? E13) ?? y14;
var C10 = Object.create;
var h15 = Object.defineProperty;
var H8 = Object.getOwnPropertyDescriptor;
var E14 = Object.getOwnPropertyNames;
var S13 = Object.getPrototypeOf, d13 = Object.prototype.hasOwnProperty;
((r)=>typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r, {
        get: (i, c)=>(typeof require != "undefined" ? require : i)[c]
    }) : r)(function(r) {
    if (typeof require != "undefined") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + r + '" is not supported');
});
var N5 = (r, i)=>()=>(i || r((i = {
            exports: {}
        }).exports, i), i.exports);
var v18 = (r, i, c, f)=>{
    if (i && typeof i == "object" || typeof i == "function") for (let p of E14(i))!d13.call(r, p) && p !== c && h15(r, p, {
        get: ()=>i[p],
        enumerable: !(f = H8(i, p)) || f.enumerable
    });
    return r;
};
var o5 = (r, i, c)=>(c = r != null ? C10(S13(r)) : {}, v18(i || !r || !r.__esModule ? h15(c, "default", {
        value: r,
        enumerable: !0
    }) : c, r));
var s9 = N5((e)=>{
    "use strict";
    e.randomBytes = e.rng = e.pseudoRandomBytes = e.prng = q7;
    e.createHash = e.Hash = I8;
    e.createHmac = e.Hmac = J6;
    var g = v17, P = Object.keys(g), A = [
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "md5",
        "rmd160"
    ].concat(P);
    e.getHashes = function() {
        return A;
    };
    var m = gr1;
    e.pbkdf2 = m.pbkdf2;
    e.pbkdf2Sync = m.pbkdf2Sync;
    var t = N3;
    e.Cipher = t.Cipher;
    e.createCipher = t.createCipher;
    e.Cipheriv = t.Cipheriv;
    e.createCipheriv = t.createCipheriv;
    e.Decipher = t.Decipher;
    e.createDecipher = t.createDecipher;
    e.Decipheriv = t.Decipheriv;
    e.createDecipheriv = t.createDecipheriv;
    e.getCiphers = t.getCiphers;
    e.listCiphers = t.listCiphers;
    var n = De3;
    e.DiffieHellmanGroup = n.DiffieHellmanGroup;
    e.createDiffieHellmanGroup = n.createDiffieHellmanGroup;
    e.getDiffieHellman = n.getDiffieHellman;
    e.createDiffieHellman = n.createDiffieHellman;
    e.DiffieHellman = n.DiffieHellman;
    var l = qr;
    e.createSign = l.createSign;
    e.Sign = l.Sign;
    e.createVerify = l.createVerify;
    e.Verify = l.Verify;
    e.createECDH = A3;
    var D = xr1;
    e.publicEncrypt = D.publicEncrypt;
    e.privateEncrypt = D.privateEncrypt;
    e.publicDecrypt = D.publicDecrypt;
    e.privateDecrypt = D.privateDecrypt;
    var _ = G8;
    e.randomFill = _.randomFill;
    e.randomFillSync = _.randomFillSync;
    e.createCredentials = function() {
        throw new Error([
            "sorry, createCredentials is not implemented yet",
            "we accept pull requests",
            "https://github.com/crypto-browserify/crypto-browserify"
        ].join(`
`));
    };
    e.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    };
});
var u11 = o5(s9()), y15 = o5(s9()), { randomBytes: G10 , rng: q14 , pseudoRandomBytes: T11 , prng: V7 , createHash: B17 , Hash: k14 , createHmac: F10 , Hmac: K13 , getHashes: L17 , pbkdf2: w23 , pbkdf2Sync: M13 , Cipher: $16 , createCipher: U6 , Cipheriv: j12 , createCipheriv: x16 , Decipher: X4 , createDecipher: Y6 , Decipheriv: z14 , createDecipheriv: J13 , getCiphers: Q8 , listCiphers: W1 , DiffieHellmanGroup: Z1 , createDiffieHellmanGroup: ee , getDiffieHellman: re3 , createDiffieHellman: ie2 , DiffieHellman: ae2 , createSign: te , Sign: ce3 , createVerify: pe1 , Verify: ne1 , createECDH: le2 , publicEncrypt: De4 , privateEncrypt: se2 , publicDecrypt: fe3 , privateDecrypt: he2 , randomFill: oe2 , randomFillSync: me1 , createCredentials: _e1 , constants: ue3  } = y15, { default: O8 , ...R12 } = y15, ye3 = (u11.default ?? O8) ?? R12;
const mod107 = {
    default: ye3,
    Cipher: $16,
    Cipheriv: j12,
    Decipher: X4,
    Decipheriv: z14,
    DiffieHellman: ae2,
    DiffieHellmanGroup: Z1,
    Hash: k14,
    Hmac: K13,
    Sign: ce3,
    Verify: ne1,
    constants: ue3,
    createCipher: U6,
    createCipheriv: x16,
    createCredentials: _e1,
    createDecipher: Y6,
    createDecipheriv: J13,
    createDiffieHellman: ie2,
    createDiffieHellmanGroup: ee,
    createECDH: le2,
    createHash: B17,
    createHmac: F10,
    createSign: te,
    createVerify: pe1,
    getCiphers: Q8,
    getDiffieHellman: re3,
    getHashes: L17,
    listCiphers: W1,
    pbkdf2: w23,
    pbkdf2Sync: M13,
    privateDecrypt: he2,
    privateEncrypt: se2,
    prng: V7,
    pseudoRandomBytes: T11,
    publicDecrypt: fe3,
    publicEncrypt: De4,
    randomBytes: G10,
    randomFill: oe2,
    randomFillSync: me1,
    rng: q14
};
const codes2 = {};
const _toString4 = Object.prototype.toString;
const _isObjectLike4 = (value)=>value !== null && typeof value === "object";
const _isFunctionLike2 = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer4(value) {
    return _isObjectLike4(value) && (_toString4.call(value) === "[object ArrayBuffer]" || _toString4.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Arguments]";
}
function isArrayBuffer4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction4(value) {
    return _isFunctionLike2(value) && _toString4.call(value) === "[object AsyncFunction]";
}
function isBooleanObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Boolean]";
}
function isBoxedPrimitive4(value) {
    return isBooleanObject4(value) || isStringObject4(value) || isNumberObject4(value) || isSymbolObject4(value) || isBigIntObject4(value);
}
function isDataView4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object DataView]";
}
function isDate5(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Date]";
}
function isGeneratorFunction4(value) {
    return _isFunctionLike2(value) && _toString4.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Generator]";
}
function isMap4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Map]";
}
function isMapIterator4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Module]";
}
function isNativeError4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Error]";
}
function isNumberObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Number]";
}
function isBigIntObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object BigInt]";
}
function isPromise4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Promise]";
}
function isRegExp5(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object RegExp]";
}
function isSet4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Set]";
}
function isSetIterator4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object String]";
}
function isSymbolObject4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object Symbol]";
}
function isWeakMap4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object WeakMap]";
}
function isWeakSet4(value) {
    return _isObjectLike4(value) && _toString4.call(value) === "[object WeakSet]";
}
const __default18 = {
    isAsyncFunction: isAsyncFunction4,
    isGeneratorFunction: isGeneratorFunction4,
    isAnyArrayBuffer: isAnyArrayBuffer4,
    isArrayBuffer: isArrayBuffer4,
    isArgumentsObject: isArgumentsObject4,
    isBoxedPrimitive: isBoxedPrimitive4,
    isDataView: isDataView4,
    isMap: isMap4,
    isMapIterator: isMapIterator4,
    isModuleNamespaceObject: isModuleNamespaceObject4,
    isNativeError: isNativeError4,
    isPromise: isPromise4,
    isSet: isSet4,
    isSetIterator: isSetIterator4,
    isWeakMap: isWeakMap4,
    isWeakSet: isWeakSet4,
    isRegExp: isRegExp5,
    isDate: isDate5,
    isStringObject: isStringObject4,
    isNumberObject: isNumberObject4,
    isBooleanObject: isBooleanObject4,
    isBigIntObject: isBigIntObject4
};
const mod108 = {
    isAnyArrayBuffer: isAnyArrayBuffer4,
    isArgumentsObject: isArgumentsObject4,
    isArrayBuffer: isArrayBuffer4,
    isAsyncFunction: isAsyncFunction4,
    isBooleanObject: isBooleanObject4,
    isBoxedPrimitive: isBoxedPrimitive4,
    isDataView: isDataView4,
    isDate: isDate5,
    isGeneratorFunction: isGeneratorFunction4,
    isGeneratorObject: isGeneratorObject4,
    isMap: isMap4,
    isMapIterator: isMapIterator4,
    isModuleNamespaceObject: isModuleNamespaceObject4,
    isNativeError: isNativeError4,
    isNumberObject: isNumberObject4,
    isBigIntObject: isBigIntObject4,
    isPromise: isPromise4,
    isRegExp: isRegExp5,
    isSet: isSet4,
    isSetIterator: isSetIterator4,
    isSharedArrayBuffer: isSharedArrayBuffer4,
    isStringObject: isStringObject4,
    isSymbolObject: isSymbolObject4,
    isWeakMap: isWeakMap4,
    isWeakSet: isWeakSet4,
    default: __default18
};
Symbol("kHandle");
Symbol("kKeyObject");
Symbol("kKeyType");
const _toString5 = Object.prototype.toString;
const _isObjectLike5 = (value)=>value !== null && typeof value === "object";
function isArrayBufferView2(value) {
    return ArrayBuffer.isView(value);
}
function isUint8Array2(value) {
    return _isObjectLike5(value) && _toString5.call(value) === "[object Uint8Array]";
}
const { isDate: isDate6 , isArgumentsObject: isArgumentsObject5 , isBigIntObject: isBigIntObject5 , isBooleanObject: isBooleanObject5 , isNumberObject: isNumberObject5 , isStringObject: isStringObject5 , isSymbolObject: isSymbolObject5 , isNativeError: isNativeError5 , isRegExp: isRegExp6 , isAsyncFunction: isAsyncFunction5 , isGeneratorFunction: isGeneratorFunction5 , isGeneratorObject: isGeneratorObject5 , isPromise: isPromise5 , isMap: isMap5 , isSet: isSet5 , isMapIterator: isMapIterator5 , isSetIterator: isSetIterator5 , isWeakMap: isWeakMap5 , isWeakSet: isWeakSet5 , isArrayBuffer: isArrayBuffer5 , isDataView: isDataView5 , isSharedArrayBuffer: isSharedArrayBuffer5 , isModuleNamespaceObject: isModuleNamespaceObject5 , isAnyArrayBuffer: isAnyArrayBuffer5 , isBoxedPrimitive: isBoxedPrimitive5 ,  } = mod108;
function hideStackFrames2(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding6(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases4(enc);
}
function slowCases4(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt322(value) {
    return value === (value | 0);
}
function isUint322(value) {
    return value === value >>> 0;
}
const validateBuffer2 = hideStackFrames2((buffer, name = "buffer")=>{
    if (!isArrayBufferView2(buffer)) {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames2((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames2((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames2((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt322(value)) {
        if (typeof value !== "number") {
            throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames2((value, name, positive)=>{
    if (!isUint322(value)) {
        if (typeof value !== "number") {
            throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes2.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
hideStackFrames2((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
hideStackFrames2((callback)=>{
    if (typeof callback !== "function") {
        throw new codes2.ERR_INVALID_CALLBACK(callback);
    }
});
hideStackFrames2((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction2 = hideStackFrames2((value, name)=>{
    if (typeof value !== "function") {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames2((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty2 = Object.create(null);
kEnumerableProperty2.enumerable = true;
new Set();
const kCustomPromisifiedSymbol2 = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol2 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify2(original) {
    validateFunction2(original, "original");
    if (original[kCustomPromisifiedSymbol2]) {
        const fn = original[kCustomPromisifiedSymbol2];
        validateFunction2(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol2];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol2, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify2.custom = kCustomPromisifiedSymbol2;
var Encodings2;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings2 || (Encodings2 = {}));
const encodings2 = [];
encodings2[Encodings2.ASCII] = "ascii";
encodings2[Encodings2.BASE64] = "base64";
encodings2[Encodings2.BASE64URL] = "base64url";
encodings2[Encodings2.BUFFER] = "buffer";
encodings2[Encodings2.HEX] = "hex";
encodings2[Encodings2.LATIN1] = "latin1";
encodings2[Encodings2.UCS2] = "utf16le";
encodings2[Encodings2.UTF8] = "utf8";
function indexOfNeedle2(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function numberToBytes2(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex2(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer2(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings2[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex2(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle2(targetBuffer, buffer, byteOffset);
}
function indexOfNumber2(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes2(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer2(targetBuffer, numberToBytes2(number), byteOffset, Encodings2.UTF8, forwardDirection);
}
const base64abc2 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode5(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc2[uint8[i - 2] >> 2];
        result += base64abc2[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc2[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc2[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc2[uint8[i - 2] >> 2];
        result += base64abc2[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc2[uint8[i - 2] >> 2];
        result += base64abc2[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc2[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode4(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url2(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase642(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url2(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url2(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode6(data) {
    return convertBase64ToBase64url2(encode5(data));
}
function decode5(b64url) {
    return decode4(convertBase64urlToBase642(b64url));
}
function asciiToBytes2(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes2(str) {
    str = base64clean2(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode4(str);
}
const INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
function base64clean2(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE2, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes2(str) {
    str = base64clean2(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode5(str);
}
function hexToBytes2(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes2(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii2(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le2(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder2 = new TextEncoder();
const float32Array2 = new Float32Array(1);
const uInt8Float32Array2 = new Uint8Array(float32Array2.buffer);
const float64Array2 = new Float64Array(1);
const uInt8Float64Array2 = new Uint8Array(float64Array2.buffer);
float32Array2[0] = -1;
const bigEndian2 = uInt8Float32Array2[3] === 0;
function readUInt48LE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE2(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE2(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards2(buffer, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buffer.length - 8);
    }
    uInt8Float64Array2[7] = first;
    uInt8Float64Array2[6] = buffer[++offset];
    uInt8Float64Array2[5] = buffer[++offset];
    uInt8Float64Array2[4] = buffer[++offset];
    uInt8Float64Array2[3] = buffer[++offset];
    uInt8Float64Array2[2] = buffer[++offset];
    uInt8Float64Array2[1] = buffer[++offset];
    uInt8Float64Array2[0] = last;
    return float64Array2[0];
}
function readDoubleForwards2(buffer, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buffer.length - 8);
    }
    uInt8Float64Array2[0] = first;
    uInt8Float64Array2[1] = buffer[++offset];
    uInt8Float64Array2[2] = buffer[++offset];
    uInt8Float64Array2[3] = buffer[++offset];
    uInt8Float64Array2[4] = buffer[++offset];
    uInt8Float64Array2[5] = buffer[++offset];
    uInt8Float64Array2[6] = buffer[++offset];
    uInt8Float64Array2[7] = last;
    return float64Array2[0];
}
function writeDoubleForwards2(buffer, val, offset = 0) {
    val = +val;
    checkBounds4(buffer, offset, 7);
    float64Array2[0] = val;
    buffer[offset++] = uInt8Float64Array2[0];
    buffer[offset++] = uInt8Float64Array2[1];
    buffer[offset++] = uInt8Float64Array2[2];
    buffer[offset++] = uInt8Float64Array2[3];
    buffer[offset++] = uInt8Float64Array2[4];
    buffer[offset++] = uInt8Float64Array2[5];
    buffer[offset++] = uInt8Float64Array2[6];
    buffer[offset++] = uInt8Float64Array2[7];
    return offset;
}
function writeDoubleBackwards2(buffer, val, offset = 0) {
    val = +val;
    checkBounds4(buffer, offset, 7);
    float64Array2[0] = val;
    buffer[offset++] = uInt8Float64Array2[7];
    buffer[offset++] = uInt8Float64Array2[6];
    buffer[offset++] = uInt8Float64Array2[5];
    buffer[offset++] = uInt8Float64Array2[4];
    buffer[offset++] = uInt8Float64Array2[3];
    buffer[offset++] = uInt8Float64Array2[2];
    buffer[offset++] = uInt8Float64Array2[1];
    buffer[offset++] = uInt8Float64Array2[0];
    return offset;
}
function readFloatBackwards2(buffer, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buffer.length - 4);
    }
    uInt8Float32Array2[3] = first;
    uInt8Float32Array2[2] = buffer[++offset];
    uInt8Float32Array2[1] = buffer[++offset];
    uInt8Float32Array2[0] = last;
    return float32Array2[0];
}
function readFloatForwards2(buffer, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buffer.length - 4);
    }
    uInt8Float32Array2[0] = first;
    uInt8Float32Array2[1] = buffer[++offset];
    uInt8Float32Array2[2] = buffer[++offset];
    uInt8Float32Array2[3] = last;
    return float32Array2[0];
}
function writeFloatForwards2(buffer, val, offset = 0) {
    val = +val;
    checkBounds4(buffer, offset, 3);
    float32Array2[0] = val;
    buffer[offset++] = uInt8Float32Array2[0];
    buffer[offset++] = uInt8Float32Array2[1];
    buffer[offset++] = uInt8Float32Array2[2];
    buffer[offset++] = uInt8Float32Array2[3];
    return offset;
}
function writeFloatBackwards2(buffer, val, offset = 0) {
    val = +val;
    checkBounds4(buffer, offset, 3);
    float32Array2[0] = val;
    buffer[offset++] = uInt8Float32Array2[3];
    buffer[offset++] = uInt8Float32Array2[2];
    buffer[offset++] = uInt8Float32Array2[1];
    buffer[offset++] = uInt8Float32Array2[0];
    return offset;
}
function readInt24LE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE2(buf, offset = 0) {
    validateNumber2(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError2(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf82(str) {
    return utf8Encoder2.encode(str).length;
}
function base64ByteLength2(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap2 = Object.create(null);
for(let i11 = 0; i11 < encodings2.length; ++i11){
    encodingsMap2[encodings2[i11]] = i11;
}
const encodingOps2 = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap2.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength2(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap2.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, base64ToBytes2(val), byteOffset, encodingsMap2.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength2(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap2.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, base64UrlToBytes2(val), byteOffset, encodingsMap2.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap2.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, hexToBytes2(val), byteOffset, encodingsMap2.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap2.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap2.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf82,
        encoding: "utf8",
        encodingVal: encodingsMap2.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, utf8Encoder2.encode(val), byteOffset, encodingsMap2.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap2.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps2(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps2.utf8;
            if (encoding === "ucs2") return encodingOps2.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps2.utf8;
            if (encoding === "ascii") return encodingOps2.ascii;
            if (encoding === "ucs-2") return encodingOps2.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps2.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps2.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps2.latin1;
            }
            if (encoding === "base64") return encodingOps2.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps2.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps2.base64url;
            }
            break;
    }
}
function _copyActual2(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError2(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber2(value, type);
        throw new codes2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber2(value, name) {
    if (typeof value !== "number") {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds4(buf, offset, byteLength) {
    validateNumber2(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError2(offset, buf.length - (byteLength + 1));
    }
}
function checkInt2(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds4(buf, offset, byteLength);
}
function toInteger2(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int82(buf, value, offset, min, max) {
    value = +value;
    validateNumber2(offset, "offset");
    if (value > max || value < min) {
        throw new codes2.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError2(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset2(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE2(buf, value, offset, min, max) {
    value = +value;
    checkInt2(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength2 = 2147483647;
const MAX_UINT322 = 2 ** 32;
const customInspectSymbol4 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES2 = 50;
Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer2.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer2.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer2(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
}
function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes2.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe2(arg);
    }
    return _from4(arg, encodingOrOffset, length);
}
Buffer2.poolSize = 8192;
function _from4(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString2(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer5(value)) {
            return fromArrayBuffer2(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from4(valueOf, encodingOrOffset, length);
        }
        const b = fromObject2(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString2(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes2.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer2.from = function from(value, encodingOrOffset, length) {
    return _from4(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer2, Uint8Array);
function assertSize3(size) {
    validateNumber2(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes2.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc2(size, fill, encoding) {
    assertSize3(size);
    const buffer = createBuffer2(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes2.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer2.alloc = function alloc(size, fill, encoding) {
    return _alloc2(size, fill, encoding);
};
function _allocUnsafe2(size) {
    assertSize3(size);
    return createBuffer2(size < 0 ? 0 : checked2(size) | 0);
}
Buffer2.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe2(size);
};
Buffer2.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe2(size);
};
function fromString2(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
        throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength4(string, encoding) | 0;
    let buf = createBuffer2(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike2(array) {
    const length = array.length < 0 ? 0 : checked2(array.length) | 0;
    const buf = createBuffer2(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject2(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer5(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer2(0);
        }
        return fromArrayLike2(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike2(obj.data);
    }
}
function checked2(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer2(length) {
    assertSize3(length);
    return Buffer2.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer2, Uint8Array);
Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
};
Buffer2.compare = function compare(a, b) {
    if (isInstance2(a, Uint8Array)) {
        a = Buffer2.from(a, a.offset, a.byteLength);
    }
    if (isInstance2(b, Uint8Array)) {
        b = Buffer2.from(b, b.offset, b.byteLength);
    }
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding6(encoding) !== undefined;
};
Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes2.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer2.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset2(length, "length");
    }
    const buffer = Buffer2.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array2(buf)) {
            throw new codes2.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual2(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength4(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView2(string) || isAnyArrayBuffer5(string)) {
            return string.byteLength;
        }
        throw new codes2.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf82(string);
    }
    const ops = getEncodingOps2(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf82(string);
    }
    return ops.byteLength(string);
}
Buffer2.byteLength = byteLength4;
Buffer2.prototype._isBuffer = true;
function swap2(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap2(this, i, i + 1);
    }
    return this;
};
Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap2(this, i, i + 3);
        swap2(this, i + 1, i + 2);
    }
    return this;
};
Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap2(this, i, i + 7);
        swap2(this, i + 1, i + 6);
        swap2(this, i + 2, i + 5);
        swap2(this, i + 3, i + 4);
    }
    return this;
};
Buffer2.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps2(encoding);
    if (ops === undefined) {
        throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
Buffer2.prototype.equals = function equals(b) {
    if (!isUint8Array2(b)) {
        throw new codes2.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer2.compare(this, b) === 0;
};
Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES2;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol4) {
    Buffer2.prototype[customInspectSymbol4] = Buffer2.prototype.inspect;
}
Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance2(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
        throw new codes2.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset2(start, "targetStart", 0, kMaxLength2);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset2(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset2(start, "sourceStart", 0, kMaxLength2);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset2(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes2.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
    validateBuffer2(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber2(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps2.utf8;
    } else {
        ops = getEncodingOps2(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array2(val)) {
        const encodingVal = ops === undefined ? encodingsMap2.utf8 : ops.encodingVal;
        return indexOfBuffer2(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes2.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
Buffer2.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii2(this);
    } else {
        return bytesToAscii2(this.slice(offset, length));
    }
};
Buffer2.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer2.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode5(this);
    } else {
        return encode5(this.slice(offset, length));
    }
};
Buffer2.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer2(base64ToBytes2(string), this, offset, length);
};
Buffer2.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode6(this);
    } else {
        return encode6(this.slice(offset, length));
    }
};
Buffer2.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer2(base64UrlToBytes2(string), this, offset, length);
};
Buffer2.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer2(hexToBytes2(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice2(this, string, offset, length);
};
Buffer2.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice2(this, string, offset, length);
};
Buffer2.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer2.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le2(this);
    } else {
        return bytesToUtf16le2(this.slice(offset, length));
    }
};
Buffer2.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer2(utf16leToBytes2(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice2(this, string, offset, length);
};
Buffer2.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer2(utf8ToBytes2(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset2(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset2(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps2(encoding);
    if (ops === undefined) {
        throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer2.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer2(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer2.prototype);
    return buffer;
}
function _utf8Slice2(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
}
const MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
    }
    return res;
}
function _latin1Slice2(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice2(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable2[buf[i]];
    }
    return out;
}
Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
};
Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE2(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE2(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE2(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE2(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE2(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE2(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber2(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError2(offset, this.length - 1);
    }
    return val;
};
Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = readUInt16BE2;
Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = readUInt32BE2;
Buffer2.prototype.readBigUint64LE = Buffer2.prototype.readBigUInt64LE = defineBigIntMethod2(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError2(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer2.prototype.readBigUint64BE = Buffer2.prototype.readBigUInt64BE = defineBigIntMethod2(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError2(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE2(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE2(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE2(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE2(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE2(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE2(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber2(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError2(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError2(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer2.prototype.readBigInt64LE = defineBigIntMethod2(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError2(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer2.prototype.readBigInt64BE = defineBigIntMethod2(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber2(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError2(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer2.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian2 ? readFloatBackwards2(this, offset) : readFloatForwards2(this, offset);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian2 ? readFloatForwards2(this, offset) : readFloatBackwards2(this, offset);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian2 ? readDoubleBackwards2(this, offset) : readDoubleForwards2(this, offset);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian2 ? readDoubleForwards2(this, offset) : readDoubleBackwards2(this, offset);
};
Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE2(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE2(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE2(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE2(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE2(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int82(this, value, offset, 0, 0xff);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE2(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE2(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE2(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE2(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE2(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int82(this, value, offset, 0, 0xff);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int82(this, value, offset, 0, 0xff);
};
Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE2(this, value, offset, 0, 0xffff);
};
Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE2(this, value, offset, 0, 0xffff);
};
Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE2(this, value, offset, 0, 0xffffffff);
};
Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE2(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE2(buf, value, offset, min, max) {
    checkIntBI2(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE2(buf, value, offset, min, max) {
    checkIntBI2(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer2.prototype.writeBigUint64LE = Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod2(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer2.prototype.writeBigUint64BE = Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod2(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE2(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE2(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE2(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE2(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE2(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int82(this, value, offset, -0x80, 0x7f);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE2(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE2(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE2(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE2(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE2(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int82(this, value, offset, -0x80, 0x7f);
    }
    boundsError2(byteLength, 6, "byteLength");
};
Buffer2.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int82(this, value, offset, -0x80, 0x7f);
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE2(this, value, offset, -0x8000, 0x7fff);
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE2(this, value, offset, -0x8000, 0x7fff);
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE2(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE2(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer2.prototype.writeBigInt64LE = defineBigIntMethod2(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer2.prototype.writeBigInt64BE = defineBigIntMethod2(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian2 ? writeFloatBackwards2(this, value, offset) : writeFloatForwards2(this, value, offset);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian2 ? writeFloatForwards2(this, value, offset) : writeFloatBackwards2(this, value, offset);
};
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian2 ? writeDoubleBackwards2(this, value, offset) : writeDoubleForwards2(this, value, offset);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian2 ? writeDoubleForwards2(this, value, offset) : writeDoubleBackwards2(this, value, offset);
};
Buffer2.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array2(this)) {
        throw new codes2.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array2(target)) {
        throw new codes2.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger2(targetStart, 0);
        if (targetStart < 0) {
            throw new codes2.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger2(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes2.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT322) {
            throw new codes2.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT322}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger2(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT322) {
            throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT322}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes2.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds5(buf, offset, byteLength2) {
    validateNumber2(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError2(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI2(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds5(buf, offset, byteLength2);
}
function utf8ToBytes2(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer2(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance2(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable2 = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod2(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined2 : fn;
}
function BufferBigIntNotDefined2() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
const codes3 = {};
function hideStackFrames3(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
const _toString6 = Object.prototype.toString;
const _isObjectLike6 = (value)=>value !== null && typeof value === "object";
const _isFunctionLike3 = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer6(value) {
    return _isObjectLike6(value) && (_toString6.call(value) === "[object ArrayBuffer]" || _toString6.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Arguments]";
}
function isArrayBuffer6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction6(value) {
    return _isFunctionLike3(value) && _toString6.call(value) === "[object AsyncFunction]";
}
function isBooleanObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Boolean]";
}
function isBoxedPrimitive6(value) {
    return isBooleanObject6(value) || isStringObject6(value) || isNumberObject6(value) || isSymbolObject6(value) || isBigIntObject6(value);
}
function isDataView6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object DataView]";
}
function isDate7(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Date]";
}
function isGeneratorFunction6(value) {
    return _isFunctionLike3(value) && _toString6.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Generator]";
}
function isMap6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Map]";
}
function isMapIterator6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Module]";
}
function isNativeError6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Error]";
}
function isNumberObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Number]";
}
function isBigIntObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object BigInt]";
}
function isPromise6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Promise]";
}
function isRegExp7(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object RegExp]";
}
function isSet6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Set]";
}
function isSetIterator6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object String]";
}
function isSymbolObject6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object Symbol]";
}
function isWeakMap6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object WeakMap]";
}
function isWeakSet6(value) {
    return _isObjectLike6(value) && _toString6.call(value) === "[object WeakSet]";
}
const __default19 = {
    isAsyncFunction: isAsyncFunction6,
    isGeneratorFunction: isGeneratorFunction6,
    isAnyArrayBuffer: isAnyArrayBuffer6,
    isArrayBuffer: isArrayBuffer6,
    isArgumentsObject: isArgumentsObject6,
    isBoxedPrimitive: isBoxedPrimitive6,
    isDataView: isDataView6,
    isMap: isMap6,
    isMapIterator: isMapIterator6,
    isModuleNamespaceObject: isModuleNamespaceObject6,
    isNativeError: isNativeError6,
    isPromise: isPromise6,
    isSet: isSet6,
    isSetIterator: isSetIterator6,
    isWeakMap: isWeakMap6,
    isWeakSet: isWeakSet6,
    isRegExp: isRegExp7,
    isDate: isDate7,
    isStringObject: isStringObject6,
    isNumberObject: isNumberObject6,
    isBooleanObject: isBooleanObject6,
    isBigIntObject: isBigIntObject6
};
const mod109 = {
    isAnyArrayBuffer: isAnyArrayBuffer6,
    isArgumentsObject: isArgumentsObject6,
    isArrayBuffer: isArrayBuffer6,
    isAsyncFunction: isAsyncFunction6,
    isBooleanObject: isBooleanObject6,
    isBoxedPrimitive: isBoxedPrimitive6,
    isDataView: isDataView6,
    isDate: isDate7,
    isGeneratorFunction: isGeneratorFunction6,
    isGeneratorObject: isGeneratorObject6,
    isMap: isMap6,
    isMapIterator: isMapIterator6,
    isModuleNamespaceObject: isModuleNamespaceObject6,
    isNativeError: isNativeError6,
    isNumberObject: isNumberObject6,
    isBigIntObject: isBigIntObject6,
    isPromise: isPromise6,
    isRegExp: isRegExp7,
    isSet: isSet6,
    isSetIterator: isSetIterator6,
    isSharedArrayBuffer: isSharedArrayBuffer6,
    isStringObject: isStringObject6,
    isSymbolObject: isSymbolObject6,
    isWeakMap: isWeakMap6,
    isWeakSet: isWeakSet6,
    default: __default19
};
Symbol("kHandle");
const kKeyObject2 = Symbol("kKeyObject");
const kKeyType2 = Symbol("kKeyType");
function isKeyObject2(obj) {
    return obj != null && obj[kKeyType2] !== undefined;
}
function isCryptoKey2(obj) {
    return obj != null && obj[kKeyObject2] !== undefined;
}
const _toString7 = Object.prototype.toString;
const _isObjectLike7 = (value)=>value !== null && typeof value === "object";
function isArrayBufferView3(value) {
    return ArrayBuffer.isView(value);
}
function isBigInt64Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object BigUint64Array]";
}
function isFloat32Array2(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Float32Array]";
}
function isFloat64Array2(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Float64Array]";
}
function isInt8Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Int8Array]";
}
function isInt16Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Int16Array]";
}
function isInt32Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Int32Array]";
}
function isTypedArray2(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike7(value) && reTypedTag.test(_toString7.call(value));
}
function isUint8Array3(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Uint16Array]";
}
function isUint32Array1(value) {
    return _isObjectLike7(value) && _toString7.call(value) === "[object Uint32Array]";
}
const { isDate: isDate8 , isArgumentsObject: isArgumentsObject7 , isBigIntObject: isBigIntObject7 , isBooleanObject: isBooleanObject7 , isNumberObject: isNumberObject7 , isStringObject: isStringObject7 , isSymbolObject: isSymbolObject7 , isNativeError: isNativeError7 , isRegExp: isRegExp8 , isAsyncFunction: isAsyncFunction7 , isGeneratorFunction: isGeneratorFunction7 , isGeneratorObject: isGeneratorObject7 , isPromise: isPromise7 , isMap: isMap7 , isSet: isSet7 , isMapIterator: isMapIterator7 , isSetIterator: isSetIterator7 , isWeakMap: isWeakMap7 , isWeakSet: isWeakSet7 , isArrayBuffer: isArrayBuffer7 , isDataView: isDataView7 , isSharedArrayBuffer: isSharedArrayBuffer7 , isModuleNamespaceObject: isModuleNamespaceObject7 , isAnyArrayBuffer: isAnyArrayBuffer7 , isBoxedPrimitive: isBoxedPrimitive7 ,  } = mod109;
const mod110 = {
    isCryptoKey: isCryptoKey2,
    isKeyObject: isKeyObject2,
    isArrayBufferView: isArrayBufferView3,
    isBigInt64Array: isBigInt64Array1,
    isBigUint64Array: isBigUint64Array1,
    isFloat32Array: isFloat32Array2,
    isFloat64Array: isFloat64Array2,
    isInt8Array: isInt8Array1,
    isInt16Array: isInt16Array1,
    isInt32Array: isInt32Array1,
    isTypedArray: isTypedArray2,
    isUint8Array: isUint8Array3,
    isUint8ClampedArray: isUint8ClampedArray1,
    isUint16Array: isUint16Array1,
    isUint32Array: isUint32Array1,
    isDate: isDate8,
    isArgumentsObject: isArgumentsObject7,
    isBigIntObject: isBigIntObject7,
    isBooleanObject: isBooleanObject7,
    isNumberObject: isNumberObject7,
    isStringObject: isStringObject7,
    isSymbolObject: isSymbolObject7,
    isNativeError: isNativeError7,
    isRegExp: isRegExp8,
    isAsyncFunction: isAsyncFunction7,
    isGeneratorFunction: isGeneratorFunction7,
    isGeneratorObject: isGeneratorObject7,
    isPromise: isPromise7,
    isMap: isMap7,
    isSet: isSet7,
    isMapIterator: isMapIterator7,
    isSetIterator: isSetIterator7,
    isWeakMap: isWeakMap7,
    isWeakSet: isWeakSet7,
    isArrayBuffer: isArrayBuffer7,
    isDataView: isDataView7,
    isSharedArrayBuffer: isSharedArrayBuffer7,
    isModuleNamespaceObject: isModuleNamespaceObject7,
    isAnyArrayBuffer: isAnyArrayBuffer7,
    isBoxedPrimitive: isBoxedPrimitive7
};
function normalizeEncoding7(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases5(enc);
}
function slowCases5(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt323(value) {
    return value === (value | 0);
}
function isUint323(value) {
    return value === value >>> 0;
}
const validateBuffer3 = hideStackFrames3((buffer, name = "buffer")=>{
    if (!isArrayBufferView3(buffer)) {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames3((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject2 = hideStackFrames3((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames3((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt323(value)) {
        if (typeof value !== "number") {
            throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames3((value, name, positive)=>{
    if (!isUint323(value)) {
        if (typeof value !== "number") {
            throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes3.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString2(value, name) {
    if (typeof value !== "string") {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
hideStackFrames3((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
const validateCallback2 = hideStackFrames3((callback)=>{
    if (typeof callback !== "function") {
        throw new codes3.ERR_INVALID_CALLBACK(callback);
    }
});
hideStackFrames3((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction3 = hideStackFrames3((value, name)=>{
    if (typeof value !== "function") {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames3((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty3 = Object.create(null);
kEnumerableProperty3.enumerable = true;
const codesWarned1 = new Set();
function deprecate1(fn, msg, code) {
    if (code !== undefined) {
        validateString2(code, "code");
    }
    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned1.has(code)) {
                    process.emitWarning(msg, "DeprecationWarning", code, deprecated);
                    codesWarned1.add(code);
                }
            } else {
                process.emitWarning(msg, "DeprecationWarning", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
const kCustomPromisifiedSymbol3 = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol3 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify3(original) {
    validateFunction3(original, "original");
    if (original[kCustomPromisifiedSymbol3]) {
        const fn = original[kCustomPromisifiedSymbol3];
        validateFunction3(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol3, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol3];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol3, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify3.custom = kCustomPromisifiedSymbol3;
let core2;
if (Deno?.core) {
    core2 = Deno.core;
} else {
    core2 = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting2 = false;
const kSize2 = 2048;
const kMask2 = 2048 - 1;
class FixedCircularBuffer2 {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize2);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask2) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask2;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask2;
        return nextItem;
    }
}
class FixedQueue2 {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer2();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer2();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue2 = new FixedQueue2();
let _nextTick2;
if (typeof core2.setNextTickCallback !== "undefined") {
    function runNextTicks2() {
        if (!core2.hasTickScheduled()) {
            core2.runMicrotasks();
        }
        if (!core2.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections2();
        return true;
    }
    function processTicksAndRejections2() {
        let tock;
        do {
            while(tock = queue2.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core2.runMicrotasks();
        }while (!queue2.isEmpty())
        core2.setHasTickScheduled(false);
    }
    core2.setNextTickCallback(processTicksAndRejections2);
    core2.setMacrotaskCallback(runNextTicks2);
    function __nextTickNative2(callback, ...args) {
        validateCallback2(callback);
        if (_exiting2) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue2.isEmpty()) {
            core2.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue2.push(tickObject);
    }
    _nextTick2 = __nextTickNative2;
} else {
    function __nextTickQueueMicrotask2(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick2 = __nextTickQueueMicrotask2;
}
function nextTick5(callback, ...args) {
    _nextTick2(callback, ...args);
}
class NodeFalsyValueRejectionError1 extends Error {
    reason;
    code = "ERR_FALSY_VALUE_REJECTION";
    constructor(reason){
        super("Promise was rejected with falsy value");
        this.reason = reason;
    }
}
class NodeInvalidArgTypeError1 extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName){
        super(`The ${argumentName} argument must be of type function.`);
    }
}
function callbackify1(original) {
    if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError1('"original"');
    }
    const callbackified = function(...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
            throw new NodeInvalidArgTypeError1("last");
        }
        const cb = (...args)=>{
            maybeCb.apply(this, args);
        };
        original.apply(this, args).then((ret)=>{
            nextTick5(cb.bind(this, null, ret));
        }, (rej)=>{
            rej = rej || new NodeFalsyValueRejectionError1(rej);
            nextTick5(cb.bind(this, rej));
        });
    };
    const descriptors = Object.getOwnPropertyDescriptors(original);
    if (typeof descriptors.length.value === "number") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === "string") {
        descriptors.name.value += "Callbackified";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}
var State2;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State2 || (State2 = {}));
var WorP2;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP2 || (WorP2 = {}));
class Flags2 {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min2 = Math.min;
const UNICODE_REPLACEMENT_CHARACTER2 = "\ufffd";
const FLOAT_REGEXP2 = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F11;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F11 || (F11 = {}));
class Printf2 {
    format;
    args;
    i;
    state = State2.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags2();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State2.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State2.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State2.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State2.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags2();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State2.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State2.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State2.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State2.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State2.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP2.WIDTH : WorP2.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State2.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP2.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP2.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State2.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State2.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP2.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State2.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State2.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP2.PRECISION);
                            break;
                        }
                        const val1 = parseInt(c);
                        if (isNaN(val1)) {
                            this.i--;
                            this.state = State2.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val1;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State2.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER2;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP2);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F11.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F11.exponent];
        let esign = m[F11.esign];
        let mantissa = parseInt(m[F11.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP2);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F11.exponent]) * (m[F11.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min2(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf2(format, ...args) {
    const printf = new Printf2(format, ...args);
    return printf.doPrintf();
}
const { Deno: Deno3  } = globalThis;
typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType2;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType2 || (DiffType2 = {}));
class AssertionError2 extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function unreachable2() {
    throw new AssertionError2("unreachable");
}
class DenoStdInternalError2 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert4(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError2(msg);
    }
}
function indexOfNeedle3(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy2(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE2 = 16;
const CR2 = "\r".charCodeAt(0);
const LF2 = "\n".charCodeAt(0);
class BufferFullError2 extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError2 extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader2 {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader2 ? r : new BufReader2(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE2;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert4(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr1 = await this.#rd.read(p);
                const nread = rr1 ?? 0;
                assert4(nread >= 0, "negative read");
                return rr1;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert4(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy2(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError2();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError2) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError2();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF2);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError2) {
                partial = err.partial;
                assert4(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError2)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR2) {
                assert4(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF2) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR2) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError2(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError2) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError2();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError2) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError2();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError2(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
class AbstractBufBase2 {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter2 extends AbstractBufBase2 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter2 ? writer : new BufWriter2(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync2 extends AbstractBufBase2 {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync2 ? writer : new BufWriterSync2(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy2(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const _TextDecoder1 = TextDecoder;
const _TextEncoder1 = TextEncoder;
const isNumericLookup2 = {};
function isArrayIndex2(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup2[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup2[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup2[value] = false;
                    }
                }
                return isNumericLookup2[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties2(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex2(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const kObjectType2 = 0;
const kArrayExtrasType2 = 2;
const kRejected2 = 2;
const meta2 = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject2 = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp2 = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp2 = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp2 = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp4 = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp2 = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions2 = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions2(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect3(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor2,
        showHidden: inspectDefaultOptions2.showHidden,
        depth: inspectDefaultOptions2.depth,
        colors: inspectDefaultOptions2.colors,
        customInspect: inspectDefaultOptions2.customInspect,
        showProxy: inspectDefaultOptions2.showProxy,
        maxArrayLength: inspectDefaultOptions2.maxArrayLength,
        maxStringLength: inspectDefaultOptions2.maxStringLength,
        breakLength: inspectDefaultOptions2.breakLength,
        compact: inspectDefaultOptions2.compact,
        sorted: inspectDefaultOptions2.sorted,
        getters: inspectDefaultOptions2.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions2.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor2;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue2(ctx, value, 0);
}
const customInspectSymbol5 = Symbol.for("nodejs.util.inspect.custom");
inspect3.custom = customInspectSymbol5;
Object.defineProperty(inspect3, "defaultOptions", {
    get () {
        return inspectDefaultOptions2;
    },
    set (options) {
        validateObject2(options, "options");
        return Object.assign(inspectDefaultOptions2, options);
    }
});
const defaultFG2 = 39;
const defaultBG2 = 49;
inspect3.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG2
    ],
    red: [
        31,
        defaultFG2
    ],
    green: [
        32,
        defaultFG2
    ],
    yellow: [
        33,
        defaultFG2
    ],
    blue: [
        34,
        defaultFG2
    ],
    magenta: [
        35,
        defaultFG2
    ],
    cyan: [
        36,
        defaultFG2
    ],
    white: [
        37,
        defaultFG2
    ],
    bgBlack: [
        40,
        defaultBG2
    ],
    bgRed: [
        41,
        defaultBG2
    ],
    bgGreen: [
        42,
        defaultBG2
    ],
    bgYellow: [
        43,
        defaultBG2
    ],
    bgBlue: [
        44,
        defaultBG2
    ],
    bgMagenta: [
        45,
        defaultBG2
    ],
    bgCyan: [
        46,
        defaultBG2
    ],
    bgWhite: [
        47,
        defaultBG2
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG2
    ],
    redBright: [
        91,
        defaultFG2
    ],
    greenBright: [
        92,
        defaultFG2
    ],
    yellowBright: [
        93,
        defaultFG2
    ],
    blueBright: [
        94,
        defaultFG2
    ],
    magentaBright: [
        95,
        defaultFG2
    ],
    cyanBright: [
        96,
        defaultFG2
    ],
    whiteBright: [
        97,
        defaultFG2
    ],
    bgGray: [
        100,
        defaultBG2
    ],
    bgRedBright: [
        101,
        defaultBG2
    ],
    bgGreenBright: [
        102,
        defaultBG2
    ],
    bgYellowBright: [
        103,
        defaultBG2
    ],
    bgBlueBright: [
        104,
        defaultBG2
    ],
    bgMagentaBright: [
        105,
        defaultBG2
    ],
    bgCyanBright: [
        106,
        defaultBG2
    ],
    bgWhiteBright: [
        107,
        defaultBG2
    ]
});
function defineColorAlias2(target, alias) {
    Object.defineProperty(inspect3.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias2("gray", "grey");
defineColorAlias2("gray", "blackBright");
defineColorAlias2("bgGray", "bgGrey");
defineColorAlias2("bgGray", "bgBlackBright");
defineColorAlias2("dim", "faint");
defineColorAlias2("strikethrough", "crossedout");
defineColorAlias2("strikethrough", "strikeThrough");
defineColorAlias2("strikethrough", "crossedOut");
defineColorAlias2("hidden", "conceal");
defineColorAlias2("inverse", "swapColors");
defineColorAlias2("inverse", "swapcolors");
defineColorAlias2("doubleunderline", "doubleUnderline");
inspect3.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes2(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn2 = (str)=>meta2[str.charCodeAt(0)];
function strEscape2(str) {
    let escapeTest = strEscapeSequencesRegExp2;
    let escapeReplace = strEscapeSequencesReplacer2;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle2;
            escapeReplace = strEscapeSequencesReplacerSingle2;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes2(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn2);
        return addQuotes2(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta2[point];
            } else {
                result += `${str.slice(last, i)}${meta2[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes2(result, singleQuote);
}
function stylizeWithColor2(str, styleType) {
    const style = inspect3.styles[styleType];
    if (style !== undefined) {
        const color = inspect3.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor2(str) {
    return str;
}
function formatValue2(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject2(value)) {
        return formatPrimitive2(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol5];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect3 && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions2(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue2(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw2(ctx, value, recurseTimes, typedArray);
}
function formatRaw2(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName2(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray2;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix2(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties2(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType2;
            formatter = formatArray2;
        } else if (isSet7(value)) {
            const size = value.size;
            const prefix1 = getPrefix2(constructor, tag, "Set", `(${size})`);
            keys = getKeys2(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet2.bind(null, value) : formatSet2.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix1}{}`;
            }
            braces = [
                `${prefix1}{`,
                "}"
            ];
        } else if (isMap7(value)) {
            const size1 = value.size;
            const prefix2 = getPrefix2(constructor, tag, "Map", `(${size1})`);
            keys = getKeys2(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap2.bind(null, value) : formatMap2.bind(null, value.entries());
            if (size1 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix2}{}`;
            }
            braces = [
                `${prefix2}{`,
                "}"
            ];
        } else if (isTypedArray2(value)) {
            keys = getOwnNonIndexProperties2(value, filter);
            const bound = value;
            const fallback = "";
            const size2 = value.length;
            const prefix3 = getPrefix2(constructor, tag, fallback, `(${size2})`);
            braces = [
                `${prefix3}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray2.bind(null, bound, size2);
            extrasType = kArrayExtrasType2;
        } else if (isMapIterator7(value)) {
            keys = getKeys2(value, ctx.showHidden);
            braces = getIteratorBraces2("Map", tag);
            formatter = formatIterator2.bind(null, braces);
        } else if (isSetIterator7(value)) {
            keys = getKeys2(value, ctx.showHidden);
            braces = getIteratorBraces2("Set", tag);
            formatter = formatIterator2.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys2(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject7(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix2(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase2(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp8(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix4 = getPrefix2(constructor, tag, "RegExp");
            if (prefix4 !== "RegExp ") {
                base = `${prefix4}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate8(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix5 = getPrefix2(constructor, tag, "Date");
            if (prefix5 !== "Date ") {
                base = `${prefix5}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError2(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer7(value)) {
            const arrayType = isArrayBuffer7(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix6 = getPrefix2(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer2;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix6 + `{ byteLength: ${formatNumber2(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix6}{`;
            Array.prototype.unshift.call(keys, "byteLength");
        } else if (isDataView7(value)) {
            braces[0] = `${getPrefix2(constructor, tag, "DataView")}{`;
            Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise7(value)) {
            braces[0] = `${getPrefix2(constructor, tag, "Promise")}{`;
            formatter = formatPromise2;
        } else if (isWeakSet7(value)) {
            braces[0] = `${getPrefix2(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet2 : formatWeakCollection2;
        } else if (isWeakMap7(value)) {
            braces[0] = `${getPrefix2(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap2 : formatWeakCollection2;
        } else if (isModuleNamespaceObject7(value)) {
            braces[0] = `${getPrefix2(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject2.bind(null, keys);
        } else if (isBoxedPrimitive7(value)) {
            base = getBoxedBase2(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle2(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle2(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle2(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty2(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName1 = getCtxStyle2(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize2(ctx, err, constructorName1, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString2(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects2 = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties2(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach.call(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push.call(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty2(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push.call(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push.call(output, value);
            }
        }
        Array.prototype.pop.call(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName2(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject2(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof2(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects2.has(descriptor.value.name))) {
                addPrototypeProperties2(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName2(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect3(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive2(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape2(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape2(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber2(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt2(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray2() {
    return [];
}
function isInstanceof2(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix2(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray2(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray2(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty2(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle2(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix2(constructor, tag, fallback);
}
function getKeys2(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet2(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push.call(output, formatValue2(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap2(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue2(ctx, k, recurseTimes)} => ${formatValue2(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray2(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber2 : formatBigInt2;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue2(ctx, value[key], recurseTimes, true);
            Array.prototype.push.call(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces2(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator2(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner2(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner2(ctx, recurseTimes, entries, 1);
}
function getFunctionBase2(value, constructor, tag) {
    const stringified = Function.prototype.toString.call(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp4.test(slice.replace(stripCommentsRegExp2)))) {
            return getClassBase2(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction7(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction7(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError2(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name1 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name1);
            if (index !== -1 && stack.includes(err[name1])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix2(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos1 = 0;
            while(nodeModule = nodeModulesRegExp2.exec(line)){
                newStack += line.slice(pos1, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos1 = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos1 === 0 ? line : line.slice(pos1);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice2;
function formatArrayBuffer2(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice2(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber2(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise2(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue2(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected2 ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection2(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet2(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner2(ctx, recurseTimes, entries, 0);
}
function formatWeakMap2(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner2(ctx, recurseTimes, entries, 0);
}
function formatProperty2(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue2(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth2(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue2(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive2(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp1 = key.toString().replace(strEscapeSequencesReplacer2, escapeFn2);
        name = `[${ctx.stylize(tmp1, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp2 = key.replace(strEscapeSequencesReplacer2, escapeFn2);
        name = `[${tmp2}]`;
    } else if (keyStrRegExp2.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape2(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize2(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp2 = /\u001b\[\d\d?m/g;
function removeColors2(str) {
    return str.replace(colorRegExp2, "");
}
function isBelowBreakLength2(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors2(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt2(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject2(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty2(ctx, value, recurseTimes, keys[i], kObjectType2);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty2(ctx, tmp, recurseTimes, keys[i], kObjectType2);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray2(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp2.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty2(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending1 = remaining > 1 ? "s" : "";
            const message1 = `<${remaining} empty item${ending1}>`;
            output.push(ctx.stylize(message1, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase2(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject7(value)) {
        type = "Number";
    } else if (isStringObject7(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject7(value)) {
        type = "Boolean";
    } else if (isBigIntObject7(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive2(stylizeNoColor2, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor2) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase2(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString2(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements2(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength2(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join10(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join10(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength2(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join10(output, ", ")} ` + braces[1];
    }
    const indentation1 = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation1}  `;
    return `${braces[0]}${ln}${join10(output, `,\n${indentation1}  `)} ${braces[1]}`;
}
function join10(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements2(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth2(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i1 = 0; i1 < columns; i1++){
            let lineMaxLength = 0;
            for(let j = i1; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i1] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i2 = 0; i2 < output.length; i2++){
                if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i3 = 0; i3 < outputLength; i3 += columns){
            const max = Math.min(i3 + columns, outputLength);
            let str = "";
            let j1 = i3;
            for(; j1 < max - 1; j1++){
                const padding = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1];
                str += `${output[j1]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding1 = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1] - 2;
                str += output[j1].padStart(padding1, " ");
            } else {
                str += output[j1];
            }
            Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner2(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue2(ctx, entries[pos], recurseTimes)} => ${formatValue2(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos1 = i * 2;
            const res = [
                formatValue2(ctx, entries[pos1], recurseTimes),
                formatValue2(ctx, entries[pos1 + 1], recurseTimes), 
            ];
            output[i] = reduceToSingleString2(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType2, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner2(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue2(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern2 = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi2 = new RegExp(ansiPattern2, "g");
function getStringWidth2(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters2(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint2(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint2(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint2 = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint2 = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function hasBuiltInToString1(value) {
    const proxyTarget = undefined;
    if (proxyTarget !== undefined) {
        value = proxyTarget;
    }
    if (typeof value.toString !== "function") {
        return true;
    }
    if (Object.prototype.hasOwnProperty.call(value, "toString")) {
        return false;
    }
    let pointer = value;
    do {
        pointer = Object.getPrototypeOf(pointer);
    }while (!Object.prototype.hasOwnProperty.call(pointer, "toString"))
    const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
    return descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name);
}
const firstErrorLine1 = (error)=>error.message.split("\n", 1)[0];
let CIRCULAR_ERROR_MESSAGE1;
function tryStringify1(arg) {
    try {
        return JSON.stringify(arg);
    } catch (err) {
        if (!CIRCULAR_ERROR_MESSAGE1) {
            try {
                const a = {};
                a.a = a;
                JSON.stringify(a);
            } catch (circularError) {
                CIRCULAR_ERROR_MESSAGE1 = firstErrorLine1(circularError);
            }
        }
        if (err.name === "TypeError" && firstErrorLine1(err) === CIRCULAR_ERROR_MESSAGE1) {
            return "[Circular]";
        }
        throw err;
    }
}
function format8(...args) {
    return formatWithOptionsInternal1(undefined, args);
}
function formatWithOptions1(inspectOptions, ...args) {
    if (typeof inspectOptions !== "object" || inspectOptions === null) {
        throw new codes3.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
    }
    return formatWithOptionsInternal1(inspectOptions, args);
}
function formatNumberNoColor1(number, options) {
    return formatNumber2(stylizeNoColor2, number, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatBigIntNoColor1(bigint, options) {
    return formatBigInt2(stylizeNoColor2, bigint, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatWithOptionsInternal1(inspectOptions, args) {
    const first = args[0];
    let a = 0;
    let str = "";
    let join = "";
    if (typeof first === "string") {
        if (args.length === 1) {
            return first;
        }
        let tempStr;
        let lastPos = 0;
        for(let i = 0; i < first.length - 1; i++){
            if (first.charCodeAt(i) === 37) {
                const nextChar = first.charCodeAt(++i);
                if (a + 1 !== args.length) {
                    switch(nextChar){
                        case 115:
                            const tempArg = args[++a];
                            if (typeof tempArg === "number") {
                                tempStr = formatNumberNoColor1(tempArg, inspectOptions);
                            } else if (typeof tempArg === "bigint") {
                                tempStr = formatBigIntNoColor1(tempArg, inspectOptions);
                            } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString1(tempArg)) {
                                tempStr = String(tempArg);
                            } else {
                                tempStr = inspect3(tempArg, {
                                    ...inspectOptions,
                                    compact: 3,
                                    colors: false,
                                    depth: 0
                                });
                            }
                            break;
                        case 106:
                            tempStr = tryStringify1(args[++a]);
                            break;
                        case 100:
                            const tempNum = args[++a];
                            if (typeof tempNum === "bigint") {
                                tempStr = formatBigIntNoColor1(tempNum, inspectOptions);
                            } else if (typeof tempNum === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor1(Number(tempNum), inspectOptions);
                            }
                            break;
                        case 79:
                            tempStr = inspect3(args[++a], inspectOptions);
                            break;
                        case 111:
                            tempStr = inspect3(args[++a], {
                                ...inspectOptions,
                                showHidden: true,
                                showProxy: true,
                                depth: 4
                            });
                            break;
                        case 105:
                            const tempInteger = args[++a];
                            if (typeof tempInteger === "bigint") {
                                tempStr = formatBigIntNoColor1(tempInteger, inspectOptions);
                            } else if (typeof tempInteger === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor1(Number.parseInt(tempInteger), inspectOptions);
                            }
                            break;
                        case 102:
                            const tempFloat = args[++a];
                            if (typeof tempFloat === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor1(Number.parseFloat(tempFloat), inspectOptions);
                            }
                            break;
                        case 99:
                            a += 1;
                            tempStr = "";
                            break;
                        case 37:
                            str += first.slice(lastPos, i);
                            lastPos = i + 1;
                            continue;
                        default:
                            continue;
                    }
                    if (lastPos !== i - 1) {
                        str += first.slice(lastPos, i - 1);
                    }
                    str += tempStr;
                    lastPos = i + 1;
                } else if (nextChar === 37) {
                    str += first.slice(lastPos, i);
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos !== 0) {
            a++;
            join = " ";
            if (lastPos < first.length) {
                str += first.slice(lastPos);
            }
        }
    }
    while(a < args.length){
        const value = args[a];
        str += join;
        str += typeof value !== "string" ? inspect3(value, inspectOptions) : value;
        join = " ";
        a++;
    }
    return str;
}
function stripVTControlCharacters2(str) {
    validateString2(str, "str");
    return str.replace(ansi2, "");
}
let debugImpls2;
let testEnabled2;
function initializeDebugEnv2(debugEnv) {
    debugImpls2 = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled2 = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled2 = ()=>false;
    }
}
function emitWarningIfNeeded2(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop2 = ()=>{};
function debuglogImpl2(enabled, set) {
    if (debugImpls2[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded2(set);
            debugImpls2[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect3(arg)).join(" ");
                console.error(sprintf2("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls2[set] = noop2;
        }
    }
    return debugImpls2[set];
}
function debuglog2(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled2(set);
    }
    let debug = (...args)=>{
        init();
        debug = debuglogImpl2(enabled, set);
        if (typeof cb === "function") {
            cb(debug);
        }
        return debug(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled;
        return enabled;
    };
    const logger = (...args)=>debug(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv2;
try {
    debugEnv2 = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error2) {
    if (error2 instanceof Deno.errors.PermissionDenied) {
        debugEnv2 = "";
    } else {
        throw error2;
    }
}
initializeDebugEnv2(debugEnv2);
const osType2 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows2 = osType2 === "windows";
const os2 = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
os2.errno.EEXIST;
os2.errno.ENOENT;
const codeToErrorWindows2 = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows2 = codeToErrorWindows2.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin2 = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin2 = codeToErrorDarwin2.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux2 = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux2 = codeToErrorLinux2.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap2 = new Map(osType2 === "windows" ? codeToErrorWindows2 : osType2 === "darwin" ? codeToErrorDarwin2 : osType2 === "linux" ? codeToErrorLinux2 : unreachable2());
const codeMap2 = new Map(osType2 === "windows" ? errorToCodeWindows2 : osType2 === "darwin" ? errorToCodeDarwin2 : osType2 === "linux" ? errorToCodeLinux2 : unreachable2());
codeMap2.get("EAI_MEMORY");
codeMap2.get("UNKNOWN");
codeMap2.get("EBADF");
codeMap2.get("EINVAL");
codeMap2.get("ENOTSOCK");
const __default20 = {
    ...mod110
};
var Encodings3;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings3 || (Encodings3 = {}));
const encodings3 = [];
encodings3[Encodings3.ASCII] = "ascii";
encodings3[Encodings3.BASE64] = "base64";
encodings3[Encodings3.BASE64URL] = "base64url";
encodings3[Encodings3.BUFFER] = "buffer";
encodings3[Encodings3.HEX] = "hex";
encodings3[Encodings3.LATIN1] = "latin1";
encodings3[Encodings3.UCS2] = "utf16le";
encodings3[Encodings3.UTF8] = "utf8";
function numberToBytes3(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex3(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer3(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings3[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex3(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle3(targetBuffer, buffer, byteOffset);
}
function indexOfNumber3(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes3(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer3(targetBuffer, numberToBytes3(number), byteOffset, Encodings3.UTF8, forwardDirection);
}
const base64abc3 = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode7(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc3[uint8[i - 2] >> 2];
        result += base64abc3[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc3[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc3[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc3[uint8[i - 2] >> 2];
        result += base64abc3[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc3[uint8[i - 2] >> 2];
        result += base64abc3[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc3[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode6(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url3(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase643(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url3(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url3(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode8(data) {
    return convertBase64ToBase64url3(encode7(data));
}
function decode7(b64url) {
    return decode6(convertBase64urlToBase643(b64url));
}
function asciiToBytes3(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes3(str) {
    str = base64clean3(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode6(str);
}
const INVALID_BASE64_RE3 = /[^+/0-9A-Za-z-_]/g;
function base64clean3(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE3, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes3(str) {
    str = base64clean3(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode7(str);
}
function hexToBytes3(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes3(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii3(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le3(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder3 = new TextEncoder();
const float32Array3 = new Float32Array(1);
const uInt8Float32Array3 = new Uint8Array(float32Array3.buffer);
const float64Array3 = new Float64Array(1);
const uInt8Float64Array3 = new Uint8Array(float64Array3.buffer);
float32Array3[0] = -1;
const bigEndian3 = uInt8Float32Array3[3] === 0;
function readUInt48LE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE3(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE3(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards3(buffer, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buffer.length - 8);
    }
    uInt8Float64Array3[7] = first;
    uInt8Float64Array3[6] = buffer[++offset];
    uInt8Float64Array3[5] = buffer[++offset];
    uInt8Float64Array3[4] = buffer[++offset];
    uInt8Float64Array3[3] = buffer[++offset];
    uInt8Float64Array3[2] = buffer[++offset];
    uInt8Float64Array3[1] = buffer[++offset];
    uInt8Float64Array3[0] = last;
    return float64Array3[0];
}
function readDoubleForwards3(buffer, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buffer.length - 8);
    }
    uInt8Float64Array3[0] = first;
    uInt8Float64Array3[1] = buffer[++offset];
    uInt8Float64Array3[2] = buffer[++offset];
    uInt8Float64Array3[3] = buffer[++offset];
    uInt8Float64Array3[4] = buffer[++offset];
    uInt8Float64Array3[5] = buffer[++offset];
    uInt8Float64Array3[6] = buffer[++offset];
    uInt8Float64Array3[7] = last;
    return float64Array3[0];
}
function writeDoubleForwards3(buffer, val, offset = 0) {
    val = +val;
    checkBounds6(buffer, offset, 7);
    float64Array3[0] = val;
    buffer[offset++] = uInt8Float64Array3[0];
    buffer[offset++] = uInt8Float64Array3[1];
    buffer[offset++] = uInt8Float64Array3[2];
    buffer[offset++] = uInt8Float64Array3[3];
    buffer[offset++] = uInt8Float64Array3[4];
    buffer[offset++] = uInt8Float64Array3[5];
    buffer[offset++] = uInt8Float64Array3[6];
    buffer[offset++] = uInt8Float64Array3[7];
    return offset;
}
function writeDoubleBackwards3(buffer, val, offset = 0) {
    val = +val;
    checkBounds6(buffer, offset, 7);
    float64Array3[0] = val;
    buffer[offset++] = uInt8Float64Array3[7];
    buffer[offset++] = uInt8Float64Array3[6];
    buffer[offset++] = uInt8Float64Array3[5];
    buffer[offset++] = uInt8Float64Array3[4];
    buffer[offset++] = uInt8Float64Array3[3];
    buffer[offset++] = uInt8Float64Array3[2];
    buffer[offset++] = uInt8Float64Array3[1];
    buffer[offset++] = uInt8Float64Array3[0];
    return offset;
}
function readFloatBackwards3(buffer, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buffer.length - 4);
    }
    uInt8Float32Array3[3] = first;
    uInt8Float32Array3[2] = buffer[++offset];
    uInt8Float32Array3[1] = buffer[++offset];
    uInt8Float32Array3[0] = last;
    return float32Array3[0];
}
function readFloatForwards3(buffer, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buffer.length - 4);
    }
    uInt8Float32Array3[0] = first;
    uInt8Float32Array3[1] = buffer[++offset];
    uInt8Float32Array3[2] = buffer[++offset];
    uInt8Float32Array3[3] = last;
    return float32Array3[0];
}
function writeFloatForwards3(buffer, val, offset = 0) {
    val = +val;
    checkBounds6(buffer, offset, 3);
    float32Array3[0] = val;
    buffer[offset++] = uInt8Float32Array3[0];
    buffer[offset++] = uInt8Float32Array3[1];
    buffer[offset++] = uInt8Float32Array3[2];
    buffer[offset++] = uInt8Float32Array3[3];
    return offset;
}
function writeFloatBackwards3(buffer, val, offset = 0) {
    val = +val;
    checkBounds6(buffer, offset, 3);
    float32Array3[0] = val;
    buffer[offset++] = uInt8Float32Array3[3];
    buffer[offset++] = uInt8Float32Array3[2];
    buffer[offset++] = uInt8Float32Array3[1];
    buffer[offset++] = uInt8Float32Array3[0];
    return offset;
}
function readInt24LE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE3(buf, offset = 0) {
    validateNumber3(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError3(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf83(str) {
    return utf8Encoder3.encode(str).length;
}
function base64ByteLength3(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap3 = Object.create(null);
for(let i12 = 0; i12 < encodings3.length; ++i12){
    encodingsMap3[encodings3[i12]] = i12;
}
const encodingOps3 = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap3.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength3(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap3.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, base64ToBytes3(val), byteOffset, encodingsMap3.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength3(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap3.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, base64UrlToBytes3(val), byteOffset, encodingsMap3.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap3.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, hexToBytes3(val), byteOffset, encodingsMap3.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap3.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap3.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf83,
        encoding: "utf8",
        encodingVal: encodingsMap3.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, utf8Encoder3.encode(val), byteOffset, encodingsMap3.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap3.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps3(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps3.utf8;
            if (encoding === "ucs2") return encodingOps3.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps3.utf8;
            if (encoding === "ascii") return encodingOps3.ascii;
            if (encoding === "ucs-2") return encodingOps3.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps3.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps3.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps3.latin1;
            }
            if (encoding === "base64") return encodingOps3.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps3.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps3.base64url;
            }
            break;
    }
}
function _copyActual3(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError3(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber3(value, type);
        throw new codes3.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes3.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber3(value, name) {
    if (typeof value !== "number") {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds6(buf, offset, byteLength) {
    validateNumber3(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError3(offset, buf.length - (byteLength + 1));
    }
}
function checkInt3(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds6(buf, offset, byteLength);
}
function toInteger3(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int83(buf, value, offset, min, max) {
    value = +value;
    validateNumber3(offset, "offset");
    if (value > max || value < min) {
        throw new codes3.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError3(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset3(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE3(buf, value, offset, min, max) {
    value = +value;
    checkInt3(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength3 = 2147483647;
const MAX_UINT323 = 2 ** 32;
const customInspectSymbol6 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES3 = 50;
Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer3.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer3.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer3(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
}
function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes3.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe3(arg);
    }
    return _from5(arg, encodingOrOffset, length);
}
Buffer3.poolSize = 8192;
function _from5(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer7(value)) {
            return fromArrayBuffer3(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from5(valueOf, encodingOrOffset, length);
        }
        const b = fromObject3(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString3(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes3.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer3.from = function from(value, encodingOrOffset, length) {
    return _from5(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer3, Uint8Array);
function assertSize4(size) {
    validateNumber3(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes3.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc3(size, fill, encoding) {
    assertSize4(size);
    const buffer = createBuffer3(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes3.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer3.alloc = function alloc(size, fill, encoding) {
    return _alloc3(size, fill, encoding);
};
function _allocUnsafe3(size) {
    assertSize4(size);
    return createBuffer3(size < 0 ? 0 : checked3(size) | 0);
}
Buffer3.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe3(size);
};
Buffer3.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe3(size);
};
function fromString3(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
        throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength5(string, encoding) | 0;
    let buf = createBuffer3(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike3(array) {
    const length = array.length < 0 ? 0 : checked3(array.length) | 0;
    const buf = createBuffer3(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject3(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer7(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer3(0);
        }
        return fromArrayLike3(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike3(obj.data);
    }
}
function checked3(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer3(length) {
    assertSize4(length);
    return Buffer3.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer3, Uint8Array);
Buffer3.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer3.prototype;
};
Buffer3.compare = function compare(a, b) {
    if (isInstance3(a, Uint8Array)) {
        a = Buffer3.from(a, a.offset, a.byteLength);
    }
    if (isInstance3(b, Uint8Array)) {
        b = Buffer3.from(b, b.offset, b.byteLength);
    }
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer3.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding7(encoding) !== undefined;
};
Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes3.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer3.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset3(length, "length");
    }
    const buffer = Buffer3.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array3(buf)) {
            throw new codes3.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual3(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength5(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView3(string) || isAnyArrayBuffer7(string)) {
            return string.byteLength;
        }
        throw new codes3.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf83(string);
    }
    const ops = getEncodingOps3(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf83(string);
    }
    return ops.byteLength(string);
}
Buffer3.byteLength = byteLength5;
Buffer3.prototype._isBuffer = true;
function swap3(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap3(this, i, i + 1);
    }
    return this;
};
Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap3(this, i, i + 3);
        swap3(this, i + 1, i + 2);
    }
    return this;
};
Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap3(this, i, i + 7);
        swap3(this, i + 1, i + 6);
        swap3(this, i + 2, i + 5);
        swap3(this, i + 3, i + 4);
    }
    return this;
};
Buffer3.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps3(encoding);
    if (ops === undefined) {
        throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
Buffer3.prototype.equals = function equals(b) {
    if (!isUint8Array3(b)) {
        throw new codes3.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer3.compare(this, b) === 0;
};
Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES3;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol6) {
    Buffer3.prototype[customInspectSymbol6] = Buffer3.prototype.inspect;
}
Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance3(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
        throw new codes3.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset3(start, "targetStart", 0, kMaxLength3);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset3(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset3(start, "sourceStart", 0, kMaxLength3);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset3(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes3.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
    validateBuffer3(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber3(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps3.utf8;
    } else {
        ops = getEncodingOps3(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array3(val)) {
        const encodingVal = ops === undefined ? encodingsMap3.utf8 : ops.encodingVal;
        return indexOfBuffer3(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes3.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
Buffer3.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii3(this);
    } else {
        return bytesToAscii3(this.slice(offset, length));
    }
};
Buffer3.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer3.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode7(this);
    } else {
        return encode7(this.slice(offset, length));
    }
};
Buffer3.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer3(base64ToBytes3(string), this, offset, length);
};
Buffer3.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode8(this);
    } else {
        return encode8(this.slice(offset, length));
    }
};
Buffer3.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer3(base64UrlToBytes3(string), this, offset, length);
};
Buffer3.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer3(hexToBytes3(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice3(this, string, offset, length);
};
Buffer3.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice3(this, string, offset, length);
};
Buffer3.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer3.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le3(this);
    } else {
        return bytesToUtf16le3(this.slice(offset, length));
    }
};
Buffer3.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer3(utf16leToBytes3(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice3(this, string, offset, length);
};
Buffer3.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer3(utf8ToBytes3(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset3(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset3(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps3(encoding);
    if (ops === undefined) {
        throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer3.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer3(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer3.prototype);
    return buffer;
}
function _utf8Slice3(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray3(res);
}
const MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
    }
    return res;
}
function _latin1Slice3(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice3(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable3[buf[i]];
    }
    return out;
}
Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
};
Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE3(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE3(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE3(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE3(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE3(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE3(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber3(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError3(offset, this.length - 1);
    }
    return val;
};
Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = readUInt16BE3;
Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = readUInt32BE3;
Buffer3.prototype.readBigUint64LE = Buffer3.prototype.readBigUInt64LE = defineBigIntMethod3(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError3(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer3.prototype.readBigUint64BE = Buffer3.prototype.readBigUInt64BE = defineBigIntMethod3(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError3(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE3(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE3(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE3(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE3(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE3(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE3(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber3(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError3(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer3.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer3.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer3.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer3.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError3(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer3.prototype.readBigInt64LE = defineBigIntMethod3(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError3(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer3.prototype.readBigInt64BE = defineBigIntMethod3(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber3(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError3(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer3.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian3 ? readFloatBackwards3(this, offset) : readFloatForwards3(this, offset);
};
Buffer3.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian3 ? readFloatForwards3(this, offset) : readFloatBackwards3(this, offset);
};
Buffer3.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian3 ? readDoubleBackwards3(this, offset) : readDoubleForwards3(this, offset);
};
Buffer3.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian3 ? readDoubleForwards3(this, offset) : readDoubleBackwards3(this, offset);
};
Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE3(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE3(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE3(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE3(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE3(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int83(this, value, offset, 0, 0xff);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE3(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE3(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE3(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE3(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE3(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int83(this, value, offset, 0, 0xff);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int83(this, value, offset, 0, 0xff);
};
Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE3(this, value, offset, 0, 0xffff);
};
Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE3(this, value, offset, 0, 0xffff);
};
Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE3(this, value, offset, 0, 0xffffffff);
};
Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE3(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE3(buf, value, offset, min, max) {
    checkIntBI3(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE3(buf, value, offset, min, max) {
    checkIntBI3(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer3.prototype.writeBigUint64LE = Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod3(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeBigUint64BE = Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod3(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE3(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE3(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE3(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE3(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE3(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int83(this, value, offset, -0x80, 0x7f);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE3(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE3(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE3(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE3(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE3(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int83(this, value, offset, -0x80, 0x7f);
    }
    boundsError3(byteLength, 6, "byteLength");
};
Buffer3.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int83(this, value, offset, -0x80, 0x7f);
};
Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE3(this, value, offset, -0x8000, 0x7fff);
};
Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE3(this, value, offset, -0x8000, 0x7fff);
};
Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE3(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE3(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer3.prototype.writeBigInt64LE = defineBigIntMethod3(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeBigInt64BE = defineBigIntMethod3(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian3 ? writeFloatBackwards3(this, value, offset) : writeFloatForwards3(this, value, offset);
};
Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian3 ? writeFloatForwards3(this, value, offset) : writeFloatBackwards3(this, value, offset);
};
Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian3 ? writeDoubleBackwards3(this, value, offset) : writeDoubleForwards3(this, value, offset);
};
Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian3 ? writeDoubleForwards3(this, value, offset) : writeDoubleBackwards3(this, value, offset);
};
Buffer3.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array3(this)) {
        throw new codes3.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array3(target)) {
        throw new codes3.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger3(targetStart, 0);
        if (targetStart < 0) {
            throw new codes3.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger3(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes3.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT323) {
            throw new codes3.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT323}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger3(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT323) {
            throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT323}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes3.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds7(buf, offset, byteLength2) {
    validateNumber3(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError3(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI3(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds7(buf, offset, byteLength2);
}
function utf8ToBytes3(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer3(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance3(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable3 = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod3(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined3 : fn;
}
function BufferBigIntNotDefined3() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType2;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType2 || (valueType2 = {}));
let memo2;
function isDeepStrictEqual1(val1, val2) {
    return innerDeepEqual2(val1, val2, true);
}
function innerDeepEqual2(val1, val2, strict, memos = memo2) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties2(val1, filter);
        const keys2 = getOwnNonIndexProperties2(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck2(val1, val2, strict, memos, valueType2.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck2(val1, val2, strict, memos, valueType2.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps2(val1, val2)) {
            return false;
        }
    } else if (isNativeError7(val1) || val1 instanceof Error) {
        if (!isNativeError7(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView3(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray2(val1) && isTypedArray2(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array2(val1) || isFloat64Array2(val1))) {
            if (!areSimilarFloatArrays2(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays2(val1, val2)) {
            return false;
        }
        const filter1 = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties2(val1, filter1);
        const keysVal2 = getOwnNonIndexProperties2(val2, filter1);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck2(val1, val2, strict, memos, valueType2.noIterator, keysVal1);
    } else if (isSet7(val1)) {
        if (!isSet7(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck2(val1, val2, strict, memos, valueType2.isSet);
    } else if (isMap7(val1)) {
        if (!isMap7(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck2(val1, val2, strict, memos, valueType2.isMap);
    } else if (isAnyArrayBuffer7(val1)) {
        if (!isAnyArrayBuffer7(val2) || !areEqualArrayBuffers2(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive7(val1)) {
        if (!isEqualBoxedPrimitive2(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView3(val2) || isSet7(val2) || isMap7(val2) || isDate8(val2) || isRegExp8(val2) || isAnyArrayBuffer7(val2) || isBoxedPrimitive7(val2) || isNativeError7(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck2(val1, val2, strict, memos, valueType2.noIterator);
}
function keyCheck2(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i = 0;
    for(; i < aKeys.length; i++){
        if (!val2.propertyIsEnumerable(aKeys[i])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                const key = symbolKeysA[i];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables2(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB1.length !== 0 && getEnumerables2(val2, symbolKeysB1).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType2.noIterator || iterationType === valueType2.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv2(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps2(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays2(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i = 0; i < arr1.byteLength; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays2(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer3.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers2(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer3.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive2(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject7(a)) {
        return isNumberObject7(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject7(a)) {
        return isStringObject7(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject7(a)) {
        return isBooleanObject7(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject7(a)) {
        return isBigIntObject7(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject7(a)) {
        return isSymbolObject7(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables2(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv2(obj1, obj2, strict, keys, memos, iterationType) {
    let i = 0;
    if (iterationType === valueType2.isSet) {
        if (!setEquiv2(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType2.isMap) {
        if (!mapEquiv2(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType2.isArray) {
        for(; i < obj1.length; i++){
            if (obj1.hasOwnProperty(i)) {
                if (!obj2.hasOwnProperty(i) || !innerDeepEqual2(obj1[i], obj2[i], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i < keys1.length; i++){
                    const key = keys1[i];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual2(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i = 0; i < keys.length; i++){
        const key1 = keys[i];
        if (!innerDeepEqual2(obj1[key1], obj2[key1], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives2(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim2(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives2(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement2(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual2(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv2(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim2(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item1 of set2){
            if (typeof item1 === "object" && item1 !== null) {
                if (!setHasEqualElement2(set, item1, strict, memos)) return false;
            } else if (!strict && !set1.has(item1) && !setHasEqualElement2(set, item1, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive2(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives2(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual2(item, curB, false, memo2)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual2(item, curB, false, memos);
}
function mapEquiv2(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual2(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive2(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key1 , 1: item  } of map2){
            if (typeof key1 === "object" && key1 !== null) {
                if (!mapHasEqualEntry2(set, map1, key1, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key1) || !innerDeepEqual2(map1.get(key1), item, false, memos)) && !mapHasEqualEntry2(set, map1, key1, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry2(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual2(key1, key2, strict, memos) && innerDeepEqual2(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger2 = Number.isSafeInteger;
function isArray1(value) {
    return Array.isArray(value);
}
function isBoolean1(value) {
    return typeof value === "boolean" || value instanceof Boolean;
}
function isNull1(value) {
    return value === null;
}
function isNullOrUndefined1(value) {
    return value === null || value === undefined;
}
function isNumber3(value) {
    return typeof value === "number" || value instanceof Number;
}
function isString1(value) {
    return typeof value === "string" || value instanceof String;
}
function isSymbol1(value) {
    return typeof value === "symbol";
}
function isUndefined1(value) {
    return value === undefined;
}
function isObject1(value) {
    return value !== null && typeof value === "object";
}
function isError1(e) {
    return e instanceof Error;
}
function isFunction1(value) {
    return typeof value === "function";
}
function isRegExp9(value) {
    return __default20.isRegExp(value);
}
function isDate9(value) {
    return __default20.isDate(value);
}
function isPrimitive1(value) {
    return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer1(value) {
    return Buffer3.isBuffer(value);
}
function _extend1(target, source) {
    if (source === null || typeof source !== "object") return target;
    const keys = Object.keys(source);
    let i = keys.length;
    while(i--){
        target[keys[i]] = source[keys[i]];
    }
    return target;
}
function getSystemErrorName2(code) {
    if (typeof code !== "number") {
        throw new codes3.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger2(code)) {
        throw new codes3.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap2.get(code)?.[0];
}
function inherits2(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new codes3.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
    }
    if (superCtor === undefined || superCtor === null) {
        throw new codes3.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
    }
    if (superCtor.prototype === undefined) {
        throw new codes3.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
    }
    Object.defineProperty(ctor, "super_", {
        value: superCtor,
        writable: true,
        configurable: true
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad1(n) {
    return n.toString().padStart(2, "0");
}
const months1 = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec", 
];
function timestamp1() {
    const d = new Date();
    const t = [
        pad1(d.getHours()),
        pad1(d.getMinutes()),
        pad1(d.getSeconds()), 
    ].join(":");
    return `${d.getDate()} ${months1[d.getMonth()]} ${t}`;
}
function log1(...args) {
    console.log("%s - %s", timestamp1(), format8(...args));
}
const __default21 = {
    format: format8,
    formatWithOptions: formatWithOptions1,
    inspect: inspect3,
    isArray: isArray1,
    isBoolean: isBoolean1,
    isNull: isNull1,
    isNullOrUndefined: isNullOrUndefined1,
    isNumber: isNumber3,
    isString: isString1,
    isSymbol: isSymbol1,
    isUndefined: isUndefined1,
    isObject: isObject1,
    isError: isError1,
    isFunction: isFunction1,
    isRegExp: isRegExp9,
    isDate: isDate9,
    isPrimitive: isPrimitive1,
    isBuffer: isBuffer1,
    _extend: _extend1,
    getSystemErrorName: getSystemErrorName2,
    deprecate: deprecate1,
    callbackify: callbackify1,
    promisify: promisify3,
    inherits: inherits2,
    types: __default20,
    stripVTControlCharacters: stripVTControlCharacters2,
    TextDecoder: _TextDecoder1,
    TextEncoder: _TextEncoder1,
    log: log1,
    debuglog: debuglog2,
    isDeepStrictEqual: isDeepStrictEqual1
};
const { errno: { ENOTDIR: ENOTDIR2 , ENOENT: ENOENT2  } ,  } = os2;
const kIsNodeError2 = Symbol("kIsNodeError");
const classRegExp5 = /^([A-Z][a-z0-9]*)+$/;
const kTypes2 = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
function addNumericalSeparator2(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace2 = hideStackFrames3(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames3(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet2(err) || uvUnmappedError2;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace2(ex);
});
hideStackFrames3(function errnoException(err, syscall, original) {
    const code = getSystemErrorName2(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace2(ex);
});
function uvErrmapGet2(name) {
    return errorMap2.get(name);
}
const uvUnmappedError2 = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames3(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet2(ctx.errno) || uvUnmappedError2;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace2(err);
});
hideStackFrames3(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName2(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace2(ex);
});
hideStackFrames3(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap2.get("EAI_NODATA") || code === codeMap2.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName2(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace2(ex);
});
class NodeErrorAbstraction2 extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError2 extends NodeErrorAbstraction2 {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError2 extends NodeErrorAbstraction2 {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError2 extends NodeErrorAbstraction2 {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction2 {
    constructor(code, message){
        super(URIError.prototype.name, code, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError2 extends NodeErrorAbstraction2 {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace2(this);
        Object.defineProperties(this, {
            [kIsNodeError2]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode2(key, msgPrfix) {
    return class NodeError extends NodeSystemError2 {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode2("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType2(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes2.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp5.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last1 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last1}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE2 extends NodeRangeError2 {
    constructor(name, expected, actual){
        const msg = createInvalidArgType2(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE2 extends NodeTypeError2 {
    constructor(name, expected, actual){
        const msg = createInvalidArgType2(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE2;
}
class ERR_INVALID_ARG_VALUE_RANGE2 extends NodeRangeError2 {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect3(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE2 extends NodeTypeError2 {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect3(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE2;
}
function invalidArgTypeHelper2(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect3(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect3(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE2 extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert4(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator2(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator2(received);
            }
            received += "n";
        } else {
            received = inspect3(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS2 extends NodeRangeError2 {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CALLBACK2 extends NodeTypeError2 {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect3(object)}`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED2 extends NodeError2 {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_SOCKET_BAD_PORT2 extends NodeRangeError2 {
    constructor(name, port, allowZero = true){
        assert4(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_UNKNOWN_ENCODING2 extends NodeTypeError2 {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
codes3.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED2;
codes3.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE2;
codes3.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE2;
codes3.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK2;
codes3.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE2;
codes3.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT2;
codes3.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS2;
codes3.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING2;
hideStackFrames3(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
const CHAR_FORWARD_SLASH2 = 47;
const CHAR_FORWARD_SLASH3 = 47;
function assertPath2(path) {
    if (typeof path !== "string") {
        throw new ERR_INVALID_ARG_TYPE2("path", [
            "string"
        ], path);
    }
}
function isPosixPathSeparator2(code) {
    return code === 47;
}
function isPathSeparator2(code) {
    return isPosixPathSeparator2(code) || code === 92;
}
function isWindowsDeviceRoot2(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString2(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH3;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS2 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace2(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS2[c] ?? c;
    });
}
const sep6 = "\\";
const delimiter6 = ";";
function resolve6(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath2(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator2(code)) {
                isAbsolute = true;
                if (isPathSeparator2(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator2(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot2(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator2(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator2(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize8(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            isAbsolute = true;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString2(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator2);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator2(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator2(code)) {
        return true;
    } else if (isWindowsDeviceRoot2(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator2(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join11(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert4(firstPart != null);
    if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator2(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize8(joined);
}
function relative6(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    const fromOrig = resolve6(from);
    const toOrig = resolve6(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath6(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve6(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator2(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename6(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE2("ext", [
            "string"
        ], ext);
    }
    assertPath2(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator2(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator2(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname6(path) {
    assertPath2(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format9(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE2("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("\\", pathObject);
}
function parse8(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl6(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl6(path) {
    if (!isAbsolute6(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default22 = {
    basename: basename6,
    delimiter: delimiter6,
    dirname: dirname6,
    extname: extname6,
    format: format9,
    fromFileUrl: fromFileUrl6,
    isAbsolute: isAbsolute6,
    join: join11,
    normalize: normalize8,
    parse: parse8,
    relative: relative6,
    resolve: resolve6,
    sep: sep6,
    toFileUrl: toFileUrl6,
    toNamespacedPath: toNamespacedPath6
};
const mod111 = {
    sep: sep6,
    delimiter: delimiter6,
    resolve: resolve6,
    normalize: normalize8,
    isAbsolute: isAbsolute6,
    join: join11,
    relative: relative6,
    toNamespacedPath: toNamespacedPath6,
    dirname: dirname6,
    basename: basename6,
    extname: extname6,
    format: format9,
    parse: parse8,
    fromFileUrl: fromFileUrl6,
    toFileUrl: toFileUrl6,
    default: __default22
};
const sep7 = "/";
const delimiter7 = ":";
function resolve7(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath2(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH3;
    }
    resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize9(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString2(path, !isAbsolute, "/", isPosixPathSeparator2);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute7(path) {
    assertPath2(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join12(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize9(joined);
}
function relative7(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    from = resolve7(from);
    to = resolve7(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath7(path) {
    return path;
}
function dirname7(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename7(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE2("ext", [
            "string"
        ], ext);
    }
    assertPath2(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname7(path) {
    assertPath2(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format10(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE2("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("/", pathObject);
}
function parse9(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl7(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl7(path) {
    if (!isAbsolute7(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default23 = {
    basename: basename7,
    delimiter: delimiter7,
    dirname: dirname7,
    extname: extname7,
    format: format10,
    fromFileUrl: fromFileUrl7,
    isAbsolute: isAbsolute7,
    join: join12,
    normalize: normalize9,
    parse: parse9,
    relative: relative7,
    resolve: resolve7,
    sep: sep7,
    toFileUrl: toFileUrl7,
    toNamespacedPath: toNamespacedPath7
};
const mod112 = {
    sep: sep7,
    delimiter: delimiter7,
    resolve: resolve7,
    normalize: normalize9,
    isAbsolute: isAbsolute7,
    join: join12,
    relative: relative7,
    toNamespacedPath: toNamespacedPath7,
    dirname: dirname7,
    basename: basename7,
    extname: extname7,
    format: format10,
    parse: parse9,
    fromFileUrl: fromFileUrl7,
    toFileUrl: toFileUrl7,
    default: __default23
};
const path4 = isWindows2 ? mod111 : mod112;
const { join: join13 , normalize: normalize10  } = path4;
const path5 = isWindows2 ? __default22 : __default23;
const { basename: basename8 , delimiter: delimiter8 , dirname: dirname8 , extname: extname8 , format: format11 , fromFileUrl: fromFileUrl8 , isAbsolute: isAbsolute8 , join: join14 , normalize: normalize11 , parse: parse10 , relative: relative8 , resolve: resolve8 , sep: sep8 , toFileUrl: toFileUrl8 , toNamespacedPath: toNamespacedPath8 ,  } = path5;
"use strict";
const base1 = 36;
const damp = 700;
const delimiter9 = "-";
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin = 36 - 1;
function error3(type) {
    throw new RangeError(errors[type]);
}
function mapDomain(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k += base1){
        delta = Math.floor(delta / baseMinusTMin);
    }
    return Math.floor(k + (baseMinusTMin + 1) * delta / (delta + 38));
}
function encode9(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter9);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue1 of input){
            if (currentValue1 >= n && currentValue1 < m) {
                m = currentValue1;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error3("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue2 of input){
            if (currentValue2 < n && ++delta > 2147483647) {
                error3("overflow");
            }
            if (currentValue2 == n) {
                let q = delta;
                for(let k = 36;; k += base1){
                    const t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = 36 - t;
                    output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join("");
}
function toASCII(input) {
    return mapDomain(input, function(str) {
        return regexNonASCII.test(str) ? "xn--" + encode9(str) : str;
    });
}
const hexTable1 = new Array(256);
for(let i13 = 0; i13 < 256; ++i13){
    hexTable1[i13] = "%" + ((i13 < 16 ? "0" : "") + i13.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i = 0; i < len; i++){
        let c = str.charCodeAt(i);
        if (c < 0x80) {
            if (noEscapeTable[c] === 1) continue;
            if (lastPos < i) out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
            continue;
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        if (c < 0x800) {
            lastPos = i + 1;
            out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i + 1;
            out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        ++i;
        if (i >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i) & 0x3ff;
        lastPos = i + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode8 = parse11;
const encode10 = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable1);
}
const escape = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret = new Array(str.length);
    for(let i = 0; i < str.length; ++i){
        ret[i] = str.charCodeAt(i);
    }
    return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode) {
    if (key.length > 0 && keyEncoded) {
        key = decode(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse11(str, sep = "&", eq = "=", { decodeURIComponent: decodeURIComponent1 = unescape , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep ? [
        38
    ] : charCodes(String(sep));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode = unescape;
    if (decodeURIComponent1) {
        decode = decodeURIComponent1;
    }
    const customDecode = decode !== unescape;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i = 0; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (code === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end1 = i - eqIdx + 1;
                        if (lastPos < end1) {
                            key += str.slice(lastPos, end1);
                        }
                        encodeCheck = 0;
                        lastPos = i + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code === 43) {
                    if (lastPos < i) {
                        key += str.slice(lastPos, i);
                    }
                    key += plusChar;
                    lastPos = i + 1;
                    continue;
                }
            }
            if (code === 43) {
                if (lastPos < i) {
                    value += str.slice(lastPos, i);
                }
                value += plusChar;
                lastPos = i + 1;
            } else if (!valEncoded) {
                if (code === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v) {
    if (typeof v === "string") {
        return v;
    }
    if (typeof v === "number" && isFinite(v)) {
        return "" + v;
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v, encode) {
    return encode(stringifyPrimitive(v));
}
function encodeStringified(v, encode) {
    if (typeof v === "string") {
        return v.length ? encode(v) : "";
    }
    if (typeof v === "number" && isFinite(v)) {
        return Math.abs(v) < 1e21 ? "" + v : encode("" + v);
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep, eq, options) {
    sep ||= "&";
    eq ||= "=";
    const encode = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i = 0; i < len; ++i){
            const k = keys[i];
            const v = obj[k];
            let ks = convert(k, encode);
            ks += eq;
            if (Array.isArray(v)) {
                const vlen = v.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep;
                    }
                    fields += ks;
                    fields += convert(v[j], encode);
                }
            } else {
                if (fields) {
                    fields += sep;
                }
                fields += ks;
                fields += convert(v, encode);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
    const out = new Buffer3(s.length);
    let index = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s.length - 2;
    let hasHex = false;
    while(index < s.length){
        currentChar = s.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index++;
            continue;
        }
        if (currentChar === 37 && index < maxLength) {
            currentChar = s.charCodeAt(++index);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s.charCodeAt(++index);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
    try {
        return decodeURIComponent(s);
    } catch  {
        return unescapeBuffer(s).toString();
    }
}
const unescape = qsUnescape;
const __default24 = {
    parse: parse11,
    stringify,
    decode: decode8,
    encode: encode10,
    unescape,
    escape,
    unescapeBuffer
};
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:", 
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
URL;
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
     #parseHost() {
        let host = this.host || "";
        let port6 = portPattern.exec(host);
        if (port6) {
            port6 = port6[0];
            if (port6 !== ":") {
                this.port = port6.slice(1);
            }
            host = host.slice(0, host.length - port6.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative) {
        return this.resolveObject(parse12(relative, false, true)).format();
    }
    resolveObject(relative) {
        if (typeof relative === "string") {
            const rel = new Url();
            rel.urlParse(relative, false, true);
            relative = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative.slashes && !relative.protocol) {
            const rkeys = Object.keys(relative);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative.protocol)) {
                const keys = Object.keys(relative);
                for(let v = 0; v < keys.length; v++){
                    const k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !/^file:?$/.test(relative.protocol) && !hostlessProtocol.has(relative.protocol)) {
                const relPath = (relative.pathname || "").split("/");
                while(relPath.length && !(relative.host = relPath.shift() || null));
                if (!relative.host) relative.host = "";
                if (!relative.hostname) relative.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
                const p = result.pathname || "";
                const s = result.search || "";
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath1 = relative.pathname && relative.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                result.auth = null;
                if (relative.host) {
                    if (relPath1[0] === "") relPath1[0] = relative.host;
                    else relPath1.unshift(relative.host);
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath1[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative.host || relative.host === "") {
                if (result.host !== relative.host) result.auth = null;
                result.host = relative.host;
                result.port = relative.port;
            }
            if (relative.hostname || relative.hostname === "") {
                if (result.hostname !== relative.hostname) result.auth = null;
                result.hostname = relative.hostname;
            }
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath1;
        } else if (relPath1.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath1);
            result.search = relative.search;
            result.query = relative.query;
        } else if (relative.search !== null && relative.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for(let i = srcPath.length - 1; i >= 0; i--){
            last = srcPath[i];
            if (last === ".") {
                srcPath.splice(i, 1);
            } else if (last === "..") {
                srcPath.splice(i, 1);
                up++;
            } else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost1 = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost1) {
                result.auth = authInHost1.shift() || null;
                result.host = result.hostname = authInHost1.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable1);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default24.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i = 0; i < pathname.length; ++i){
            switch(pathname.charCodeAt(i)){
                case 35:
                    if (i - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i);
                    }
                    newPathname += "%23";
                    lastPos = i + 1;
                    break;
                case 63:
                    if (i - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i);
                    }
                    newPathname += "%3F";
                    lastPos = i + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url, parseQueryString, slashesDenoteHost) {
        let hasHash = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i = 0, inWs = false, split = false; i < url.length; ++i){
            const code = url.charCodeAt(i);
            const isWs = code === 32 || code === 9 || code === 13 || code === 10 || code === 12 || code === 160 || code === 65279;
            if (start === -1) {
                if (isWs) continue;
                lastPos = start = i;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i;
                inWs = true;
            }
            if (!split) {
                switch(code){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i - lastPos > 0) rest += url.slice(lastPos, i);
                        rest += "/";
                        lastPos = i + 1;
                        break;
                }
            } else if (!hasHash && code === 35) {
                hasHash = true;
            }
        }
        if (start !== -1) {
            if (lastPos === start) {
                if (end === -1) {
                    if (start === 0) rest = url;
                    else rest = url.slice(start);
                } else {
                    rest = url.slice(start, end);
                }
            } else if (end === -1 && lastPos < url.length) {
                rest += url.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default24.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
            proto = proto[0];
            lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH2 && rest.charCodeAt(1) === CHAR_FORWARD_SLASH2;
            if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i1 = 0; i1 < rest.length; ++i1){
                switch(rest.charCodeAt(i1)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i1;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i1;
                        hostEnd = i1;
                        break;
                    case 64:
                        atSign = i1;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start);
                rest = "";
            } else {
                this.host = rest.slice(start, nonHost);
                rest = rest.slice(nonHost);
            }
            this.#parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                this.hostname = toASCII(this.hostname);
            }
            const p = this.port ? ":" + this.port : "";
            const h = this.hostname || "";
            this.host = h + p;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i2 = 0; i2 < rest.length; ++i2){
            const code1 = rest.charCodeAt(i2);
            if (code1 === 35) {
                this.hash = rest.slice(i2);
                hashIdx = i2;
                break;
            } else if (code1 === 63 && questionIdx === -1) {
                questionIdx = i2;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default24.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p1 = this.pathname || "";
            const s = this.search || "";
            this.path = p1 + s;
        }
        this.href = this.format();
        return this;
    }
}
function isIpv6Hostname(hostname) {
    return hostname.charCodeAt(0) === 91 && hostname.charCodeAt(hostname.length - 1) === 93;
}
function getHostname(self1, rest, hostname) {
    for(let i = 0; i < hostname.length; ++i){
        const code = hostname.charCodeAt(i);
        const isValid = code >= 97 && code <= 122 || code === 46 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 43 || code === 95 || code > 127;
        if (!isValid) {
            self1.hostname = hostname.slice(0, i);
            return `/${hostname.slice(i)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i = 0; i < rest.length; ++i){
        const escapedChar = escapedCodes[rest.charCodeAt(i)];
        if (escapedChar) {
            if (i > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i);
            }
            escaped += escapedChar;
            lastEscapedPos = i + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse12(url, parseQueryString, slashesDenoteHost) {
    if (url instanceof Url) return url;
    const urlObject = new Url();
    urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
    return urlObject;
}
const isCryptoKey3 = (key)=>key instanceof CryptoKey;
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
    const size = buffers.reduce((acc, { length  })=>acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer)=>{
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}
const encodeBase64 = (input)=>{
    let unencoded = input;
    if (typeof unencoded === 'string') {
        unencoded = encoder.encode(unencoded);
    }
    const CHUNK_SIZE = 0x8000;
    const arr = [];
    for(let i = 0; i < unencoded.length; i += CHUNK_SIZE){
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + 0x8000)));
    }
    return btoa(arr.join(''));
};
const encode11 = (input)=>{
    return encodeBase64(input).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};
class JOSEError extends Error {
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
    code = 'ERR_JOSE_GENERIC';
    constructor(message){
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class JOSENotSupported extends JOSEError {
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
    code = 'ERR_JOSE_NOT_SUPPORTED';
}
class JWSInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWS_INVALID';
    }
    code = 'ERR_JWS_INVALID';
}
class JWTInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWT_INVALID';
    }
    code = 'ERR_JWT_INVALID';
}
crypto.getRandomValues.bind(crypto);
function isCloudflareWorkers() {
    return typeof WebSocketPair === 'function';
}
function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
    switch(alg){
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected)=>key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        } else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            {
                if (!isAlgorithm(key.algorithm, 'HMAC')) throw unusable('HMAC');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'RS256':
        case 'RS384':
        case 'RS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5')) throw unusable('RSASSA-PKCS1-v1_5');
                const expected1 = parseInt(alg.slice(2), 10);
                const actual1 = getHashLength(key.algorithm.hash);
                if (actual1 !== expected1) throw unusable(`SHA-${expected1}`, 'algorithm.hash');
                break;
            }
        case 'PS256':
        case 'PS384':
        case 'PS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-PSS')) throw unusable('RSA-PSS');
                const expected2 = parseInt(alg.slice(2), 10);
                const actual2 = getHashLength(key.algorithm.hash);
                if (actual2 !== expected2) throw unusable(`SHA-${expected2}`, 'algorithm.hash');
                break;
            }
        case isCloudflareWorkers() && 'EdDSA':
            {
                if (!isAlgorithm(key.algorithm, 'NODE-ED25519')) throw unusable('NODE-ED25519');
                break;
            }
        case 'ES256':
        case 'ES384':
        case 'ES512':
            {
                if (!isAlgorithm(key.algorithm, 'ECDSA')) throw unusable('ECDSA');
                const expected3 = getNamedCurve(alg);
                const actual3 = key.algorithm.namedCurve;
                if (actual3 !== expected3) throw unusable(expected3, 'algorithm.namedCurve');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
const __default25 = (actual, ...types)=>{
    let msg = 'Key must be ';
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    } else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    } else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    } else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
};
const types = [
    'CryptoKey'
];
const __default26 = (key)=>{
    return isCryptoKey3(key);
};
const isDisjoint = (...headers)=>{
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources){
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters){
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject2(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}
const __default27 = (alg, key)=>{
    if (alg.startsWith('RS') || alg.startsWith('PS')) {
        const { modulusLength  } = key.algorithm;
        if (typeof modulusLength !== 'number' || modulusLength < 2048) {
            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
    }
};
const __default28 = (b64, descriptor)=>{
    const newlined = (b64.match(/.{1,64}/g) || []).join('\n');
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
};
const findOid = (keyData, oid, from = 0)=>{
    if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(0x06);
    }
    let i = keyData.indexOf(oid[0], from);
    if (i === -1) return false;
    const sub = keyData.subarray(i, i + oid.length);
    if (sub.length !== oid.length) return false;
    return sub.every((value, index)=>value === oid[index]) || findOid(keyData, oid, i + 1);
};
const symmetricTypeCheck = (key)=>{
    if (key instanceof Uint8Array) return;
    if (!__default26(key)) {
        throw new TypeError(__default25(key, ...types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (key, usage)=>{
    if (!__default26(key)) {
        throw new TypeError(__default25(key, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage)=>{
    const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(key);
    } else {
        asymmetricTypeCheck(key, usage);
    }
};
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([
            ...Object.entries(recognizedOption),
            ...recognizedDefault.entries()
        ]);
    } else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit){
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
Symbol();
function subtleDsa(alg, algorithm) {
    const hash = `SHA-${alg.slice(-3)}`;
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            return {
                hash,
                name: 'HMAC'
            };
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                hash,
                name: 'RSA-PSS',
                saltLength: alg.slice(-3) >> 3
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                hash,
                name: 'RSASSA-PKCS1-v1_5'
            };
        case 'ES256':
        case 'ES384':
        case 'ES512':
            return {
                hash,
                name: 'ECDSA',
                namedCurve: algorithm.namedCurve
            };
        case isCloudflareWorkers() && 'EdDSA':
            const { namedCurve  } = algorithm;
            return {
                name: namedCurve,
                namedCurve
            };
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
function getCryptoKey(alg, key, usage) {
    if (isCryptoKey3(key)) {
        checkSigCryptoKey(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError(__default25(key, ...types));
        }
        return crypto.subtle.importKey('raw', key, {
            hash: `SHA-${alg.slice(-3)}`,
            name: 'HMAC'
        }, false, [
            usage
        ]);
    }
    throw new TypeError(__default25(key, ...types, 'Uint8Array'));
}
const __default29 = (date)=>Math.floor(date.getTime() / 1000);
const hour = 60 * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
const __default30 = (str)=>{
    const matched = REGEX.exec(str);
    if (!matched) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch(unit){
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            return Math.round(value);
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            return Math.round(value * 60);
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            return Math.round(value * hour);
        case 'day':
        case 'days':
        case 'd':
            return Math.round(value * day);
        case 'week':
        case 'weeks':
        case 'w':
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
};
const sign = async (alg, key, data)=>{
    const cryptoKey = await getCryptoKey(alg, key, 'sign');
    __default27(alg, cryptoKey);
    const signature = await crypto.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
    return new Uint8Array(signature);
};
class FlattenedSign {
    _payload;
    _protectedHeader;
    _unprotectedHeader;
    constructor(payload){
        if (!(payload instanceof Uint8Array)) {
            throw new TypeError('payload must be an instance of Uint8Array');
        }
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
        }
        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {
            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader
        };
        const extensions = validateCrit(JWSInvalid, new Map([
            [
                'b64',
                true
            ]
        ]), options?.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') {
                throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
        }
        const { alg  } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        checkKeyType(alg, key, 'sign');
        let payload = this._payload;
        if (b64) {
            payload = encoder.encode(encode11(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
            protectedHeader = encoder.encode(encode11(JSON.stringify(this._protectedHeader)));
        } else {
            protectedHeader = encoder.encode('');
        }
        const data = concat(protectedHeader, encoder.encode('.'), payload);
        const signature = await sign(alg, key, data);
        const jws = {
            signature: encode11(signature),
            payload: ''
        };
        if (b64) {
            jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
            jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
            jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
    }
}
class CompactSign {
    _flattened;
    constructor(payload){
        this._flattened = new FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) {
            throw new TypeError('use the flattened module for creating JWS with b64: false');
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}
class ProduceJWT {
    _payload;
    constructor(payload){
        if (!isObject2(payload)) {
            throw new TypeError('JWT Claims Set MUST be an object');
        }
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = {
            ...this._payload,
            iss: issuer
        };
        return this;
    }
    setSubject(subject) {
        this._payload = {
            ...this._payload,
            sub: subject
        };
        return this;
    }
    setAudience(audience) {
        this._payload = {
            ...this._payload,
            aud: audience
        };
        return this;
    }
    setJti(jwtId) {
        this._payload = {
            ...this._payload,
            jti: jwtId
        };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === 'number') {
            this._payload = {
                ...this._payload,
                nbf: input
            };
        } else {
            this._payload = {
                ...this._payload,
                nbf: __default29(new Date()) + __default30(input)
            };
        }
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === 'number') {
            this._payload = {
                ...this._payload,
                exp: input
            };
        } else {
            this._payload = {
                ...this._payload,
                exp: __default29(new Date()) + __default30(input)
            };
        }
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === 'undefined') {
            this._payload = {
                ...this._payload,
                iat: __default29(new Date())
            };
        } else {
            this._payload = {
                ...this._payload,
                iat: input
            };
        }
        return this;
    }
}
class SignJWT extends ProduceJWT {
    _protectedHeader;
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes('b64') && this._protectedHeader.b64 === false) {
            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
        }
        return sig.sign(key, options);
    }
}
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(var i = 0, len = code.length; i < len; ++i){
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
    if (!inited) {
        init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for(i = 0, j = 0; i < l; i += 4, j += 3){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = tmp >> 16 & 255;
        arr[L++] = tmp >> 8 & 255;
        arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[L++] = tmp >> 8 & 255;
        arr[L++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    if (!inited) {
        init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[tmp << 4 & 63];
        output += "==";
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        output += lookup[tmp >> 10];
        output += lookup[tmp >> 4 & 63];
        output += lookup[tmp << 2 & 63];
        output += "=";
    }
    parts.push(output);
    return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
}
var toString = {}.toString;
var isArray2 = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES4 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
function kMaxLength4() {
    return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer4(that, length) {
    if (kMaxLength4() < length) {
        throw new RangeError("Invalid typed array length");
    }
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        that = new Uint8Array(length);
        that.__proto__ = Buffer4.prototype;
    } else {
        if (that === null) {
            that = new Buffer4(length);
        }
        that.length = length;
    }
    return that;
}
function Buffer4(arg, encodingOrOffset, length) {
    if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
        return new Buffer4(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new Error("If encoding is specified then the first argument must be a string");
        }
        return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
}
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
    arr.__proto__ = Buffer4.prototype;
    return arr;
};
function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer4(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
        return fromString4(that, value, encodingOrOffset);
    }
    return fromObject4(that, value);
}
Buffer4.from = function(value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
    Buffer4.prototype.__proto__ = Uint8Array.prototype;
    Buffer4.__proto__ = Uint8Array;
}
function assertSize5(size) {
    if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
    }
}
function alloc(that, size, fill2, encoding) {
    assertSize5(size);
    if (size <= 0) {
        return createBuffer4(that, size);
    }
    if (fill2 !== void 0) {
        return typeof encoding === "string" ? createBuffer4(that, size).fill(fill2, encoding) : createBuffer4(that, size).fill(fill2);
    }
    return createBuffer4(that, size);
}
Buffer4.alloc = function(size, fill2, encoding) {
    return alloc(null, size, fill2, encoding);
};
function allocUnsafe(that, size) {
    assertSize5(size);
    that = createBuffer4(that, size < 0 ? 0 : checked4(size) | 0);
    if (!Buffer4.TYPED_ARRAY_SUPPORT) {
        for(var i = 0; i < size; ++i){
            that[i] = 0;
        }
    }
    return that;
}
Buffer4.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
};
function fromString4(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength6(string, encoding) | 0;
    that = createBuffer4(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
        that = that.slice(0, actual);
    }
    return that;
}
function fromArrayLike4(that, array) {
    var length = array.length < 0 ? 0 : checked4(array.length) | 0;
    that = createBuffer4(that, length);
    for(var i = 0; i < length; i += 1){
        that[i] = array[i] & 255;
    }
    return that;
}
function fromArrayBuffer4(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
        array = new Uint8Array(array);
    } else if (length === void 0) {
        array = new Uint8Array(array, byteOffset);
    } else {
        array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        that = array;
        that.__proto__ = Buffer4.prototype;
    } else {
        that = fromArrayLike4(that, array);
    }
    return that;
}
function fromObject4(that, obj) {
    if (internalIsBuffer(obj)) {
        var len = checked4(obj.length) | 0;
        that = createBuffer4(that, len);
        if (that.length === 0) {
            return that;
        }
        obj.copy(that, 0, 0, len);
        return that;
    }
    if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            if (typeof obj.length !== "number" || isnan(obj.length)) {
                return createBuffer4(that, 0);
            }
            return fromArrayLike4(that, obj);
        }
        if (obj.type === "Buffer" && isArray2(obj.data)) {
            return fromArrayLike4(that, obj.data);
        }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked4(length) {
    if (length >= kMaxLength4()) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength4().toString(16) + " bytes");
    }
    return length | 0;
}
Buffer4.isBuffer = isBuffer2;
function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
}
Buffer4.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
    }
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer4.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer4.concat = function concat(list, length) {
    if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
        return Buffer4.alloc(0);
    }
    var i;
    if (length === void 0) {
        length = 0;
        for(i = 0; i < list.length; ++i){
            length += list[i].length;
        }
    }
    var buffer = Buffer4.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength6(string, encoding) {
    if (internalIsBuffer(string)) {
        return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
    }
    if (typeof string !== "string") {
        string = "" + string;
    }
    var len = string.length;
    if (len === 0) return 0;
    var loweredCase = false;
    for(;;){
        switch(encoding){
            case "ascii":
            case "latin1":
            case "binary":
                return len;
            case "utf8":
            case "utf-8":
            case void 0:
                return utf8ToBytes4(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return len * 2;
            case "hex":
                return len >>> 1;
            case "base64":
                return base64ToBytes4(string).length;
            default:
                if (loweredCase) return utf8ToBytes4(string).length;
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
        }
    }
}
Buffer4.byteLength = byteLength6;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
        start = 0;
    }
    if (start > this.length) {
        return "";
    }
    if (end === void 0 || end > this.length) {
        end = this.length;
    }
    if (end <= 0) {
        return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
        return "";
    }
    if (!encoding) encoding = "utf8";
    while(true){
        switch(encoding){
            case "hex":
                return hexSlice3(this, start, end);
            case "utf8":
            case "utf-8":
                return utf8Slice(this, start, end);
            case "ascii":
                return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
                return latin1Slice(this, start, end);
            case "base64":
                return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return utf16leSlice(this, start, end);
            default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
        }
    }
}
Buffer4.prototype._isBuffer = true;
function swap4(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer4.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(var i = 0; i < len; i += 2){
        swap4(this, i, i + 1);
    }
    return this;
};
Buffer4.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(var i = 0; i < len; i += 4){
        swap4(this, i, i + 3);
        swap4(this, i + 1, i + 2);
    }
    return this;
};
Buffer4.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(var i = 0; i < len; i += 8){
        swap4(this, i, i + 7);
        swap4(this, i + 1, i + 6);
        swap4(this, i + 2, i + 5);
        swap4(this, i + 3, i + 4);
    }
    return this;
};
Buffer4.prototype.toString = function toString2() {
    var length = this.length | 0;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer4.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer4.compare(this, b) === 0;
};
Buffer4.prototype.inspect = function inspect() {
    var str = "";
    var max = INSPECT_MAX_BYTES4;
    if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max) str += " ... ";
    }
    return "<Buffer " + str + ">";
};
Buffer4.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
    }
    if (start === void 0) {
        start = 0;
    }
    if (end === void 0) {
        end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
        thisStart = 0;
    }
    if (thisEnd === void 0) {
        thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
function bidirectionalIndexOf4(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0) return -1;
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
        if (val.length === 0) {
            return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 255;
        if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
                return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read2(buf, i2) {
        if (indexSize === 1) {
            return buf[i2];
        } else {
            return buf.readUInt16BE(i2 * indexSize);
        }
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++){
            if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++){
                if (read2(arr, i + j) !== read2(val, j)) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf4(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf4(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
        length = remaining;
    } else {
        length = Number(length);
        if (length > remaining) {
            length = remaining;
        }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
        length = strLen / 2;
    }
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write2(buf, string, offset, length) {
    return blitBuffer4(utf8ToBytes4(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer4(asciiToBytes4(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer4(base64ToBytes4(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer4(utf16leToBytes4(string, buf.length - offset), buf, offset, length);
}
Buffer4.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0) encoding = "utf8";
        } else {
            encoding = length;
            length = void 0;
        }
    } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;){
        switch(encoding){
            case "hex":
                return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
                return utf8Write2(this, string, offset, length);
            case "ascii":
                return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
                return latin1Write(this, string, offset, length);
            case "base64":
                return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return ucs2Write(this, string, offset, length);
            default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
        }
    }
};
Buffer4.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
        return fromByteArray(buf);
    } else {
        return fromByteArray(buf.slice(start, end));
    }
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray4(res);
}
var MAX_ARGUMENTS_LENGTH4 = 4096;
function decodeCodePointsArray4(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH4) {
        return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH4));
    }
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function hexSlice3(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i){
        out += toHex(buf[i]);
    }
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for(var i = 0; i < bytes.length; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Buffer4.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) {
        end = len;
    }
    if (end < start) end = start;
    var newBuf;
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer4.prototype;
    } else {
        var sliceLen = end - start;
        newBuf = new Buffer4(sliceLen, void 0);
        for(var i = 0; i < sliceLen; ++i){
            newBuf[i] = this[i + start];
        }
    }
    return newBuf;
};
function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength2 && (mul *= 256)){
        val += this[offset + i] * mul;
    }
    return val;
};
Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while(byteLength2 > 0 && (mul *= 256)){
        val += this[offset + --byteLength2] * mul;
    }
    return val;
};
Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength2 && (mul *= 256)){
        val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
};
Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    var i = byteLength2;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256)){
        val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
};
Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
};
Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
};
function checkInt4(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt4(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while(++i < byteLength2 && (mul *= 256)){
        this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
};
Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt4(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
};
Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 1, 255, 0);
    if (!Buffer4.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 65535 + value + 1;
    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){
        buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
}
Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 2, 65535, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
    } else {
        objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
};
Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 2, 65535, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
    } else {
        objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 4294967295 + value + 1;
    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){
        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
}
Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 4, 4294967295, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
    } else {
        objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
};
Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 4, 4294967295, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
    } else {
        objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
};
Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt4(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while(++i < byteLength2 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
};
Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt4(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
};
Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 1, 127, -128);
    if (!Buffer4.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 2, 32767, -32768);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
    } else {
        objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
};
Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 2, 32767, -32768);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
    } else {
        objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
};
Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
    } else {
        objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
};
Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt4(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
    } else {
        objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
        for(i = len - 1; i >= 0; --i){
            target[i + targetStart] = this[i + start];
        }
    } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
        for(i = 0; i < len; ++i){
            target[i + targetStart] = this[i + start];
        }
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }
    return len;
};
Buffer4.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
                val = code;
            }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
    } else if (typeof val === "number") {
        val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes4(new Buffer4(val, encoding).toString());
        var len = bytes.length;
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
var INVALID_BASE64_RE4 = /[^+\/0-9A-Za-z-_]/g;
function base64clean4(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE4, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
    if (n < 16) return "0" + n.toString(16);
    return n.toString(16);
}
function utf8ToBytes4(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function asciiToBytes4(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
}
function utf16leToBytes4(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes4(str) {
    return toByteArray(base64clean4(str));
}
function blitBuffer4(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
function isnan(val) {
    return val !== val;
}
function isBuffer2(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var version2 = "1.0.0";
var encode12 = function encode2(buffer) {
    return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
var decode9 = function decode2(base64) {
    base64 += Array(5 - base64.length % 4).join("=");
    base64 = base64.replace(/\-/g, "+").replace(/\_/g, "/");
    return new Buffer4(base64, "base64");
};
var validate = function validate2(base64) {
    return /^[A-Za-z0-9\-_]+$/.test(base64);
};
var urlsafeBase64 = {
    version: version2,
    encode: encode12,
    decode: decode9,
    validate
};
var urlsafeBase64$1 = urlsafeBase64;
var decode$1 = urlsafeBase64$1.decode;
var encode$1 = urlsafeBase64$1.encode;
var validate$1 = urlsafeBase64$1.validate;
var version$1 = urlsafeBase64$1.version;
const mod113 = {
    default: urlsafeBase64$1,
    __moduleExports: urlsafeBase64$1,
    decode: decode$1,
    encode: encode$1,
    validate: validate$1,
    version: version$1
};
const importMeta = {
    url: "file:///Users/mcharlton/OtherCode/deno-web-push/mod.ts",
    main: import.meta.main
};
var crypto_default = mod107;
var WebPushConstants = {};
var supportedContentEncodings = {
    AES_GCM: "aesgcm",
    AES_128_GCM: "aes128gcm"
};
WebPushConstants.supportedContentEncodings = supportedContentEncodings;
var web_push_constants_default = WebPushConstants;
var DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;
var MAX_EXPIRATION_SECONDS = 24 * 60 * 60;
function generateVAPIDKeys() {
    const curve = crypto_default.createECDH("prime256v1");
    curve.generateKeys();
    let publicKeyBuffer = curve.getPublicKey();
    let privateKeyBuffer = curve.getPrivateKey();
    if (privateKeyBuffer.length < 32) {
        const padding = Buffer2.alloc(32 - privateKeyBuffer.length);
        padding.fill(0);
        privateKeyBuffer = Buffer2.concat([
            padding,
            privateKeyBuffer
        ]);
    }
    if (publicKeyBuffer.length < 65) {
        const padding1 = Buffer2.alloc(65 - publicKeyBuffer.length);
        padding1.fill(0);
        publicKeyBuffer = Buffer2.concat([
            padding1,
            publicKeyBuffer
        ]);
    }
    return {
        publicKey: encode$1(publicKeyBuffer),
        privateKey: encode$1(privateKeyBuffer)
    };
}
function validateSubject(subject) {
    if (!subject) {
        throw new Error("No subject set in vapidDetails.subject.");
    }
    if (typeof subject !== "string" || subject.length === 0) {
        throw new Error("The subject value must be a string containing a URL or mailto: address. " + subject);
    }
    if (subject.indexOf("mailto:") !== 0) {
        const subjectParseResult = parse12(subject, false, false);
        if (!subjectParseResult.hostname) {
            throw new Error("Vapid subject is not a url or mailto url. " + subject);
        }
    }
}
function validatePublicKey(publicKey) {
    if (!publicKey) {
        throw new Error("No key set vapidDetails.publicKey");
    }
    if (typeof publicKey !== "string") {
        throw new Error("Vapid public key is must be a URL safe Base 64 encoded string.");
    }
    if (!validate$1(publicKey)) {
        throw new Error('Vapid public key must be a URL safe Base 64 (without "=")');
    }
    publicKey = decode$1(publicKey);
    if (publicKey.length !== 65) {
        throw new Error("Vapid public key should be 65 bytes long when decoded.");
    }
}
function validatePrivateKey(privateKey) {
    if (!privateKey) {
        throw new Error("No key set in vapidDetails.privateKey");
    }
    if (typeof privateKey !== "string") {
        throw new Error("Vapid private key must be a URL safe Base 64 encoded string.");
    }
    if (!validate$1(privateKey)) {
        throw new Error('Vapid private key must be a URL safe Base 64 (without "=")');
    }
    privateKey = decode$1(privateKey);
    if (privateKey.length !== 32) {
        throw new Error("Vapid private key should be 32 bytes long when decoded.");
    }
}
function getFutureExpirationTimestamp(numSeconds) {
    const futureExp = new Date();
    futureExp.setSeconds(futureExp.getSeconds() + numSeconds);
    return Math.floor(futureExp.getTime() / 1e3);
}
function validateExpiration(expiration) {
    if (!Number.isInteger(expiration)) {
        throw new Error("`expiration` value must be a number");
    }
    if (expiration < 0) {
        throw new Error("`expiration` must be a positive integer");
    }
    const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);
    if (expiration >= maxExpirationTimestamp) {
        throw new Error("`expiration` value is greater than maximum of 24 hours");
    }
}
async function getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {
    if (!audience) {
        throw new Error("No audience could be generated for VAPID.");
    }
    if (typeof audience !== "string" || audience.length === 0) {
        throw new Error("The audience value must be a string containing the origin of a push service. " + audience);
    }
    const audienceParseResult = parse12(audience, false, false);
    if (!audienceParseResult.hostname) {
        throw new Error("VAPID audience is not a url. " + audience);
    }
    validateSubject(subject);
    validatePublicKey(publicKey);
    validatePrivateKey(privateKey);
    privateKey = decode$1(privateKey);
    if (expiration) {
        validateExpiration(expiration);
    } else {
        expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);
    }
    const header = {
        typ: "JWT",
        alg: "ES256"
    };
    const jwtPayload = {
        aud: audience,
        exp: expiration,
        sub: subject
    };
    const jwt = await new SignJWT(jwtPayload).setProtectedHeader(header).sign(new __default21.TextEncoder().encode(__default28(privateKey, "EC PRIVATE KEY")));
    if (contentEncoding === supportedContentEncodings.AES_128_GCM) {
        return {
            Authorization: "vapid t=" + jwt + ", k=" + publicKey
        };
    }
    if (contentEncoding === supportedContentEncodings.AES_GCM) {
        return {
            Authorization: "WebPush " + jwt,
            "Crypto-Key": "p256ecdsa=" + publicKey
        };
    }
    throw new Error("Unsupported encoding type specified.");
}
var AES_GCM = "aes-128-gcm";
var PAD_SIZE = {
    aes128gcm: 1,
    aesgcm: 2
};
var TAG_LENGTH = 16;
var KEY_LENGTH = 16;
var NONCE_LENGTH = 12;
var SHA_256_LENGTH = 32;
var MODE_ENCRYPT = "encrypt";
var MODE_DECRYPT = "decrypt";
var keylog;
if (importMeta.env?.ECE_KEYLOG === "1") {
    keylog = function(m, k) {
        console.warn(m + " [" + k.length + "]: " + encode$1(k));
        return k;
    };
} else {
    keylog = function(m, k) {
        return k;
    };
}
function decode31(b) {
    if (typeof b === "string") {
        return decode$1(b);
    }
    return b;
}
function HMAC_hash(key, input) {
    const hmac = crypto_default.createHmac("sha256", key);
    hmac.update(input);
    return hmac.digest();
}
function HKDF_extract(salt, ikm) {
    keylog("salt", salt);
    keylog("ikm", ikm);
    return keylog("extract", HMAC_hash(salt, ikm));
}
function HKDF_expand(prk, info2, l) {
    keylog("prk", prk);
    keylog("info", info2);
    let output = Buffer2.alloc(0);
    let T = Buffer2.alloc(0);
    info2 = Buffer2.from(info2, "ascii");
    let counter = 0;
    const cbuf = Buffer2.alloc(1);
    while(output.length < l){
        cbuf.writeUIntBE(++counter, 0, 1);
        T = HMAC_hash(prk, Buffer2.concat([
            T,
            info2,
            cbuf
        ]));
        output = Buffer2.concat([
            output,
            T
        ]);
    }
    return keylog("expand", output.slice(0, l));
}
function HKDF(salt, ikm, info2, len) {
    return HKDF_expand(HKDF_extract(salt, ikm), info2, len);
}
function info(base, context) {
    const result = Buffer2.concat([
        Buffer2.from("Content-Encoding: " + base + "\0", "ascii"),
        context
    ]);
    keylog("info " + base, result);
    return result;
}
function lengthPrefix(buffer) {
    const b = Buffer2.concat([
        Buffer2.alloc(2),
        buffer
    ]);
    b.writeUIntBE(buffer.length, 0, 2);
    return b;
}
function extractDH(header, mode) {
    const key = header.privateKey;
    let senderPubKey, receiverPubKey;
    if (mode === MODE_ENCRYPT) {
        senderPubKey = key.getPublicKey();
        receiverPubKey = header.dh;
    } else if (mode === MODE_DECRYPT) {
        senderPubKey = header.dh;
        receiverPubKey = key.getPublicKey();
    } else {
        throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
    }
    return {
        secret: key.computeSecret(header.dh),
        context: Buffer2.concat([
            Buffer2.from(header.keylabel, "ascii"),
            Buffer2.from([
                0
            ]),
            lengthPrefix(receiverPubKey),
            lengthPrefix(senderPubKey)
        ])
    };
}
function extractSecretAndContext(header, mode) {
    let result = {
        secret: null,
        context: Buffer2.alloc(0)
    };
    if (header.key) {
        result.secret = header.key;
        if (result.secret !== null && result.secret.length !== KEY_LENGTH) {
            throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
        }
    } else if (header.dh) {
        result = extractDH(header, mode);
    } else if (header.keyid !== void 0) {
        result.secret = header.keymap[header.keyid];
    }
    if (!result.secret) {
        throw new Error("Unable to determine key");
    }
    keylog("secret", result.secret);
    keylog("context", result.context);
    if (header.authSecret) {
        result.secret = HKDF(header.authSecret, result.secret, info("auth", Buffer2.alloc(0)), SHA_256_LENGTH);
        keylog("authsecret", result.secret);
    }
    return result;
}
function webpushSecret(header, mode) {
    if (!header.authSecret) {
        throw new Error("No authentication secret for webpush");
    }
    keylog("authsecret", header.authSecret);
    let remotePubKey, senderPubKey, receiverPubKey;
    if (mode === MODE_ENCRYPT) {
        senderPubKey = header.privateKey.getPublicKey();
        remotePubKey = receiverPubKey = header.dh;
    } else if (mode === MODE_DECRYPT) {
        remotePubKey = senderPubKey = header.keyid;
        receiverPubKey = header.privateKey.getPublicKey();
    } else {
        throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
    }
    keylog("remote pubkey", remotePubKey);
    keylog("sender pubkey", senderPubKey);
    keylog("receiver pubkey", receiverPubKey);
    return keylog("secret dh", HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer2.concat([
        Buffer2.from("WebPush: info\0"),
        receiverPubKey,
        senderPubKey
    ]), SHA_256_LENGTH));
}
function extractSecret(header, mode, keyLookupCallback) {
    if (keyLookupCallback) {
        if (!isFunction2(keyLookupCallback)) {
            throw new Error("Callback is not a function");
        }
    }
    if (header.key) {
        if (header.key.length !== KEY_LENGTH) {
            throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
        }
        return keylog("secret key", header.key);
    }
    if (!header.privateKey) {
        let key;
        if (!keyLookupCallback) {
            key = header.keymap && header.keymap[header.keyid];
        } else {
            key = keyLookupCallback(header.keyid);
        }
        if (!key) {
            throw new Error('No saved key (keyid: "' + header.keyid + '")');
        }
        return key;
    }
    return webpushSecret(header, mode);
}
function deriveKeyAndNonce(header, mode, lookupKeyCallback) {
    if (!header.salt) {
        throw new Error("must include a salt parameter for " + header.version);
    }
    let keyInfo;
    let nonceInfo;
    let secret;
    if (header.version === "aesgcm") {
        const s = extractSecretAndContext(header, mode, lookupKeyCallback);
        keyInfo = info("aesgcm", s.context);
        nonceInfo = info("nonce", s.context);
        secret = s.secret;
    } else if (header.version === "aes128gcm") {
        keyInfo = Buffer2.from("Content-Encoding: aes128gcm\0");
        nonceInfo = Buffer2.from("Content-Encoding: nonce\0");
        secret = extractSecret(header, mode, lookupKeyCallback);
    } else {
        throw new Error("Unable to set context for mode " + header.version);
    }
    const prk = HKDF_extract(header.salt, secret);
    const result = {
        key: HKDF_expand(prk, keyInfo, KEY_LENGTH),
        nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)
    };
    keylog("key", result.key);
    keylog("nonce base", result.nonce);
    return result;
}
function parseParams(params) {
    const header = {};
    header.version = params.version || "aes128gcm";
    header.rs = parseInt(params.rs, 10);
    if (isNaN(header.rs)) {
        header.rs = 4096;
    }
    let overhead = PAD_SIZE[header.version];
    if (header.version === "aes128gcm") {
        overhead += TAG_LENGTH;
    }
    if (header.rs <= overhead) {
        throw new Error("The rs parameter has to be greater than " + overhead);
    }
    if (params.salt) {
        header.salt = decode31(params.salt);
        if (header.salt.length !== KEY_LENGTH) {
            throw new Error("The salt parameter must be " + KEY_LENGTH + " bytes");
        }
    }
    header.keyid = params.keyid;
    if (params.key) {
        header.key = decode31(params.key);
    } else {
        header.privateKey = params.privateKey;
        if (!header.privateKey) {
            header.keymap = params.keymap;
        }
        if (header.version !== "aes128gcm") {
            header.keylabel = params.keylabel || "P-256";
        }
        if (params.dh) {
            header.dh = decode31(params.dh);
        }
    }
    if (params.authSecret) {
        header.authSecret = decode31(params.authSecret);
    }
    return header;
}
function generateNonce(base, counter) {
    const nonce = Buffer2.from(base);
    const m = nonce.readUIntBE(nonce.length - 6, 6);
    const x = ((m ^ counter) & 16777215) + ((m / 16777216 ^ counter / 16777216) & 16777215) * 16777216;
    nonce.writeUIntBE(x, nonce.length - 6, 6);
    keylog("nonce" + counter, nonce);
    return nonce;
}
function encryptRecord(key, counter, buffer, pad, header, last) {
    keylog("encrypt", buffer);
    pad = pad || 0;
    const nonce = generateNonce(key.nonce, counter);
    const gcm = crypto_default.createCipheriv(AES_GCM, key.key, nonce);
    const ciphertext = [];
    const padSize = PAD_SIZE[header.version];
    const padding = Buffer2.alloc(pad + padSize);
    padding.fill(0);
    if (header.version !== "aes128gcm") {
        padding.writeUIntBE(pad, 0, padSize);
        keylog("padding", padding);
        ciphertext.push(gcm.update(padding));
        ciphertext.push(gcm.update(buffer));
        if (!last && padding.length + buffer.length < header.rs) {
            throw new Error("Unable to pad to record size");
        }
    } else {
        ciphertext.push(gcm.update(buffer));
        padding.writeUIntBE(last ? 2 : 1, 0, 1);
        keylog("padding", padding);
        ciphertext.push(gcm.update(padding));
    }
    gcm.final();
    const tag = gcm.getAuthTag();
    if (tag.length !== TAG_LENGTH) {
        throw new Error("invalid tag generated");
    }
    ciphertext.push(tag);
    return keylog("encrypted", Buffer2.concat(ciphertext));
}
function writeHeader(header) {
    const ints = Buffer2.alloc(5);
    const keyid = Buffer2.from(header.keyid || []);
    if (keyid.length > 255) {
        throw new Error("keyid is too large");
    }
    ints.writeUIntBE(header.rs, 0, 4);
    ints.writeUIntBE(keyid.length, 4, 1);
    return Buffer2.concat([
        header.salt,
        ints,
        keyid
    ]);
}
function encrypt7(buffer, params, keyLookupCallback) {
    if (!Buffer2.isBuffer(buffer)) {
        throw new Error("buffer argument must be a Buffer");
    }
    const header = parseParams(params);
    if (!header.salt) {
        header.salt = crypto_default.randomBytes(KEY_LENGTH);
    }
    let result;
    if (header.version === "aes128gcm") {
        if (header.privateKey && !header.keyid) {
            header.keyid = header.privateKey.getPublicKey();
        }
        result = writeHeader(header);
    } else {
        result = Buffer2.alloc(0);
    }
    const key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);
    let start = 0;
    const padSize = PAD_SIZE[header.version];
    let overhead = padSize;
    if (header.version === "aes128gcm") {
        overhead += TAG_LENGTH;
    }
    let pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);
    let counter = 0;
    let last = false;
    while(!last){
        let recordPad = Math.min(header.rs - overhead - 1, pad);
        if (header.version !== "aes128gcm") {
            recordPad = Math.min((1 << padSize * 8) - 1, recordPad);
        }
        if (pad > 0 && recordPad === 0) {
            ++recordPad;
        }
        pad -= recordPad;
        const end = start + header.rs - overhead - recordPad;
        if (header.version !== "aes128gcm") {
            last = end > buffer.length;
        } else {
            last = end >= buffer.length;
        }
        last = last && pad <= 0;
        const block = encryptRecord(key, counter, buffer.slice(start, end), recordPad, header, last);
        result = Buffer2.concat([
            result,
            block
        ]);
        start = end;
        ++counter;
    }
    return result;
}
function isFunction2(object) {
    return typeof object === "function";
}
var encrypt21 = function(userPublicKey, userAuth, payload, contentEncoding) {
    if (!userPublicKey) {
        throw new Error("No user public key provided for encryption.");
    }
    if (typeof userPublicKey !== "string") {
        throw new Error("The subscription p256dh value must be a string.");
    }
    if (mod113.decode(userPublicKey).length !== 65) {
        throw new Error("The subscription p256dh value should be 65 bytes long.");
    }
    if (!userAuth) {
        throw new Error("No user auth provided for encryption.");
    }
    if (typeof userAuth !== "string") {
        throw new Error("The subscription auth key must be a string.");
    }
    if (mod113.decode(userAuth).length < 16) {
        throw new Error("The subscription auth key should be at least 16 bytes long");
    }
    if (typeof payload !== "string" && !Buffer2.isBuffer(payload)) {
        throw new Error("Payload must be either a string or a Node Buffer.");
    }
    if (typeof payload === "string" || payload instanceof String) {
        payload = Buffer2.from(payload);
    }
    const localCurve = crypto_default.createECDH("prime256v1");
    const localPublicKey = localCurve.generateKeys();
    const salt = mod113.encode(crypto_default.randomBytes(16));
    const cipherText = encrypt7(payload, {
        version: contentEncoding,
        dh: userPublicKey,
        privateKey: localCurve,
        salt,
        authSecret: userAuth
    });
    return {
        localPublicKey,
        salt,
        cipherText
    };
};
function WebPushError(message, statusCode, headers, body, endpoint) {
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.message = message;
    this.statusCode = statusCode;
    this.headers = headers;
    this.body = body;
    this.endpoint = endpoint;
}
__default21.inherits(WebPushError, Error);
var web_push_error_default = WebPushError;
var DEFAULT_TTL = 2419200;
var gcmAPIKey = "";
var vapidDetails;
function WebPushLib() {}
WebPushLib.prototype.setGCMAPIKey = function(apiKey) {
    if (apiKey === null) {
        gcmAPIKey = null;
        return;
    }
    if (typeof apiKey === "undefined" || typeof apiKey !== "string" || apiKey.length === 0) {
        throw new Error("The GCM API Key should be a non-empty string or null.");
    }
    gcmAPIKey = apiKey;
};
WebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {
    if (arguments.length === 1 && arguments[0] === null) {
        vapidDetails = null;
        return;
    }
    validateSubject(subject);
    validatePublicKey(publicKey);
    validatePrivateKey(privateKey);
    vapidDetails = {
        subject,
        publicKey,
        privateKey
    };
};
WebPushLib.prototype.generateRequestDetails = async function(subscription, payload, options) {
    if (!subscription || !subscription.endpoint) {
        throw new Error("You must pass in a subscription with at least an endpoint.");
    }
    if (typeof subscription.endpoint !== "string" || subscription.endpoint.length === 0) {
        throw new Error("The subscription endpoint must be a string with a valid URL.");
    }
    if (payload) {
        if (typeof subscription !== "object" || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {
            throw new Error("To send a message with a payload, the subscription must have 'auth' and 'p256dh' keys.");
        }
    }
    let currentGCMAPIKey = gcmAPIKey;
    let currentVapidDetails = vapidDetails;
    let timeToLive = DEFAULT_TTL;
    let extraHeaders = {};
    let contentEncoding = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
    let proxy;
    let agent;
    let timeout;
    if (options) {
        const validOptionKeys = [
            "headers",
            "gcmAPIKey",
            "vapidDetails",
            "TTL",
            "contentEncoding",
            "proxy",
            "agent",
            "timeout"
        ];
        const optionKeys = Object.keys(options);
        for(let i = 0; i < optionKeys.length; i += 1){
            const optionKey = optionKeys[i];
            if (validOptionKeys.indexOf(optionKey) === -1) {
                throw new Error("'" + optionKey + "' is an invalid option. The valid options are ['" + validOptionKeys.join("', '") + "'].");
            }
        }
        if (options.headers) {
            extraHeaders = options.headers;
            let duplicates = Object.keys(extraHeaders).filter(function(header) {
                return typeof options[header] !== "undefined";
            });
            if (duplicates.length > 0) {
                throw new Error("Duplicated headers defined [" + duplicates.join(",") + "]. Please either define the header in thetop level options OR in the 'headers' key.");
            }
        }
        if (options.gcmAPIKey) {
            currentGCMAPIKey = options.gcmAPIKey;
        }
        if (options.vapidDetails !== void 0) {
            currentVapidDetails = options.vapidDetails;
        }
        if (options.TTL !== void 0) {
            timeToLive = Number(options.TTL);
            if (timeToLive < 0) {
                throw new Error("TTL should be a number and should be at least 0");
            }
        }
        if (options.contentEncoding) {
            if (options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM || options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
                contentEncoding = options.contentEncoding;
            } else {
                throw new Error("Unsupported content encoding specified.");
            }
        }
        if (options.proxy) {
            if (typeof options.proxy === "string" || typeof options.proxy.host === "string") {
                proxy = options.proxy;
            } else {
                console.warn("Attempt to use proxy option, but invalid type it should be a string or proxy options object.");
            }
        }
        if (options.agent) {
            if (options.agent instanceof Agent) {
                if (proxy) {
                    console.warn("Agent option will be ignored because proxy option is defined.");
                }
                agent = options.agent;
            } else {
                console.warn("Wrong type for the agent option, it should be an instance of https.Agent.");
            }
        }
        if (typeof options.timeout === "number") {
            timeout = options.timeout;
        }
    }
    if (typeof timeToLive === "undefined") {
        timeToLive = DEFAULT_TTL;
    }
    const requestDetails = {
        method: "POST",
        headers: {
            TTL: timeToLive
        }
    };
    Object.keys(extraHeaders).forEach(function(header) {
        requestDetails.headers[header] = extraHeaders[header];
    });
    let requestPayload = null;
    if (payload) {
        const encrypted = encrypt21(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);
        requestDetails.headers["Content-Length"] = encrypted.cipherText.length;
        requestDetails.headers["Content-Type"] = "application/octet-stream";
        if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM) {
            requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
        } else if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
            requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_GCM;
            requestDetails.headers.Encryption = "salt=" + encrypted.salt;
            requestDetails.headers["Crypto-Key"] = "dh=" + encode$1(encrypted.localPublicKey);
        }
        requestPayload = encrypted.cipherText;
    } else {
        requestDetails.headers["Content-Length"] = 0;
    }
    const isGCM = subscription.endpoint.indexOf("https://android.googleapis.com/gcm/send") === 0;
    const isFCM = subscription.endpoint.indexOf("https://fcm.googleapis.com/fcm/send") === 0;
    if (isGCM) {
        if (!currentGCMAPIKey) {
            console.warn("Attempt to send push notification to GCM endpoint, but no GCM key is defined. Please use setGCMApiKey() or add 'gcmAPIKey' as an option.");
        } else {
            requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
        }
    } else if (currentVapidDetails) {
        const parsedUrl = parse12(subscription.endpoint);
        const audience = parsedUrl.protocol + "//" + parsedUrl.host;
        const vapidHeaders = await getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);
        requestDetails.headers.Authorization = vapidHeaders.Authorization;
        if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
            if (requestDetails.headers["Crypto-Key"]) {
                requestDetails.headers["Crypto-Key"] += ";" + vapidHeaders["Crypto-Key"];
            } else {
                requestDetails.headers["Crypto-Key"] = vapidHeaders["Crypto-Key"];
            }
        }
    } else if (isFCM && currentGCMAPIKey) {
        requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
    }
    requestDetails.body = requestPayload;
    requestDetails.endpoint = subscription.endpoint;
    if (proxy) {
        requestDetails.proxy = proxy;
    }
    if (agent) {
        requestDetails.agent = agent;
    }
    if (timeout) {
        requestDetails.timeout = timeout;
    }
    return requestDetails;
};
WebPushLib.prototype.sendNotification = async function(subscription, payload, options) {
    let requestDetails;
    try {
        requestDetails = await this.generateRequestDetails(subscription, payload, options);
    } catch (err) {
        return Promise.reject(err);
    }
    return new Promise(async function(resolve, reject) {
        const httpsOptions = {};
        const urlParts = parse12(requestDetails.endpoint, false, false);
        httpsOptions.hostname = urlParts.hostname;
        httpsOptions.port = urlParts.port;
        httpsOptions.path = urlParts.path;
        httpsOptions.headers = requestDetails.headers;
        httpsOptions.method = requestDetails.method;
        if (requestDetails.timeout) {
            httpsOptions.timeout = requestDetails.timeout;
        }
        if (requestDetails.agent) {
            httpsOptions.agent = requestDetails.agent;
        }
        if (requestDetails.body) {
            httpsOptions.body = requestDetails.body;
        }
        const pushResponse = await fetch(requestDetails.endpoint, httpsOptions).catch((e)=>{
            reject(e);
        });
        if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {
            reject(new web_push_error_default("Received unexpected response code", pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));
        } else {
            const responseText2 = await pushResponse.text();
            resolve({
                statusCode: pushResponse.statusCode,
                body: responseText2,
                headers: pushResponse.headers
            });
        }
    });
};
var web_push_lib_default = WebPushLib;
var webPush = new web_push_lib_default();
var setGCMAPIKey = webPush.setGCMAPIKey;
var setVapidDetails = webPush.setVapidDetails;
var generateRequestDetails = webPush.generateRequestDetails;
var sendNotification = webPush.sendNotification;
export { web_push_error_default as WebPushError, encrypt21 as encrypt, generateRequestDetails as generateRequestDetails, generateVAPIDKeys as generateVAPIDKeys, getVapidHeaders as getVapidHeaders, sendNotification as sendNotification, setGCMAPIKey as setGCMAPIKey, setVapidDetails as setVapidDetails, supportedContentEncodings as supportedContentEncodings };
