"use strict";
if (typeof Deno === 'undefined') {
  globalThis.addEventListener = () => {}
  globalThis.Deno = {
    args: [],
    errors: {
    PermissionDenied: Error
  },
  build:{
arch: 'x86_64'
}
};
}
const crypto = require('node:crypto').webcrypto;
globalThis.crypto = crypto;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj2, key2, value) => key2 in obj2 ? __defProp(obj2, key2, { enumerable: true, configurable: true, writable: true, value }) : obj2[key2] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from6, except, desc) => {
  if (from6 && typeof from6 === "object" || typeof from6 === "function") {
    for (let key2 of __getOwnPropNames(from6))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from6[key2], enumerable: !(desc = __getOwnPropDesc(from6, key2)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod114) => __copyProps(__defProp({}, "__esModule", { value: true }), mod114);
var __publicField = (obj2, key2, value) => {
  __defNormalProp(obj2, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};

// index.mjs
var deno_web_push_exports = {};
__export(deno_web_push_exports, {
  WebPushError: () => web_push_error_default,
  encrypt: () => encrypt21,
  generateRequestDetails: () => generateRequestDetails,
  generateVAPIDKeys: () => generateVAPIDKeys,
  getVapidHeaders: () => getVapidHeaders,
  sendNotification: () => sendNotification,
  setGCMAPIKey: () => setGCMAPIKey,
  setVapidDetails: () => setVapidDetails,
  supportedContentEncodings: () => supportedContentEncodings
});
module.exports = __toCommonJS(deno_web_push_exports);
var import_meta = {};
var codes = {};
var _toString = Object.prototype.toString;
var _isObjectLike = (value) => value !== null && typeof value === "object";
var _isFunctionLike = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
  return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
  return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
var __default = {
  isAsyncFunction,
  isGeneratorFunction,
  isAnyArrayBuffer,
  isArrayBuffer,
  isArgumentsObject,
  isBoxedPrimitive,
  isDataView,
  isMap,
  isMapIterator,
  isModuleNamespaceObject,
  isNativeError,
  isPromise,
  isSet,
  isSetIterator,
  isWeakMap,
  isWeakSet,
  isRegExp,
  isDate,
  isStringObject,
  isNumberObject,
  isBooleanObject,
  isBigIntObject
};
var mod = {
  isAnyArrayBuffer,
  isArgumentsObject,
  isArrayBuffer,
  isAsyncFunction,
  isBooleanObject,
  isBoxedPrimitive,
  isDataView,
  isDate,
  isGeneratorFunction,
  isGeneratorObject,
  isMap,
  isMapIterator,
  isModuleNamespaceObject,
  isNativeError,
  isNumberObject,
  isBigIntObject,
  isPromise,
  isRegExp,
  isSet,
  isSetIterator,
  isSharedArrayBuffer,
  isStringObject,
  isSymbolObject,
  isWeakMap,
  isWeakSet,
  default: __default
};
var kHandle = Symbol("kHandle");
var kKeyObject = Symbol("kKeyObject");
var kKeyType = Symbol("kKeyType");
function isKeyObject(obj2) {
  return obj2 != null && obj2[kKeyType] !== void 0;
}
function isCryptoKey(obj2) {
  return obj2 != null && obj2[kKeyObject] !== void 0;
}
var _toString1 = Object.prototype.toString;
var _isObjectLike1 = (value) => value !== null && typeof value === "object";
function isArrayBufferView(value) {
  return ArrayBuffer.isView(value);
}
function isTypedArray(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
  return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
var { isDate: isDate1, isArgumentsObject: isArgumentsObject1, isBigIntObject: isBigIntObject1, isBooleanObject: isBooleanObject1, isNumberObject: isNumberObject1, isStringObject: isStringObject1, isSymbolObject: isSymbolObject1, isNativeError: isNativeError1, isRegExp: isRegExp1, isAsyncFunction: isAsyncFunction1, isGeneratorFunction: isGeneratorFunction1, isGeneratorObject: isGeneratorObject1, isPromise: isPromise1, isMap: isMap1, isSet: isSet1, isMapIterator: isMapIterator1, isSetIterator: isSetIterator1, isWeakMap: isWeakMap1, isWeakSet: isWeakSet1, isArrayBuffer: isArrayBuffer1, isDataView: isDataView1, isSharedArrayBuffer: isSharedArrayBuffer1, isModuleNamespaceObject: isModuleNamespaceObject1, isAnyArrayBuffer: isAnyArrayBuffer1, isBoxedPrimitive: isBoxedPrimitive1 } = mod;
function hideStackFrames(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", {
    value: hidden
  });
  return fn;
}
function normalizeEncoding(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases(enc);
}
function slowCases(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}
function isInt32(value) {
  return value === (value | 0);
}
function isUint32(value) {
  return value === value >>> 0;
}
var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
  if (!isArrayBufferView(buffer)) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, [
      "Buffer",
      "TypedArray",
      "DataView"
    ], buffer);
  }
});
var validateInteger = hideStackFrames((value, name, min3 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
var validateObject = hideStackFrames((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt32 = hideStackFrames((value, name, min3 = -2147483648, max2 = 2147483647) => {
  if (!isInt32(value)) {
    if (typeof value !== "number") {
      throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
  if (value < min3 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
hideStackFrames((value, name, positive) => {
  if (!isUint32(value)) {
    if (typeof value !== "number") {
      throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min3 = positive ? 1 : 0;
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min3} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
}
hideStackFrames((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v19) => typeof v19 === "string" ? `'${v19}'` : String(v19)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback = hideStackFrames((callback) => {
  if (typeof callback !== "function") {
    throw new codes.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal = hideStackFrames((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction = hideStackFrames((value, name) => {
  if (typeof value !== "function") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
hideStackFrames((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
  let called = false;
  return function(...args) {
    if (called)
      return;
    called = true;
    Reflect.apply(callback, this, args);
  };
}
function createDeferredPromise() {
  let resolve9;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve9 = res;
    reject = rej;
  });
  return {
    promise,
    resolve: resolve9,
    reject
  };
}
var kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
  validateFunction(original, "original");
  if (original[kCustomPromisifiedSymbol]) {
    const fn = original[kCustomPromisifiedSymbol];
    validateFunction(fn, "util.promisify.custom");
    return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol];
  function fn1(...args) {
    return new Promise((resolve9, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve9(obj2);
        } else {
          resolve9(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
  Object.defineProperty(fn1, kCustomPromisifiedSymbol, {
    value: fn1,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
var Encodings;
(function(Encodings4) {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
var encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
var __default1 = {
  encodings
};
var mod1 = {
  encodings,
  default: __default1
};
function indexOfNeedle(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s10 = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s10)
      continue;
    const pin = i;
    let matched = 1;
    let j13 = i;
    while (matched < needle.length) {
      j13++;
      if (source[j13] !== needle[j13 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}
function numberToBytes(n3) {
  if (n3 === 0)
    return new Uint8Array([
      0
    ]);
  const bytes = [];
  bytes.unshift(n3 & 255);
  while (n3 >= 256) {
    n3 = n3 >>> 8;
    bytes.unshift(n3 & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x17 = 0; x17 <= searchableBufferLastIndex; x17++) {
    if (searchableBuffer[searchableBufferLastIndex - x17] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x17;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x17 = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x17;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
var __default2 = {
  indexOfBuffer,
  indexOfNumber
};
var mod2 = {
  indexOfBuffer,
  indexOfNumber,
  numberToBytes,
  default: __default2
};
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l22 = uint8.length;
  for (i = 2; i < l22; i += 3) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc[uint8[i] & 63];
  }
  if (i === l22 + 1) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l22) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
function addPaddingToBase64url(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase64(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data) {
  return convertBase64ToBase64url(encode(data));
}
function decode1(b64url) {
  return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
  str = base64clean(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode(str);
}
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes(str) {
  str = base64clean(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode1(str);
}
function hexToBytes(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a7 = Number.parseInt(str[i * 2], 16);
    const b15 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a7) && Number.isNaN(b15)) {
      break;
    }
    byteArray[i] = a7 << 4 | b15;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
  let c13, hi, lo;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c13 = str.charCodeAt(i);
    hi = c13 >> 8;
    lo = c13 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
var utf8Encoder = new TextEncoder();
var float32Array = new Float32Array(1);
var uInt8Float32Array = new Uint8Array(float32Array.buffer);
var float64Array = new Float64Array(1);
var uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
var bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 8);
  }
  uInt8Float64Array[7] = first;
  uInt8Float64Array[6] = buffer[++offset];
  uInt8Float64Array[5] = buffer[++offset];
  uInt8Float64Array[4] = buffer[++offset];
  uInt8Float64Array[3] = buffer[++offset];
  uInt8Float64Array[2] = buffer[++offset];
  uInt8Float64Array[1] = buffer[++offset];
  uInt8Float64Array[0] = last;
  return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 8);
  }
  uInt8Float64Array[0] = first;
  uInt8Float64Array[1] = buffer[++offset];
  uInt8Float64Array[2] = buffer[++offset];
  uInt8Float64Array[3] = buffer[++offset];
  uInt8Float64Array[4] = buffer[++offset];
  uInt8Float64Array[5] = buffer[++offset];
  uInt8Float64Array[6] = buffer[++offset];
  uInt8Float64Array[7] = last;
  return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 7);
  float64Array[0] = val;
  buffer[offset++] = uInt8Float64Array[0];
  buffer[offset++] = uInt8Float64Array[1];
  buffer[offset++] = uInt8Float64Array[2];
  buffer[offset++] = uInt8Float64Array[3];
  buffer[offset++] = uInt8Float64Array[4];
  buffer[offset++] = uInt8Float64Array[5];
  buffer[offset++] = uInt8Float64Array[6];
  buffer[offset++] = uInt8Float64Array[7];
  return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 7);
  float64Array[0] = val;
  buffer[offset++] = uInt8Float64Array[7];
  buffer[offset++] = uInt8Float64Array[6];
  buffer[offset++] = uInt8Float64Array[5];
  buffer[offset++] = uInt8Float64Array[4];
  buffer[offset++] = uInt8Float64Array[3];
  buffer[offset++] = uInt8Float64Array[2];
  buffer[offset++] = uInt8Float64Array[1];
  buffer[offset++] = uInt8Float64Array[0];
  return offset;
}
function readFloatBackwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 4);
  }
  uInt8Float32Array[3] = first;
  uInt8Float32Array[2] = buffer[++offset];
  uInt8Float32Array[1] = buffer[++offset];
  uInt8Float32Array[0] = last;
  return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 4);
  }
  uInt8Float32Array[0] = first;
  uInt8Float32Array[1] = buffer[++offset];
  uInt8Float32Array[2] = buffer[++offset];
  uInt8Float32Array[3] = last;
  return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 3);
  float32Array[0] = val;
  buffer[offset++] = uInt8Float32Array[0];
  buffer[offset++] = uInt8Float32Array[1];
  buffer[offset++] = uInt8Float32Array[2];
  buffer[offset++] = uInt8Float32Array[3];
  return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 3);
  float32Array[0] = val;
  buffer[offset++] = uInt8Float32Array[3];
  buffer[offset++] = uInt8Float32Array[2];
  buffer[offset++] = uInt8Float32Array[1];
  buffer[offset++] = uInt8Float32Array[0];
  return offset;
}
function readInt24LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
  return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings.length; ++i) {
  encodingsMap[encodings[i]] = i;
}
var encodingOps = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf8,
    encoding: "utf8",
    encodingVal: encodingsMap.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps.utf8;
      if (encoding === "ucs2")
        return encodingOps.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps.utf8;
      if (encoding === "ascii")
        return encodingOps.ascii;
      if (encoding === "ucs-2")
        return encodingOps.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps.latin1;
      }
      if (encoding === "base64")
        return encodingOps.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps.base64url;
      }
      break;
  }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds(buf, offset, byteLength3) {
  validateNumber(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
    boundsError(offset, buf.length - (byteLength3 + 1));
  }
}
function checkInt(value, min3, max2, buf, offset, byteLength3) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength3 > 3) {
      if (min3 === 0 || min3 === 0n) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength3 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}) and < 2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset, byteLength3);
}
function toInteger(n3, defaultVal) {
  n3 = +n3;
  if (!Number.isNaN(n3) && n3 >= Number.MIN_SAFE_INTEGER && n3 <= Number.MAX_SAFE_INTEGER) {
    return n3 % 1 === 0 ? n3 : Math.floor(n3);
  }
  return defaultVal;
}
function writeU_Int8(buf, value, offset, min3, max2) {
  value = +value;
  validateNumber(offset, "offset");
  if (value > max2 || value < min3) {
    throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min3} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset(value, name, min3 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
}
function writeU_Int48LE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE(buf, value, offset, min3, max2) {
  value = +value;
  checkInt(value, min3, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
var kMaxLength = 2147483647;
var MAX_UINT32 = 2 ** 32;
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer2.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer2.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer2.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer2.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > 2147483647) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer2.prototype);
  return buf;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe(arg);
  }
  return _from(arg, encodingOrOffset, length);
}
Buffer2.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer1(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from(valueOf, encodingOrOffset, length);
    }
    const b15 = fromObject(value);
    if (b15) {
      return b15;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
    "string",
    "Buffer",
    "ArrayBuffer",
    "Array",
    "Array-like Object"
  ], value);
}
Buffer2.from = function from(value, encodingOrOffset, length) {
  return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer2, Uint8Array);
function assertSize(size) {
  validateNumber(size, "size");
  if (!(size >= 0 && size <= 2147483647)) {
    throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc(size, fill6, encoding) {
  assertSize(size);
  const buffer = createBuffer(size);
  if (fill6 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill6, encoding);
  }
  return buffer;
}
Buffer2.alloc = function alloc(size, fill6, encoding) {
  return _alloc(size, fill6, encoding);
};
function _allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer2.allocUnsafe = function allocUnsafe(size) {
  return _allocUnsafe(size);
};
Buffer2.allocUnsafeSlow = function allocUnsafeSlow(size) {
  return _allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength(string, encoding) | 0;
  let buf = createBuffer(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  const buf = createBuffer(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer1(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer(0);
    }
    return fromArrayLike(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike(obj2.data);
  }
}
function checked(length) {
  if (length >= 2147483647) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  assertSize(length);
  return Buffer2.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer2.isBuffer = function isBuffer(b15) {
  return b15 != null && b15._isBuffer === true && b15 !== Buffer2.prototype;
};
Buffer2.compare = function compare(a7, b15) {
  if (isInstance(a7, Uint8Array)) {
    a7 = Buffer2.from(a7, a7.offset, a7.byteLength);
  }
  if (isInstance(b15, Uint8Array)) {
    b15 = Buffer2.from(b15, b15.offset, b15.byteLength);
  }
  if (!Buffer2.isBuffer(a7) || !Buffer2.isBuffer(b15)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a7 === b15) {
    return 0;
  }
  let x17 = a7.length;
  let y16 = b15.length;
  for (let i = 0, len = Math.min(x17, y16); i < len; ++i) {
    if (a7[i] !== b15[i]) {
      x17 = a7[i];
      y16 = b15[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== void 0;
};
Buffer2.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset(length, "length");
  }
  const buffer = Buffer2.allocUnsafe(length);
  let pos = 0;
  for (let i12 = 0; i12 < list.length; i12++) {
    const buf = list[i12];
    if (!isUint8Array(buf)) {
      throw new codes.ERR_INVALID_ARG_TYPE(`list[${i12}]`, [
        "Buffer",
        "Uint8Array"
      ], list[i12]);
    }
    pos += _copyActual(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
      return string.byteLength;
    }
    throw new codes.ERR_INVALID_ARG_TYPE("string", [
      "string",
      "Buffer",
      "ArrayBuffer"
    ], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf8(string);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf8(string);
  }
  return ops.byteLength(string);
}
Buffer2.byteLength = byteLength;
Buffer2.prototype._isBuffer = true;
function swap(b15, n3, m20) {
  const i = b15[n3];
  b15[n3] = b15[m20];
  b15[m20] = i;
}
Buffer2.prototype.swap16 = function swap16() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
Buffer2.prototype.equals = function equals(b15) {
  if (!isUint8Array(b15)) {
    throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
      "Buffer",
      "Uint8Array"
    ], b15);
  }
  if (this === b15) {
    return true;
  }
  return Buffer2.compare(this, b15) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
  Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
}
Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer2.from(target, target.offset, target.byteLength);
  }
  if (!Buffer2.isBuffer(target)) {
    throw new codes.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset(start, "targetStart", 0, kMaxLength);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset(start, "sourceStart", 0, kMaxLength);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x17 = thisEnd - thisStart;
  let y16 = end - start;
  const len = Math.min(x17, y16);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x17 = thisCopy[i];
      y16 = targetCopy[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  validateBuffer(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps.utf8;
  } else {
    ops = getEncodingOps(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array(val)) {
    const encodingVal = ops === void 0 ? encodingsMap.utf8 : ops.encodingVal;
    return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes.ERR_INVALID_ARG_TYPE("value", [
    "number",
    "string",
    "Buffer",
    "Uint8Array"
  ], val);
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer2.prototype.asciiSlice = function asciiSlice(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii(this);
  } else {
    return bytesToAscii(this.slice(offset, length));
  }
};
Buffer2.prototype.asciiWrite = function asciiWrite(string, offset, length) {
  return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer2.prototype.base64Slice = function base64Slice(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode(this);
  } else {
    return encode(this.slice(offset, length));
  }
};
Buffer2.prototype.base64Write = function base64Write(string, offset, length) {
  return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer2.prototype.base64urlSlice = function base64urlSlice(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode1(this);
  } else {
    return encode1(this.slice(offset, length));
  }
};
Buffer2.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
  return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer2.prototype.hexWrite = function hexWrite(string, offset, length) {
  return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.hexSlice = function hexSlice(string, offset, length) {
  return _hexSlice(this, string, offset, length);
};
Buffer2.prototype.latin1Slice = function latin1Slice(string, offset, length) {
  return _latin1Slice(this, string, offset, length);
};
Buffer2.prototype.latin1Write = function latin1Write(string, offset, length) {
  return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer2.prototype.ucs2Slice = function ucs2Slice(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le(this);
  } else {
    return bytesToUtf16le(this.slice(offset, length));
  }
};
Buffer2.prototype.ucs2Write = function ucs2Write(string, offset, length) {
  return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.utf8Slice = function utf8Slice(string, offset, length) {
  return _utf8Slice(this, string, offset, length);
};
Buffer2.prototype.utf8Write = function utf8Write(string, offset, length) {
  return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer2.prototype.write = function write(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer2.prototype);
  return buffer;
}
function _utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= 4096) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function _latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
Buffer2.prototype.slice = function slice(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer2.prototype);
  return newBuf;
};
Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48LE(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40LE(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24LE(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48BE(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40BE(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24BE(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset = 0) {
  validateNumber(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError(offset, this.length - 1);
  }
  return val;
};
Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = readUInt16BE;
Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = readUInt32BE;
Buffer2.prototype.readBigUint64LE = Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer2.prototype.readBigUint64BE = Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48LE(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40LE(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24LE(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48BE(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40BE(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24BE(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.readInt8 = function readInt8(offset = 0) {
  validateNumber(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer2.prototype.readFloatLE = function readFloatLE(offset) {
  return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset) {
  return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset) {
  return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset) {
  return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int8(this, value, offset, 0, 255);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int8(this, value, offset, 0, 255);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
  return writeU_Int8(this, value, offset, 0, 255);
};
Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
  return writeU_Int16LE(this, value, offset, 0, 65535);
};
Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
  return writeU_Int16BE(this, value, offset, 0, 65535);
};
Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
  return _writeUInt32LE(this, value, offset, 0, 4294967295);
};
Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
  return _writeUInt32BE(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE(buf, value, offset, min3, max2) {
  checkIntBI(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min3, max2) {
  checkIntBI(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer2.prototype.writeBigUint64LE = Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer2.prototype.writeBigUint64BE = Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int8(this, value, offset, -128, 127);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int8(this, value, offset, -128, 127);
  }
  boundsError(byteLength3, 6, "byteLength");
};
Buffer2.prototype.writeInt8 = function writeInt8(value, offset = 0) {
  return writeU_Int8(this, value, offset, -128, 127);
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
  return writeU_Int16LE(this, value, offset, -32768, 32767);
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
  return writeU_Int16BE(this, value, offset, -32768, 32767);
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
  return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
  return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
};
Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset) {
  return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset) {
  return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
  return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
  return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer2.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array(this)) {
    throw new codes.ERR_INVALID_ARG_TYPE("source", [
      "Buffer",
      "Uint8Array"
    ], this);
  }
  if (!isUint8Array(target)) {
    throw new codes.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger(targetStart, 0);
    if (targetStart < 0) {
      throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT32) {
      throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT32) {
      throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds1(buf, offset, byteLength23) {
  validateNumber(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength23] === void 0) {
    boundsError(offset, buf.length - (byteLength23 + 1));
  }
}
function checkIntBI(value, min3, max2, buf, offset, byteLength23) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength23 > 3) {
      if (min3 === 0 || min3 === BigInt(0)) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength23 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength23 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength23 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds1(buf, offset, byteLength23);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer(src, dst, offset, byteLength3) {
  let i;
  const length = byteLength3 === void 0 ? src.length : byteLength3;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j13 = 0; j13 < 16; ++j13) {
      table[i16 + j13] = alphabet[i] + alphabet[j13];
    }
  }
  return table;
}();
function defineBigIntMethod(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var yr = Object.create;
var N = Object.defineProperty;
var wr = Object.getOwnPropertyDescriptor;
var xr = Object.getOwnPropertyNames;
var Br = Object.getPrototypeOf;
var Er = Object.prototype.hasOwnProperty;
var dr = (i) => N(i, "__esModule", {
  value: true
});
var k = (i, r2) => () => (r2 || i((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var gr = (i, r2, t2) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let n3 of xr(r2))
      !Er.call(i, n3) && n3 !== "default" && N(i, n3, {
        get: () => r2[n3],
        enumerable: !(t2 = wr(r2, n3)) || t2.enumerable
      });
  return i;
};
var H = (i) => gr(dr(N(i != null ? yr(Br(i)) : {}, "default", i && i.__esModule && "default" in i ? {
  get: () => i.default,
  enumerable: true
} : {
  value: i,
  enumerable: true
})), i);
var J = k((_11) => {
  "use strict";
  _11.byteLength = Ir;
  _11.toByteArray = Ar2;
  _11.fromByteArray = Rr2;
  var B18 = [], w24 = [], mr2 = typeof Uint8Array != "undefined" ? Uint8Array : Array, b15 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (m20 = 0, V8 = b15.length; m20 < V8; ++m20)
    B18[m20] = b15[m20], w24[b15.charCodeAt(m20)] = m20;
  var m20, V8;
  w24["-".charCodeAt(0)] = 62;
  w24["_".charCodeAt(0)] = 63;
  function z15(i) {
    var r2 = i.length;
    if (r2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t2 = i.indexOf("=");
    t2 === -1 && (t2 = r2);
    var n3 = t2 === r2 ? 0 : 4 - t2 % 4;
    return [
      t2,
      n3
    ];
  }
  function Ir(i) {
    var r2 = z15(i), t2 = r2[0], n3 = r2[1];
    return (t2 + n3) * 3 / 4 - n3;
  }
  function Fr2(i, r2, t2) {
    return (r2 + t2) * 3 / 4 - t2;
  }
  function Ar2(i) {
    var r2, t2 = z15(i), n3 = t2[0], e = t2[1], o6 = new mr2(Fr2(i, n3, e)), u12 = 0, f8 = e > 0 ? n3 - 4 : n3, c13;
    for (c13 = 0; c13 < f8; c13 += 4)
      r2 = w24[i.charCodeAt(c13)] << 18 | w24[i.charCodeAt(c13 + 1)] << 12 | w24[i.charCodeAt(c13 + 2)] << 6 | w24[i.charCodeAt(c13 + 3)], o6[u12++] = r2 >> 16 & 255, o6[u12++] = r2 >> 8 & 255, o6[u12++] = r2 & 255;
    return e === 2 && (r2 = w24[i.charCodeAt(c13)] << 2 | w24[i.charCodeAt(c13 + 1)] >> 4, o6[u12++] = r2 & 255), e === 1 && (r2 = w24[i.charCodeAt(c13)] << 10 | w24[i.charCodeAt(c13 + 1)] << 4 | w24[i.charCodeAt(c13 + 2)] >> 2, o6[u12++] = r2 >> 8 & 255, o6[u12++] = r2 & 255), o6;
  }
  function Ur(i) {
    return B18[i >> 18 & 63] + B18[i >> 12 & 63] + B18[i >> 6 & 63] + B18[i & 63];
  }
  function Tr(i, r2, t2) {
    for (var n3, e = [], o6 = r2; o6 < t2; o6 += 3)
      n3 = (i[o6] << 16 & 16711680) + (i[o6 + 1] << 8 & 65280) + (i[o6 + 2] & 255), e.push(Ur(n3));
    return e.join("");
  }
  function Rr2(i) {
    for (var r2, t2 = i.length, n3 = t2 % 3, e = [], o6 = 16383, u12 = 0, f8 = t2 - n3; u12 < f8; u12 += o6)
      e.push(Tr(i, u12, u12 + o6 > f8 ? f8 : u12 + o6));
    return n3 === 1 ? (r2 = i[t2 - 1], e.push(B18[r2 >> 2] + B18[r2 << 4 & 63] + "==")) : n3 === 2 && (r2 = (i[t2 - 2] << 8) + i[t2 - 1], e.push(B18[r2 >> 10] + B18[r2 >> 4 & 63] + B18[r2 << 2 & 63] + "=")), e.join("");
  }
});
var K = k((D12) => {
  D12.read = function(i, r2, t2, n3, e) {
    var o6, u12, f8 = e * 8 - n3 - 1, c13 = (1 << f8) - 1, l22 = c13 >> 1, s10 = -7, p7 = t2 ? e - 1 : 0, F12 = t2 ? -1 : 1, x17 = i[r2 + p7];
    for (p7 += F12, o6 = x17 & (1 << -s10) - 1, x17 >>= -s10, s10 += f8; s10 > 0; o6 = o6 * 256 + i[r2 + p7], p7 += F12, s10 -= 8)
      ;
    for (u12 = o6 & (1 << -s10) - 1, o6 >>= -s10, s10 += n3; s10 > 0; u12 = u12 * 256 + i[r2 + p7], p7 += F12, s10 -= 8)
      ;
    if (o6 === 0)
      o6 = 1 - l22;
    else {
      if (o6 === c13)
        return u12 ? NaN : (x17 ? -1 : 1) * (1 / 0);
      u12 = u12 + Math.pow(2, n3), o6 = o6 - l22;
    }
    return (x17 ? -1 : 1) * u12 * Math.pow(2, o6 - n3);
  };
  D12.write = function(i, r2, t2, n3, e, o6) {
    var u12, f8, c13, l22 = o6 * 8 - e - 1, s10 = (1 << l22) - 1, p7 = s10 >> 1, F12 = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x17 = n3 ? 0 : o6 - 1, M14 = n3 ? 1 : -1, ar2 = r2 < 0 || r2 === 0 && 1 / r2 < 0 ? 1 : 0;
    for (r2 = Math.abs(r2), isNaN(r2) || r2 === 1 / 0 ? (f8 = isNaN(r2) ? 1 : 0, u12 = s10) : (u12 = Math.floor(Math.log(r2) / Math.LN2), r2 * (c13 = Math.pow(2, -u12)) < 1 && (u12--, c13 *= 2), u12 + p7 >= 1 ? r2 += F12 / c13 : r2 += F12 * Math.pow(2, 1 - p7), r2 * c13 >= 2 && (u12++, c13 /= 2), u12 + p7 >= s10 ? (f8 = 0, u12 = s10) : u12 + p7 >= 1 ? (f8 = (r2 * c13 - 1) * Math.pow(2, e), u12 = u12 + p7) : (f8 = r2 * Math.pow(2, p7 - 1) * Math.pow(2, e), u12 = 0)); e >= 8; i[t2 + x17] = f8 & 255, x17 += M14, f8 /= 256, e -= 8)
      ;
    for (u12 = u12 << e | f8, l22 += e; l22 > 0; i[t2 + x17] = u12 & 255, x17 += M14, u12 /= 256, l22 -= 8)
      ;
    i[t2 + x17 - M14] |= ar2 * 128;
  };
});
var X = k((R13) => {
  "use strict";
  var $17 = J(), A14 = K(), Z2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  R13.Buffer = h16;
  R13.SlowBuffer = Nr;
  R13.INSPECT_MAX_BYTES = 50;
  var S14 = 2147483647;
  R13.kMaxLength = S14;
  h16.TYPED_ARRAY_SUPPORT = Cr();
  !h16.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Cr() {
    try {
      let i = new Uint8Array(1), r2 = {
        foo: function() {
          return 42;
        }
      };
      return Object.setPrototypeOf(r2, Uint8Array.prototype), Object.setPrototypeOf(i, r2), i.foo() === 42;
    } catch (i12) {
      return false;
    }
  }
  Object.defineProperty(h16.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!!h16.isBuffer(this))
        return this.buffer;
    }
  });
  Object.defineProperty(h16.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!!h16.isBuffer(this))
        return this.byteOffset;
    }
  });
  function d14(i) {
    if (i > S14)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    let r2 = new Uint8Array(i);
    return Object.setPrototypeOf(r2, h16.prototype), r2;
  }
  function h16(i, r2, t2) {
    if (typeof i == "number") {
      if (typeof r2 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return P13(i);
    }
    return Q9(i, r2, t2);
  }
  h16.poolSize = 8192;
  function Q9(i, r2, t2) {
    if (typeof i == "string")
      return Sr(i, r2);
    if (ArrayBuffer.isView(i))
      return Lr(i);
    if (i == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    if (E15(i, ArrayBuffer) || i && E15(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (E15(i, SharedArrayBuffer) || i && E15(i.buffer, SharedArrayBuffer)))
      return G11(i, r2, t2);
    if (typeof i == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n3 = i.valueOf && i.valueOf();
    if (n3 != null && n3 !== i)
      return h16.from(n3, r2, t2);
    let e = Mr(i);
    if (e)
      return e;
    if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return h16.from(i[Symbol.toPrimitive]("string"), r2, t2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
  }
  h16.from = function(i, r2, t2) {
    return Q9(i, r2, t2);
  };
  Object.setPrototypeOf(h16.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(h16, Uint8Array);
  function v19(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function _r(i, r2, t2) {
    return v19(i), i <= 0 ? d14(i) : r2 !== void 0 ? typeof t2 == "string" ? d14(i).fill(r2, t2) : d14(i).fill(r2) : d14(i);
  }
  h16.alloc = function(i, r2, t2) {
    return _r(i, r2, t2);
  };
  function P13(i) {
    return v19(i), d14(i < 0 ? 0 : Y7(i) | 0);
  }
  h16.allocUnsafe = function(i) {
    return P13(i);
  };
  h16.allocUnsafeSlow = function(i) {
    return P13(i);
  };
  function Sr(i, r2) {
    if ((typeof r2 != "string" || r2 === "") && (r2 = "utf8"), !h16.isEncoding(r2))
      throw new TypeError("Unknown encoding: " + r2);
    let t2 = rr2(i, r2) | 0, n3 = d14(t2), e = n3.write(i, r2);
    return e !== t2 && (n3 = n3.slice(0, e)), n3;
  }
  function O9(i) {
    let r2 = i.length < 0 ? 0 : Y7(i.length) | 0, t2 = d14(r2);
    for (let n3 = 0; n3 < r2; n3 += 1)
      t2[n3] = i[n3] & 255;
    return t2;
  }
  function Lr(i) {
    if (E15(i, Uint8Array)) {
      let r2 = new Uint8Array(i);
      return G11(r2.buffer, r2.byteOffset, r2.byteLength);
    }
    return O9(i);
  }
  function G11(i, r2, t2) {
    if (r2 < 0 || i.byteLength < r2)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < r2 + (t2 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n3;
    return r2 === void 0 && t2 === void 0 ? n3 = new Uint8Array(i) : t2 === void 0 ? n3 = new Uint8Array(i, r2) : n3 = new Uint8Array(i, r2, t2), Object.setPrototypeOf(n3, h16.prototype), n3;
  }
  function Mr(i) {
    if (h16.isBuffer(i)) {
      let r2 = Y7(i.length) | 0, t2 = d14(r2);
      return t2.length === 0 || i.copy(t2, 0, 0, r2), t2;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || j13(i.length) ? d14(0) : O9(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return O9(i.data);
  }
  function Y7(i) {
    if (i >= S14)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S14.toString(16) + " bytes");
    return i | 0;
  }
  function Nr(i) {
    return +i != i && (i = 0), h16.alloc(+i);
  }
  h16.isBuffer = function(r2) {
    return r2 != null && r2._isBuffer === true && r2 !== h16.prototype;
  };
  h16.compare = function(r2, t2) {
    if (E15(r2, Uint8Array) && (r2 = h16.from(r2, r2.offset, r2.byteLength)), E15(t2, Uint8Array) && (t2 = h16.from(t2, t2.offset, t2.byteLength)), !h16.isBuffer(r2) || !h16.isBuffer(t2))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r2 === t2)
      return 0;
    let n3 = r2.length, e = t2.length;
    for (let o6 = 0, u12 = Math.min(n3, e); o6 < u12; ++o6)
      if (r2[o6] !== t2[o6]) {
        n3 = r2[o6], e = t2[o6];
        break;
      }
    return n3 < e ? -1 : e < n3 ? 1 : 0;
  };
  h16.isEncoding = function(r2) {
    switch (String(r2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  h16.concat = function(r2, t2) {
    if (!Array.isArray(r2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r2.length === 0)
      return h16.alloc(0);
    let n3;
    if (t2 === void 0)
      for (t2 = 0, n3 = 0; n3 < r2.length; ++n3)
        t2 += r2[n3].length;
    let e = h16.allocUnsafe(t2), o6 = 0;
    for (n3 = 0; n3 < r2.length; ++n3) {
      let u12 = r2[n3];
      if (E15(u12, Uint8Array))
        o6 + u12.length > e.length ? (h16.isBuffer(u12) || (u12 = h16.from(u12)), u12.copy(e, o6)) : Uint8Array.prototype.set.call(e, u12, o6);
      else if (h16.isBuffer(u12))
        u12.copy(e, o6);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      o6 += u12.length;
    }
    return e;
  };
  function rr2(i, r2) {
    if (h16.isBuffer(i))
      return i.length;
    if (ArrayBuffer.isView(i) || E15(i, ArrayBuffer))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
    let t2 = i.length, n3 = arguments.length > 2 && arguments[2] === true;
    if (!n3 && t2 === 0)
      return 0;
    let e = false;
    for (; ; )
      switch (r2) {
        case "ascii":
        case "latin1":
        case "binary":
          return t2;
        case "utf8":
        case "utf-8":
          return W2(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t2 * 2;
        case "hex":
          return t2 >>> 1;
        case "base64":
          return lr(i).length;
        default:
          if (e)
            return n3 ? -1 : W2(i).length;
          r2 = ("" + r2).toLowerCase(), e = true;
      }
  }
  h16.byteLength = rr2;
  function kr2(i, r2, t2) {
    let n3 = false;
    if ((r2 === void 0 || r2 < 0) && (r2 = 0), r2 > this.length || ((t2 === void 0 || t2 > this.length) && (t2 = this.length), t2 <= 0) || (t2 >>>= 0, r2 >>>= 0, t2 <= r2))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return jr(this, r2, t2);
        case "utf8":
        case "utf-8":
          return nr2(this, r2, t2);
        case "ascii":
          return qr2(this, r2, t2);
        case "latin1":
        case "binary":
          return Wr(this, r2, t2);
        case "base64":
          return Gr(this, r2, t2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Xr(this, r2, t2);
        default:
          if (n3)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), n3 = true;
      }
  }
  h16.prototype._isBuffer = true;
  function I13(i, r2, t2) {
    let n3 = i[r2];
    i[r2] = i[t2], i[t2] = n3;
  }
  h16.prototype.swap16 = function() {
    let r2 = this.length;
    if (r2 % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t2 = 0; t2 < r2; t2 += 2)
      I13(this, t2, t2 + 1);
    return this;
  };
  h16.prototype.swap32 = function() {
    let r2 = this.length;
    if (r2 % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t2 = 0; t2 < r2; t2 += 4)
      I13(this, t2, t2 + 3), I13(this, t2 + 1, t2 + 2);
    return this;
  };
  h16.prototype.swap64 = function() {
    let r2 = this.length;
    if (r2 % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t2 = 0; t2 < r2; t2 += 8)
      I13(this, t2, t2 + 7), I13(this, t2 + 1, t2 + 6), I13(this, t2 + 2, t2 + 5), I13(this, t2 + 3, t2 + 4);
    return this;
  };
  h16.prototype.toString = function() {
    let r2 = this.length;
    return r2 === 0 ? "" : arguments.length === 0 ? nr2(this, 0, r2) : kr2.apply(this, arguments);
  };
  h16.prototype.toLocaleString = h16.prototype.toString;
  h16.prototype.equals = function(r2) {
    if (!h16.isBuffer(r2))
      throw new TypeError("Argument must be a Buffer");
    return this === r2 ? true : h16.compare(this, r2) === 0;
  };
  h16.prototype.inspect = function() {
    let r2 = "", t2 = R13.INSPECT_MAX_BYTES;
    return r2 = this.toString("hex", 0, t2).replace(/(.{2})/g, "$1 ").trim(), this.length > t2 && (r2 += " ... "), "<Buffer " + r2 + ">";
  };
  Z2 && (h16.prototype[Z2] = h16.prototype.inspect);
  h16.prototype.compare = function(r2, t2, n3, e, o6) {
    if (E15(r2, Uint8Array) && (r2 = h16.from(r2, r2.offset, r2.byteLength)), !h16.isBuffer(r2))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r2);
    if (t2 === void 0 && (t2 = 0), n3 === void 0 && (n3 = r2 ? r2.length : 0), e === void 0 && (e = 0), o6 === void 0 && (o6 = this.length), t2 < 0 || n3 > r2.length || e < 0 || o6 > this.length)
      throw new RangeError("out of range index");
    if (e >= o6 && t2 >= n3)
      return 0;
    if (e >= o6)
      return -1;
    if (t2 >= n3)
      return 1;
    if (t2 >>>= 0, n3 >>>= 0, e >>>= 0, o6 >>>= 0, this === r2)
      return 0;
    let u12 = o6 - e, f8 = n3 - t2, c13 = Math.min(u12, f8), l22 = this.slice(e, o6), s10 = r2.slice(t2, n3);
    for (let p7 = 0; p7 < c13; ++p7)
      if (l22[p7] !== s10[p7]) {
        u12 = l22[p7], f8 = s10[p7];
        break;
      }
    return u12 < f8 ? -1 : f8 < u12 ? 1 : 0;
  };
  function tr2(i, r2, t2, n3, e) {
    if (i.length === 0)
      return -1;
    if (typeof t2 == "string" ? (n3 = t2, t2 = 0) : t2 > 2147483647 ? t2 = 2147483647 : t2 < -2147483648 && (t2 = -2147483648), t2 = +t2, j13(t2) && (t2 = e ? 0 : i.length - 1), t2 < 0 && (t2 = i.length + t2), t2 >= i.length) {
      if (e)
        return -1;
      t2 = i.length - 1;
    } else if (t2 < 0)
      if (e)
        t2 = 0;
      else
        return -1;
    if (typeof r2 == "string" && (r2 = h16.from(r2, n3)), h16.isBuffer(r2))
      return r2.length === 0 ? -1 : ir2(i, r2, t2, n3, e);
    if (typeof r2 == "number")
      return r2 = r2 & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r2, t2) : Uint8Array.prototype.lastIndexOf.call(i, r2, t2) : ir2(i, [
        r2
      ], t2, n3, e);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ir2(i, r2, t2, n3, e) {
    let o6 = 1, u12 = i.length, f8 = r2.length;
    if (n3 !== void 0 && (n3 = String(n3).toLowerCase(), n3 === "ucs2" || n3 === "ucs-2" || n3 === "utf16le" || n3 === "utf-16le")) {
      if (i.length < 2 || r2.length < 2)
        return -1;
      o6 = 2, u12 /= 2, f8 /= 2, t2 /= 2;
    }
    function c13(s10, p7) {
      return o6 === 1 ? s10[p7] : s10.readUInt16BE(p7 * o6);
    }
    let l22;
    if (e) {
      let s10 = -1;
      for (l22 = t2; l22 < u12; l22++)
        if (c13(i, l22) === c13(r2, s10 === -1 ? 0 : l22 - s10)) {
          if (s10 === -1 && (s10 = l22), l22 - s10 + 1 === f8)
            return s10 * o6;
        } else
          s10 !== -1 && (l22 -= l22 - s10), s10 = -1;
    } else
      for (t2 + f8 > u12 && (t2 = u12 - f8), l22 = t2; l22 >= 0; l22--) {
        let s12 = true;
        for (let p7 = 0; p7 < f8; p7++)
          if (c13(i, l22 + p7) !== c13(r2, p7)) {
            s12 = false;
            break;
          }
        if (s12)
          return l22;
      }
    return -1;
  }
  h16.prototype.includes = function(r2, t2, n3) {
    return this.indexOf(r2, t2, n3) !== -1;
  };
  h16.prototype.indexOf = function(r2, t2, n3) {
    return tr2(this, r2, t2, n3, true);
  };
  h16.prototype.lastIndexOf = function(r2, t2, n3) {
    return tr2(this, r2, t2, n3, false);
  };
  function br3(i, r2, t2, n3) {
    t2 = Number(t2) || 0;
    let e = i.length - t2;
    n3 ? (n3 = Number(n3), n3 > e && (n3 = e)) : n3 = e;
    let o6 = r2.length;
    n3 > o6 / 2 && (n3 = o6 / 2);
    let u12;
    for (u12 = 0; u12 < n3; ++u12) {
      let f8 = parseInt(r2.substr(u12 * 2, 2), 16);
      if (j13(f8))
        return u12;
      i[t2 + u12] = f8;
    }
    return u12;
  }
  function Dr2(i, r2, t2, n3) {
    return L18(W2(r2, i.length - t2), i, t2, n3);
  }
  function $r(i, r2, t2, n3) {
    return L18(Jr(r2), i, t2, n3);
  }
  function Pr2(i, r2, t2, n3) {
    return L18(lr(r2), i, t2, n3);
  }
  function Or(i, r2, t2, n3) {
    return L18(Kr(r2, i.length - t2), i, t2, n3);
  }
  h16.prototype.write = function(r2, t2, n3, e) {
    if (t2 === void 0)
      e = "utf8", n3 = this.length, t2 = 0;
    else if (n3 === void 0 && typeof t2 == "string")
      e = t2, n3 = this.length, t2 = 0;
    else if (isFinite(t2))
      t2 = t2 >>> 0, isFinite(n3) ? (n3 = n3 >>> 0, e === void 0 && (e = "utf8")) : (e = n3, n3 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let o6 = this.length - t2;
    if ((n3 === void 0 || n3 > o6) && (n3 = o6), r2.length > 0 && (n3 < 0 || t2 < 0) || t2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    e || (e = "utf8");
    let u12 = false;
    for (; ; )
      switch (e) {
        case "hex":
          return br3(this, r2, t2, n3);
        case "utf8":
        case "utf-8":
          return Dr2(this, r2, t2, n3);
        case "ascii":
        case "latin1":
        case "binary":
          return $r(this, r2, t2, n3);
        case "base64":
          return Pr2(this, r2, t2, n3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Or(this, r2, t2, n3);
        default:
          if (u12)
            throw new TypeError("Unknown encoding: " + e);
          e = ("" + e).toLowerCase(), u12 = true;
      }
  };
  h16.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Gr(i, r2, t2) {
    return r2 === 0 && t2 === i.length ? $17.fromByteArray(i) : $17.fromByteArray(i.slice(r2, t2));
  }
  function nr2(i, r2, t2) {
    t2 = Math.min(i.length, t2);
    let n3 = [], e = r2;
    for (; e < t2; ) {
      let o6 = i[e], u12 = null, f8 = o6 > 239 ? 4 : o6 > 223 ? 3 : o6 > 191 ? 2 : 1;
      if (e + f8 <= t2) {
        let c13, l22, s10, p7;
        switch (f8) {
          case 1:
            o6 < 128 && (u12 = o6);
            break;
          case 2:
            c13 = i[e + 1], (c13 & 192) == 128 && (p7 = (o6 & 31) << 6 | c13 & 63, p7 > 127 && (u12 = p7));
            break;
          case 3:
            c13 = i[e + 1], l22 = i[e + 2], (c13 & 192) == 128 && (l22 & 192) == 128 && (p7 = (o6 & 15) << 12 | (c13 & 63) << 6 | l22 & 63, p7 > 2047 && (p7 < 55296 || p7 > 57343) && (u12 = p7));
            break;
          case 4:
            c13 = i[e + 1], l22 = i[e + 2], s10 = i[e + 3], (c13 & 192) == 128 && (l22 & 192) == 128 && (s10 & 192) == 128 && (p7 = (o6 & 15) << 18 | (c13 & 63) << 12 | (l22 & 63) << 6 | s10 & 63, p7 > 65535 && p7 < 1114112 && (u12 = p7));
        }
      }
      u12 === null ? (u12 = 65533, f8 = 1) : u12 > 65535 && (u12 -= 65536, n3.push(u12 >>> 10 & 1023 | 55296), u12 = 56320 | u12 & 1023), n3.push(u12), e += f8;
    }
    return Yr(n3);
  }
  var er2 = 4096;
  function Yr(i) {
    let r2 = i.length;
    if (r2 <= er2)
      return String.fromCharCode.apply(String, i);
    let t2 = "", n3 = 0;
    for (; n3 < r2; )
      t2 += String.fromCharCode.apply(String, i.slice(n3, n3 += er2));
    return t2;
  }
  function qr2(i, r2, t2) {
    let n3 = "";
    t2 = Math.min(i.length, t2);
    for (let e = r2; e < t2; ++e)
      n3 += String.fromCharCode(i[e] & 127);
    return n3;
  }
  function Wr(i, r2, t2) {
    let n3 = "";
    t2 = Math.min(i.length, t2);
    for (let e = r2; e < t2; ++e)
      n3 += String.fromCharCode(i[e]);
    return n3;
  }
  function jr(i, r2, t2) {
    let n3 = i.length;
    (!r2 || r2 < 0) && (r2 = 0), (!t2 || t2 < 0 || t2 > n3) && (t2 = n3);
    let e = "";
    for (let o6 = r2; o6 < t2; ++o6)
      e += Zr[i[o6]];
    return e;
  }
  function Xr(i, r2, t2) {
    let n3 = i.slice(r2, t2), e = "";
    for (let o6 = 0; o6 < n3.length - 1; o6 += 2)
      e += String.fromCharCode(n3[o6] + n3[o6 + 1] * 256);
    return e;
  }
  h16.prototype.slice = function(r2, t2) {
    let n3 = this.length;
    r2 = ~~r2, t2 = t2 === void 0 ? n3 : ~~t2, r2 < 0 ? (r2 += n3, r2 < 0 && (r2 = 0)) : r2 > n3 && (r2 = n3), t2 < 0 ? (t2 += n3, t2 < 0 && (t2 = 0)) : t2 > n3 && (t2 = n3), t2 < r2 && (t2 = r2);
    let e = this.subarray(r2, t2);
    return Object.setPrototypeOf(e, h16.prototype), e;
  };
  function a7(i, r2, t2) {
    if (i % 1 != 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + r2 > t2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  h16.prototype.readUintLE = h16.prototype.readUIntLE = function(r2, t2, n3) {
    r2 = r2 >>> 0, t2 = t2 >>> 0, n3 || a7(r2, t2, this.length);
    let e = this[r2], o6 = 1, u12 = 0;
    for (; ++u12 < t2 && (o6 *= 256); )
      e += this[r2 + u12] * o6;
    return e;
  };
  h16.prototype.readUintBE = h16.prototype.readUIntBE = function(r2, t2, n3) {
    r2 = r2 >>> 0, t2 = t2 >>> 0, n3 || a7(r2, t2, this.length);
    let e = this[r2 + --t2], o6 = 1;
    for (; t2 > 0 && (o6 *= 256); )
      e += this[r2 + --t2] * o6;
    return e;
  };
  h16.prototype.readUint8 = h16.prototype.readUInt8 = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 1, this.length), this[r2];
  };
  h16.prototype.readUint16LE = h16.prototype.readUInt16LE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 2, this.length), this[r2] | this[r2 + 1] << 8;
  };
  h16.prototype.readUint16BE = h16.prototype.readUInt16BE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 2, this.length), this[r2] << 8 | this[r2 + 1];
  };
  h16.prototype.readUint32LE = h16.prototype.readUInt32LE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 4, this.length), (this[r2] | this[r2 + 1] << 8 | this[r2 + 2] << 16) + this[r2 + 3] * 16777216;
  };
  h16.prototype.readUint32BE = h16.prototype.readUInt32BE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 4, this.length), this[r2] * 16777216 + (this[r2 + 1] << 16 | this[r2 + 2] << 8 | this[r2 + 3]);
  };
  h16.prototype.readBigUInt64LE = g17(function(r2) {
    r2 = r2 >>> 0, T12(r2, "offset");
    let t2 = this[r2], n3 = this[r2 + 7];
    (t2 === void 0 || n3 === void 0) && C11(r2, this.length - 8);
    let e = t2 + this[++r2] * 2 ** 8 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 24, o6 = this[++r2] + this[++r2] * 2 ** 8 + this[++r2] * 2 ** 16 + n3 * 2 ** 24;
    return BigInt(e) + (BigInt(o6) << BigInt(32));
  });
  h16.prototype.readBigUInt64BE = g17(function(r2) {
    r2 = r2 >>> 0, T12(r2, "offset");
    let t2 = this[r2], n3 = this[r2 + 7];
    (t2 === void 0 || n3 === void 0) && C11(r2, this.length - 8);
    let e = t2 * 2 ** 24 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + this[++r2], o6 = this[++r2] * 2 ** 24 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + n3;
    return (BigInt(e) << BigInt(32)) + BigInt(o6);
  });
  h16.prototype.readIntLE = function(r2, t2, n3) {
    r2 = r2 >>> 0, t2 = t2 >>> 0, n3 || a7(r2, t2, this.length);
    let e = this[r2], o6 = 1, u12 = 0;
    for (; ++u12 < t2 && (o6 *= 256); )
      e += this[r2 + u12] * o6;
    return o6 *= 128, e >= o6 && (e -= Math.pow(2, 8 * t2)), e;
  };
  h16.prototype.readIntBE = function(r2, t2, n3) {
    r2 = r2 >>> 0, t2 = t2 >>> 0, n3 || a7(r2, t2, this.length);
    let e = t2, o6 = 1, u12 = this[r2 + --e];
    for (; e > 0 && (o6 *= 256); )
      u12 += this[r2 + --e] * o6;
    return o6 *= 128, u12 >= o6 && (u12 -= Math.pow(2, 8 * t2)), u12;
  };
  h16.prototype.readInt8 = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 1, this.length), this[r2] & 128 ? (255 - this[r2] + 1) * -1 : this[r2];
  };
  h16.prototype.readInt16LE = function(r2, t2) {
    r2 = r2 >>> 0, t2 || a7(r2, 2, this.length);
    let n3 = this[r2] | this[r2 + 1] << 8;
    return n3 & 32768 ? n3 | 4294901760 : n3;
  };
  h16.prototype.readInt16BE = function(r2, t2) {
    r2 = r2 >>> 0, t2 || a7(r2, 2, this.length);
    let n3 = this[r2 + 1] | this[r2] << 8;
    return n3 & 32768 ? n3 | 4294901760 : n3;
  };
  h16.prototype.readInt32LE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 4, this.length), this[r2] | this[r2 + 1] << 8 | this[r2 + 2] << 16 | this[r2 + 3] << 24;
  };
  h16.prototype.readInt32BE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 4, this.length), this[r2] << 24 | this[r2 + 1] << 16 | this[r2 + 2] << 8 | this[r2 + 3];
  };
  h16.prototype.readBigInt64LE = g17(function(r2) {
    r2 = r2 >>> 0, T12(r2, "offset");
    let t2 = this[r2], n3 = this[r2 + 7];
    (t2 === void 0 || n3 === void 0) && C11(r2, this.length - 8);
    let e = this[r2 + 4] + this[r2 + 5] * 2 ** 8 + this[r2 + 6] * 2 ** 16 + (n3 << 24);
    return (BigInt(e) << BigInt(32)) + BigInt(t2 + this[++r2] * 2 ** 8 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 24);
  });
  h16.prototype.readBigInt64BE = g17(function(r2) {
    r2 = r2 >>> 0, T12(r2, "offset");
    let t2 = this[r2], n3 = this[r2 + 7];
    (t2 === void 0 || n3 === void 0) && C11(r2, this.length - 8);
    let e = (t2 << 24) + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + this[++r2];
    return (BigInt(e) << BigInt(32)) + BigInt(this[++r2] * 2 ** 24 + this[++r2] * 2 ** 16 + this[++r2] * 2 ** 8 + n3);
  });
  h16.prototype.readFloatLE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 4, this.length), A14.read(this, r2, true, 23, 4);
  };
  h16.prototype.readFloatBE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 4, this.length), A14.read(this, r2, false, 23, 4);
  };
  h16.prototype.readDoubleLE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 8, this.length), A14.read(this, r2, true, 52, 8);
  };
  h16.prototype.readDoubleBE = function(r2, t2) {
    return r2 = r2 >>> 0, t2 || a7(r2, 8, this.length), A14.read(this, r2, false, 52, 8);
  };
  function y16(i, r2, t2, n3, e, o6) {
    if (!h16.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r2 > e || r2 < o6)
      throw new RangeError('"value" argument is out of bounds');
    if (t2 + n3 > i.length)
      throw new RangeError("Index out of range");
  }
  h16.prototype.writeUintLE = h16.prototype.writeUIntLE = function(r2, t2, n3, e) {
    if (r2 = +r2, t2 = t2 >>> 0, n3 = n3 >>> 0, !e) {
      let f8 = Math.pow(2, 8 * n3) - 1;
      y16(this, r2, t2, n3, f8, 0);
    }
    let o6 = 1, u12 = 0;
    for (this[t2] = r2 & 255; ++u12 < n3 && (o6 *= 256); )
      this[t2 + u12] = r2 / o6 & 255;
    return t2 + n3;
  };
  h16.prototype.writeUintBE = h16.prototype.writeUIntBE = function(r2, t2, n3, e) {
    if (r2 = +r2, t2 = t2 >>> 0, n3 = n3 >>> 0, !e) {
      let f8 = Math.pow(2, 8 * n3) - 1;
      y16(this, r2, t2, n3, f8, 0);
    }
    let o6 = n3 - 1, u12 = 1;
    for (this[t2 + o6] = r2 & 255; --o6 >= 0 && (u12 *= 256); )
      this[t2 + o6] = r2 / u12 & 255;
    return t2 + n3;
  };
  h16.prototype.writeUint8 = h16.prototype.writeUInt8 = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 1, 255, 0), this[t2] = r2 & 255, t2 + 1;
  };
  h16.prototype.writeUint16LE = h16.prototype.writeUInt16LE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 2, 65535, 0), this[t2] = r2 & 255, this[t2 + 1] = r2 >>> 8, t2 + 2;
  };
  h16.prototype.writeUint16BE = h16.prototype.writeUInt16BE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 2, 65535, 0), this[t2] = r2 >>> 8, this[t2 + 1] = r2 & 255, t2 + 2;
  };
  h16.prototype.writeUint32LE = h16.prototype.writeUInt32LE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 4, 4294967295, 0), this[t2 + 3] = r2 >>> 24, this[t2 + 2] = r2 >>> 16, this[t2 + 1] = r2 >>> 8, this[t2] = r2 & 255, t2 + 4;
  };
  h16.prototype.writeUint32BE = h16.prototype.writeUInt32BE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 4, 4294967295, 0), this[t2] = r2 >>> 24, this[t2 + 1] = r2 >>> 16, this[t2 + 2] = r2 >>> 8, this[t2 + 3] = r2 & 255, t2 + 4;
  };
  function or3(i, r2, t2, n3, e) {
    sr(r2, n3, e, i, t2, 7);
    let o6 = Number(r2 & BigInt(4294967295));
    i[t2++] = o6, o6 = o6 >> 8, i[t2++] = o6, o6 = o6 >> 8, i[t2++] = o6, o6 = o6 >> 8, i[t2++] = o6;
    let u12 = Number(r2 >> BigInt(32) & BigInt(4294967295));
    return i[t2++] = u12, u12 = u12 >> 8, i[t2++] = u12, u12 = u12 >> 8, i[t2++] = u12, u12 = u12 >> 8, i[t2++] = u12, t2;
  }
  function ur(i, r2, t2, n3, e) {
    sr(r2, n3, e, i, t2, 7);
    let o6 = Number(r2 & BigInt(4294967295));
    i[t2 + 7] = o6, o6 = o6 >> 8, i[t2 + 6] = o6, o6 = o6 >> 8, i[t2 + 5] = o6, o6 = o6 >> 8, i[t2 + 4] = o6;
    let u12 = Number(r2 >> BigInt(32) & BigInt(4294967295));
    return i[t2 + 3] = u12, u12 = u12 >> 8, i[t2 + 2] = u12, u12 = u12 >> 8, i[t2 + 1] = u12, u12 = u12 >> 8, i[t2] = u12, t2 + 8;
  }
  h16.prototype.writeBigUInt64LE = g17(function(r2, t2 = 0) {
    return or3(this, r2, t2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  h16.prototype.writeBigUInt64BE = g17(function(r2, t2 = 0) {
    return ur(this, r2, t2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  h16.prototype.writeIntLE = function(r2, t2, n3, e) {
    if (r2 = +r2, t2 = t2 >>> 0, !e) {
      let c13 = Math.pow(2, 8 * n3 - 1);
      y16(this, r2, t2, n3, c13 - 1, -c13);
    }
    let o6 = 0, u12 = 1, f8 = 0;
    for (this[t2] = r2 & 255; ++o6 < n3 && (u12 *= 256); )
      r2 < 0 && f8 === 0 && this[t2 + o6 - 1] !== 0 && (f8 = 1), this[t2 + o6] = (r2 / u12 >> 0) - f8 & 255;
    return t2 + n3;
  };
  h16.prototype.writeIntBE = function(r2, t2, n3, e) {
    if (r2 = +r2, t2 = t2 >>> 0, !e) {
      let c13 = Math.pow(2, 8 * n3 - 1);
      y16(this, r2, t2, n3, c13 - 1, -c13);
    }
    let o6 = n3 - 1, u12 = 1, f8 = 0;
    for (this[t2 + o6] = r2 & 255; --o6 >= 0 && (u12 *= 256); )
      r2 < 0 && f8 === 0 && this[t2 + o6 + 1] !== 0 && (f8 = 1), this[t2 + o6] = (r2 / u12 >> 0) - f8 & 255;
    return t2 + n3;
  };
  h16.prototype.writeInt8 = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 1, 127, -128), r2 < 0 && (r2 = 255 + r2 + 1), this[t2] = r2 & 255, t2 + 1;
  };
  h16.prototype.writeInt16LE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 2, 32767, -32768), this[t2] = r2 & 255, this[t2 + 1] = r2 >>> 8, t2 + 2;
  };
  h16.prototype.writeInt16BE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 2, 32767, -32768), this[t2] = r2 >>> 8, this[t2 + 1] = r2 & 255, t2 + 2;
  };
  h16.prototype.writeInt32LE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 4, 2147483647, -2147483648), this[t2] = r2 & 255, this[t2 + 1] = r2 >>> 8, this[t2 + 2] = r2 >>> 16, this[t2 + 3] = r2 >>> 24, t2 + 4;
  };
  h16.prototype.writeInt32BE = function(r2, t2, n3) {
    return r2 = +r2, t2 = t2 >>> 0, n3 || y16(this, r2, t2, 4, 2147483647, -2147483648), r2 < 0 && (r2 = 4294967295 + r2 + 1), this[t2] = r2 >>> 24, this[t2 + 1] = r2 >>> 16, this[t2 + 2] = r2 >>> 8, this[t2 + 3] = r2 & 255, t2 + 4;
  };
  h16.prototype.writeBigInt64LE = g17(function(r2, t2 = 0) {
    return or3(this, r2, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  h16.prototype.writeBigInt64BE = g17(function(r2, t2 = 0) {
    return ur(this, r2, t2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function hr2(i, r2, t2, n3, e, o6) {
    if (t2 + n3 > i.length)
      throw new RangeError("Index out of range");
    if (t2 < 0)
      throw new RangeError("Index out of range");
  }
  function fr(i, r2, t2, n3, e) {
    return r2 = +r2, t2 = t2 >>> 0, e || hr2(i, r2, t2, 4, 34028234663852886e22, -34028234663852886e22), A14.write(i, r2, t2, n3, 23, 4), t2 + 4;
  }
  h16.prototype.writeFloatLE = function(r2, t2, n3) {
    return fr(this, r2, t2, true, n3);
  };
  h16.prototype.writeFloatBE = function(r2, t2, n3) {
    return fr(this, r2, t2, false, n3);
  };
  function cr(i, r2, t2, n3, e) {
    return r2 = +r2, t2 = t2 >>> 0, e || hr2(i, r2, t2, 8, 17976931348623157e292, -17976931348623157e292), A14.write(i, r2, t2, n3, 52, 8), t2 + 8;
  }
  h16.prototype.writeDoubleLE = function(r2, t2, n3) {
    return cr(this, r2, t2, true, n3);
  };
  h16.prototype.writeDoubleBE = function(r2, t2, n3) {
    return cr(this, r2, t2, false, n3);
  };
  h16.prototype.copy = function(r2, t2, n3, e) {
    if (!h16.isBuffer(r2))
      throw new TypeError("argument should be a Buffer");
    if (n3 || (n3 = 0), !e && e !== 0 && (e = this.length), t2 >= r2.length && (t2 = r2.length), t2 || (t2 = 0), e > 0 && e < n3 && (e = n3), e === n3 || r2.length === 0 || this.length === 0)
      return 0;
    if (t2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (n3 < 0 || n3 >= this.length)
      throw new RangeError("Index out of range");
    if (e < 0)
      throw new RangeError("sourceEnd out of bounds");
    e > this.length && (e = this.length), r2.length - t2 < e - n3 && (e = r2.length - t2 + n3);
    let o6 = e - n3;
    return this === r2 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t2, n3, e) : Uint8Array.prototype.set.call(r2, this.subarray(n3, e), t2), o6;
  };
  h16.prototype.fill = function(r2, t2, n3, e) {
    if (typeof r2 == "string") {
      if (typeof t2 == "string" ? (e = t2, t2 = 0, n3 = this.length) : typeof n3 == "string" && (e = n3, n3 = this.length), e !== void 0 && typeof e != "string")
        throw new TypeError("encoding must be a string");
      if (typeof e == "string" && !h16.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      if (r2.length === 1) {
        let u12 = r2.charCodeAt(0);
        (e === "utf8" && u12 < 128 || e === "latin1") && (r2 = u12);
      }
    } else
      typeof r2 == "number" ? r2 = r2 & 255 : typeof r2 == "boolean" && (r2 = Number(r2));
    if (t2 < 0 || this.length < t2 || this.length < n3)
      throw new RangeError("Out of range index");
    if (n3 <= t2)
      return this;
    t2 = t2 >>> 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, r2 || (r2 = 0);
    let o6;
    if (typeof r2 == "number")
      for (o6 = t2; o6 < n3; ++o6)
        this[o6] = r2;
    else {
      let u12 = h16.isBuffer(r2) ? r2 : h16.from(r2, e), f8 = u12.length;
      if (f8 === 0)
        throw new TypeError('The value "' + r2 + '" is invalid for argument "value"');
      for (o6 = 0; o6 < n3 - t2; ++o6)
        this[o6 + t2] = u12[o6 % f8];
    }
    return this;
  };
  var U7 = {};
  function q15(i, r2, t2) {
    U7[i] = class extends t2 {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: r2.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(e) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: e,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  q15("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
    return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  q15("ERR_INVALID_ARG_TYPE", function(i, r2) {
    return `The "${i}" argument must be of type number. Received type ${typeof r2}`;
  }, TypeError);
  q15("ERR_OUT_OF_RANGE", function(i, r2, t2) {
    let n3 = `The value of "${i}" is out of range.`, e = t2;
    return Number.isInteger(t2) && Math.abs(t2) > 2 ** 32 ? e = pr2(String(t2)) : typeof t2 == "bigint" && (e = String(t2), (t2 > BigInt(2) ** BigInt(32) || t2 < -(BigInt(2) ** BigInt(32))) && (e = pr2(e)), e += "n"), n3 += ` It must be ${r2}. Received ${e}`, n3;
  }, RangeError);
  function pr2(i) {
    let r2 = "", t2 = i.length, n3 = i[0] === "-" ? 1 : 0;
    for (; t2 >= n3 + 4; t2 -= 3)
      r2 = `_${i.slice(t2 - 3, t2)}${r2}`;
    return `${i.slice(0, t2)}${r2}`;
  }
  function Hr2(i, r2, t2) {
    T12(r2, "offset"), (i[r2] === void 0 || i[r2 + t2] === void 0) && C11(r2, i.length - (t2 + 1));
  }
  function sr(i, r2, t2, n3, e, o6) {
    if (i > t2 || i < r2) {
      let u12 = typeof r2 == "bigint" ? "n" : "", f8;
      throw o6 > 3 ? r2 === 0 || r2 === BigInt(0) ? f8 = `>= 0${u12} and < 2${u12} ** ${(o6 + 1) * 8}${u12}` : f8 = `>= -(2${u12} ** ${(o6 + 1) * 8 - 1}${u12}) and < 2 ** ${(o6 + 1) * 8 - 1}${u12}` : f8 = `>= ${r2}${u12} and <= ${t2}${u12}`, new U7.ERR_OUT_OF_RANGE("value", f8, i);
    }
    Hr2(n3, e, o6);
  }
  function T12(i, r2) {
    if (typeof i != "number")
      throw new U7.ERR_INVALID_ARG_TYPE(r2, "number", i);
  }
  function C11(i, r2, t2) {
    throw Math.floor(i) !== i ? (T12(i, t2), new U7.ERR_OUT_OF_RANGE(t2 || "offset", "an integer", i)) : r2 < 0 ? new U7.ERR_BUFFER_OUT_OF_BOUNDS() : new U7.ERR_OUT_OF_RANGE(t2 || "offset", `>= ${t2 ? 1 : 0} and <= ${r2}`, i);
  }
  var Vr = /[^+/0-9A-Za-z-_]/g;
  function zr(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Vr, ""), i.length < 2)
      return "";
    for (; i.length % 4 != 0; )
      i = i + "=";
    return i;
  }
  function W2(i, r2) {
    r2 = r2 || 1 / 0;
    let t2, n3 = i.length, e = null, o6 = [];
    for (let u12 = 0; u12 < n3; ++u12) {
      if (t2 = i.charCodeAt(u12), t2 > 55295 && t2 < 57344) {
        if (!e) {
          if (t2 > 56319) {
            (r2 -= 3) > -1 && o6.push(239, 191, 189);
            continue;
          } else if (u12 + 1 === n3) {
            (r2 -= 3) > -1 && o6.push(239, 191, 189);
            continue;
          }
          e = t2;
          continue;
        }
        if (t2 < 56320) {
          (r2 -= 3) > -1 && o6.push(239, 191, 189), e = t2;
          continue;
        }
        t2 = (e - 55296 << 10 | t2 - 56320) + 65536;
      } else
        e && (r2 -= 3) > -1 && o6.push(239, 191, 189);
      if (e = null, t2 < 128) {
        if ((r2 -= 1) < 0)
          break;
        o6.push(t2);
      } else if (t2 < 2048) {
        if ((r2 -= 2) < 0)
          break;
        o6.push(t2 >> 6 | 192, t2 & 63 | 128);
      } else if (t2 < 65536) {
        if ((r2 -= 3) < 0)
          break;
        o6.push(t2 >> 12 | 224, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else if (t2 < 1114112) {
        if ((r2 -= 4) < 0)
          break;
        o6.push(t2 >> 18 | 240, t2 >> 12 & 63 | 128, t2 >> 6 & 63 | 128, t2 & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return o6;
  }
  function Jr(i) {
    let r2 = [];
    for (let t2 = 0; t2 < i.length; ++t2)
      r2.push(i.charCodeAt(t2) & 255);
    return r2;
  }
  function Kr(i, r2) {
    let t2, n3, e, o6 = [];
    for (let u12 = 0; u12 < i.length && !((r2 -= 2) < 0); ++u12)
      t2 = i.charCodeAt(u12), n3 = t2 >> 8, e = t2 % 256, o6.push(e), o6.push(n3);
    return o6;
  }
  function lr(i) {
    return $17.toByteArray(zr(i));
  }
  function L18(i, r2, t2, n3) {
    let e;
    for (e = 0; e < n3 && !(e + t2 >= r2.length || e >= i.length); ++e)
      r2[e + t2] = i[e];
    return e;
  }
  function E15(i, r2) {
    return i instanceof r2 || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r2.name;
  }
  function j13(i) {
    return i !== i;
  }
  var Zr = function() {
    let i = "0123456789abcdef", r2 = new Array(256);
    for (let t2 = 0; t2 < 16; ++t2) {
      let n3 = t2 * 16;
      for (let e = 0; e < 16; ++e)
        r2[n3 + e] = i[t2] + i[e];
    }
    return r2;
  }();
  function g17(i) {
    return typeof BigInt == "undefined" ? Qr : i;
  }
  function Qr() {
    throw new Error("BigInt not supported");
  }
});
var vr = H(X());
var rt = H(X());
var { Buffer: ut, SlowBuffer: ht, INSPECT_MAX_BYTES: ft, kMaxLength: ct } = vr;
var export_default = rt.default;
var pi = Object.create;
var ni = Object.defineProperty;
var Mi = Object.getOwnPropertyDescriptor;
var gi = Object.getOwnPropertyNames;
var ci = Object.getPrototypeOf;
var wi = Object.prototype.hasOwnProperty;
((b15) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(b15, {
  get: (et2, v19) => (typeof require != "undefined" ? require : et2)[v19]
}) : b15)(function(b15) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + b15 + '" is not supported');
});
var xi = (b15, et2) => () => (et2 || b15((et2 = {
  exports: {}
}).exports, et2), et2.exports);
var bi = (b15, et2, v19, nt2) => {
  if (et2 && typeof et2 == "object" || typeof et2 == "function")
    for (let l22 of gi(et2))
      !wi.call(b15, l22) && l22 !== v19 && ni(b15, l22, {
        get: () => et2[l22],
        enumerable: !(nt2 = Mi(et2, l22)) || nt2.enumerable
      });
  return b15;
};
var si = (b15, et2, v19) => (v19 = b15 != null ? pi(ci(b15)) : {}, bi(et2 || !b15 || !b15.__esModule ? ni(v19, "default", {
  value: b15,
  enumerable: true
}) : v19, b15));
var zt = xi((oi, Lt2) => {
  (function(b15, et2) {
    "use strict";
    function v19(o6, t2) {
      if (!o6)
        throw new Error(t2 || "Assertion failed");
    }
    function nt2(o6, t2) {
      o6.super_ = t2;
      var r2 = function() {
      };
      r2.prototype = t2.prototype, o6.prototype = new r2(), o6.prototype.constructor = o6;
    }
    function l22(o6, t2, r2) {
      if (l22.isBN(o6))
        return o6;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, o6 !== null && ((t2 === "le" || t2 === "be") && (r2 = t2, t2 = 10), this._init(o6 || 0, t2 || 10, r2 || "be"));
    }
    typeof b15 == "object" ? b15.exports = l22 : et2.BN = l22, l22.BN = l22, l22.wordSize = 26;
    var at2;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? at2 = window.Buffer : at2 = export_default.Buffer;
    } catch {
    }
    l22.isBN = function(t2) {
      return t2 instanceof l22 ? true : t2 !== null && typeof t2 == "object" && t2.constructor.wordSize === l22.wordSize && Array.isArray(t2.words);
    }, l22.max = function(t2, r2) {
      return t2.cmp(r2) > 0 ? t2 : r2;
    }, l22.min = function(t2, r2) {
      return t2.cmp(r2) < 0 ? t2 : r2;
    }, l22.prototype._init = function(t2, r2, e) {
      if (typeof t2 == "number")
        return this._initNumber(t2, r2, e);
      if (typeof t2 == "object")
        return this._initArray(t2, r2, e);
      r2 === "hex" && (r2 = 16), v19(r2 === (r2 | 0) && r2 >= 2 && r2 <= 36), t2 = t2.toString().replace(/\s+/g, "");
      var h16 = 0;
      t2[0] === "-" && (h16++, this.negative = 1), h16 < t2.length && (r2 === 16 ? this._parseHex(t2, h16, e) : (this._parseBase(t2, r2, h16), e === "le" && this._initArray(this.toArray(), r2, e)));
    }, l22.prototype._initNumber = function(t2, r2, e) {
      t2 < 0 && (this.negative = 1, t2 = -t2), t2 < 67108864 ? (this.words = [
        t2 & 67108863
      ], this.length = 1) : t2 < 4503599627370496 ? (this.words = [
        t2 & 67108863,
        t2 / 67108864 & 67108863
      ], this.length = 2) : (v19(t2 < 9007199254740992), this.words = [
        t2 & 67108863,
        t2 / 67108864 & 67108863,
        1
      ], this.length = 3), e === "le" && this._initArray(this.toArray(), r2, e);
    }, l22.prototype._initArray = function(t2, r2, e) {
      if (v19(typeof t2.length == "number"), t2.length <= 0)
        return this.words = [
          0
        ], this.length = 1, this;
      this.length = Math.ceil(t2.length / 3), this.words = new Array(this.length);
      for (var h16 = 0; h16 < this.length; h16++)
        this.words[h16] = 0;
      var s10, a7, u12 = 0;
      if (e === "be")
        for (h16 = t2.length - 1, s10 = 0; h16 >= 0; h16 -= 3)
          a7 = t2[h16] | t2[h16 - 1] << 8 | t2[h16 - 2] << 16, this.words[s10] |= a7 << u12 & 67108863, this.words[s10 + 1] = a7 >>> 26 - u12 & 67108863, u12 += 24, u12 >= 26 && (u12 -= 26, s10++);
      else if (e === "le")
        for (h16 = 0, s10 = 0; h16 < t2.length; h16 += 3)
          a7 = t2[h16] | t2[h16 + 1] << 8 | t2[h16 + 2] << 16, this.words[s10] |= a7 << u12 & 67108863, this.words[s10 + 1] = a7 >>> 26 - u12 & 67108863, u12 += 24, u12 >= 26 && (u12 -= 26, s10++);
      return this.strip();
    };
    function It2(o6, t2) {
      var r2 = o6.charCodeAt(t2);
      return r2 >= 65 && r2 <= 70 ? r2 - 55 : r2 >= 97 && r2 <= 102 ? r2 - 87 : r2 - 48 & 15;
    }
    function Nt2(o6, t2, r2) {
      var e = It2(o6, r2);
      return r2 - 1 >= t2 && (e |= It2(o6, r2 - 1) << 4), e;
    }
    l22.prototype._parseHex = function(t2, r2, e) {
      this.length = Math.ceil((t2.length - r2) / 6), this.words = new Array(this.length);
      for (var h16 = 0; h16 < this.length; h16++)
        this.words[h16] = 0;
      var s10 = 0, a7 = 0, u12;
      if (e === "be")
        for (h16 = t2.length - 1; h16 >= r2; h16 -= 2)
          u12 = Nt2(t2, r2, h16) << s10, this.words[a7] |= u12 & 67108863, s10 >= 18 ? (s10 -= 18, a7 += 1, this.words[a7] |= u12 >>> 26) : s10 += 8;
      else {
        var f8 = t2.length - r2;
        for (h16 = f8 % 2 === 0 ? r2 + 1 : r2; h16 < t2.length; h16 += 2)
          u12 = Nt2(t2, r2, h16) << s10, this.words[a7] |= u12 & 67108863, s10 >= 18 ? (s10 -= 18, a7 += 1, this.words[a7] |= u12 >>> 26) : s10 += 8;
      }
      this.strip();
    };
    function Et(o6, t2, r2, e) {
      for (var h16 = 0, s10 = Math.min(o6.length, r2), a7 = t2; a7 < s10; a7++) {
        var u12 = o6.charCodeAt(a7) - 48;
        h16 *= e, u12 >= 49 ? h16 += u12 - 49 + 10 : u12 >= 17 ? h16 += u12 - 17 + 10 : h16 += u12;
      }
      return h16;
    }
    l22.prototype._parseBase = function(t2, r2, e) {
      this.words = [
        0
      ], this.length = 1;
      for (var h16 = 0, s10 = 1; s10 <= 67108863; s10 *= r2)
        h16++;
      h16--, s10 = s10 / r2 | 0;
      for (var a7 = t2.length - e, u12 = a7 % h16, f8 = Math.min(a7, a7 - u12) + e, i = 0, n3 = e; n3 < f8; n3 += h16)
        i = Et(t2, n3, n3 + h16, r2), this.imuln(s10), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
      if (u12 !== 0) {
        var d14 = 1;
        for (i = Et(t2, n3, t2.length, r2), n3 = 0; n3 < u12; n3++)
          d14 *= r2;
        this.imuln(d14), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
      }
      this.strip();
    }, l22.prototype.copy = function(t2) {
      t2.words = new Array(this.length);
      for (var r2 = 0; r2 < this.length; r2++)
        t2.words[r2] = this.words[r2];
      t2.length = this.length, t2.negative = this.negative, t2.red = this.red;
    }, l22.prototype.clone = function() {
      var t2 = new l22(null);
      return this.copy(t2), t2;
    }, l22.prototype._expand = function(t2) {
      for (; this.length < t2; )
        this.words[this.length++] = 0;
      return this;
    }, l22.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, l22.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, l22.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var Ot2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ui = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], vi2 = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    l22.prototype.toString = function(t2, r2) {
      t2 = t2 || 10, r2 = r2 | 0 || 1;
      var e;
      if (t2 === 16 || t2 === "hex") {
        e = "";
        for (var h16 = 0, s10 = 0, a7 = 0; a7 < this.length; a7++) {
          var u12 = this.words[a7], f8 = ((u12 << h16 | s10) & 16777215).toString(16);
          s10 = u12 >>> 24 - h16 & 16777215, s10 !== 0 || a7 !== this.length - 1 ? e = Ot2[6 - f8.length] + f8 + e : e = f8 + e, h16 += 2, h16 >= 26 && (h16 -= 26, a7--);
        }
        for (s10 !== 0 && (e = s10.toString(16) + e); e.length % r2 !== 0; )
          e = "0" + e;
        return this.negative !== 0 && (e = "-" + e), e;
      }
      if (t2 === (t2 | 0) && t2 >= 2 && t2 <= 36) {
        var i = ui[t2], n3 = vi2[t2];
        e = "";
        var d14 = this.clone();
        for (d14.negative = 0; !d14.isZero(); ) {
          var m20 = d14.modn(n3).toString(t2);
          d14 = d14.idivn(n3), d14.isZero() ? e = m20 + e : e = Ot2[i - m20.length] + m20 + e;
        }
        for (this.isZero() && (e = "0" + e); e.length % r2 !== 0; )
          e = "0" + e;
        return this.negative !== 0 && (e = "-" + e), e;
      }
      v19(false, "Base should be between 2 and 36");
    }, l22.prototype.toNumber = function() {
      var t2 = this.words[0];
      return this.length === 2 ? t2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && v19(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t2 : t2;
    }, l22.prototype.toJSON = function() {
      return this.toString(16);
    }, l22.prototype.toBuffer = function(t2, r2) {
      return v19(typeof at2 < "u"), this.toArrayLike(at2, t2, r2);
    }, l22.prototype.toArray = function(t2, r2) {
      return this.toArrayLike(Array, t2, r2);
    }, l22.prototype.toArrayLike = function(t2, r2, e) {
      var h16 = this.byteLength(), s10 = e || Math.max(1, h16);
      v19(h16 <= s10, "byte array longer than desired length"), v19(s10 > 0, "Requested array length <= 0"), this.strip();
      var a7 = r2 === "le", u12 = new t2(s10), f8, i, n3 = this.clone();
      if (a7) {
        for (i = 0; !n3.isZero(); i++)
          f8 = n3.andln(255), n3.iushrn(8), u12[i] = f8;
        for (; i < s10; i++)
          u12[i] = 0;
      } else {
        for (i = 0; i < s10 - h16; i++)
          u12[i] = 0;
        for (i = 0; !n3.isZero(); i++)
          f8 = n3.andln(255), n3.iushrn(8), u12[s10 - i - 1] = f8;
      }
      return u12;
    }, Math.clz32 ? l22.prototype._countBits = function(t2) {
      return 32 - Math.clz32(t2);
    } : l22.prototype._countBits = function(t2) {
      var r2 = t2, e = 0;
      return r2 >= 4096 && (e += 13, r2 >>>= 13), r2 >= 64 && (e += 7, r2 >>>= 7), r2 >= 8 && (e += 4, r2 >>>= 4), r2 >= 2 && (e += 2, r2 >>>= 2), e + r2;
    }, l22.prototype._zeroBits = function(t2) {
      if (t2 === 0)
        return 26;
      var r2 = t2, e = 0;
      return (r2 & 8191) === 0 && (e += 13, r2 >>>= 13), (r2 & 127) === 0 && (e += 7, r2 >>>= 7), (r2 & 15) === 0 && (e += 4, r2 >>>= 4), (r2 & 3) === 0 && (e += 2, r2 >>>= 2), (r2 & 1) === 0 && e++, e;
    }, l22.prototype.bitLength = function() {
      var t2 = this.words[this.length - 1], r2 = this._countBits(t2);
      return (this.length - 1) * 26 + r2;
    };
    function di2(o6) {
      for (var t2 = new Array(o6.bitLength()), r2 = 0; r2 < t2.length; r2++) {
        var e = r2 / 26 | 0, h16 = r2 % 26;
        t2[r2] = (o6.words[e] & 1 << h16) >>> h16;
      }
      return t2;
    }
    l22.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var t2 = 0, r2 = 0; r2 < this.length; r2++) {
        var e = this._zeroBits(this.words[r2]);
        if (t2 += e, e !== 26)
          break;
      }
      return t2;
    }, l22.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, l22.prototype.toTwos = function(t2) {
      return this.negative !== 0 ? this.abs().inotn(t2).iaddn(1) : this.clone();
    }, l22.prototype.fromTwos = function(t2) {
      return this.testn(t2 - 1) ? this.notn(t2).iaddn(1).ineg() : this.clone();
    }, l22.prototype.isNeg = function() {
      return this.negative !== 0;
    }, l22.prototype.neg = function() {
      return this.clone().ineg();
    }, l22.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, l22.prototype.iuor = function(t2) {
      for (; this.length < t2.length; )
        this.words[this.length++] = 0;
      for (var r2 = 0; r2 < t2.length; r2++)
        this.words[r2] = this.words[r2] | t2.words[r2];
      return this.strip();
    }, l22.prototype.ior = function(t2) {
      return v19((this.negative | t2.negative) === 0), this.iuor(t2);
    }, l22.prototype.or = function(t2) {
      return this.length > t2.length ? this.clone().ior(t2) : t2.clone().ior(this);
    }, l22.prototype.uor = function(t2) {
      return this.length > t2.length ? this.clone().iuor(t2) : t2.clone().iuor(this);
    }, l22.prototype.iuand = function(t2) {
      var r2;
      this.length > t2.length ? r2 = t2 : r2 = this;
      for (var e = 0; e < r2.length; e++)
        this.words[e] = this.words[e] & t2.words[e];
      return this.length = r2.length, this.strip();
    }, l22.prototype.iand = function(t2) {
      return v19((this.negative | t2.negative) === 0), this.iuand(t2);
    }, l22.prototype.and = function(t2) {
      return this.length > t2.length ? this.clone().iand(t2) : t2.clone().iand(this);
    }, l22.prototype.uand = function(t2) {
      return this.length > t2.length ? this.clone().iuand(t2) : t2.clone().iuand(this);
    }, l22.prototype.iuxor = function(t2) {
      var r2, e;
      this.length > t2.length ? (r2 = this, e = t2) : (r2 = t2, e = this);
      for (var h16 = 0; h16 < e.length; h16++)
        this.words[h16] = r2.words[h16] ^ e.words[h16];
      if (this !== r2)
        for (; h16 < r2.length; h16++)
          this.words[h16] = r2.words[h16];
      return this.length = r2.length, this.strip();
    }, l22.prototype.ixor = function(t2) {
      return v19((this.negative | t2.negative) === 0), this.iuxor(t2);
    }, l22.prototype.xor = function(t2) {
      return this.length > t2.length ? this.clone().ixor(t2) : t2.clone().ixor(this);
    }, l22.prototype.uxor = function(t2) {
      return this.length > t2.length ? this.clone().iuxor(t2) : t2.clone().iuxor(this);
    }, l22.prototype.inotn = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = Math.ceil(t2 / 26) | 0, e = t2 % 26;
      this._expand(r2), e > 0 && r2--;
      for (var h16 = 0; h16 < r2; h16++)
        this.words[h16] = ~this.words[h16] & 67108863;
      return e > 0 && (this.words[h16] = ~this.words[h16] & 67108863 >> 26 - e), this.strip();
    }, l22.prototype.notn = function(t2) {
      return this.clone().inotn(t2);
    }, l22.prototype.setn = function(t2, r2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var e = t2 / 26 | 0, h16 = t2 % 26;
      return this._expand(e + 1), r2 ? this.words[e] = this.words[e] | 1 << h16 : this.words[e] = this.words[e] & ~(1 << h16), this.strip();
    }, l22.prototype.iadd = function(t2) {
      var r2;
      if (this.negative !== 0 && t2.negative === 0)
        return this.negative = 0, r2 = this.isub(t2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && t2.negative !== 0)
        return t2.negative = 0, r2 = this.isub(t2), t2.negative = 1, r2._normSign();
      var e, h16;
      this.length > t2.length ? (e = this, h16 = t2) : (e = t2, h16 = this);
      for (var s10 = 0, a7 = 0; a7 < h16.length; a7++)
        r2 = (e.words[a7] | 0) + (h16.words[a7] | 0) + s10, this.words[a7] = r2 & 67108863, s10 = r2 >>> 26;
      for (; s10 !== 0 && a7 < e.length; a7++)
        r2 = (e.words[a7] | 0) + s10, this.words[a7] = r2 & 67108863, s10 = r2 >>> 26;
      if (this.length = e.length, s10 !== 0)
        this.words[this.length] = s10, this.length++;
      else if (e !== this)
        for (; a7 < e.length; a7++)
          this.words[a7] = e.words[a7];
      return this;
    }, l22.prototype.add = function(t2) {
      var r2;
      return t2.negative !== 0 && this.negative === 0 ? (t2.negative = 0, r2 = this.sub(t2), t2.negative ^= 1, r2) : t2.negative === 0 && this.negative !== 0 ? (this.negative = 0, r2 = t2.sub(this), this.negative = 1, r2) : this.length > t2.length ? this.clone().iadd(t2) : t2.clone().iadd(this);
    }, l22.prototype.isub = function(t2) {
      if (t2.negative !== 0) {
        t2.negative = 0;
        var r2 = this.iadd(t2);
        return t2.negative = 1, r2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(t2), this.negative = 1, this._normSign();
      var e = this.cmp(t2);
      if (e === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var h16, s10;
      e > 0 ? (h16 = this, s10 = t2) : (h16 = t2, s10 = this);
      for (var a7 = 0, u12 = 0; u12 < s10.length; u12++)
        r2 = (h16.words[u12] | 0) - (s10.words[u12] | 0) + a7, a7 = r2 >> 26, this.words[u12] = r2 & 67108863;
      for (; a7 !== 0 && u12 < h16.length; u12++)
        r2 = (h16.words[u12] | 0) + a7, a7 = r2 >> 26, this.words[u12] = r2 & 67108863;
      if (a7 === 0 && u12 < h16.length && h16 !== this)
        for (; u12 < h16.length; u12++)
          this.words[u12] = h16.words[u12];
      return this.length = Math.max(this.length, u12), h16 !== this && (this.negative = 1), this.strip();
    }, l22.prototype.sub = function(t2) {
      return this.clone().isub(t2);
    };
    function Kt2(o6, t2, r2) {
      r2.negative = t2.negative ^ o6.negative;
      var e = o6.length + t2.length | 0;
      r2.length = e, e = e - 1 | 0;
      var h16 = o6.words[0] | 0, s10 = t2.words[0] | 0, a7 = h16 * s10, u12 = a7 & 67108863, f8 = a7 / 67108864 | 0;
      r2.words[0] = u12;
      for (var i = 1; i < e; i++) {
        for (var n3 = f8 >>> 26, d14 = f8 & 67108863, m20 = Math.min(i, t2.length - 1), p7 = Math.max(0, i - o6.length + 1); p7 <= m20; p7++) {
          var M14 = i - p7 | 0;
          h16 = o6.words[M14] | 0, s10 = t2.words[p7] | 0, a7 = h16 * s10 + d14, n3 += a7 / 67108864 | 0, d14 = a7 & 67108863;
        }
        r2.words[i] = d14 | 0, f8 = n3 | 0;
      }
      return f8 !== 0 ? r2.words[i] = f8 | 0 : r2.length--, r2.strip();
    }
    var Ft = function(t2, r2, e) {
      var h16 = t2.words, s10 = r2.words, a7 = e.words, u12 = 0, f8, i, n3, d14 = h16[0] | 0, m20 = d14 & 8191, p7 = d14 >>> 13, M14 = h16[1] | 0, g17 = M14 & 8191, c13 = M14 >>> 13, st2 = h16[2] | 0, w24 = st2 & 8191, y16 = st2 >>> 13, $t2 = h16[3] | 0, _11 = $t2 & 8191, A14 = $t2 >>> 13, Ct = h16[4] | 0, B18 = Ct & 8191, S14 = Ct >>> 13, Jt2 = h16[5] | 0, k15 = Jt2 & 8191, q15 = Jt2 >>> 13, Ut = h16[6] | 0, R13 = Ut & 8191, Z2 = Ut >>> 13, Wt = h16[7] | 0, T12 = Wt & 8191, L18 = Wt >>> 13, Gt = h16[8] | 0, z15 = Gt & 8191, I13 = Gt >>> 13, Qt = h16[9] | 0, N6 = Qt & 8191, E15 = Qt >>> 13, Vt = s10[0] | 0, O9 = Vt & 8191, K14 = Vt >>> 13, Xt = s10[1] | 0, F12 = Xt & 8191, H9 = Xt >>> 13, Yt = s10[2] | 0, P13 = Yt & 8191, D12 = Yt >>> 13, jt = s10[3] | 0, $17 = jt & 8191, C11 = jt >>> 13, ti = s10[4] | 0, J14 = ti & 8191, U7 = ti >>> 13, ii = s10[5] | 0, W2 = ii & 8191, G11 = ii >>> 13, ri = s10[6] | 0, Q9 = ri & 8191, V8 = ri >>> 13, ei = s10[7] | 0, X5 = ei & 8191, Y7 = ei >>> 13, hi = s10[8] | 0, j13 = hi & 8191, tt3 = hi >>> 13, fi = s10[9] | 0, it3 = fi & 8191, rt3 = fi >>> 13;
      e.negative = t2.negative ^ r2.negative, e.length = 19, f8 = Math.imul(m20, O9), i = Math.imul(m20, K14), i = i + Math.imul(p7, O9) | 0, n3 = Math.imul(p7, K14);
      var dt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (dt2 >>> 26) | 0, dt2 &= 67108863, f8 = Math.imul(g17, O9), i = Math.imul(g17, K14), i = i + Math.imul(c13, O9) | 0, n3 = Math.imul(c13, K14), f8 = f8 + Math.imul(m20, F12) | 0, i = i + Math.imul(m20, H9) | 0, i = i + Math.imul(p7, F12) | 0, n3 = n3 + Math.imul(p7, H9) | 0;
      var mt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (mt2 >>> 26) | 0, mt2 &= 67108863, f8 = Math.imul(w24, O9), i = Math.imul(w24, K14), i = i + Math.imul(y16, O9) | 0, n3 = Math.imul(y16, K14), f8 = f8 + Math.imul(g17, F12) | 0, i = i + Math.imul(g17, H9) | 0, i = i + Math.imul(c13, F12) | 0, n3 = n3 + Math.imul(c13, H9) | 0, f8 = f8 + Math.imul(m20, P13) | 0, i = i + Math.imul(m20, D12) | 0, i = i + Math.imul(p7, P13) | 0, n3 = n3 + Math.imul(p7, D12) | 0;
      var pt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (pt2 >>> 26) | 0, pt2 &= 67108863, f8 = Math.imul(_11, O9), i = Math.imul(_11, K14), i = i + Math.imul(A14, O9) | 0, n3 = Math.imul(A14, K14), f8 = f8 + Math.imul(w24, F12) | 0, i = i + Math.imul(w24, H9) | 0, i = i + Math.imul(y16, F12) | 0, n3 = n3 + Math.imul(y16, H9) | 0, f8 = f8 + Math.imul(g17, P13) | 0, i = i + Math.imul(g17, D12) | 0, i = i + Math.imul(c13, P13) | 0, n3 = n3 + Math.imul(c13, D12) | 0, f8 = f8 + Math.imul(m20, $17) | 0, i = i + Math.imul(m20, C11) | 0, i = i + Math.imul(p7, $17) | 0, n3 = n3 + Math.imul(p7, C11) | 0;
      var Mt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (Mt2 >>> 26) | 0, Mt2 &= 67108863, f8 = Math.imul(B18, O9), i = Math.imul(B18, K14), i = i + Math.imul(S14, O9) | 0, n3 = Math.imul(S14, K14), f8 = f8 + Math.imul(_11, F12) | 0, i = i + Math.imul(_11, H9) | 0, i = i + Math.imul(A14, F12) | 0, n3 = n3 + Math.imul(A14, H9) | 0, f8 = f8 + Math.imul(w24, P13) | 0, i = i + Math.imul(w24, D12) | 0, i = i + Math.imul(y16, P13) | 0, n3 = n3 + Math.imul(y16, D12) | 0, f8 = f8 + Math.imul(g17, $17) | 0, i = i + Math.imul(g17, C11) | 0, i = i + Math.imul(c13, $17) | 0, n3 = n3 + Math.imul(c13, C11) | 0, f8 = f8 + Math.imul(m20, J14) | 0, i = i + Math.imul(m20, U7) | 0, i = i + Math.imul(p7, J14) | 0, n3 = n3 + Math.imul(p7, U7) | 0;
      var gt3 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (gt3 >>> 26) | 0, gt3 &= 67108863, f8 = Math.imul(k15, O9), i = Math.imul(k15, K14), i = i + Math.imul(q15, O9) | 0, n3 = Math.imul(q15, K14), f8 = f8 + Math.imul(B18, F12) | 0, i = i + Math.imul(B18, H9) | 0, i = i + Math.imul(S14, F12) | 0, n3 = n3 + Math.imul(S14, H9) | 0, f8 = f8 + Math.imul(_11, P13) | 0, i = i + Math.imul(_11, D12) | 0, i = i + Math.imul(A14, P13) | 0, n3 = n3 + Math.imul(A14, D12) | 0, f8 = f8 + Math.imul(w24, $17) | 0, i = i + Math.imul(w24, C11) | 0, i = i + Math.imul(y16, $17) | 0, n3 = n3 + Math.imul(y16, C11) | 0, f8 = f8 + Math.imul(g17, J14) | 0, i = i + Math.imul(g17, U7) | 0, i = i + Math.imul(c13, J14) | 0, n3 = n3 + Math.imul(c13, U7) | 0, f8 = f8 + Math.imul(m20, W2) | 0, i = i + Math.imul(m20, G11) | 0, i = i + Math.imul(p7, W2) | 0, n3 = n3 + Math.imul(p7, G11) | 0;
      var ct3 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (ct3 >>> 26) | 0, ct3 &= 67108863, f8 = Math.imul(R13, O9), i = Math.imul(R13, K14), i = i + Math.imul(Z2, O9) | 0, n3 = Math.imul(Z2, K14), f8 = f8 + Math.imul(k15, F12) | 0, i = i + Math.imul(k15, H9) | 0, i = i + Math.imul(q15, F12) | 0, n3 = n3 + Math.imul(q15, H9) | 0, f8 = f8 + Math.imul(B18, P13) | 0, i = i + Math.imul(B18, D12) | 0, i = i + Math.imul(S14, P13) | 0, n3 = n3 + Math.imul(S14, D12) | 0, f8 = f8 + Math.imul(_11, $17) | 0, i = i + Math.imul(_11, C11) | 0, i = i + Math.imul(A14, $17) | 0, n3 = n3 + Math.imul(A14, C11) | 0, f8 = f8 + Math.imul(w24, J14) | 0, i = i + Math.imul(w24, U7) | 0, i = i + Math.imul(y16, J14) | 0, n3 = n3 + Math.imul(y16, U7) | 0, f8 = f8 + Math.imul(g17, W2) | 0, i = i + Math.imul(g17, G11) | 0, i = i + Math.imul(c13, W2) | 0, n3 = n3 + Math.imul(c13, G11) | 0, f8 = f8 + Math.imul(m20, Q9) | 0, i = i + Math.imul(m20, V8) | 0, i = i + Math.imul(p7, Q9) | 0, n3 = n3 + Math.imul(p7, V8) | 0;
      var wt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, f8 = Math.imul(T12, O9), i = Math.imul(T12, K14), i = i + Math.imul(L18, O9) | 0, n3 = Math.imul(L18, K14), f8 = f8 + Math.imul(R13, F12) | 0, i = i + Math.imul(R13, H9) | 0, i = i + Math.imul(Z2, F12) | 0, n3 = n3 + Math.imul(Z2, H9) | 0, f8 = f8 + Math.imul(k15, P13) | 0, i = i + Math.imul(k15, D12) | 0, i = i + Math.imul(q15, P13) | 0, n3 = n3 + Math.imul(q15, D12) | 0, f8 = f8 + Math.imul(B18, $17) | 0, i = i + Math.imul(B18, C11) | 0, i = i + Math.imul(S14, $17) | 0, n3 = n3 + Math.imul(S14, C11) | 0, f8 = f8 + Math.imul(_11, J14) | 0, i = i + Math.imul(_11, U7) | 0, i = i + Math.imul(A14, J14) | 0, n3 = n3 + Math.imul(A14, U7) | 0, f8 = f8 + Math.imul(w24, W2) | 0, i = i + Math.imul(w24, G11) | 0, i = i + Math.imul(y16, W2) | 0, n3 = n3 + Math.imul(y16, G11) | 0, f8 = f8 + Math.imul(g17, Q9) | 0, i = i + Math.imul(g17, V8) | 0, i = i + Math.imul(c13, Q9) | 0, n3 = n3 + Math.imul(c13, V8) | 0, f8 = f8 + Math.imul(m20, X5) | 0, i = i + Math.imul(m20, Y7) | 0, i = i + Math.imul(p7, X5) | 0, n3 = n3 + Math.imul(p7, Y7) | 0;
      var yt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (yt2 >>> 26) | 0, yt2 &= 67108863, f8 = Math.imul(z15, O9), i = Math.imul(z15, K14), i = i + Math.imul(I13, O9) | 0, n3 = Math.imul(I13, K14), f8 = f8 + Math.imul(T12, F12) | 0, i = i + Math.imul(T12, H9) | 0, i = i + Math.imul(L18, F12) | 0, n3 = n3 + Math.imul(L18, H9) | 0, f8 = f8 + Math.imul(R13, P13) | 0, i = i + Math.imul(R13, D12) | 0, i = i + Math.imul(Z2, P13) | 0, n3 = n3 + Math.imul(Z2, D12) | 0, f8 = f8 + Math.imul(k15, $17) | 0, i = i + Math.imul(k15, C11) | 0, i = i + Math.imul(q15, $17) | 0, n3 = n3 + Math.imul(q15, C11) | 0, f8 = f8 + Math.imul(B18, J14) | 0, i = i + Math.imul(B18, U7) | 0, i = i + Math.imul(S14, J14) | 0, n3 = n3 + Math.imul(S14, U7) | 0, f8 = f8 + Math.imul(_11, W2) | 0, i = i + Math.imul(_11, G11) | 0, i = i + Math.imul(A14, W2) | 0, n3 = n3 + Math.imul(A14, G11) | 0, f8 = f8 + Math.imul(w24, Q9) | 0, i = i + Math.imul(w24, V8) | 0, i = i + Math.imul(y16, Q9) | 0, n3 = n3 + Math.imul(y16, V8) | 0, f8 = f8 + Math.imul(g17, X5) | 0, i = i + Math.imul(g17, Y7) | 0, i = i + Math.imul(c13, X5) | 0, n3 = n3 + Math.imul(c13, Y7) | 0, f8 = f8 + Math.imul(m20, j13) | 0, i = i + Math.imul(m20, tt3) | 0, i = i + Math.imul(p7, j13) | 0, n3 = n3 + Math.imul(p7, tt3) | 0;
      var xt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, f8 = Math.imul(N6, O9), i = Math.imul(N6, K14), i = i + Math.imul(E15, O9) | 0, n3 = Math.imul(E15, K14), f8 = f8 + Math.imul(z15, F12) | 0, i = i + Math.imul(z15, H9) | 0, i = i + Math.imul(I13, F12) | 0, n3 = n3 + Math.imul(I13, H9) | 0, f8 = f8 + Math.imul(T12, P13) | 0, i = i + Math.imul(T12, D12) | 0, i = i + Math.imul(L18, P13) | 0, n3 = n3 + Math.imul(L18, D12) | 0, f8 = f8 + Math.imul(R13, $17) | 0, i = i + Math.imul(R13, C11) | 0, i = i + Math.imul(Z2, $17) | 0, n3 = n3 + Math.imul(Z2, C11) | 0, f8 = f8 + Math.imul(k15, J14) | 0, i = i + Math.imul(k15, U7) | 0, i = i + Math.imul(q15, J14) | 0, n3 = n3 + Math.imul(q15, U7) | 0, f8 = f8 + Math.imul(B18, W2) | 0, i = i + Math.imul(B18, G11) | 0, i = i + Math.imul(S14, W2) | 0, n3 = n3 + Math.imul(S14, G11) | 0, f8 = f8 + Math.imul(_11, Q9) | 0, i = i + Math.imul(_11, V8) | 0, i = i + Math.imul(A14, Q9) | 0, n3 = n3 + Math.imul(A14, V8) | 0, f8 = f8 + Math.imul(w24, X5) | 0, i = i + Math.imul(w24, Y7) | 0, i = i + Math.imul(y16, X5) | 0, n3 = n3 + Math.imul(y16, Y7) | 0, f8 = f8 + Math.imul(g17, j13) | 0, i = i + Math.imul(g17, tt3) | 0, i = i + Math.imul(c13, j13) | 0, n3 = n3 + Math.imul(c13, tt3) | 0, f8 = f8 + Math.imul(m20, it3) | 0, i = i + Math.imul(m20, rt3) | 0, i = i + Math.imul(p7, it3) | 0, n3 = n3 + Math.imul(p7, rt3) | 0;
      var bt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (bt2 >>> 26) | 0, bt2 &= 67108863, f8 = Math.imul(N6, F12), i = Math.imul(N6, H9), i = i + Math.imul(E15, F12) | 0, n3 = Math.imul(E15, H9), f8 = f8 + Math.imul(z15, P13) | 0, i = i + Math.imul(z15, D12) | 0, i = i + Math.imul(I13, P13) | 0, n3 = n3 + Math.imul(I13, D12) | 0, f8 = f8 + Math.imul(T12, $17) | 0, i = i + Math.imul(T12, C11) | 0, i = i + Math.imul(L18, $17) | 0, n3 = n3 + Math.imul(L18, C11) | 0, f8 = f8 + Math.imul(R13, J14) | 0, i = i + Math.imul(R13, U7) | 0, i = i + Math.imul(Z2, J14) | 0, n3 = n3 + Math.imul(Z2, U7) | 0, f8 = f8 + Math.imul(k15, W2) | 0, i = i + Math.imul(k15, G11) | 0, i = i + Math.imul(q15, W2) | 0, n3 = n3 + Math.imul(q15, G11) | 0, f8 = f8 + Math.imul(B18, Q9) | 0, i = i + Math.imul(B18, V8) | 0, i = i + Math.imul(S14, Q9) | 0, n3 = n3 + Math.imul(S14, V8) | 0, f8 = f8 + Math.imul(_11, X5) | 0, i = i + Math.imul(_11, Y7) | 0, i = i + Math.imul(A14, X5) | 0, n3 = n3 + Math.imul(A14, Y7) | 0, f8 = f8 + Math.imul(w24, j13) | 0, i = i + Math.imul(w24, tt3) | 0, i = i + Math.imul(y16, j13) | 0, n3 = n3 + Math.imul(y16, tt3) | 0, f8 = f8 + Math.imul(g17, it3) | 0, i = i + Math.imul(g17, rt3) | 0, i = i + Math.imul(c13, it3) | 0, n3 = n3 + Math.imul(c13, rt3) | 0;
      var _t2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (_t2 >>> 26) | 0, _t2 &= 67108863, f8 = Math.imul(N6, P13), i = Math.imul(N6, D12), i = i + Math.imul(E15, P13) | 0, n3 = Math.imul(E15, D12), f8 = f8 + Math.imul(z15, $17) | 0, i = i + Math.imul(z15, C11) | 0, i = i + Math.imul(I13, $17) | 0, n3 = n3 + Math.imul(I13, C11) | 0, f8 = f8 + Math.imul(T12, J14) | 0, i = i + Math.imul(T12, U7) | 0, i = i + Math.imul(L18, J14) | 0, n3 = n3 + Math.imul(L18, U7) | 0, f8 = f8 + Math.imul(R13, W2) | 0, i = i + Math.imul(R13, G11) | 0, i = i + Math.imul(Z2, W2) | 0, n3 = n3 + Math.imul(Z2, G11) | 0, f8 = f8 + Math.imul(k15, Q9) | 0, i = i + Math.imul(k15, V8) | 0, i = i + Math.imul(q15, Q9) | 0, n3 = n3 + Math.imul(q15, V8) | 0, f8 = f8 + Math.imul(B18, X5) | 0, i = i + Math.imul(B18, Y7) | 0, i = i + Math.imul(S14, X5) | 0, n3 = n3 + Math.imul(S14, Y7) | 0, f8 = f8 + Math.imul(_11, j13) | 0, i = i + Math.imul(_11, tt3) | 0, i = i + Math.imul(A14, j13) | 0, n3 = n3 + Math.imul(A14, tt3) | 0, f8 = f8 + Math.imul(w24, it3) | 0, i = i + Math.imul(w24, rt3) | 0, i = i + Math.imul(y16, it3) | 0, n3 = n3 + Math.imul(y16, rt3) | 0;
      var At2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, f8 = Math.imul(N6, $17), i = Math.imul(N6, C11), i = i + Math.imul(E15, $17) | 0, n3 = Math.imul(E15, C11), f8 = f8 + Math.imul(z15, J14) | 0, i = i + Math.imul(z15, U7) | 0, i = i + Math.imul(I13, J14) | 0, n3 = n3 + Math.imul(I13, U7) | 0, f8 = f8 + Math.imul(T12, W2) | 0, i = i + Math.imul(T12, G11) | 0, i = i + Math.imul(L18, W2) | 0, n3 = n3 + Math.imul(L18, G11) | 0, f8 = f8 + Math.imul(R13, Q9) | 0, i = i + Math.imul(R13, V8) | 0, i = i + Math.imul(Z2, Q9) | 0, n3 = n3 + Math.imul(Z2, V8) | 0, f8 = f8 + Math.imul(k15, X5) | 0, i = i + Math.imul(k15, Y7) | 0, i = i + Math.imul(q15, X5) | 0, n3 = n3 + Math.imul(q15, Y7) | 0, f8 = f8 + Math.imul(B18, j13) | 0, i = i + Math.imul(B18, tt3) | 0, i = i + Math.imul(S14, j13) | 0, n3 = n3 + Math.imul(S14, tt3) | 0, f8 = f8 + Math.imul(_11, it3) | 0, i = i + Math.imul(_11, rt3) | 0, i = i + Math.imul(A14, it3) | 0, n3 = n3 + Math.imul(A14, rt3) | 0;
      var Bt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, f8 = Math.imul(N6, J14), i = Math.imul(N6, U7), i = i + Math.imul(E15, J14) | 0, n3 = Math.imul(E15, U7), f8 = f8 + Math.imul(z15, W2) | 0, i = i + Math.imul(z15, G11) | 0, i = i + Math.imul(I13, W2) | 0, n3 = n3 + Math.imul(I13, G11) | 0, f8 = f8 + Math.imul(T12, Q9) | 0, i = i + Math.imul(T12, V8) | 0, i = i + Math.imul(L18, Q9) | 0, n3 = n3 + Math.imul(L18, V8) | 0, f8 = f8 + Math.imul(R13, X5) | 0, i = i + Math.imul(R13, Y7) | 0, i = i + Math.imul(Z2, X5) | 0, n3 = n3 + Math.imul(Z2, Y7) | 0, f8 = f8 + Math.imul(k15, j13) | 0, i = i + Math.imul(k15, tt3) | 0, i = i + Math.imul(q15, j13) | 0, n3 = n3 + Math.imul(q15, tt3) | 0, f8 = f8 + Math.imul(B18, it3) | 0, i = i + Math.imul(B18, rt3) | 0, i = i + Math.imul(S14, it3) | 0, n3 = n3 + Math.imul(S14, rt3) | 0;
      var St2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (St2 >>> 26) | 0, St2 &= 67108863, f8 = Math.imul(N6, W2), i = Math.imul(N6, G11), i = i + Math.imul(E15, W2) | 0, n3 = Math.imul(E15, G11), f8 = f8 + Math.imul(z15, Q9) | 0, i = i + Math.imul(z15, V8) | 0, i = i + Math.imul(I13, Q9) | 0, n3 = n3 + Math.imul(I13, V8) | 0, f8 = f8 + Math.imul(T12, X5) | 0, i = i + Math.imul(T12, Y7) | 0, i = i + Math.imul(L18, X5) | 0, n3 = n3 + Math.imul(L18, Y7) | 0, f8 = f8 + Math.imul(R13, j13) | 0, i = i + Math.imul(R13, tt3) | 0, i = i + Math.imul(Z2, j13) | 0, n3 = n3 + Math.imul(Z2, tt3) | 0, f8 = f8 + Math.imul(k15, it3) | 0, i = i + Math.imul(k15, rt3) | 0, i = i + Math.imul(q15, it3) | 0, n3 = n3 + Math.imul(q15, rt3) | 0;
      var kt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, f8 = Math.imul(N6, Q9), i = Math.imul(N6, V8), i = i + Math.imul(E15, Q9) | 0, n3 = Math.imul(E15, V8), f8 = f8 + Math.imul(z15, X5) | 0, i = i + Math.imul(z15, Y7) | 0, i = i + Math.imul(I13, X5) | 0, n3 = n3 + Math.imul(I13, Y7) | 0, f8 = f8 + Math.imul(T12, j13) | 0, i = i + Math.imul(T12, tt3) | 0, i = i + Math.imul(L18, j13) | 0, n3 = n3 + Math.imul(L18, tt3) | 0, f8 = f8 + Math.imul(R13, it3) | 0, i = i + Math.imul(R13, rt3) | 0, i = i + Math.imul(Z2, it3) | 0, n3 = n3 + Math.imul(Z2, rt3) | 0;
      var qt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, f8 = Math.imul(N6, X5), i = Math.imul(N6, Y7), i = i + Math.imul(E15, X5) | 0, n3 = Math.imul(E15, Y7), f8 = f8 + Math.imul(z15, j13) | 0, i = i + Math.imul(z15, tt3) | 0, i = i + Math.imul(I13, j13) | 0, n3 = n3 + Math.imul(I13, tt3) | 0, f8 = f8 + Math.imul(T12, it3) | 0, i = i + Math.imul(T12, rt3) | 0, i = i + Math.imul(L18, it3) | 0, n3 = n3 + Math.imul(L18, rt3) | 0;
      var Rt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, f8 = Math.imul(N6, j13), i = Math.imul(N6, tt3), i = i + Math.imul(E15, j13) | 0, n3 = Math.imul(E15, tt3), f8 = f8 + Math.imul(z15, it3) | 0, i = i + Math.imul(z15, rt3) | 0, i = i + Math.imul(I13, it3) | 0, n3 = n3 + Math.imul(I13, rt3) | 0;
      var Zt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (n3 + (i >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, f8 = Math.imul(N6, it3), i = Math.imul(N6, rt3), i = i + Math.imul(E15, it3) | 0, n3 = Math.imul(E15, rt3);
      var Tt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      return u12 = (n3 + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, a7[0] = dt2, a7[1] = mt2, a7[2] = pt2, a7[3] = Mt2, a7[4] = gt3, a7[5] = ct3, a7[6] = wt, a7[7] = yt2, a7[8] = xt, a7[9] = bt2, a7[10] = _t2, a7[11] = At2, a7[12] = Bt, a7[13] = St2, a7[14] = kt2, a7[15] = qt2, a7[16] = Rt, a7[17] = Zt, a7[18] = Tt, u12 !== 0 && (a7[19] = u12, e.length++), e;
    };
    Math.imul || (Ft = Kt2);
    function mi(o6, t2, r2) {
      r2.negative = t2.negative ^ o6.negative, r2.length = o6.length + t2.length;
      for (var e = 0, h16 = 0, s10 = 0; s10 < r2.length - 1; s10++) {
        var a7 = h16;
        h16 = 0;
        for (var u12 = e & 67108863, f8 = Math.min(s10, t2.length - 1), i = Math.max(0, s10 - o6.length + 1); i <= f8; i++) {
          var n3 = s10 - i, d14 = o6.words[n3] | 0, m20 = t2.words[i] | 0, p7 = d14 * m20, M14 = p7 & 67108863;
          a7 = a7 + (p7 / 67108864 | 0) | 0, M14 = M14 + u12 | 0, u12 = M14 & 67108863, a7 = a7 + (M14 >>> 26) | 0, h16 += a7 >>> 26, a7 &= 67108863;
        }
        r2.words[s10] = u12, e = a7, a7 = h16;
      }
      return e !== 0 ? r2.words[s10] = e : r2.length--, r2.strip();
    }
    function Ht(o6, t2, r2) {
      var e = new ft2();
      return e.mulp(o6, t2, r2);
    }
    l22.prototype.mulTo = function(t2, r2) {
      var e, h16 = this.length + t2.length;
      return this.length === 10 && t2.length === 10 ? e = Ft(this, t2, r2) : h16 < 63 ? e = Kt2(this, t2, r2) : h16 < 1024 ? e = mi(this, t2, r2) : e = Ht(this, t2, r2), e;
    };
    function ft2(o6, t2) {
      this.x = o6, this.y = t2;
    }
    ft2.prototype.makeRBT = function(t2) {
      for (var r2 = new Array(t2), e = l22.prototype._countBits(t2) - 1, h16 = 0; h16 < t2; h16++)
        r2[h16] = this.revBin(h16, e, t2);
      return r2;
    }, ft2.prototype.revBin = function(t2, r2, e) {
      if (t2 === 0 || t2 === e - 1)
        return t2;
      for (var h16 = 0, s10 = 0; s10 < r2; s10++)
        h16 |= (t2 & 1) << r2 - s10 - 1, t2 >>= 1;
      return h16;
    }, ft2.prototype.permute = function(t2, r2, e, h16, s10, a7) {
      for (var u12 = 0; u12 < a7; u12++)
        h16[u12] = r2[t2[u12]], s10[u12] = e[t2[u12]];
    }, ft2.prototype.transform = function(t2, r2, e, h16, s10, a7) {
      this.permute(a7, t2, r2, e, h16, s10);
      for (var u12 = 1; u12 < s10; u12 <<= 1)
        for (var f8 = u12 << 1, i = Math.cos(2 * Math.PI / f8), n3 = Math.sin(2 * Math.PI / f8), d14 = 0; d14 < s10; d14 += f8)
          for (var m20 = i, p7 = n3, M14 = 0; M14 < u12; M14++) {
            var g17 = e[d14 + M14], c13 = h16[d14 + M14], st2 = e[d14 + M14 + u12], w24 = h16[d14 + M14 + u12], y16 = m20 * st2 - p7 * w24;
            w24 = m20 * w24 + p7 * st2, st2 = y16, e[d14 + M14] = g17 + st2, h16[d14 + M14] = c13 + w24, e[d14 + M14 + u12] = g17 - st2, h16[d14 + M14 + u12] = c13 - w24, M14 !== f8 && (y16 = i * m20 - n3 * p7, p7 = i * p7 + n3 * m20, m20 = y16);
          }
    }, ft2.prototype.guessLen13b = function(t2, r2) {
      var e = Math.max(r2, t2) | 1, h16 = e & 1, s10 = 0;
      for (e = e / 2 | 0; e; e = e >>> 1)
        s10++;
      return 1 << s10 + 1 + h16;
    }, ft2.prototype.conjugate = function(t2, r2, e) {
      if (!(e <= 1))
        for (var h16 = 0; h16 < e / 2; h16++) {
          var s10 = t2[h16];
          t2[h16] = t2[e - h16 - 1], t2[e - h16 - 1] = s10, s10 = r2[h16], r2[h16] = -r2[e - h16 - 1], r2[e - h16 - 1] = -s10;
        }
    }, ft2.prototype.normalize13b = function(t2, r2) {
      for (var e = 0, h16 = 0; h16 < r2 / 2; h16++) {
        var s10 = Math.round(t2[2 * h16 + 1] / r2) * 8192 + Math.round(t2[2 * h16] / r2) + e;
        t2[h16] = s10 & 67108863, s10 < 67108864 ? e = 0 : e = s10 / 67108864 | 0;
      }
      return t2;
    }, ft2.prototype.convert13b = function(t2, r2, e, h16) {
      for (var s10 = 0, a7 = 0; a7 < r2; a7++)
        s10 = s10 + (t2[a7] | 0), e[2 * a7] = s10 & 8191, s10 = s10 >>> 13, e[2 * a7 + 1] = s10 & 8191, s10 = s10 >>> 13;
      for (a7 = 2 * r2; a7 < h16; ++a7)
        e[a7] = 0;
      v19(s10 === 0), v19((s10 & -8192) === 0);
    }, ft2.prototype.stub = function(t2) {
      for (var r2 = new Array(t2), e = 0; e < t2; e++)
        r2[e] = 0;
      return r2;
    }, ft2.prototype.mulp = function(t2, r2, e) {
      var h16 = 2 * this.guessLen13b(t2.length, r2.length), s10 = this.makeRBT(h16), a7 = this.stub(h16), u12 = new Array(h16), f8 = new Array(h16), i = new Array(h16), n3 = new Array(h16), d14 = new Array(h16), m20 = new Array(h16), p7 = e.words;
      p7.length = h16, this.convert13b(t2.words, t2.length, u12, h16), this.convert13b(r2.words, r2.length, n3, h16), this.transform(u12, a7, f8, i, h16, s10), this.transform(n3, a7, d14, m20, h16, s10);
      for (var M14 = 0; M14 < h16; M14++) {
        var g17 = f8[M14] * d14[M14] - i[M14] * m20[M14];
        i[M14] = f8[M14] * m20[M14] + i[M14] * d14[M14], f8[M14] = g17;
      }
      return this.conjugate(f8, i, h16), this.transform(f8, i, p7, a7, h16, s10), this.conjugate(p7, a7, h16), this.normalize13b(p7, h16), e.negative = t2.negative ^ r2.negative, e.length = t2.length + r2.length, e.strip();
    }, l22.prototype.mul = function(t2) {
      var r2 = new l22(null);
      return r2.words = new Array(this.length + t2.length), this.mulTo(t2, r2);
    }, l22.prototype.mulf = function(t2) {
      var r2 = new l22(null);
      return r2.words = new Array(this.length + t2.length), Ht(this, t2, r2);
    }, l22.prototype.imul = function(t2) {
      return this.clone().mulTo(t2, this);
    }, l22.prototype.imuln = function(t2) {
      v19(typeof t2 == "number"), v19(t2 < 67108864);
      for (var r2 = 0, e = 0; e < this.length; e++) {
        var h16 = (this.words[e] | 0) * t2, s10 = (h16 & 67108863) + (r2 & 67108863);
        r2 >>= 26, r2 += h16 / 67108864 | 0, r2 += s10 >>> 26, this.words[e] = s10 & 67108863;
      }
      return r2 !== 0 && (this.words[e] = r2, this.length++), this;
    }, l22.prototype.muln = function(t2) {
      return this.clone().imuln(t2);
    }, l22.prototype.sqr = function() {
      return this.mul(this);
    }, l22.prototype.isqr = function() {
      return this.imul(this.clone());
    }, l22.prototype.pow = function(t2) {
      var r2 = di2(t2);
      if (r2.length === 0)
        return new l22(1);
      for (var e = this, h16 = 0; h16 < r2.length && r2[h16] === 0; h16++, e = e.sqr())
        ;
      if (++h16 < r2.length)
        for (var s10 = e.sqr(); h16 < r2.length; h16++, s10 = s10.sqr())
          r2[h16] !== 0 && (e = e.mul(s10));
      return e;
    }, l22.prototype.iushln = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = t2 % 26, e = (t2 - r2) / 26, h16 = 67108863 >>> 26 - r2 << 26 - r2, s10;
      if (r2 !== 0) {
        var a7 = 0;
        for (s10 = 0; s10 < this.length; s10++) {
          var u12 = this.words[s10] & h16, f8 = (this.words[s10] | 0) - u12 << r2;
          this.words[s10] = f8 | a7, a7 = u12 >>> 26 - r2;
        }
        a7 && (this.words[s10] = a7, this.length++);
      }
      if (e !== 0) {
        for (s10 = this.length - 1; s10 >= 0; s10--)
          this.words[s10 + e] = this.words[s10];
        for (s10 = 0; s10 < e; s10++)
          this.words[s10] = 0;
        this.length += e;
      }
      return this.strip();
    }, l22.prototype.ishln = function(t2) {
      return v19(this.negative === 0), this.iushln(t2);
    }, l22.prototype.iushrn = function(t2, r2, e) {
      v19(typeof t2 == "number" && t2 >= 0);
      var h16;
      r2 ? h16 = (r2 - r2 % 26) / 26 : h16 = 0;
      var s10 = t2 % 26, a7 = Math.min((t2 - s10) / 26, this.length), u12 = 67108863 ^ 67108863 >>> s10 << s10, f8 = e;
      if (h16 -= a7, h16 = Math.max(0, h16), f8) {
        for (var i = 0; i < a7; i++)
          f8.words[i] = this.words[i];
        f8.length = a7;
      }
      if (a7 !== 0)
        if (this.length > a7)
          for (this.length -= a7, i = 0; i < this.length; i++)
            this.words[i] = this.words[i + a7];
        else
          this.words[0] = 0, this.length = 1;
      var n3 = 0;
      for (i = this.length - 1; i >= 0 && (n3 !== 0 || i >= h16); i--) {
        var d14 = this.words[i] | 0;
        this.words[i] = n3 << 26 - s10 | d14 >>> s10, n3 = d14 & u12;
      }
      return f8 && n3 !== 0 && (f8.words[f8.length++] = n3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, l22.prototype.ishrn = function(t2, r2, e) {
      return v19(this.negative === 0), this.iushrn(t2, r2, e);
    }, l22.prototype.shln = function(t2) {
      return this.clone().ishln(t2);
    }, l22.prototype.ushln = function(t2) {
      return this.clone().iushln(t2);
    }, l22.prototype.shrn = function(t2) {
      return this.clone().ishrn(t2);
    }, l22.prototype.ushrn = function(t2) {
      return this.clone().iushrn(t2);
    }, l22.prototype.testn = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = t2 % 26, e = (t2 - r2) / 26, h16 = 1 << r2;
      if (this.length <= e)
        return false;
      var s10 = this.words[e];
      return !!(s10 & h16);
    }, l22.prototype.imaskn = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = t2 % 26, e = (t2 - r2) / 26;
      if (v19(this.negative === 0, "imaskn works only with positive numbers"), this.length <= e)
        return this;
      if (r2 !== 0 && e++, this.length = Math.min(e, this.length), r2 !== 0) {
        var h16 = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= h16;
      }
      return this.strip();
    }, l22.prototype.maskn = function(t2) {
      return this.clone().imaskn(t2);
    }, l22.prototype.iaddn = function(t2) {
      return v19(typeof t2 == "number"), v19(t2 < 67108864), t2 < 0 ? this.isubn(-t2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < t2 ? (this.words[0] = t2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t2), this.negative = 1, this) : this._iaddn(t2);
    }, l22.prototype._iaddn = function(t2) {
      this.words[0] += t2;
      for (var r2 = 0; r2 < this.length && this.words[r2] >= 67108864; r2++)
        this.words[r2] -= 67108864, r2 === this.length - 1 ? this.words[r2 + 1] = 1 : this.words[r2 + 1]++;
      return this.length = Math.max(this.length, r2 + 1), this;
    }, l22.prototype.isubn = function(t2) {
      if (v19(typeof t2 == "number"), v19(t2 < 67108864), t2 < 0)
        return this.iaddn(-t2);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(t2), this.negative = 1, this;
      if (this.words[0] -= t2, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var r2 = 0; r2 < this.length && this.words[r2] < 0; r2++)
          this.words[r2] += 67108864, this.words[r2 + 1] -= 1;
      return this.strip();
    }, l22.prototype.addn = function(t2) {
      return this.clone().iaddn(t2);
    }, l22.prototype.subn = function(t2) {
      return this.clone().isubn(t2);
    }, l22.prototype.iabs = function() {
      return this.negative = 0, this;
    }, l22.prototype.abs = function() {
      return this.clone().iabs();
    }, l22.prototype._ishlnsubmul = function(t2, r2, e) {
      var h16 = t2.length + e, s10;
      this._expand(h16);
      var a7, u12 = 0;
      for (s10 = 0; s10 < t2.length; s10++) {
        a7 = (this.words[s10 + e] | 0) + u12;
        var f8 = (t2.words[s10] | 0) * r2;
        a7 -= f8 & 67108863, u12 = (a7 >> 26) - (f8 / 67108864 | 0), this.words[s10 + e] = a7 & 67108863;
      }
      for (; s10 < this.length - e; s10++)
        a7 = (this.words[s10 + e] | 0) + u12, u12 = a7 >> 26, this.words[s10 + e] = a7 & 67108863;
      if (u12 === 0)
        return this.strip();
      for (v19(u12 === -1), u12 = 0, s10 = 0; s10 < this.length; s10++)
        a7 = -(this.words[s10] | 0) + u12, u12 = a7 >> 26, this.words[s10] = a7 & 67108863;
      return this.negative = 1, this.strip();
    }, l22.prototype._wordDiv = function(t2, r2) {
      var e = this.length - t2.length, h16 = this.clone(), s10 = t2, a7 = s10.words[s10.length - 1] | 0, u12 = this._countBits(a7);
      e = 26 - u12, e !== 0 && (s10 = s10.ushln(e), h16.iushln(e), a7 = s10.words[s10.length - 1] | 0);
      var f8 = h16.length - s10.length, i;
      if (r2 !== "mod") {
        i = new l22(null), i.length = f8 + 1, i.words = new Array(i.length);
        for (var n3 = 0; n3 < i.length; n3++)
          i.words[n3] = 0;
      }
      var d14 = h16.clone()._ishlnsubmul(s10, 1, f8);
      d14.negative === 0 && (h16 = d14, i && (i.words[f8] = 1));
      for (var m20 = f8 - 1; m20 >= 0; m20--) {
        var p7 = (h16.words[s10.length + m20] | 0) * 67108864 + (h16.words[s10.length + m20 - 1] | 0);
        for (p7 = Math.min(p7 / a7 | 0, 67108863), h16._ishlnsubmul(s10, p7, m20); h16.negative !== 0; )
          p7--, h16.negative = 0, h16._ishlnsubmul(s10, 1, m20), h16.isZero() || (h16.negative ^= 1);
        i && (i.words[m20] = p7);
      }
      return i && i.strip(), h16.strip(), r2 !== "div" && e !== 0 && h16.iushrn(e), {
        div: i || null,
        mod: h16
      };
    }, l22.prototype.divmod = function(t2, r2, e) {
      if (v19(!t2.isZero()), this.isZero())
        return {
          div: new l22(0),
          mod: new l22(0)
        };
      var h16, s10, a7;
      return this.negative !== 0 && t2.negative === 0 ? (a7 = this.neg().divmod(t2, r2), r2 !== "mod" && (h16 = a7.div.neg()), r2 !== "div" && (s10 = a7.mod.neg(), e && s10.negative !== 0 && s10.iadd(t2)), {
        div: h16,
        mod: s10
      }) : this.negative === 0 && t2.negative !== 0 ? (a7 = this.divmod(t2.neg(), r2), r2 !== "mod" && (h16 = a7.div.neg()), {
        div: h16,
        mod: a7.mod
      }) : (this.negative & t2.negative) !== 0 ? (a7 = this.neg().divmod(t2.neg(), r2), r2 !== "div" && (s10 = a7.mod.neg(), e && s10.negative !== 0 && s10.isub(t2)), {
        div: a7.div,
        mod: s10
      }) : t2.length > this.length || this.cmp(t2) < 0 ? {
        div: new l22(0),
        mod: this
      } : t2.length === 1 ? r2 === "div" ? {
        div: this.divn(t2.words[0]),
        mod: null
      } : r2 === "mod" ? {
        div: null,
        mod: new l22(this.modn(t2.words[0]))
      } : {
        div: this.divn(t2.words[0]),
        mod: new l22(this.modn(t2.words[0]))
      } : this._wordDiv(t2, r2);
    }, l22.prototype.div = function(t2) {
      return this.divmod(t2, "div", false).div;
    }, l22.prototype.mod = function(t2) {
      return this.divmod(t2, "mod", false).mod;
    }, l22.prototype.umod = function(t2) {
      return this.divmod(t2, "mod", true).mod;
    }, l22.prototype.divRound = function(t2) {
      var r2 = this.divmod(t2);
      if (r2.mod.isZero())
        return r2.div;
      var e = r2.div.negative !== 0 ? r2.mod.isub(t2) : r2.mod, h16 = t2.ushrn(1), s10 = t2.andln(1), a7 = e.cmp(h16);
      return a7 < 0 || s10 === 1 && a7 === 0 ? r2.div : r2.div.negative !== 0 ? r2.div.isubn(1) : r2.div.iaddn(1);
    }, l22.prototype.modn = function(t2) {
      v19(t2 <= 67108863);
      for (var r2 = (1 << 26) % t2, e = 0, h16 = this.length - 1; h16 >= 0; h16--)
        e = (r2 * e + (this.words[h16] | 0)) % t2;
      return e;
    }, l22.prototype.idivn = function(t2) {
      v19(t2 <= 67108863);
      for (var r2 = 0, e = this.length - 1; e >= 0; e--) {
        var h16 = (this.words[e] | 0) + r2 * 67108864;
        this.words[e] = h16 / t2 | 0, r2 = h16 % t2;
      }
      return this.strip();
    }, l22.prototype.divn = function(t2) {
      return this.clone().idivn(t2);
    }, l22.prototype.egcd = function(t2) {
      v19(t2.negative === 0), v19(!t2.isZero());
      var r2 = this, e = t2.clone();
      r2.negative !== 0 ? r2 = r2.umod(t2) : r2 = r2.clone();
      for (var h16 = new l22(1), s10 = new l22(0), a7 = new l22(0), u12 = new l22(1), f8 = 0; r2.isEven() && e.isEven(); )
        r2.iushrn(1), e.iushrn(1), ++f8;
      for (var i = e.clone(), n3 = r2.clone(); !r2.isZero(); ) {
        for (var d14 = 0, m20 = 1; (r2.words[0] & m20) === 0 && d14 < 26; ++d14, m20 <<= 1)
          ;
        if (d14 > 0)
          for (r2.iushrn(d14); d14-- > 0; )
            (h16.isOdd() || s10.isOdd()) && (h16.iadd(i), s10.isub(n3)), h16.iushrn(1), s10.iushrn(1);
        for (var p7 = 0, M14 = 1; (e.words[0] & M14) === 0 && p7 < 26; ++p7, M14 <<= 1)
          ;
        if (p7 > 0)
          for (e.iushrn(p7); p7-- > 0; )
            (a7.isOdd() || u12.isOdd()) && (a7.iadd(i), u12.isub(n3)), a7.iushrn(1), u12.iushrn(1);
        r2.cmp(e) >= 0 ? (r2.isub(e), h16.isub(a7), s10.isub(u12)) : (e.isub(r2), a7.isub(h16), u12.isub(s10));
      }
      return {
        a: a7,
        b: u12,
        gcd: e.iushln(f8)
      };
    }, l22.prototype._invmp = function(t2) {
      v19(t2.negative === 0), v19(!t2.isZero());
      var r2 = this, e = t2.clone();
      r2.negative !== 0 ? r2 = r2.umod(t2) : r2 = r2.clone();
      for (var h16 = new l22(1), s10 = new l22(0), a7 = e.clone(); r2.cmpn(1) > 0 && e.cmpn(1) > 0; ) {
        for (var u12 = 0, f8 = 1; (r2.words[0] & f8) === 0 && u12 < 26; ++u12, f8 <<= 1)
          ;
        if (u12 > 0)
          for (r2.iushrn(u12); u12-- > 0; )
            h16.isOdd() && h16.iadd(a7), h16.iushrn(1);
        for (var i = 0, n3 = 1; (e.words[0] & n3) === 0 && i < 26; ++i, n3 <<= 1)
          ;
        if (i > 0)
          for (e.iushrn(i); i-- > 0; )
            s10.isOdd() && s10.iadd(a7), s10.iushrn(1);
        r2.cmp(e) >= 0 ? (r2.isub(e), h16.isub(s10)) : (e.isub(r2), s10.isub(h16));
      }
      var d14;
      return r2.cmpn(1) === 0 ? d14 = h16 : d14 = s10, d14.cmpn(0) < 0 && d14.iadd(t2), d14;
    }, l22.prototype.gcd = function(t2) {
      if (this.isZero())
        return t2.abs();
      if (t2.isZero())
        return this.abs();
      var r2 = this.clone(), e = t2.clone();
      r2.negative = 0, e.negative = 0;
      for (var h16 = 0; r2.isEven() && e.isEven(); h16++)
        r2.iushrn(1), e.iushrn(1);
      do {
        for (; r2.isEven(); )
          r2.iushrn(1);
        for (; e.isEven(); )
          e.iushrn(1);
        var s10 = r2.cmp(e);
        if (s10 < 0) {
          var a7 = r2;
          r2 = e, e = a7;
        } else if (s10 === 0 || e.cmpn(1) === 0)
          break;
        r2.isub(e);
      } while (true);
      return e.iushln(h16);
    }, l22.prototype.invm = function(t2) {
      return this.egcd(t2).a.umod(t2);
    }, l22.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, l22.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, l22.prototype.andln = function(t2) {
      return this.words[0] & t2;
    }, l22.prototype.bincn = function(t2) {
      v19(typeof t2 == "number");
      var r2 = t2 % 26, e = (t2 - r2) / 26, h16 = 1 << r2;
      if (this.length <= e)
        return this._expand(e + 1), this.words[e] |= h16, this;
      for (var s10 = h16, a7 = e; s10 !== 0 && a7 < this.length; a7++) {
        var u12 = this.words[a7] | 0;
        u12 += s10, s10 = u12 >>> 26, u12 &= 67108863, this.words[a7] = u12;
      }
      return s10 !== 0 && (this.words[a7] = s10, this.length++), this;
    }, l22.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, l22.prototype.cmpn = function(t2) {
      var r2 = t2 < 0;
      if (this.negative !== 0 && !r2)
        return -1;
      if (this.negative === 0 && r2)
        return 1;
      this.strip();
      var e;
      if (this.length > 1)
        e = 1;
      else {
        r2 && (t2 = -t2), v19(t2 <= 67108863, "Number is too big");
        var h16 = this.words[0] | 0;
        e = h16 === t2 ? 0 : h16 < t2 ? -1 : 1;
      }
      return this.negative !== 0 ? -e | 0 : e;
    }, l22.prototype.cmp = function(t2) {
      if (this.negative !== 0 && t2.negative === 0)
        return -1;
      if (this.negative === 0 && t2.negative !== 0)
        return 1;
      var r2 = this.ucmp(t2);
      return this.negative !== 0 ? -r2 | 0 : r2;
    }, l22.prototype.ucmp = function(t2) {
      if (this.length > t2.length)
        return 1;
      if (this.length < t2.length)
        return -1;
      for (var r2 = 0, e = this.length - 1; e >= 0; e--) {
        var h16 = this.words[e] | 0, s10 = t2.words[e] | 0;
        if (h16 !== s10) {
          h16 < s10 ? r2 = -1 : h16 > s10 && (r2 = 1);
          break;
        }
      }
      return r2;
    }, l22.prototype.gtn = function(t2) {
      return this.cmpn(t2) === 1;
    }, l22.prototype.gt = function(t2) {
      return this.cmp(t2) === 1;
    }, l22.prototype.gten = function(t2) {
      return this.cmpn(t2) >= 0;
    }, l22.prototype.gte = function(t2) {
      return this.cmp(t2) >= 0;
    }, l22.prototype.ltn = function(t2) {
      return this.cmpn(t2) === -1;
    }, l22.prototype.lt = function(t2) {
      return this.cmp(t2) === -1;
    }, l22.prototype.lten = function(t2) {
      return this.cmpn(t2) <= 0;
    }, l22.prototype.lte = function(t2) {
      return this.cmp(t2) <= 0;
    }, l22.prototype.eqn = function(t2) {
      return this.cmpn(t2) === 0;
    }, l22.prototype.eq = function(t2) {
      return this.cmp(t2) === 0;
    }, l22.red = function(t2) {
      return new x17(t2);
    }, l22.prototype.toRed = function(t2) {
      return v19(!this.red, "Already a number in reduction context"), v19(this.negative === 0, "red works only with positives"), t2.convertTo(this)._forceRed(t2);
    }, l22.prototype.fromRed = function() {
      return v19(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, l22.prototype._forceRed = function(t2) {
      return this.red = t2, this;
    }, l22.prototype.forceRed = function(t2) {
      return v19(!this.red, "Already a number in reduction context"), this._forceRed(t2);
    }, l22.prototype.redAdd = function(t2) {
      return v19(this.red, "redAdd works only with red numbers"), this.red.add(this, t2);
    }, l22.prototype.redIAdd = function(t2) {
      return v19(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t2);
    }, l22.prototype.redSub = function(t2) {
      return v19(this.red, "redSub works only with red numbers"), this.red.sub(this, t2);
    }, l22.prototype.redISub = function(t2) {
      return v19(this.red, "redISub works only with red numbers"), this.red.isub(this, t2);
    }, l22.prototype.redShl = function(t2) {
      return v19(this.red, "redShl works only with red numbers"), this.red.shl(this, t2);
    }, l22.prototype.redMul = function(t2) {
      return v19(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.mul(this, t2);
    }, l22.prototype.redIMul = function(t2) {
      return v19(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.imul(this, t2);
    }, l22.prototype.redSqr = function() {
      return v19(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, l22.prototype.redISqr = function() {
      return v19(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, l22.prototype.redSqrt = function() {
      return v19(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, l22.prototype.redInvm = function() {
      return v19(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, l22.prototype.redNeg = function() {
      return v19(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, l22.prototype.redPow = function(t2) {
      return v19(this.red && !t2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t2);
    };
    var ut4 = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ht4(o6, t2) {
      this.name = o6, this.p = new l22(t2, 16), this.n = this.p.bitLength(), this.k = new l22(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ht4.prototype._tmp = function() {
      var t2 = new l22(null);
      return t2.words = new Array(Math.ceil(this.n / 13)), t2;
    }, ht4.prototype.ireduce = function(t2) {
      var r2 = t2, e;
      do
        this.split(r2, this.tmp), r2 = this.imulK(r2), r2 = r2.iadd(this.tmp), e = r2.bitLength();
      while (e > this.n);
      var h16 = e < this.n ? -1 : r2.ucmp(this.p);
      return h16 === 0 ? (r2.words[0] = 0, r2.length = 1) : h16 > 0 ? r2.isub(this.p) : r2.strip !== void 0 ? r2.strip() : r2._strip(), r2;
    }, ht4.prototype.split = function(t2, r2) {
      t2.iushrn(this.n, 0, r2);
    }, ht4.prototype.imulK = function(t2) {
      return t2.imul(this.k);
    };
    function lt2() {
      ht4.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    nt2(lt2, ht4), lt2.prototype.split = function(t2, r2) {
      for (var e = 4194303, h16 = Math.min(t2.length, 9), s10 = 0; s10 < h16; s10++)
        r2.words[s10] = t2.words[s10];
      if (r2.length = h16, t2.length <= 9) {
        t2.words[0] = 0, t2.length = 1;
        return;
      }
      var a7 = t2.words[9];
      for (r2.words[r2.length++] = a7 & e, s10 = 10; s10 < t2.length; s10++) {
        var u12 = t2.words[s10] | 0;
        t2.words[s10 - 10] = (u12 & e) << 4 | a7 >>> 22, a7 = u12;
      }
      a7 >>>= 22, t2.words[s10 - 10] = a7, a7 === 0 && t2.length > 10 ? t2.length -= 10 : t2.length -= 9;
    }, lt2.prototype.imulK = function(t2) {
      t2.words[t2.length] = 0, t2.words[t2.length + 1] = 0, t2.length += 2;
      for (var r2 = 0, e = 0; e < t2.length; e++) {
        var h16 = t2.words[e] | 0;
        r2 += h16 * 977, t2.words[e] = r2 & 67108863, r2 = h16 * 64 + (r2 / 67108864 | 0);
      }
      return t2.words[t2.length - 1] === 0 && (t2.length--, t2.words[t2.length - 1] === 0 && t2.length--), t2;
    };
    function Pt2() {
      ht4.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    nt2(Pt2, ht4);
    function Dt2() {
      ht4.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    nt2(Dt2, ht4);
    function vt() {
      ht4.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    nt2(vt, ht4), vt.prototype.imulK = function(t2) {
      for (var r2 = 0, e = 0; e < t2.length; e++) {
        var h16 = (t2.words[e] | 0) * 19 + r2, s10 = h16 & 67108863;
        h16 >>>= 26, t2.words[e] = s10, r2 = h16;
      }
      return r2 !== 0 && (t2.words[t2.length++] = r2), t2;
    }, l22._prime = function(t2) {
      if (ut4[t2])
        return ut4[t2];
      var r2;
      if (t2 === "k256")
        r2 = new lt2();
      else if (t2 === "p224")
        r2 = new Pt2();
      else if (t2 === "p192")
        r2 = new Dt2();
      else if (t2 === "p25519")
        r2 = new vt();
      else
        throw new Error("Unknown prime " + t2);
      return ut4[t2] = r2, r2;
    };
    function x17(o6) {
      if (typeof o6 == "string") {
        var t2 = l22._prime(o6);
        this.m = t2.p, this.prime = t2;
      } else
        v19(o6.gtn(1), "modulus must be greater than 1"), this.m = o6, this.prime = null;
    }
    x17.prototype._verify1 = function(t2) {
      v19(t2.negative === 0, "red works only with positives"), v19(t2.red, "red works only with red numbers");
    }, x17.prototype._verify2 = function(t2, r2) {
      v19((t2.negative | r2.negative) === 0, "red works only with positives"), v19(t2.red && t2.red === r2.red, "red works only with red numbers");
    }, x17.prototype.imod = function(t2) {
      return this.prime ? this.prime.ireduce(t2)._forceRed(this) : t2.umod(this.m)._forceRed(this);
    }, x17.prototype.neg = function(t2) {
      return t2.isZero() ? t2.clone() : this.m.sub(t2)._forceRed(this);
    }, x17.prototype.add = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.add(r2);
      return e.cmp(this.m) >= 0 && e.isub(this.m), e._forceRed(this);
    }, x17.prototype.iadd = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.iadd(r2);
      return e.cmp(this.m) >= 0 && e.isub(this.m), e;
    }, x17.prototype.sub = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.sub(r2);
      return e.cmpn(0) < 0 && e.iadd(this.m), e._forceRed(this);
    }, x17.prototype.isub = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.isub(r2);
      return e.cmpn(0) < 0 && e.iadd(this.m), e;
    }, x17.prototype.shl = function(t2, r2) {
      return this._verify1(t2), this.imod(t2.ushln(r2));
    }, x17.prototype.imul = function(t2, r2) {
      return this._verify2(t2, r2), this.imod(t2.imul(r2));
    }, x17.prototype.mul = function(t2, r2) {
      return this._verify2(t2, r2), this.imod(t2.mul(r2));
    }, x17.prototype.isqr = function(t2) {
      return this.imul(t2, t2.clone());
    }, x17.prototype.sqr = function(t2) {
      return this.mul(t2, t2);
    }, x17.prototype.sqrt = function(t2) {
      if (t2.isZero())
        return t2.clone();
      var r2 = this.m.andln(3);
      if (v19(r2 % 2 === 1), r2 === 3) {
        var e = this.m.add(new l22(1)).iushrn(2);
        return this.pow(t2, e);
      }
      for (var h16 = this.m.subn(1), s10 = 0; !h16.isZero() && h16.andln(1) === 0; )
        s10++, h16.iushrn(1);
      v19(!h16.isZero());
      var a7 = new l22(1).toRed(this), u12 = a7.redNeg(), f8 = this.m.subn(1).iushrn(1), i = this.m.bitLength();
      for (i = new l22(2 * i * i).toRed(this); this.pow(i, f8).cmp(u12) !== 0; )
        i.redIAdd(u12);
      for (var n3 = this.pow(i, h16), d14 = this.pow(t2, h16.addn(1).iushrn(1)), m20 = this.pow(t2, h16), p7 = s10; m20.cmp(a7) !== 0; ) {
        for (var M14 = m20, g17 = 0; M14.cmp(a7) !== 0; g17++)
          M14 = M14.redSqr();
        v19(g17 < p7);
        var c13 = this.pow(n3, new l22(1).iushln(p7 - g17 - 1));
        d14 = d14.redMul(c13), n3 = c13.redSqr(), m20 = m20.redMul(n3), p7 = g17;
      }
      return d14;
    }, x17.prototype.invm = function(t2) {
      var r2 = t2._invmp(this.m);
      return r2.negative !== 0 ? (r2.negative = 0, this.imod(r2).redNeg()) : this.imod(r2);
    }, x17.prototype.pow = function(t2, r2) {
      if (r2.isZero())
        return new l22(1).toRed(this);
      if (r2.cmpn(1) === 0)
        return t2.clone();
      var e = 4, h16 = new Array(1 << e);
      h16[0] = new l22(1).toRed(this), h16[1] = t2;
      for (var s10 = 2; s10 < h16.length; s10++)
        h16[s10] = this.mul(h16[s10 - 1], t2);
      var a7 = h16[0], u12 = 0, f8 = 0, i = r2.bitLength() % 26;
      for (i === 0 && (i = 26), s10 = r2.length - 1; s10 >= 0; s10--) {
        for (var n3 = r2.words[s10], d14 = i - 1; d14 >= 0; d14--) {
          var m20 = n3 >> d14 & 1;
          if (a7 !== h16[0] && (a7 = this.sqr(a7)), m20 === 0 && u12 === 0) {
            f8 = 0;
            continue;
          }
          u12 <<= 1, u12 |= m20, f8++, !(f8 !== e && (s10 !== 0 || d14 !== 0)) && (a7 = this.mul(a7, h16[u12]), f8 = 0, u12 = 0);
        }
        i = 26;
      }
      return a7;
    }, x17.prototype.convertTo = function(t2) {
      var r2 = t2.umod(this.m);
      return r2 === t2 ? r2.clone() : r2;
    }, x17.prototype.convertFrom = function(t2) {
      var r2 = t2.clone();
      return r2.red = null, r2;
    }, l22.mont = function(t2) {
      return new ot2(t2);
    };
    function ot2(o6) {
      x17.call(this, o6), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new l22(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    nt2(ot2, x17), ot2.prototype.convertTo = function(t2) {
      return this.imod(t2.ushln(this.shift));
    }, ot2.prototype.convertFrom = function(t2) {
      var r2 = this.imod(t2.mul(this.rinv));
      return r2.red = null, r2;
    }, ot2.prototype.imul = function(t2, r2) {
      if (t2.isZero() || r2.isZero())
        return t2.words[0] = 0, t2.length = 1, t2;
      var e = t2.imul(r2), h16 = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s10 = e.isub(h16).iushrn(this.shift), a7 = s10;
      return s10.cmp(this.m) >= 0 ? a7 = s10.isub(this.m) : s10.cmpn(0) < 0 && (a7 = s10.iadd(this.m)), a7._forceRed(this);
    }, ot2.prototype.mul = function(t2, r2) {
      if (t2.isZero() || r2.isZero())
        return new l22(0)._forceRed(this);
      var e = t2.mul(r2), h16 = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s10 = e.isub(h16).iushrn(this.shift), a7 = s10;
      return s10.cmp(this.m) >= 0 ? a7 = s10.isub(this.m) : s10.cmpn(0) < 0 && (a7 = s10.iadd(this.m)), a7._forceRed(this);
    }, ot2.prototype.invm = function(t2) {
      var r2 = this.imod(t2._invmp(this.m).mul(this.r2));
      return r2._forceRed(this);
    };
  })(typeof Lt2 > "u" || Lt2, oi);
});
var ai = si(zt());
var li = si(zt());
var { BN: Si } = li;
var { default: _i, ...Ai } = li;
var ki = ai.default ?? _i ?? Ai;
var l = Object.create;
var p = Object.defineProperty;
var c = Object.getOwnPropertyDescriptor;
var s = Object.getOwnPropertyNames;
var y = Object.getPrototypeOf;
var b = Object.prototype.hasOwnProperty;
var d = (t2, e) => () => (e || t2((e = {
  exports: {}
}).exports, e), e.exports);
var m = (t2, e, o6, f8) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n3 of s(e))
      !b.call(t2, n3) && n3 !== o6 && p(t2, n3, {
        get: () => e[n3],
        enumerable: !(f8 = c(e, n3)) || f8.enumerable
      });
  return t2;
};
var u = (t2, e, o6) => (o6 = t2 != null ? l(y(t2)) : {}, m(e || !t2 || !t2.__esModule ? p(o6, "default", {
  value: t2,
  enumerable: true
}) : o6, t2));
var i1 = d((v19, r2) => {
  typeof Object.create == "function" ? r2.exports = function(e, o6) {
    o6 && (e.super_ = o6, e.prototype = Object.create(o6.prototype, {
      constructor: {
        value: e,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : r2.exports = function(e, o6) {
    if (o6) {
      e.super_ = o6;
      var f8 = function() {
      };
      f8.prototype = o6.prototype, e.prototype = new f8(), e.prototype.constructor = e;
    }
  };
});
var a = u(i1());
var $ = u(i1());
var { default: x, ...h } = $;
var w = a.default ?? x ?? h;
var m1 = Object.create;
var a1 = Object.defineProperty;
var p1 = Object.getOwnPropertyDescriptor;
var c1 = Object.getOwnPropertyNames;
var w1 = Object.getPrototypeOf;
var $1 = Object.prototype.hasOwnProperty;
var q = (r2, e) => () => (e || r2((e = {
  exports: {}
}).exports, e), e.exports);
var x1 = (r2, e, t2, s10) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o6 of c1(e))
      !$1.call(r2, o6) && o6 !== t2 && a1(r2, o6, {
        get: () => e[o6],
        enumerable: !(s10 = p1(e, o6)) || s10.enumerable
      });
  return r2;
};
var i2 = (r2, e, t2) => (t2 = r2 != null ? m1(w1(r2)) : {}, x1(e || !r2 || !r2.__esModule ? a1(t2, "default", {
  value: r2,
  enumerable: true
}) : t2, r2));
var f = q((b15, u12) => {
  u12.exports = n3;
  function n3(r2, e) {
    if (!r2)
      throw new Error(e || "Assertion failed");
  }
  n3.equal = function(e, t2, s10) {
    if (e != t2)
      throw new Error(s10 || "Assertion failed: " + e + " != " + t2);
  };
});
var l1 = i2(f());
var d1 = i2(f());
var { equal: g } = d1;
var { default: E, ...h1 } = d1;
var j = l1.default ?? E ?? h1;
var er = Object.create;
var g0 = Object.defineProperty;
var tr = Object.getOwnPropertyDescriptor;
var ar = Object.getOwnPropertyNames;
var hr = Object.getPrototypeOf;
var ir = Object.prototype.hasOwnProperty;
((r2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r2, {
  get: (e, a7) => (typeof require != "undefined" ? require : e)[a7]
}) : r2)(function(r2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var p2 = (r2, e) => () => (e || r2((e = {
  exports: {}
}).exports, e), e.exports);
var nr = (r2, e, a7, h16) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let t2 of ar(e))
      !ir.call(r2, t2) && t2 !== a7 && g0(r2, t2, {
        get: () => e[t2],
        enumerable: !(h16 = tr(e, t2)) || h16.enumerable
      });
  return r2;
};
var S0 = (r2, e, a7) => (a7 = r2 != null ? er(hr(r2)) : {}, nr(e || !r2 || !r2.__esModule ? g0(a7, "default", {
  value: r2,
  enumerable: true
}) : a7, r2));
var g1 = p2((o6) => {
  "use strict";
  var sr = j, fr = w;
  o6.inherits = fr;
  function ur(r2, e) {
    return (r2.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= r2.length ? false : (r2.charCodeAt(e + 1) & 64512) === 56320;
  }
  function cr(r2, e) {
    if (Array.isArray(r2))
      return r2.slice();
    if (!r2)
      return [];
    var a7 = [];
    if (typeof r2 == "string")
      if (e) {
        if (e === "hex")
          for (r2 = r2.replace(/[^a-z0-9]+/ig, ""), r2.length % 2 !== 0 && (r2 = "0" + r2), t2 = 0; t2 < r2.length; t2 += 2)
            a7.push(parseInt(r2[t2] + r2[t2 + 1], 16));
      } else
        for (var h16 = 0, t2 = 0; t2 < r2.length; t2++) {
          var i = r2.charCodeAt(t2);
          i < 128 ? a7[h16++] = i : i < 2048 ? (a7[h16++] = i >> 6 | 192, a7[h16++] = i & 63 | 128) : ur(r2, t2) ? (i = 65536 + ((i & 1023) << 10) + (r2.charCodeAt(++t2) & 1023), a7[h16++] = i >> 18 | 240, a7[h16++] = i >> 12 & 63 | 128, a7[h16++] = i >> 6 & 63 | 128, a7[h16++] = i & 63 | 128) : (a7[h16++] = i >> 12 | 224, a7[h16++] = i >> 6 & 63 | 128, a7[h16++] = i & 63 | 128);
        }
    else
      for (t2 = 0; t2 < r2.length; t2++)
        a7[t2] = r2[t2] | 0;
    return a7;
  }
  o6.toArray = cr;
  function xr2(r2) {
    for (var e = "", a7 = 0; a7 < r2.length; a7++)
      e += q0(r2[a7].toString(16));
    return e;
  }
  o6.toHex = xr2;
  function m0(r2) {
    var e = r2 >>> 24 | r2 >>> 8 & 65280 | r2 << 8 & 16711680 | (r2 & 255) << 24;
    return e >>> 0;
  }
  o6.htonl = m0;
  function or3(r2, e) {
    for (var a7 = "", h16 = 0; h16 < r2.length; h16++) {
      var t2 = r2[h16];
      e === "little" && (t2 = m0(t2)), a7 += H02(t2.toString(16));
    }
    return a7;
  }
  o6.toHex32 = or3;
  function q0(r2) {
    return r2.length === 1 ? "0" + r2 : r2;
  }
  o6.zero2 = q0;
  function H02(r2) {
    return r2.length === 7 ? "0" + r2 : r2.length === 6 ? "00" + r2 : r2.length === 5 ? "000" + r2 : r2.length === 4 ? "0000" + r2 : r2.length === 3 ? "00000" + r2 : r2.length === 2 ? "000000" + r2 : r2.length === 1 ? "0000000" + r2 : r2;
  }
  o6.zero8 = H02;
  function vr2(r2, e, a7, h16) {
    var t2 = a7 - e;
    sr(t2 % 4 === 0);
    for (var i = new Array(t2 / 4), n3 = 0, s10 = e; n3 < i.length; n3++, s10 += 4) {
      var u12;
      h16 === "big" ? u12 = r2[s10] << 24 | r2[s10 + 1] << 16 | r2[s10 + 2] << 8 | r2[s10 + 3] : u12 = r2[s10 + 3] << 24 | r2[s10 + 2] << 16 | r2[s10 + 1] << 8 | r2[s10], i[n3] = u12 >>> 0;
    }
    return i;
  }
  o6.join32 = vr2;
  function dr2(r2, e) {
    for (var a7 = new Array(r2.length * 4), h16 = 0, t2 = 0; h16 < r2.length; h16++, t2 += 4) {
      var i = r2[h16];
      e === "big" ? (a7[t2] = i >>> 24, a7[t2 + 1] = i >>> 16 & 255, a7[t2 + 2] = i >>> 8 & 255, a7[t2 + 3] = i & 255) : (a7[t2 + 3] = i >>> 24, a7[t2 + 2] = i >>> 16 & 255, a7[t2 + 1] = i >>> 8 & 255, a7[t2] = i & 255);
    }
    return a7;
  }
  o6.split32 = dr2;
  function br3(r2, e) {
    return r2 >>> e | r2 << 32 - e;
  }
  o6.rotr32 = br3;
  function lr(r2, e) {
    return r2 << e | r2 >>> 32 - e;
  }
  o6.rotl32 = lr;
  function _r(r2, e) {
    return r2 + e >>> 0;
  }
  o6.sum32 = _r;
  function pr2(r2, e, a7) {
    return r2 + e + a7 >>> 0;
  }
  o6.sum32_3 = pr2;
  function gr2(r2, e, a7, h16) {
    return r2 + e + a7 + h16 >>> 0;
  }
  o6.sum32_4 = gr2;
  function Sr(r2, e, a7, h16, t2) {
    return r2 + e + a7 + h16 + t2 >>> 0;
  }
  o6.sum32_5 = Sr;
  function mr2(r2, e, a7, h16) {
    var t2 = r2[e], i = r2[e + 1], n3 = h16 + i >>> 0, s10 = (n3 < h16 ? 1 : 0) + a7 + t2;
    r2[e] = s10 >>> 0, r2[e + 1] = n3;
  }
  o6.sum64 = mr2;
  function qr2(r2, e, a7, h16) {
    var t2 = e + h16 >>> 0, i = (t2 < e ? 1 : 0) + r2 + a7;
    return i >>> 0;
  }
  o6.sum64_hi = qr2;
  function Hr2(r2, e, a7, h16) {
    var t2 = e + h16;
    return t2 >>> 0;
  }
  o6.sum64_lo = Hr2;
  function Ar2(r2, e, a7, h16, t2, i, n3, s10) {
    var u12 = 0, f8 = e;
    f8 = f8 + h16 >>> 0, u12 += f8 < e ? 1 : 0, f8 = f8 + i >>> 0, u12 += f8 < i ? 1 : 0, f8 = f8 + s10 >>> 0, u12 += f8 < s10 ? 1 : 0;
    var x17 = r2 + a7 + t2 + n3 + u12;
    return x17 >>> 0;
  }
  o6.sum64_4_hi = Ar2;
  function zr(r2, e, a7, h16, t2, i, n3, s10) {
    var u12 = e + h16 + i + s10;
    return u12 >>> 0;
  }
  o6.sum64_4_lo = zr;
  function Br2(r2, e, a7, h16, t2, i, n3, s10, u12, f8) {
    var x17 = 0, c13 = e;
    c13 = c13 + h16 >>> 0, x17 += c13 < e ? 1 : 0, c13 = c13 + i >>> 0, x17 += c13 < i ? 1 : 0, c13 = c13 + s10 >>> 0, x17 += c13 < s10 ? 1 : 0, c13 = c13 + f8 >>> 0, x17 += c13 < f8 ? 1 : 0;
    var v19 = r2 + a7 + t2 + n3 + u12 + x17;
    return v19 >>> 0;
  }
  o6.sum64_5_hi = Br2;
  function yr2(r2, e, a7, h16, t2, i, n3, s10, u12, f8) {
    var x17 = e + h16 + i + s10 + f8;
    return x17 >>> 0;
  }
  o6.sum64_5_lo = yr2;
  function Cr(r2, e, a7) {
    var h16 = e << 32 - a7 | r2 >>> a7;
    return h16 >>> 0;
  }
  o6.rotr64_hi = Cr;
  function Lr(r2, e, a7) {
    var h16 = r2 << 32 - a7 | e >>> a7;
    return h16 >>> 0;
  }
  o6.rotr64_lo = Lr;
  function Wr(r2, e, a7) {
    return r2 >>> a7;
  }
  o6.shr64_hi = Wr;
  function kr2(r2, e, a7) {
    var h16 = r2 << 32 - a7 | e >>> a7;
    return h16 >>> 0;
  }
  o6.shr64_lo = kr2;
});
var K1 = p2((z02) => {
  "use strict";
  var A0 = g1(), Dr2 = j;
  function w24() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  z02.BlockHash = w24;
  w24.prototype.update = function(e, a7) {
    if (e = A0.toArray(e, a7), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var h16 = e.length % this._delta8;
      this.pending = e.slice(e.length - h16, e.length), this.pending.length === 0 && (this.pending = null), e = A0.join32(e, 0, e.length - h16, this.endian);
      for (var t2 = 0; t2 < e.length; t2 += this._delta32)
        this._update(e, t2, t2 + this._delta32);
    }
    return this;
  };
  w24.prototype.digest = function(e) {
    return this.update(this._pad()), Dr2(this.pending === null), this._digest(e);
  };
  w24.prototype._pad = function() {
    var e = this.pendingTotal, a7 = this._delta8, h16 = a7 - (e + this.padLength) % a7, t2 = new Array(h16 + this.padLength);
    t2[0] = 128;
    for (var i = 1; i < h16; i++)
      t2[i] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var n3 = 8; n3 < this.padLength; n3++)
        t2[i++] = 0;
      t2[i++] = 0, t2[i++] = 0, t2[i++] = 0, t2[i++] = 0, t2[i++] = e >>> 24 & 255, t2[i++] = e >>> 16 & 255, t2[i++] = e >>> 8 & 255, t2[i++] = e & 255;
    } else
      for (t2[i++] = e & 255, t2[i++] = e >>> 8 & 255, t2[i++] = e >>> 16 & 255, t2[i++] = e >>> 24 & 255, t2[i++] = 0, t2[i++] = 0, t2[i++] = 0, t2[i++] = 0, n3 = 8; n3 < this.padLength; n3++)
        t2[i++] = 0;
    return t2;
  };
});
var t0 = p2((C11) => {
  "use strict";
  var Fr2 = g1(), q15 = Fr2.rotr32;
  function Er2(r2, e, a7, h16) {
    if (r2 === 0)
      return B02(e, a7, h16);
    if (r2 === 1 || r2 === 3)
      return C0(e, a7, h16);
    if (r2 === 2)
      return y0(e, a7, h16);
  }
  C11.ft_1 = Er2;
  function B02(r2, e, a7) {
    return r2 & e ^ ~r2 & a7;
  }
  C11.ch32 = B02;
  function y0(r2, e, a7) {
    return r2 & e ^ r2 & a7 ^ e & a7;
  }
  C11.maj32 = y0;
  function C0(r2, e, a7) {
    return r2 ^ e ^ a7;
  }
  C11.p32 = C0;
  function Kr(r2) {
    return q15(r2, 2) ^ q15(r2, 13) ^ q15(r2, 22);
  }
  C11.s0_256 = Kr;
  function $r(r2) {
    return q15(r2, 6) ^ q15(r2, 11) ^ q15(r2, 25);
  }
  C11.s1_256 = $r;
  function Ir(r2) {
    return q15(r2, 7) ^ q15(r2, 18) ^ r2 >>> 3;
  }
  C11.g0_256 = Ir;
  function Pr2(r2) {
    return q15(r2, 17) ^ q15(r2, 19) ^ r2 >>> 10;
  }
  C11.g1_256 = Pr2;
});
var k0 = p2(($e2, W0) => {
  "use strict";
  var $17 = g1(), Mr = K1(), Rr2 = t0(), a0 = $17.rotl32, X5 = $17.sum32, Gr = $17.sum32_5, Jr = Rr2.ft_1, L0 = Mr.BlockHash, Nr = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function H9() {
    if (!(this instanceof H9))
      return new H9();
    L0.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  $17.inherits(H9, L0);
  W0.exports = H9;
  H9.blockSize = 512;
  H9.outSize = 160;
  H9.hmacStrength = 80;
  H9.padLength = 64;
  H9.prototype._update = function(e, a7) {
    for (var h16 = this.W, t2 = 0; t2 < 16; t2++)
      h16[t2] = e[a7 + t2];
    for (; t2 < h16.length; t2++)
      h16[t2] = a0(h16[t2 - 3] ^ h16[t2 - 8] ^ h16[t2 - 14] ^ h16[t2 - 16], 1);
    var i = this.h[0], n3 = this.h[1], s10 = this.h[2], u12 = this.h[3], f8 = this.h[4];
    for (t2 = 0; t2 < h16.length; t2++) {
      var x17 = ~~(t2 / 20), c13 = Gr(a0(i, 5), Jr(x17, n3, s10, u12), f8, h16[t2], Nr[x17]);
      f8 = u12, u12 = s10, s10 = a0(n3, 30), n3 = i, i = c13;
    }
    this.h[0] = X5(this.h[0], i), this.h[1] = X5(this.h[1], n3), this.h[2] = X5(this.h[2], s10), this.h[3] = X5(this.h[3], u12), this.h[4] = X5(this.h[4], f8);
  };
  H9.prototype._digest = function(e) {
    return e === "hex" ? $17.toHex32(this.h, "big") : $17.split32(this.h, "big");
  };
});
var h0 = p2((Ie, F0) => {
  "use strict";
  var I13 = g1(), Or = K1(), P13 = t0(), Qr = j, S14 = I13.sum32, Ur = I13.sum32_4, Vr = I13.sum32_5, Xr = P13.ch32, Yr = P13.maj32, Zr = P13.s0_256, jr = P13.s1_256, wr2 = P13.g0_256, Tr = P13.g1_256, D0 = Or.BlockHash, re4 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function A14() {
    if (!(this instanceof A14))
      return new A14();
    D0.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = re4, this.W = new Array(64);
  }
  I13.inherits(A14, D0);
  F0.exports = A14;
  A14.blockSize = 512;
  A14.outSize = 256;
  A14.hmacStrength = 192;
  A14.padLength = 64;
  A14.prototype._update = function(e, a7) {
    for (var h16 = this.W, t2 = 0; t2 < 16; t2++)
      h16[t2] = e[a7 + t2];
    for (; t2 < h16.length; t2++)
      h16[t2] = Ur(Tr(h16[t2 - 2]), h16[t2 - 7], wr2(h16[t2 - 15]), h16[t2 - 16]);
    var i = this.h[0], n3 = this.h[1], s10 = this.h[2], u12 = this.h[3], f8 = this.h[4], x17 = this.h[5], c13 = this.h[6], v19 = this.h[7];
    for (Qr(this.k.length === h16.length), t2 = 0; t2 < h16.length; t2++) {
      var d14 = Vr(v19, jr(f8), Xr(f8, x17, c13), this.k[t2], h16[t2]), _11 = S14(Zr(i), Yr(i, n3, s10));
      v19 = c13, c13 = x17, x17 = f8, f8 = S14(u12, d14), u12 = s10, s10 = n3, n3 = i, i = S14(d14, _11);
    }
    this.h[0] = S14(this.h[0], i), this.h[1] = S14(this.h[1], n3), this.h[2] = S14(this.h[2], s10), this.h[3] = S14(this.h[3], u12), this.h[4] = S14(this.h[4], f8), this.h[5] = S14(this.h[5], x17), this.h[6] = S14(this.h[6], c13), this.h[7] = S14(this.h[7], v19);
  };
  A14.prototype._digest = function(e) {
    return e === "hex" ? I13.toHex32(this.h, "big") : I13.split32(this.h, "big");
  };
});
var $0 = p2((Pe4, K02) => {
  "use strict";
  var i0 = g1(), E0 = h0();
  function L18() {
    if (!(this instanceof L18))
      return new L18();
    E0.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  i0.inherits(L18, E0);
  K02.exports = L18;
  L18.blockSize = 512;
  L18.outSize = 224;
  L18.hmacStrength = 192;
  L18.padLength = 64;
  L18.prototype._digest = function(e) {
    return e === "hex" ? i0.toHex32(this.h.slice(0, 7), "big") : i0.split32(this.h.slice(0, 7), "big");
  };
});
var f0 = p2((Me, R0) => {
  "use strict";
  var l22 = g1(), ee2 = K1(), te2 = j, z15 = l22.rotr64_hi, B18 = l22.rotr64_lo, I0 = l22.shr64_hi, P0 = l22.shr64_lo, k15 = l22.sum64, n0 = l22.sum64_hi, s0 = l22.sum64_lo, ae3 = l22.sum64_4_hi, he3 = l22.sum64_4_lo, ie3 = l22.sum64_5_hi, ne2 = l22.sum64_5_lo, M0 = ee2.BlockHash, se3 = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function m20() {
    if (!(this instanceof m20))
      return new m20();
    M0.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = se3, this.W = new Array(160);
  }
  l22.inherits(m20, M0);
  R0.exports = m20;
  m20.blockSize = 1024;
  m20.outSize = 512;
  m20.hmacStrength = 192;
  m20.padLength = 128;
  m20.prototype._prepareBlock = function(e, a7) {
    for (var h16 = this.W, t2 = 0; t2 < 32; t2++)
      h16[t2] = e[a7 + t2];
    for (; t2 < h16.length; t2 += 2) {
      var i = pe2(h16[t2 - 4], h16[t2 - 3]), n3 = ge2(h16[t2 - 4], h16[t2 - 3]), s10 = h16[t2 - 14], u12 = h16[t2 - 13], f8 = le3(h16[t2 - 30], h16[t2 - 29]), x17 = _e2(h16[t2 - 30], h16[t2 - 29]), c13 = h16[t2 - 32], v19 = h16[t2 - 31];
      h16[t2] = ae3(i, n3, s10, u12, f8, x17, c13, v19), h16[t2 + 1] = he3(i, n3, s10, u12, f8, x17, c13, v19);
    }
  };
  m20.prototype._update = function(e, a7) {
    this._prepareBlock(e, a7);
    var h16 = this.W, t2 = this.h[0], i = this.h[1], n3 = this.h[2], s10 = this.h[3], u12 = this.h[4], f8 = this.h[5], x17 = this.h[6], c13 = this.h[7], v19 = this.h[8], d14 = this.h[9], _11 = this.h[10], G11 = this.h[11], J14 = this.h[12], N6 = this.h[13], r0 = this.h[14], e02 = this.h[15];
    te2(this.k.length === h16.length);
    for (var F12 = 0; F12 < h16.length; F12 += 2) {
      var O9 = r0, Q9 = e02, U7 = de2(v19, d14), V8 = be3(v19, d14), x0 = fe4(v19, d14, _11, G11, J14, N6), o0 = ue4(v19, d14, _11, G11, J14, N6), v02 = this.k[F12], d0 = this.k[F12 + 1], b0 = h16[F12], l0 = h16[F12 + 1], Z2 = ie3(O9, Q9, U7, V8, x0, o0, v02, d0, b0, l0), j13 = ne2(O9, Q9, U7, V8, x0, o0, v02, d0, b0, l0);
      O9 = oe3(t2, i), Q9 = ve2(t2, i), U7 = ce4(t2, i, n3, s10, u12, f8), V8 = xe4(t2, i, n3, s10, u12, f8);
      var _02 = n0(O9, Q9, U7, V8), p02 = s0(O9, Q9, U7, V8);
      r0 = J14, e02 = N6, J14 = _11, N6 = G11, _11 = v19, G11 = d14, v19 = n0(x17, c13, Z2, j13), d14 = s0(c13, c13, Z2, j13), x17 = u12, c13 = f8, u12 = n3, f8 = s10, n3 = t2, s10 = i, t2 = n0(Z2, j13, _02, p02), i = s0(Z2, j13, _02, p02);
    }
    k15(this.h, 0, t2, i), k15(this.h, 2, n3, s10), k15(this.h, 4, u12, f8), k15(this.h, 6, x17, c13), k15(this.h, 8, v19, d14), k15(this.h, 10, _11, G11), k15(this.h, 12, J14, N6), k15(this.h, 14, r0, e02);
  };
  m20.prototype._digest = function(e) {
    return e === "hex" ? l22.toHex32(this.h, "big") : l22.split32(this.h, "big");
  };
  function fe4(r2, e, a7, h16, t2) {
    var i = r2 & a7 ^ ~r2 & t2;
    return i < 0 && (i += 4294967296), i;
  }
  function ue4(r2, e, a7, h16, t2, i) {
    var n3 = e & h16 ^ ~e & i;
    return n3 < 0 && (n3 += 4294967296), n3;
  }
  function ce4(r2, e, a7, h16, t2) {
    var i = r2 & a7 ^ r2 & t2 ^ a7 & t2;
    return i < 0 && (i += 4294967296), i;
  }
  function xe4(r2, e, a7, h16, t2, i) {
    var n3 = e & h16 ^ e & i ^ h16 & i;
    return n3 < 0 && (n3 += 4294967296), n3;
  }
  function oe3(r2, e) {
    var a7 = z15(r2, e, 28), h16 = z15(e, r2, 2), t2 = z15(e, r2, 7), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function ve2(r2, e) {
    var a7 = B18(r2, e, 28), h16 = B18(e, r2, 2), t2 = B18(e, r2, 7), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function de2(r2, e) {
    var a7 = z15(r2, e, 14), h16 = z15(r2, e, 18), t2 = z15(e, r2, 9), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function be3(r2, e) {
    var a7 = B18(r2, e, 14), h16 = B18(r2, e, 18), t2 = B18(e, r2, 9), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function le3(r2, e) {
    var a7 = z15(r2, e, 1), h16 = z15(r2, e, 8), t2 = I0(r2, e, 7), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function _e2(r2, e) {
    var a7 = B18(r2, e, 1), h16 = B18(r2, e, 8), t2 = P0(r2, e, 7), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function pe2(r2, e) {
    var a7 = z15(r2, e, 19), h16 = z15(e, r2, 29), t2 = I0(r2, e, 6), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
  function ge2(r2, e) {
    var a7 = B18(r2, e, 19), h16 = B18(e, r2, 29), t2 = P0(r2, e, 6), i = a7 ^ h16 ^ t2;
    return i < 0 && (i += 4294967296), i;
  }
});
var N0 = p2((Re2, J0) => {
  "use strict";
  var u0 = g1(), G02 = f0();
  function W2() {
    if (!(this instanceof W2))
      return new W2();
    G02.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  u0.inherits(W2, G02);
  J0.exports = W2;
  W2.blockSize = 1024;
  W2.outSize = 384;
  W2.hmacStrength = 192;
  W2.padLength = 128;
  W2.prototype._digest = function(e) {
    return e === "hex" ? u0.toHex32(this.h.slice(0, 12), "big") : u0.split32(this.h.slice(0, 12), "big");
  };
});
var O0 = p2((M14) => {
  "use strict";
  M14.sha1 = k0();
  M14.sha224 = $0();
  M14.sha256 = h0();
  M14.sha384 = N0();
  M14.sha512 = f0();
});
var Z0 = p2((Y0) => {
  "use strict";
  var D12 = g1(), Se2 = K1(), T12 = D12.rotl32, Q0 = D12.sum32, Y7 = D12.sum32_3, U02 = D12.sum32_4, X0 = Se2.BlockHash;
  function y16() {
    if (!(this instanceof y16))
      return new y16();
    X0.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.endian = "little";
  }
  D12.inherits(y16, X0);
  Y0.ripemd160 = y16;
  y16.blockSize = 512;
  y16.outSize = 160;
  y16.hmacStrength = 192;
  y16.padLength = 64;
  y16.prototype._update = function(e, a7) {
    for (var h16 = this.h[0], t2 = this.h[1], i = this.h[2], n3 = this.h[3], s10 = this.h[4], u12 = h16, f8 = t2, x17 = i, c13 = n3, v19 = s10, d14 = 0; d14 < 80; d14++) {
      var _11 = Q0(T12(U02(h16, V0(d14, t2, i, n3), e[He4[d14] + a7], me2(d14)), ze3[d14]), s10);
      h16 = s10, s10 = n3, n3 = T12(i, 10), i = t2, t2 = _11, _11 = Q0(T12(U02(u12, V0(79 - d14, f8, x17, c13), e[Ae3[d14] + a7], qe4(d14)), Be2[d14]), v19), u12 = v19, v19 = c13, c13 = T12(x17, 10), x17 = f8, f8 = _11;
    }
    _11 = Y7(this.h[1], i, c13), this.h[1] = Y7(this.h[2], n3, v19), this.h[2] = Y7(this.h[3], s10, u12), this.h[3] = Y7(this.h[4], h16, f8), this.h[4] = Y7(this.h[0], t2, x17), this.h[0] = _11;
  };
  y16.prototype._digest = function(e) {
    return e === "hex" ? D12.toHex32(this.h, "little") : D12.split32(this.h, "little");
  };
  function V0(r2, e, a7, h16) {
    return r2 <= 15 ? e ^ a7 ^ h16 : r2 <= 31 ? e & a7 | ~e & h16 : r2 <= 47 ? (e | ~a7) ^ h16 : r2 <= 63 ? e & h16 | a7 & ~h16 : e ^ (a7 | ~h16);
  }
  function me2(r2) {
    return r2 <= 15 ? 0 : r2 <= 31 ? 1518500249 : r2 <= 47 ? 1859775393 : r2 <= 63 ? 2400959708 : 2840853838;
  }
  function qe4(r2) {
    return r2 <= 15 ? 1352829926 : r2 <= 31 ? 1548603684 : r2 <= 47 ? 1836072691 : r2 <= 63 ? 2053994217 : 0;
  }
  var He4 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Ae3 = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], ze3 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], Be2 = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
});
var w0 = p2((Ne, j0) => {
  "use strict";
  var ye4 = g1(), Ce = j;
  function R13(r2, e, a7) {
    if (!(this instanceof R13))
      return new R13(r2, e, a7);
    this.Hash = r2, this.blockSize = r2.blockSize / 8, this.outSize = r2.outSize / 8, this.inner = null, this.outer = null, this._init(ye4.toArray(e, a7));
  }
  j0.exports = R13;
  R13.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), Ce(e.length <= this.blockSize);
    for (var a7 = e.length; a7 < this.blockSize; a7++)
      e.push(0);
    for (a7 = 0; a7 < e.length; a7++)
      e[a7] ^= 54;
    for (this.inner = new this.Hash().update(e), a7 = 0; a7 < e.length; a7++)
      e[a7] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  R13.prototype.update = function(e, a7) {
    return this.inner.update(e, a7), this;
  };
  R13.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var c0 = p2((T0) => {
  var b15 = T0;
  b15.utils = g1();
  b15.common = K1();
  b15.sha = O0();
  b15.ripemd = Z0();
  b15.hmac = w0();
  b15.sha1 = b15.sha.sha1;
  b15.sha256 = b15.sha.sha256;
  b15.sha224 = b15.sha.sha224;
  b15.sha384 = b15.sha.sha384;
  b15.sha512 = b15.sha.sha512;
  b15.ripemd160 = b15.ripemd.ripemd160;
});
var rr = S0(c0());
var Le = S0(c0());
var { default: We, ...ke } = Le;
var Qe = rr.default ?? We ?? ke;
var core;
if (Deno?.core) {
  core = Deno.core;
} else {
  core = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}
var _exiting = false;
var kSize = 2048;
var kMask = 2048 - 1;
var FixedCircularBuffer = class {
  bottom;
  top;
  list;
  next;
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask;
    return nextItem;
  }
};
var FixedQueue = class {
  head;
  tail;
  constructor() {
    this.head = this.tail = new FixedCircularBuffer();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};
var queue = new FixedQueue();
var _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
  let runNextTicks = function() {
    if (!core.hasTickScheduled()) {
      core.runMicrotasks();
    }
    if (!core.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections();
    return true;
  }, processTicksAndRejections = function() {
    let tock;
    do {
      while (tock = queue.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core.runMicrotasks();
    } while (!queue.isEmpty());
    core.setHasTickScheduled(false);
  }, __nextTickNative = function(callback, ...args) {
    validateCallback(callback);
    if (_exiting) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [
          args[0]
        ];
        break;
      case 2:
        args_ = [
          args[0],
          args[1]
        ];
        break;
      case 3:
        args_ = [
          args[0],
          args[1],
          args[2]
        ];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue.isEmpty()) {
      core.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue.push(tickObject);
  };
  runNextTicks2 = runNextTicks, processTicksAndRejections2 = processTicksAndRejections, __nextTickNative2 = __nextTickNative;
  core.setNextTickCallback(processTicksAndRejections);
  core.setMacrotaskCallback(runNextTicks);
  _nextTick = __nextTickNative;
} else {
  let __nextTickQueueMicrotask = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  __nextTickQueueMicrotask2 = __nextTickQueueMicrotask;
  _nextTick = __nextTickQueueMicrotask;
}
var runNextTicks2;
var processTicksAndRejections2;
var __nextTickNative2;
var __nextTickQueueMicrotask2;
function nextTick1(callback, ...args) {
  _nextTick(callback, ...args);
}
var State;
(function(State3) {
  State3[State3["PASSTHROUGH"] = 0] = "PASSTHROUGH";
  State3[State3["PERCENT"] = 1] = "PERCENT";
  State3[State3["POSITIONAL"] = 2] = "POSITIONAL";
  State3[State3["PRECISION"] = 3] = "PRECISION";
  State3[State3["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP3) {
  WorP3[WorP3["WIDTH"] = 0] = "WIDTH";
  WorP3[WorP3["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
var Flags = class {
  plus;
  dash;
  sharp;
  space;
  zero;
  lessthan;
  width = -1;
  precision = -1;
};
var min = Math.min;
var UNICODE_REPLACEMENT_CHARACTER = "\uFFFD";
var FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F12) {
  F12[F12["sign"] = 1] = "sign";
  F12[F12["mantissa"] = 2] = "mantissa";
  F12[F12["fractional"] = 3] = "fractional";
  F12[F12["esign"] = 4] = "esign";
  F12[F12["exponent"] = 5] = "exponent";
})(F || (F = {}));
var Printf = class {
  format;
  args;
  i;
  state = State.PASSTHROUGH;
  verb = "";
  buf = "";
  argNum = 0;
  flags = new Flags();
  haveSeen;
  tmpError;
  constructor(format12, ...args) {
    this.format = format12;
    this.args = args;
    this.haveSeen = Array.from({
      length: args.length
    });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c13 = this.format[this.i];
      switch (this.state) {
        case State.PASSTHROUGH:
          if (c13 === "%") {
            this.state = State.PERCENT;
          } else {
            this.buf += c13;
          }
          break;
        case State.PERCENT:
          if (c13 === "%") {
            this.buf += c13;
            this.state = State.PASSTHROUGH;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c13 = this.format[this.i];
      switch (this.state) {
        case State.PERCENT:
          switch (c13) {
            case "[":
              this.handlePositional();
              this.state = State.POSITIONAL;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c13 && c13 <= "9" || c13 === "." || c13 === "*") {
                if (c13 === ".") {
                  this.flags.precision = 0;
                  this.state = State.PRECISION;
                  this.i++;
                } else {
                  this.state = State.WIDTH;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case State.POSITIONAL:
          if (c13 === "*") {
            const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
            this.handleWidthOrPrecisionRef(worp);
            this.state = State.PERCENT;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case WorP.WIDTH:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c13 = fmt[this.i];
      switch (this.state) {
        case State.WIDTH:
          switch (c13) {
            case ".":
              this.flags.precision = 0;
              this.state = State.PRECISION;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(WorP.WIDTH);
              break;
            default: {
              const val = parseInt(c13);
              if (isNaN(val)) {
                this.i--;
                this.state = State.PERCENT;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case State.PRECISION: {
          if (c13 === "*") {
            this.handleWidthOrPrecisionRef(WorP.PRECISION);
            break;
          }
          const val1 = parseInt(c13);
          if (isNaN(val1)) {
            this.i--;
            this.state = State.PERCENT;
            return;
          }
          flags.precision *= 10;
          flags.precision += val1;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format12 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format12[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format12[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = State.PASSTHROUGH;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s10) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s10.padEnd(this.flags.width, padding);
    }
    return s10.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign2;
    if (neg3) {
      sign2 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign2 = this.flags.plus ? "+" : " ";
    } else {
      sign2 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign2 + nStr;
    }
    const pad2 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign2.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad2);
    } else {
      nStr = nStr.padStart(len, pad2);
    }
    if (zero) {
      nStr = sign2 + nStr;
    }
    return nStr;
  }
  fmtNumber(n3, radix, upcase = false) {
    let num = Math.abs(n3).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n3 === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n3 < 0);
  }
  fmtNumberCodePoint(n3) {
    let s10 = "";
    try {
      s10 = String.fromCodePoint(n3);
    } catch {
      s10 = UNICODE_REPLACEMENT_CHARACTER;
    }
    return this.pad(s10);
  }
  fmtFloatSpecial(n3) {
    if (isNaN(n3)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n3 === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n3 === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [
      fractional,
      round
    ];
  }
  fmtFloatE(n3, upcase = false) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    const m20 = n3.toExponential().match(FLOAT_REGEXP);
    if (!m20) {
      throw Error("can't happen, bug");
    }
    let fractional = m20[F.fractional];
    const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m20[F.exponent];
    let esign = m20[F.esign];
    let mantissa = parseInt(m20[F.mantissa]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r2 = parseInt(esign + e) + 1;
        e = r2.toString();
        esign = r2 < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n3 < 0);
  }
  fmtFloatF(n3) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    function expandNumber(n4) {
      if (Number.isSafeInteger(n4)) {
        return n4.toString() + ".";
      }
      const t2 = n4.toExponential().split("e");
      let m20 = t2[0].replace(".", "");
      const e = parseInt(t2[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m20;
      } else {
        const splIdx = e + 1;
        while (m20.length < splIdx) {
          m20 += "0";
        }
        return m20.substr(0, splIdx) + "." + m20.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n3));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n3 < 0);
  }
  fmtFloatG(n3, upcase = false) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    let P13 = this.flags.precision !== -1 ? this.flags.precision : 6;
    P13 = P13 === 0 ? 1 : P13;
    const m20 = n3.toExponential().match(FLOAT_REGEXP);
    if (!m20) {
      throw Error("can't happen");
    }
    const X5 = parseInt(m20[F.exponent]) * (m20[F.esign] === "-" ? -1 : 1);
    let nStr = "";
    if (P13 > X5 && X5 >= -4) {
      this.flags.precision = P13 - (X5 + 1);
      nStr = this.fmtFloatF(n3);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P13 - 1;
      nStr = this.fmtFloatE(n3);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s10) {
    if (this.flags.precision !== -1) {
      s10 = s10.substr(0, this.flags.precision);
    }
    return this.pad(s10);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c13 = (val.charCodeAt(i) & 255).toString(16);
          hex += c13.length === 1 ? `0${c13}` : c13;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? {
        depth: this.flags.precision
      } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p7 = this.flags.precision;
      return p7 === -1 ? val.toString() : val.toString().substr(0, p7);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf(format12, ...args) {
  const printf = new Printf(format12, ...args);
  return printf.doPrintf();
}
function delay(ms, options = {}) {
  const { signal } = options;
  if (signal?.aborted) {
    return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
  }
  return new Promise((resolve9, reject) => {
    const abort = () => {
      clearTimeout(i);
      reject(new DOMException("Delay was aborted.", "AbortError"));
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve9();
    };
    const i = setTimeout(done, ms);
    signal?.addEventListener("abort", abort, {
      once: true
    });
  });
}
var { Deno: Deno1 } = globalThis;
var noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code2) {
  return enabled ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}` : str;
}
function bold(str) {
  return run(str, code([
    1
  ], 22));
}
function red(str) {
  return run(str, code([
    31
  ], 39));
}
function green(str) {
  return run(str, code([
    32
  ], 39));
}
function white(str) {
  return run(str, code([
    37
  ], 39));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([
    90
  ], 39));
}
function bgRed(str) {
  return run(str, code([
    41
  ], 49));
}
function bgGreen(str) {
  return run(str, code([
    42
  ], 49));
}
new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
var DiffType;
(function(DiffType3) {
  DiffType3["removed"] = "removed";
  DiffType3["common"] = "common";
  DiffType3["added"] = "added";
})(DiffType || (DiffType = {}));
var REMOVED = 1;
var COMMON = 2;
var ADDED = 3;
function createCommon(A14, B18, reverse2) {
  const common = [];
  if (A14.length === 0 || B18.length === 0)
    return [];
  for (let i = 0; i < Math.min(A14.length, B18.length); i += 1) {
    if (A14[reverse2 ? A14.length - i - 1 : i] === B18[reverse2 ? B18.length - i - 1 : i]) {
      common.push(A14[reverse2 ? A14.length - i - 1 : i]);
    } else {
      return common;
    }
  }
  return common;
}
function diff(A14, B18) {
  const prefixCommon = createCommon(A14, B18);
  const suffixCommon = createCommon(A14.slice(prefixCommon.length), B18.slice(prefixCommon.length), true).reverse();
  A14 = suffixCommon.length ? A14.slice(prefixCommon.length, -suffixCommon.length) : A14.slice(prefixCommon.length);
  B18 = suffixCommon.length ? B18.slice(prefixCommon.length, -suffixCommon.length) : B18.slice(prefixCommon.length);
  const swapped = B18.length > A14.length;
  [A14, B18] = swapped ? [
    B18,
    A14
  ] : [
    A14,
    B18
  ];
  const M14 = A14.length;
  const N6 = B18.length;
  if (!M14 && !N6 && !suffixCommon.length && !prefixCommon.length)
    return [];
  if (!N6) {
    return [
      ...prefixCommon.map((c13) => ({
        type: DiffType.common,
        value: c13
      })),
      ...A14.map((a7) => ({
        type: swapped ? DiffType.added : DiffType.removed,
        value: a7
      })),
      ...suffixCommon.map((c13) => ({
        type: DiffType.common,
        value: c13
      }))
    ];
  }
  const offset = N6;
  const delta = M14 - N6;
  const size = M14 + N6 + 1;
  const fp = Array.from({
    length: size
  }, () => ({
    y: -1,
    id: -1
  }));
  const routes = new Uint32Array((M14 * N6 + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p7 = -1;
  function backTrace(A15, B19, current, swapped2) {
    const M15 = A15.length;
    const N7 = B19.length;
    const result = [];
    let a7 = M15 - 1;
    let b15 = N7 - 1;
    let j13 = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while (true) {
      if (!j13 && !type)
        break;
      const prev = j13;
      if (type === 1) {
        result.unshift({
          type: swapped2 ? DiffType.removed : DiffType.added,
          value: B19[b15]
        });
        b15 -= 1;
      } else if (type === 3) {
        result.unshift({
          type: swapped2 ? DiffType.added : DiffType.removed,
          value: A15[a7]
        });
        a7 -= 1;
      } else {
        result.unshift({
          type: DiffType.common,
          value: A15[a7]
        });
        a7 -= 1;
        b15 -= 1;
      }
      j13 = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k15, M15) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return {
        y: 0,
        id: 0
      };
    }
    if (down && down.y === -1 || k15 === M15 || (slide && slide.y) > (down && down.y) + 1) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return {
        y: slide.y,
        id: ptr
      };
    } else {
      const prev1 = down.id;
      ptr++;
      routes[ptr] = prev1;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return {
        y: down.y + 1,
        id: ptr
      };
    }
  }
  function snake(k15, slide, down, _offset, A15, B19) {
    const M15 = A15.length;
    const N7 = B19.length;
    if (k15 < -N7 || M15 < k15)
      return {
        y: -1,
        id: -1
      };
    const fp2 = createFP(slide, down, k15, M15);
    while (fp2.y + k15 < M15 && fp2.y < N7 && A15[fp2.y + k15] === B19[fp2.y]) {
      const prev = fp2.id;
      ptr++;
      fp2.id = ptr;
      fp2.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp2;
  }
  while (fp[delta + offset].y < N6) {
    p7 = p7 + 1;
    for (let k15 = -p7; k15 < delta; ++k15) {
      fp[k15 + offset] = snake(k15, fp[k15 - 1 + offset], fp[k15 + 1 + offset], offset, A14, B18);
    }
    for (let k15 = delta + p7; k15 > delta; --k15) {
      fp[k15 + offset] = snake(k15, fp[k15 - 1 + offset], fp[k15 + 1 + offset], offset, A14, B18);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A14, B18);
  }
  return [
    ...prefixCommon.map((c13) => ({
      type: DiffType.common,
      value: c13
    })),
    ...backTrace(A14, B18, fp[delta + offset], swapped),
    ...suffixCommon.map((c13) => ({
      type: DiffType.common,
      value: c13
    }))
  ];
}
function diffstr(A14, B18) {
  function unescape2(string) {
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("	", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str) => str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      for (let i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token) => token);
    } else {
      const tokens1 = [], lines = string.split(/(\n|\r\n)/);
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      for (let i12 = 0; i12 < lines.length; i12++) {
        if (i12 % 2) {
          tokens1[tokens1.length - 1] += lines[i12];
        } else {
          tokens1.push(lines[i12]);
        }
      }
      return tokens1;
    }
  }
  function createDetails(line, tokens) {
    return tokens.filter(({ type }) => type === line.type || type === DiffType.common).map((result, i, t2) => {
      if (result.type === DiffType.common && t2[i - 1] && t2[i - 1]?.type === t2[i + 1]?.type && /\s+/.test(result.value)) {
        result.type = t2[i - 1].type;
      }
      return result;
    });
  }
  const diffResult = diff(tokenize(`${unescape2(A14)}
`), tokenize(`${unescape2(B18)}
`));
  const added = [], removed = [];
  for (const result of diffResult) {
    if (result.type === DiffType.added) {
      added.push(result);
    }
    if (result.type === DiffType.removed) {
      removed.push(result);
    }
  }
  const aLines = added.length < removed.length ? added : removed;
  const bLines = aLines === removed ? added : removed;
  for (const a7 of aLines) {
    let tokens = [], b15;
    while (bLines.length) {
      b15 = bLines.shift();
      tokens = diff(tokenize(a7.value, {
        wordDiff: true
      }), tokenize(b15?.value ?? "", {
        wordDiff: true
      }));
      if (tokens.some(({ type, value }) => type === DiffType.common && value.trim().length)) {
        break;
      }
    }
    a7.details = createDetails(a7, tokens);
    if (b15) {
      b15.details = createDetails(b15, tokens);
    }
  }
  return diffResult;
}
function createColor(diffType, { background = false } = {}) {
  switch (diffType) {
    case DiffType.added:
      return (s10) => background ? bgGreen(white(s10)) : green(bold(s10));
    case DiffType.removed:
      return (s10) => background ? bgRed(white(s10)) : red(bold(s10));
    default:
      return white;
  }
}
function createSign(diffType) {
  switch (diffType) {
    case DiffType.added:
      return "+   ";
    case DiffType.removed:
      return "-   ";
    default:
      return "    ";
  }
}
function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [], diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result) => {
    const c13 = createColor(result.type);
    const line = result.details?.map((detail) => detail.type !== DiffType.common ? createColor(detail.type, {
      background: true
    })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c13(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages);
  messages.push("");
  return messages;
}
function format(v19) {
  const { Deno: Deno12 } = globalThis;
  return typeof Deno12?.inspect === "function" ? Deno12.inspect(v19, {
    depth: Infinity,
    sorted: true,
    trailingComma: true,
    compact: false,
    iterableLimit: Infinity
  }) : `"${String(v19).replace(/(?=["\\])/g, "\\")}"`;
}
var CAN_NOT_DISPLAY = "[Cannot display]";
var AssertionError = class extends Error {
  name = "AssertionError";
  constructor(message) {
    super(message);
  }
};
function isKeyedCollection(x17) {
  return [
    Symbol.iterator,
    "size"
  ].every((k15) => k15 in x17);
}
function equal(c13, d14) {
  const seen = /* @__PURE__ */ new Map();
  return function compare11(a7, b15) {
    if (a7 && b15 && (a7 instanceof RegExp && b15 instanceof RegExp || a7 instanceof URL && b15 instanceof URL)) {
      return String(a7) === String(b15);
    }
    if (a7 instanceof Date && b15 instanceof Date) {
      const aTime = a7.getTime();
      const bTime = b15.getTime();
      if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
        return true;
      }
      return aTime === bTime;
    }
    if (typeof a7 === "number" && typeof b15 === "number") {
      return Number.isNaN(a7) && Number.isNaN(b15) || a7 === b15;
    }
    if (Object.is(a7, b15)) {
      return true;
    }
    if (a7 && typeof a7 === "object" && b15 && typeof b15 === "object") {
      if (a7 && b15 && !constructorsEqual(a7, b15)) {
        return false;
      }
      if (a7 instanceof WeakMap || b15 instanceof WeakMap) {
        if (!(a7 instanceof WeakMap && b15 instanceof WeakMap))
          return false;
        throw new TypeError("cannot compare WeakMap instances");
      }
      if (a7 instanceof WeakSet || b15 instanceof WeakSet) {
        if (!(a7 instanceof WeakSet && b15 instanceof WeakSet))
          return false;
        throw new TypeError("cannot compare WeakSet instances");
      }
      if (seen.get(a7) === b15) {
        return true;
      }
      if (Object.keys(a7 || {}).length !== Object.keys(b15 || {}).length) {
        return false;
      }
      seen.set(a7, b15);
      if (isKeyedCollection(a7) && isKeyedCollection(b15)) {
        if (a7.size !== b15.size) {
          return false;
        }
        let unmatchedEntries = a7.size;
        for (const [aKey, aValue] of a7.entries()) {
          for (const [bKey, bValue] of b15.entries()) {
            if (aKey === aValue && bKey === bValue && compare11(aKey, bKey) || compare11(aKey, bKey) && compare11(aValue, bValue)) {
              unmatchedEntries--;
            }
          }
        }
        return unmatchedEntries === 0;
      }
      const merged = {
        ...a7,
        ...b15
      };
      for (const key2 of [
        ...Object.getOwnPropertyNames(merged),
        ...Object.getOwnPropertySymbols(merged)
      ]) {
        if (!compare11(a7 && a7[key2], b15 && b15[key2])) {
          return false;
        }
        if (key2 in a7 && !(key2 in b15) || key2 in b15 && !(key2 in a7)) {
          return false;
        }
      }
      if (a7 instanceof WeakRef || b15 instanceof WeakRef) {
        if (!(a7 instanceof WeakRef && b15 instanceof WeakRef))
          return false;
        return compare11(a7.deref(), b15.deref());
      }
      return true;
    }
    return false;
  }(c13, d14);
}
function constructorsEqual(a7, b15) {
  return a7.constructor === b15.constructor || a7.constructor === Object && !b15.constructor || !a7.constructor && b15.constructor === Object;
}
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}
function assertEquals(actual, expected, msg) {
  if (equal(actual, expected)) {
    return;
  }
  let message = "";
  const actualString = format(actual);
  const expectedString = format(expected);
  try {
    const stringDiff = typeof actual === "string" && typeof expected === "string";
    const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
    const diffMsg = buildMessage(diffResult, {
      stringDiff
    }).join("\n");
    message = `Values are not equal:
${diffMsg}`;
  } catch {
    message = `
${red(CAN_NOT_DISPLAY)} + 

`;
  }
  if (msg) {
    message = msg;
  }
  throw new AssertionError(message);
}
function unreachable() {
  throw new AssertionError("unreachable");
}
function notImplemented(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  throw new Error(message);
}
function warnNotImplemented(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  console.warn(message);
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function normalizeEncoding1(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases1(enc);
}
function slowCases1(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}
function guessHandleType(_fd) {
  notImplemented("util.guessHandleType");
}
var isNumericLookup = {};
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k15) => !isArrayIndex(k15));
  }
  if (filter === 0) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & 1 && !desc.writable) {
      continue;
    }
    if (filter & 2 && !desc.enumerable) {
      continue;
    }
    if (filter & 4 && !desc.configurable) {
      continue;
    }
    if (filter & 8 && typeof key2 === "string") {
      continue;
    }
    if (filter & 16 && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}
var mod3 = function() {
  return {
    guessHandleType,
    ALL_PROPERTIES: 0,
    ONLY_WRITABLE: 1,
    ONLY_ENUMERABLE: 2,
    ONLY_CONFIGURABLE: 4,
    ONLY_ENUM_WRITABLE: 6,
    SKIP_STRINGS: 8,
    SKIP_SYMBOLS: 16,
    isArrayIndex,
    getOwnNonIndexProperties
  };
}();
var kObjectType = 0;
var kArrayExtrasType = 2;
var kRejected = 2;
var meta = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject = (v19) => typeof v19 === "undefined" && v19 !== void 0;
var strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect2(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    maxStringLength: inspectDefaultOptions.maxStringLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue(ctx, value, 0);
}
var customInspectSymbol1 = Symbol.for("nodejs.util.inspect.custom");
inspect2.custom = customInspectSymbol1;
Object.defineProperty(inspect2, "defaultOptions", {
  get() {
    return inspectDefaultOptions;
  },
  set(options) {
    validateObject(options, "options");
    return Object.assign(inspectDefaultOptions, options);
  }
});
var defaultFG = 39;
var defaultBG = 49;
inspect2.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [
    0,
    0
  ],
  bold: [
    1,
    22
  ],
  dim: [
    2,
    22
  ],
  italic: [
    3,
    23
  ],
  underline: [
    4,
    24
  ],
  blink: [
    5,
    25
  ],
  inverse: [
    7,
    27
  ],
  hidden: [
    8,
    28
  ],
  strikethrough: [
    9,
    29
  ],
  doubleunderline: [
    21,
    24
  ],
  black: [
    30,
    defaultFG
  ],
  red: [
    31,
    defaultFG
  ],
  green: [
    32,
    defaultFG
  ],
  yellow: [
    33,
    defaultFG
  ],
  blue: [
    34,
    defaultFG
  ],
  magenta: [
    35,
    defaultFG
  ],
  cyan: [
    36,
    defaultFG
  ],
  white: [
    37,
    defaultFG
  ],
  bgBlack: [
    40,
    defaultBG
  ],
  bgRed: [
    41,
    defaultBG
  ],
  bgGreen: [
    42,
    defaultBG
  ],
  bgYellow: [
    43,
    defaultBG
  ],
  bgBlue: [
    44,
    defaultBG
  ],
  bgMagenta: [
    45,
    defaultBG
  ],
  bgCyan: [
    46,
    defaultBG
  ],
  bgWhite: [
    47,
    defaultBG
  ],
  framed: [
    51,
    54
  ],
  overlined: [
    53,
    55
  ],
  gray: [
    90,
    defaultFG
  ],
  redBright: [
    91,
    defaultFG
  ],
  greenBright: [
    92,
    defaultFG
  ],
  yellowBright: [
    93,
    defaultFG
  ],
  blueBright: [
    94,
    defaultFG
  ],
  magentaBright: [
    95,
    defaultFG
  ],
  cyanBright: [
    96,
    defaultFG
  ],
  whiteBright: [
    97,
    defaultFG
  ],
  bgGray: [
    100,
    defaultBG
  ],
  bgRedBright: [
    101,
    defaultBG
  ],
  bgGreenBright: [
    102,
    defaultBG
  ],
  bgYellowBright: [
    103,
    defaultBG
  ],
  bgBlueBright: [
    104,
    defaultBG
  ],
  bgMagentaBright: [
    105,
    defaultBG
  ],
  bgCyanBright: [
    106,
    defaultBG
  ],
  bgWhiteBright: [
    107,
    defaultBG
  ]
});
function defineColorAlias(target, alias) {
  Object.defineProperty(inspect2.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect2.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn = (str) => meta[str.charCodeAt(0)];
function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
  const style = inspect2.styles[styleType];
  if (style !== void 0) {
    const color = inspect2.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor(str) {
  return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
    return formatPrimitive(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol1];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base2 = "";
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? 0 : 2;
  let extrasType = 0;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties(value, filter);
      braces = [
        `${prefix}[`,
        "]"
      ];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet1(value)) {
      const size = value.size;
      const prefix1 = getPrefix(constructor, tag2, "Set", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix1}{}`;
      }
      braces = [
        `${prefix1}{`,
        "}"
      ];
    } else if (isMap1(value)) {
      const size1 = value.size;
      const prefix2 = getPrefix(constructor, tag2, "Map", `(${size1})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
      if (size1 === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix2}{}`;
      }
      braces = [
        `${prefix2}{`,
        "}"
      ];
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const bound = value;
      const fallback = "";
      const size2 = value.length;
      const prefix3 = getPrefix(constructor, tag2, fallback, `(${size2})`);
      braces = [
        `${prefix3}[`,
        "]"
      ];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray.bind(null, bound, size2);
      extrasType = kArrayExtrasType;
    } else if (isMapIterator1(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Map", tag2);
      formatter = formatIterator.bind(null, braces);
    } else if (isSetIterator1(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Set", tag2);
      formatter = formatIterator.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = [
      "{",
      "}"
    ];
    if (constructor === "Object") {
      if (isArgumentsObject1(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base2 = getFunctionBase(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "special");
      }
    } else if (isRegExp1(value)) {
      base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix4 = getPrefix(constructor, tag2, "RegExp");
      if (prefix4 !== "RegExp ") {
        base2 = `${prefix4}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base2, "regexp");
      }
    } else if (isDate1(value)) {
      base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix5 = getPrefix(constructor, tag2, "Date");
      if (prefix5 !== "Date ") {
        base2 = `${prefix5}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "date");
      }
    } else if (value instanceof Error) {
      base2 = formatError(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else if (isAnyArrayBuffer1(value)) {
      const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix6 = getPrefix(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix6 + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix6}{`;
      Array.prototype.unshift(keys, "byteLength");
    } else if (isDataView1(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise1(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "Promise")}{`;
      formatter = formatPromise;
    } else if (isWeakSet1(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap1(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
    } else if (isModuleNamespaceObject1(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject.bind(null, keys);
    } else if (isBoxedPrimitive1(value)) {
      base2 = getBoxedBase(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName1 = getCtxStyle(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName1, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base2 = base2 === "" ? reference : `${reference} ${base2}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === 0) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString(ctx, output, base2, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty(ctx, obj2, recurseTimes, key2, 0, desc, main);
      if (ctx.colors) {
        Array.prototype.push(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push(output, value);
      }
    }
    Array.prototype.pop(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects.has(descriptor.value.name))) {
        addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect2(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
  return [];
}
function isInstanceof(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty(ctx, value, recurseTimes, i, 1));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix(constructor, tag2, fallback);
}
function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v19 of value) {
    Array.prototype.push(output, formatValue(ctx, v19, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k15, 1: v19 } of value) {
    output.push(`${formatValue(ctx, k15, recurseTimes)} => ${formatValue(ctx, v19, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue(ctx, value[key2], recurseTimes, true);
      Array.prototype.push(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [
    `[${tag2}] {`,
    "}"
  ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner(ctx, recurseTimes, entries, 2);
  }
  return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag2) {
  const stringified = Function.prototype.toString(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice6 = stringified.slice(5, -1);
    const bracketIndex = slice6.indexOf("{");
    if (bracketIndex !== -1 && (!slice6.slice(0, bracketIndex).includes("(") || classRegExp.test(slice6.replace(stripCommentsRegExp)))) {
      return getClassBase(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction1(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction1(value)) {
    type = `Async${type}`;
  }
  let base2 = `[${type}`;
  if (constructor === null) {
    base2 += " (null prototype)";
  }
  if (value.name === "") {
    base2 += " (anonymous)";
  } else {
    base2 += `: ${value.name}`;
  }
  base2 += "]";
  if (constructor !== type && constructor !== null) {
    base2 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base2 += ` [${tag2}]`;
  }
  return base2;
}
function formatError(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name1 of [
      "name",
      "message",
      "stack"
    ]) {
      const index = keys.indexOf(name1);
      if (index !== -1 && stack.includes(err[name1])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos1 = 0;
      while (nodeModule = nodeModulesRegExp.exec(line)) {
        newStack += line.slice(pos1, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos1 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos1 === 0 ? line : line.slice(pos1);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice2;
function formatArrayBuffer(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [
      ctx.stylize("(detached)", "special")
    ];
  }
  let str = hexSlice2(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [
    `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
  ];
}
function formatNumber(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === 0) {
    output = [
      ctx.stylize("<pending>", "special")
    ];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection(ctx) {
  return [
    ctx.stylize("<items unknown>", "special")
  ];
}
function formatWeakSet(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || {
    value: value[key2],
    enumerable: true
  };
  if (desc.value !== void 0) {
    const diff2 = ctx.compact !== true || type !== 0 ? 2 : 3;
    ctx.indentationLvl += diff2;
    str = formatValue(ctx, desc.value, recurseTimes);
    if (diff2 === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff2;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s10 = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s10(`[${label}:`, sp)} ${s10("null", "null")}${s10("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s10(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s10, tmp, ctx);
          str = `${s10(`[${label}:`, sp)} ${primitive}${s10("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s10(`[${label}:`, sp)} ${message}${s10("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === 1) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp1 = key2.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp1, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp2 = key2.replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${tmp2}]`;
  } else if (keyStrRegExp.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
  return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base2) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base2 === "" || !base2.includes("\n");
}
function formatBigInt(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
    } catch (_err) {
      const tmp = {
        [keys[i]]: ""
      };
      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty(ctx, value, recurseTimes, key2, 1));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending1 = remaining > 1 ? "s" : "";
      const message1 = `<${remaining} empty item${ending1}>`;
      output.push(ctx.stylize(message1, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject1(value)) {
    type = "Number";
  } else if (isStringObject1(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject1(value)) {
    type = "Boolean";
  } else if (isBigIntObject1(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base2 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base2 += " (null prototype)";
    } else {
      base2 += ` (${constructor})`;
    }
  }
  base2 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base2 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base2;
  }
  return ctx.stylize(base2, type.toLowerCase());
}
function getClassBase(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base2 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base2 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base2 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base2 += ` extends ${superName}`;
    }
  } else {
    base2 += " extends [null prototype]";
  }
  return `[${base2}]`;
}
function reduceToSingleString(ctx, output, base2, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === 2 && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base2.length + 10;
        if (isBelowBreakLength(ctx, output, start, base2)) {
          return `${base2 ? `${base2} ` : ""}${braces[0]} ${join(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base2 ? `${base2} ` : ""}${braces[0]}${indentation}  ${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  }
  if (isBelowBreakLength(ctx, output, 0, base2)) {
    return `${braces[0]}${base2 ? ` ${base2}` : ""} ${join(output, ", ")} ` + braces[1];
  }
  const indentation1 = " ".repeat(ctx.indentationLvl);
  const ln = base2 === "" && braces[0].length === 1 ? " " : `${base2 ? ` ${base2}` : ""}
${indentation1}  `;
  return `${braces[0]}${ln}${join(output, `,
${indentation1}  `)} ${braces[1]}`;
}
function join(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + 2;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i12 = 0; i12 < columns; i12++) {
      let lineMaxLength = 0;
      for (let j13 = i12; j13 < output.length; j13 += columns) {
        if (dataLen[j13] > lineMaxLength) {
          lineMaxLength = dataLen[j13];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i12] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i22 = 0; i22 < output.length; i22++) {
        if (typeof value[i22] !== "number" && typeof value[i22] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i32 = 0; i32 < outputLength; i32 += columns) {
      const max2 = Math.min(i32 + columns, outputLength);
      let str = "";
      let j13 = i32;
      for (; j13 < max2 - 1; j13++) {
        const padding = maxLineLength[j13 - i32] + output[j13].length - dataLen[j13];
        str += `${output[j13]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding1 = maxLineLength[j13 - i32] + output[j13].length - dataLen[j13] - 2;
        str += output[j13].padStart(padding1, " ");
      } else {
        str += output[j13];
      }
      Array.prototype.push(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === 0) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos1 = i * 2;
      const res = [
        formatValue(ctx, entries[pos1], recurseTimes),
        formatValue(ctx, entries[pos1 + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString(ctx, res, "", [
        "[",
        "]"
      ], kArrayExtrasType, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === 0 && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters(str);
  }
  str = str.normalize("NFC");
  for (const __char of str[Symbol.iterator]()) {
    const code2 = __char.codePointAt(0);
    if (isFullWidthCodePoint(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function stripVTControlCharacters(str) {
  validateString(str, "str");
  return str.replace(ansi, "");
}
var debugImpls;
var testEnabled;
function initializeDebugEnv(debugEnv3) {
  debugImpls = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled = () => false;
  }
}
function emitWarningIfNeeded(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop = () => {
};
function debuglogImpl(enabled2, set) {
  if (debugImpls[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded(set);
      debugImpls[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect2(arg)).join(" ");
        console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls[set] = noop;
    }
  }
  return debugImpls[set];
}
function debuglog(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv;
try {
  debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error2) {
  if (error2 instanceof Deno.errors.PermissionDenied) {
    debugEnv = "";
  } else {
    throw error2;
  }
}
initializeDebugEnv(debugEnv);
var osType = (() => {
  const { Deno: Deno12 } = globalThis;
  if (typeof Deno12?.build?.os === "string") {
    return Deno12.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";
var isLinux = osType === "linux";
function uvTranslateSysError(sysErrno) {
  switch (sysErrno) {
    case 5:
      return "EACCES";
    case 998:
      return "EACCES";
    case 10013:
      return "EACCES";
    case 1920:
      return "EACCES";
    case 1227:
      return "EADDRINUSE";
    case 10048:
      return "EADDRINUSE";
    case 10049:
      return "EADDRNOTAVAIL";
    case 10047:
      return "EAFNOSUPPORT";
    case 10035:
      return "EAGAIN";
    case 10037:
      return "EALREADY";
    case 1004:
      return "EBADF";
    case 6:
      return "EBADF";
    case 33:
      return "EBUSY";
    case 231:
      return "EBUSY";
    case 32:
      return "EBUSY";
    case 995:
      return "ECANCELED";
    case 10004:
      return "ECANCELED";
    case 1113:
      return "ECHARSET";
    case 1236:
      return "ECONNABORTED";
    case 10053:
      return "ECONNABORTED";
    case 1225:
      return "ECONNREFUSED";
    case 10061:
      return "ECONNREFUSED";
    case 64:
      return "ECONNRESET";
    case 10054:
      return "ECONNRESET";
    case 183:
      return "EEXIST";
    case 80:
      return "EEXIST";
    case 111:
      return "EFAULT";
    case 10014:
      return "EFAULT";
    case 1232:
      return "EHOSTUNREACH";
    case 10065:
      return "EHOSTUNREACH";
    case 122:
      return "EINVAL";
    case 13:
      return "EINVAL";
    case 123:
      return "EINVAL";
    case 87:
      return "EINVAL";
    case 10022:
      return "EINVAL";
    case 10046:
      return "EINVAL";
    case 1102:
      return "EIO";
    case 1111:
      return "EIO";
    case 23:
      return "EIO";
    case 1166:
      return "EIO";
    case 1165:
      return "EIO";
    case 1393:
      return "EIO";
    case 1129:
      return "EIO";
    case 1101:
      return "EIO";
    case 31:
      return "EIO";
    case 1106:
      return "EIO";
    case 1117:
      return "EIO";
    case 1104:
      return "EIO";
    case 205:
      return "EIO";
    case 110:
      return "EIO";
    case 1103:
      return "EIO";
    case 156:
      return "EIO";
    case 10056:
      return "EISCONN";
    case 1921:
      return "ELOOP";
    case 4:
      return "EMFILE";
    case 10024:
      return "EMFILE";
    case 10040:
      return "EMSGSIZE";
    case 206:
      return "ENAMETOOLONG";
    case 1231:
      return "ENETUNREACH";
    case 10051:
      return "ENETUNREACH";
    case 10055:
      return "ENOBUFS";
    case 161:
      return "ENOENT";
    case 267:
      return "ENOTDIR";
    case 203:
      return "ENOENT";
    case 2:
      return "ENOENT";
    case 15:
      return "ENOENT";
    case 4392:
      return "ENOENT";
    case 126:
      return "ENOENT";
    case 3:
      return "ENOENT";
    case 11001:
      return "ENOENT";
    case 11004:
      return "ENOENT";
    case 8:
      return "ENOMEM";
    case 14:
      return "ENOMEM";
    case 82:
      return "ENOSPC";
    case 112:
      return "ENOSPC";
    case 277:
      return "ENOSPC";
    case 1100:
      return "ENOSPC";
    case 39:
      return "ENOSPC";
    case 2250:
      return "ENOTCONN";
    case 10057:
      return "ENOTCONN";
    case 145:
      return "ENOTEMPTY";
    case 10038:
      return "ENOTSOCK";
    case 50:
      return "ENOTSUP";
    case 109:
      return "EOF";
    case 1314:
      return "EPERM";
    case 230:
      return "EPIPE";
    case 232:
      return "EPIPE";
    case 233:
      return "EPIPE";
    case 10058:
      return "EPIPE";
    case 10043:
      return "EPROTONOSUPPORT";
    case 19:
      return "EROFS";
    case 121:
      return "ETIMEDOUT";
    case 10060:
      return "ETIMEDOUT";
    case 17:
      return "EXDEV";
    case 1:
      return "EISDIR";
    case 208:
      return "E2BIG";
    case 10044:
      return "ESOCKTNOSUPPORT";
    default:
      return "UNKNOWN";
  }
}
var os = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
var fs = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};
var crypto1 = {
  OPENSSL_VERSION_NUMBER: 269488319,
  SSL_OP_ALL: 2147485780,
  SSL_OP_ALLOW_NO_DHE_KEX: 1024,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
  SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
  SSL_OP_CISCO_ANYCONNECT: 32768,
  SSL_OP_COOKIE_EXCHANGE: 8192,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
  SSL_OP_EPHEMERAL_RSA: 0,
  SSL_OP_LEGACY_SERVER_CONNECT: 4,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
  SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
  SSL_OP_NETSCAPE_CA_DN_BUG: 0,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NO_COMPRESSION: 131072,
  SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
  SSL_OP_NO_QUERY_MTU: 4096,
  SSL_OP_NO_RENEGOTIATION: 1073741824,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
  SSL_OP_NO_SSLv2: 0,
  SSL_OP_NO_SSLv3: 33554432,
  SSL_OP_NO_TICKET: 16384,
  SSL_OP_NO_TLSv1: 67108864,
  SSL_OP_NO_TLSv1_1: 268435456,
  SSL_OP_NO_TLSv1_2: 134217728,
  SSL_OP_NO_TLSv1_3: 536870912,
  SSL_OP_PKCS1_CHECK_1: 0,
  SSL_OP_PKCS1_CHECK_2: 0,
  SSL_OP_PRIORITIZE_CHACHA: 2097152,
  SSL_OP_SINGLE_DH_USE: 0,
  SSL_OP_SINGLE_ECDH_USE: 0,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
  SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
  SSL_OP_TLS_D5_BUG: 0,
  SSL_OP_TLS_ROLLBACK_BUG: 8388608,
  ENGINE_METHOD_RSA: 1,
  ENGINE_METHOD_DSA: 2,
  ENGINE_METHOD_DH: 4,
  ENGINE_METHOD_RAND: 8,
  ENGINE_METHOD_EC: 2048,
  ENGINE_METHOD_CIPHERS: 64,
  ENGINE_METHOD_DIGESTS: 128,
  ENGINE_METHOD_PKEY_METHS: 512,
  ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
  ENGINE_METHOD_ALL: 65535,
  ENGINE_METHOD_NONE: 0,
  DH_CHECK_P_NOT_SAFE_PRIME: 2,
  DH_CHECK_P_NOT_PRIME: 1,
  DH_UNABLE_TO_CHECK_GENERATOR: 4,
  DH_NOT_SUITABLE_GENERATOR: 8,
  ALPN_ENABLED: 1,
  RSA_PKCS1_PADDING: 1,
  RSA_SSLV23_PADDING: 2,
  RSA_NO_PADDING: 3,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_X931_PADDING: 5,
  RSA_PKCS1_PSS_PADDING: 6,
  RSA_PSS_SALTLEN_DIGEST: -1,
  RSA_PSS_SALTLEN_MAX_SIGN: -2,
  RSA_PSS_SALTLEN_AUTO: -2,
  defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
  TLS1_VERSION: 769,
  TLS1_1_VERSION: 770,
  TLS1_2_VERSION: 771,
  TLS1_3_VERSION: 772,
  POINT_CONVERSION_COMPRESSED: 2,
  POINT_CONVERSION_UNCOMPRESSED: 4,
  POINT_CONVERSION_HYBRID: 6
};
var zlib = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
var trace = {
  TRACE_EVENT_PHASE_BEGIN: 66,
  TRACE_EVENT_PHASE_END: 69,
  TRACE_EVENT_PHASE_COMPLETE: 88,
  TRACE_EVENT_PHASE_INSTANT: 73,
  TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
  TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
  TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
  TRACE_EVENT_PHASE_ASYNC_END: 70,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
  TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
  TRACE_EVENT_PHASE_FLOW_STEP: 116,
  TRACE_EVENT_PHASE_FLOW_END: 102,
  TRACE_EVENT_PHASE_METADATA: 77,
  TRACE_EVENT_PHASE_COUNTER: 67,
  TRACE_EVENT_PHASE_SAMPLE: 80,
  TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
  TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
  TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
  TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
  TRACE_EVENT_PHASE_MARK: 82,
  TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
  TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
  TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
  TRACE_EVENT_PHASE_LINK_IDS: 61
};
var mod4 = {
  os,
  fs,
  crypto: crypto1,
  zlib,
  trace
};
var UV_EEXIST = os.errno.EEXIST;
var UV_ENOENT = os.errno.ENOENT;
var codeToErrorWindows = [
  [
    -4093,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -4092,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -4091,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -4090,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -4089,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -4088,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -4084,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -4083,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -4082,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -4081,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -4079,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -4078,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -4077,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -4076,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -4075,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -4074,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -4036,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -4073,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4072,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -4071,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -4070,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -4069,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -4068,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -4067,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -4066,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -4065,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -4064,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -4063,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -4062,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -4061,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -4060,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -4059,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -4058,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -4057,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -4056,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -4035,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -4055,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -4054,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -4053,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -4052,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -4051,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -4050,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -4049,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -4048,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -4047,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -4046,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -4045,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -4044,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -4034,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -4043,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -4042,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -4041,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -4040,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -4039,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -4038,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -4037,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -4033,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -4032,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -4031,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -4030,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -4029,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -4028,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -4027,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeWindows = codeToErrorWindows.map(([status, [error2]]) => [
  error2,
  status
]);
var codeToErrorDarwin = [
  [
    -7,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -13,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -48,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -49,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -47,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -35,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -37,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -9,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -16,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -89,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -53,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -61,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -54,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -39,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -17,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -14,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -27,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -65,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -22,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -5,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -56,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -21,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -62,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -24,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -40,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -63,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -50,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -51,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -23,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -55,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -19,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -2,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -12,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -4056,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -42,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -28,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -78,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -57,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -20,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -66,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -38,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -45,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -1,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -32,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -100,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -43,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -41,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -34,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -30,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -58,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -29,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -3,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -60,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -26,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -18,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -6,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -31,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -64,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -4030,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -25,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -79,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -92,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeDarwin = codeToErrorDarwin.map(([status, [code2]]) => [
  code2,
  status
]);
var codeToErrorLinux = [
  [
    -7,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -13,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -98,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -99,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -97,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -11,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -114,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -9,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -16,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -125,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -103,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -111,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -104,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -89,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -17,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -14,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -27,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -113,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -22,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -5,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -106,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -21,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -40,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -24,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -90,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -36,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -100,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -101,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -23,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -105,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -19,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -2,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -12,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -64,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -92,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -28,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -38,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -107,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -20,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -39,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -88,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -95,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -1,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -32,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -71,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -93,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -91,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -34,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -30,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -108,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -29,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -3,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -110,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -26,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -18,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -6,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -31,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -112,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -121,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -25,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -4028,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -84,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeLinux = codeToErrorLinux.map(([status, [code2]]) => [
  code2,
  status
]);
var errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
var codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
  if (osType === "windows") {
    const code2 = uvTranslateSysError(sysErrno);
    return codeMap.get(code2) ?? -sysErrno;
  } else {
    return -sysErrno;
  }
}
var UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
var UV_UNKNOWN = codeMap.get("UNKNOWN");
var UV_EBADF = codeMap.get("EBADF");
var UV_EINVAL = codeMap.get("EINVAL");
var UV_ENOTSOCK = codeMap.get("ENOTSOCK");
var mod5 = {
  UV_EEXIST,
  UV_ENOENT,
  errorMap,
  codeMap,
  mapSysErrnoToUvErrno,
  UV_EAI_MEMORY,
  UV_UNKNOWN,
  UV_EBADF,
  UV_EINVAL,
  UV_ENOTSOCK
};
var valueType;
(function(valueType3) {
  valueType3[valueType3["noIterator"] = 0] = "noIterator";
  valueType3[valueType3["isArray"] = 1] = "isArray";
  valueType3[valueType3["isSet"] = 2] = "isSet";
  valueType3[valueType3["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
var NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code2) {
  if (typeof code2 !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger(code2)) {
    throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap.get(code2)?.[0];
}
var DenoStdInternalError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert1(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError(msg);
  }
}
var { errno: { ENOTDIR, ENOENT } } = os;
var kIsNodeError = Symbol("kIsNodeError");
var classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
var kTypes = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
var AbortError = class extends Error {
  code;
  constructor() {
    super("The operation was aborted");
    this.code = "ABORT_ERR";
    this.name = "AbortError";
  }
};
function addNumericalSeparator(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace2(err) {
  Error.captureStackTrace(err);
  return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
  const code2 = getSystemErrorName(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
  return errorMap.get(name);
}
var uvUnmappedError = [
  "UNKNOWN",
  "unknown error"
];
hideStackFrames(function uvException(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace(ex);
});
hideStackFrames(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap.get("EAI_NODATA") || code2 === codeMap.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace(ex);
});
var NodeErrorAbstraction = class extends Error {
  code;
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError = class extends NodeErrorAbstraction {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace(this);
    Object.defineProperties(this, {
      [kIsNodeError]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode(key2, msgPrfix) {
  return class NodeError extends NodeSystemError {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
  expected = Array.isArray(expected) ? expected : [
    expected
  ];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types2 = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes.includes(value)) {
      types2.push(value.toLocaleLowerCase());
    } else if (classRegExp1.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types2.indexOf("object");
    if (pos !== -1) {
      types2.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types2.length > 0) {
    if (types2.length > 2) {
      const last = types2.pop();
      msg += `one of type ${types2.join(", ")}, or ${last}`;
    } else if (types2.length === 2) {
      msg += `one of type ${types2[0]} or ${types2[1]}`;
    } else {
      msg += `of type ${types2[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last1 = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last1}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last2 = other.pop();
      msg += `one of ${other.join(", ")}, or ${last2}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE = class extends NodeRangeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE = class extends NodeTypeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
  }
};
__publicField(ERR_INVALID_ARG_TYPE, "RangeError", ERR_INVALID_ARG_TYPE_RANGE);
var ERR_INVALID_ARG_VALUE_RANGE = class extends NodeRangeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect2(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE = class extends NodeTypeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect2(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
__publicField(ERR_INVALID_ARG_VALUE, "RangeError", ERR_INVALID_ARG_VALUE_RANGE);
function invalidArgTypeHelper(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect2(input, {
      depth: -1
    })}`;
  }
  let inspected = inspect2(input, {
    colors: false
  });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE = class extends RangeError {
  code = "ERR_OUT_OF_RANGE";
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert1(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect2(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS = class extends NodeRangeError {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_CRYPTO_FIPS_FORCED = class extends NodeError {
  constructor() {
    super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
  }
};
var ERR_INVALID_CALLBACK = class extends NodeTypeError {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect2(object)}`);
  }
};
var ERR_IPC_CHANNEL_CLOSED = class extends NodeError {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_METHOD_NOT_IMPLEMENTED = class extends NodeError {
  constructor(x17) {
    super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x17} method is not implemented`);
  }
};
var ERR_MISSING_ARGS = class extends NodeTypeError {
  constructor(...args) {
    let msg = "The ";
    const len = args.length;
    const wrap3 = (a7) => `"${a7}"`;
    args = args.map((a7) => Array.isArray(a7) ? a7.map(wrap3).join(" or ") : wrap3(a7));
    switch (len) {
      case 1:
        msg += `${args[0]} argument`;
        break;
      case 2:
        msg += `${args[0]} and ${args[1]} arguments`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += `, and ${args[len - 1]} arguments`;
        break;
    }
    super("ERR_MISSING_ARGS", `${msg} must be specified`);
  }
};
var ERR_MULTIPLE_CALLBACK = class extends NodeError {
  constructor() {
    super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
  }
};
var ERR_SOCKET_BAD_PORT = class extends NodeRangeError {
  constructor(name, port, allowZero = true) {
    assert1(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_STREAM_ALREADY_FINISHED = class extends NodeError {
  constructor(x17) {
    super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x17} after a stream was finished`);
  }
};
var ERR_STREAM_CANNOT_PIPE = class extends NodeError {
  constructor() {
    super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
  }
};
var ERR_STREAM_DESTROYED = class extends NodeError {
  constructor(x17) {
    super("ERR_STREAM_DESTROYED", `Cannot call ${x17} after a stream was destroyed`);
  }
};
var ERR_STREAM_NULL_VALUES = class extends NodeTypeError {
  constructor() {
    super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
  }
};
var ERR_STREAM_PREMATURE_CLOSE = class extends NodeError {
  constructor() {
    super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
  }
};
var ERR_STREAM_PUSH_AFTER_EOF = class extends NodeError {
  constructor() {
    super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
  }
};
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = class extends NodeError {
  constructor() {
    super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
  }
};
var ERR_STREAM_WRITE_AFTER_END = class extends NodeError {
  constructor() {
    super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
  }
};
var ERR_UNHANDLED_ERROR = class extends NodeError {
  constructor(x17) {
    super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x17})`);
  }
};
var ERR_UNKNOWN_ENCODING = class extends NodeTypeError {
  constructor(x17) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x17}`);
  }
};
var ERR_UNKNOWN_SIGNAL = class extends NodeTypeError {
  constructor(x17) {
    super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x17}`);
  }
};
function buildReturnPropertyType(value) {
  if (value && value.constructor && value.constructor.name) {
    return `instance of ${value.constructor.name}`;
  } else {
    return `type ${typeof value}`;
  }
}
var ERR_INVALID_RETURN_VALUE = class extends NodeTypeError {
  constructor(input, name, value) {
    super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType(value)}.`);
  }
};
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      outerError.errors.push(innerError);
      return outerError;
    }
    const err = new AggregateError([
      outerError,
      innerError
    ], outerError.message);
    err.code = outerError.code;
    return err;
  }
  return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames(function genericNodeError(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});
var { hasOwn } = Object;
function get(obj2, key2) {
  if (hasOwn(obj2, key2)) {
    return obj2[key2];
  }
}
function getForce(obj2, key2) {
  const v19 = get(obj2, key2);
  assert1(v19 != null);
  return v19;
}
function isNumber(x17) {
  if (typeof x17 === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(String(x17)))
    return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x17));
}
function hasKey(obj2, keys) {
  let o6 = obj2;
  keys.slice(0, -1).forEach((key3) => {
    o6 = get(o6, key3) ?? {};
  });
  const key2 = keys[keys.length - 1];
  return key2 in o6;
}
function parse(args, { "--": doubleDash = false, alias = {}, boolean: __boolean = false, default: defaults = {}, stopEarly = false, string = [], collect = [], negatable = [], unknown = (i) => i } = {}) {
  const flags = {
    bools: {},
    strings: {},
    unknownFn: unknown,
    allBools: false,
    collect: {},
    negatable: {}
  };
  if (__boolean !== void 0) {
    if (typeof __boolean === "boolean") {
      flags.allBools = !!__boolean;
    } else {
      const booleanArgs = typeof __boolean === "string" ? [
        __boolean
      ] : __boolean;
      for (const key2 of booleanArgs.filter(Boolean)) {
        flags.bools[key2] = true;
      }
    }
  }
  const aliases = {};
  if (alias !== void 0) {
    for (const key1 in alias) {
      const val = getForce(alias, key1);
      if (typeof val === "string") {
        aliases[key1] = [
          val
        ];
      } else {
        aliases[key1] = val;
      }
      for (const alias1 of getForce(aliases, key1)) {
        aliases[alias1] = [
          key1
        ].concat(aliases[key1].filter((y16) => alias1 !== y16));
      }
    }
  }
  if (string !== void 0) {
    const stringArgs = typeof string === "string" ? [
      string
    ] : string;
    for (const key2 of stringArgs.filter(Boolean)) {
      flags.strings[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.strings[al] = true;
        }
      }
    }
  }
  if (collect !== void 0) {
    const collectArgs = typeof collect === "string" ? [
      collect
    ] : collect;
    for (const key3 of collectArgs.filter(Boolean)) {
      flags.collect[key3] = true;
      const alias3 = get(aliases, key3);
      if (alias3) {
        for (const al1 of alias3) {
          flags.collect[al1] = true;
        }
      }
    }
  }
  if (negatable !== void 0) {
    const negatableArgs = typeof negatable === "string" ? [
      negatable
    ] : negatable;
    for (const key4 of negatableArgs.filter(Boolean)) {
      flags.negatable[key4] = true;
      const alias4 = get(aliases, key4);
      if (alias4) {
        for (const al2 of alias4) {
          flags.negatable[al2] = true;
        }
      }
    }
  }
  const argv2 = {
    _: []
  };
  function argDefined(key2, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key2) || !!get(flags.strings, key2) || !!get(aliases, key2);
  }
  function setKey(obj2, name, value, collect2 = true) {
    let o6 = obj2;
    const keys = name.split(".");
    keys.slice(0, -1).forEach(function(key3) {
      if (get(o6, key3) === void 0) {
        o6[key3] = {};
      }
      o6 = get(o6, key3);
    });
    const key2 = keys[keys.length - 1];
    const collectable = collect2 && !!get(flags.collect, name);
    if (!collectable) {
      o6[key2] = value;
    } else if (get(o6, key2) === void 0) {
      o6[key2] = [
        value
      ];
    } else if (Array.isArray(get(o6, key2))) {
      o6[key2].push(value);
    } else {
      o6[key2] = [
        get(o6, key2),
        value
      ];
    }
  }
  function setArg(key2, val, arg = void 0, collect2) {
    if (arg && flags.unknownFn && !argDefined(key2, arg)) {
      if (flags.unknownFn(arg, key2, val) === false)
        return;
    }
    const value = !get(flags.strings, key2) && isNumber(val) ? Number(val) : val;
    setKey(argv2, key2, value, collect2);
    const alias2 = get(aliases, key2);
    if (alias2) {
      for (const x17 of alias2) {
        setKey(argv2, x17, value, collect2);
      }
    }
  }
  function aliasIsBoolean(key2) {
    return getForce(aliases, key2).some((x17) => typeof get(flags.bools, x17) === "boolean");
  }
  let notFlags = [];
  if (args.includes("--")) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (/^--.+=/.test(arg)) {
      const m20 = arg.match(/^--([^=]+)=(.*)$/s);
      assert1(m20 != null);
      const [, key5, value] = m20;
      if (flags.bools[key5]) {
        const booleanValue = value !== "false";
        setArg(key5, booleanValue, arg);
      } else {
        setArg(key5, value, arg);
      }
    } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
      const m110 = arg.match(/^--no-(.+)/);
      assert1(m110 != null);
      setArg(m110[1], false, arg, false);
    } else if (/^--.+/.test(arg)) {
      const m22 = arg.match(/^--(.+)/);
      assert1(m22 != null);
      const [, key6] = m22;
      const next = args[i + 1];
      if (next !== void 0 && !/^-/.test(next) && !get(flags.bools, key6) && !flags.allBools && (get(aliases, key6) ? !aliasIsBoolean(key6) : true)) {
        setArg(key6, next, arg);
        i++;
      } else if (/^(true|false)$/.test(next)) {
        setArg(key6, next === "true", arg);
        i++;
      } else {
        setArg(key6, get(flags.strings, key6) ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      const letters = arg.slice(1, -1).split("");
      let broken = false;
      for (let j13 = 0; j13 < letters.length; j13++) {
        const next1 = arg.slice(j13 + 2);
        if (next1 === "-") {
          setArg(letters[j13], next1, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letters[j13]) && /=/.test(next1)) {
          setArg(letters[j13], next1.split(/=(.+)/)[1], arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letters[j13]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next1)) {
          setArg(letters[j13], next1, arg);
          broken = true;
          break;
        }
        if (letters[j13 + 1] && letters[j13 + 1].match(/\W/)) {
          setArg(letters[j13], arg.slice(j13 + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letters[j13], get(flags.strings, letters[j13]) ? "" : true, arg);
        }
      }
      const [key7] = arg.slice(-1);
      if (!broken && key7 !== "-") {
        if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key7) && (get(aliases, key7) ? !aliasIsBoolean(key7) : true)) {
          setArg(key7, args[i + 1], arg);
          i++;
        } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
          setArg(key7, args[i + 1] === "true", arg);
          i++;
        } else {
          setArg(key7, get(flags.strings, key7) ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv2._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
      }
      if (stopEarly) {
        argv2._.push(...args.slice(i + 1));
        break;
      }
    }
  }
  for (const [key8, value1] of Object.entries(defaults)) {
    if (!hasKey(argv2, key8.split("."))) {
      setKey(argv2, key8, value1);
      if (aliases[key8]) {
        for (const x17 of aliases[key8]) {
          setKey(argv2, x17, value1);
        }
      }
    }
  }
  for (const key9 of Object.keys(flags.bools)) {
    if (!hasKey(argv2, key9.split("."))) {
      const value2 = get(flags.collect, key9) ? [] : false;
      setKey(argv2, key9, value2, false);
    }
  }
  for (const key10 of Object.keys(flags.strings)) {
    if (!hasKey(argv2, key10.split(".")) && get(flags.collect, key10)) {
      setKey(argv2, key10, [], false);
    }
  }
  if (doubleDash) {
    argv2["--"] = [];
    for (const key11 of notFlags) {
      argv2["--"].push(key11);
    }
  } else {
    for (const key12 of notFlags) {
      argv2._.push(key12);
    }
  }
  return argv2;
}
function getOptions() {
  const args = parse(Deno.args);
  const options = new Map(Object.entries(args).map(([key2, value]) => [
    key2,
    {
      value
    }
  ]));
  return {
    options
  };
}
var optionsMap;
function getOptionsFromBinding() {
  if (!optionsMap) {
    ({ options: optionsMap } = getOptions());
  }
  return optionsMap;
}
function getOptionValue(optionName) {
  const options = getOptionsFromBinding();
  if (optionName.startsWith("--no-")) {
    const option = options.get("--" + optionName.slice(5));
    return option && !option.value;
  }
  return options.get(optionName)?.value;
}
var timingSafeEqual = (a7, b15) => {
  if (a7 instanceof DataView)
    a7 = Buffer2.from(a7.buffer);
  if (b15 instanceof DataView)
    b15 = Buffer2.from(b15.buffer);
  if (a7 instanceof ArrayBuffer)
    a7 = Buffer2.from(a7);
  if (b15 instanceof ArrayBuffer)
    b15 = Buffer2.from(b15);
  let result = 0;
  if (a7.byteLength !== b15.byteLength) {
    b15 = a7;
    result = 1;
  }
  for (let i = 0; i < a7.byteLength; i++) {
    result |= a7[i] ^ b15[i];
  }
  return result === 0;
};
function getFipsCrypto() {
  notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
  notImplemented("crypto.setFipsCrypto");
}
var mod6 = {
  timingSafeEqual,
  getFipsCrypto,
  setFipsCrypto
};
var MAX_RANDOM_VALUES = 65536;
function generateRandomBytes(size) {
  if (size > 4294967295) {
    throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${4294967295}. Received ${size}`);
  }
  const bytes = Buffer2.allocUnsafe(size);
  if (size > 65536) {
    for (let generated = 0; generated < size; generated += MAX_RANDOM_VALUES) {
      globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
    }
  } else {
    globalThis.crypto.getRandomValues(bytes);
  }
  return bytes;
}
function randomBytes(size, cb) {
  if (typeof cb === "function") {
    let err = null, bytes;
    try {
      bytes = generateRandomBytes(size);
    } catch (e) {
      if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
        throw e;
      } else if (e instanceof Error) {
        err = e;
      } else {
        err = new Error("[non-error thrown]");
      }
    }
    setTimeout(() => {
      if (err) {
        cb(err);
      } else {
        cb(null, bytes);
      }
    }, 0);
  } else {
    return generateRandomBytes(size);
  }
}
function assertOffset(offset, length) {
  if (offset > 4294967295 || offset < 0) {
    throw new TypeError("offset must be a uint32");
  }
  if (offset > 2147483647 || offset > length) {
    throw new RangeError("offset out of range");
  }
}
function assertSize1(size, offset, length) {
  if (size > 4294967295 || size < 0) {
    throw new TypeError("size must be a uint32");
  }
  if (size + offset > length || size > 2147483647) {
    throw new RangeError("buffer too small");
  }
}
function randomFill(buf, offset, size, cb) {
  if (typeof offset === "function") {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === "function") {
    cb = size;
    size = buf.length - Number(offset);
  }
  assertOffset(offset, buf.length);
  assertSize1(size, offset, buf.length);
  randomBytes(size, (err, bytes) => {
    if (err)
      return cb(err, buf);
    bytes?.copy(buf, offset);
    cb(null, buf);
  });
}
function randomFillSync(buf, offset = 0, size) {
  assertOffset(offset, buf.length);
  if (size === void 0)
    size = buf.length - offset;
  assertSize1(size, offset, buf.length);
  const bytes = randomBytes(size);
  bytes.copy(buf, offset);
  return buf;
}
function randomInt(max2, min3, cb) {
  if (typeof max2 === "number" && typeof min3 === "number") {
    [max2, min3] = [
      min3,
      max2
    ];
  }
  if (min3 === void 0)
    min3 = 0;
  else if (typeof min3 === "function") {
    cb = min3;
    min3 = 0;
  }
  if (!Number.isSafeInteger(min3) || typeof max2 === "number" && !Number.isSafeInteger(max2)) {
    throw new Error("max or min is not a Safe Number");
  }
  if (max2 - min3 > Math.pow(2, 48)) {
    throw new RangeError("max - min should be less than 2^48!");
  }
  if (min3 >= max2) {
    throw new Error("Min is bigger than Max!");
  }
  const randomBuffer = new Uint32Array(1);
  globalThis.crypto.getRandomValues(randomBuffer);
  const randomNumber = randomBuffer[0] / (4294967295 + 1);
  min3 = Math.ceil(min3);
  max2 = Math.floor(max2);
  const result = Math.floor(randomNumber * (max2 - min3)) + min3;
  if (cb) {
    cb(null, result);
    return;
  }
  return result;
}
function checkPrime(_candidate, _options, _callback) {
  notImplemented("crypto.checkPrime");
}
function checkPrimeSync(_candidate, _options) {
  notImplemented("crypto.checkPrimeSync");
}
function generatePrime(_size, _options, _callback) {
  notImplemented("crypto.generatePrime");
}
function generatePrimeSync(_size, _options) {
  notImplemented("crypto.generatePrimeSync");
}
var randomUUID = () => globalThis.crypto.randomUUID();
var wasm;
var heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function addHeapObject(obj2) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj2;
  return idx;
}
var cachedTextDecoder = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder.decode();
var cachedUint8Memory0;
function getUint8Memory0() {
  if (cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr = malloc(buf.length);
    getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr;
  }
  let len = arg.length;
  let ptr1 = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr1 + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr1 = realloc(ptr1, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr1 + offset, ptr1 + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr1;
}
function isLikeNone(x17) {
  return x17 === void 0 || x17 === null;
}
var cachedInt32Memory0;
function getInt32Memory0() {
  if (cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r12 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    var v19 = getArrayU8FromWasm0(r0, r12).slice();
    wasm.__wbindgen_free(r0, r12 * 1);
    return v19;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
var DigestContextFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_digestcontext_free(ptr));
var DigestContext = class {
  static __wrap(ptr) {
    const obj2 = Object.create(DigestContext.prototype);
    obj2.ptr = ptr;
    DigestContextFinalization.register(obj2, obj2.ptr, obj2);
    return obj2;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    DigestContextFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_digestcontext_free(ptr);
  }
  constructor(algorithm) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.digestcontext_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r12);
      }
      return DigestContext.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  update(data) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      if (r12) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digest(length) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v02 = getArrayU8FromWasm0(r0, r12).slice();
      wasm.__wbindgen_free(r0, r12 * 1);
      return v02;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digestAndReset(length) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v02 = getArrayU8FromWasm0(r0, r12).slice();
      wasm.__wbindgen_free(r0, r12 * 1);
      return v02;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digestAndDrop(length) {
    try {
      const ptr = this.__destroy_into_raw();
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v02 = getArrayU8FromWasm0(r0, r12).slice();
      wasm.__wbindgen_free(r0, r12 * 1);
      return v02;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  reset() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_reset(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      if (r12) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  clone() {
    const ret = wasm.digestcontext_clone(this.ptr);
    return DigestContext.__wrap(ret);
  }
};
var imports = {
  __wbindgen_placeholder__: {
    __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
      const ret = new TypeError(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    },
    __wbindgen_object_drop_ref: function(arg0) {
      takeObject(arg0);
    },
    __wbg_byteLength_3e250b41a8915757: function(arg0) {
      const ret = getObject(arg0).byteLength;
      return ret;
    },
    __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
      const ret = getObject(arg0).byteOffset;
      return ret;
    },
    __wbg_buffer_facf0398a281c85b: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    },
    __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    },
    __wbindgen_memory: function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    },
    __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_new_a7ce447f15ff496f: function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    },
    __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    },
    __wbindgen_throw: function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    }
  }
};
function instantiate() {
  return instantiateWithInstance().exports;
}
var instanceWithExports;
function instantiateWithInstance() {
  if (instanceWithExports == null) {
    const instance = instantiateInstance();
    wasm = instance.exports;
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    instanceWithExports = {
      instance,
      exports: {
        digest,
        DigestContext
      }
    };
  }
  return instanceWithExports;
}
function instantiateInstance() {
  const wasmBytes = base64decode("AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fwF/AqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRjZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNWRmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQPsgICAAGsJBwkHBxEFBwcFAwcHDwMHBRACBQUFBwUCCAYHBxQMCA4HBwcHBgcHCBcNBQUJCAgNBwkFCQkGBgUFBQUFBQcHBwcHAAUCCAoHBwMCBQ4MCwwLCxITCQUICAMGBgIFAAAGAwYAAAUFBAAFAgSFgICAAAFwARUVBYOAgIAAAQARBomAgIAAAX8BQYCAwAALB7aCgIAADgZtZW1vcnkCAAZkaWdlc3QANhhfX3diZ19kaWdlc3Rjb250ZXh0X2ZyZWUAURFkaWdlc3Rjb250ZXh0X25ldwA9FGRpZ2VzdGNvbnRleHRfdXBkYXRlAFUUZGlnZXN0Y29udGV4dF9kaWdlc3QAPhxkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZFJlc2V0AEAbZGlnZXN0Y29udGV4dF9kaWdlc3RBbmREcm9wADkTZGlnZXN0Y29udGV4dF9yZXNldAAhE2RpZ2VzdGNvbnRleHRfY2xvbmUAGh9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAG0RX193YmluZGdlbl9tYWxsb2MAVhJfX3diaW5kZ2VuX3JlYWxsb2MAYw9fX3diaW5kZ2VuX2ZyZWUAaQmagICAAAEAQQELFGZnbnVsWjxbXFlkYV1eX2B2QkNzCuXMiIAAa6B+AhJ/An4jAEGwJWsiBCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgAOGAABAgMEHBsaGRgXFhUUExIREA8ODQwLCgALIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAGoQRCAEIBY3A9ASIAUgBEGQEmpB0AEQOhpBACEGQQAhAQwfCyABKAIEIQFB0AEQFiIFRQ0EIARBkBJqQThqIAFBOGopAwA3AwAgBEGQEmpBMGogAUEwaikDADcDACAEQZASakEoaiABQShqKQMANwMAIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBGGogAUEYaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQQhqIAFBCGopAwA3AwAgBCABKQMANwOQEiABKQNAIRYgBEGQEmpByABqIAFByABqEEQgBCAWNwPQEiAFIARBkBJqQdABEDoaQQEhAQwbCyABKAIEIQFB0AEQFiIFRQ0EIARBkBJqQThqIAFBOGopAwA3AwAgBEGQEmpBMGogAUEwaikDADcDACAEQZASakEoaiABQShqKQMANwMAIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBGGogAUEYaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQQhqIAFBCGopAwA3AwAgBCABKQMANwOQEiABKQNAIRYgBEGQEmpByABqIAFByABqEEQgBCAWNwPQEiAFIARBkBJqQdABEDoaQQIhAQwaCyABKAIEIQFB8AAQFiIFRQ0EIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBGGogAUEYaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIAQgASkDCDcDmBIgASkDACEWIARBkBJqQShqIAFBKGoQOCAEIBY3A5ASIAUgBEGQEmpB8AAQOhpBAyEBDBkLIAEoAgQhAUH4DhAWIgVFDQQgBEGQEmpBiAFqIAFBiAFqKQMANwMAIARBkBJqQYABaiABQYABaikDADcDACAEQZASakH4AGogAUH4AGopAwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQSBqIAFBIGopAwA3AwAgBEGQEmpBMGogAUEwaikDADcDACAEQZASakE4aiABQThqKQMANwMAIARBkBJqQcAAaiABQcAAaikDADcDACAEQZASakHIAGogAUHIAGopAwA3AwAgBEGQEmpB0ABqIAFB0ABqKQMANwMAIARBkBJqQdgAaiABQdgAaikDADcDACAEQZASakHgAGogAUHgAGopAwA3AwAgBCABKQNwNwOAEyAEIAEpAwg3A5gSIAQgASkDKDcDuBIgASkDACEWIAEtAGohByABLQBpIQggAS0AaCEJAkAgASgCkAFBBXQiCg0AQQAhCgwbCyAEQRhqIgsgAUGUAWoiBkEYaikAADcDACAEQRBqIgwgBkEQ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ABA6GiABQbgiakE4aiIKIAFBkBJqQTxqKQIANwMAIAFBuCJqQTBqIgMgAUGQEmpBNGopAgA3AwAgAUG4ImpBKGoiDyABQZASakEsaikCADcDACABQbgiakEgaiILIAFBkBJqQSRqKQIANwMAIAFBuCJqQRhqIgwgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiDSABQZASakEUaikCADcDACABQbgiakEIaiIQIAFBkBJqQQxqKQIANwMAIAEgASkClBI3A7giIAFBkBJqIAFB0AEQOhogASABKQPQEiABQdgTai0AACIGrXw3A9ASIAFB2BJqIQICQCAGQYABRg0AIAIgBmpBAEGAASAGaxA7GgsgAUEAOgDYEyABQZASaiACQn8QESABQfgOakEIaiIGIAFBkBJqQQhqKQMANwMAIAFB+A5qQRBqIgIgAUGQEmpBEGopAwA3AwAgAUH4DmpBGGoiDiABQZASakEYaikDADcDACABQfgOakEgaiIHIAEpA7ASNwMAIAFB+A5qQShqIgggAUGQEmpBKGopAwA3AwAgAUH4DmpBMGoiCSABQZASakEwaikDADcDACABQfgOakE4aiIRIAFBkBJqQThqKQMANwMAIAEgASkDkBI3A/gOIBAgBikDADcDACANIAIpAwA3AwAgDCAOKQMANwMAIAsgBykDADcDACAPIAgpAwA3AwAgAyAJKQMANwMAIAogESkDADcDACABIAEpA/gONwO4IkHAABAWIgZFDRwgBiABKQO4IjcAACAGQThqIAFBuCJqQThqKQMANwAAIAZBMGogAUG4ImpBMGopAwA3AAAgBkEoaiABQbgiakEoaikDADcAACAGQSBqIAFBuCJqQSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQcAAIQMMGgsgBCAFQdABEDoiAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQSA2AvgOIAFBkBJqQRhqIgsgAUH4DmpBGGoiAikDADcDACABQZASakEQaiIMIAFB+A5qQRBqIgopAwA3AwAgAUGQEmpBCGoiDSABQfgOakEIaiIDKQMANwMAIAFBkBJqQSBqIAFB+A5qQSBqIhAoAgA2AgAgASABKQP4DjcDkBIgAUG4ImpBEGoiDiABQZASakEUaikCADcDACABQbgiakEIaiIHIAFBkBJqQQxqKQIANwMAIAFBuCJqQRhqIgggAUGQEmpBHGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQARA6GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDwJAIAZBgAFGDQAgDyAGakEAQYABIAZrEDsaCyABQQA6ANgTIAFBkBJqIA9CfxARIAMgDSkDADcDACAKIAwpAwA3AwAgAiALKQMANwMAIBAgASkDsBI3AwAgAUH4DmpBKGogAUGQEmpBKGopAwA3AwAgAUH4DmpBMGogAUGQEmpBMGopAwA3AwAgAUH4DmpBOGogAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gByADKQMANwMAIA4gCikDADcDACAIIAIpAwA3AwAgASABKQP4DjcDuCJBIBAWIgZFDRwgBiABKQO4IjcAACAGQRhqIAFBuCJqQRhqKQMANwAAIAZBEGogAUG4ImpBEGopAwA3AAAgBkEIaiABQbgiakEIaikDADcAAEEgIQMMGQsgBCAFQdABEDoiAUH4DmpBLGpCADcCACABQfgOakEkakIANwIAIAFB+A5qQRxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEMakIANwIAIAFCADcC/A4gAUEwNgL4DiABQZASakEoaiINIAFB+A5qQShqIgIpAwA3AwAgAUGQEmpBIGogAUH4DmpBIGoiCikDADcDACABQZASakEYaiIQIAFB+A5qQRhqIgMpAwA3AwAgAUGQEmpBEGoiDiABQfgOakEQaiIPKQMANwMAIAFBkBJqQQhqIgcgAUH4DmpBCGoiCykDADcDACABQZASakEwaiIIIAFB+A5qQTBqIgkoAgA2AgAgASABKQP4DjcDkBIgAUG4ImpBIGoiESABQZASakEkaikCADcDACABQbgiakEYaiISIAFBkBJqQRxqKQIANwMAIAFBuCJqQRBqIhMgAUGQEmpBFGopAgA3AwAgAUG4ImpBCGoiFCABQZASakEMaikCADcDACABQbgiakEoaiIVIAFBkBJqQSxqKQIANwMAIAEgASkClBI3A7giIAFBkBJqIAFB0AEQOhogASABKQPQEiABQdgTai0AACIGrXw3A9ASIAFB2BJqIQwCQCAGQYABRg0AIAwgBmpBAEGAASAGaxA7GgsgAUEAOgDYEyABQZASaiAMQn8QESALIAcpAwA3AwAgDyAOKQMANwMAIAMgECkDADcDACAKIAEpA7ASNwMAIAIgDSkDADcDACAJIAgpAwA3AwAgAUH4DmpBOGogAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gFCALKQMANwMAIBMgDykDADcDACASIAMpAwA3AwAgESAKKQMANwMAIBUgAikDADcDACABIAEpA/gONwO4IkEwEBYiBkUNHCAGIAEpA7giNwAAIAZBKGogAUG4ImpBKGopAwA3AAAgBkEgaiABQbgiakEgaikDADcAACAGQRhqIAFBuCJqQRhqKQMANwAAIAZBEGogAUG4ImpBEGopAwA3AAAgBkEIaiABQbgiakEIaikDADcAAEEwIQMMGAsgBCAFQfAAEDoiAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQSA2AvgOIAFBkBJqQRhqIgogAUH4DmpBGGopAwA3AwAgAUGQEmpBEGoiAyABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaiIPKQMANwMAIAFBkBJqQSBqIgsgAUH4DmpBIGooAgA2AgAgASABKQP4DjcDkBIgAUHoI2pBEGoiDCABQZASakEUaikCADcDACABQegjakEIaiINIAFBkBJqQQxqKQIANwMAIAFB6CNqQRhqIhAgAUGQEmpBHGopAgA3AwAgASABKQKUEjcD6CMgAUGQEmogAUHwABA6GiABIAEpA5ASIAFB+BJqLQAAIgatfDcDkBIgAUG4EmohAgJAIAZBwABGDQAgAiAGakEAQcAAIAZrEDsaCyABQQA6APgSIAFBkBJqIAJBfxATIA8gAykDACIWNwMAIA0gFjcDACAMIAopAwA3AwAgECALKQMANwMAIAEgASkDmBIiFjcD+A4gASAWNwPoI0EgEBYiBkUNHCAGIAEpA+gjNwAAIAZBGGogAUHoI2pBGGopAwA3AAAgBkEQaiABQegjakEQaikDADcAACAGQQhqIAFB6CNqQQhqKQMANwAAQSAhAwwXCyAEIAVB+A4QOiEBIANBAEgNEgJAAkAgAw0AQQEhBgwBCyADEBYiBkUNHSAGQXxqLQAAQQNxRQ0AIAZBACADEDsaCyABQZASaiABQfgOEDoaIAFB+A5qIAFBkBJqECMgAUH4DmogBiADEBgMFgsgBCAFQeACEDoiCkGQEmogCkHgAhA6GiAKQZASaiAKQegUai0AACIBakHIAWohAgJAIAFBkAFGDQAgAkEAQZABIAFrEDsaC0EAIQYgCkEAOgDoFCACQQE6AAAgCkHnFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQZABRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGooAgA2AgAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQRwhA0EcEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASgCADYAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADBULIAQgBUHYAhA6IgpBkBJqIApB2AIQOhogCkGQEmogCkHgFGotAAAiAWpByAFqIQICQCABQYgBRg0AIAJBAEGIASABaxA7GgtBACEGIApBADoA4BQgAkEBOgAAIApB3xRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkGIAUcNAAsgCkGQEmoQJCAKQfgOakEYaiIBIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIgIgCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiDyAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkEgIQNBIBAWIgZFDRwgBiAKKQP4DjcAACAGQRhqIAEpAwA3AAAgBkEQaiACKQMANwAAIAZBCGogDykDADcAAAwUCyAEIAVBuAIQOiIKQZASaiAKQbgCEDoaIApBkBJqIApBwBRqLQAAIgFqQcgBaiECAkAgAUHoAEYNACACQQBB6AAgAWsQOxoLQQAhBiAKQQA6AMAUIAJBAToAACAKQb8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZB6ABHDQALIApBkBJqECQgCkH4DmpBKGoiASAKQZASakEoaikDADcDACAKQfgOakEgaiICIApBkBJqQSBqKQMANwMAIApB+A5qQRhqIg8gCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiCyAKQZASakEQaikDADcDACAKQfgOakEIaiIMIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQTAhA0EwEBYiBkUNHCAGIAopA/gONwAAIAZBKGogASkDADcAACAGQSBqIAIpAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhqIAwpAwA3AAAMEwsgBCAFQZgCEDoiCkGQEmogCkGYAhA6GiAKQZASaiAKQaAUai0AACIBakHIAWohAgJAIAFByABGDQAgAkEAQcgAIAFrEDsaC0EAIQYgCkEAOgCgFCACQQE6AAAgCkGfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQcgARw0ACyAKQZASahAkIApB+A5qQThqIgEgCkGQEmpBOGopAwA3AwAgCkH4DmpBMGoiAiAKQZASakEwaikDADcDACAKQfgOakEoaiIPIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgsgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDCAKQZASakEYaikDADcDACAKQfgOakEQaiINIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIhAgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BwAAhA0HAABAWIgZFDRwgBiAKKQP4DjcAACAGQThqIAEpAwA3AAAgBkEwaiACKQMANwAAIAZBKGogDykDADcAACAGQSBqIAspAwA3AAAgBkEYaiAMKQMANwAAIAZBEGogDSkDADcAACAGQQhqIBApAwA3AAAMEgsgBCAFQeAAEDoiAUH4DmpBDGpCADcCACABQgA3AvwOQRAhAyABQRA2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKAIANgIAIAFBkBJqQQhqIAFB+A5qQQhqKQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAUGQEmogAUHgABA6GiABQZASaiABQagSaiABQegjahAvQRAQFiIGRQ0cIAYgASkD6CM3AAAgBkEIaiACKQMANwAADBELIAQgBUHgABA6IgFB+A5qQQxqQgA3AgAgAUIANwL8DkEQIQMgAUEQNgL4DiABQZASakEQaiABQfgOakEQaigCADYCACABQZASakEIaiABQfgOakEIaikDADcDACABQegjakEIaiICIAFBkBJqQQxqKQIANwMAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB4AAQOhogAUGQEmogAUGoEmogAUHoI2oQLkEQEBYiBkUNHCAGIAEpA+gjNwAAIAZBCGogAikDADcAAAwQC0EUIQMgBCAFQegAEDoiAUH4DmpBFGpBADYCACABQfgOakEMakIANwIAIAFBADYC+A4gAUIANwL8DiABQRQ2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqKQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgAUHoI2pBEGoiCiABQZASakEUaigCADYCACABIAEpA/gONwOQEiABIAEpApQSNwPoIyABQZASaiABQegAEDoaIAFBkBJqIAFBsBJqIAFB6CNqEC1BFBAWIgZFDRwgBiABKQPoIzcAACAGQRBqIAooAgA2AAAgBkEIaiACKQMANwAADA8LQRQhAyAEIAVB6AAQOiIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3AgAgAUEANgL4DiABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKAIANgIAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQOhogAUGQEmogAUGwEmogAUHoI2oQKEEUEBYiBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDgsgBCAFQeACEDoiCkGQEmogCkHgAhA6GiAKQZASaiAKQegUai0AACIBakHIAWohAgJAIAFBkAFGDQAgAkEAQZABIAFrEDsaC0EAIQYgCkEAOgDoFCACQQY6AAAgCkHnFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQZABRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGooAgA2AgAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQRwhA0EcEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASgCADYAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADA0LIAQgBUHYAhA6IgpBkBJqIApB2AIQOhogCkGQEmogCkHgFGotAAAiAWpByAFqIQICQCABQYgBRg0AIAJBAEGIASABaxA7GgtBACEGIApBADoA4BQgAkEGOgAAIApB3xRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkGIAUcNAAsgCkGQEmoQJCAKQfgOakEYaiIBIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIgIgCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiDyAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkEgIQNBIBAWIgZFDRwgBiAKKQP4DjcAACAGQRhqIAEpAwA3AAAgBkEQaiACKQMANwAAIAZBCGogDykDADcAAAwMCyAEIAVBuAIQOiIKQZASaiAKQbgCEDoaIApBkBJqIApBwBRqLQAAIgFqQcgBaiECAkAgAUHoAEYNACACQQBB6AAgAWsQOxoLQQAhBiAKQQA6AMAUIAJBBjoAACAKQb8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZB6ABHDQALIApBkBJqECQgCkH4DmpBKGoiASAKQZASakEoaikDADcDACAKQfgOakEgaiICIApBkBJqQSBqKQMANwMAIApB+A5qQRhqIg8gCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiCyAKQZASakEQaikDADcDACAKQfgOakEIaiIMIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQTAhA0EwEBYiBkUNHCAGIAopA/gONwAAIAZBKGogASkDADcAACAGQSBqIAIpAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhqIAwpAwA3AAAMCwsgBCAFQZgCEDoiCkGQEmogCkGYAhA6GiAKQZASaiAKQaAUai0AACIBakHIAWohAgJAIAFByABGDQAgAkEAQcgAIAFrEDsaC0EAIQYgCkEAOgCgFCACQQY6AAAgCkGfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQcgARw0ACyAKQZASahAkIApB+A5qQThqIgEgCkGQEmpBOGopAwA3AwAgCkH4DmpBMGoiAiAKQZASakEwaikDADcDACAKQfgOakEoaiIPIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgsgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDCAKQZASakEYaikDADcDACAKQfgOakEQaiINIApBkBJq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BEGgA2pBGGoiCiAEQShqQRxqKQIANwMAIARBoANqQRBqIgsgBEEoakEUaikCADcDACAEQaADakEIaiIMIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAIpA0AgAkHIAWoiAy0AACIBrXw3A0AgAkHIAGohBQJAIAFBgAFGDQAgBSABakEAQYABIAFrEDsaC0EAIQEgA0EAOgAAIAIgBUJ/EBEgBEEoakEIaiIFIAJBCGopAwAiEDcDACAEQShqQRBqIAJBEGopAwAiETcDACAEQShqQRhqIAJBGGopAwAiEjcDACAEQShqQSBqIAIpAyAiEzcDACAEQShqQShqIAJBKGopAwAiFDcDACAMIBA3AwAgCyARNwMAIAogEjcDACAJIBM3AwAgCCAUNwMAIAcgAkEwaikDADcDACAGIAJBOGopAwA3AwAgBCACKQMAIhA3AyggBCAQNwOgAyAFQcAAEFAgAiAFQcgAEDoaIANBADoAAEHAABAWIgJFDRogAiAEKQOgAzcAACACQThqIARBoANqQThqKQMANwAAIAJBMGogBEGgA2pBMGopAwA3AAAgAkEoaiAEQaADakEoaikDADcAACACQSBqIARBoANqQSBqKQMANwAAIAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIARBoANqQQhqKQMANwAAQcAAIQMMMgsgASgCBCECIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEMakIANwIAIARCADcC1AQgBEEgNgLQBCAEQShqQRhqIgcgBEHQBGpBGGopAwA3AwAgBEEoakEQaiIIIARB0ARqQRBqKQMANwMAIARBKGpBCGoiAyAEQdAEakEIaikDADcDACAEQShqQSBqIgkgBEHQBGpBIGooAgA2AgAgBCAEKQPQBDcDKCAEQaADakEQaiIKIARBKGpBFGopAgA3AwAgBEGgA2pBCGoiCyAEQShqQQxqKQIANwMAIARBoANqQRhqIgwgBEEoakEcaikCADcDACAEIAQpAiw3A6ADIAIgAikDQCACQcgBaiIFLQAAIgGtfDcDQCACQcgAaiEGAkAgAUGAAUYNACAGIAFqQQBBgAEgAWsQOxoLQQAhASAFQQA6AAAgAiAGQn8QESADIAJBCGopAwAiEDcDACAIIAJBEGopAwAiETcDACAHIAJBGGopAwAiEjcDACAJIAIpAyA3AwAgBEEoakEoaiACQShqKQMANwMAIAsgEDcDACAKIBE3AwAgDCASNwMAIAQgAikDACIQNwMoIAQgEDcDoAMgA0EgEFAgAiADQcgAEDoaIAVBADoAAEEgEBYiAkUNGiACIAQpA6ADNwAAIAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIARBoANqQQhqKQMANwAAQSAhAwwxCyABKAIEIQIgBEHQBGpBLGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEMakIANwIAIARCADcC1AQgBEEwNgLQBCAEQShqQShqIgcgBEHQBGpBKGopAwA3AwAgBEEoakEgaiIIIARB0ARqQSBqKQMANwMAIARBKGpBGGoiCSAEQdAEakEYaikDADcDACAEQShqQRBqIgogBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBMGogBEHQBGpBMGooAgA2AgAgBCAEKQPQBDcDKCAEQaADakEgaiILIARBKGpBJGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIANwMAIARBoANqQRBqIg0gBEEoakEUaikCADcDACAEQaADakEIaiIOIARBKGpBDGopAgA3AwAgBEGgA2pBKGoiDyAEQShqQSxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYCQCABQYABRg0AIAYgAWpBAEGAASABaxA7GgtBACEBIAVBADoAACACIAZCfxARIAMgAkEIaikDACIQNwMAIAogAkEQaikDACIRNwMAIAkgAkEYaikDACISNwMAIAggAikDICITNwMAIAcgAkEoaikDACIUNwMAIA4gEDcDACANIBE3AwAgDCASNwMAIAsgEzcDACAPIBQ3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQTAQUCACIANByAAQOhogBUEAOgAAQTAQFiICRQ0aIAIgBCkDoAM3AAAgAkEoaiAEQaADakEoaikDADcAACACQSBqIARBoANqQSBqKQMANwAAIAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIARBoANqQQhqKQMANwAAQTAhAwwwCyABKAIEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGGoiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARBoANqQRBqIgogBEEoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQMAIAJB6ABqIgUtAAAiAa18NwMAIAJBKGohBgJAIAFBwABGDQAgBiABakEAQcAAIAFrEDsaC0EAIQEgBUEAOgAAIAIgBkF/EBMgAyACQRBqIgYpAgAiEDcDACALIBA3AwAgCiACQRhqIgspAgA3AwAgDCACQSBqIgopAgA3AwAgBCACQQhqIgwpAgAiEDcDKCAEIBA3A6ADIAMQVyAKIARBKGpBKGopAwA3AwAgCyAJKQMANwMAIAYgBykDADcDACAMIAgpAwA3AwAgAiAEKQMwNwMAIAVBADoAAEEgEBYiAkUNGiACIAQpA6ADNwAAIAJBGGogBEGgA2pBGGopAwA3AAAgAkEQaiAEQaADakEQaikDADcAACACQQhqIARBoANqQQhqKQMANwAAQSAhAwwvCyADQQBIDRIgASgCBCEFAkACQCADDQBBASECDAELIAMQFiICRQ0bIAJBfGotAABBA3FFDQAgAkEAIAMQOxoLIARBKGogBRAjIAVCADcDACAFQSBqIAVBiAFqKQMANwMAIAVBGGogBUGAAWopAwA3AwAgBUEQaiAFQfgAaikDADcDACAFIAUpA3A3AwhBACEBIAVBKGpBAEHCABA7GgJAIAUoApABRQ0AIAVBADYCkAELIARBKGogAiADEBgMLgsgASgCBCIFIAVB2AJqIgYtAAAiAWpByAFqIQMCQCABQZABRg0AIANBAEGQASABaxA7GgtBACECIAZBADoAACADQQE6AAAgBUHXAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJBkAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaigAADYCACAEQShqQRBqIgcgBUEQaikAADcDACAEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdgCakEAOgAAQRwhA0EcEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKAIANgAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAMLQsgASgCBCIFIAVB0AJqIgYtAAAiAWpByAFqIQMCQCABQYgBRg0AIANBAEGIASABaxA7GgtBACECIAZBADoAACADQQE6AAAgBUHPAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJBiAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaikAADcDACAEQShqQRBqIgcgBUEQaikAADcDACAEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdACakEAOgAAQSAhA0EgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKQMANwAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAMLAsgASgCBCIFIAVBsAJqIgYtAAAiAWpByAFqIQMCQCABQegARg0AIANBAEHoACABaxA7GgtBACECIAZBADoAACADQQE6AAAgBUGvAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJB6ABHDQALIAUQJCAEQShqQShqIgYgBUEoaikAADcDACAEQShqQSBqIgcgBUEgaikAADcDACAEQShqQRhqIgggBUEYaikAADcDACAEQShqQRBqIgkgBUEQaikAADcDACAEQShqQQhqIgogBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QbACakEAOgAAQTAhA0EwEBYiAkUNGiACIAQpAyg3AAAgAkEoaiAGKQMANwAAIAJBIGogBykDADcAACACQRhqIAgpAwA3AAAgAkEQaiAJKQMANwAAIAJBCGogCikDADcAAAwrCyABKAIEIgUgBUGQAmoiBi0AACIBakHIAWohAwJAIAFByABGDQAgA0EAQcgAIAFrEDsaC0EAIQIgBkEAOgAAIANBAToAACAFQY8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkHIAEcNAAsgBRAkIARBKGpBOGoiBiAFQThqKQAANwMAIARBKGpBMGoiByAFQTBqKQAANwMAIARBKGpBKGoiCCAFQShqKQAANwMAIARBKGpBIGoiCSAFQSBqKQAANwMAIARBKGpBGGoiCiAFQRhqKQAANwMAIARBKGpBEGoiCyAFQRBqKQAANwMAIARBKGpBCGoiDCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDtBkAJqQQA6AABBwAAhA0HAABAWIgJFDRogAiAEKQMoNwAAIAJBOGogBikDADcAACACQTBqIAcpAwA3AAAgAkEoaiAIKQMANwAAIAJBIGogCSkDADcAACACQRhqIAopAwA3AAAgAkEQaiALKQMANwAAIAJBCGogDCkDADcAAAwqCyABKAIEIQIgBEHQBGpBDGpCADcCACAEQgA3AtQEQRAhAyAEQRA2AtAEIARBKGpBEGogBEHQBGpBEGooAgA2AgAgBEEoakEIaiAEQdAEakEIaikDADcDACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBCAEKQPQBDcDKCAEIAQpAiw3A6ADIAIgAkEYaiAEQaADahAvQQAhASACQdgAakEAOgAAIAJBEGpC/rnrxemOlZkQNwMAIAJCgcaUupbx6uZvNwMIIAJCADcDAEEQEBYiAkUNGiACIAQpA6ADNwAAIAJBCGogBSkDADcAAAwpCyABKAIEIQIgBEHQBGpBDGpCADcCACAEQgA3AtQEQRAhAyAEQRA2AtAEIARBKGpBEGogBEHQBGpBEGooAgA2AgAgBEEoakEIaiAEQdAEakEIaikDADcDACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBCAEKQPQBDcDKCAEIAQpAiw3A6ADIAIgAkEYaiAEQaADahAuQQAhASACQdgAakEAOgAAIAJBEGpC/rnrxemOlZkQNwMAIAJCgcaUupbx6uZvNwMIIAJCADcDAEEQEBYiAkUNGiACIAQpA6ADNwAAIAJBCGogBSkDADcAAAwoCyABKAIEIQJBFCEDQQAhASAEQdAEakEUakEANgIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQRQ2AtAEIARBKGpBEGogBEHQBGpBEGopAwA3AwAgBEEoakEIaiAEQdAEakEIaikDADcDACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBEGgA2pBEGoiBiAEQShqQRRqKAIANgIAIAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQLSACQgA3AwAgAkHgAGpBADoAACACQQApA9iNQDcDCCACQRBqQQApA+CNQDcDACACQRhqQQAoAuiNQDYCAEEUEBYiAkUNGiACIAQpA6ADNwAAIAJBEGogBigCADYAACACQQhqIAUpAwA3AAAMJwsgASgCBCECQRQhA0EAIQEgBEHQBGpBFGpBADYCACAEQdAEakEMakIANwIAIARCADcC1AQgBEEUNgLQBCAEQShqQRBqIARB0ARqQRBqKQMANwMAIARBKGpBCGogBEHQBGpBCGopAwA3AwAgBEGgA2pBCGoiBSAEQShqQQxqKQIANwMAIARBoANqQRBqIgYgBEEoakEUaigCADYCACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQSBqIARBoANqECggAkHgAGpBADoAACACQRhqQfDDy558NgIAIAJBEGpC/rnrxemOlZkQNwMAIAJCgcaUupbx6uZvNwMIIAJCADcDAEEUEBYiAkUNGiACIAQpA6ADNwAAIAJBEGogBigCADYAACACQQhqIAUpAwA3AAAMJgsgASgCBCIFIAVB2AJqIgYtAAAiAWpByAFqIQMCQCABQZABRg0AIANBAEGQASABaxA7GgtBACECIAZBADoAACADQQY6AAAgBUHXAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJBkAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaigAADYCACAEQShqQRBqIgcgBUEQaikAADcDACAEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdgCakEAOgAAQRwhA0EcEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKAIANgAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAMJQsgASgCBCIFIAVB0AJqIgYtAAAiAWpByAFqIQMCQCABQYgBRg0AIANBAEGIASABaxA7GgtBACECIAZBADoAACADQQY6AAAgBUHPAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJBiAFHDQALIAUQJCAEQShqQRhqIgYgBUEYaikAADcDACAEQShqQRBqIgcgBUEQaikAADcDACAEQShqQQhqIgggBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QdACakEAOgAAQSAhA0EgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAGKQMANwAAIAJBEGogBykDADcAACACQQhqIAgpAwA3AAAMJAsgASgCBCIFIAVBsAJqIgYtAAAiAWpByAFqIQMCQCABQegARg0AIANBAEHoACABaxA7GgtBACECIAZBADoAACADQQY6AAAgBUGvAmoiASABLQAAQYABcjoAAANAIAUgAmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgMgAy0AACABQckBai0AAHM6AAAgAUECaiIDIAMtAAAgAUHKAWotAABzOgAAIAFBA2oiAyADLQAAIAFBywFqLQAAczoAACACQQRqIgJB6ABHDQALIAUQJCAEQShqQShqIgYgBUEoaikAADcDACAEQShqQSBqIgcgBUEgaikAADcDACAEQShqQRhqIgggBUEYaikAADcDACAEQShqQRBqIgkgBUEQaikAADcDACAEQShqQQhqIgogBUEIaikAADcDACAEIAUpAAA3AyhBACEBIAVBAEHIARA7QbACakEAOgAAQTAhA0EwEBYiAkUNGiACIAQpAyg3AAAgAkEoaiAGKQMANwAAIAJBIGogBykDADcAACACQRhqIAgpAwA3AAAgAkEQaiAJKQMANwAAIAJBCGogCikDADcAAAwjCyABKAIEIgUgBUGQAmoiBi0AACIBakHIAWohAwJAIAFByABGDQAgA0EAQcgAIAFrEDsaC0EAIQIgBkEAOgAAIANBBjoAACAFQY8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkHIAEcNAAsgBRAkIARBKGpBOGoiBiAFQThqKQAANwMAIARBKGpBMGoiByAFQTBqKQAANwMAIARBKGpBKGoiCCAFQShqKQAANwMAIARBKGpBIGoiCSAFQSBqKQAANwMAIARBKGpBGGoiCiAFQRhqKQAANwMAIARBKGpBEGoiCyAFQRBqKQAANwMAIARBKGpBCGoiDCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDtBkAJqQQA6AABBwAAhA0HAABAWIgJFDRogAiAEKQMoNwAAIAJBOGogBikDADcAACACQTBqIAcpAwA3AAAgAkEoaiAIKQMANwAAIAJBIGogCSkDADcAACACQRhqIAopAwA3AAAgAkEQaiALKQMANwAAIAJBCGogDCkDADcAAAwiCyABKAIEIQJBHCEDIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEMakIANwIAIARCADcC1AQgBEEgNgLQBCAEQShqQRhqIgUgBEHQBGpBGGopAwA3AwAgBEEoakEQaiIGIARB0ARqQRBqKQMANwMAIARBKGpBCGoiByAEQdAEakEIaikDADcDACAEQShqQSBqIARB0ARqQSBqKAIANgIAIAQgBCkD0AQ3AyggBEGgA2pBEGoiASAEQShqQRRqKQIANwMAIARBoANqQQhqIgggBEEoakEMaikCADcDACAEQaADakEYaiIJIARBKGpBHGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBEGgA2oQJyAFIAkoAgA2AgAgBiABKQMANwMAIAcgCCkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEgAkHoAGpBADoAACACQQApA5COQDcDCCACQRBqQQApA5iOQDcDACACQRhqQQApA6COQDcDACACQSBqQQApA6iOQDcDAEEcEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAFKAIANgAAIAJBEGogBikDADcAACACQQhqIAcpAwA3AAAMIQsgASgCBCECIARB0ARqQRxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEMakIANwIAIARCADcC1ARBICEDIARBIDYC0AQgBEEoakEgaiAEQdAEakEgaigCADYCACAEQShqQRhqIgUgBEHQBGpBGGopAwA3AwAgBEEoakEQaiIGIARB0ARqQRBqKQMANwMAIARBKGpBCGoiByAEQdAEakEIaikDADcDACAEIAQpA9AENwMoIARBoANqQRhqIgEgBEEoakEcaikCADcDACAEQaADakEQaiIIIARBKGpBFGopAgA3AwAgBEGgA2pBCGoiCSAEQShqQQxqKQIANwMAIAQgBCkCLDcDoAMgAiACQShqIARBoANqECcgBSABKQMANwMAIAYgCCkDADcDACAHIAkpAwA3AwAgBCAEKQOgAzcDKCACQgA3AwBBACEBIAJB6ABqQQA6AAAgAkEAKQPwjUA3AwggAkEQakEAKQP4jUA3AwAgAkEYakEAKQOAjkA3AwAgAkEgakEAKQOIjkA3AwBBIBAWIgJFDRogAiAEKQMoNwAAIAJBGGogBSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADCALIAEoAgQhAiAEQdAEakEMakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQSxqQgA3AgAgBEHQBGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1AQgBEHAADYC0AQgBEEoaiAEQdAEakHEABA6GiAEQaADakE4aiAEQShqQTxqKQIANwMAQTAhAyAEQaADakEwaiAEQShqQTRqKQIANwMAIARBoANqQShqIgEgBEEoakEsaikCADcDACAEQaADakEgaiIFIARBKGpBJGopAgA3AwAgBEGgA2pBGGoiBiAEQShqQRxqKQIANwMAIARBoANqQRBqIgcgBEEoakEUaikCADcDACAEQaADakEIaiIIIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJB0ABqIARBoANqECIgBEEoakEoaiIJIAEpAwA3AwAgBEEoakEgaiIKIAUpAwA3AwAgBEEoakEYaiIFIAYpAwA3AwAgBEEoakEQaiIGIAcpAwA3AwAgBEEoakEIaiIHIAgpAwA3AwAgBCAEKQOgAzcDKCACQcgAakIANwMAIAJCADcDQEEAIQEgAkE4akEAKQOoj0A3AwAgAkEwakEAKQOgj0A3AwAgAkEoakEAKQOYj0A3AwAgAkEgakEAKQOQj0A3AwAgAkEYakEAKQOIj0A3AwAgAkEQakEAKQOAj0A3AwAgAkEIakEAKQP4jkA3AwAgAkEAKQPwjkA3AwAgAkHQAWpBADoAAEEwEBYiAkUNGiACIAQpAyg3AAAgAkEoaiAJKQMANwAAIAJBIGogCikDADcAACACQRhqIAUpAwA3AAAgAkEQaiAGKQMANwAAIAJBCGogBykDADcAAAwfCyABKAIEIQIgBEHQBGpBDGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQRxqQgA3AgAgBEHQBGpBJGpCADcCACAEQdAEakEsakIANwIAIARB0ARqQTRqQgA3AgAgBEHQBGpBPGpCADcCACAEQgA3AtQEQcAAIQMgBEHAADYC0AQgBEEoaiAEQdAEakHEABA6GiAEQaADakE4aiIBIARBKGpBPGopAgA3AwAgBEGgA2pBMGoiBSAEQShqQTRqKQIANwMAIARBoANqQShqIgYgBEEoakEsaikCADcDACAEQaADakEgaiIHIARBKGpBJGopAgA3AwAgBEGgA2pBGGoiCCAEQShqQRxqKQIANwMAIARBoANqQRBqIgkgBEEoakEUaikCADcDACAEQaADakEIaiIKIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJB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IANB6AFqQRBqIgQgBikCADcDACADQegBakEIaiIGIAApAgA3AwAgAyAIKQIINwPoASADQegBaiADQfgAakEoaiAKIB0gBxAZIAkoAgAhByAEKAIAIQQgBigCACEJIAMoAoQCIQogAygC/AEhCyADKAL0ASEMIAMoAuwBIQ0gAygC6AEhDiAIIAgpAwAQKSAIKAKQASIGQTdPDRMgCEGQAWogBkEFdGoiAEEgaiAKNgIAIABBHGogBzYCACAAQRhqIAs2AgAgAEEUaiAENgIAIABBEGogDDYCACAAQQxqIAk2AgAgAEEIaiANNgIAIABBBGogDjYCACAIIAZBAWo2ApABIAhBKGoiAEIANwMAIABBCGpCADcDACAAQRBqQgA3AwAgAEEYakIANwMAIABBIGpCADcDACAAQShqQgA3AwAgAEEwakIANwMAIABBOGpCADcDACAIQQA7AWggCEEIaiIAIAgpA3A3AwAgAEEIaiAIQfgAaikDADcDACAAQRBqIAhBgAFqKQMANwMAIABBGGogCEGIAWopAwA3AwAgCCAIKQMAQgF8NwMAIAEgBWohAQw2CyAAKAIEIgRByAFqIQoCQEGQASAEQdgCai0AACIAayIIIAJLDQACQCAARQ0AIAogAGogASAIEDoaIAIgCGshAkEAIQUDQCAEIAVqIgAgAC0AACAAQcgBai0AAHM6AAAgAEEBaiIGIAYtAAAgAEHJAWotAABzOgAAIABBAmoiBiAGLQAAIABBygFqLQAAczoAACAAQQNqIgYgBi0AACAAQcsBai0AAHM6AAAgBUEEaiIFQZABRw0ACyAEECQgASAIaiEBCyABIAJBkAFuQZABbCIAaiEHIAIgAGshCSACQY8BTQ0zIABFDTMDQCABQZABaiEIQQAhBQNAIAQgBWoiACAALQAAIAEgBWoiBi0AAHM6AAAgAEEBaiICIAItAAAgBkEBai0AAHM6AAAgAEECaiICIAItAAAgBkECai0AAHM6AAAgAEEDaiIAIAAtAAAgBkEDai0AAHM6AAAgBUEEaiIFQZABRw0ACyAEECQgCCEBIAggB0YNNAwACwsgCiAAaiABIAIQOhogACACaiEJDDMLIAAoAgQiBEHIAWohCgJAQYgBIARB0AJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQOhogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVBiAFHDQALIAQQJCABIAhqIQELIAEgAkGIAW5BiAFsIgBqIQcgAiAAayEJIAJBhwFNDS8gAEUNLwNAIAFBiAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoAACAAQQNqIgAgAC0AACAGQQNqLQAAczoAACAFQQRqIgVBiAFHDQALIAQQJCAIIQEgCCAHRg0wDAALCyAKIABqIAEgAhA6GiAAIAJqIQkMLwsgACgCBCIEQcgBaiEKAkBB6AAgBEGwAmotAAAiAGsiCCACSw0AAkAgAEUNACAKIABqIAEgCBA6GiACIAhrIQJBACEFA0AgBCAFaiIAIAAtAAAgAEHIAWotAABzOgAAIABBAWoiBiAGLQAAIABByQFqLQAAczoAACAAQQJqIgYgBi0AACAAQcoBai0AAHM6AAAgAEEDaiIGIAYtAAAgAEHLAWotAABzOgAAIAVBBGoiBUHoAEcNAAsgBBAkIAEgCGohAQsgASACQegAbkHoAGwiAGohByACIABrIQkgAkHnAE0NKyAARQ0rA0AgAUHoAGohCEEAIQUDQCAEIAVqIgAgAC0AACABIAVqIgYtAABzOgAAIABBAWoiAiACLQAAIAZBAWotAABzOgAAIABBAmoiAiACLQAAIAZBAmotAABzOgAAIABBA2oiACAALQAAIAZBA2otAABzOgAAIAVBBGoiBUHoAEcNAAsgBBAkIAghASAIIAdGDSwMAAsLIAogAGogASACEDoaIAAgAmohCQwrCyAAKAIEIgRByAFqIQoCQEHIACAEQZACai0AACIAayIIIAJLDQACQCAARQ0AIAogAGogASAIEDoaIAIgCGshAkEAIQUDQCAEIAVqIgAgAC0AACAAQcgBai0AAHM6AAAgAEEBaiIGIAYtAAAgAEHJAWotAABzOgAAIABBAmoiBiAGLQAAIABBygFqLQAAczoAACAAQQNqIgYgBi0AACAAQcsBai0AAHM6AAAgBUEEaiIFQcgARw0ACyAEECQgASAIaiEBCyABIAJByABuQcgAbCIAaiEHIAIgAGshCSACQccATQ0nIABFDScDQCABQcgAaiEIQQAhBQNAIAQgBWoiACAALQAAIAEgBWoiBi0AAHM6AAAgAEEBaiICIAItAAAgBkEBai0AAHM6AAAgAEECaiICIAItAAAgBkECai0AAHM6AAAgAEEDaiIAIAAtAAAgBkEDai0AAHM6AAAgBUEEaiIFQcgARw0ACyAEECQgCCEBIAggB0YNKAwACwsgCiAAaiABIAIQOhogACACaiEJDCcLIAAoAgQiBkEYaiEEAkBBwAAgBkHYAGotAAAiAGsiBSACSw0AAkAgAEUNACAEIABqIAEgBRA6GiAGIAYpAwBCAXw3AwAgBkEIaiAEEB8gASAFaiEBIAIgBWshAgsgAkE/cSEIIAEgAkFAcWohByACQT9NDSQgBiAGKQMAIAJBBnYiAK18NwMAIABBBnRFDSQgBkEIaiEFIABBBnQhAANAIAUgARAfIAFBwABqIQEgAEFAaiIADQAMJQsLIAQgAGogASACEDoaIAAgAmohCAwkCyADIAAoAgQiADYCCCAAQRhqIQYgAEHYAGotAAAhBSADIANBCGo2AngCQAJAQcAAIAVrIgQgAksNAAJAIAVFDQAgBiAFaiABIAQQOhogA0H4AGogBkEBEBsgASAEaiEBIAIgBGshAgsgAkE/cSEFIAEgAkFAcWohBAJAIAJBP0sNACAGIAQgBRA6GgwCCyADQfgAaiABIAJBBnYQGyAGIAQgBRA6GgwBCyAGIAVqIAEgAhA6GiAFIAJqIQULIABB2ABqIAU6AAAMPAsgACgCBCIGQSBqIQQCQEHAACAGQeAAai0AACIAayIFIAJLDQACQCAARQ0AIAQgAGogASAFEDoaIAYgBikDAEIBfDcDACAGQQhqIAQQEiABIAVqIQEgAiAFayECCyACQT9xIQggASACQUBxaiEHIAJBP00NICAGIAYpAwAgAkEGdiIArXw3AwAgAEEGdEUNICAGQQhqIQUgAEEGdCEAA0AgBSABEBIgAUHAAGohASAAQUBqIgANAAwhCwsgBCAAaiABIAIQOhogACACaiEIDCALIAAoAgQiAEEgaiEGAkACQEHAACAAQeAAai0AACIFayIEIAJLDQACQCAFRQ0AIAYgBWogASAEEDoaIAAgACkDAEIBfDcDACAAQQhqIAZBARAUIAEgBGohASACIARrIQILIAJBP3EhBSABIAJBQHFqIQQCQCACQT9LDQAgBiAEIAUQOhoMAgsgACAAKQMAIAJBBnYiAq18NwMAIABBCGogASACEBQgBiAEIAUQOhoMAQsgBiAFaiABIAIQOhogBSACaiEFCyAAQeAAaiAFOgAADDoLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQOhogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCABIAhqIQELIAEgAkGQAW5BkAFsIgBqIQcgAiAAayEJIAJBjwFNDRsgAEUNGwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoAACAAQQNqIgAgAC0AACAGQQNqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCAIIQEgCCAHRg0cDAALCyAKIABqIAEgAhA6GiAAIAJqIQkMGwsgACgCBCIEQcgBaiEKAkBBiAEgBEHQAmotAAAiAGsiCCACSw0AAkAgAEUNACAKIABqIAEgCBA6GiACIAhrIQJBACEFA0AgBCAFaiIAIAAtAAAgAEHIAWotAABzOgAAIABBAWoiBiAGLQAAIABByQFqLQAAczoAACAAQQJqIgYgBi0AACAAQcoBai0AAHM6AAAgAEEDaiIGIAYtAAAgAEHLAWotAABzOgAAIAVBBGoiBUGIAUcNAAsgBBAkIAEgCGohAQsgASACQYgBbkGIAWwiAGohByACIABrIQkgAkGHAU0NFyAARQ0XA0AgAUGIAWohCEEAIQUDQCAEIAVqIgAgAC0AACABIAVqIgYtAABzOgAAIABBAWoiAiACLQAAIAZBAWotAABzOgAAIABBAmoiAiACLQAAIAZBAmotAABzOgAAIABBA2oiACAALQAAIAZBA2otAABzOgAAIAVBBGoiBUGIAUcNAAsgBBAkIAghASAIIAdGDRgMAAsLIAogAGogASACEDoaIAAgAmohCQwXCyAAKAIEIgRByAFqIQoCQEHoACAEQbACai0AACIAayIIIAJLDQACQCAARQ0AIAogAGogASAIEDoaIAIgCGshAkEAIQUDQCAEIAVqIgAgAC0AACAAQcgBai0AAHM6AAAgAEEBaiIGIAYtAAAgAEHJAWotAABzOgAAIABBAmoiBiAGLQAAIABBygFqLQAAczoAACAAQQNqIgYgBi0AACAAQcsBai0AAHM6AAAgBUEEaiIFQegARw0ACyAEECQgASAIaiEBCyABIAJB6ABuQegAbCIAaiEHIAIgAGshCSACQecATQ0TIABFDRMDQCABQegAaiEIQQAhBQNAIAQgBWoiACAALQAAIAEgBWoiBi0AAHM6AAAgAEEBaiICIAItAAAgBkEBai0AAHM6AAAgAEECaiICIAItAAAgBkECai0AAHM6AAAgAEEDaiIAIAAtAAAgBkEDai0AAHM6AAAgBUEEaiIFQegARw0ACyAEECQgCCEBIAggB0YNFAwACwsgCiAAaiABIAIQOhogACACaiEJDBMLIAAoAgQiBEHIAWohCgJAQcgAIARBkAJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQOhogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVByABHDQALIAQQJCABIAhqIQELIAEgAkHIAG5ByABsIgBqIQcgAiAAayEJIAJBxwBNDQ8gAEUNDwNAIAFByABqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoAACAAQQNqIgAgAC0AACAGQQNqLQAAczoAACAFQQRqIgVByABHDQALIAQQJCAIIQEgCCAHRg0QDAALCyAKIABqIAEgAhA6GiAAIAJqIQkMDwsgACgCBCIAQShqIQYCQAJAQcAAIABB6ABqLQAA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ajoA4gEgA0H4AGogASAAEDQaIAwgCykDADcDACAMQQhqIAUpAwA3AwAgDEEQaiAGKQMANwMAIAxBGGogBykDADcDACAKIAkpAwA3AwAgCkEIaiAOKQMANwMAIApBEGogFykDADcDACAKQRhqIBgpAwA3AwAgCkEgaiAZKQMANwMAIApBKGogGikDADcDACAKQTBqIBspAwA3AwAgCkE4aiAcKQMANwMAIAMtAOIBIQ4gAy0A4QEhFyADIAMtAOABIhg6AHAgAyADKQN4Ih43AwggAyAOIBdFckECciIOOgBxIANB6AFqQRhqIhcgBykCADcDACADQegBakEQaiIHIAYpAgA3AwAgA0HoAWpBCGoiBiAFKQIANwMAIAMgCykCADcD6AEgA0HoAWogCiAYIB4gDhAZIBcoAgAhDiAHKAIAIQcgBigCACEXIAMoAoQCIRggAygC/AEhGSADKAL0ASEaIAMoAuwBIRsgAygC6AEhHCAIIAgpAwAQKSAIKAKQASIGQTdPDQkgDSAGQQV0aiIFIBg2AhwgBSAONgIYIAUgGTYCFCAFIAc2AhAgBSAaNgIMIAUgFzYCCCAFIBs2AgQgBSAcNgIAIAggBkEBajYCkAELIAggCCkDACAdfCIeNwMAIAIgAEkNCSABIABqIQEgAiAAayICQYAISw0ACwsgAkUNEyAIIAEgAhA0GiAIIAgpAwAQKQwTCyAAIAJBoIXAABBKAAsgBUHAAEHghMAAEEoACyAGQcAAQfCEwAAQSgALIAZBIEGAhcAAEEoACyADQZACakEIaiIBIBo2AgAgA0GQAmpBEGoiACAYNgIAIANBkAJqQRhqIgUgDjYCACADIBk2ApwCIANBgQFqIgYgASkDADcAACADIBc2AqQCIANBiQFqIgEgACkDADcAACADIAc2AqwCIANBkQFqIgAgBSkDADcAACADIBs2ApQCIAMgHDYCkAIgAyADKQOQAjcAeSADQQhqQRhqIAApAAA3AwAgA0EIakEQaiABKQAANwMAIANBCGpBCGogBikAADcDACADIAMpAHk3AwhBkJLAACADQQhqQYCGwABB+IbAABBBAAsgA0GQAmpBCGoiASAUNgIAIANBkAJqQRBqIgAgEjYCACADQZACakEYaiIFIBA2AgAgAyATNgKcAiADQYEBaiIGIAEpAwA3AAAgAyARNgKk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NgIAIAAgASAVaiAGIApqIAkgDyAgQX9zcnNqQc76z8p6akEGd2ogAyALaiANIAVzIARzakELdyACaiIKajYCECAAIAEgEGogBWogAiAHaiAEIBZzIApzakELd2o2AgwLhCgCMH8BfiMAQcAAayIDQRhqIgRCADcDACADQSBqIgVCADcDACADQThqIgZCADcDACADQTBqIgdCADcDACADQShqIghCADcDACADQQhqIgkgASkACDcDACADQRBqIgogASkAEDcDACAEIAEoABgiCzYCACAFIAEoACAiBDYCACADIAEpAAA3AwAgAyABKAAcIgU2AhwgAyABKAAkIgw2AiQgCCABKAAoIg02AgAgAyABKAAsIgg2AiwgByABKAAwIg42AgAgAyABKAA0Igc2AjQgBiABKAA4Ig82AgAgAyABKAA8IgE2AjwgACAIIAEgBCAFIAcgCCALIAQgDCAMIA0gDyABIAQgBCALIAEgDSAPIAggBSAHIAEgBSAIIAsgByAHIA4gBSALIABBJGoiECgCACIRIABBFGoiEigCACITamoiBkGZmoPfBXNBEHciFEG66r+qemoiFSARc0EUdyIWIAZqaiIXIBRzQRh3IhggFWoiGSAWc0EZdyIaIABBIGoiGygCACIVIABBEGoiHCgCACIdaiAKKAIAIgZqIgogAnNBq7OP/AFzQRB3Ih5B8ua74wNqIh8gFXNBFHciICAKaiADKAIUIgJqIiFqaiIiIABBHGoiIygCACIWIABBDGoiJCgCACIlaiAJKAIAIglqIgogACkDACIzQiCIp3NBjNGV2HlzQRB3IhRBhd2e23tqIiYgFnNBFHciJyAKaiADKAIMIgpqIiggFHNBGHciKXNBEHciKiAAQRhqIisoAgAiLCAAKAIIIi1qIAMoAgAiFGoiLiAzp3NB/6S5iAVzQRB3Ii9B58yn0AZqIjAgLHNBFHciMSAuaiADKAIEIgNqIi4gL3NBGHciLyAwaiIwaiIyIBpzQRR3IhogImpqIiIgKnNBGHciKiAyaiIyIBpzQRl3IhogASAPIBcgMCAxc0EZdyIwamoiFyAhIB5zQRh3Ih5zQRB3IiEgKSAmaiImaiIpIDBzQRR3IjAgF2pqIhdqaiIxIAwgBCAmICdzQRl3IiYgLmpqIicgGHNBEHciGCAeIB9qIh5qIh8gJnNBFHci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IgIkACABKAIAIQMCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCCCIEQX1qDgkDCwkKAQQLAgALCwJAIANBl4DAAEELEFJFDQAgA0GigMAAQQsQUg0LQdABEBYiBEUNDSACQbgBaiIFQTAQUCAEIAVByAAQOiEFIAJBADYCACACQQRyQQBBgAEQOxogAkGAATYCACACQbABaiACQYQBEDoaIAVByABqIAJBsAFqQQRyQYABEDoaIAVBADoAyAFBAiEFDCQLQdABEBYiBEUNCyACQbgBaiIFQSAQUCAEIAVByAAQOiEFIAJBADYCACACQQRyQQBBgAEQOxogAkGAATYCACACQbABaiACQYQBEDoaIAVByABqIAJBsAFqQQRyQYABEDoaIAVBADoAyAFBASEFDCMLIANBkIDAAEEHEFJFDSECQCADQa2AwABBBxBSRQ0AIANB94DAACAEEFJFDQQgA0H+gMAAIAQQUkUNBSADQYWBwAAgBBBSRQ0GIANBjIHAACAEEFINCkHYARAWIgRFDRwgAkEANgIAIAJBBHJBAEGAARA7GiACQYABNgIAIAJBsAFqIAJBhAEQOhogBEHQAGogAkGwAWpBBHJBgAEQOhogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA7COQDcDACAEQQhqQQApA7iOQDcDACAEQRBqQQApA8COQDcDACAEQRhqQQApA8iOQDcDACAEQSBqQQApA9COQDcDACAEQShqQQApA9iOQDcDACAEQTBqQQApA+COQDcDACAEQThqQQApA+iOQDcDAEEUIQUMIwtB8AAQFiIERQ0MIAJBsAFqQQhqEFcgBEEgaiACQdgBaikDADcDACAEQRhqIAJBsAFqQSBqKQMANwMAIARBEGogAkGwAWpBGGopAwA3AwAgBEEIaiACQbABakEQaikDADcDACAEIAIpA7gBNwMAIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDoaIARB4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJBsAFqQSxqKQIANwAAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOGogAkGwAWpBFGopAgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARBADoAaEEDIQUMIgsCQAJAAkACQCADQbqAwABBChBSRQ0AIANBxIDAAEEKEFJFDQEgA0HOgMAAQQoQUkUNAiADQdiAwABBChBSRQ0DIANB6IDAAEEKEFINDEHoABAWIgRFDRYgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOhogBEHYAGogAkGwAWpBPGopAgA3AAAgBEHQAGogAkGwAWpBNGopAgA3AAAgBEHIAGogAkGwAWpBLGopAgA3AAAgBEHAAGogAkGwAWpBJGopAgA3AAAgBEE4aiACQbABakEcaikCADcAACAEQTBqIAJBsAFqQRRqKQIANwAAIARBKGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAICAEQgA3AwAgBEEAOgBgIARBACkD2I1ANwMIIARBEGpBACkD4I1ANwMAIARBGGpBACgC6I1ANgIAQQshBQwlC0HgAhAWIgRFDQ8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQZABEDsaIAJBkAE2AgAgAkGwAWogAkGUARA6GiAFQcgBaiACQbABakEEckGQARA6GiAFQQA6ANgCQQUhBQwkC0HYAhAWIgRFDQ8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQYgBEDsaIAJBiAE2AgAgAkGwAWogAkGMARA6GiAFQcgBaiACQbABakEEckGIARA6GiAFQQA6ANACQQYhBQwjC0G4AhAWIgRFDQ8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQegAEDsaIAJB6AA2AgAgAkGwAWogAkHsABA6GiAFQcgBaiACQbABakEEckHoABA6GiAFQQA6ALACQQchBQwiC0GYAhAWIgRFDQ8gBEEAQcgBEDshBSACQQA2AgAgAkEEckEAQcgAEDsaIAJByAA2AgAgAkGwAWogAkHMABA6GiAFQcgBaiACQbABakEEckHIABA6GiAFQQA6AJACQQghBQwhCwJAIANB4oDAAEEDEFJFDQAgA0HlgMAAQQMQUg0IQeAAEBYiBEUNESACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQdAAaiACQbABakE8aikCADcAACAEQcgAaiACQbABakE0aikCADcAACAEQcAAaiACQbABakEsaikCADcAACAEQThqIAJBsAFqQSRqKQIANwAAIARBMGogAkGwAWpBHGopAgA3AAAgBEEoaiACQbABakEUaikCADcAACAEQSBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ABggBEL+uevF6Y6VmRA3AxAgBEKBxpS6lvHq5m83AwggBEIANwMAIARBADoAWEEKIQUMIQtB4AAQFiIERQ0PIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDoaIARB0ABqIAJBsAFqQTxqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANwAAIARBOGogAkGwAWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIANwAAIARBIGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8ermbzcDCCAEQgA3AwAgBEEAOgBYQQkhBQwgCwJAAkACQAJAIAMpAABC05CFmtPFjJk0UQ0AIAMpAABC05CFmtPFzJo2UQ0BIAMpAABC05CFmtPljJw0UQ0CIAMpAABC05CFmtOlzZgyUQ0DIAMpAABC05CF2tSojJk4UQ0HIAMpAABC05CF2tTIzJo2Ug0KQdgCEBYiBEUNHiAEQQBByAEQOyEFIAJBADYCACACQQRyQQBBiAEQOxogAkGIATYCACACQbABaiACQYwBEDoaIAVByAFqIAJBsAFqQQRyQYgBEDoaIAVBADoA0AJBFiEFDCMLQeACEBYiBEUNFCAEQQBByAEQOyEFIAJBADYCACACQQRyQQBBkAEQOxogAkGQATYCACACQbABaiACQZQBEDoaIAVByAFqIAJBsAFqQQRyQZABEDoaIAVBADoA2AJBDSEFDCILQdgCEBYiBEUNFCAEQQBByAEQOyEFIAJBADYCACACQQRyQQBBiAEQOxogAkGIATYCACACQbABaiACQYwBEDoaIAVByAFqIAJBsAFqQQRyQYgBEDoaIAVBADoA0AJBDiEFDCELQbgCEBYiBEUNFCAEQQBByAEQOyEFIAJBADYCACACQQRyQQBB6AAQOxogAkHoADYCACACQbABaiACQewAEDoaIAVByAFqIAJBsAFqQQRyQegAEDoaIAVBADoAsAJBDyEFDCALQZgCEBYiBEUNFCAEQQBByAEQOyEFIAJBADYCACACQQRyQQBByAAQOxogAkHIADYCACACQbABaiACQcwAEDoaIAVByAFqIAJBsAFqQQRyQcgAEDoaIAVBADoAkAJBECEFDB8LQfAAEBYiBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQeAAaiACQbABakE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikCADcAACAEQcgAaiACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQRRqKQIANwAAIARBMGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkDkI5ANwMIIARBEGpBACkDmI5ANwMAIARBGGpBACkDoI5ANwMAIARBIGpBACkDqI5ANwMAQREhBQweC0HwABAWIgRFDRQgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOhogBEHgAGogAkGwAWpBPGopAgA3AAAgBEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGopAgA3AAAgBEHIAGogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABakEUaikCADcAACAEQTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEIANwMAIARBADoAaCAEQQApA/CNQDcDCCAEQRBqQQApA/iNQDcDACAEQRhqQQApA4COQDcDACAEQSBqQQApA4iOQDcDAEESIQUMHQtB2AEQFiIERQ0UIAJBADYCACACQQRyQQBBgAEQOxogAkGAATYCACACQbABaiACQYQBEDoaIARB0ABqIAJBsAFqQQRyQYABEDoaIARByABqQgA3AwAgBEIANwNAIARBADoA0AEgBEEAKQPwjkA3AwAgBEEIakEAKQP4jkA3AwAgBEEQakEAKQOAj0A3AwAgBEEYakEAKQOIj0A3AwAgBEEgakEAKQOQj0A3AwAgBEEoakEAKQOYj0A3AwAgBEEwakEAKQOgj0A3AwAgBEE4akEAKQOoj0A3AwBBEyEFDBwLQfgCEBYiBEUNFSAEQQBByAEQOyEFIAJBADYCACACQQRyQQBBqAEQOxogAkGoATYCACACQbABaiACQawBEDoaIAVByAFqIAJBsAFqQQRyQagBEDoaIAVBADoA8AJBFSEFDBsLIANB8oDAAEEFEFJFDRcgA0GTgcAAQQUQUg0BQegAEBYiBEUNFiAEQgA3AwAgBEEAKQP4kUA3AwggBEEQakEAKQOAkkA3AwAgBEEYakEAKQOIkkA3AwAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOhogBEHYAGogAkGwAWpBPGopAgA3AAAgBEHQAGogAkGwAWpBNGopAgA3AAAgBEHIAGogAkGwAWpBLGopAgA3AAAgBEHAAGogAkGwAWpBJGopAgA3AAAgBEE4aiACQbABakEcaikCADcAACAEQTBqIAJBsAFqQRRqKQIANwAAIARBKGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAICAEQQA6AGBBFyEFDBoLIANBtIDAAEEGEFJFDRcLQQEhBEGYgcAAQRUQACEFDBkLQdABQQhBACgC+NRAIgJBBCACGxEFAAALQdABQQhBACgC+NRAIgJBBCACGxEFAAALQfAAQQhBACgC+NRAIgJBBCACGxEFAAALQeACQQhBACgC+NRAIgJBBCACGxEFAAALQdgCQQhBACgC+NRAIgJBBCACGxEFAAALQbgCQQhBACgC+NRAIgJBBCACGxEFAAALQZgCQQhBACgC+NRAIgJBBCACGxEFAAALQeAAQQhBACgC+NRAIgJBBCACGxEFAAALQeAAQQhBACgC+NRAIgJBBCACGxEFAAALQegAQQhBACgC+NRAIgJBBCACGxEFAAALQeACQQhBACgC+NRAIgJBBCACGxEFAAALQdgCQQhBACgC+NRAIgJBBCACGxEFAAALQbgCQQhBACgC+NRAIgJBBCACGxEFAAALQZgCQQhBACgC+NRAIgJBBCACGxEFAAALQfAAQQhBACgC+NRAIgJBBCACGxEFAAALQfAAQQhBACgC+NRAIgJBBCACGxEFAAALQdgBQQhBACgC+NRAIgJBBCACGxEFAAALQdgBQQhBACgC+NRAIgJBBCACGxEFAAALQfgCQQhBACgC+NRAIgJBBCACGxEFAAALQdgCQQhBACgC+NRAIgJBBCACGxEFAAALQegAQQhBACgC+NRAIgJBBCACGxEFAAALAkBB6AAQFiIERQ0AQQwhBSACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARB8MPLnnw2AhggBEL+uevF6Y6VmRA3AxAgBEKBxpS6lvHq5m83AwggBEIANwMAIARBADoAYAwDC0HoAEEIQQAoAvjUQCICQQQgAhsRBQAACwJAQfgOEBYiBEUNACAEQQA2ApABIARBiAFqQQApA4iO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1UBBAEEANgK42EBBAEHM1cAANgLY1UBBAEHE1cAANgLM1UBBAEHM1cAANgLU1UBBAEHU1cAANgLg1UBBAEHU1cAANgLc1UBBAEHc1cAANgLo1UBBAEHc1cAANgLk1UBBAEHk1cAANgLw1UBBAEHk1cAANgLs1UBBAEHs1cAANgL41UBBAEHs1cAANgL01UBBAEH01cAANgKA1kBBAEH01cAANgL81UBBAEH81cAANgKI1kBBAEH81cAANgKE1kBBAEGE1sAANgKQ1kBBAEGE1sAANgKM1kBBAEGM1sAANgKY1kBBAEGU1sAANgKg1kBBAEGM1sAANgKU1kBBAEGc1sAANgKo1kBBAEGU1sAANgKc1kBBAEGk1sAANgKw1kBBAEGc1sAANgKk1kBBAEGs1sAANgK41kBBAEGk1sAANgKs1kBBAEG01sAANgLA1kBBAEGs1sAANgK01kBBAEG81sAANgLI1kBBAEG01sAANgK81kBBAEHE1sAANgLQ1kBBAEG81sAANgLE1kBBAEHM1sAANgLY1kBBAEHE1sAANgLM1kBBAEHU1sAANgLg1kBBAEHM1sAANgLU1kBBAEHc1sAANgLo1kBBAEHU1sAANgLc1kBBAEHk1sAANgLw1kBBAEHc1sAANgLk1kBBAEHs1sAANgL41kBBAEHk1sAANgLs1kBBAEH01sAANgKA10BBAEHs1sAANgL01kBBAEH81sAANgKI10BBAEH01sAANgL81kBBAEGE18AANgKQ10BBAEH81sAANgKE10BBACAGNgKg2EBBAEGE18AANgKM10BBACAIQVhqIgA2ApjYQCAGIABBAXI2AgQgCCAGakFcakEoNgIAQQBBgICAATYCvNhAC0EAIQFBACgCmNhAIgAgAk0NAEEAIAAgAmsiATYCmNhAQQBBACgCoNhAIgAgAmoiBTYCoNhAIAUgAUEBcjYCBCAAIAJBA3I2AgQgAEEIag8LIAELuSUCA38efiMAQcAAayIDQThqQgA3AwAgA0EwakIANwMAIANBKGpCADcDACADQSBqQgA3AwAgA0EYakIANwMAIANBEGpCADcDACADQQhqQgA3AwAgA0IANwMAAkAgAkUNACABIAJBBnRqIQQgACkDECEGIAApAwghByAAKQMAIQgDQCADIAFBGGopAAAiCSABKQAAIgogAUE4aikAACIL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DiAbaiIXaiIVIAZzQRR3IgZqIglzNgIIIAAgASAKIBBqIBcgHXNBGXciEGoiF2ogFyANc0EQdyIBIBJqIg0gEHNBFHciEGoiFyABc0EYdyIBIA1qIg0gCyAYIAdqIAQgCHNBGXciCGoiB2ogByAOc0EQdyIHIA9qIg8gCHNBFHciCGoiDnM2AgQgACAOIAdzQRh3IgcgD2oiDyAXczYCDCAAIAkgBXNBGHciBSAVaiIOIBNzNgIAIAAgAiARc0EZdyAFczYCFCAAIA0gEHNBGXcgB3M2AhAgACAOIAZzQRl3IAxzNgIcIAAgDyAIc0EZdyABczYCGAuRIgIOfwJ+IwBBoA9rIgEkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABFDQAgACgCACICQX9GDQEgACACQQFqNgIAIABBBGohAgJAAkACQAJAAkAgACgCBA4YAAECAwQeHRwbGhkYFxYVFBMSERAPDg0MAAsgAigCBCEDQdABEBYiAkUNBiABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIAMpA0AhDyABQQhqQcgAaiADQcgAahBEIAEgDzcDSCACIAFBCGpB0AEQOhpBACEDDB8LIAIoAgQhA0HQARAWIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAGogA0HIAGoQRCABIA83A0ggAiABQQhqQdABEDoaQQEhAwweCyACKAIEIQNB0AEQFiICRQ0GIAFBCGpBOGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEQgASAPNwNIIAIgAUEIakHQARA6GkECIQMMHQsgAigCBCEDQfAAEBYiAkUNBiABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpBKGogA0EoahA4IAEgDzcDCCACIAFBCGpB8AAQOhpBAyEDDBwLIAIoAgQhA0H4DhAWIgJFDQYgAUEIakGIAWogA0GIAWopAwA3AwAgAUEIakGAAWogA0GAAWopAwA3AwAgAUEIakH4AGogA0H4AGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBOGogA0E4aikDADcDACABQQhqQcAAaiADQcAAaikDADcDACABQQhqQcgAaiADQcgAaikDADcDACABQQhqQdAAaiADQdAAaikDADcDACABQQhqQdgAaiADQdgAaikDADcDACABQQhqQeAAaiADQeAAaikDADcDACABIAMpA3A3A3ggASADKQMINwMQIAEgAykDKDcDMCADKQMAIQ8gAy0AaiEEIAMtAGkhBSADLQBoIQYCQCADKAKQAUEFdCIHDQBBACEHDBsLIAFBgA9qQRhqIgggA0GUAWoiCUEYaikAADcDACABQYAPakEQaiIKIAlBEGopAAA3AwAgAUGAD2pBCGoiCyAJQQhqKQAANwMAIAEgCSkAADcDgA8gA0HUAWohCUEAIAdBYGpBBXZrIQwgAUG8AWohA0ECIQcDQCADQWBqIg0gASkDgA83AAAgDUEYaiAIKQMANwAAIA1BEGogCikDADcAACANQQhqIAspAwA3AAACQAJAIAwgB2oiDkECRg0AIAggCUFgaiINQRhqKQAANwMAIAogDUEQaikAADcDACALIA1BCGopAAA3AwAgASANKQAANwOADyAHQThHDQEQawALIAdBf2ohBwwcCyADIAEpA4APNwAAIANBGGogCCkDADcAACADQRBqIAopAwA3AAAgA0EIaiALKQMANwAAIA5BAUYNGyAIIAlBGGopAAA3AwAgCiAJQRBqKQAANwMAIAsgCUEIaikAADcDACABIAkpAAA3A4APIANBwABqIQMgB0ECaiEHIAlBwABqIQkMAAsLEG8ACxBwAAtB0AFBCEEAKAL41EAiAUEEIAEbEQUAAAtB0AFBCEEAKAL41EAiAUEEIAEbEQUAAAtB0AFBCEEAKAL41EAiAUEEIAEbEQUAAAtB8ABBCEEAKAL41EAiAUEEIAEbEQUAAAtB+A5BCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB6AAQFiICRQ0AIAFBCGpBEGogA0EQaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgASADKQMINwMQIAMpAwAhDyABQQhqQSBqIANBIGoQOCABIA83AwggAiABQQhqQegAEDoaQRchAwwUC0HoAEEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHYAhAWIgJFDQAgAUEIaiADQcgBEDoaIAFBCGpByAFqIANByAFqEEUgAiABQQhqQdgCEDoaQRYhAwwTC0HYAkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEH4AhAWIgJFDQAgAUEIaiADQcgBEDoaIAFBCGpByAFqIANByAFqEEYgAiABQQhqQfgCEDoaQRUhAwwSC0H4AkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHYARAWIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADQcgAaikDACEPIAMpA0AhECABQQhqQdAAaiADQdAAahBEIAFBCGpByABqIA83AwAgASAQNwNIIAIgAUEIakHYARA6GkEUIQMMEQtB2AFBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB2AEQFiICRQ0AIAFBCGpBOGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggA0HIAGopAwAhDyADKQNAIRAgAUEIakHQAGogA0HQAGoQRCABQQhqQcgAaiAPNwMAIAEgEDcDSCACIAFBCGpB2AEQOhpBEyEDDBALQdgBQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQfAAEBYiAkUNACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpBKGogA0EoahA4IAEgDzcDCCACIAFBCGpB8AAQOhpBEiEDDA8LQfAAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQfAAEBYiAkUNACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpBKGogA0EoahA4IAEgDzcDCCACIAFBCGpB8AAQOhpBESEDDA4LQfAAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQZgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRyACIAFBCGpBmAIQOhpBECEDDA0LQZgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQbgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQSCACIAFBCGpBuAIQOhpBDyEDDAwLQbgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRSACIAFBCGpB2AIQOhpBDiEDDAsLQdgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQeACEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQSSACIAFBCGpB4AIQOhpBDSEDDAoLQeACQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQegAEBYiAkUNACABQQhqQRhqIANBGGooAgA2AgAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEgaiADQSBqEDggASAPNwMIIAIgAUEIakHoABA6GkEMIQMMCQtB6ABBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB6AAQFiICRQ0AIAFBCGpBGGogA0EYaigCADYCACABQQhqQRBqIANBEGopAwA3AwAgASADKQMINwMQIAMpAwAhDyABQQhqQSBqIANBIGoQOCABIA83AwggAiABQQhqQegAEDoaQQshAwwIC0HoAEEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHgABAWIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEYaiADQRhqEDggASAPNwMIIAIgAUEIakHgABA6GkEKIQMMBwtB4ABBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB4AAQFiICRQ0AIAFBCGpBEGogA0EQaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpBGGogA0EYahA4IAEgDzcDCCACIAFBCGpB4AAQOhpBCSEDDAYLQeAAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQZgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRyACIAFBCGpBmAIQOhpBCCEDDAULQZgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQbgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQSCACIAFBCGpBuAIQOhpBByEDDAQLQbgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRSACIAFBCGpB2AIQOhpBBiEDDAMLQdgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQeACEBYiAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQSSACIAFBCGpB4AIQOhpBBSEDDAILQeACQQhBACgC+NRAIgFBBCABGxEFAAALIAEgBzYCmAEgASAEOgBy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AHMgDCAJaiAAIApzIAtzakGFuqAkakEXdyALaiIJc2pBuaDTzn1qQQR3IAlqIgogCXMgGyAAaiAJIAtzIApzakHls+62fmpBC3cgCmoiAHNqQfj5if0BakEQdyAAaiILaiAOIABqIBcgCmogECAJaiAAIApzIAtzakHlrLGlfGpBF3cgC2oiCSAAQX9zciALc2pBxMSkoX9qQQZ3IAlqIgAgC0F/c3IgCXNqQZf/q5kEakEKdyAAaiIKIAlBf3NyIABzakGnx9DcempBD3cgCmoiC2ogFCAKaiAbIABqIBggCWogCyAAQX9zciAKc2pBucDOZGpBFXcgC2oiACAKQX9zciALc2pBw7PtqgZqQQZ3IABqIgkgC0F/c3IgAHNqQZKZs/h4akEKdyAJaiIKIABBf3NyIAlzakH96L9/akEPdyAKaiILaiATIApqIA0gCWogFiAAaiALIAlBf3NyIApzakHRu5GseGpBFXcgC2oiACAKQX9zciALc2pBz/yh/QZqQQZ3IABqIgkgC0F/c3IgAHNqQeDNs3FqQQp3IAlqIgogAEF/c3IgCXNqQZSGhZh6akEPdyAKaiILaiAVIApqIBkgCWogGiAAaiALIAlBf3NyIApzakGho6DwBGpBFXcgC2oiACAKQX9zciALc2pBgv3Nun9qQQZ3IABqIgkgC0F/c3IgAHNqQbXk6+l7akEKdyAJaiIKIABBf3NyIAlzakG7pd/WAmpBD3cgCmoiCyACaiAPIABqIAsgCUF/c3IgCnNqQZGnm9x+akEVd2ohAiALIAdqIQcgCiAGaiEGIAkgCGohCCABQcAAaiIBIAVHDQALIAQgBjYCFCAEIAc2AhAgBCACNgIMIAQgCDYCCAsL7REBGH8jACECIAAoAgAiAygCACEEIAMoAgghBSADKAIMIQYgAygCBCEHIAJBwABrIgBBGGoiAkIANwMAIABBIGoiCEIANwMAIABBOGoiCUIANwMAIABBMGoiCkIANwMAIABBKGoiC0IANwMAIABBCGoiDCABKQAINwMAIABBEGoiDSABKQAQNwMAIAIgASgAGCIONgIAIAggASgAICIPNgIAIAAgASkAADcDACAAIAEoABwiEDYCHCAAIAEoACQiETYCJCALIAEoACgiEjYCACAAIAEoACwiCzYCLCAKIAEoADAiEzYCACAAIAEoADQiCjYCNCAJIAEoADgiFDYCACAAIAEoADwiCTYCPCADIAQgDSgCACINIA8gEyAAKAIAIhUgESAKIAAoAgQiFiAAKAIUIhcgCiARIBcgFiATIA8gDSAHIBUgBCAHIAVxaiAGIAdBf3NxampB+Miqu31qQQd3aiIBaiAHIAAoAgwiGGogBSAMKAIAIgxqIAYgFmogASAHcWogBSABQX9zcWpB1u6exn5qQQx3IAFqIgAgAXFqIAcgAEF/c3FqQdvhgaECakERdyAAaiICIABxaiABIAJBf3NxakHunfeNfGpBFncgAmoiASACcWogACABQX9zcWpBr5/wq39qQQd3IAFqIghqIBAgAWogDiACaiAXIABqIAggAXFqIAIgCEF/c3FqQaqMn7wEakEMdyAIaiIAIAhxaiABIABBf3NxakGTjMHBempBEXcgAGoiASAAcWogCCABQX9zcWpBgaqaampBFncgAWoiAiABcWogACACQX9zcWpB2LGCzAZqQQd3IAJqIghqIAsgAmogEiABaiARIABqIAggAnFqIAEgCEF/c3FqQa/vk9p4akEMdyAIaiIAIAhxaiACIABBf3NxakGxt31qQRF3IABqIgEgAHFqIAggAUF/c3FqQb6v88p4akEWdyABaiICIAFxaiAAIAJBf3NxakGiosDcBmpBB3cgAmoiCGogFCABaiAKIABqIAggAnFqIAEgCEF/c3FqQZPj4WxqQQx3IAhqIgAgCHFqIAIgAEF/cyIZcWpBjofls3pqQRF3IABqIgEgGXFqIAkgAmogASAAcWogCCABQX9zIhlxakGhkNDNBGpBFncgAWoiAiAAcWpB4sr4sH9qQQV3IAJqIghqIAsgAWogCCACQX9zcWogDiAAaiACIBlxaiAIIAFxakHA5oKCfGpBCXcgCGoiACACcWpB0bT5sgJqQQ53IABqIgEgAEF/c3FqIBUgAmogACAIQX9zcWogASAIcWpBqo/bzX5qQRR3IAFqIgIgAHFqQd2gvLF9akEFdyACaiIIaiAJIAFqIAggAkF/c3FqIBIgAGogAiABQX9zcWogCCABcWpB06iQEmpBCXcgCGoiACACcWpBgc2HxX1qQQ53IABqIgEgAEF/c3FqIA0gAmogACAIQX9zcWogASAIcWpByPfPvn5qQRR3IAFqIgIgAHFqQeabh48CakEFdyACaiII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QQJyEBkgBSAJKQMANwAYIAUgCykDADcAECAFIAwpAwA3AAggBSAHKQMINwAAIAcoAowBIQkLIAFFDQggB0GQAWpBMGoiDUIANwMAIAdBkAFqQThqIg5CADcDACAHQZABakHAAGoiD0IANwMAIAdBkAFqQcgAaiIQQgA3AwAgB0GQAWpB0ABqIhFCADcDACAHQZABakHYAGoiEkIANwMAIAdBkAFqQeAAaiITQgA3AwAgB0GQAWpBIGoiCCACQRhqKQIANwMAIAdBkAFqQRhqIgsgAkEQaikCADcDACAHQZABakEQaiIMIAJBCGopAgA3AwAgB0IANwO4ASAHIAQ6APoBIAdBADsB+AEgByACKQIANwOYASAHIAmtIAN8NwOQASAHQZABaiAAIApqIAEQNBogB0EIakEQaiAMKQMANwMAIAdBCGpBGGogCykDADcDACAHQQhqQSBqIAgpAwA3AwAgB0EIakEwaiANKQMANwMAIAdBCGpBOGogDikDADcDACAHQQhqQcAAaiAPKQMANwMAIAdBCGpByABqIBApAwA3AwAgB0EIakHQAGogESkDADcDACAHQQhqQdgAaiASKQMANwMAIAdBCGpB4ABqIBMpAwA3AwAgByAHKQOYATcDECAHIAcpA7gBNwMwIActAPoBIQQgBy0A+QEhAiAHIActAPgBIgE6AHAgByAHKQOQASIDNwMIIAcgBCACRXJBAnIiBDoAcSAHQYACakEYaiICIAgpAwA3AwAgB0GAAmpBEGoiACALKQMANwMAIAdBgAJqQQhqIgogDCkDADcDACAHIAcpA5gBNwOAAiAHQYACaiAHQTBqIAEgAyAEEBkgCUEFdCIEQSBqIQggBEFgRg0EIAggBksNBSACKAIAIQggACgCACECIAooAgAhASAHKAKUAiEAIAcoAowCIQYgBygChAIhCiAHKAKAAiELIAUgBGoiBCAHKAKcAjYAHCAEIAg2ABggBCAANgAUIAQgAjYAECAEIAY2AAwgBCABNgAIIAQgCjYABCAEIAs2AAAgCUEBaiEJDAgLQcAAIQsgB0EIakHAAGohCiAAIAggAiADIAQgB0EIakHAABAdIQgLIAEgCSACIBQgBCAKIAsQHSEJAkAgCEEBRw0AIAZBP00NBSAFIAcpAAg3AAAgBUE4aiAHQQhqQThqKQAANwAAIAVBMGogB0EIakEwaikAADcAACAFQShqIAdBCGpBKGopAAA3AAAgBUEgaiAHQQhqQSBqKQAANwAAIAVBGGogB0EIakEYaikAADcAACAFQRBqIAdBCGpBEGopAAA3AAAgBUEIaiAHQQhqQQhqKQAANwAAQQIhCQwHCyAJIAhqQQV0IghBgQFPDQUgB0EIaiAIIAIgBCAFIAYQLCEJDAYLIAcgAEGACGo2AghBkJLAACAHQQhqQfCFwABB+IbAABBBAAtBoY3AAEEjQbSDwAAQVAALQWAgCEGghMAAEEwACyAIIAZBoITAABBKAAtBwAAgBkHQhMAAEEoACyAIQYABQcCEwAAQSgALIAdBoAJqJAAgCQvNDgEHfyAAQXhqIgEgAEF8aigCACICQXhxIgBqIQMCQAJAIAJBAXENACACQQNxRQ0BIAEoAgAiAiAAaiEAAkBBACgCnNhAIAEgAmsiAUcNACADKAIEQQNxQQNHDQFBACAANgKU2EAgAyADKAIEQX5xNgIEIAEgAEEBcjYCBCABIABqIAA2AgAPCwJAAkAgAkGAAkkNACABKAIYIQQCQAJAIAEoAgwiBSABRw0AIAFBFEEQIAEoAhQiBRtqKAIAIgINAUEAIQUMAwsgASgCCCICIAU2AgwgBSACNgIIDAILIAFBFGogAUEQaiAFGyEGA0AgBiEHAkAgAiIFQRRqIgYoAgAiAg0AIAVBEGohBiAFKAIQIQILIAINAAsgB0EANgIADAELAkAgAUEMaigCACIFIAFBCGooAgAiBkYNACAGIAU2AgwgBSAGNgIIDAILQQBBACgChNVAQX4gAkEDdndxNgKE1UAMAQsgBEUNAAJAAkAgASgCHEECdEGU18AAaiICKAIAIAFGDQAgBEEQQRQgBCgCECABRhtqIAU2AgAgBUUNAgwBCyACIAU2AgAgBQ0AQQBBACgCiNVAQX4gASgCHHdxNgKI1UAMAQsgBSAENgIYAkAgASgCECICRQ0AIAUgAjYCECACIAU2AhgLIAEoAhQiAkUNACAFQRRqIAI2AgAgAiAFNgIYCwJAAkAgAygCBCICQQJxRQ0AIAMgAkF+cTYCBCABIABBAXI2AgQgASAAaiAANgIADAELAkACQAJAAkACQAJAAkBBACgCoNhAIANGDQBBACgCnNhAIANHDQFBACABNgKc2EBBAEEAKAKU2EAgAGoiADYClNhAIAEgAEEBcjYCBCABIABqIAA2AgAPC0EAIAE2AqDYQEEAQQAoApjYQCAAaiIANgKY2EAgASAAQQFyNgIEIAFBACgCnNhARg0BDAULIAJBeHEiBSAAaiEAIAVBgAJJDQEgAygCGCEEAkACQCADKAIMIgUgA0cNACADQRRBECADKAIUIgUbaigCACICDQFBACEFDAQLIAMoAggiAiAFNgIMIAUgAjYCCAwDCyADQRRqIANBEGogBRshBgNAIAYhBwJAIAIiBUEUaiIGKAIAIgINACAFQRBqIQYgBSgCECECCyACDQALIAdBADYCAAwCC0EAQQA2ApTYQEEAQQA2ApzYQAwDCwJAIANBDGooAgAiBSADQQhqKAIAIgNGDQAgAyAFNgIMIAUgAzYCCAwCC0EAQQAoAoTVQEF+IAJBA3Z3cTYChNVADAELIARFDQACQAJAIAMoAhxBAnRBlNfAAGoiAigCACADRg0AIARBEEEUIAQoAhAgA0YbaiAFNgIAIAVFDQIMAQsgAiAFNgIAIAUNAEEAQQAoAojVQEF+IAMoAhx3cTYCiNVADAELIAUgBDYCGAJAIAMoAhAiAkUNACAFIAI2AhAgAiAFNgIYCyADKAIUIgNFDQAgBUEUaiADNgIAIAMgBTYCGAsgASAAQQFyNgIEIAEgAGogADYCACABQQAoApzYQEcNAUEAIAA2ApTYQAwCC0EAKAK82EAiAiAATw0BQQAoAqDYQCIARQ0BAkBBACgCmNhAIgVBKUkNAEGs2MAAIQEDQAJAIAEoAgAiAyAASw0AIAMgASgCBGogAEsNAgsgASgCCCIBDQALCwJAAkBBACgCtNhAIgANAEH/HyEBDAELQQAhAQNAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxshAQtBACABNgLE2EAgBSACTQ0BQQBBfzYCvNhADwsCQAJAAkAgAEGAAkkNAEEfIQMCQCAAQf///wdLDQAgAEEGIABBCHZnIgNrdkEBcSADQQF0a0E+aiEDCyABQgA3AhAgAUEcaiADNgIAIANBAnRBlNfAAGohAgJAAkACQAJAAkACQEEAKAKI1UAiBUEBIAN0IgZxRQ0AIAIoAgAiBSgCBEF4cSAARw0BIAUhAwwCC0EAIAUgBnI2AojVQCACIAE2AgAgAUEYaiACNgIADAMLIABBAEEZIANBAXZrQR9xIANBH0YbdCECA0AgBSACQR12QQRxakEQaiIGKAIAIgNFDQIgAkEBdCECIAMhBSADKAIEQXhxIABHDQALCyADKAIIIgAgATYCDCADIAE2AgggAUEYakEANgIAIAEgAzYCDCABIAA2AggMAgsgBiABNgIAIAFBGGogBTYCAAsgASABNgIMIAEgATYCCAtBAEEAKALE2EBBf2oiATYCxNhAIAENA0EAKAK02EAiAA0BQf8fIQEMAgsgAEEDdiIDQQN0QYzVwABqIQACQAJAQQAoAoTVQCICQQEgA3QiA3FFDQAgACgCCCEDDAELQQAgAiADcjYChNVAIAAhAwsgACABNgIIIAMgATYCDCABIAA2AgwgASADNgIIDwtBACEBA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGyEBC0EAIAE2AsTYQA8LC5UMARh/IwAhAiAAKAIAIQMgACgCCCEEIAAoAgwhBSAAKAIEIQYgAkHAAGsiAkEYaiIHQgA3AwAgAkEgaiIIQgA3AwAgAkE4aiIJQgA3AwAgAkEwaiIKQgA3AwAgAkEoaiILQgA3AwAgAkEIaiIMIAEpAAg3AwAgAkEQaiINIAEpABA3AwAgByABKAAYIg42AgAgCCABKAAgIg82AgAgAiABKQAANwMAIAIgASgAHCIQNgIcIAIgASgAJCIRNgIkIAsgASgAKCISNgIAIAIgASgALCILNgIsIAogASgAMCITNgIAIAIgASgANCIKNgI0IAkgASgAOCIUNgIAIAIgASgAPCIVNgI8IAAgAyATIAsgEiARIA8gECAOIAYgBCAFIAYgAyAGIARxaiAFIAZBf3NxaiACKAIAIhZqQQN3IgFxaiAEIAFBf3NxaiACKAIEIhdqQQd3IgcgAXFqIAYgB0F/c3FqIAwoAgAiDGpBC3ciCCAHcWogASAIQX9zcWogAigCDCIYakETdyIJIAhxIAFqIAcgCUF/c3FqIA0oAgAiDWpBA3ciASAJcSAHaiAIIAFBf3NxaiACKAIUIhlqQQd3IgIgAXEgCGogCSACQX9zcWpqQQt3IgcgAnEgCWogASAHQX9zcWpqQRN3IgggB3EgAWogAiAIQX9zcWpqQQN3IgEgCHEgAmogByABQX9zcWpqQQd3IgIgAXEgB2ogCCACQX9zcWpqQQt3IgcgAnEgCGogASAHQX9zcWpqQRN3IgggB3EgAWogAiAIQX9zcWpqQQN3IgEgFCABIAogASAIcSACaiAHIAFBf3NxampBB3ciCXEgB2ogCCAJQX9zcWpqQQt3IgIgCXIgFSACIAlxIgcgCGogASACQX9zcWpqQRN3IgFxIAdyaiAWakGZ84nUBWpBA3ciByACIA9qIAkgDWogByABIAJycSABIAJxcmpBmfOJ1AVqQQV3IgIgByABcnEgByABcXJqQZnzidQFakEJdyIIIAJyIAEgE2ogCCACIAdycSACIAdxcmpBmfOJ1AVqQQ13IgFxIAggAnFyaiAXakGZ84nUBWpBA3ciByAIIBFqIAIgGWogByABIAhycSABIAhxcmpBmfOJ1AVqQQV3IgIgByABcnEgByABcXJqQZnzidQFakEJdyIIIAJyIAEgCmogCCACIAdycSACIAdxcmpBmfOJ1AVqQQ13IgFxIAggAnFyaiAMakGZ84nUBWpBA3ciByAIIBJqIAIgDmogByABIAhycSABIAhxcmpBmfOJ1AVqQQV3IgIgByABcnEgByABcXJqQZnzidQFakEJdyIIIAJyIAEgFGogCCACIAdycSACIAdxcmpBmfOJ1AVqQQ13IgFxIAggAnFyaiAYakGZ84nUBWpBA3ciByABIBVqIAggC2ogAiAQaiAHIAEgCHJxIAEgCHFyakGZ84nUBWpBBXciAiAHIAFycSAHIAFxcmpBmfOJ1AVqQQl3IgggAiAHcnEgAiAHcXJqQZnzidQFakENdyIHIAhzIgkgAnNqIBZqQaHX5/YGakEDdyIBIBMgByABIA8gAiAJIAFzampBodfn9gZqQQl3IgJzIAggDWogASAHcyACc2pBodfn9gZqQQt3IghzampBodfn9gZqQQ93IgcgCHMiCSACc2ogDGpBodfn9gZqQQN3IgEgFCAHIAEgEiACIAkgAXNqakGh1+f2BmpBCXciAnMgCCAOaiABIAdzIAJzakGh1+f2BmpBC3ciCHNqakGh1+f2BmpBD3ciByAIcyIJIAJzaiAXakGh1+f2BmpBA3ciASAKIAcgASARIAIgCSABc2pqQaHX5/YGakEJdyICcyAIIBlqIAEgB3MgAnNqQaHX5/YGakELdyIIc2pqQaHX5/YGakEPdyIHIAhzIgkgAnNqIBhqQaHX5/YGakEDdyIBajYCACAAIAUgCyACIAkgAXNqakGh1+f2BmpBCXciAmo2AgwgACAEIAggEGogASAHcyACc2pBodfn9gZqQQt3IghqNgIIIAAgBiAVIAcgAiABcyAIc2pqQaHX5/YGakEPd2o2AgQLoAwBBn8gACABaiECAkACQAJAIAAoAgQiA0EBcQ0AIANBA3FFDQEgACgCACIDIAFqIQECQEEAKAKc2EAgACADayIARw0AIAIoAgRBA3FBA0cNAUEAIAE2ApTYQCACIAIoAgRBfnE2AgQgACABQQFyNgIEIAIgATYCAA8LAkACQCADQYACSQ0AIAAoAhghBAJAAkAgACgCDCIFIABHDQAgAEEUQRAgACgCFCIFG2ooAgAiAw0BQQAhBQwDCyAAKAIIIgMgBTYCDCAFIAM2AggMAgsgAEEUaiAAQRBqIAUbIQYDQCAGIQcCQCADIgVBFGoiBigCACIDDQAgBUEQaiEGIAUoAhAhAwsgAw0ACyAHQQA2AgAMAQsCQCAAQQxqKAIAIgUgAEEIaigCACIGRg0AIAYgBTYCDCAFIAY2AggMAgtBAEEAKAKE1UBBfiADQQN2d3E2AoTVQAwBCyAERQ0AAkACQCAAKAIcQQJ0QZTXwABqIgMoAgAgAEYNACAEQRBBFCAEKAIQIABGG2ogBTYCACAFRQ0CDAELIAMgBTYCACAFDQBBAEEAKAKI1UBBfiAAKAIcd3E2AojVQAwBCyAFIAQ2AhgCQCAAKAIQIgNFDQAgBSADNgIQIAMgBTYCGAsgACgCFCIDRQ0AIAVBFGogAzYCACADIAU2AhgLAkAgAigCBCIDQQJxRQ0AIAIgA0F+cTYCBCAAIAFBAXI2AgQgACABaiABNgIADAILAkACQEEAKAKg2EAgAkYNAEEAKAKc2EAgAkcNAUEAIAA2ApzYQEEAQQAoApTYQCABaiIBNgKU2EAgACABQQFyNgIEIAAgAWogATYCAA8LQQAgADYCoNhAQQBBACgCmNhAIAFqIgE2ApjYQCAAIAFBAXI2AgQgAEEAKAKc2EBHDQFBAEEANgKU2EBBAEEANgKc2EAPCyADQXhxIgUgAWohAQJAAkACQCAFQYACSQ0AIAIoAhghBAJAAkAgAigCDCIFIAJHDQAgAkEUQRAgAigCFCIFG2ooAgAiAw0BQQAhBQwDCyACKAIIIgMgBTYCDCAFIAM2AggMAgsgAkEUaiACQRBqIAUbIQYDQCAGIQcCQCADIgVBFGoiBigCACIDDQAgBUEQaiEGIAUoAhAhAwsgAw0ACyAHQQA2AgAMAQsCQCACQQxqKAIAIgUgAkEIaigCACICRg0AIAIgBTYCDCAFIAI2AggMAgtBAEEAKAKE1UBBfiADQQN2d3E2AoTVQAwBCyAERQ0AAkACQCACKAIcQQJ0QZTXwABqIgMoAgAgAkYNACAEQRBBFCAEKAIQIAJGG2ogBTYCACAFRQ0CDAELIAMgBTYCACAFDQBBAEEAKAKI1UBBfiACKAIcd3E2AojVQAwBCyAFIAQ2AhgCQCACKAIQIgNFDQAgBSADNgIQIAMgBTYCGAsgAigCFCICRQ0AIAVBFGogAjYCACACIAU2AhgLIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEEAKAKc2EBHDQFBACABNgKU2EALDwsCQCABQYACSQ0AQR8hAgJAIAFB////B0sNACABQQYgAUEIdmciAmt2QQFxIAJBAXRrQT5qIQILIABCADcCECAAQRxqIAI2AgAgAkECdEGU18AAaiEDAkACQAJAAkACQEEAKAKI1UAiBUEBIAJ0IgZxRQ0AIAMoAgAiBSgCBEF4cSABRw0BIAUhAgwCC0EAIAUgBnI2AojVQCADIAA2AgAgAEEYaiADNgIADAMLIAFBAEEZIAJBAXZrQR9xIAJBH0YbdCEDA0AgBSADQR12QQRxakEQaiIGKAIAIgJFDQIgA0EBdCEDIAIhBSACKAIEQXhxIAFHDQALCyACKAIIIgEgADYCDCACIAA2AgggAEEYakEANgIAIAAgAjYCDCAAIAE2AggPCyAGIAA2AgAgAEEYaiAFNgIACyAAIAA2AgwgACAANgIIDwsgAUEDdiICQQN0QYzVwABqIQECQAJAQQAoAoTVQCIDQQEgAnQiAnFFDQAgASgCCCECDAELQQAgAyACcjYChNVAIAEhAgsgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC/MLAQN/IwBB0ABrIgIkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAIAFBBGohAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgQOGAABAgMEBQYHCAkKCwwNDg8QERITFBUWFwALIAMoAgQhAyACQQhqIgRBwAAQUCADIARByAAQOkHIAWpBADoAAAwXCyADKAIEIQMgAkEIaiIEQSAQUCADIARByAAQOkHIAWpBADoAAAwWCyADKAIEIQMgAkEIaiIEQTAQUCADIARByAAQOkHIAWpBADoAAAwVCyADKAIEIQMgAkEIahBXIANBIGogAkEoaikDADcDACADQRhqIAJBIGopAwA3AwAgA0EQaiACQRhqKQMANwMAIANBCGogAkEQaikDADcDACADIAIpAwg3AwAgA0HoAGpBADoAAAwUCyADKAIEIgNCADcDACADIAMpA3A3AwggA0EgaiADQYgBaikDADcDACADQRhqIANBgAFqKQMANwMAIANBEGogA0H4AGopAwA3AwAgA0EoakEAQcIAEDsaIAMoApABRQ0TIANBADYCkAEMEwsgAygCBEEAQcgBEDtB2AJqQQA6AAAMEgsgAygCBEEAQcgBEDtB0AJqQQA6AAAMEQsgAygCBEEAQcgBEDtBsAJqQQA6AAAMEAsgAygCBEEAQcgBEDtBkAJqQQA6AAAMDwsgAygCBCIDQoHGlLqW8ermbzcDCCADQgA3AwAgA0HYAGpBADoAACADQRBqQv6568XpjpWZEDcDAAwOCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAAIANBEGpC/rnrxemOlZkQNwMADA0LIAMoAgQiA0IANwMAIANB4ABqQQA6AAAgA0EAKQPYjUA3AwggA0EQakEAKQPgjUA3AwAgA0EYakEAKALojUA2AgAMDAsgAygCBCIDQoHGlLqW8ermbzcDCCADQgA3AwAgA0HgAGpBADoAACADQRhqQfDDy558NgIAIANBEGpC/rnrxemOlZkQNwMADAsLIAMoAgRBAEHIARA7QdgCakEAOgAADAoLIAMoAgRBAEHIARA7QdACakEAOgAADAkLIAMoAgRBAEHIARA7QbACakEAOgAADAgLIAMoAgRBAEHIARA7QZACakEAOgAADAcLIAMoAgQiA0IANwMAIANB6ABqQQA6AAAgA0EAKQOQjkA3AwggA0EQakEAKQOYjkA3AwAgA0EYakEAKQOgjkA3AwAgA0EgakEAKQOojkA3AwAMBgsgAygCBCIDQgA3AwAgA0HoAGpBADoAACADQQApA/CNQDcDCCADQRBqQQApA/iNQDcDACADQRhqQQApA4COQDcDACADQSBqQQApA4iOQDcDAAwFCyADKAIEIgNCADcDQCADQQApA/COQDcDACADQcgAakIANwMAIANBOGpBACkDqI9ANwMAIANBMGpBACkDoI9ANwMAIANBKGpBACkDmI9ANwMAIANBIGpBACkDkI9ANwMAIANBGGpBACkDiI9ANwMAIANBEGpBACkDgI9ANwMAIANBCGpBACkD+I5ANwMAIANB0AFqQQA6AAAMBAsgAygCBCIDQgA3A0AgA0EAKQOwjkA3AwAgA0HIAGpCADcDACADQThqQQApA+iOQDcDACADQTBqQQApA+COQDcDACADQShqQQApA9iOQDcDACADQSBqQQApA9COQDcDACADQRhqQQApA8iOQDcDACADQRBqQQApA8COQDcDACADQQhqQQApA7iOQDcDACADQdABakEAOgAADAMLIAMoAgRBAEHIARA7QfACakEAOgAADAILIAMoAgRBAEHIARA7QdACakEAOgAADAELIAMoAgQiA0IANwMAIANB4ABqQQA6AAAgA0EAKQP4kUA3AwggA0EQakEAKQOAkkA3AwAgA0EYakEAKQOIkkA3AwALIAFBADYCACAAQgA3AwAgAkHQAGokAA8LEG8ACxBwAAuYCgIEfwR+IwBBkANrIgMkACABIAFBgAFqLQAAIgRqIgVBgAE6AAAgAEHIAGopAwBCCoYgACkDQCIHQjaIhCIIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEIQkgCEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQhCiAHQgqGIAStQgOGhCIIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEIQcgCEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQhCAJAIARB/wBzIgZFDQAgBUEBakEAIAYQOxoLIAogCYQhCSAIIAeEIQgCQAJAIARB8ABxQfAARg0AIAFB+ABqIAg3AAAgAUHwAGogCTcAACAAIAFBARANDAELIAAgAUEBEA0gA0EANgKAASADQYABakEEckEAQYABEDsaIANBgAE2AoABIANBiAJqIANBgAFqQYQBEDoaIAMgA0GIAmpBBHJB8AAQOiIEQfgAaiAINwMAIARB8ABqIAk3AwAgACAEQQEQDQsgAUGAAWpBADoAACACIAApAwAiCEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQ3AAAgAiAAKQMIIghCOIYgCEIohkKAgICAgIDA/wCDhCAIQhiGQoCAgICA4D+DIAhCCIZCgICAgPAfg4SEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISENwAIIAIgACkDECIIQjiGIAhCKIZCgICAgICAwP8Ag4QgCEIYhkKAgICAgOA/gyAIQgiGQoCAgIDwH4OEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhDcAECACIAApAxgiCEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQ3ABggAiAAKQMgIghCOIYgCEIohkKAgICAgIDA/wCDhCAIQhiGQoCAgICA4D+DIAhCCIZCgICAgPAfg4SEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISENwAgIAIgACkDKCIIQjiGIAhCKIZCgICAgICAwP8Ag4QgCEIYhkKAgICAgOA/gyAIQgiGQoCAgIDwH4OEhCAIQgiIQoCAgPgPgyAIQhiIQoCA/AeDhCAIQiiIQoD+A4MgCEI4iISEhDcAKCACIAApAzAiCEI4hiAIQiiGQoCAgICAgMD/AIOEIAhCGIZCgICAgIDgP4MgCEIIhkKAgICA8B+DhIQgCEIIiEKAgID4D4MgCEIYiEKAgPwHg4QgCEIoiEKA/gODIAhCOIiEhIQ3ADAgAiAAKQM4IghCOIYgCEIohkKAgICAgIDA/wCDhCAIQhiGQoCAgICA4D+DIAhCCIZCgICAgPAfg4SEIAhCCIhCgICA+A+DIAhCGIhCgID8B4OEIAhCKIhCgP4DgyAIQjiIhISENwA4IANBkANqJAAL7wkCEH8FfiMAQZABayICJAACQAJAAkAgASgCkAEiA0UNAAJAAkAgAUHpAGotAAAiBEEGdEEAIAEtAGgiBWtHDQAgA0F+aiEGIANBAU0NBCACQRBqIAFB+ABqKQMANwMAIAJBGGogAUGAAWopAwA3AwAgAkEgaiABQYgBaikDADcDACACQTBqIAFBlAFqIgcgBkEFdGoiBEEIaikCADcDACACQThqIARBEGopAgA3AwBBwAAhBSACQcAAaiAEQRhqKQIANwMAIAIgASkDcDcDCCACIAQpAgA3AyggA0EFdCAHakFgaiIEKQIAIRIgBCkCCCETIAQpAhAhFCABLQBqIQggAkHgAGogBCkCGDcDACACQdgAaiAUNwMAIAJB0ABqIBM3AwAgAkHIAGogEjcDAEIAIRIgAkIANwMAIAhBBHIhCSACQQhqIQQMAQsgAkEQaiABQRBqKQMANwMAIAJBGGogAUEYaikDADcDACACQSBqIAFBIGopAwA3AwAgAkEwaiABQTBqKQMANwMAIAJBOGogAUE4aikDADcDACACQcAAaiABQcAAaikDADcDACACQcgAaiABQcgAaikDADcDACACQdAAaiABQdAAaikDADcDACACQdgAaiABQdgAaikDADcDACACQeAAaiABQeAAaikDADcDACACIAEpAwg3AwggAiABKQMoNwMoIAEtAGohCCACIAEpAwAiEjcDACAIIARFckECciEJIAJBCGohBCADIQYLIAIgCToAaSACIAU6AGgCQAJAIAZFDQAgAUHwAGohCiACQShqIQdBASAGayELIAhBBHIhCCAGQQV0IAFqQfQAaiEBIAZBf2ogA08hDANAIAwNAiACQfAAakEYaiIGIARBGGoiDSkCADcDACACQfAAakEQaiIOIARBEGoiDykCADcDACACQfAAakEIaiIQIARBCGoiESkCADcDACACIAQpAgA3A3AgAkHwAGogByAFIBIgCRAZIBApAwAhEyAOKQMAIRQgBikDACEVIAIpA3AhFiAHQRhqIAFBGGopAgA3AgAgB0EQaiABQRBqKQIANwIAIAdBCGogAUEIaikCADcCACAHIAEpAgA3AgAgBCAKKQMANwMAIBEgCkEIaikDADcDACAPIApBEGopAwA3AwAgDSAKQRhqKQMANwMAQgAhEiACQgA3AwAgAiAVNwNgIAIg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dEGAgPwHcXIgAEEIdkGA/gNxIABBGHZycjYAHCADQdABaiQAC6IGAgN/An4jAEHwAWsiAyQAIAApAwAhBiABIAFBwABqLQAAIgRqIgVBgAE6AAAgA0EIakEQaiAAQRhqKAIANgIAIANBEGogAEEQaikCADcDACADIAApAgg3AwggBkIJhiAErUIDhoQiBkIIiEKAgID4D4MgBkIYiEKAgPwHg4QgBkIoiEKA/gODIAZCOIiEhCEHIAZCOIYgBkIohkKAgICAgIDA/wCDhCAGQhiGQoCAgICA4D+DIAZCCIZCgICAgPAfg4SEIQYCQCAEQT9zIgBFDQAgBUEBakEAIAAQOxoLIAYgB4QhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADQQhqIAFBARAUDAELIANBCGogAUEBEBQgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HAADYCYCADQagBaiADQeAAakHEABA6GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEkaikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBakEMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQQhqIANBIGpBARAUCyABQcAAakEAOgAAIAIgAygCCCIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAAgAiADKAIMIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYABCACIAMoAhAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAIIAIgAygCFCIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAwgAiADKAIYIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYAECADQfABaiQAC7IGARV/IwBBsAFrIgIkAAJAAkACQCAAKAKQASIDIAF7pyIETQ0AIABB8ABqIQUgAkEoaiEGIAJBCGoh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BEE/cyIARQ0AIAVBAWpBACAAEDsaCyAGIAeEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgA0EIaiABEBIMAQsgA0EIaiABEBIgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HAADYCYCADQagBaiADQeAAakHEABA6GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEkaikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBakEMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQQhqIANBIGoQEgsgAiADKAIINgAAIAIgAykCDDcABCACIAMpAhQ3AAwgAUHAAGpBADoAACADQfABaiQAC/ADAgN/An4jAEHwAWsiAyQAIAFBwABqLQAAIQQgACkDACEGIANBEGogAEEQaikCADcDACADIAApAgg3AwggASAEaiIAQYABOgAAIAZCCYYhBiAErUIDhiEHIAMgA0EIajYCHAJAIARBP3MiBUUNACAAQQFqQQAgBRA7GgsgByAGhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIANBHGogARAcDAELIANBHGogARAcIANB4ABqQQxqQgA3AgAgA0HgAGpBFGpCADcCACADQeAAakEcakIANwIAIANB4ABqQSRqQgA3AgAgA0HgAGpBLGpCADcCACADQeAAakE0akIANwIAIANBnAFqQgA3AgAgA0IANwJkIANBwAA2AmAgA0GoAWogA0HgAGpBxAAQOhogA0HQAGogA0GoAWpBNGopAgA3AwAgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpBJGopAgA3AwAgA0E4aiADQagBakEcaikCADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAWpBDGopAgA3AwAgAyADKQKsATcDICADIAY3A1ggA0EcaiADQSBqEBwLIAFBwABqQQA6AAAgAiADKQMINwAAIAIgAykDEDcACCADQfABaiQAC9kDAgN/An4jAEHgAWsiAyQAIAApAwAhBiABIAFBwABqLQAAIgRqIgVBgAE6AAAgA0EIaiAAQRBqKQIANwMAIAMgACkCCDcDACAGQgmGIQYgBK1CA4YhBwJAIARBP3MiAEUNACAFQQFqQQAgABA7GgsgByAGhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIAMgARAfDAELIAMgARAfIANB0ABqQQxqQgA3AgAgA0HQAGpBFGpCADcCACADQdAAakEcakIANwIAIANB0ABqQSRqQgA3AgAgA0HQAGpBLGpCADcCACADQdAAakE0akIANwIAIANBjAFqQgA3AgAgA0IANwJUIANBwAA2AlAgA0GYAWogA0HQAGpBxAAQOhogA0HAAGogA0GYAWpBNGopAgA3AwAgA0E4aiADQZgBakEsaikCADcDACADQTBqIANBmAFqQSRqKQIANwMAIANBKGogA0GYAWpBHGopAgA3AwAgA0EgaiADQZgBakEUaikCADcDACADQRhqIANBmAFqQQxqKQIANwMAIAMgAykCnAE3AxAgAyAGNwNIIAMgA0EQahAfCyACIAMpAwA3AAAgAiADKQMINwAIIAFBwABqQQA6AAAgA0HgAWokAAvUAwIEfwJ+IwBB0AFrIgMkACABIAFBwABqLQAAIgRqIgVBAToAACAAKQMAQgmGIQcgBK1CA4YhCAJAIARBP3MiBkUNACAFQQFqQQAgBhA7GgsgByAIhCEHAkACQCAEQThxQThGDQAgAUE4aiAHNwAAIABBCGogAUEBEBcMAQsgAEEIaiIEIAFBARAXIANBwABqQQxqQgA3AgAgA0HAAGpBFGpCADcCACADQcAAakEcakIANwIAIANBwABqQSRqQgA3AgAgA0HAAGpBLGpCADcCACADQcAAakE0akIANwIAIANB/ABqQgA3AgAgA0IANwJEIANBwAA2AkAgA0GIAWogA0HAAGpBxAAQOhogA0EwaiADQYgBakE0aikCADcDACADQShqIANBiAFqQSxqKQIANwMAIANBIGogA0GIAWpBJGopAgA3AwAgA0EYaiADQYgBakEcaikCADcDACADQRBqIANBiAFqQRRqKQIANwMAIANBCGogA0GIAWpBDGopAgA3AwAgAyADKQKMATcDACADIAc3AzggBCADQQEQFwsgAUHAAGpBADoAACACIAApAwg3AAAgAiAAQRBqKQMANwAIIAIgAEEYaikDADcAECADQdABaiQAC4kDAQV/AkACQAJAIAFBCUkNAEEAIQJBzf97IAFBECABQRBLGyIBayAATQ0BIAFBECAAQQtqQXhxIABBC0kbIgNqQQxqEBYiAEUNASAAQXhqIQICQAJAIAFBf2oiBCAAcQ0AIAIhAQwBCyAAQXxqIgUoAgAiBkF4cSAEIABqQQAgAWtxQXhqIgBBACABIAAgAmtBEEsbaiIBIAJrIgBrIQQCQCAGQQNxRQ0AIAEgASgCBEEBcSAEckECcjYCBCAEIAFqQQRqIgQgBCgCAEEBcjYCACAFIAUoAgBBAXEgAHJBAnI2AgAgACACakEEaiIEIAQoAgBBAXI2AgAgAiAAECAMAQsgAigCACECIAEgBDYCBCABIAIgAGo2AgALIAEoAgQiAEEDcUUNAiAAQXhxIgIgA0EQak0NAiABIABBAXEgA3JBAnI2AgQgASADaiIAIAIgA2siAkEDcjYCBCAAIAJBBHJqIgMgAygCAEEBcjYCACAAIAIQIAwCCyAAEBYhAgsgAg8LIAFBCGoLlwMBBX8jAEGQBGsiAyQAIABByAFqIQQCQAJAAkACQAJAIABB8AJqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEDogBmohASACIAZrIQILIAIgAkGoAW4iBUGoAWwiB0kNASACIAdrIQYCQCAFQagBbCICRQ0AIAEhBQNAIANB4AJqIABBqAEQOhogABAkIAUgA0HgAmpBqAEQOkGoAWohBSACQdh+aiICDQALCwJAIAYNAEEAIQYMBAsgA0EANgKwASADQbABakEEckEAQagBEDsaIANBqAE2ArABIANB4AJqIANBsAFqQawBEDoaIANBCGogA0HgAmpBBHJBqAEQOhogA0HgAmogAEGoARA6GiAAECQgA0EIaiADQeACakGoARA6GiAGQakBTw0CIAEgB2ogA0EIaiAGEDoaIAQgA0EIakGoARA6GgwDCyABIAQgBWogAhA6GiAFIAJqIQYMAgtBoY3AAEEjQcSNwAAQVAALIAZBqAFBxIzAABBKAAsgAEHwAmogBjoAACADQZAEaiQAC5cDAQV/IwBBsANrIgMkACAAQcgBaiEEAkACQAJAAkACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhA6IAZqIQEgAiAGayECCyACIAJBiAFuIgVBiAFsIgdJDQEgAiAHayEGAkAgBUGIAWwiAkUNACABIQUDQCADQaACaiAAQYgBEDoaIAAQJCAFIANBoAJqQYgBEDpBiAFqIQUgAkH4fmoiAg0ACwsCQCAGDQBBACEGDAQLIANBADYCkAEgA0GQAWpBBHJBAEGIARA7GiADQYgBNgKQASADQaACaiADQZABakGMARA6GiADQQhqIANBoAJqQQRyQYgBEDoaIANBoAJqIABBiAEQOhogABAkIANBCGogA0GgAmpBiAEQOhogBkGJAU8NAiABIAdqIANBCGogBhA6GiAEIANBCGpBiAEQOhoMAwsgASAEIAVqIAIQOhogBSACaiEGDAILQaGNwABBI0HEjcAAEFQACyAGQYgBQcSMwAAQSgALIABB0AJqIAY6AAAgA0GwA2okAAuCAwEDfwJAAkACQAJAIAAtAGgiA0UNAAJAIANBwQBPDQAgACADakEoaiABIAJBwAAgA2siAyADIAJLGyIDEDoaIAAgAC0AaCADaiIEOgBoIAEgA2ohAQJAIAIgA2siAg0AQQAhAgwDCyAAQQhqIABBKGoiBEHAACAAKQMAIAAtAGogAEHpAGoiAy0AAEVyEBkgBEEAQcEAEDsaIAMgAy0AAEEBajoAAAwBCyADQcAAQZCEwAAQSwALAkAgAkHAAEsNACACQcAAIAJBwABJGyECQQAhAwwCCyAAQQhqIQUgAEHpAGoiAy0AACEEA0AgBSABQcAAIAApAwAgAC0AaiAEQf8BcUVyEBkgAyADLQAAQQFqIgQ6AAAgAUHAAGohASACQUBqIgJBwABLDQALIAAtAGghBAsgBEH/AXEiA0HBAE8NASACQcAAIANrIgQgBCACSxshAgsgACADakEoaiABIAIQOhogACAALQBoIAJqOgBoIAAPCyADQcAAQZCEwAAQSwAL0AICBX8BfiMAQTBrIgIkAEEnIQMCQAJAIABCkM4AWg0AIAAhBwwBC0EnIQMDQCACQQlqIANqIgRBfGogAEKQzgCAIgdC8LF/fiAAfKciBUH//wNxQeQAbiIGQQF0QamIwABqLwAAOwAAIARBfmogBkGcf2wgBWpB//8DcUEBdEGpiMAAai8AADsAACADQXxqIQMgAEL/wdcvViEEIAchACAEDQALCwJAIAenIgRB4wBMDQAgAkEJaiADQX5qIgNqIAenIgVB//8DcUHkAG4iBEGcf2wgBWpB//8DcUEBdEGpiMAAai8AADsAAAsCQAJAIARBCkgNACACQQlqIANBfmoiA2ogBEEBdEGpiMAAai8AADsAAAwBCyACQQlqIANBf2oiA2ogBEEwajoAAAsgAUGgkcAAQQAgAkEJaiADakEnIANrECohAyACQTBqJAAgAwuhAgEBfyMAQTBrIgYkACAGIAI2AiggBiACNgIkIAYgATYCICAGQRBqIAZBIGoQFSAGKAIUIQICQAJAAkAgBigCEEEBRg0AIAYgAjYCCCAGIAZBEGpBCGooAgA2AgwgBkEIaiADEDcgBiAGKQMINwMQIAZBIGogBkEQaiAEQQBHIAUQDiAGQSBqQQhqKAIAIQQgBigCJCECAkAgBigCICIFQQFHDQAgAiAEEAAhAgsCQCAGKAIQQQRHDQAgBigCFCIDKAKQAUUNACADQQA2ApABCyAGKAIUEB5BACEDQQAhASAFDQEMAgsCQCADQSRJDQAgAxABCwtBASEBIAIhAwsgACABNgIMIAAgAzYCCCAAIAQ2AgQgACACNgIAIAZBMGokAAvjAQEHfyMAQRBrIgIkACABEAIhAyABEAMhBCABEAQhBQJAAkAgA0GBgARJDQBBACEGIAMhBwNAIAIgBSAEIAZqIAdBgIAEIAdBgIAESRsQBSIIED8CQCAIQSRJDQAgCBABCyAAIAIoAgAiCCACKAIIEA8gBkGAgARqIQYCQCACKAIERQ0AIAgQHgsgB0GAgHxqIQcgAyAGSw0ADAILCyACIAEQPyAAIAIoAgAiBiACKAIIEA8gAigCBEUNACAGEB4LAkAgBUEkSQ0AIAUQAQsCQCABQSRJDQAgARABCyACQRBqJAAL5QEBAn8jAEGQAWsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgA0EEaiIDQcAARw0ACyACQcAANgIAIAJByABqIAJBxAAQOhogAEE4aiACQYQBaikCADcAACAAQTBqIAJB/ABqKQIANwAAIABBKGogAkH0AGopAgA3AAAgAEEgaiACQewAaikCADcAACAAQRhqIAJB5ABqKQIANwAAIABBEGogAkHcAGopAgA3AAAgAEEIaiACQdQAaikCADcAACAAIAIpAkw3AAAgACABLQBAOgBAIAJBkAFqJAALzwECA38BfiMAQSBrIgQkAAJAAkAgAUUNACABKAIADQFBACEFIAFBADYCACABKQIEIQcgARAeIAQgBzcDCCAEQRBqIARBCGogAkEARyADEA4gBEEYaigCACECIAQoAhQhAQJAIAQoAhAiA0EBRw0AIAEgAhAAIgUhAQsCQCAEKAIIQQRHDQAgBCgCDCIGKAKQAUUNACAGQQA2ApABCyAEKAIMEB4gACADNgIMIAAgBTYCCCAAIAI2AgQgACABNgIAIARBIGokAA8LEG8ACxBwAAu7AQEEfwJAIAJFDQAgAkEDcSEDQQAhBAJAIAJBf2pBA0kNACACQXxxIQVBACEEA0AgACAEaiICIAEgBGoiBi0AADoAACACQQFqIAZBAWotAAA6AAAgAkECaiAGQQJqLQAAOgAAIAJBA2ogBkEDai0AADoAACAFIARBBGoiBEcNAAsLIANFDQAgASAEaiECIAAgBGohBANAIAQgAi0AADoAACACQQFqIQIgBEEBaiEEIANBf2oiAw0ACwsgAAu4AQEDfwJAIAJFDQAgAkEHcSEDQQAhBAJAIAJBf2pBB0kNACACQXhxIQVBACEEA0AgACAEaiICIAE6AAAgAkEHaiABOgAAIAJBBmogAToAACACQQVqIAE6AAAgAkEEaiABOgAAIAJBA2ogAToAACACQQJqIAE6AAAgAkEBaiABOgAAIAUgBEEIaiIERw0ACwsgA0UNACAAIARqIQIDQCACIAE6AAAgAkEBaiECIANBf2oiAw0ACwsgAAutAQEBfyMAQRBrIgYkAAJAAkAgAUUNACAGIAEgAyAEIAUgAigCEBELACAGKAIAIQMCQAJAIAYoAgQiBCAGKAIIIgFLDQAgAyECDAELAkAgAUECdCIFDQBBBCECIARBAnRFDQEgAxAeDAELIAMgBRAmIgJFDQILIAAgATYCBCAAIAI2AgAgBkEQaiQADwtBsI/AAEEwEHEACyAFQQRBACgC+NRAIgZBBCAGGxEFAAALrgEBAn8jAEEgayIDJAAgAyACNgIYIAMgAjYCFCADIAE2AhAgAyADQRBqEBVBASEEIAMoAgQhAQJAAkACQCADKAIAQQFHDQAMAQsgA0EIaigCACEEQQwQFiICRQ0BIAIgBDYCCCACIAE2AgRBACEBIAJBADYCAEEAIQQLIAAgBDYCCCAAIAE2AgQgACACNgIAIANBIGokAA8LQQxBBEEAKAL41EAiA0EEIAMbEQUAAAujAQEDfyMAQRBrIgQkAAJAAkAgAUUNACABKAIAIgVBf0YNASABIAVBAWo2AgBBACEFIAQgAUEEaiACQQBHIAMQDCAEQQhqKAIAIQMgBCgCBCECAkAgBCgCACIGQQFHDQAgAiADEAAiBSECCyABIAEoAgBBf2o2AgAgACAGNgIMIAAgBTYCCCAAIAM2AgQgACACNgIAIARBEGokAA8LEG8ACxBwAAudAQEEfwJAAkACQAJAIAEQBiICQQBIDQAgAg0BQQEhAwwCCxBqAAsgAhAWIgNFDQELIAAgAjYCBCAAIAM2AgAQByIEEAgiBRAJIQICQCAFQSRJDQAgBRABCyACIAEgAxAKAkAgAkEkSQ0AIAIQAQsCQCAEQSRJDQAgBBABCyAAIAEQBjYCCA8LIAJBAUEAKAL41EAiAUEEIAEbEQUAAAuaAQEDfyMAQRBrIgQkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAIAQgAUEEaiACQQBHIAMQDiAEQQhqKAIAIQMgBCgCBCECAkACQCAEKAIAIgVBAUYNAEEAIQYMAQsgAiADEAAiBiECCyABQQA2AgAgACAFNgIMIAAgBjYCCCAAIAM2AgQgACACNgIAIARBEGokAA8LEG8ACxBwAAt+AQF/IwBBwABrIgQkACAEQSs2AgwgBCAANgIIIAQgAjYCFCAEIAE2AhAgBEEsakECNgIAIARBPGpBATYCACAEQgI3AhwgBEGYiMAANgIYIARBAjYCNCAEIARBMGo2AiggBCAEQRBqNgI4IAQgBEEIajYCMCAEQRhqIAMQWAALfgECfyMAQTBrIgIkACACQRRqQQI2AgAgAkG4h8AANgIQIAJBAjYCDCACQZiHwAA2AgggAUEcaigCACEDIAEoAhghASACQSxqQQI2AgAgAkICNwIcIAJBmIjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC34BAn8jAEEwayICJAAgAkEUakECNgIAIAJBuIfAADYCECACQQI2AgwgAkGYh8AANgIIIAFBHGooAgAhAyABKAIYIQEgAkEsakECNgIAIAJCAjcCHCACQZiIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqECshASACQTBqJAAgAQt0AQJ/IwBBkAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GAAUcNAAsgAkGAATYCACACQYgBaiACQYQBEDoaIAAgAkGIAWpBBHJBgAEQOiABLQCAAToAgAEgAkGQAmokAAt0AQJ/IwBBoAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GIAUcNAAsgAkGIATYCACACQZABaiACQYwBEDoaIAAgAkGQAWpBBHJBiAEQOiABLQCIAToAiAEgAkGgAmokAAt0AQJ/IwBB4AJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GoAUcNAAsgAkGoATYCACACQbABaiACQawBEDoaIAAgAkGwAWpBBHJBqAEQOiABLQCoAToAqAEgAkHgAmokAAtyAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0HIAEcNAAsgAkHIADYCACACQdAAaiACQcwAEDoaIAAgAkHQAGpBBHJByAAQOiABLQBIOgBIIAJBoAFqJAALcgECfyMAQeABayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACADQQRqIgNB6ABHDQALIAJB6AA2AgAgAkHwAGogAkHsABA6GiAAIAJB8ABqQQRyQegAEDogAS0AaDoAaCACQeABaiQAC3QBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgA0EEaiIDQZABRw0ACyACQZABNgIAIAJBmAFqIAJBlAEQOhogACACQZgBakEEckGQARA6IAEtAJABOgCQASACQbACaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQciKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBYAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GoisAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQWAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANB/IrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFgAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQcyLwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBYAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GEiMAANgIIIANBAzYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQWAALdQECf0EBIQBBAEEAKAKA1UAiAUEBajYCgNVAAkACQEEAKALI2EBBAUcNAEEAKALM2EBBAWohAAwBC0EAQQE2AsjYQAtBACAANgLM2EACQCABQQBIDQAgAEECSw0AQQAoAvzUQEF/TA0AIABBAUsNABB0AAsAC5oBACMAQTBrGiAAQgA3A0AgAEE4akL5wvibkaOz8NsANwMAIABBMGpC6/qG2r+19sEfNwMAIABBKGpCn9j52cKR2oKbfzcDACAAQtGFmu/6z5SH0QA3AyAgAELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7fzcDCCAAIAGtQoiS95X/zPmE6gCFNwMAC1UBAn8CQAJAIABFDQAgACgCAA0BIABBADYCACAAKAIIIQEgACgCBCECIAAQHgJAIAJBBEcNACABKAKQAUUNACABQQA2ApABCyABEB4PCxBvAAsQcAALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLVAEBfwJAAkACQCABQYCAxABGDQBBASEEIAAoAhggASAAQRxqKAIAKAIQEQYADQELIAINAUEAIQQLIAQPCyAAKAIYIAIgAyAAQRxqKAIAKAIMEQgAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIANBoJHAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEFgACzkAAkACQCABRQ0AIAEoAgANASABQX82AgAgAUEEaiACEDcgAUEANgIAIABCADcDAA8LEG8ACxBwAAsrAAJAIABBfEsNAAJAIAANAEEEDwsgACAAQX1JQQJ0EDEiAEUNACAADwsAC1IAIABCx8yj2NbQ67O7fzcDCCAAQgA3AwAgAEEgakKrs4/8kaOz8NsANwMAIABBGGpC/6S5iMWR2oKbfzcDACAAQRBqQvLmu+Ojp/2npX83AwALNAEBfyMAQRBrIgIkACACIAE2AgwgAiAANgIIIAJBwIfAADYCBCACQaCRwAA2AgAgAhBoAAslAAJAIAANAEGwj8AAQTAQcQALIAAgAiADIAQgBSABKAIQEQwACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQoACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQkACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQoACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQkACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQEQkACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQERUACyMAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgBCABKAIQERYACyEAAkAgAA0AQbCPwABBMBBxAAsgACACIAMgASgCEBEHAAseACAAQRRqKAIAGgJAIABBBGooAgAOAgAAAAsQTwALHAACQAJAIAFBfEsNACAAIAIQJiIBDQELAAsgAQsfAAJAIAANAEGwj8AAQTAQcQALIAAgAiABKAIQEQYACxoAAkAgAA0AQaCRwABBK0HokcAAEFQACyAACxQAIAAoAgAgASAAKAIEKAIMEQYACxAAIAEgACgCACAAKAIEECULDgAgACgCCBBlIAAQcgALDgACQCABRQ0AIAAQHgsLEQBBgoLAAEERQZSCwAAQVAALEQBBpILAAEEvQaSDwAAQVAALDQAgACgCABoDfwwACwsLACAAIwBqJAAjAAsLACAANQIAIAEQNQsMAEHA0sAAQRsQcQALDQBB29LAAEHPABBxAAsJACAAIAEQCwALCQAgACABEGIACwwAQqXwls/l/+mlVgsDAAALAgALAgALC/7UgIAAAQBBgIDAAAv0VPQFEABQAAAAlQAAAAkAAABCTEFLRTJCQkxBS0UyQi0yNTZCTEFLRTJCLTM4NEJMQUtFMlNCTEFLRTNLRUNDQUstMjI0S0VDQ0FLLTI1NktFQ0NBSy0zODRLRUNDQUstNTEyTUQ0TUQ1UklQRU1ELTE2MFNIQS0xU0hBLTIyNFNIQS0yNTZTSEEtMzg0U0hBLTUxMlRJR0VSdW5zdXBwb3J0ZWQgYWxnb3JpdGhtbm9uLWRlZmF1bHQgbGVuZ3RoIHNwZWNpZmllZCBmb3Igbm9uLWV4dGVuZGFibGUgYWxnb3JpdGhtbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AOYAEAAcAAAAMgIAAAUAAABBcnJheVZlYzogY2FwYWNpdHkgZXhjZWVkZWQgaW4gZXh0ZW5kL2Zyb21faXRlcn4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2ZWMtMC43LjIvc3JjL2FycmF5dmVjLnJzAFMBEABQAAAAAQQAAAUAAABUBhAATQAAAAEGAAAJAAAAfi8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9ibGFrZTMtMS4zLjAvc3JjL2xpYi5ycwAAAMQBEABJAAAAuQEAAAkAAADEARAASQAAAF8CAAAKAAAAxAEQAEkAAACNAgAACQAAAMQBEABJAAAA3QIAAAoAAADEARAASQAAANYCAAAJAAAAxAEQAEkAAAABAwAAGQAAAMQBEABJAAAAAwMAAAkAAADEARAASQAAAAMDAAA4AAAAxAEQAEkAAAD4AwAAMgAAAMQBEABJAAAAqgQAABYAAADEARAASQAAALwEAAAWAAAAxAEQAEkAAADtBAAAEgAAAMQBEABJAAAA9wQAABIAAADEARAASQAAAGkFAAAhAAAAEQAAAAQAAAAEAAAAEgAAABEAAAAgAAAAAQAAABMAAAARAAAABAAAAAQAAAASAAAAfi8uY2FyZ28vcmVnaXN0cnkvc3Jj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AAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIAAAADAAAABAAAAAIAAAAEAAAAAYAAAAQAAAACAAAAAwAAAAIAAAACAAAAAcAAAAIAAAADAAAABAAAAAEAAAABAAAAAUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIAAAADAAAABAAAAAIAAAAEAAAAAYAAAAANm3gIAABG5hbWUBzreAgAB3AEVqc19zeXM6OlR5cGVFcnJvcjo6bmV3OjpfX3diZ19uZXdfYTRiNjFhMGY1NDgyNGNmZDo6aDVkNzhiNTczMzA4ODhkZmMBO3dhc21fYmluZGdlbjo6X193YmluZGdlbl9vYmplY3RfZHJvcF9yZWY6OmhmOGQ1NWUyOTY2MWNmMmMzAlVqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfbGVuZ3RoOjpfX3diZ19ieXRlTGVuZ3RoXzNlMjUwYjQxYTg5MTU3NTc6OmgzYjMxOGIxOGQ4ZjI4YmJiA1Vqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfb2Zmc2V0OjpfX3diZ19ieXRlT2Zmc2V0XzQyMDRlY2IyNGE2ZTVkZjk6OmgwMWMwN2M5MTZkMGRhN2UxBExqc19zeXM6OlVpbnQ4QXJyYXk6OmJ1ZmZlcjo6X193YmdfYnVmZmVyX2ZhY2YwMzk4YTI4MWM4NWI6OmhhMDMyM2EyMGJlYTAwZDgwBXlqc19zeXM6OlVpbnQ4QXJyYXk6Om5ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGg6Ol9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoXzRiOWI4YzRlM2Y1YWRiZmY6OmhmMzFiMWFiYmIzYmMxM2JiBkxqc19zeXM6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzFlYjhmYzYwOGEwZDRjZGI6OmhkM2I3MTk5ZGY0ZDc4Y2NkBzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoODkyYTNjZGU4NGVhMTRmMQhVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5NGRkOjpoMGE4NmI1ZWRiYTIxM2ZkYQlGanNfc3lzOjpVaW50OEFycmF5OjpuZXc6Ol9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmOjpoNjlmMDc1YzAxMzBkYjhhNQpGanNfc3lzOjpVaW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwOjpoMTFiZWUxMTIxZTAxZjcyYgsxd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoZDc3NmVjZjQ0ZjhjNmFjNQxAZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0OjpoMTA1Y2Q2NGEwYzM2Y2QzZg0sc2hhMjo6c2hhNTEyOjpjb21wcmVzczUxMjo6aDZiMTBjMzNhZDA1YzM1ZjYOSmRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdF9hbmRfcmVzZXQ6OmhlMmUyZmI2YmI0Yzk4ZWZiD0BkZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0Ojp1cGRhdGU6OmhmZmY1NWRkZjM1M2YzOTVkECxzaGEyOjpzaGEyNTY6OmNvbXByZXNzMjU2OjpoZTg3ODAyOWNjZmRkM2RmNBEzYmxha2UyOjpCbGFrZTJiVmFyQ29yZTo6Y29tcHJlc3M6Omg5Zjg3YTc2YThmYmVlMjJiEilyaXBlbWQ6OmMxNjA6OmNvbXByZXNzOjpoMTg5YzQ3OWZiZDY3YWZhZBMzYmxha2UyOjpCbGFrZTJzVmFyQ29yZTo6Y29tcHJlc3M6Omg5ZGRhOWMyYTJiNjE3Njg5FCtzaGExOjpjb21wcmVzczo6Y29tcHJlc3M6Omg1MGU1ZDgzZTkxZDY1NGFhFTtkZW5vX3N0ZF93YXNtX2NyeXB0bzo6RGlnZXN0Q29udGV4dDo6bmV3OjpoOTM3MDI0OThjYjZjZDE4ORY6ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoMmEyNzIwN2VlOWFmN2ZlORcsdGlnZXI6OmNvbXByZXNzOjpjb21wcmVzczo6aDZkMjU4ZmJmNzU0OGJmZTEYLWJsYWtlMzo6T3V0cHV0UmVhZGVyOjpmaWxsOjpoYTljMjcwYzliN2ZmNDFlZRk2Ymxha2UzOjpwb3J0YWJsZTo6Y29tcHJlc3NfaW5fcGxhY2U6OmhjNGFkNzQ3N2NiZjUyZjBlGhNkaWdlc3Rjb250ZXh0X2Nsb25lG2U8ZGlnZXN0Ojpjb3JlX2FwaTo6d3JhcHBlcjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6Ont7Y2xvc3VyZX19OjpoNDcwNmQ4NDE5YmQwMjBiZBxoPG1kNTo6TWQ1Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjp7e2Nsb3N1cmV9fTo6aDIyZmYyYTYxYmVlOGQxMjEdMGJsYWtlMzo6Y29tcHJlc3Nfc3VidHJlZV93aWRlOjpoOTk1ZjkyYTA5OWQ5ODYzNB44ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZnJlZTo6aGNiNzk0N2E5YTdlMjgyY2EfIG1kNDo6Y29tcHJlc3M6Omg5MGQ1NDAzNmNhNjMzZTNjIEFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3NlX2NodW5rOjpoMmY5MGJkZGZhYjlmZGFmOSETZGlnZXN0Y29udGV4dF9yZXNldCJyPHNoYTI6OmNvcmVfYXBpOjpTaGE1MTJWYXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OlZhcmlhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3ZhcmlhYmxlX2NvcmU6Omg5ZWE0YTIxNThlMDcwMzNiIy9ibGFrZTM6Okhhc2hlcjo6ZmluYWxpemVfeG9mOjpoYjg4M2U2YzVjNGU1ZDQwYiQga2VjY2FrOjpmMTYwMDo6aGE4MjU3OTBjZjI1YTVmNWUlLGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWQ6Omg0OWQyY2ZjY2FmYmJkZTRkJg5fX3J1c3RfcmVhbGxvYydyPHNoYTI6OmNvcmVfYXBpOjpTaGEyNTZWYXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OlZhcmlhYmxlT3V0cHV0Q29yZT46OmZpbmFsaXplX3ZhcmlhYmxlX2NvcmU6OmgwM2E5MzBiOGM3NGM5ZWQ1KF08c2hhMTo6U2hhMUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGI1ZDllYzcwMjQ4ZTE4MjApMWJsYWtlMzo6SGFzaGVyOjptZXJnZV9jdl9zdGFjazo6aDQ3YjZlMjRlNjdlMjE2NWIqNWNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OmhjNjY5NDdiMWRlZDU3OGFhKyNjb3JlOjpmbXQ6OndyaXRlOjpoYmJhZjM5ZjA5YmY0OWVmYiw0Ymxha2UzOjpjb21wcmVzc19wYXJlbnRzX3BhcmFsbGVsOjpoYTA3MzJmYWNiMTI3NjliYi1kPHJpcGVtZDo6UmlwZW1kMTYwQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoZGU4ZmMyYWY3MTFmMTg1Zi5bPG1kNTo6TWQ1Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMGIzMDAzZTQ4NDI5YWMzZC9bPG1kNDo6TWQ0Q29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoM2UyYjMwMDczMGFhOGFmMDBfPHRpZ2VyOjpUaWdlckNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDQ1NzNhNDBlYmM1NGNhNTMxMGRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoMTg5ZmJjYTAzNzNhYjgyODJlPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aDY2ZWNhYWJkY2FlNWI2YzkzZTxkaWdlc3Q6OmNvcmVfYXBpOjp4b2ZfcmVhZGVyOjpYb2ZSZWFkZXJDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlhvZlJlYWRlcj46OnJlYWQ6OmgxMTUwZDlhNGM1NDUyNmQ5NC1ibGFrZTM6OkNodW5rU3RhdGU6OnVwZGF0ZTo6aGM1ODhhOGNkN2MyNmNlZjU1L2NvcmU6OmZtdDo6bnVtOjppbXA6OmZtdF91NjQ6Omg2NjI4YTNlNzIyN2U4NTUzNgZkaWdlc3Q3PmRlbm9fc3RkX3dhc21fY3J5cHRvOjpEaWdlc3RDb250ZXh0Ojp1cGRhdGU6OmgyNGY5YmIzMWIwYzliNzkwOFs8YmxvY2tfYnVmZmVyOjpCbG9ja0J1ZmZlcjxCbG9ja1NpemUsS2luZD4gYXMgY29yZTo6Y2xvbmU6OkNsb25lPjo6Y2xvbmU6OmhhY2M4MzRjMmE0MDExODhmORtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZERyb3A6Bm1lbWNweTsGbWVtc2V0PD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDdmYjEyNTEyZTA3YmQxZjc9EWRpZ2VzdGNvbnRleHRfbmV3PhRkaWdlc3Rjb250ZXh0X2RpZ2VzdD8tanNfc3lzOjpVaW50OEFycmF5Ojp0b192ZWM6OmhmY2JiMjgxYTc0OTMwNTIwQBxkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZFJlc2V0QS5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6OmhkNTg0ZWZiN2I4NGJmMzI2QlA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOGNhMzY5Yzk4MTBjMjIyOUNQPGFycmF5dmVjOjplcnJvcnM6OkNhcGFjaXR5RXJyb3I8VD4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGFiZDJiNjQzZGQwZWNkMmNEWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDY5YTI5MTg4MDk5ZmFkODhFWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aGI0ZTUyZDAzNjFkZGNiODlGWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDBhZTg3YmU0ZmQxOWZiZjRHWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDViYjE1ZmNkMjdhMTg1ZGZIWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDczZWIxMzRhMzI4NzVmZjdJWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDNlYzIzYzc3ODMwZDM2NjRKP2NvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfZW5kX2luZGV4X2xlbl9mYWlsOjpoYzNlMGRjZjZkODY2ZTFiZUtBY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aDZjMTA5YWM4NTg3ZjI5MTFMPWNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfaW5kZXhfb3JkZXJfZmFpbDo6aGQyN2RjMzg1YTdlYzEzYzFNTmNvcmU6OnNsaWNlOjo8aW1wbCBbVF0+Ojpjb3B5X2Zyb21fc2xpY2U6Omxlbl9taXNtYXRjaF9mYWlsOjpoZWRkMTBjNWJjYzAyNjEwY042Y29yZTo6cGFuaWNraW5nOjpwYW5pY19ib3VuZHNfY2hlY2s6OmhjZTA1MDJmNjM3MTFmYWQ4TzdzdGQ6OnBhbmlja2luZzo6cnVzdF9wYW5pY193aXRoX2hvb2s6Omg2MDZkN2M3ZjdhNDIzYjk4UDpibGFrZTI6OkJsYWtlMmJWYXJDb3JlOjpuZXdfd2l0aF9wYXJhbXM6Omg1ODdmOWE3Mjc5ZjM3MTZkURhfX3diZ19kaWdlc3Rjb250ZXh0X2ZyZWVSBm1lbWNtcFNDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6d3JpdGVfcHJlZml4OjpoYWEwYWRmMDBjYjY3ZGVkN1QpY29yZTo6cGFuaWNraW5nOjpwYW5pYzo6aGVjMWZjMDU3YmQwYmFmMGJVFGRpZ2VzdGNvbnRleHRfdXBkYXRlVhFfX3diaW5kZ2VuX21hbGxvY1c6Ymxha2UyOjpCbGFrZTJzVmFyQ29yZTo6bmV3X3dpdGhfcGFyYW1zOjpoNWZmNDU5ZjIzMWFiOGQ2OFgtY29yZTo6cGFuaWNraW5nOjpwYW5pY19mbXQ6Omg2MzE0YjVjOTFhYmU3MzQ5WT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2U0X211dDo6aDNhOTBmNjIyOGY4N2JmMmFaP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZjcyNTE0MTM3YzU4YjI1NFs/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzYzEzN2VhOTQ0ZThjNmMyXD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGIyMDMyZTIyODg3NGRlMTJdP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoNDU3ZmQ2MjZhOTdmMzIzZV4/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgyOTIwY2MxM2U4ODkwMjAzXz93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDQ3ZGFkYjQ0N2Q3NjlmODVgP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoYjY5NTY1MWUxNWRhMzk4N2E/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMl9tdXQ6Omg1ODZiMzZlNDY0NDIyY2Q0YkNzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6e3tjbG9zdXJlfX06Omg5Yjk4NWEyOTNhYWM0Y2UxYxJfX3diaW5kZ2VuX3JlYWxsb2NkP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTFfbXV0OjpoZGIzMDcxOWY5NDI1NTZlN2UyY29yZTo6b3B0aW9uOjpPcHRpb248VD46OnVud3JhcDo6aDVhN2RmOTFiNWQ2MDkwY2JmMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMGQ5Y2Q2MjZkYWJhYTFlZmcyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGQzMDNiYzE2YWVlNTU5MTBoEXJ1c3RfYmVnaW5fdW53aW5kaQ9fX3diaW5kZ2VuX2ZyZWVqNGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDRiNDkwMTQ4MzBjYWZlNjNrM2FycmF5dmVjOjphcnJheXZlYzo6ZXh0ZW5kX3BhbmljOjpoMzdkNTk4ZDc1ZDBkMmU2Zmw5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6OmgyYWI4Njc2N2VjMTdjNTBkbR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVybk5jb3JlOjpmbXQ6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIHUzMj46OmZtdDo6aDA0NmVjYzVlYWFiMzRjZDVvMXdhc21fYmluZGdlbjo6X19ydDo6dGhyb3dfbnVsbDo6aGQyZjhkMzcwNzBlOWNhYjRwMndhc21fYmluZGdlbjo6X19ydDo6Ym9ycm93X2ZhaWw6OmhkNDdlYTRlMzA4NDZkMzA5cSp3YXNtX2JpbmRnZW46OnRocm93X3N0cjo6aDgwMzQ3MGFlNWVmYmIzNzlySXN0ZDo6c3lzX2NvbW1vbjo6YmFja3RyYWNlOjpfX3J1c3RfZW5kX3Nob3J0X2JhY2t0cmFjZTo6aGEwM2FiZWYwMmE4YjcwZmRzMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGEwYzQ0OTIyMTZkNGQyZTd0CnJ1c3RfcGFuaWN1N3N0ZDo6YWxsb2M6OmRlZmF1bHRfYWxsb2NfZXJyb3JfaG9vazo6aGY5YzM5M2JhM2NkMjg3ZTF2b2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmY29yZTo6aXRlcjo6YWRhcHRlcnM6OmNvcGllZDo6Q29waWVkPGNvcmU6OnNsaWNlOjppdGVyOjpJdGVyPHU4Pj4+OjpoNjNjMmUxNDk3YjUyZjNkNwD7gICAAAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNTcuMCAoZjFlZGQwNDI5IDIwMjEtMTEtMjkpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuEjAuMi44MCAoOWE2ZTc3ZjVlKQ==");
  const wasmModule = new WebAssembly.Module(wasmBytes);
  return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
var digestAlgorithms = [
  "BLAKE2B-256",
  "BLAKE2B-384",
  "BLAKE2B",
  "BLAKE2S",
  "BLAKE3",
  "KECCAK-224",
  "KECCAK-256",
  "KECCAK-384",
  "KECCAK-512",
  "SHA-384",
  "SHA3-224",
  "SHA3-256",
  "SHA3-384",
  "SHA3-512",
  "SHAKE128",
  "SHAKE256",
  "TIGER",
  "RIPEMD-160",
  "SHA-224",
  "SHA-256",
  "SHA-512",
  "MD4",
  "MD5",
  "SHA-1"
];
function _uint8ArrayToBuffer(chunk) {
  return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function _arch() {
  if (Deno.build.arch == "x86_64") {
    return "x64";
  } else if (Deno.build.arch == "aarch64") {
    return "arm64";
  } else {
    throw Error("unreachable");
  }
}
var arch = _arch();
var chdir = Deno.chdir;
var cwd = Deno.cwd;
var nextTick2 = nextTick1;
var env = new Proxy({}, {
  get(_target, prop) {
    return Deno.env.get(String(prop));
  },
  ownKeys: () => Reflect.ownKeys(Deno.env.toObject()),
  getOwnPropertyDescriptor: (_target, name) => {
    const e = Deno.env.toObject();
    if (name in Deno.env.toObject()) {
      const o6 = {
        enumerable: true,
        configurable: true
      };
      if (typeof name === "string") {
        o6.value = e[name];
      }
      return o6;
    }
  },
  set(_target, prop, value) {
    Deno.env.set(String(prop), String(value));
    return value;
  }
});
var pid = Deno.pid;
var platform = isWindows ? "win32" : Deno.build.os;
var version = "v16.11.1";
var versions = {
  node: "16.11.1",
  uv: "1.42.0",
  zlib: "1.2.11",
  brotli: "1.0.9",
  ares: "1.17.2",
  modules: "93",
  nghttp2: "1.45.1",
  napi: "8",
  llhttp: "6.0.4",
  openssl: "1.1.1l",
  cldr: "39.0",
  icu: "69.1",
  tz: "2021a",
  unicode: "13.0",
  ...Deno.version
};
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
  return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
  return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
  return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
  if (stream.writableFinished)
    return true;
  const wState = stream._writableState;
  if (!wState || wState.errored)
    return false;
  return wState.finished || wState.ended && wState.length === 0;
}
var nop = () => {
};
function isReadableEnded(stream) {
  if (stream.readableEnded)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  } else if (options == null) {
    options = {};
  } else {
    validateObject(options, "options");
  }
  validateFunction(callback, "callback");
  validateAbortSignal(options.signal, "options.signal");
  callback = once(callback);
  const readable = options.readable || options.readable !== false && isReadable(stream);
  const writable = options.writable || options.writable !== false && isWritable(stream);
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  const onlegacyfinish = () => {
    if (!stream.writable)
      onfinish();
  };
  let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
  let writableFinished = stream.writableFinished || wState && wState.finished;
  const onfinish = () => {
    writableFinished = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.readable || readable))
      return;
    if (!readable || readableEnded)
      callback.call(stream);
  };
  let readableEnded = stream.readableEnded || rState && rState.endEmitted;
  const onend = () => {
    readableEnded = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.writable || writable))
      return;
    if (!writable || writableFinished)
      callback.call(stream);
  };
  const onerror = (err) => {
    callback.call(stream, err);
  };
  const onclose = () => {
    if (readable && !readableEnded) {
      if (!isReadableEnded(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    callback.call(stream);
  };
  const onrequest = () => {
    stream.req.on("finish", onfinish);
  };
  if (isRequest(stream)) {
    stream.on("complete", onfinish);
    if (!willEmitClose) {
      stream.on("abort", onclose);
    }
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !wState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  if (!willEmitClose && typeof stream.aborted === "boolean") {
    stream.on("aborted", onclose);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (options.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
  if (closed) {
    nextTick1(() => {
      callback();
    });
  }
  const cleanup = () => {
    callback = nop;
    stream.removeListener("aborted", onclose);
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
  if (options.signal && !closed) {
    const abort = () => {
      const endCallback = callback;
      cleanup();
      endCallback.call(stream, new AbortError());
    };
    if (options.signal.aborted) {
      nextTick1(abort);
    } else {
      const originalCallback = callback;
      callback = once((...args) => {
        options.signal.removeEventListener("abort", abort);
        originalCallback.apply(stream, args);
      });
      options.signal.addEventListener("abort", abort);
    }
  }
  return cleanup;
}
var validateAbortSignal1 = (signal, name) => {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
};
function isStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function");
}
function addAbortSignal(signal, stream) {
  validateAbortSignal1(signal, "signal");
  if (!isStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
  }
  return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    return stream;
  }
  const onAbort = () => {
    stream.destroy(new AbortError());
  };
  if (signal.aborted) {
    onAbort();
  } else {
    signal.addEventListener("abort", onAbort);
    eos(stream, () => signal.removeEventListener("abort", onAbort));
  }
  return stream;
}
var kDestroy = Symbol("kDestroy");
var kConstruct = Symbol("kConstruct");
function checkError(err, w24, r2) {
  if (err) {
    err.stack;
    if (w24 && !w24.errored) {
      w24.errored = err;
    }
    if (r2 && !r2.errored) {
      r2.errored = err;
    }
  }
}
function destroy1(err, cb) {
  const r2 = this._readableState;
  const w24 = this._writableState;
  const s10 = w24 || r2;
  if (w24 && w24.destroyed || r2 && r2.destroyed) {
    if (typeof cb === "function") {
      cb();
    }
    return this;
  }
  checkError(err, w24, r2);
  if (w24) {
    w24.destroyed = true;
  }
  if (r2) {
    r2.destroyed = true;
  }
  if (!s10.constructed) {
    this.once(kDestroy, function(er2) {
      _destroy(this, aggregateTwoErrors(er2, err), cb);
    });
  } else {
    _destroy(this, err, cb);
  }
  return this;
}
function _destroy(self1, err, cb) {
  let called = false;
  function onDestroy(err2) {
    if (called) {
      return;
    }
    called = true;
    const r2 = self1._readableState;
    const w24 = self1._writableState;
    checkError(err2, w24, r2);
    if (w24) {
      w24.closed = true;
    }
    if (r2) {
      r2.closed = true;
    }
    if (typeof cb === "function") {
      cb(err2);
    }
    if (err2) {
      nextTick1(emitErrorCloseNT, self1, err2);
    } else {
      nextTick1(emitCloseNT, self1);
    }
  }
  try {
    const result = self1._destroy(err || null, onDestroy);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick1(onDestroy, null);
        }, function(err2) {
          nextTick1(onDestroy, err2);
        });
      }
    }
  } catch (err1) {
    onDestroy(err1);
  }
}
function emitErrorCloseNT(self1, err) {
  emitErrorNT(self1, err);
  emitCloseNT(self1);
}
function emitCloseNT(self1) {
  const r2 = self1._readableState;
  const w24 = self1._writableState;
  if (w24) {
    w24.closeEmitted = true;
  }
  if (r2) {
    r2.closeEmitted = true;
  }
  if (w24 && w24.emitClose || r2 && r2.emitClose) {
    self1.emit("close");
  }
}
function emitErrorNT(self1, err) {
  const r2 = self1._readableState;
  const w24 = self1._writableState;
  if (w24 && w24.errorEmitted || r2 && r2.errorEmitted) {
    return;
  }
  if (w24) {
    w24.errorEmitted = true;
  }
  if (r2) {
    r2.errorEmitted = true;
  }
  self1.emit("error", err);
}
function undestroy() {
  const r2 = this._readableState;
  const w24 = this._writableState;
  if (r2) {
    r2.constructed = true;
    r2.closed = false;
    r2.closeEmitted = false;
    r2.destroyed = false;
    r2.errored = null;
    r2.errorEmitted = false;
    r2.reading = false;
    r2.ended = false;
    r2.endEmitted = false;
  }
  if (w24) {
    w24.constructed = true;
    w24.destroyed = false;
    w24.closed = false;
    w24.closeEmitted = false;
    w24.errored = null;
    w24.errorEmitted = false;
    w24.ended = false;
    w24.ending = false;
    w24.finalCalled = false;
    w24.prefinished = false;
    w24.finished = false;
  }
}
function errorOrDestroy(stream, err, sync) {
  const r2 = stream._readableState;
  const w24 = stream._writableState;
  if (w24 && w24.destroyed || r2 && r2.destroyed) {
    return this;
  }
  if (r2 && r2.autoDestroy || w24 && w24.autoDestroy) {
    stream.destroy(err);
  } else if (err) {
    err.stack;
    if (w24 && !w24.errored) {
      w24.errored = err;
    }
    if (r2 && !r2.errored) {
      r2.errored = err;
    }
    if (sync) {
      nextTick1(emitErrorNT, stream, err);
    } else {
      emitErrorNT(stream, err);
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== "function") {
    return;
  }
  const r2 = stream._readableState;
  const w24 = stream._writableState;
  if (r2) {
    r2.constructed = false;
  }
  if (w24) {
    w24.constructed = false;
  }
  stream.once(kConstruct, cb);
  if (stream.listenerCount(kConstruct) > 1) {
    return;
  }
  nextTick1(constructNT, stream);
}
function constructNT(stream) {
  let called = false;
  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    const r2 = stream._readableState;
    const w24 = stream._writableState;
    const s10 = w24 || r2;
    if (r2) {
      r2.constructed = true;
    }
    if (w24) {
      w24.constructed = true;
    }
    if (s10.destroyed) {
      stream.emit(kDestroy, err);
    } else if (err) {
      errorOrDestroy(stream, err, true);
    } else {
      nextTick1(emitConstructNT, stream);
    }
  }
  try {
    const result = stream._construct(onConstruct);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick1(onConstruct, null);
        }, function(err) {
          nextTick1(onConstruct, err);
        });
      }
    }
  } catch (err) {
    onConstruct(err);
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct);
}
function isRequest1(stream) {
  return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
  if (!stream)
    return;
  if (isRequest1(stream))
    return stream.abort();
  if (isRequest1(stream.req))
    return stream.req.abort();
  if (typeof stream.destroy === "function")
    return stream.destroy(err);
  if (typeof stream.close === "function")
    return stream.close();
}
var __default3 = {
  construct,
  destroyer,
  destroy: destroy1,
  undestroy,
  errorOrDestroy
};
var kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function" && typeof obj2.on === "function" && (!obj2._writableState || obj2._readableState?.readable !== false) && (!obj2._writableState || obj2._readableState));
}
function isWritableNodeStream(obj2) {
  return !!(obj2 && typeof obj2.write === "function" && typeof obj2.on === "function" && (!obj2._readableState || obj2._writableState?.writable !== false));
}
function isDuplexNodeStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function" && obj2._readableState && typeof obj2.on === "function" && typeof obj2.write === "function");
}
function isNodeStream(obj2) {
  return obj2 && (obj2._readableState || obj2._writableState || typeof obj2.write === "function" && typeof obj2.on === "function" || typeof obj2.pipe === "function" && typeof obj2.on === "function");
}
function isIterable(obj2, isAsync) {
  if (obj2 == null)
    return false;
  if (isAsync === true)
    return typeof obj2[Symbol.asyncIterator] === "function";
  if (isAsync === false)
    return typeof obj2[Symbol.iterator] === "function";
  return typeof obj2[Symbol.asyncIterator] === "function" || typeof obj2[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
  if (!isNodeStream(stream))
    return null;
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream))
    return null;
  if (stream.writableEnded === true)
    return true;
  const wState = stream._writableState;
  if (wState?.errored)
    return false;
  if (typeof wState?.ended !== "boolean")
    return null;
  return wState.ended;
}
function isReadableEnded1(stream) {
  if (!isReadableNodeStream(stream))
    return null;
  if (stream.readableEnded === true)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  if (typeof rState?.ended !== "boolean")
    return null;
  return rState.ended;
}
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream))
    return null;
  const rState = stream._readableState;
  if (rState?.errored)
    return false;
  if (typeof rState?.endEmitted !== "boolean")
    return null;
  return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
  return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
  const r2 = isReadableNodeStream(stream);
  if (r2 === null || typeof stream?.readable !== "boolean")
    return null;
  if (isDestroyed(stream))
    return false;
  return r2 && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
  const r2 = isWritableNodeStream(stream);
  if (r2 === null || typeof stream?.writable !== "boolean")
    return null;
  if (isDestroyed(stream))
    return false;
  return r2 && stream.writable && !isWritableEnded(stream);
}
var stdio = {};
function isBlob(object) {
  return object instanceof Blob;
}
function _from1(Readable2, iterable, opts) {
  let iterator;
  if (typeof iterable === "string" || iterable instanceof Buffer2) {
    return new Readable2({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable);
        this.push(null);
      }
    });
  }
  let isAsync;
  if (iterable && iterable[Symbol.asyncIterator]) {
    isAsync = true;
    iterator = iterable[Symbol.asyncIterator]();
  } else if (iterable && iterable[Symbol.iterator]) {
    isAsync = false;
    iterator = iterable[Symbol.iterator]();
  } else {
    throw new ERR_INVALID_ARG_TYPE("iterable", [
      "Iterable"
    ], iterable);
  }
  const readable = new Readable2({
    objectMode: true,
    highWaterMark: 1,
    ...opts
  });
  let reading = false;
  readable._read = function() {
    if (!reading) {
      reading = true;
      next();
    }
  };
  readable._destroy = function(error2, cb) {
    close(error2).then(() => nextTick2(cb, error2), (e) => nextTick2(cb, e || error2));
  };
  async function close(error2) {
    const hadError = error2 !== void 0 && error2 !== null;
    const hasThrow = typeof iterator.throw === "function";
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error2);
      await value;
      if (done) {
        return;
      }
    }
    if (typeof iterator.return === "function") {
      const { value: value1 } = await iterator.return();
      await value1;
    }
  }
  async function next() {
    for (; ; ) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next();
        if (done) {
          readable.push(null);
        } else {
          const res = value && typeof value.then === "function" ? await value : value;
          if (res === null) {
            reading = false;
            throw new ERR_STREAM_NULL_VALUES();
          } else if (readable.push(res)) {
            continue;
          } else {
            reading = false;
          }
        }
      } catch (err) {
        readable.destroy(err);
      }
      break;
    }
  }
  return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!Number.isInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
      throw new ERR_INVALID_ARG_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return getDefaultHighWaterMark(state.objectMode);
}
var kRejection = Symbol.for("nodejs.rejection");
var kCapture = Symbol("kCapture");
var kErrorMonitor = Symbol("events.errorMonitor");
var kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
var kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
  get() {
    return EventEmitter.prototype[kCapture];
  },
  set(value) {
    validateBoolean(value, "EventEmitter.captureRejections");
    EventEmitter.prototype[kCapture] = value;
  },
  enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
  value: false,
  writable: true,
  enumerable: false
});
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
      throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
    }
    defaultMaxListeners = arg;
  }
});
Object.defineProperties(EventEmitter, {
  kMaxEventTargetListeners: {
    value: kMaxEventTargetListeners,
    enumerable: false,
    configurable: false,
    writable: false
  },
  kMaxEventTargetListenersWarned: {
    value: kMaxEventTargetListenersWarned,
    enumerable: false,
    configurable: false,
    writable: false
  }
});
EventEmitter.setMaxListeners = function(n3 = defaultMaxListeners, ...eventTargets) {
  if (typeof n3 !== "number" || n3 < 0 || Number.isNaN(n3)) {
    throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n3);
  }
  if (eventTargets.length === 0) {
    defaultMaxListeners = n3;
  } else {
    for (let i = 0; i < eventTargets.length; i++) {
      const target = eventTargets[i];
      if (target instanceof EventTarget) {
        target[kMaxEventTargetListeners] = n3;
        target[kMaxEventTargetListenersWarned] = false;
      } else if (typeof target.setMaxListeners === "function") {
        target.setMaxListeners(n3);
      } else {
        throw new ERR_INVALID_ARG_TYPE("eventTargets", [
          "EventEmitter",
          "EventTarget"
        ], target);
      }
    }
  }
};
EventEmitter.init = function(opts) {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
  if (opts?.captureRejections) {
    validateBoolean(opts.captureRejections, "options.captureRejections");
    this[kCapture] = Boolean(opts.captureRejections);
  } else {
    this[kCapture] = EventEmitter.prototype[kCapture];
  }
};
function addCatch(that, promise, type, args) {
  if (!that[kCapture]) {
    return;
  }
  try {
    const then = promise.then;
    if (typeof then === "function") {
      then.call(promise, void 0, function(err) {
        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
      });
    }
  } catch (err) {
    that.emit("error", err);
  }
}
function emitUnhandledRejectionOrErr(ee2, err, type, args) {
  if (typeof ee2[kRejection] === "function") {
    ee2[kRejection](err, type, ...args);
  } else {
    const prev = ee2[kCapture];
    try {
      ee2[kCapture] = false;
      ee2.emit("error", err);
    } finally {
      ee2[kCapture] = prev;
    }
  }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n3) {
  if (typeof n3 !== "number" || n3 < 0 || Number.isNaN(n3)) {
    throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n3);
  }
  this._maxListeners = n3;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0) {
    return EventEmitter.defaultMaxListeners;
  }
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
  let doError = type === "error";
  const events = this._events;
  if (events !== void 0) {
    if (doError && events[kErrorMonitor] !== void 0) {
      this.emit(kErrorMonitor, ...args);
    }
    doError = doError && events.error === void 0;
  } else if (!doError) {
    return false;
  }
  if (doError) {
    let er2;
    if (args.length > 0) {
      er2 = args[0];
    }
    if (er2 instanceof Error) {
      try {
        const capture = {};
        Error.captureStackTrace(capture, EventEmitter.prototype.emit);
      } catch {
      }
      throw er2;
    }
    let stringifiedEr;
    try {
      stringifiedEr = inspect2(er2);
    } catch {
      stringifiedEr = er2;
    }
    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
    err.context = er2;
    throw err;
  }
  const handler = events[type];
  if (handler === void 0) {
    return false;
  }
  if (typeof handler === "function") {
    const result = handler.apply(this, args);
    if (result !== void 0 && result !== null) {
      addCatch(this, result, type, args);
    }
  } else {
    const len = handler.length;
    const listeners3 = arrayClone(handler);
    for (let i = 0; i < len; ++i) {
      const result1 = listeners3[i].apply(this, args);
      if (result1 !== void 0 && result1 !== null) {
        addCatch(this, result1, type, args);
      }
    }
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  let m20;
  let events;
  let existing;
  checkListener(listener);
  events = target._events;
  if (events === void 0) {
    events = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ?? listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === void 0) {
    events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [
        listener,
        existing
      ] : [
        existing,
        listener
      ];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m20 = _getMaxListeners(target);
    if (m20 > 0 && existing.length > m20 && !existing.warned) {
      existing.warned = true;
      const w24 = new Error(`Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners added to ${inspect2(target, {
        depth: -1
      })}. Use emitter.setMaxListeners() to increase limit`);
      w24.name = "MaxListenersExceededWarning";
      w24.emitter = target;
      w24.type = type;
      w24.count = existing.length;
      process.emitWarning(w24);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) {
      return this.listener.call(this.target);
    }
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  const state = {
    fired: false,
    wrapFn: void 0,
    target,
    type,
    listener
  };
  const wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  checkListener(listener);
  const events = this._events;
  if (events === void 0) {
    return this;
  }
  const list = events[type];
  if (list === void 0) {
    return this;
  }
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
    } else {
      delete events[type];
      if (events.removeListener) {
        this.emit("removeListener", type, list.listener || listener);
      }
    }
  } else if (typeof list !== "function") {
    let position = -1;
    for (let i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        position = i;
        break;
      }
    }
    if (position < 0) {
      return this;
    }
    if (position === 0) {
      list.shift();
    } else {
      spliceOne(list, position);
    }
    if (list.length === 1) {
      events[type] = list[0];
    }
    if (events.removeListener !== void 0) {
      this.emit("removeListener", type, listener);
    }
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  const events = this._events;
  if (events === void 0) {
    return this;
  }
  if (events.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== void 0) {
      if (--this._eventsCount === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
      } else {
        delete events[type];
      }
    }
    return this;
  }
  if (arguments.length === 0) {
    for (const key2 of Reflect.ownKeys(events)) {
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  const listeners3 = events[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3 !== void 0) {
    for (let i = listeners3.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners3[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  const events = target._events;
  if (events === void 0) {
    return [];
  }
  const evlistener = events[type];
  if (evlistener === void 0) {
    return [];
  }
  if (typeof evlistener === "function") {
    return unwrap ? [
      evlistener.listener || evlistener
    ] : [
      evlistener
    ];
  }
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  }
  return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  const events = this._events;
  if (events !== void 0) {
    const evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
  switch (arr.length) {
    case 2:
      return [
        arr[0],
        arr[1]
      ];
    case 3:
      return [
        arr[0],
        arr[1],
        arr[2]
      ];
    case 4:
      return [
        arr[0],
        arr[1],
        arr[2],
        arr[3]
      ];
    case 5:
      return [
        arr[0],
        arr[1],
        arr[2],
        arr[3],
        arr[4]
      ];
    case 6:
      return [
        arr[0],
        arr[1],
        arr[2],
        arr[3],
        arr[4],
        arr[5]
      ];
  }
  return arr.slice();
}
function unwrapListeners(arr) {
  const ret = arrayClone(arr);
  for (let i = 0; i < ret.length; ++i) {
    const orig = ret[i].listener;
    if (typeof orig === "function") {
      ret[i] = orig;
    }
  }
  return ret;
}
function getEventListeners(emitterOrTarget, type) {
  if (typeof emitterOrTarget.listeners === "function") {
    return emitterOrTarget.listeners(type);
  }
  if (emitterOrTarget instanceof EventTarget) {
    const root = emitterOrTarget[kEvents].get(type);
    const listeners3 = [];
    let handler = root?.next;
    while (handler?.listener !== void 0) {
      const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
      listeners3.push(listener);
      handler = handler.next;
    }
    return listeners3;
  }
  throw new ERR_INVALID_ARG_TYPE("emitter", [
    "EventEmitter",
    "EventTarget"
  ], emitterOrTarget);
}
async function once1(emitter, name, options = {}) {
  const signal = options?.signal;
  validateAbortSignal(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError();
  }
  return new Promise((resolve9, reject) => {
    const errorListener = (err) => {
      emitter.removeListener(name, resolver);
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      }
      reject(err);
    };
    const resolver = (...args) => {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      }
      resolve9(args);
    };
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== "error" && typeof emitter.once === "function") {
      emitter.once("error", errorListener);
    }
    function abortListener() {
      eventTargetAgnosticRemoveListener(emitter, name, resolver);
      eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
      reject(new AbortError());
    }
    if (signal != null) {
      eventTargetAgnosticAddListener(signal, "abort", abortListener, {
        once: true
      });
    }
  });
}
var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}).prototype);
function createIterResult(value, done) {
  return {
    value,
    done
  };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function") {
    emitter.removeListener(name, listener);
  } else if (typeof emitter.removeEventListener === "function") {
    emitter.removeEventListener(name, listener, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags?.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, (arg) => {
      listener(arg);
    }, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
  }
}
function on(emitter, event, options) {
  const signal = options?.signal;
  validateAbortSignal(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError();
  }
  const unconsumedEvents = [];
  const unconsumedPromises = [];
  let error2 = null;
  let finished2 = false;
  const iterator = Object.setPrototypeOf({
    next() {
      const value = unconsumedEvents.shift();
      if (value) {
        return Promise.resolve(createIterResult(value, false));
      }
      if (error2) {
        const p7 = Promise.reject(error2);
        error2 = null;
        return p7;
      }
      if (finished2) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      return new Promise(function(resolve9, reject) {
        unconsumedPromises.push({
          resolve: resolve9,
          reject
        });
      });
    },
    return() {
      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
      if (signal) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
          once: true
        });
      }
      finished2 = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return Promise.resolve(createIterResult(void 0, true));
    },
    throw(err) {
      if (!err || !(err instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
      }
      error2 = err;
      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  }, AsyncIteratorPrototype);
  eventTargetAgnosticAddListener(emitter, event, eventHandler);
  if (event !== "error" && typeof emitter.on === "function") {
    emitter.on("error", errorHandler);
  }
  if (signal) {
    eventTargetAgnosticAddListener(signal, "abort", abortListener, {
      once: true
    });
  }
  return iterator;
  function abortListener() {
    errorHandler(new AbortError());
  }
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEvents.push(args);
    }
  }
  function errorHandler(err) {
    finished2 = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error2 = err;
    }
    iterator.return();
  }
}
function Stream(opts) {
  EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
  const source = this;
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause();
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  let didOnEnd = false;
  function onend() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er2) {
    cleanup();
    if (EventEmitter.listenerCount(this, "error") === 0) {
      this.emit("error", er2);
    }
  }
  prependListener2(source, "error", onerror);
  prependListener2(dest, "error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  }
  if (!emitter._events || !emitter._events[event]) {
    emitter.on(event, fn);
  } else if (Array.isArray(emitter._events[event])) {
    emitter._events[event].unshift(fn);
  } else {
    emitter._events[event] = [
      fn,
      emitter._events[event]
    ];
  }
}
var NotImplemented;
(function(NotImplemented2) {
  NotImplemented2[NotImplemented2["ascii"] = 0] = "ascii";
  NotImplemented2[NotImplemented2["latin1"] = 1] = "latin1";
  NotImplemented2[NotImplemented2["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
  const encoding = normalizeEncoding1(enc ?? null);
  if (encoding && encoding in NotImplemented)
    notImplemented(encoding);
  if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
    throw new Error(`Unknown encoding: ${enc}`);
  }
  return String(encoding);
}
function utf8CheckByte(__byte) {
  if (__byte <= 127)
    return 0;
  else if (__byte >> 5 === 6)
    return 2;
  else if (__byte >> 4 === 14)
    return 3;
  else if (__byte >> 3 === 30)
    return 4;
  return __byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self1, buf, i) {
  let j13 = buf.length - 1;
  if (j13 < i)
    return 0;
  let nb = utf8CheckByte(buf[j13]);
  if (nb >= 0) {
    if (nb > 0)
      self1.lastNeed = nb - 1;
    return nb;
  }
  if (--j13 < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j13]);
  if (nb >= 0) {
    if (nb > 0)
      self1.lastNeed = nb - 2;
    return nb;
  }
  if (--j13 < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j13]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self1.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self1, buf) {
  if ((buf[0] & 192) !== 128) {
    self1.lastNeed = 0;
    return "\uFFFD";
  }
  if (self1.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self1.lastNeed = 1;
      return "\uFFFD";
    }
    if (self1.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self1.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}
function utf8FillLastComplete(buf) {
  const p7 = this.lastTotal - this.lastNeed;
  const r2 = utf8CheckExtraBytes(this, buf);
  if (r2 !== void 0)
    return r2;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p7, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p7, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
  const total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  const end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i, end);
}
function utf8End(buf) {
  const r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + "\uFFFD";
  return r2;
}
function utf8Write2(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  if (buf.length === 0)
    return "";
  let r2;
  let i;
  if (this.lastNeed) {
    r2 = this.fillLast(buf);
    if (r2 === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r2 ? r2 + this.text(buf, i) : this.text(buf, i);
  return r2 || "";
}
function base64Text(buf, i) {
  const n3 = (buf.length - i) % 3;
  if (n3 === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n3;
  this.lastTotal = 3;
  if (n3 === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n3);
}
function base64End(buf) {
  const r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  }
  return r2;
}
function simpleWrite(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var StringDecoderBase = class {
  lastChar;
  lastNeed;
  lastTotal;
  constructor(encoding, nb) {
    this.encoding = encoding;
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  encoding;
};
var Base64Decoder = class extends StringDecoderBase {
  end = base64End;
  fillLast = utf8FillLastIncomplete;
  text = base64Text;
  write = utf8Write2;
  constructor(encoding) {
    super(normalizeEncoding2(encoding), 3);
  }
};
var GenericDecoder = class extends StringDecoderBase {
  end = simpleEnd;
  fillLast = void 0;
  text = utf8Text;
  write = simpleWrite;
  constructor(encoding) {
    super(normalizeEncoding2(encoding), 4);
  }
};
var Utf8Decoder = class extends StringDecoderBase {
  end = utf8End;
  fillLast = utf8FillLastComplete;
  text = utf8Text;
  write = utf8Write2;
  constructor(encoding) {
    super(normalizeEncoding2(encoding), 4);
  }
};
var StringDecoder = class {
  encoding;
  end;
  fillLast;
  lastChar;
  lastNeed;
  lastTotal;
  text;
  write;
  constructor(encoding) {
    let decoder2;
    switch (encoding) {
      case "utf8":
        decoder2 = new Utf8Decoder(encoding);
        break;
      case "base64":
        decoder2 = new Base64Decoder(encoding);
        break;
      default:
        decoder2 = new GenericDecoder(encoding);
    }
    this.encoding = decoder2.encoding;
    this.end = decoder2.end;
    this.fillLast = decoder2.fillLast;
    this.lastChar = decoder2.lastChar;
    this.lastNeed = decoder2.lastNeed;
    this.lastTotal = decoder2.lastTotal;
    this.text = decoder2.text;
    this.write = decoder2.write;
  }
};
var PStringDecoder = new Proxy(StringDecoder, {
  apply(_target, thisArg, args) {
    return Object.assign(thisArg, new StringDecoder(...args));
  }
});
var __default4 = {
  StringDecoder: PStringDecoder
};
var BufferList = class {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(v19) {
    const entry = {
      data: v19,
      next: null
    };
    if (this.length > 0) {
      this.tail.next = entry;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    ++this.length;
  }
  unshift(v19) {
    const entry = {
      data: v19,
      next: this.head
    };
    if (this.length === 0) {
      this.tail = entry;
    }
    this.head = entry;
    ++this.length;
  }
  shift() {
    if (this.length === 0) {
      return;
    }
    const ret = this.head.data;
    if (this.length === 1) {
      this.head = this.tail = null;
    } else {
      this.head = this.head.next;
    }
    --this.length;
    return ret;
  }
  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }
  join(s10) {
    if (this.length === 0) {
      return "";
    }
    let p7 = this.head;
    let ret = "" + p7.data;
    while (p7 = p7.next) {
      ret += s10 + p7.data;
    }
    return ret;
  }
  concat(n3) {
    if (this.length === 0) {
      return Buffer2.alloc(0);
    }
    const ret = Buffer2.allocUnsafe(n3 >>> 0);
    let p7 = this.head;
    let i = 0;
    while (p7) {
      ret.set(p7.data, i);
      i += p7.data.length;
      p7 = p7.next;
    }
    return ret;
  }
  consume(n3, hasStrings) {
    const data = this.head.data;
    if (n3 < data.length) {
      const slice6 = data.slice(0, n3);
      this.head.data = data.slice(n3);
      return slice6;
    }
    if (n3 === data.length) {
      return this.shift();
    }
    return hasStrings ? this._getString(n3) : this._getBuffer(n3);
  }
  first() {
    return this.head.data;
  }
  *[Symbol.iterator]() {
    for (let p7 = this.head; p7; p7 = p7.next) {
      yield p7.data;
    }
  }
  _getString(n3) {
    let ret = "";
    let p7 = this.head;
    let c13 = 0;
    do {
      const str = p7.data;
      if (n3 > str.length) {
        ret += str;
        n3 -= str.length;
      } else {
        if (n3 === str.length) {
          ret += str;
          ++c13;
          if (p7.next) {
            this.head = p7.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret += str.slice(0, n3);
          this.head = p7;
          p7.data = str.slice(n3);
        }
        break;
      }
      ++c13;
    } while (p7 = p7.next);
    this.length -= c13;
    return ret;
  }
  _getBuffer(n3) {
    const ret = Buffer2.allocUnsafe(n3);
    const retLen = n3;
    let p7 = this.head;
    let c13 = 0;
    do {
      const buf = p7.data;
      if (n3 > buf.length) {
        ret.set(buf, retLen - n3);
        n3 -= buf.length;
      } else {
        if (n3 === buf.length) {
          ret.set(buf, retLen - n3);
          ++c13;
          if (p7.next) {
            this.head = p7.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), retLen - n3);
          this.head = p7;
          p7.data = buf.slice(n3);
        }
        break;
      }
      ++c13;
    } while (p7 = p7.next);
    this.length -= c13;
    return ret;
  }
  [inspect2.custom](_11, options) {
    return inspect2(this, {
      ...options,
      depth: 0,
      customInspect: false
    });
  }
};
var debug = debuglog("stream", (fn) => {
  debug = fn;
});
var kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
var nop1 = () => {
};
var { errorOrDestroy: errorOrDestroy1 } = __default3;
function ReadableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = stream instanceof Stream.Duplex;
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = [];
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.constructed = true;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this[kPaused] = null;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.destroyed = false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.awaitDrainWriters = null;
  this.multiAwaitDrain = false;
  this.readingMore = false;
  this.dataEmitted = false;
  this.decoder = null;
  this.encoding = null;
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  }
  const isDuplex = this instanceof Stream.Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);
  if (options) {
    if (typeof options.read === "function") {
      this._read = options.read;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal && !isDuplex) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  __default3.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState);
    }
  });
}
Readable.prototype.destroy = __default3.destroy;
Readable.prototype._undestroy = __default3.undestroy;
Readable.prototype._destroy = function(err, cb) {
  cb(err);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
  debug("readableAddChunk", chunk);
  const state = stream._readableState;
  let err;
  if (!state.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
        } else {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
      }
    } else if (chunk instanceof Buffer2) {
      encoding = "";
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk);
      encoding = "";
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
      ], chunk);
    }
  }
  if (err) {
    errorOrDestroy1(stream, err);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (addToFront) {
      if (state.endEmitted) {
        errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
      } else {
        addChunk(stream, state, chunk, true);
      }
    } else if (state.ended) {
      errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
    } else if (state.destroyed || state.errored) {
      return false;
    } else {
      state.reading = false;
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk);
        if (state.objectMode || chunk.length !== 0) {
          addChunk(stream, state, chunk, false);
        } else {
          maybeReadMore(stream, state);
        }
      } else {
        addChunk(stream, state, chunk, false);
      }
    }
  } else if (!addToFront) {
    state.reading = false;
    maybeReadMore(stream, state);
  }
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
    state.dataEmitted = true;
    stream.emit("data", chunk);
  } else {
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) {
      state.buffer.unshift(chunk);
    } else {
      state.buffer.push(chunk);
    }
    if (state.needReadable) {
      emitReadable(stream);
    }
  }
  maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
  const state = this._readableState;
  return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
  const decoder2 = new StringDecoder(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  const buffer = this._readableState.buffer;
  let content = "";
  for (const data of buffer) {
    content += decoder2.write(data);
  }
  buffer.clear();
  if (content !== "") {
    buffer.push(content);
  }
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n3) {
  if (n3 >= 1073741824) {
    n3 = MAX_HWM;
  } else {
    n3--;
    n3 |= n3 >>> 1;
    n3 |= n3 >>> 2;
    n3 |= n3 >>> 4;
    n3 |= n3 >>> 8;
    n3 |= n3 >>> 16;
    n3++;
  }
  return n3;
}
function howMuchToRead(n3, state) {
  if (n3 <= 0 || state.length === 0 && state.ended) {
    return 0;
  }
  if (state.objectMode) {
    return 1;
  }
  if (Number.isNaN(n3)) {
    if (state.flowing && state.length) {
      return state.buffer.first().length;
    }
    return state.length;
  }
  if (n3 <= state.length) {
    return n3;
  }
  return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n3) {
  debug("read", n3);
  if (n3 === void 0) {
    n3 = NaN;
  } else if (!Number.isInteger(n3)) {
    n3 = Number.parseInt(n3, 10);
  }
  const state = this._readableState;
  const nOrig = n3;
  if (n3 > state.highWaterMark) {
    state.highWaterMark = computeNewHighWaterMark(n3);
  }
  if (n3 !== 0) {
    state.emittedReadable = false;
  }
  if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended) {
      endReadable(this);
    } else {
      emitReadable(this);
    }
    return null;
  }
  n3 = howMuchToRead(n3, state);
  if (n3 === 0 && state.ended) {
    if (state.length === 0) {
      endReadable(this);
    }
    return null;
  }
  let doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n3 < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false;
    debug("reading, ended or constructing", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0) {
      state.needReadable = true;
    }
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading) {
      n3 = howMuchToRead(nOrig, state);
    }
  }
  let ret;
  if (n3 > 0) {
    ret = fromList(n3, state);
  } else {
    ret = null;
  }
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n3 = 0;
  } else {
    state.length -= n3;
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
  }
  if (state.length === 0) {
    if (!state.ended) {
      state.needReadable = true;
    }
    if (nOrig !== n3 && state.ended) {
      endReadable(this);
    }
  }
  if (ret !== null) {
    state.dataEmitted = true;
    this.emit("data", ret);
  }
  return ret;
};
function onEofChunk(stream, state) {
  debug("onEofChunk");
  if (state.ended)
    return;
  if (state.decoder) {
    const chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    emitReadable(stream);
  } else {
    state.needReadable = false;
    state.emittedReadable = true;
    emitReadable_(stream);
  }
}
function emitReadable(stream) {
  const state = stream._readableState;
  debug("emitReadable", state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    nextTick1(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  const state = stream._readableState;
  debug("emitReadable_", state.destroyed, state.length, state.ended);
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit("readable");
    state.emittedReadable = false;
  }
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true;
    nextTick1(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    const len = state.length;
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length) {
      break;
    }
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n3) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  const src = this;
  const state = this._readableState;
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true;
      state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [
        state.awaitDrainWriters
      ] : []);
    }
  }
  state.pipes.push(dest);
  debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
  const endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) {
    nextTick1(endFn);
  } else {
    src.once("end", endFn);
  }
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug("onend");
    dest.end();
  }
  let ondrain;
  let cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    if (ondrain) {
      dest.removeListener("drain", ondrain);
    }
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
      ondrain();
    }
  }
  function pause() {
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug("false write response, pause", 0);
        state.awaitDrainWriters = dest;
        state.multiAwaitDrain = false;
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug("false write response, pause", state.awaitDrainWriters.size);
        state.awaitDrainWriters.add(dest);
      }
      src.pause();
    }
    if (!ondrain) {
      ondrain = pipeOnDrain(src, dest);
      dest.on("drain", ondrain);
    }
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    const ret = dest.write(chunk);
    debug("dest.write", ret);
    if (ret === false) {
      pause();
    }
  }
  function onerror(er2) {
    debug("onerror", er2);
    unpipe();
    dest.removeListener("error", onerror);
    if (EventEmitter.listenerCount(dest, "error") === 0) {
      const s10 = dest._writableState || dest._readableState;
      if (s10 && !s10.errorEmitted) {
        errorOrDestroy1(dest, er2);
      } else {
        dest.emit("error", er2);
      }
    }
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause();
    }
  } else if (!state.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState;
    if (state.awaitDrainWriters === dest) {
      debug("pipeOnDrain", 1);
      state.awaitDrainWriters = null;
    } else if (state.multiAwaitDrain) {
      debug("pipeOnDrain", state.awaitDrainWriters.size);
      state.awaitDrainWriters.delete(dest);
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  const state = this._readableState;
  const unpipeInfo = {
    hasUnpiped: false
  };
  if (state.pipes.length === 0) {
    return this;
  }
  if (!dest) {
    const dests = state.pipes;
    state.pipes = [];
    this.pause();
    for (let i = 0; i < dests.length; i++) {
      dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  const index = state.pipes.indexOf(dest);
  if (index === -1) {
    return this;
  }
  state.pipes.splice(index, 1);
  if (state.pipes.length === 0) {
    this.pause();
  }
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);
  const state = this._readableState;
  if (ev === "data") {
    state.readableListening = this.listenerCount("readable") > 0;
    if (state.flowing !== false) {
      this.resume();
    }
  } else if (ev === "readable") {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug("on readable", state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        nextTick1(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    nextTick1(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    nextTick1(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self1) {
  const state = self1._readableState;
  state.readableListening = self1.listenerCount("readable") > 0;
  if (state.resumeScheduled && state[kPaused] === false) {
    state.flowing = true;
  } else if (self1.listenerCount("data") > 0) {
    self1.resume();
  } else if (!state.readableListening) {
    state.flowing = null;
  }
}
function nReadingNextTick(self1) {
  debug("readable nexttick read 0");
  self1.read(0);
}
Readable.prototype.resume = function() {
  const state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state[kPaused] = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick1(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug("resume", state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading) {
    stream.read(0);
  }
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState[kPaused] = true;
  return this;
};
function flow(stream) {
  const state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null)
    ;
}
Readable.prototype.wrap = function(stream) {
  let paused = false;
  stream.on("data", (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true;
      stream.pause();
    }
  });
  stream.on("end", () => {
    this.push(null);
  });
  stream.on("error", (err) => {
    errorOrDestroy1(this, err);
  });
  stream.on("close", () => {
    this.destroy();
  });
  stream.on("destroy", () => {
    this.destroy();
  });
  this._read = () => {
    if (paused && stream.resume) {
      paused = false;
      stream.resume();
    }
  };
  const streamKeys = Object.keys(stream);
  for (let j13 = 1; j13 < streamKeys.length; j13++) {
    const i = streamKeys[j13];
    if (this[i] === void 0 && typeof stream[i] === "function") {
      this[i] = stream[i].bind(stream);
    }
  }
  return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
  return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
  if (options !== void 0) {
    validateObject(options, "options");
  }
  return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== "function") {
    stream = Readable.wrap(stream, {
      objectMode: true
    });
  }
  const iter = createAsyncIterator(stream, options);
  iter.stream = stream;
  return iter;
}
async function* createAsyncIterator(stream, options) {
  let callback = nop1;
  const opts = {
    destroyOnReturn: true,
    destroyOnError: true,
    ...options
  };
  function next(resolve9) {
    if (this === stream) {
      callback();
      callback = nop1;
    } else {
      callback = resolve9;
    }
  }
  const state = stream._readableState;
  let error2 = state.errored;
  let errorEmitted = state.errorEmitted;
  let endEmitted = state.endEmitted;
  let closeEmitted = state.closeEmitted;
  stream.on("readable", next).on("error", function(err) {
    error2 = err;
    errorEmitted = true;
    next.call(this);
  }).on("end", function() {
    endEmitted = true;
    next.call(this);
  }).on("close", function() {
    closeEmitted = true;
    next.call(this);
  });
  let errorThrown = false;
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read();
      if (chunk !== null) {
        yield chunk;
      } else if (errorEmitted) {
        throw error2;
      } else if (endEmitted) {
        break;
      } else if (closeEmitted) {
        break;
      } else {
        await new Promise(next);
      }
    }
  } catch (err) {
    if (opts.destroyOnError) {
      __default3.destroyer(stream, err);
    }
    errorThrown = true;
    throw err;
  } finally {
    if (!errorThrown && opts.destroyOnReturn) {
      if (state.autoDestroy || !endEmitted) {
        __default3.destroyer(stream, null);
      }
    }
  }
}
Object.defineProperties(Readable.prototype, {
  readable: {
    get() {
      const r2 = this._readableState;
      return !!r2 && r2.readable !== false && !r2.destroyed && !r2.errorEmitted && !r2.endEmitted;
    },
    set(val) {
      if (this._readableState) {
        this._readableState.readable = !!val;
      }
    }
  },
  readableDidRead: {
    enumerable: false,
    get: function() {
      return this._readableState.dataEmitted;
    }
  },
  readableAborted: {
    enumerable: false,
    get: function() {
      return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
    }
  },
  readableHighWaterMark: {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  },
  readableBuffer: {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  },
  readableFlowing: {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  },
  readableLength: {
    enumerable: false,
    get() {
      return this._readableState.length;
    }
  },
  readableObjectMode: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false;
    }
  },
  readableEncoding: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null;
    }
  },
  destroyed: {
    enumerable: false,
    get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  },
  readableEnded: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false;
    }
  }
});
Object.defineProperties(ReadableState.prototype, {
  pipesCount: {
    get() {
      return this.pipes.length;
    }
  },
  paused: {
    get() {
      return this[kPaused] !== false;
    },
    set(value) {
      this[kPaused] = !!value;
    }
  }
});
function fromList(n3, state) {
  if (state.length === 0) {
    return null;
  }
  let ret;
  if (state.objectMode) {
    ret = state.buffer.shift();
  } else if (!n3 || n3 >= state.length) {
    if (state.decoder) {
      ret = state.buffer.join("");
    } else if (state.buffer.length === 1) {
      ret = state.buffer.first();
    } else {
      ret = state.buffer.concat(state.length);
    }
    state.buffer.clear();
  } else {
    ret = state.buffer.consume(n3, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  const state = stream._readableState;
  debug("endReadable", state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    nextTick1(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug("endReadableNT", state.endEmitted, state.length);
  if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.emit("end");
    if (stream.writable && stream.allowHalfOpen === false) {
      nextTick1(endWritableNT, stream);
    } else if (state.autoDestroy) {
      const wState = stream._writableState;
      const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
  if (writable) {
    stream.end();
  }
}
function readableFrom(iterable, opts) {
  return _from1(Readable, iterable, opts);
}
function wrap(src, options) {
  return new Readable({
    objectMode: src.readableObjectMode ?? src.objectMode ?? true,
    ...options,
    destroy(err, callback) {
      __default3.destroyer(src, err);
      callback(err);
    }
  }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
var { errorOrDestroy: errorOrDestroy2 } = __default3;
function isDuplexStream(maybe_duplex) {
  const isReadable4 = Readable.prototype.isPrototypeOf(maybe_duplex);
  let prototype = maybe_duplex;
  let isDuplex = false;
  while (prototype?.constructor && prototype.constructor.name !== "Object") {
    if (prototype.constructor.name === "Duplex") {
      isDuplex = true;
      break;
    }
    prototype = Object.getPrototypeOf(prototype);
  }
  return isReadable4 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {
}
var kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = isDuplexStream(stream);
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  const noDecode = !!(options && options.decodeStrings === false);
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = onwrite.bind(void 0, stream);
  this.writecb = null;
  this.writelen = 0;
  this.afterWriteTickInfo = null;
  resetBuffer(this);
  this.pendingcb = 0;
  this.constructed = true;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this[kOnFinished] = [];
}
function resetBuffer(state) {
  state.buffered = [];
  state.bufferedIndex = 0;
  state.allBuffers = true;
  state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
  return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
  get() {
    return this.buffered.length - this.bufferedIndex;
  }
});
function Writable(options) {
  const isDuplex = isDuplexStream(this);
  if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
    return new Writable(options);
  }
  this._writableState = new WritableState(options, this, isDuplex);
  if (options) {
    if (typeof options.write === "function") {
      this._write = options.write;
    }
    if (typeof options.writev === "function") {
      this._writev = options.writev;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.final === "function") {
      this._final = options.final;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  __default3.construct(this, () => {
    const state = this._writableState;
    if (!state.writing) {
      clearBuffer(this, state);
    }
    finishMaybe(this, state);
  });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
  value: function(object) {
    if (Function.prototype[Symbol.hasInstance].call(this, object))
      return true;
    if (this !== Writable)
      return false;
    return object && object._writableState instanceof WritableState;
  }
});
Writable.prototype.pipe = function() {
  errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = state.defaultEncoding;
  } else {
    if (!encoding) {
      encoding = state.defaultEncoding;
    } else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding)) {
      throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    if (typeof cb !== "function") {
      cb = nop2;
    }
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES();
  } else if (!state.objectMode) {
    if (typeof chunk === "string") {
      if (state.decodeStrings !== false) {
        chunk = Buffer2.from(chunk, encoding);
        encoding = "buffer";
      }
    } else if (chunk instanceof Buffer2) {
      encoding = "buffer";
    } else if (isUint8Array(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
      encoding = "buffer";
    } else {
      throw new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
      ], chunk);
    }
  }
  let err;
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END();
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED("write");
  }
  if (err) {
    nextTick1(cb, err);
    errorOrDestroy2(stream, err, true);
    return err;
  }
  state.pendingcb++;
  return writeOrBuffer(stream, state, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
  this._writableState.corked++;
};
Writable.prototype.uncork = function() {
  const state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing) {
      clearBuffer(this, state);
    }
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") {
    encoding = encoding.toLowerCase();
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new ERR_UNKNOWN_ENCODING(encoding);
  }
  this._writableState.defaultEncoding = encoding;
  return this;
};
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  const ret = state.length < state.highWaterMark;
  if (!ret) {
    state.needDrain = true;
  }
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({
      chunk,
      encoding,
      callback
    });
    if (state.allBuffers && encoding !== "buffer") {
      state.allBuffers = false;
    }
    if (state.allNoop && callback !== nop2) {
      state.allNoop = false;
    }
  } else {
    state.writelen = len;
    state.writecb = callback;
    state.writing = true;
    state.sync = true;
    stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) {
    state.onwrite(new ERR_STREAM_DESTROYED("write"));
  } else if (writev) {
    stream._writev(chunk, state.onwrite);
  } else {
    stream._write(chunk, encoding, state.onwrite);
  }
  state.sync = false;
}
function onwriteError(stream, state, er2, cb) {
  --state.pendingcb;
  cb(er2);
  errorBuffer(state);
  errorOrDestroy2(stream, er2);
}
function onwrite(stream, er2) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;
  if (typeof cb !== "function") {
    errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
    return;
  }
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
  if (er2) {
    er2.stack;
    if (!state.errored) {
      state.errored = er2;
    }
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er2;
    }
    if (sync) {
      nextTick1(onwriteError, stream, state, er2, cb);
    } else {
      onwriteError(stream, state, er2, cb);
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state);
    }
    if (sync) {
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++;
      } else {
        state.afterWriteTickInfo = {
          count: 1,
          cb,
          stream,
          state
        };
        nextTick1(afterWriteTick, state.afterWriteTickInfo);
      }
    } else {
      afterWrite(stream, state, 1, cb);
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null;
  return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
  if (needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
  while (count-- > 0) {
    state.pendingcb--;
    cb();
  }
  if (state.destroyed) {
    errorBuffer(state);
  }
  finishMaybe(stream, state);
}
function errorBuffer(state) {
  if (state.writing) {
    return;
  }
  for (let n3 = state.bufferedIndex; n3 < state.buffered.length; ++n3) {
    const { chunk, callback } = state.buffered[n3];
    const len = state.objectMode ? 1 : chunk.length;
    state.length -= len;
    callback(new ERR_STREAM_DESTROYED("write"));
  }
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i](new ERR_STREAM_DESTROYED("end"));
  }
  resetBuffer(state);
}
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return;
  }
  const { buffered, bufferedIndex, objectMode } = state;
  const bufferedLength = buffered.length - bufferedIndex;
  if (!bufferedLength) {
    return;
  }
  let i = bufferedIndex;
  state.bufferProcessing = true;
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1;
    const callback = state.allNoop ? nop2 : (err) => {
      for (let n3 = i; n3 < buffered.length; ++n3) {
        buffered[n3].callback(err);
      }
    };
    const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
    chunks.allBuffers = state.allBuffers;
    doWrite(stream, state, true, state.length, chunks, "", callback);
    resetBuffer(state);
  } else {
    do {
      const { chunk, encoding, callback: callback1 } = buffered[i];
      buffered[i++] = null;
      const len = objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, callback1);
    } while (i < buffered.length && !state.writing);
    if (i === buffered.length) {
      resetBuffer(state);
    } else if (i > 256) {
      buffered.splice(0, i);
      state.bufferedIndex = 0;
    } else {
      state.bufferedIndex = i;
    }
  }
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  if (this._writev) {
    this._writev([
      {
        chunk,
        encoding
      }
    ], cb);
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
  }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  const state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  let err;
  if (chunk !== null && chunk !== void 0) {
    const ret = _write(this, chunk, encoding);
    if (ret instanceof Error) {
      err = ret;
    }
  }
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (err) {
  } else if (!state.errored && !state.ending) {
    state.ending = true;
    finishMaybe(this, state, true);
    state.ended = true;
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED("end");
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED("end");
  }
  if (typeof cb === "function") {
    if (err || state.finished) {
      nextTick2(cb, err);
    } else {
      state[kOnFinished].push(cb);
    }
  }
  return this;
};
function needFinish(state) {
  return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
  let called = false;
  function onFinish(err) {
    if (called) {
      errorOrDestroy2(stream, err ?? ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    state.pendingcb--;
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err);
      }
      errorOrDestroy2(stream, err, state.sync);
    } else if (needFinish(state)) {
      state.prefinished = true;
      stream.emit("prefinish");
      state.pendingcb++;
      nextTick1(finish, stream, state);
    }
  }
  state.sync = true;
  state.pendingcb++;
  try {
    const result = stream._final(onFinish);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick1(onFinish, null);
        }, function(err) {
          nextTick1(onFinish, err);
        });
      }
    }
  } catch (err) {
    onFinish(stream, state, err);
  }
  state.sync = false;
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === "function" && !state.destroyed) {
      state.finalCalled = true;
      callFinal(stream, state);
    } else {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state);
    if (state.pendingcb === 0 && needFinish(state)) {
      state.pendingcb++;
      if (sync) {
        nextTick1(finish, stream, state);
      } else {
        finish(stream, state);
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--;
  state.finished = true;
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]();
  }
  stream.emit("finish");
  if (state.autoDestroy) {
    const rState = stream._readableState;
    const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
    if (autoDestroy) {
      stream.destroy();
    }
  }
}
Object.defineProperties(Writable.prototype, {
  destroyed: {
    get() {
      return this._writableState ? this._writableState.destroyed : false;
    },
    set(value) {
      if (this._writableState) {
        this._writableState.destroyed = value;
      }
    }
  },
  writable: {
    get() {
      const w24 = this._writableState;
      return !!w24 && w24.writable !== false && !w24.destroyed && !w24.errored && !w24.ending && !w24.ended;
    },
    set(val) {
      if (this._writableState) {
        this._writableState.writable = !!val;
      }
    }
  },
  writableFinished: {
    get() {
      return this._writableState ? this._writableState.finished : false;
    }
  },
  writableObjectMode: {
    get() {
      return this._writableState ? this._writableState.objectMode : false;
    }
  },
  writableBuffer: {
    get() {
      return this._writableState && this._writableState.getBuffer();
    }
  },
  writableEnded: {
    get() {
      return this._writableState ? this._writableState.ending : false;
    }
  },
  writableNeedDrain: {
    get() {
      const wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    }
  },
  writableHighWaterMark: {
    get() {
      return this._writableState && this._writableState.highWaterMark;
    }
  },
  writableCorked: {
    get() {
      return this._writableState ? this._writableState.corked : 0;
    }
  },
  writableLength: {
    get() {
      return this._writableState && this._writableState.length;
    }
  }
});
var destroy2 = __default3.destroy;
Writable.prototype.destroy = function(err, cb) {
  const state = this._writableState;
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    nextTick2(errorBuffer, state);
  }
  destroy2.call(this, err, cb);
  return this;
};
Writable.prototype._undestroy = __default3.undestroy;
Writable.prototype._destroy = function(err, cb) {
  cb(err);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Writable.WritableState = WritableState;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
  for (const method of Object.keys(Writable.prototype)) {
    if (!Duplex.prototype[method]) {
      Duplex.prototype[method] = Writable.prototype[method];
    }
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
    }
  }
}
Object.defineProperties(Duplex.prototype, {
  writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
  writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
  writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
  writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
  writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
  writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
  writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
  writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
  writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
  destroyed: {
    get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set(value) {
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    }
  }
});
function isReadableStream(object) {
  return object instanceof ReadableStream;
}
function isWritableStream(object) {
  return object instanceof WritableStream;
}
Duplex.fromWeb = function(pair, options) {
  validateObject(pair, "pair");
  const { readable: readableStream, writable: writableStream } = pair;
  if (!isReadableStream(readableStream)) {
    throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
  }
  if (!isWritableStream(writableStream)) {
    throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
  }
  validateObject(options, "options");
  const { allowHalfOpen = false, objectMode = false, encoding, decodeStrings = true, highWaterMark, signal } = options;
  validateBoolean(objectMode, "options.objectMode");
  if (encoding !== void 0 && !Buffer2.isEncoding(encoding)) {
    throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
  }
  const writer = writableStream.getWriter();
  const reader = readableStream.getReader();
  let writableClosed = false;
  let readableClosed = false;
  const duplex = new Duplex({
    allowHalfOpen,
    highWaterMark,
    objectMode,
    encoding,
    decodeStrings,
    signal,
    writev(chunks, callback) {
      function done(error2) {
        error2 = error2.filter((e) => e);
        try {
          callback(error2.length === 0 ? void 0 : error2);
        } catch (error1) {
          nextTick2(() => destroy(duplex, error1));
        }
      }
      writer.ready.then(() => Promise.All(chunks.map((data) => writer.write(data.chunk))).then(done, done), done);
    },
    write(chunk, encoding2, callback) {
      if (typeof chunk === "string" && decodeStrings && !objectMode) {
        chunk = Buffer2.from(chunk, encoding2);
        chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      }
      function done(error2) {
        try {
          callback(error2);
        } catch (error1) {
          destroy(duplex, error1);
        }
      }
      writer.ready.then(() => writer.write(chunk).then(done, done), done);
    },
    final(callback) {
      function done(error2) {
        try {
          callback(error2);
        } catch (error1) {
          nextTick2(() => destroy(duplex, error1));
        }
      }
      if (!writableClosed) {
        writer.close().then(done, done);
      }
    },
    read() {
      reader.read().then((chunk) => {
        if (chunk.done) {
          duplex.push(null);
        } else {
          duplex.push(chunk.value);
        }
      }, (error2) => destroy(duplex, error2));
    },
    destroy(error2, callback) {
      function done() {
        try {
          callback(error2);
        } catch (error1) {
          nextTick2(() => {
            throw error1;
          });
        }
      }
      async function closeWriter() {
        if (!writableClosed) {
          await writer.abort(error2);
        }
      }
      async function closeReader() {
        if (!readableClosed) {
          await reader.cancel(error2);
        }
      }
      if (!writableClosed || !readableClosed) {
        Promise.All([
          closeWriter(),
          closeReader()
        ]).then(done, done);
        return;
      }
      done();
    }
  });
  writer.closed.then(() => {
    writableClosed = true;
    if (!isWritableEnded(duplex)) {
      destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE());
    }
  }, (error2) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error2);
  });
  reader.closed.then(() => {
    readableClosed = true;
    if (!isReadableEnded1(duplex)) {
      duplex.push(null);
    }
  }, (error2) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error2);
  });
  return duplex;
};
var Duplexify = class extends Duplex {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body;
  }
  if (isReadableNodeStream(body)) {
    return _duplexify({
      readable: body
    });
  }
  if (isWritableNodeStream(body)) {
    return _duplexify({
      writable: body
    });
  }
  if (isNodeStream(body)) {
    return _duplexify({
      writable: false,
      readable: false
    });
  }
  if (typeof body === "function") {
    const { value, write: write6, final: __final2, destroy: destroy12 } = fromAsyncGen(body);
    if (isIterable(value)) {
      return _from1(Duplexify, value, {
        objectMode: true,
        write: write6,
        final: __final2,
        destroy: destroy12
      });
    }
    const then = value?.then;
    if (typeof then === "function") {
      let d14;
      const promise = then.call(value, (val) => {
        if (val != null) {
          throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
        }
      }, (err) => {
        destroyer(d14, err);
      });
      return d14 = new Duplexify({
        objectMode: true,
        readable: false,
        write: write6,
        final(cb) {
          __final2(async () => {
            try {
              await promise;
              nextTick2(cb, null);
            } catch (err) {
              nextTick2(cb, err);
            }
          });
        },
        destroy: destroy12
      });
    }
    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
  }
  if (isBlob(body)) {
    return duplexify(body.arrayBuffer());
  }
  if (isIterable(body)) {
    return _from1(Duplexify, body, {
      objectMode: true,
      writable: false
    });
  }
  if (typeof body?.writable === "object" || typeof body?.readable === "object") {
    const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : void 0;
    const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : void 0;
    return _duplexify({
      readable,
      writable
    });
  }
  const then1 = body?.then;
  if (typeof then1 === "function") {
    let d14;
    then1.call(body, (val) => {
      if (val != null) {
        d14.push(val);
      }
      d14.push(null);
    }, (err) => {
      destroyer(d14, err);
    });
    return d14 = new Duplexify({
      objectMode: true,
      writable: false,
      read() {
      }
    });
  }
  throw new ERR_INVALID_ARG_TYPE(name, [
    "Blob",
    "ReadableStream",
    "WritableStream",
    "Stream",
    "Iterable",
    "AsyncIterable",
    "Function",
    "{ readable, writable } pair",
    "Promise"
  ], body);
}
function fromAsyncGen(fn) {
  let { promise, resolve: resolve9 } = createDeferredPromise();
  const ac = new AbortController();
  const signal = ac.signal;
  const value = fn(async function* () {
    while (true) {
      const _promise = promise;
      promise = null;
      const { chunk, done, cb } = await _promise;
      nextTick1(cb);
      if (done)
        return;
      if (signal.aborted)
        throw new AbortError();
      ({ promise, resolve: resolve9 } = createDeferredPromise());
      yield chunk;
    }
  }(), {
    signal
  });
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve9;
      resolve9 = null;
      _resolve({
        chunk,
        done: false,
        cb
      });
    },
    final(cb) {
      const _resolve = resolve9;
      resolve9 = null;
      _resolve({
        done: true,
        cb
      });
    },
    destroy(err, cb) {
      ac.abort();
      cb(err);
    }
  };
}
function _duplexify(pair) {
  const r2 = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
  const w24 = pair.writable;
  let readable = !!isReadable1(r2);
  let writable = !!isWritable1(w24);
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d14;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d14.destroy(err);
    } else if (!readable && !writable) {
      d14.destroy();
    }
  }
  d14 = new Duplexify({
    readableObjectMode: !!r2?.readableObjectMode,
    writableObjectMode: !!w24?.writableObjectMode,
    readable,
    writable
  });
  if (writable) {
    eos(w24, (err) => {
      writable = false;
      if (err) {
        destroyer(r2, err);
      }
      onfinished(err);
    });
    d14._write = function(chunk, encoding, callback) {
      if (w24.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d14._final = function(callback) {
      w24.end();
      onfinish = callback;
    };
    w24.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    w24.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    eos(r2, (err) => {
      readable = false;
      if (err) {
        destroyer(r2, err);
      }
      onfinished(err);
    });
    r2.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    r2.on("end", function() {
      d14.push(null);
    });
    d14._read = function() {
      while (true) {
        const buf = r2.read();
        if (buf === null) {
          onreadable = d14._read;
          return;
        }
        if (!d14.push(buf)) {
          return;
        }
      }
    };
  }
  d14._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(w24, err);
      destroyer(r2, err);
    }
  };
  return d14;
}
function duplexFrom(body) {
  return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
var kCallback = Symbol("kCallback");
function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }
  Duplex.call(this, options);
  this._readableState.sync = false;
  this[kCallback] = null;
  if (options) {
    if (typeof options.transform === "function") {
      this._transform = options.transform;
    }
    if (typeof options.flush === "function") {
      this._flush = options.flush;
    }
  }
  this.on("prefinish", prefinish1);
}
function __final(cb) {
  let called = false;
  if (typeof this._flush === "function" && !this.destroyed) {
    const result = this._flush((er2, data) => {
      called = true;
      if (er2) {
        if (cb) {
          cb(er2);
        } else {
          this.destroy(er2);
        }
        return;
      }
      if (data != null) {
        this.push(data);
      }
      this.push(null);
      if (cb) {
        cb();
      }
    });
    if (result !== void 0 && result !== null) {
      try {
        const then = result.then;
        if (typeof then === "function") {
          then.call(result, (data) => {
            if (called) {
              return;
            }
            if (data != null) {
              this.push(data);
            }
            this.push(null);
            if (cb) {
              nextTick1(cb);
            }
          }, (err) => {
            if (cb) {
              nextTick1(cb, err);
            } else {
              nextTick1(() => this.destroy(err));
            }
          });
        }
      } catch (err) {
        nextTick1(() => this.destroy(err));
      }
    }
  } else {
    this.push(null);
    if (cb) {
      cb();
    }
  }
}
function prefinish1() {
  if (this._final !== __final) {
    __final.call(this);
  }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
  const rState = this._readableState;
  const wState = this._writableState;
  const length = rState.length;
  let called = false;
  const result = this._transform(chunk, encoding, (err, val) => {
    called = true;
    if (err) {
      callback(err);
      return;
    }
    if (val != null) {
      this.push(val);
    }
    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
      callback();
    } else {
      this[kCallback] = callback;
    }
  });
  if (result !== void 0 && result != null) {
    try {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, (val) => {
          if (called) {
            return;
          }
          if (val != null) {
            this.push(val);
          }
          if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            nextTick2(callback);
          } else {
            this[kCallback] = callback;
          }
        }, (err) => {
          nextTick2(callback, err);
        });
      }
    } catch (err) {
      nextTick2(callback, err);
    }
  }
};
Transform.prototype._read = function() {
  if (this[kCallback]) {
    const callback = this[kCallback];
    this[kCallback] = null;
    callback();
  }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) {
    return new PassThrough(options);
  }
  Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
  callback = once(callback);
  let finished2 = false;
  stream.on("close", () => {
    finished2 = true;
  });
  eos(stream, {
    readable: reading,
    writable: writing
  }, (err) => {
    finished2 = !err;
    const rState = stream._readableState;
    if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
      stream.once("end", callback).once("error", callback);
    } else {
      callback(err);
    }
  });
  return (err) => {
    if (finished2)
      return;
    finished2 = true;
    __default3.destroyer(stream, err);
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function popCallback(streams) {
  validateCallback(streams[streams.length - 1]);
  return streams.pop();
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val;
  } else if (isReadableNodeStream(val)) {
    return fromReadable(val);
  }
  throw new ERR_INVALID_ARG_TYPE("val", [
    "Readable",
    "Iterable",
    "AsyncIterable"
  ], val);
}
async function* fromReadable(val) {
  yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish2) {
  let error2;
  let onresolve = null;
  const resume2 = (err) => {
    if (err) {
      error2 = err;
    }
    if (onresolve) {
      const callback = onresolve;
      onresolve = null;
      callback();
    }
  };
  const wait = () => new Promise((resolve9, reject) => {
    if (error2) {
      reject(error2);
    } else {
      onresolve = () => {
        if (error2) {
          reject(error2);
        } else {
          resolve9();
        }
      };
    }
  });
  writable.on("drain", resume2);
  const cleanup = eos(writable, {
    readable: false
  }, resume2);
  try {
    if (writable.writableNeedDrain) {
      await wait();
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait();
      }
    }
    writable.end();
    await wait();
    finish2();
  } catch (err) {
    finish2(error2 !== err ? aggregateTwoErrors(error2, err) : err);
  } finally {
    cleanup();
    writable.off("drain", resume2);
  }
}
function pipeline(...streams) {
  const callback = once(popCallback(streams));
  if (Array.isArray(streams[0]) && streams.length === 1) {
    streams = streams[0];
  }
  return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  const ac = new AbortController();
  const signal = ac.signal;
  const outerSignal = opts?.signal;
  validateAbortSignal(outerSignal, "options.signal");
  function abort() {
    finishImpl(new AbortError());
  }
  outerSignal?.addEventListener("abort", abort);
  let error2;
  let value;
  const destroys = [];
  let finishCount = 0;
  function finish2(err) {
    finishImpl(err, --finishCount === 0);
  }
  function finishImpl(err, __final2) {
    if (err && (!error2 || error2.code === "ERR_STREAM_PREMATURE_CLOSE")) {
      error2 = err;
    }
    if (!error2 && !__final2) {
      return;
    }
    while (destroys.length) {
      destroys.shift()(error2);
    }
    outerSignal?.removeEventListener("abort", abort);
    ac.abort();
    if (__final2) {
      callback(error2, value);
    }
  }
  let ret;
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i];
    const reading = i < streams.length - 1;
    const writing = i > 0;
    if (isNodeStream(stream)) {
      finishCount++;
      destroys.push(destroyer1(stream, reading, writing, finish2));
    }
    if (i === 0) {
      if (typeof stream === "function") {
        ret = stream({
          signal
        });
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream)) {
        ret = stream;
      } else {
        ret = Duplex.from(stream);
      }
    } else if (typeof stream === "function") {
      ret = makeAsyncIterable(ret);
      ret = stream(ret, {
        signal
      });
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
        }
      } else {
        const pt2 = new PassThrough({
          objectMode: true
        });
        const then = ret?.then;
        if (typeof then === "function") {
          then.call(ret, (val) => {
            value = val;
            pt2.end(val);
          }, (err) => {
            pt2.destroy(err);
          });
        } else if (isIterable(ret, true)) {
          finishCount++;
          pump(ret, pt2, finish2);
        } else {
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
        }
        ret = pt2;
        finishCount++;
        destroys.push(destroyer1(ret, false, true, finish2));
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        ret.pipe(stream);
        if (stream === stdio.stdout || stream === stdio.stderr) {
          ret.on("end", () => stream.end());
        }
      } else {
        ret = makeAsyncIterable(ret);
        finishCount++;
        pump(ret, stream, finish2);
      }
      ret = stream;
    } else {
      ret = Duplex.from(stream);
    }
  }
  if (signal?.aborted || outerSignal?.aborted) {
    nextTick1(abort);
  }
  return ret;
}
var ComposeDuplex = class extends Duplex {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS("streams");
  }
  if (streams.length === 1) {
    return Duplex.from(streams[0]);
  }
  const orgStreams = [
    ...streams
  ];
  if (typeof streams[0] === "function") {
    streams[0] = Duplex.from(streams[0]);
  }
  if (typeof streams[streams.length - 1] === "function") {
    const idx = streams.length - 1;
    streams[idx] = Duplex.from(streams[idx]);
  }
  for (let n3 = 0; n3 < streams.length; ++n3) {
    if (!isNodeStream(streams[n3])) {
      continue;
    }
    if (n3 < streams.length - 1 && !isReadable1(streams[n3])) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n3}]`, orgStreams[n3], "must be readable");
    }
    if (n3 > 0 && !isWritable1(streams[n3])) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n3}]`, orgStreams[n3], "must be writable");
    }
  }
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d14;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d14.destroy(err);
    } else if (!readable && !writable) {
      d14.destroy();
    }
  }
  const head = streams[0];
  const tail = pipeline(streams, onfinished);
  const writable = !!isWritable1(head);
  const readable = !!isReadable1(tail);
  d14 = new ComposeDuplex({
    writableObjectMode: !!head?.writableObjectMode,
    readableObjectMode: !!tail?.writableObjectMode,
    writable,
    readable
  });
  if (writable) {
    d14._write = function(chunk, encoding, callback) {
      if (head.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d14._final = function(callback) {
      head.end();
      onfinish = callback;
    };
    head.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    tail.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    tail.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    tail.on("end", function() {
      d14.push(null);
    });
    d14._read = function() {
      while (true) {
        const buf = tail.read();
        if (buf === null) {
          onreadable = d14._read;
          return;
        }
        if (!d14.push(buf)) {
          return;
        }
      }
    };
  }
  d14._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(tail, err);
    }
  };
  return d14;
}
function pipeline1(...streams) {
  return new Promise((resolve9, reject) => {
    let signal;
    let end;
    const lastArg = streams[streams.length - 1];
    if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
      const options = streams.pop();
      signal = options.signal;
      end = options.end;
    }
    pipelineImpl(streams, (err, value) => {
      if (err) {
        reject(err);
      } else {
        resolve9(value);
      }
    }, {
      signal,
      end
    });
  });
}
function finished(stream, opts) {
  return new Promise((resolve9, reject) => {
    eos(stream, opts, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve9();
      }
    });
  });
}
var __default5 = {
  finished,
  pipeline: pipeline1
};
var { custom: customPromisify } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;
Object.defineProperty(Stream, "promises", {
  configurable: true,
  enumerable: true,
  get() {
    return __default5;
  }
});
Object.defineProperty(pipeline, customPromisify, {
  enumerable: true,
  get() {
    return __default5.pipeline;
  }
});
Object.defineProperty(eos, customPromisify, {
  enumerable: true,
  get() {
    return __default5.finished;
  }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
var hexTable = new TextEncoder().encode("0123456789abcdef");
function encode2(src) {
  const dst = new Uint8Array(src.length * 2);
  for (let i = 0; i < dst.length; i++) {
    const v19 = src[i];
    dst[i * 2] = hexTable[v19 >> 4];
    dst[i * 2 + 1] = hexTable[v19 & 15];
  }
  return dst;
}
var coerceToBytes = (data) => {
  if (data instanceof Uint8Array) {
    return data;
  } else if (typeof data === "string") {
    return new TextEncoder().encode(data);
  } else if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    throw new TypeError("expected data to be string | BufferSource");
  }
};
var Hash = class extends Transform {
  #context;
  constructor(algorithm, _opts) {
    super({
      transform(chunk, _encoding, callback) {
        context.update(coerceToBytes(chunk));
        callback();
      },
      flush(callback) {
        this.push(context.digest(void 0));
        callback();
      }
    });
    if (typeof algorithm === "string") {
      algorithm = algorithm.toUpperCase();
      if (opensslToWebCryptoDigestNames[algorithm]) {
        algorithm = opensslToWebCryptoDigestNames[algorithm];
      }
      this.#context = new (instantiate()).DigestContext(algorithm);
    } else {
      this.#context = algorithm;
    }
    const context = this.#context;
  }
  copy() {
    return new Hash(this.#context.clone());
  }
  update(data, _encoding) {
    let bytes;
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
      bytes = coerceToBytes(data);
    } else {
      bytes = coerceToBytes(data);
    }
    this.#context.update(bytes);
    return this;
  }
  digest(encoding) {
    const digest2 = this.#context.digest(void 0);
    if (encoding === void 0) {
      return Buffer2.from(digest2);
    }
    switch (encoding) {
      case "hex":
        return new TextDecoder().decode(encode2(new Uint8Array(digest2)));
      case "binary":
        return String.fromCharCode(...digest2);
      case "base64":
        return encode(digest2);
      default:
        throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
    }
  }
};
var Hmac = class extends Transform {
  constructor(hmac, _key, _options) {
    validateString(hmac, "hmac");
    super();
    notImplemented("crypto.Hmac");
  }
  digest(_encoding) {
    notImplemented("crypto.Hmac.prototype.digest");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Hmac.prototype.update");
  }
};
var opensslToWebCryptoDigestNames = {
  BLAKE2B512: "BLAKE2B",
  BLAKE2S256: "BLAKE2S",
  RIPEMD160: "RIPEMD-160",
  RMD160: "RIPEMD-160",
  SHA1: "SHA-1",
  SHA224: "SHA-224",
  SHA256: "SHA-256",
  SHA384: "SHA-384",
  SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
  return new Hash(algorithm, opts);
}
var MAX_ALLOC = Math.pow(2, 30) - 1;
var createHasher = (algorithm) => (value) => Buffer2.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros2) {
  return Buffer2.alloc(zeros2);
}
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function toBuffer(bufferable) {
  if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
    return Buffer2.from(bufferable);
  } else {
    return Buffer2.from(bufferable.buffer);
  }
}
var Hmac1 = class {
  hash;
  ipad1;
  opad;
  alg;
  blocksize;
  size;
  ipad2;
  constructor(alg, key2, saltLen) {
    this.hash = createHasher(alg);
    const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    if (key2.length > blocksize) {
      key2 = this.hash(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer2.concat([
        key2,
        getZeroes(blocksize - key2.length)
      ], blocksize);
    }
    const ipad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
    const opad = Buffer2.allocUnsafe(blocksize + sizes[alg]);
    for (let i = 0; i < blocksize; i++) {
      ipad[i] = key2[i] ^ 54;
      opad[i] = key2[i] ^ 92;
    }
    const ipad1 = Buffer2.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.size = sizes[alg];
  }
  run(data, ipad) {
    data.copy(ipad, this.blocksize);
    const h16 = this.hash(ipad);
    h16.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
  }
};
function pbkdf2Sync(password, salt, iterations, keylen, digest2 = "sha1") {
  if (typeof iterations !== "number" || iterations < 0) {
    throw new TypeError("Bad iterations");
  }
  if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
    throw new TypeError("Bad key length");
  }
  const bufferedPassword = toBuffer(password);
  const bufferedSalt = toBuffer(salt);
  const hmac = new Hmac1(digest2, bufferedPassword, bufferedSalt.length);
  const DK = Buffer2.allocUnsafe(keylen);
  const block1 = Buffer2.allocUnsafe(bufferedSalt.length + 4);
  bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
  let destPos = 0;
  const hLen = sizes[digest2];
  const l22 = Math.ceil(keylen / hLen);
  for (let i = 1; i <= l22; i++) {
    block1.writeUInt32BE(i, bufferedSalt.length);
    const T12 = hmac.run(block1, hmac.ipad1);
    let U7 = T12;
    for (let j13 = 1; j13 < iterations; j13++) {
      U7 = hmac.run(U7, hmac.ipad2);
      for (let k15 = 0; k15 < hLen; k15++)
        T12[k15] ^= U7[k15];
    }
    T12.copy(DK, destPos);
    destPos += hLen;
  }
  return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest2 = "sha1", callback) {
  setTimeout(() => {
    let err = null, res;
    try {
      res = pbkdf2Sync(password, salt, iterations, keylen, digest2);
    } catch (e) {
      err = e;
    }
    if (err) {
      callback(err instanceof Error ? err : new Error("[non-error thrown]"));
    } else {
      callback(null, res);
    }
  }, 0);
}
var fixOpts = (opts) => {
  const out = {
    N: 16384,
    p: 1,
    r: 8,
    maxmem: 32 << 20
  };
  if (!opts)
    return out;
  if (opts.N)
    out.N = opts.N;
  else if (opts.cost)
    out.N = opts.cost;
  if (opts.p)
    out.p = opts.p;
  else if (opts.parallelization)
    out.p = opts.parallelization;
  if (opts.r)
    out.r = opts.r;
  else if (opts.blockSize)
    out.r = opts.blockSize;
  if (opts.maxmem)
    out.maxmem = opts.maxmem;
  return out;
};
function blockxor(S14, Si2, D12, Di, len) {
  let i = -1;
  while (++i < len)
    D12[Di + i] ^= S14[Si2 + i];
}
function arraycopy(src, srcPos, dest, destPos, length) {
  src.copy(dest, destPos, srcPos, srcPos + length);
}
var R = (a7, b15) => a7 << b15 | a7 >>> 32 - b15;
var ScryptRom = class {
  B;
  r;
  N;
  p;
  XY;
  V;
  B32;
  x;
  _X;
  constructor(b15, r2, N6, p7) {
    this.B = b15;
    this.r = r2;
    this.N = N6;
    this.p = p7;
    this.XY = Buffer2.allocUnsafe(256 * r2);
    this.V = Buffer2.allocUnsafe(128 * r2 * N6);
    this.B32 = new Int32Array(16);
    this.x = new Int32Array(16);
    this._X = Buffer2.allocUnsafe(64);
  }
  run() {
    const p7 = this.p | 0;
    const r2 = this.r | 0;
    for (let i = 0; i < p7; i++)
      this.scryptROMix(i, r2);
    return this.B;
  }
  scryptROMix(i, r2) {
    const blockStart = i * 128 * r2;
    const offset = (2 * r2 - 1) * 64;
    const blockLen = 128 * r2;
    const B18 = this.B;
    const N6 = this.N | 0;
    const V8 = this.V;
    const XY = this.XY;
    B18.copy(XY, 0, blockStart, blockStart + blockLen);
    for (let i12 = 0; i12 < N6; i12++) {
      XY.copy(V8, i12 * blockLen, 0, blockLen);
      this.blockmix_salsa8(blockLen);
    }
    let j13;
    for (let i22 = 0; i22 < N6; i22++) {
      j13 = XY.readUInt32LE(offset) & N6 - 1;
      blockxor(V8, j13 * blockLen, XY, 0, blockLen);
      this.blockmix_salsa8(blockLen);
    }
    XY.copy(B18, blockStart, 0, blockLen);
  }
  blockmix_salsa8(blockLen) {
    const BY = this.XY;
    const r2 = this.r;
    const _X = this._X;
    arraycopy(BY, (2 * r2 - 1) * 64, _X, 0, 64);
    let i;
    for (i = 0; i < 2 * r2; i++) {
      blockxor(BY, i * 64, _X, 0, 64);
      this.salsa20_8();
      arraycopy(_X, 0, BY, blockLen + i * 64, 64);
    }
    for (i = 0; i < r2; i++) {
      arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
      arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r2) * 64, 64);
    }
  }
  salsa20_8() {
    const B32 = this.B32;
    const B18 = this._X;
    const x17 = this.x;
    let i;
    for (i = 0; i < 16; i++) {
      B32[i] = (B18[i * 4 + 0] & 255) << 0;
      B32[i] |= (B18[i * 4 + 1] & 255) << 8;
      B32[i] |= (B18[i * 4 + 2] & 255) << 16;
      B32[i] |= (B18[i * 4 + 3] & 255) << 24;
    }
    for (i = 0; i < 16; i++)
      x17[i] = B32[i];
    for (i = 0; i < 4; i++) {
      x17[4] ^= R(x17[0] + x17[12], 7);
      x17[8] ^= R(x17[4] + x17[0], 9);
      x17[12] ^= R(x17[8] + x17[4], 13);
      x17[0] ^= R(x17[12] + x17[8], 18);
      x17[9] ^= R(x17[5] + x17[1], 7);
      x17[13] ^= R(x17[9] + x17[5], 9);
      x17[1] ^= R(x17[13] + x17[9], 13);
      x17[5] ^= R(x17[1] + x17[13], 18);
      x17[14] ^= R(x17[10] + x17[6], 7);
      x17[2] ^= R(x17[14] + x17[10], 9);
      x17[6] ^= R(x17[2] + x17[14], 13);
      x17[10] ^= R(x17[6] + x17[2], 18);
      x17[3] ^= R(x17[15] + x17[11], 7);
      x17[7] ^= R(x17[3] + x17[15], 9);
      x17[11] ^= R(x17[7] + x17[3], 13);
      x17[15] ^= R(x17[11] + x17[7], 18);
      x17[1] ^= R(x17[0] + x17[3], 7);
      x17[2] ^= R(x17[1] + x17[0], 9);
      x17[3] ^= R(x17[2] + x17[1], 13);
      x17[0] ^= R(x17[3] + x17[2], 18);
      x17[6] ^= R(x17[5] + x17[4], 7);
      x17[7] ^= R(x17[6] + x17[5], 9);
      x17[4] ^= R(x17[7] + x17[6], 13);
      x17[5] ^= R(x17[4] + x17[7], 18);
      x17[11] ^= R(x17[10] + x17[9], 7);
      x17[8] ^= R(x17[11] + x17[10], 9);
      x17[9] ^= R(x17[8] + x17[11], 13);
      x17[10] ^= R(x17[9] + x17[8], 18);
      x17[12] ^= R(x17[15] + x17[14], 7);
      x17[13] ^= R(x17[12] + x17[15], 9);
      x17[14] ^= R(x17[13] + x17[12], 13);
      x17[15] ^= R(x17[14] + x17[13], 18);
    }
    for (i = 0; i < 16; i++)
      B32[i] += x17[i];
    let bi2;
    for (i = 0; i < 16; i++) {
      bi2 = i * 4;
      B18[bi2 + 0] = B32[i] >> 0 & 255;
      B18[bi2 + 1] = B32[i] >> 8 & 255;
      B18[bi2 + 2] = B32[i] >> 16 & 255;
      B18[bi2 + 3] = B32[i] >> 24 & 255;
    }
  }
  clean() {
    this.XY.fill(0);
    this.V.fill(0);
    this._X.fill(0);
    this.B.fill(0);
    for (let i = 0; i < 16; i++) {
      this.B32[i] = 0;
      this.x[i] = 0;
    }
  }
};
function scryptSync(password, salt, keylen, _opts) {
  const { N: N6, r: r2, p: p7, maxmem } = fixOpts(_opts);
  const blen = p7 * 128 * r2;
  if (32 * r2 * (N6 + 2) * 4 + blen > maxmem) {
    throw new Error("excedes max memory");
  }
  const b15 = pbkdf2Sync(password, salt, 1, blen, "sha256");
  const scryptRom = new ScryptRom(b15, r2, N6, p7);
  const out = scryptRom.run();
  const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
  scryptRom.clean();
  return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
  if (!cb) {
    cb = _opts;
    _opts = null;
  }
  const { N: N6, r: r2, p: p7, maxmem } = fixOpts(_opts);
  const blen = p7 * 128 * r2;
  if (32 * r2 * (N6 + 2) * 4 + blen > maxmem) {
    throw new Error("excedes max memory");
  }
  try {
    const b15 = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b15, r2, N6, p7);
    const out = scryptRom.run();
    const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    cb(null, result);
  } catch (err) {
    return cb(err);
  }
}
var encrypt = function(self1, block) {
  return self1._cipher.encryptBlock(block);
};
var decrypt = function(self1, block) {
  return self1._cipher.decryptBlock(block);
};
var mod7 = {
  encrypt,
  decrypt
};
function xor(a7, b15) {
  const length = Math.min(a7.length, b15.length);
  const buffer = Buffer2.allocUnsafe(length);
  for (let i = 0; i < length; ++i) {
    buffer[i] = a7[i] ^ b15[i];
  }
  return buffer;
}
var encrypt1 = function(self1, block) {
  const data = xor(block, self1._prev);
  self1._prev = self1._cipher.encryptBlock(data);
  return self1._prev;
};
var decrypt1 = function(self1, block) {
  const pad2 = self1._prev;
  self1._prev = block;
  const out = self1._cipher.decryptBlock(block);
  return xor(out, pad2);
};
var mod8 = {
  encrypt: encrypt1,
  decrypt: decrypt1
};
function encryptStart(self1, data, decrypt3) {
  const len = data.length;
  const out = xor(data, self1._cache);
  self1._cache = self1._cache.slice(len);
  self1._prev = Buffer2.concat([
    self1._prev,
    decrypt3 ? data : out
  ]);
  return out;
}
var encrypt2 = function(self1, data, decrypt3) {
  let out = Buffer2.allocUnsafe(0);
  let len;
  while (data.length) {
    if (self1._cache.length === 0) {
      self1._cache = self1._cipher.encryptBlock(self1._prev);
      self1._prev = Buffer2.allocUnsafe(0);
    }
    if (self1._cache.length <= data.length) {
      len = self1._cache.length;
      out = Buffer2.concat([
        out,
        encryptStart(self1, data.slice(0, len), decrypt3)
      ]);
      data = data.slice(len);
    } else {
      out = Buffer2.concat([
        out,
        encryptStart(self1, data, decrypt3)
      ]);
      break;
    }
  }
  return out;
};
var mod9 = {
  encrypt: encrypt2
};
function encryptByte(self1, byteParam, decrypt3) {
  const pad2 = self1._cipher.encryptBlock(self1._prev);
  const out = pad2[0] ^ byteParam;
  self1._prev = Buffer2.concat([
    self1._prev.slice(1),
    Buffer2.from([
      decrypt3 ? byteParam : out
    ])
  ]);
  return out;
}
var encrypt3 = function(self1, chunk, decrypt3) {
  const len = chunk.length;
  const out = Buffer2.allocUnsafe(len);
  let i = -1;
  while (++i < len) {
    out[i] = encryptByte(self1, chunk[i], decrypt3);
  }
  return out;
};
var mod10 = {
  encrypt: encrypt3
};
function encryptByte1(self1, byteParam, decrypt3) {
  let pad2;
  let i = -1;
  let out = 0;
  let bit, value;
  while (++i < 8) {
    pad2 = self1._cipher.encryptBlock(self1._prev);
    bit = byteParam & 1 << 7 - i ? 128 : 0;
    value = pad2[0] ^ bit;
    out += (value & 128) >> i % 8;
    self1._prev = shiftIn(self1._prev, decrypt3 ? bit : value);
  }
  return out;
}
function shiftIn(buffer, value) {
  const len = buffer.length;
  let i = -1;
  const out = Buffer2.allocUnsafe(buffer.length);
  buffer = Buffer2.concat([
    buffer,
    Buffer2.from([
      value
    ])
  ]);
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
  }
  return out;
}
var encrypt4 = function(self1, chunk, decrypt3) {
  const len = chunk.length;
  const out = Buffer2.allocUnsafe(len);
  let i = -1;
  while (++i < len) {
    out[i] = encryptByte1(self1, chunk[i], decrypt3);
  }
  return out;
};
var mod11 = {
  encrypt: encrypt4
};
function getBlock(self1) {
  self1._prev = self1._cipher.encryptBlock(self1._prev);
  return self1._prev;
}
var encrypt5 = function(self1, chunk) {
  while (self1._cache.length < chunk.length) {
    self1._cache = Buffer2.concat([
      self1._cache,
      getBlock(self1)
    ]);
  }
  const pad2 = self1._cache.slice(0, chunk.length);
  self1._cache = self1._cache.slice(chunk.length);
  return xor(chunk, pad2);
};
var mod12 = {
  encrypt: encrypt5
};
function incr32(iv) {
  let len = iv.length;
  let item;
  while (len--) {
    item = iv.readUInt8(len);
    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}
function getBlock1(self1) {
  const out = self1._cipher.encryptBlockRaw(self1._prev);
  incr32(self1._prev);
  return out;
}
var blockSize = 16;
var encrypt6 = function(self1, chunk) {
  const chunkNum = Math.ceil(chunk.length / 16);
  const start = self1._cache.length;
  self1._cache = Buffer2.concat([
    self1._cache,
    Buffer2.allocUnsafe(chunkNum * blockSize)
  ]);
  for (let i = 0; i < chunkNum; i++) {
    const out = getBlock1(self1);
    const offset = start + i * 16;
    self1._cache.writeUInt32BE(out[0], offset + 0);
    self1._cache.writeUInt32BE(out[1], offset + 4);
    self1._cache.writeUInt32BE(out[2], offset + 8);
    self1._cache.writeUInt32BE(out[3], offset + 12);
  }
  const pad2 = self1._cache.slice(0, chunk.length);
  self1._cache = self1._cache.slice(chunk.length);
  return xor(chunk, pad2);
};
var mod13 = {
  encrypt: encrypt6
};
var modeModules = {
  ECB: mod7,
  CBC: mod8,
  CFB: mod9,
  CFB8: mod10,
  CFB1: mod11,
  OFB: mod12,
  CTR: mod13,
  GCM: mod13
};
var MODES = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
};
for (const mode of Object.values(MODES)) {
  mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
  if (!Buffer2.isBuffer(buf))
    buf = Buffer2.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);
  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }
  return out;
}
function scrubVec(v19) {
  for (var i = 0; i < v19.length; v19++) {
    v19[i] = 0;
  }
}
function cryptBlock(M14, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s0 = M14[0] ^ keySchedule[0];
  var s12 = M14[1] ^ keySchedule[1];
  var s22 = M14[2] ^ keySchedule[2];
  var s32 = M14[3] ^ keySchedule[3];
  var t02, t1, t2, t3;
  var ksRow = 4;
  for (var round = 1; round < nRounds; round++) {
    t02 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s12 >>> 16 & 255] ^ SUB_MIX2[s22 >>> 8 & 255] ^ SUB_MIX3[s32 & 255] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s12 >>> 24] ^ SUB_MIX1[s22 >>> 16 & 255] ^ SUB_MIX2[s32 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s22 >>> 24] ^ SUB_MIX1[s32 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s12 & 255] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s32 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s12 >>> 8 & 255] ^ SUB_MIX3[s22 & 255] ^ keySchedule[ksRow++];
    s0 = t02;
    s12 = t1;
    s22 = t2;
    s32 = t3;
  }
  t02 = (SBOX[s0 >>> 24] << 24 | SBOX[s12 >>> 16 & 255] << 16 | SBOX[s22 >>> 8 & 255] << 8 | SBOX[s32 & 255]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s12 >>> 24] << 24 | SBOX[s22 >>> 16 & 255] << 16 | SBOX[s32 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s22 >>> 24] << 24 | SBOX[s32 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s12 & 255]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s32 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s12 >>> 8 & 255] << 8 | SBOX[s22 & 255]) ^ keySchedule[ksRow++];
  t02 = t02 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [
    t02,
    t1,
    t2,
    t3
  ];
}
var RCON = [
  0,
  1,
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  27,
  54
];
var G = function() {
  var d14 = new Array(256);
  for (var j13 = 0; j13 < 256; j13++) {
    if (j13 < 128) {
      d14[j13] = j13 << 1;
    } else {
      d14[j13] = j13 << 1 ^ 283;
    }
  }
  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [
    [],
    [],
    [],
    []
  ];
  var INV_SUB_MIX = [
    [],
    [],
    [],
    []
  ];
  var x17 = 0;
  var xi3 = 0;
  for (var i = 0; i < 256; ++i) {
    var sx = xi3 ^ xi3 << 1 ^ xi3 << 2 ^ xi3 << 3 ^ xi3 << 4;
    sx = sx >>> 8 ^ sx & 255 ^ 99;
    SBOX[x17] = sx;
    INV_SBOX[sx] = x17;
    var x22 = d14[x17];
    var x42 = d14[x22];
    var x82 = d14[x42];
    var t2 = d14[sx] * 257 ^ sx * 16843008;
    SUB_MIX[0][x17] = t2 << 24 | t2 >>> 8;
    SUB_MIX[1][x17] = t2 << 16 | t2 >>> 16;
    SUB_MIX[2][x17] = t2 << 8 | t2 >>> 24;
    SUB_MIX[3][x17] = t2;
    t2 = x82 * 16843009 ^ x42 * 65537 ^ x22 * 257 ^ x17 * 16843008;
    INV_SUB_MIX[0][sx] = t2 << 24 | t2 >>> 8;
    INV_SUB_MIX[1][sx] = t2 << 16 | t2 >>> 16;
    INV_SUB_MIX[2][sx] = t2 << 8 | t2 >>> 24;
    INV_SUB_MIX[3][sx] = t2;
    if (x17 === 0) {
      x17 = xi3 = 1;
    } else {
      x17 = x22 ^ d14[d14[d14[x82 ^ x22]]];
      xi3 ^= d14[d14[xi3]];
    }
  }
  return {
    SBOX,
    INV_SBOX,
    SUB_MIX,
    INV_SUB_MIX
  };
}();
function AES(key2) {
  this._key = asUInt32Array(key2);
  this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];
  for (var k15 = 0; k15 < keySize; k15++) {
    keySchedule[k15] = keyWords[k15];
  }
  for (k15 = keySize; k15 < ksRows; k15++) {
    var t2 = keySchedule[k15 - 1];
    if (k15 % keySize === 0) {
      t2 = t2 << 8 | t2 >>> 24;
      t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
      t2 ^= RCON[k15 / keySize | 0] << 24;
    } else if (keySize > 6 && k15 % keySize === 4) {
      t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
    }
    keySchedule[k15] = keySchedule[k15 - keySize] ^ t2;
  }
  var invKeySchedule = [];
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt3 = keySchedule[ksR - (ik % 4 ? 0 : 4)];
    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt3;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt3 >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt3 >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt3 >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt3 & 255]];
    }
  }
  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M14) {
  M14 = asUInt32Array(M14);
  return cryptBlock(M14, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M14) {
  var out = this.encryptBlockRaw(M14);
  var buf = Buffer2.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};
AES.prototype.decryptBlock = function(M14) {
  M14 = asUInt32Array(M14);
  var m110 = M14[1];
  M14[1] = M14[3];
  M14[3] = m110;
  var out = cryptBlock(M14, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer2.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};
function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === "string";
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
CipherBase.prototype = Object.create(Transform.prototype, {
  constructor: {
    value: CipherBase,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
  if (typeof data === "string") {
    data = Buffer2.from(data, inputEnc);
  }
  var outData = this._update(data);
  if (this.hashMode)
    return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function() {
};
CipherBase.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _11, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase.prototype._flush = function(done) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
  var outData = this.__final() || Buffer2.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc)
    throw new Error("can't switch encodings");
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var ZEROES = Buffer2.alloc(16, 0);
function toArray(buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ];
}
function fromArray(out) {
  var buf = Buffer2.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}
function GHASH(key2) {
  this.h = key2;
  this.state = Buffer2.alloc(16, 0);
  this.cache = Buffer2.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
  var i = -1;
  while (++i < block.length) {
    this.state[i] ^= block[i];
  }
  this._multiply();
};
GHASH.prototype._multiply = function() {
  var Vi = toArray(this.h);
  var Zi = [
    0,
    0,
    0,
    0
  ];
  var j13, xi3, lsbVi;
  var i = -1;
  while (++i < 128) {
    xi3 = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
    if (xi3) {
      Zi[0] ^= Vi[0];
      Zi[1] ^= Vi[1];
      Zi[2] ^= Vi[2];
      Zi[3] ^= Vi[3];
    }
    lsbVi = (Vi[3] & 1) !== 0;
    for (j13 = 3; j13 > 0; j13--) {
      Vi[j13] = Vi[j13] >>> 1 | (Vi[j13 - 1] & 1) << 31;
    }
    Vi[0] = Vi[0] >>> 1;
    if (lsbVi) {
      Vi[0] = Vi[0] ^ 225 << 24;
    }
  }
  this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
  this.cache = Buffer2.concat([
    this.cache,
    buf
  ]);
  var chunk;
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};
GHASH.prototype.final = function(abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer2.concat([
      this.cache,
      ZEROES
    ], 16));
  }
  this.ghash(fromArray([
    0,
    abl,
    0,
    bl
  ]));
  return this.state;
};
function xorTest(a7, b15) {
  var out = 0;
  if (a7.length !== b15.length)
    out++;
  var len = Math.min(a7.length, b15.length);
  for (var i = 0; i < len; ++i) {
    out += a7[i] ^ b15[i];
  }
  return out;
}
function calcIv(self1, iv, ck) {
  if (iv.length === 12) {
    self1._finID = Buffer2.concat([
      iv,
      Buffer2.from([
        0,
        0,
        0,
        1
      ])
    ]);
    return Buffer2.concat([
      iv,
      Buffer2.from([
        0,
        0,
        0,
        2
      ])
    ]);
  }
  var ghash = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash.update(iv);
  if (toPad) {
    toPad = 16 - toPad;
    ghash.update(Buffer2.alloc(toPad, 0));
  }
  ghash.update(Buffer2.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer2.alloc(8);
  tail.writeUIntBE(ivBits, 2, 6);
  ghash.update(tail);
  self1._finID = ghash.state;
  var out = Buffer2.from(self1._finID);
  incr32(out);
  return out;
}
function StreamCipher(mode, key2, iv, decrypt3) {
  CipherBase.call(this);
  var h16 = Buffer2.alloc(4, 0);
  this._cipher = new AES(key2);
  var ck = this._cipher.encryptBlock(h16);
  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer2.from(iv);
  this._cache = Buffer2.allocUnsafe(0);
  this._secCache = Buffer2.allocUnsafe(0);
  this._decrypt = decrypt3;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
  constructor: {
    value: StreamCipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
StreamCipher.prototype._update = function(chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;
    if (rump < 16) {
      rump = Buffer2.alloc(rump, 0);
      this._ghash.update(rump);
    }
  }
  this._called = true;
  var out = this._mode.encrypt(this, chunk);
  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }
  this._len += chunk.length;
  return out;
};
StreamCipher.prototype._final = function() {
  if (this._decrypt && !this._authTag) {
    throw new Error("Unsupported state or unable to authenticate data");
  }
  var tag2 = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag2, this._authTag)) {
    throw new Error("Unsupported state or unable to authenticate data");
  }
  this._authTag = tag2;
  this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer2.isBuffer(this._authTag)) {
    throw new Error("Attempting to get auth tag in unsupported state");
  }
  return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag2) {
  if (!this._decrypt) {
    throw new Error("Attempting to set auth tag in unsupported state");
  }
  this._authTag = tag2;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
  if (this._called) {
    throw new Error("Attempting to set AAD in unsupported state");
  }
  this._ghash.update(buf);
  this._alen += buf.length;
};
function StreamCipher1(mode, key2, iv, decrypt3) {
  CipherBase.call(this);
  this._cipher = new AES(key2);
  this._prev = Buffer2.from(iv);
  this._cache = Buffer2.allocUnsafe(0);
  this._secCache = Buffer2.allocUnsafe(0);
  this._decrypt = decrypt3;
  this._mode = mode;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
  constructor: {
    value: StreamCipher1,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
StreamCipher1.prototype._update = function(chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
  this._cipher.scrub();
};
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer2.isBuffer(password))
    password = Buffer2.from(password, "binary");
  if (salt) {
    if (!Buffer2.isBuffer(salt))
      salt = Buffer2.from(salt, "binary");
    if (salt.length !== 8) {
      throw new RangeError("salt should be Buffer with 8 byte length");
    }
  }
  let keyLen = keyBits / 8;
  const key2 = Buffer2.alloc(keyLen);
  const iv = Buffer2.alloc(ivLen || 0);
  let tmp = Buffer2.alloc(0);
  while (keyLen > 0 || ivLen > 0) {
    const hash = createHash("md5");
    hash.update(tmp);
    hash.update(password);
    if (salt)
      hash.update(salt);
    tmp = hash.digest();
    let used = 0;
    if (keyLen > 0) {
      const keyStart = key2.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key2, keyStart, 0, used);
      keyLen -= used;
    }
    if (used < tmp.length && ivLen > 0) {
      const ivStart = iv.length - ivLen;
      const length = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }
  tmp.fill(0);
  return {
    key: key2,
    iv
  };
}
function Cipher(mode, key2, iv) {
  CipherBase.call(this);
  this._cache = new Splitter();
  this._cipher = new AES(key2);
  this._prev = Buffer2.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
  constructor: {
    value: Cipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Cipher.prototype._update = function(data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }
  return Buffer2.concat(out);
};
var PADDING = Buffer2.alloc(16, 16);
Cipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);
    this._cipher.scrub();
    return chunk;
  }
  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();
    throw new Error("data not multiple of block length");
  }
};
Cipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter() {
  this.cache = Buffer2.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
  this.cache = Buffer2.concat([
    this.cache,
    data
  ]);
};
Splitter.prototype.get = function() {
  if (this.cache.length > 15) {
    const out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }
  return null;
};
Splitter.prototype.flush = function() {
  var len = 16 - this.cache.length;
  var padBuff = Buffer2.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }
  return Buffer2.concat([
    this.cache,
    padBuff
  ]);
};
function Decipher(mode, key2, iv) {
  CipherBase.call(this);
  this._cache = new Splitter1();
  this._last = void 0;
  this._cipher = new AES(key2);
  this._prev = Buffer2.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
  constructor: {
    value: Decipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Decipher.prototype._update = function(data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }
  return Buffer2.concat(out);
};
Decipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error("data not multiple of block length");
  }
};
Decipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter1() {
  this.cache = Buffer2.allocUnsafe(0);
}
Splitter1.prototype.add = function(data) {
  this.cache = Buffer2.concat([
    this.cache,
    data
  ]);
};
Splitter1.prototype.get = function(autoPadding) {
  var out;
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }
  return null;
};
Splitter1.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(last) {
  var padded = last[15];
  if (padded < 1 || padded > 16) {
    throw new Error("unable to decrypt data");
  }
  var i = -1;
  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error("unable to decrypt data");
    }
  }
  if (padded === 16)
    return;
  return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config)
    throw new TypeError("invalid suite type");
  if (typeof iv === "string")
    iv = Buffer2.from(iv);
  if (config.mode !== "GCM" && iv.length !== config.iv) {
    throw new TypeError("invalid iv length " + iv.length);
  }
  if (typeof password === "string")
    password = Buffer2.from(password);
  if (password.length !== config.key / 8) {
    throw new TypeError("invalid key length " + password.length);
  }
  if (config.type === "stream") {
    return new StreamCipher1(config.module, password, iv, true);
  } else if (config.type === "auth") {
    return new StreamCipher(config.module, password, iv, true);
  }
  return new Decipher(config.module, password, iv);
}
function getCiphers() {
  return Object.keys(MODES);
}
var defaultEncoding = "buffer";
function getDefaultEncoding() {
  return defaultEncoding;
}
function toBuf(val, encoding) {
  if (typeof val === "string") {
    if (encoding === "buffer") {
      encoding = "utf8";
    }
    return Buffer2.from(val, encoding);
  }
  return val;
}
var validateByteSource = hideStackFrames((val, name) => {
  val = toBuf(val);
  if (isAnyArrayBuffer1(val) || isArrayBufferView(val)) {
    return;
  }
  throw new ERR_INVALID_ARG_TYPE(name, [
    "string",
    "ArrayBuffer",
    "TypedArray",
    "DataView",
    "Buffer"
  ], val);
});
function getHashes() {
  return digestAlgorithms;
}
function getCurves() {
  notImplemented("crypto.getCurves");
}
function secureHeapUsed() {
  notImplemented("crypto.secureHeapUsed");
}
function setEngine(_engine, _flags) {
  notImplemented("crypto.setEngine");
}
var KeyObject = class {
  [kKeyType];
  [kHandle];
  constructor(type, handle) {
    if (type !== "secret" && type !== "public" && type !== "private") {
      throw new ERR_INVALID_ARG_VALUE("type", type);
    }
    if (typeof handle !== "object") {
      throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
    }
    this[kKeyType] = type;
    Object.defineProperty(this, kHandle, {
      value: handle,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }
  get type() {
    return this[kKeyType];
  }
  get asymmetricKeyDetails() {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
    return void 0;
  }
  get asymmetricKeyType() {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    return void 0;
  }
  get symmetricKeySize() {
    notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
    return void 0;
  }
  static from(key2) {
    if (!isCryptoKey(key2)) {
      throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key2);
    }
    notImplemented("crypto.KeyObject.prototype.from");
  }
  equals(otherKeyObject) {
    if (!isKeyObject(otherKeyObject)) {
      throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
    }
    notImplemented("crypto.KeyObject.prototype.equals");
  }
  export(_options) {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
  }
};
function createPrivateKey(_key) {
  notImplemented("crypto.createPrivateKey");
}
function createPublicKey(_key) {
  notImplemented("crypto.createPublicKey");
}
function createSecretKey(_key, _encoding) {
  notImplemented("crypto.createSecretKey");
}
var validateParameters = hideStackFrames((hash, key2, salt, info2, length) => {
  key2 = prepareKey(key2);
  salt = toBuf(salt);
  info2 = toBuf(info2);
  validateString(hash, "digest");
  validateByteSource(salt, "salt");
  validateByteSource(info2, "info");
  validateInteger(length, "length", 0, 2147483647);
  if (info2.byteLength > 1024) {
    throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info2.byteLength);
  }
  return {
    hash,
    key: key2,
    salt,
    info: info2,
    length
  };
});
function prepareKey(key2) {
  if (isKeyObject(key2)) {
    return key2;
  }
  if (isAnyArrayBuffer1(key2)) {
    return createSecretKey(new Uint8Array(key2));
  }
  key2 = toBuf(key2);
  if (!isArrayBufferView(key2)) {
    throw new ERR_INVALID_ARG_TYPE("ikm", [
      "string",
      "SecretKeyObject",
      "ArrayBuffer",
      "TypedArray",
      "DataView",
      "Buffer"
    ], key2);
  }
  return createSecretKey(key2);
}
function hkdf(hash, key2, salt, info2, length, callback) {
  ({ hash, key: key2, salt, info: info2, length } = validateParameters(hash, key2, salt, info2, length));
  validateCallback(callback);
  notImplemented("crypto.hkdf");
}
function hkdfSync(hash, key2, salt, info2, length) {
  ({ hash, key: key2, salt, info: info2, length } = validateParameters(hash, key2, salt, info2, length));
  notImplemented("crypto.hkdfSync");
}
function generateKey(_type, _options, _callback) {
  notImplemented("crypto.generateKey");
}
function generateKeyPair(_type, _options, _callback) {
  notImplemented("crypto.generateKeyPair");
}
function generateKeyPairSync(_type, _options) {
  notImplemented("crypto.generateKeyPairSync");
}
function generateKeySync(_type, _options) {
  notImplemented("crypto.generateKeySync");
}
var DH_GENERATOR = 2;
var DiffieHellman = class {
  verifyError;
  constructor(sizeOrKey, keyEncoding, generator, genEncoding) {
    if (typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer1(sizeOrKey)) {
      throw new ERR_INVALID_ARG_TYPE("sizeOrKey", [
        "number",
        "string",
        "ArrayBuffer",
        "Buffer",
        "TypedArray",
        "DataView"
      ], sizeOrKey);
    }
    if (typeof sizeOrKey === "number") {
      validateInt32(sizeOrKey, "sizeOrKey");
    }
    if (keyEncoding && !Buffer2.isEncoding(keyEncoding) && keyEncoding !== "buffer") {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
    const encoding = getDefaultEncoding();
    keyEncoding = keyEncoding || encoding;
    genEncoding = genEncoding || encoding;
    if (typeof sizeOrKey !== "number") {
      sizeOrKey = toBuf(sizeOrKey, keyEncoding);
    }
    if (!generator) {
      generator = DH_GENERATOR;
    } else if (typeof generator === "number") {
      validateInt32(generator, "generator");
    } else if (typeof generator === "string") {
      generator = toBuf(generator, genEncoding);
    } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer1(generator)) {
      throw new ERR_INVALID_ARG_TYPE("generator", [
        "number",
        "string",
        "ArrayBuffer",
        "Buffer",
        "TypedArray",
        "DataView"
      ], generator);
    }
    notImplemented("crypto.DiffieHellman");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.DiffieHellman.prototype.computeSecret");
  }
  generateKeys(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.generateKeys");
  }
  getGenerator(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getGenerator");
  }
  getPrime(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrime");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
  }
  getPublicKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
  }
  setPrivateKey(_privateKey, _encoding) {
    notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
  }
  setPublicKey(_publicKey, _encoding) {
    notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
  }
};
var DiffieHellmanGroup = class {
  verifyError;
  constructor(_name) {
    notImplemented("crypto.DiffieHellmanGroup");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.DiffieHellman.prototype.computeSecret");
  }
  generateKeys(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.generateKeys");
  }
  getGenerator(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getGenerator");
  }
  getPrime(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrime");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
  }
  getPublicKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
  }
};
var ECDH = class {
  constructor(curve) {
    validateString(curve, "curve");
    notImplemented("crypto.ECDH");
  }
  static convertKey(_key, _curve, _inputEncoding, _outputEncoding, _format3) {
    notImplemented("crypto.ECDH.prototype.convertKey");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.ECDH.prototype.computeSecret");
  }
  generateKeys(_encoding, _format3) {
    notImplemented("crypto.ECDH.prototype.generateKeys");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.ECDH.prototype.getPrivateKey");
  }
  getPublicKey(_encoding, _format3) {
    notImplemented("crypto.ECDH.prototype.getPublicKey");
  }
  setPrivateKey(_privateKey, _encoding) {
    notImplemented("crypto.ECDH.prototype.setPrivateKey");
  }
};
function diffieHellman(_options) {
  notImplemented("crypto.diffieHellman");
}
function assert2(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {
  };
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}
function BN(number, base2, endian) {
  if (BN.isBN(number)) {
    return number;
  }
  this.negative = 0;
  this.words = null;
  this.length = 0;
  this.red = null;
  if (number !== null) {
    if (base2 === "le" || base2 === "be") {
      endian = base2;
      base2 = 10;
    }
    this._init(number || 0, base2 || 10, endian || "be");
  }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
  if (num instanceof BN) {
    return true;
  }
  return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
  if (left.cmp(right) > 0)
    return left;
  return right;
};
BN.min = function min2(left, right) {
  if (left.cmp(right) < 0)
    return left;
  return right;
};
BN.prototype._init = function init(number, base2, endian) {
  if (typeof number === "number") {
    return this._initNumber(number, base2, endian);
  }
  if (typeof number === "object") {
    return this._initArray(number, base2, endian);
  }
  if (base2 === "hex") {
    base2 = 16;
  }
  assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
  number = number.toString().replace(/\s+/g, "");
  var start = 0;
  if (number[0] === "-") {
    start++;
    this.negative = 1;
  }
  if (start < number.length) {
    if (base2 === 16) {
      this._parseHex(number, start, endian);
    } else {
      this._parseBase(number, base2, start);
      if (endian === "le") {
        this._initArray(this.toArray(), base2, endian);
      }
    }
  }
};
BN.prototype._initNumber = function _initNumber(number, base2, endian) {
  if (number < 0) {
    this.negative = 1;
    number = -number;
  }
  if (number < 67108864) {
    this.words = [
      number & 67108863
    ];
    this.length = 1;
  } else if (number < 4503599627370496) {
    this.words = [
      number & 67108863,
      number / 67108864 & 67108863
    ];
    this.length = 2;
  } else {
    assert2(number < 9007199254740992);
    this.words = [
      number & 67108863,
      number / 67108864 & 67108863,
      1
    ];
    this.length = 3;
  }
  if (endian !== "le")
    return;
  this._initArray(this.toArray(), base2, endian);
};
BN.prototype._initArray = function _initArray(number, base2, endian) {
  assert2(typeof number.length === "number");
  if (number.length <= 0) {
    this.words = [
      0
    ];
    this.length = 1;
    return this;
  }
  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    this.words[i] = 0;
  }
  var j13, w24;
  var off = 0;
  if (endian === "be") {
    for (i = number.length - 1, j13 = 0; i >= 0; i -= 3) {
      w24 = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
      this.words[j13] |= w24 << off & 67108863;
      this.words[j13 + 1] = w24 >>> 26 - off & 67108863;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j13++;
      }
    }
  } else if (endian === "le") {
    for (i = 0, j13 = 0; i < number.length; i += 3) {
      w24 = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
      this.words[j13] |= w24 << off & 67108863;
      this.words[j13 + 1] = w24 >>> 26 - off & 67108863;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j13++;
      }
    }
  }
  return this._strip();
};
function parseHex4Bits(string, index) {
  var c13 = string.charCodeAt(index);
  if (c13 >= 48 && c13 <= 57) {
    return c13 - 48;
  } else if (c13 >= 65 && c13 <= 70) {
    return c13 - 55;
  } else if (c13 >= 97 && c13 <= 102) {
    return c13 - 87;
  } else {
    assert2(false, "Invalid character in " + string);
  }
}
function parseHexByte(string, lowerBound, index) {
  var r2 = parseHex4Bits(string, index);
  if (index - 1 >= lowerBound) {
    r2 |= parseHex4Bits(string, index - 1) << 4;
  }
  return r2;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    this.words[i] = 0;
  }
  var off = 0;
  var j13 = 0;
  var w24;
  if (endian === "be") {
    for (i = number.length - 1; i >= start; i -= 2) {
      w24 = parseHexByte(number, start, i) << off;
      this.words[j13] |= w24 & 67108863;
      if (off >= 18) {
        off -= 18;
        j13 += 1;
        this.words[j13] |= w24 >>> 26;
      } else {
        off += 8;
      }
    }
  } else {
    var parseLength = number.length - start;
    for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
      w24 = parseHexByte(number, start, i) << off;
      this.words[j13] |= w24 & 67108863;
      if (off >= 18) {
        off -= 18;
        j13 += 1;
        this.words[j13] |= w24 >>> 26;
      } else {
        off += 8;
      }
    }
  }
  this._strip();
};
function parseBase(str, start, end, mul4) {
  var r2 = 0;
  var b15 = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c13 = str.charCodeAt(i) - 48;
    r2 *= mul4;
    if (c13 >= 49) {
      b15 = c13 - 49 + 10;
    } else if (c13 >= 17) {
      b15 = c13 - 17 + 10;
    } else {
      b15 = c13;
    }
    assert2(c13 >= 0 && b15 < mul4, "Invalid character");
    r2 += b15;
  }
  return r2;
}
BN.prototype._parseBase = function _parseBase(number, base2, start) {
  this.words = [
    0
  ];
  this.length = 1;
  for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
    limbLen++;
  }
  limbLen--;
  limbPow = limbPow / base2 | 0;
  var total = number.length - start;
  var mod114 = total % limbLen;
  var end = Math.min(total, total - mod114) + start;
  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base2);
    this.imuln(limbPow);
    if (this.words[0] + word < 67108864) {
      this.words[0] += word;
    } else {
      this._iaddn(word);
    }
  }
  if (mod114 !== 0) {
    var pow3 = 1;
    word = parseBase(number, i, number.length, base2);
    for (i = 0; i < mod114; i++) {
      pow3 *= base2;
    }
    this.imuln(pow3);
    if (this.words[0] + word < 67108864) {
      this.words[0] += word;
    } else {
      this._iaddn(word);
    }
  }
  this._strip();
};
BN.prototype.copy = function copy2(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    dest.words[i] = this.words[i];
  }
  dest.length = this.length;
  dest.negative = this.negative;
  dest.red = this.red;
};
function move(dest, src) {
  dest.words = src.words;
  dest.length = src.length;
  dest.negative = src.negative;
  dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
  move(dest, this);
};
BN.prototype.clone = function clone() {
  var r2 = new BN(null);
  this.copy(r2);
  return r2;
};
BN.prototype._expand = function _expand(size) {
  while (this.length < size) {
    this.words[this.length++] = 0;
  }
  return this;
};
BN.prototype._strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0) {
    this.length--;
  }
  return this._normSign();
};
BN.prototype._normSign = function _normSign() {
  if (this.length === 1 && this.words[0] === 0) {
    this.negative = 0;
  }
  return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
  try {
    BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
  } catch (e) {
    BN.prototype.inspect = inspect1;
  }
} else {
  BN.prototype.inspect = inspect1;
}
function inspect1() {
  return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
  "",
  "0",
  "00",
  "000",
  "0000",
  "00000",
  "000000",
  "0000000",
  "00000000",
  "000000000",
  "0000000000",
  "00000000000",
  "000000000000",
  "0000000000000",
  "00000000000000",
  "000000000000000",
  "0000000000000000",
  "00000000000000000",
  "000000000000000000",
  "0000000000000000000",
  "00000000000000000000",
  "000000000000000000000",
  "0000000000000000000000",
  "00000000000000000000000",
  "000000000000000000000000",
  "0000000000000000000000000"
];
var groupSizes = [
  0,
  0,
  25,
  16,
  12,
  11,
  10,
  9,
  8,
  8,
  7,
  7,
  7,
  7,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5
];
var groupBases = [
  0,
  0,
  33554432,
  43046721,
  16777216,
  48828125,
  60466176,
  40353607,
  16777216,
  43046721,
  1e7,
  19487171,
  35831808,
  62748517,
  7529536,
  11390625,
  16777216,
  24137569,
  34012224,
  47045881,
  64e6,
  4084101,
  5153632,
  6436343,
  7962624,
  9765625,
  11881376,
  14348907,
  17210368,
  20511149,
  243e5,
  28629151,
  33554432,
  39135393,
  45435424,
  52521875,
  60466176
];
BN.prototype.toString = function toString2(base2, padding) {
  base2 = base2 || 10;
  padding = padding | 0 || 1;
  var out;
  if (base2 === 16 || base2 === "hex") {
    out = "";
    var off = 0;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w24 = this.words[i];
      var word = ((w24 << off | carry) & 16777215).toString(16);
      carry = w24 >>> 24 - off & 16777215;
      if (carry !== 0 || i !== this.length - 1) {
        out = zeros[6 - word.length] + word + out;
      } else {
        out = word + out;
      }
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0) {
      out = carry.toString(16) + out;
    }
    while (out.length % padding !== 0) {
      out = "0" + out;
    }
    if (this.negative !== 0) {
      out = "-" + out;
    }
    return out;
  }
  if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
    var groupSize = groupSizes[base2];
    var groupBase = groupBases[base2];
    out = "";
    var c13 = this.clone();
    c13.negative = 0;
    while (!c13.isZero()) {
      var r2 = c13.modrn(groupBase).toString(base2);
      c13 = c13.idivn(groupBase);
      if (!c13.isZero()) {
        out = zeros[groupSize - r2.length] + r2 + out;
      } else {
        out = r2 + out;
      }
    }
    if (this.isZero()) {
      out = "0" + out;
    }
    while (out.length % padding !== 0) {
      out = "0" + out;
    }
    if (this.negative !== 0) {
      out = "-" + out;
    }
    return out;
  }
  assert2(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
  var ret = this.words[0];
  if (this.length === 2) {
    ret += this.words[1] * 67108864;
  } else if (this.length === 3 && this.words[2] === 1) {
    ret += 4503599627370496 + this.words[1] * 67108864;
  } else if (this.length > 2) {
    assert2(false, "Number can only safely store up to 53 bits");
  }
  return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON2() {
  return this.toString(16, 2);
};
if (Buffer2) {
  BN.prototype.toBuffer = function toBuffer2(endian, length) {
    return this.toArrayLike(Buffer2, endian, length);
  };
}
BN.prototype.toArray = function toArray2(endian, length) {
  return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate2(ArrayType, size) {
  if (ArrayType.allocUnsafe) {
    return ArrayType.allocUnsafe(size);
  }
  return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
  this._strip();
  var byteLength3 = this.byteLength();
  var reqLength = length || Math.max(1, byteLength3);
  assert2(byteLength3 <= reqLength, "byte array longer than desired length");
  assert2(reqLength > 0, "Requested array length <= 0");
  var res = allocate(ArrayType, reqLength);
  var postfix = endian === "le" ? "LE" : "BE";
  this["_toArrayLike" + postfix](res, byteLength3);
  return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength3) {
  var position = 0;
  var carry = 0;
  for (var i = 0, shift = 0; i < this.length; i++) {
    var word = this.words[i] << shift | carry;
    res[position++] = word & 255;
    if (position < res.length) {
      res[position++] = word >> 8 & 255;
    }
    if (position < res.length) {
      res[position++] = word >> 16 & 255;
    }
    if (shift === 6) {
      if (position < res.length) {
        res[position++] = word >> 24 & 255;
      }
      carry = 0;
      shift = 0;
    } else {
      carry = word >>> 24;
      shift += 2;
    }
  }
  if (position < res.length) {
    res[position++] = carry;
    while (position < res.length) {
      res[position++] = 0;
    }
  }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength3) {
  var position = res.length - 1;
  var carry = 0;
  for (var i = 0, shift = 0; i < this.length; i++) {
    var word = this.words[i] << shift | carry;
    res[position--] = word & 255;
    if (position >= 0) {
      res[position--] = word >> 8 & 255;
    }
    if (position >= 0) {
      res[position--] = word >> 16 & 255;
    }
    if (shift === 6) {
      if (position >= 0) {
        res[position--] = word >> 24 & 255;
      }
      carry = 0;
      shift = 0;
    } else {
      carry = word >>> 24;
      shift += 2;
    }
  }
  if (position >= 0) {
    res[position--] = carry;
    while (position >= 0) {
      res[position--] = 0;
    }
  }
};
if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w24) {
    return 32 - Math.clz32(w24);
  };
} else {
  BN.prototype._countBits = function _countBits(w24) {
    var t2 = w24;
    var r2 = 0;
    if (t2 >= 4096) {
      r2 += 13;
      t2 >>>= 13;
    }
    if (t2 >= 64) {
      r2 += 7;
      t2 >>>= 7;
    }
    if (t2 >= 8) {
      r2 += 4;
      t2 >>>= 4;
    }
    if (t2 >= 2) {
      r2 += 2;
      t2 >>>= 2;
    }
    return r2 + t2;
  };
}
BN.prototype._zeroBits = function _zeroBits(w24) {
  if (w24 === 0)
    return 26;
  var t2 = w24;
  var r2 = 0;
  if ((t2 & 8191) === 0) {
    r2 += 13;
    t2 >>>= 13;
  }
  if ((t2 & 127) === 0) {
    r2 += 7;
    t2 >>>= 7;
  }
  if ((t2 & 15) === 0) {
    r2 += 4;
    t2 >>>= 4;
  }
  if ((t2 & 3) === 0) {
    r2 += 2;
    t2 >>>= 2;
  }
  if ((t2 & 1) === 0) {
    r2++;
  }
  return r2;
};
BN.prototype.bitLength = function bitLength() {
  var w24 = this.words[this.length - 1];
  var hi = this._countBits(w24);
  return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
  var w24 = new Array(num.bitLength());
  for (var bit = 0; bit < w24.length; bit++) {
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    w24[bit] = num.words[off] >>> wbit & 1;
  }
  return w24;
}
BN.prototype.zeroBits = function zeroBits() {
  if (this.isZero())
    return 0;
  var r2 = 0;
  for (var i = 0; i < this.length; i++) {
    var b15 = this._zeroBits(this.words[i]);
    r2 += b15;
    if (b15 !== 26)
      break;
  }
  return r2;
};
BN.prototype.byteLength = function byteLength2() {
  return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
  if (this.negative !== 0) {
    return this.abs().inotn(width).iaddn(1);
  }
  return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
  if (this.testn(width - 1)) {
    return this.notn(width).iaddn(1).ineg();
  }
  return this.clone();
};
BN.prototype.isNeg = function isNeg() {
  return this.negative !== 0;
};
BN.prototype.neg = function neg() {
  return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
  if (!this.isZero()) {
    this.negative ^= 1;
  }
  return this;
};
BN.prototype.iuor = function iuor(num) {
  while (this.length < num.length) {
    this.words[this.length++] = 0;
  }
  for (var i = 0; i < num.length; i++) {
    this.words[i] = this.words[i] | num.words[i];
  }
  return this._strip();
};
BN.prototype.ior = function ior(num) {
  assert2((this.negative | num.negative) === 0);
  return this.iuor(num);
};
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
  if (this.length > num.length)
    return this.clone().iuor(num);
  return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
  var b15;
  if (this.length > num.length) {
    b15 = num;
  } else {
    b15 = this;
  }
  for (var i = 0; i < b15.length; i++) {
    this.words[i] = this.words[i] & num.words[i];
  }
  this.length = b15.length;
  return this._strip();
};
BN.prototype.iand = function iand(num) {
  assert2((this.negative | num.negative) === 0);
  return this.iuand(num);
};
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
  if (this.length > num.length)
    return this.clone().iuand(num);
  return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
  var a7;
  var b15;
  if (this.length > num.length) {
    a7 = this;
    b15 = num;
  } else {
    a7 = num;
    b15 = this;
  }
  for (var i = 0; i < b15.length; i++) {
    this.words[i] = a7.words[i] ^ b15.words[i];
  }
  if (this !== a7) {
    for (; i < a7.length; i++) {
      this.words[i] = a7.words[i];
    }
  }
  this.length = a7.length;
  return this._strip();
};
BN.prototype.ixor = function ixor(num) {
  assert2((this.negative | num.negative) === 0);
  return this.iuxor(num);
};
BN.prototype.xor = function xor2(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
  if (this.length > num.length)
    return this.clone().iuxor(num);
  return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
  assert2(typeof width === "number" && width >= 0);
  var bytesNeeded = Math.ceil(width / 26) | 0;
  var bitsLeft = width % 26;
  this._expand(bytesNeeded);
  if (bitsLeft > 0) {
    bytesNeeded--;
  }
  for (var i = 0; i < bytesNeeded; i++) {
    this.words[i] = ~this.words[i] & 67108863;
  }
  if (bitsLeft > 0) {
    this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
  }
  return this._strip();
};
BN.prototype.notn = function notn(width) {
  return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
  assert2(typeof bit === "number" && bit >= 0);
  var off = bit / 26 | 0;
  var wbit = bit % 26;
  this._expand(off + 1);
  if (val) {
    this.words[off] = this.words[off] | 1 << wbit;
  } else {
    this.words[off] = this.words[off] & ~(1 << wbit);
  }
  return this._strip();
};
BN.prototype.iadd = function iadd(num) {
  var r2;
  if (this.negative !== 0 && num.negative === 0) {
    this.negative = 0;
    r2 = this.isub(num);
    this.negative ^= 1;
    return this._normSign();
  } else if (this.negative === 0 && num.negative !== 0) {
    num.negative = 0;
    r2 = this.isub(num);
    num.negative = 1;
    return r2._normSign();
  }
  var a7, b15;
  if (this.length > num.length) {
    a7 = this;
    b15 = num;
  } else {
    a7 = num;
    b15 = this;
  }
  var carry = 0;
  for (var i = 0; i < b15.length; i++) {
    r2 = (a7.words[i] | 0) + (b15.words[i] | 0) + carry;
    this.words[i] = r2 & 67108863;
    carry = r2 >>> 26;
  }
  for (; carry !== 0 && i < a7.length; i++) {
    r2 = (a7.words[i] | 0) + carry;
    this.words[i] = r2 & 67108863;
    carry = r2 >>> 26;
  }
  this.length = a7.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  } else if (a7 !== this) {
    for (; i < a7.length; i++) {
      this.words[i] = a7.words[i];
    }
  }
  return this;
};
BN.prototype.add = function add(num) {
  var res;
  if (num.negative !== 0 && this.negative === 0) {
    num.negative = 0;
    res = this.sub(num);
    num.negative ^= 1;
    return res;
  } else if (num.negative === 0 && this.negative !== 0) {
    this.negative = 0;
    res = num.sub(this);
    this.negative = 1;
    return res;
  }
  if (this.length > num.length)
    return this.clone().iadd(num);
  return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
  if (num.negative !== 0) {
    num.negative = 0;
    var r2 = this.iadd(num);
    num.negative = 1;
    return r2._normSign();
  } else if (this.negative !== 0) {
    this.negative = 0;
    this.iadd(num);
    this.negative = 1;
    return this._normSign();
  }
  var cmp2 = this.cmp(num);
  if (cmp2 === 0) {
    this.negative = 0;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }
  var a7, b15;
  if (cmp2 > 0) {
    a7 = this;
    b15 = num;
  } else {
    a7 = num;
    b15 = this;
  }
  var carry = 0;
  for (var i = 0; i < b15.length; i++) {
    r2 = (a7.words[i] | 0) - (b15.words[i] | 0) + carry;
    carry = r2 >> 26;
    this.words[i] = r2 & 67108863;
  }
  for (; carry !== 0 && i < a7.length; i++) {
    r2 = (a7.words[i] | 0) + carry;
    carry = r2 >> 26;
    this.words[i] = r2 & 67108863;
  }
  if (carry === 0 && i < a7.length && a7 !== this) {
    for (; i < a7.length; i++) {
      this.words[i] = a7.words[i];
    }
  }
  this.length = Math.max(this.length, i);
  if (a7 !== this) {
    this.negative = 1;
  }
  return this._strip();
};
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};
function smallMulTo(self1, num, out) {
  out.negative = num.negative ^ self1.negative;
  var len = self1.length + num.length | 0;
  out.length = len;
  len = len - 1 | 0;
  var a7 = self1.words[0] | 0;
  var b15 = num.words[0] | 0;
  var r2 = a7 * b15;
  var lo = r2 & 67108863;
  var carry = r2 / 67108864 | 0;
  out.words[0] = lo;
  for (var k15 = 1; k15 < len; k15++) {
    var ncarry = carry >>> 26;
    var rword = carry & 67108863;
    var maxJ = Math.min(k15, num.length - 1);
    for (var j13 = Math.max(0, k15 - self1.length + 1); j13 <= maxJ; j13++) {
      var i = k15 - j13 | 0;
      a7 = self1.words[i] | 0;
      b15 = num.words[j13] | 0;
      r2 = a7 * b15 + rword;
      ncarry += r2 / 67108864 | 0;
      rword = r2 & 67108863;
    }
    out.words[k15] = rword | 0;
    carry = ncarry | 0;
  }
  if (carry !== 0) {
    out.words[k15] = carry | 0;
  } else {
    out.length--;
  }
  return out._strip();
}
var comb10MulTo = function comb10MulTo2(self1, num, out) {
  var a7 = self1.words;
  var b15 = num.words;
  var o6 = out.words;
  var c13 = 0;
  var lo;
  var mid;
  var hi;
  var a0 = a7[0] | 0;
  var al0 = a0 & 8191;
  var ah0 = a0 >>> 13;
  var a12 = a7[1] | 0;
  var al1 = a12 & 8191;
  var ah1 = a12 >>> 13;
  var a22 = a7[2] | 0;
  var al2 = a22 & 8191;
  var ah2 = a22 >>> 13;
  var a32 = a7[3] | 0;
  var al3 = a32 & 8191;
  var ah3 = a32 >>> 13;
  var a42 = a7[4] | 0;
  var al4 = a42 & 8191;
  var ah4 = a42 >>> 13;
  var a52 = a7[5] | 0;
  var al5 = a52 & 8191;
  var ah5 = a52 >>> 13;
  var a62 = a7[6] | 0;
  var al6 = a62 & 8191;
  var ah6 = a62 >>> 13;
  var a72 = a7[7] | 0;
  var al7 = a72 & 8191;
  var ah7 = a72 >>> 13;
  var a8 = a7[8] | 0;
  var al8 = a8 & 8191;
  var ah8 = a8 >>> 13;
  var a9 = a7[9] | 0;
  var al9 = a9 & 8191;
  var ah9 = a9 >>> 13;
  var b0 = b15[0] | 0;
  var bl0 = b0 & 8191;
  var bh0 = b0 >>> 13;
  var b16 = b15[1] | 0;
  var bl1 = b16 & 8191;
  var bh1 = b16 >>> 13;
  var b22 = b15[2] | 0;
  var bl2 = b22 & 8191;
  var bh2 = b22 >>> 13;
  var b32 = b15[3] | 0;
  var bl3 = b32 & 8191;
  var bh3 = b32 >>> 13;
  var b42 = b15[4] | 0;
  var bl4 = b42 & 8191;
  var bh4 = b42 >>> 13;
  var b52 = b15[5] | 0;
  var bl5 = b52 & 8191;
  var bh5 = b52 >>> 13;
  var b62 = b15[6] | 0;
  var bl6 = b62 & 8191;
  var bh6 = b62 >>> 13;
  var b72 = b15[7] | 0;
  var bl7 = b72 & 8191;
  var bh7 = b72 >>> 13;
  var b82 = b15[8] | 0;
  var bl8 = b82 & 8191;
  var bh8 = b82 >>> 13;
  var b92 = b15[9] | 0;
  var bl9 = b92 & 8191;
  var bh9 = b92 >>> 13;
  out.negative = self1.negative ^ num.negative;
  out.length = 19;
  lo = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = mid + Math.imul(ah0, bl0) | 0;
  hi = Math.imul(ah0, bh0);
  var w02 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
  w02 &= 67108863;
  lo = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = mid + Math.imul(ah1, bl0) | 0;
  hi = Math.imul(ah1, bh0);
  lo = lo + Math.imul(al0, bl1) | 0;
  mid = mid + Math.imul(al0, bh1) | 0;
  mid = mid + Math.imul(ah0, bl1) | 0;
  hi = hi + Math.imul(ah0, bh1) | 0;
  var w110 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w110 >>> 26) | 0;
  w110 &= 67108863;
  lo = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = mid + Math.imul(ah2, bl0) | 0;
  hi = Math.imul(ah2, bh0);
  lo = lo + Math.imul(al1, bl1) | 0;
  mid = mid + Math.imul(al1, bh1) | 0;
  mid = mid + Math.imul(ah1, bl1) | 0;
  hi = hi + Math.imul(ah1, bh1) | 0;
  lo = lo + Math.imul(al0, bl2) | 0;
  mid = mid + Math.imul(al0, bh2) | 0;
  mid = mid + Math.imul(ah0, bl2) | 0;
  hi = hi + Math.imul(ah0, bh2) | 0;
  var w24 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w24 >>> 26) | 0;
  w24 &= 67108863;
  lo = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = mid + Math.imul(ah3, bl0) | 0;
  hi = Math.imul(ah3, bh0);
  lo = lo + Math.imul(al2, bl1) | 0;
  mid = mid + Math.imul(al2, bh1) | 0;
  mid = mid + Math.imul(ah2, bl1) | 0;
  hi = hi + Math.imul(ah2, bh1) | 0;
  lo = lo + Math.imul(al1, bl2) | 0;
  mid = mid + Math.imul(al1, bh2) | 0;
  mid = mid + Math.imul(ah1, bl2) | 0;
  hi = hi + Math.imul(ah1, bh2) | 0;
  lo = lo + Math.imul(al0, bl3) | 0;
  mid = mid + Math.imul(al0, bh3) | 0;
  mid = mid + Math.imul(ah0, bl3) | 0;
  hi = hi + Math.imul(ah0, bh3) | 0;
  var w32 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
  w32 &= 67108863;
  lo = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = mid + Math.imul(ah4, bl0) | 0;
  hi = Math.imul(ah4, bh0);
  lo = lo + Math.imul(al3, bl1) | 0;
  mid = mid + Math.imul(al3, bh1) | 0;
  mid = mid + Math.imul(ah3, bl1) | 0;
  hi = hi + Math.imul(ah3, bh1) | 0;
  lo = lo + Math.imul(al2, bl2) | 0;
  mid = mid + Math.imul(al2, bh2) | 0;
  mid = mid + Math.imul(ah2, bl2) | 0;
  hi = hi + Math.imul(ah2, bh2) | 0;
  lo = lo + Math.imul(al1, bl3) | 0;
  mid = mid + Math.imul(al1, bh3) | 0;
  mid = mid + Math.imul(ah1, bl3) | 0;
  hi = hi + Math.imul(ah1, bh3) | 0;
  lo = lo + Math.imul(al0, bl4) | 0;
  mid = mid + Math.imul(al0, bh4) | 0;
  mid = mid + Math.imul(ah0, bl4) | 0;
  hi = hi + Math.imul(ah0, bh4) | 0;
  var w42 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
  w42 &= 67108863;
  lo = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = mid + Math.imul(ah5, bl0) | 0;
  hi = Math.imul(ah5, bh0);
  lo = lo + Math.imul(al4, bl1) | 0;
  mid = mid + Math.imul(al4, bh1) | 0;
  mid = mid + Math.imul(ah4, bl1) | 0;
  hi = hi + Math.imul(ah4, bh1) | 0;
  lo = lo + Math.imul(al3, bl2) | 0;
  mid = mid + Math.imul(al3, bh2) | 0;
  mid = mid + Math.imul(ah3, bl2) | 0;
  hi = hi + Math.imul(ah3, bh2) | 0;
  lo = lo + Math.imul(al2, bl3) | 0;
  mid = mid + Math.imul(al2, bh3) | 0;
  mid = mid + Math.imul(ah2, bl3) | 0;
  hi = hi + Math.imul(ah2, bh3) | 0;
  lo = lo + Math.imul(al1, bl4) | 0;
  mid = mid + Math.imul(al1, bh4) | 0;
  mid = mid + Math.imul(ah1, bl4) | 0;
  hi = hi + Math.imul(ah1, bh4) | 0;
  lo = lo + Math.imul(al0, bl5) | 0;
  mid = mid + Math.imul(al0, bh5) | 0;
  mid = mid + Math.imul(ah0, bl5) | 0;
  hi = hi + Math.imul(ah0, bh5) | 0;
  var w52 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
  w52 &= 67108863;
  lo = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = mid + Math.imul(ah6, bl0) | 0;
  hi = Math.imul(ah6, bh0);
  lo = lo + Math.imul(al5, bl1) | 0;
  mid = mid + Math.imul(al5, bh1) | 0;
  mid = mid + Math.imul(ah5, bl1) | 0;
  hi = hi + Math.imul(ah5, bh1) | 0;
  lo = lo + Math.imul(al4, bl2) | 0;
  mid = mid + Math.imul(al4, bh2) | 0;
  mid = mid + Math.imul(ah4, bl2) | 0;
  hi = hi + Math.imul(ah4, bh2) | 0;
  lo = lo + Math.imul(al3, bl3) | 0;
  mid = mid + Math.imul(al3, bh3) | 0;
  mid = mid + Math.imul(ah3, bl3) | 0;
  hi = hi + Math.imul(ah3, bh3) | 0;
  lo = lo + Math.imul(al2, bl4) | 0;
  mid = mid + Math.imul(al2, bh4) | 0;
  mid = mid + Math.imul(ah2, bl4) | 0;
  hi = hi + Math.imul(ah2, bh4) | 0;
  lo = lo + Math.imul(al1, bl5) | 0;
  mid = mid + Math.imul(al1, bh5) | 0;
  mid = mid + Math.imul(ah1, bl5) | 0;
  hi = hi + Math.imul(ah1, bh5) | 0;
  lo = lo + Math.imul(al0, bl6) | 0;
  mid = mid + Math.imul(al0, bh6) | 0;
  mid = mid + Math.imul(ah0, bl6) | 0;
  hi = hi + Math.imul(ah0, bh6) | 0;
  var w62 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
  w62 &= 67108863;
  lo = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = mid + Math.imul(ah7, bl0) | 0;
  hi = Math.imul(ah7, bh0);
  lo = lo + Math.imul(al6, bl1) | 0;
  mid = mid + Math.imul(al6, bh1) | 0;
  mid = mid + Math.imul(ah6, bl1) | 0;
  hi = hi + Math.imul(ah6, bh1) | 0;
  lo = lo + Math.imul(al5, bl2) | 0;
  mid = mid + Math.imul(al5, bh2) | 0;
  mid = mid + Math.imul(ah5, bl2) | 0;
  hi = hi + Math.imul(ah5, bh2) | 0;
  lo = lo + Math.imul(al4, bl3) | 0;
  mid = mid + Math.imul(al4, bh3) | 0;
  mid = mid + Math.imul(ah4, bl3) | 0;
  hi = hi + Math.imul(ah4, bh3) | 0;
  lo = lo + Math.imul(al3, bl4) | 0;
  mid = mid + Math.imul(al3, bh4) | 0;
  mid = mid + Math.imul(ah3, bl4) | 0;
  hi = hi + Math.imul(ah3, bh4) | 0;
  lo = lo + Math.imul(al2, bl5) | 0;
  mid = mid + Math.imul(al2, bh5) | 0;
  mid = mid + Math.imul(ah2, bl5) | 0;
  hi = hi + Math.imul(ah2, bh5) | 0;
  lo = lo + Math.imul(al1, bl6) | 0;
  mid = mid + Math.imul(al1, bh6) | 0;
  mid = mid + Math.imul(ah1, bl6) | 0;
  hi = hi + Math.imul(ah1, bh6) | 0;
  lo = lo + Math.imul(al0, bl7) | 0;
  mid = mid + Math.imul(al0, bh7) | 0;
  mid = mid + Math.imul(ah0, bl7) | 0;
  hi = hi + Math.imul(ah0, bh7) | 0;
  var w72 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
  w72 &= 67108863;
  lo = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = mid + Math.imul(ah8, bl0) | 0;
  hi = Math.imul(ah8, bh0);
  lo = lo + Math.imul(al7, bl1) | 0;
  mid = mid + Math.imul(al7, bh1) | 0;
  mid = mid + Math.imul(ah7, bl1) | 0;
  hi = hi + Math.imul(ah7, bh1) | 0;
  lo = lo + Math.imul(al6, bl2) | 0;
  mid = mid + Math.imul(al6, bh2) | 0;
  mid = mid + Math.imul(ah6, bl2) | 0;
  hi = hi + Math.imul(ah6, bh2) | 0;
  lo = lo + Math.imul(al5, bl3) | 0;
  mid = mid + Math.imul(al5, bh3) | 0;
  mid = mid + Math.imul(ah5, bl3) | 0;
  hi = hi + Math.imul(ah5, bh3) | 0;
  lo = lo + Math.imul(al4, bl4) | 0;
  mid = mid + Math.imul(al4, bh4) | 0;
  mid = mid + Math.imul(ah4, bl4) | 0;
  hi = hi + Math.imul(ah4, bh4) | 0;
  lo = lo + Math.imul(al3, bl5) | 0;
  mid = mid + Math.imul(al3, bh5) | 0;
  mid = mid + Math.imul(ah3, bl5) | 0;
  hi = hi + Math.imul(ah3, bh5) | 0;
  lo = lo + Math.imul(al2, bl6) | 0;
  mid = mid + Math.imul(al2, bh6) | 0;
  mid = mid + Math.imul(ah2, bl6) | 0;
  hi = hi + Math.imul(ah2, bh6) | 0;
  lo = lo + Math.imul(al1, bl7) | 0;
  mid = mid + Math.imul(al1, bh7) | 0;
  mid = mid + Math.imul(ah1, bl7) | 0;
  hi = hi + Math.imul(ah1, bh7) | 0;
  lo = lo + Math.imul(al0, bl8) | 0;
  mid = mid + Math.imul(al0, bh8) | 0;
  mid = mid + Math.imul(ah0, bl8) | 0;
  hi = hi + Math.imul(ah0, bh8) | 0;
  var w82 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w82 >>> 26) | 0;
  w82 &= 67108863;
  lo = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = mid + Math.imul(ah9, bl0) | 0;
  hi = Math.imul(ah9, bh0);
  lo = lo + Math.imul(al8, bl1) | 0;
  mid = mid + Math.imul(al8, bh1) | 0;
  mid = mid + Math.imul(ah8, bl1) | 0;
  hi = hi + Math.imul(ah8, bh1) | 0;
  lo = lo + Math.imul(al7, bl2) | 0;
  mid = mid + Math.imul(al7, bh2) | 0;
  mid = mid + Math.imul(ah7, bl2) | 0;
  hi = hi + Math.imul(ah7, bh2) | 0;
  lo = lo + Math.imul(al6, bl3) | 0;
  mid = mid + Math.imul(al6, bh3) | 0;
  mid = mid + Math.imul(ah6, bl3) | 0;
  hi = hi + Math.imul(ah6, bh3) | 0;
  lo = lo + Math.imul(al5, bl4) | 0;
  mid = mid + Math.imul(al5, bh4) | 0;
  mid = mid + Math.imul(ah5, bl4) | 0;
  hi = hi + Math.imul(ah5, bh4) | 0;
  lo = lo + Math.imul(al4, bl5) | 0;
  mid = mid + Math.imul(al4, bh5) | 0;
  mid = mid + Math.imul(ah4, bl5) | 0;
  hi = hi + Math.imul(ah4, bh5) | 0;
  lo = lo + Math.imul(al3, bl6) | 0;
  mid = mid + Math.imul(al3, bh6) | 0;
  mid = mid + Math.imul(ah3, bl6) | 0;
  hi = hi + Math.imul(ah3, bh6) | 0;
  lo = lo + Math.imul(al2, bl7) | 0;
  mid = mid + Math.imul(al2, bh7) | 0;
  mid = mid + Math.imul(ah2, bl7) | 0;
  hi = hi + Math.imul(ah2, bh7) | 0;
  lo = lo + Math.imul(al1, bl8) | 0;
  mid = mid + Math.imul(al1, bh8) | 0;
  mid = mid + Math.imul(ah1, bl8) | 0;
  hi = hi + Math.imul(ah1, bh8) | 0;
  lo = lo + Math.imul(al0, bl9) | 0;
  mid = mid + Math.imul(al0, bh9) | 0;
  mid = mid + Math.imul(ah0, bl9) | 0;
  hi = hi + Math.imul(ah0, bh9) | 0;
  var w92 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w92 >>> 26) | 0;
  w92 &= 67108863;
  lo = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = mid + Math.imul(ah9, bl1) | 0;
  hi = Math.imul(ah9, bh1);
  lo = lo + Math.imul(al8, bl2) | 0;
  mid = mid + Math.imul(al8, bh2) | 0;
  mid = mid + Math.imul(ah8, bl2) | 0;
  hi = hi + Math.imul(ah8, bh2) | 0;
  lo = lo + Math.imul(al7, bl3) | 0;
  mid = mid + Math.imul(al7, bh3) | 0;
  mid = mid + Math.imul(ah7, bl3) | 0;
  hi = hi + Math.imul(ah7, bh3) | 0;
  lo = lo + Math.imul(al6, bl4) | 0;
  mid = mid + Math.imul(al6, bh4) | 0;
  mid = mid + Math.imul(ah6, bl4) | 0;
  hi = hi + Math.imul(ah6, bh4) | 0;
  lo = lo + Math.imul(al5, bl5) | 0;
  mid = mid + Math.imul(al5, bh5) | 0;
  mid = mid + Math.imul(ah5, bl5) | 0;
  hi = hi + Math.imul(ah5, bh5) | 0;
  lo = lo + Math.imul(al4, bl6) | 0;
  mid = mid + Math.imul(al4, bh6) | 0;
  mid = mid + Math.imul(ah4, bl6) | 0;
  hi = hi + Math.imul(ah4, bh6) | 0;
  lo = lo + Math.imul(al3, bl7) | 0;
  mid = mid + Math.imul(al3, bh7) | 0;
  mid = mid + Math.imul(ah3, bl7) | 0;
  hi = hi + Math.imul(ah3, bh7) | 0;
  lo = lo + Math.imul(al2, bl8) | 0;
  mid = mid + Math.imul(al2, bh8) | 0;
  mid = mid + Math.imul(ah2, bl8) | 0;
  hi = hi + Math.imul(ah2, bh8) | 0;
  lo = lo + Math.imul(al1, bl9) | 0;
  mid = mid + Math.imul(al1, bh9) | 0;
  mid = mid + Math.imul(ah1, bl9) | 0;
  hi = hi + Math.imul(ah1, bh9) | 0;
  var w102 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w102 >>> 26) | 0;
  w102 &= 67108863;
  lo = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = mid + Math.imul(ah9, bl2) | 0;
  hi = Math.imul(ah9, bh2);
  lo = lo + Math.imul(al8, bl3) | 0;
  mid = mid + Math.imul(al8, bh3) | 0;
  mid = mid + Math.imul(ah8, bl3) | 0;
  hi = hi + Math.imul(ah8, bh3) | 0;
  lo = lo + Math.imul(al7, bl4) | 0;
  mid = mid + Math.imul(al7, bh4) | 0;
  mid = mid + Math.imul(ah7, bl4) | 0;
  hi = hi + Math.imul(ah7, bh4) | 0;
  lo = lo + Math.imul(al6, bl5) | 0;
  mid = mid + Math.imul(al6, bh5) | 0;
  mid = mid + Math.imul(ah6, bl5) | 0;
  hi = hi + Math.imul(ah6, bh5) | 0;
  lo = lo + Math.imul(al5, bl6) | 0;
  mid = mid + Math.imul(al5, bh6) | 0;
  mid = mid + Math.imul(ah5, bl6) | 0;
  hi = hi + Math.imul(ah5, bh6) | 0;
  lo = lo + Math.imul(al4, bl7) | 0;
  mid = mid + Math.imul(al4, bh7) | 0;
  mid = mid + Math.imul(ah4, bl7) | 0;
  hi = hi + Math.imul(ah4, bh7) | 0;
  lo = lo + Math.imul(al3, bl8) | 0;
  mid = mid + Math.imul(al3, bh8) | 0;
  mid = mid + Math.imul(ah3, bl8) | 0;
  hi = hi + Math.imul(ah3, bh8) | 0;
  lo = lo + Math.imul(al2, bl9) | 0;
  mid = mid + Math.imul(al2, bh9) | 0;
  mid = mid + Math.imul(ah2, bl9) | 0;
  hi = hi + Math.imul(ah2, bh9) | 0;
  var w112 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w112 >>> 26) | 0;
  w112 &= 67108863;
  lo = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = mid + Math.imul(ah9, bl3) | 0;
  hi = Math.imul(ah9, bh3);
  lo = lo + Math.imul(al8, bl4) | 0;
  mid = mid + Math.imul(al8, bh4) | 0;
  mid = mid + Math.imul(ah8, bl4) | 0;
  hi = hi + Math.imul(ah8, bh4) | 0;
  lo = lo + Math.imul(al7, bl5) | 0;
  mid = mid + Math.imul(al7, bh5) | 0;
  mid = mid + Math.imul(ah7, bl5) | 0;
  hi = hi + Math.imul(ah7, bh5) | 0;
  lo = lo + Math.imul(al6, bl6) | 0;
  mid = mid + Math.imul(al6, bh6) | 0;
  mid = mid + Math.imul(ah6, bl6) | 0;
  hi = hi + Math.imul(ah6, bh6) | 0;
  lo = lo + Math.imul(al5, bl7) | 0;
  mid = mid + Math.imul(al5, bh7) | 0;
  mid = mid + Math.imul(ah5, bl7) | 0;
  hi = hi + Math.imul(ah5, bh7) | 0;
  lo = lo + Math.imul(al4, bl8) | 0;
  mid = mid + Math.imul(al4, bh8) | 0;
  mid = mid + Math.imul(ah4, bl8) | 0;
  hi = hi + Math.imul(ah4, bh8) | 0;
  lo = lo + Math.imul(al3, bl9) | 0;
  mid = mid + Math.imul(al3, bh9) | 0;
  mid = mid + Math.imul(ah3, bl9) | 0;
  hi = hi + Math.imul(ah3, bh9) | 0;
  var w122 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
  w122 &= 67108863;
  lo = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = mid + Math.imul(ah9, bl4) | 0;
  hi = Math.imul(ah9, bh4);
  lo = lo + Math.imul(al8, bl5) | 0;
  mid = mid + Math.imul(al8, bh5) | 0;
  mid = mid + Math.imul(ah8, bl5) | 0;
  hi = hi + Math.imul(ah8, bh5) | 0;
  lo = lo + Math.imul(al7, bl6) | 0;
  mid = mid + Math.imul(al7, bh6) | 0;
  mid = mid + Math.imul(ah7, bl6) | 0;
  hi = hi + Math.imul(ah7, bh6) | 0;
  lo = lo + Math.imul(al6, bl7) | 0;
  mid = mid + Math.imul(al6, bh7) | 0;
  mid = mid + Math.imul(ah6, bl7) | 0;
  hi = hi + Math.imul(ah6, bh7) | 0;
  lo = lo + Math.imul(al5, bl8) | 0;
  mid = mid + Math.imul(al5, bh8) | 0;
  mid = mid + Math.imul(ah5, bl8) | 0;
  hi = hi + Math.imul(ah5, bh8) | 0;
  lo = lo + Math.imul(al4, bl9) | 0;
  mid = mid + Math.imul(al4, bh9) | 0;
  mid = mid + Math.imul(ah4, bl9) | 0;
  hi = hi + Math.imul(ah4, bh9) | 0;
  var w132 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w132 >>> 26) | 0;
  w132 &= 67108863;
  lo = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = mid + Math.imul(ah9, bl5) | 0;
  hi = Math.imul(ah9, bh5);
  lo = lo + Math.imul(al8, bl6) | 0;
  mid = mid + Math.imul(al8, bh6) | 0;
  mid = mid + Math.imul(ah8, bl6) | 0;
  hi = hi + Math.imul(ah8, bh6) | 0;
  lo = lo + Math.imul(al7, bl7) | 0;
  mid = mid + Math.imul(al7, bh7) | 0;
  mid = mid + Math.imul(ah7, bl7) | 0;
  hi = hi + Math.imul(ah7, bh7) | 0;
  lo = lo + Math.imul(al6, bl8) | 0;
  mid = mid + Math.imul(al6, bh8) | 0;
  mid = mid + Math.imul(ah6, bl8) | 0;
  hi = hi + Math.imul(ah6, bh8) | 0;
  lo = lo + Math.imul(al5, bl9) | 0;
  mid = mid + Math.imul(al5, bh9) | 0;
  mid = mid + Math.imul(ah5, bl9) | 0;
  hi = hi + Math.imul(ah5, bh9) | 0;
  var w142 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w142 >>> 26) | 0;
  w142 &= 67108863;
  lo = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = mid + Math.imul(ah9, bl6) | 0;
  hi = Math.imul(ah9, bh6);
  lo = lo + Math.imul(al8, bl7) | 0;
  mid = mid + Math.imul(al8, bh7) | 0;
  mid = mid + Math.imul(ah8, bl7) | 0;
  hi = hi + Math.imul(ah8, bh7) | 0;
  lo = lo + Math.imul(al7, bl8) | 0;
  mid = mid + Math.imul(al7, bh8) | 0;
  mid = mid + Math.imul(ah7, bl8) | 0;
  hi = hi + Math.imul(ah7, bh8) | 0;
  lo = lo + Math.imul(al6, bl9) | 0;
  mid = mid + Math.imul(al6, bh9) | 0;
  mid = mid + Math.imul(ah6, bl9) | 0;
  hi = hi + Math.imul(ah6, bh9) | 0;
  var w152 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w152 >>> 26) | 0;
  w152 &= 67108863;
  lo = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = mid + Math.imul(ah9, bl7) | 0;
  hi = Math.imul(ah9, bh7);
  lo = lo + Math.imul(al8, bl8) | 0;
  mid = mid + Math.imul(al8, bh8) | 0;
  mid = mid + Math.imul(ah8, bl8) | 0;
  hi = hi + Math.imul(ah8, bh8) | 0;
  lo = lo + Math.imul(al7, bl9) | 0;
  mid = mid + Math.imul(al7, bh9) | 0;
  mid = mid + Math.imul(ah7, bl9) | 0;
  hi = hi + Math.imul(ah7, bh9) | 0;
  var w162 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w162 >>> 26) | 0;
  w162 &= 67108863;
  lo = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = mid + Math.imul(ah9, bl8) | 0;
  hi = Math.imul(ah9, bh8);
  lo = lo + Math.imul(al8, bl9) | 0;
  mid = mid + Math.imul(al8, bh9) | 0;
  mid = mid + Math.imul(ah8, bl9) | 0;
  hi = hi + Math.imul(ah8, bh9) | 0;
  var w172 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w172 >>> 26) | 0;
  w172 &= 67108863;
  lo = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = mid + Math.imul(ah9, bl9) | 0;
  hi = Math.imul(ah9, bh9);
  var w182 = (c13 + lo | 0) + ((mid & 8191) << 13) | 0;
  c13 = (hi + (mid >>> 13) | 0) + (w182 >>> 26) | 0;
  w182 &= 67108863;
  o6[0] = w02;
  o6[1] = w110;
  o6[2] = w24;
  o6[3] = w32;
  o6[4] = w42;
  o6[5] = w52;
  o6[6] = w62;
  o6[7] = w72;
  o6[8] = w82;
  o6[9] = w92;
  o6[10] = w102;
  o6[11] = w112;
  o6[12] = w122;
  o6[13] = w132;
  o6[14] = w142;
  o6[15] = w152;
  o6[16] = w162;
  o6[17] = w172;
  o6[18] = w182;
  if (c13 !== 0) {
    o6[19] = c13;
    out.length++;
  }
  return out;
};
if (!Math.imul) {
  comb10MulTo = smallMulTo;
}
function bigMulTo(self1, num, out) {
  out.negative = num.negative ^ self1.negative;
  out.length = self1.length + num.length;
  var carry = 0;
  var hncarry = 0;
  for (var k15 = 0; k15 < out.length - 1; k15++) {
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 67108863;
    var maxJ = Math.min(k15, num.length - 1);
    for (var j13 = Math.max(0, k15 - self1.length + 1); j13 <= maxJ; j13++) {
      var i = k15 - j13;
      var a7 = self1.words[i] | 0;
      var b15 = num.words[j13] | 0;
      var r2 = a7 * b15;
      var lo = r2 & 67108863;
      ncarry = ncarry + (r2 / 67108864 | 0) | 0;
      lo = lo + rword | 0;
      rword = lo & 67108863;
      ncarry = ncarry + (lo >>> 26) | 0;
      hncarry += ncarry >>> 26;
      ncarry &= 67108863;
    }
    out.words[k15] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k15] = carry;
  } else {
    out.length--;
  }
  return out._strip();
}
function jumboMulTo(self1, num, out) {
  return bigMulTo(self1, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  var len = this.length + num.length;
  if (this.length === 10 && num.length === 10) {
    res = comb10MulTo(this, num, out);
  } else if (len < 63) {
    res = smallMulTo(this, num, out);
  } else if (len < 1024) {
    res = bigMulTo(this, num, out);
  } else {
    res = jumboMulTo(this, num, out);
  }
  return res;
};
function FFTM(x17, y16) {
  this.x = x17;
  this.y = y16;
}
FFTM.prototype.makeRBT = function makeRBT(N6) {
  var t2 = new Array(N6);
  var l22 = BN.prototype._countBits(N6) - 1;
  for (var i = 0; i < N6; i++) {
    t2[i] = this.revBin(i, l22, N6);
  }
  return t2;
};
FFTM.prototype.revBin = function revBin(x17, l22, N6) {
  if (x17 === 0 || x17 === N6 - 1)
    return x17;
  var rb = 0;
  for (var i = 0; i < l22; i++) {
    rb |= (x17 & 1) << l22 - i - 1;
    x17 >>= 1;
  }
  return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
  for (var i = 0; i < N6; i++) {
    rtws[i] = rws[rbt[i]];
    itws[i] = iws[rbt[i]];
  }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
  this.permute(rbt, rws, iws, rtws, itws, N6);
  for (var s10 = 1; s10 < N6; s10 <<= 1) {
    var l22 = s10 << 1;
    var rtwdf = Math.cos(2 * Math.PI / l22);
    var itwdf = Math.sin(2 * Math.PI / l22);
    for (var p7 = 0; p7 < N6; p7 += l22) {
      var rtwdf_ = rtwdf;
      var itwdf_ = itwdf;
      for (var j13 = 0; j13 < s10; j13++) {
        var re4 = rtws[p7 + j13];
        var ie3 = itws[p7 + j13];
        var ro = rtws[p7 + j13 + s10];
        var io = itws[p7 + j13 + s10];
        var rx = rtwdf_ * ro - itwdf_ * io;
        io = rtwdf_ * io + itwdf_ * ro;
        ro = rx;
        rtws[p7 + j13] = re4 + ro;
        itws[p7 + j13] = ie3 + io;
        rtws[p7 + j13 + s10] = re4 - ro;
        itws[p7 + j13 + s10] = ie3 - io;
        if (j13 !== l22) {
          rx = rtwdf * rtwdf_ - itwdf * itwdf_;
          itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
          rtwdf_ = rx;
        }
      }
    }
  }
};
FFTM.prototype.guessLen13b = function guessLen13b(n3, m20) {
  var N6 = Math.max(m20, n3) | 1;
  var odd = N6 & 1;
  var i = 0;
  for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
    i++;
  }
  return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
  if (N6 <= 1)
    return;
  for (var i = 0; i < N6 / 2; i++) {
    var t2 = rws[i];
    rws[i] = rws[N6 - i - 1];
    rws[N6 - i - 1] = t2;
    t2 = iws[i];
    iws[i] = -iws[N6 - i - 1];
    iws[N6 - i - 1] = -t2;
  }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N6) {
  var carry = 0;
  for (var i = 0; i < N6 / 2; i++) {
    var w24 = Math.round(ws[2 * i + 1] / N6) * 8192 + Math.round(ws[2 * i] / N6) + carry;
    ws[i] = w24 & 67108863;
    if (w24 < 67108864) {
      carry = 0;
    } else {
      carry = w24 / 67108864 | 0;
    }
  }
  return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N6) {
  var carry = 0;
  for (var i = 0; i < len; i++) {
    carry = carry + (ws[i] | 0);
    rws[2 * i] = carry & 8191;
    carry = carry >>> 13;
    rws[2 * i + 1] = carry & 8191;
    carry = carry >>> 13;
  }
  for (i = 2 * len; i < N6; ++i) {
    rws[i] = 0;
  }
  assert2(carry === 0);
  assert2((carry & ~8191) === 0);
};
FFTM.prototype.stub = function stub(N6) {
  var ph = new Array(N6);
  for (var i = 0; i < N6; i++) {
    ph[i] = 0;
  }
  return ph;
};
FFTM.prototype.mulp = function mulp(x17, y16, out) {
  var N6 = 2 * this.guessLen13b(x17.length, y16.length);
  var rbt = this.makeRBT(N6);
  var _11 = this.stub(N6);
  var rws = new Array(N6);
  var rwst = new Array(N6);
  var iwst = new Array(N6);
  var nrws = new Array(N6);
  var nrwst = new Array(N6);
  var niwst = new Array(N6);
  var rmws = out.words;
  rmws.length = N6;
  this.convert13b(x17.words, x17.length, rws, N6);
  this.convert13b(y16.words, y16.length, nrws, N6);
  this.transform(rws, _11, rwst, iwst, N6, rbt);
  this.transform(nrws, _11, nrwst, niwst, N6, rbt);
  for (var i = 0; i < N6; i++) {
    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
    rwst[i] = rx;
  }
  this.conjugate(rwst, iwst, N6);
  this.transform(rwst, iwst, rmws, _11, N6, rbt);
  this.conjugate(rmws, _11, N6);
  this.normalize13b(rmws, N6);
  out.negative = x17.negative ^ y16.negative;
  out.length = x17.length + y16.length;
  return out._strip();
};
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
  return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert2(typeof num === "number");
  assert2(num < 67108864);
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w24 = (this.words[i] | 0) * num;
    var lo = (w24 & 67108863) + (carry & 67108863);
    carry >>= 26;
    carry += w24 / 67108864 | 0;
    carry += lo >>> 26;
    this.words[i] = lo & 67108863;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};
BN.prototype.isqr = function isqr() {
  return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
  var w24 = toBitArray(num);
  if (w24.length === 0)
    return new BN(1);
  var res = this;
  for (var i = 0; i < w24.length; i++, res = res.sqr()) {
    if (w24[i] !== 0)
      break;
  }
  if (++i < w24.length) {
    for (var q15 = res.sqr(); i < w24.length; i++, q15 = q15.sqr()) {
      if (w24[i] === 0)
        continue;
      res = res.mul(q15);
    }
  }
  return res;
};
BN.prototype.iushln = function iushln(bits) {
  assert2(typeof bits === "number" && bits >= 0);
  var r2 = bits % 26;
  var s10 = (bits - r2) / 26;
  var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
  var i;
  if (r2 !== 0) {
    var carry = 0;
    for (i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c13 = (this.words[i] | 0) - newCarry << r2;
      this.words[i] = c13 | carry;
      carry = newCarry >>> 26 - r2;
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }
  if (s10 !== 0) {
    for (i = this.length - 1; i >= 0; i--) {
      this.words[i + s10] = this.words[i];
    }
    for (i = 0; i < s10; i++) {
      this.words[i] = 0;
    }
    this.length += s10;
  }
  return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
  assert2(this.negative === 0);
  return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
  assert2(typeof bits === "number" && bits >= 0);
  var h16;
  if (hint) {
    h16 = (hint - hint % 26) / 26;
  } else {
    h16 = 0;
  }
  var r2 = bits % 26;
  var s10 = Math.min((bits - r2) / 26, this.length);
  var mask = 67108863 ^ 67108863 >>> r2 << r2;
  var maskedWords = extended;
  h16 -= s10;
  h16 = Math.max(0, h16);
  if (maskedWords) {
    for (var i = 0; i < s10; i++) {
      maskedWords.words[i] = this.words[i];
    }
    maskedWords.length = s10;
  }
  if (s10 === 0) {
  } else if (this.length > s10) {
    this.length -= s10;
    for (i = 0; i < this.length; i++) {
      this.words[i] = this.words[i + s10];
    }
  } else {
    this.words[0] = 0;
    this.length = 1;
  }
  var carry = 0;
  for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h16); i--) {
    var word = this.words[i] | 0;
    this.words[i] = carry << 26 - r2 | word >>> r2;
    carry = word & mask;
  }
  if (maskedWords && carry !== 0) {
    maskedWords.words[maskedWords.length++] = carry;
  }
  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }
  return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert2(this.negative === 0);
  return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
  return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
  return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
  assert2(typeof bit === "number" && bit >= 0);
  var r2 = bit % 26;
  var s10 = (bit - r2) / 26;
  var q15 = 1 << r2;
  if (this.length <= s10)
    return false;
  var w24 = this.words[s10];
  return !!(w24 & q15);
};
BN.prototype.imaskn = function imaskn(bits) {
  assert2(typeof bits === "number" && bits >= 0);
  var r2 = bits % 26;
  var s10 = (bits - r2) / 26;
  assert2(this.negative === 0, "imaskn works only with positive numbers");
  if (this.length <= s10) {
    return this;
  }
  if (r2 !== 0) {
    s10++;
  }
  this.length = Math.min(s10, this.length);
  if (r2 !== 0) {
    var mask = 67108863 ^ 67108863 >>> r2 << r2;
    this.words[this.length - 1] &= mask;
  }
  return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
  assert2(typeof num === "number");
  assert2(num < 67108864);
  if (num < 0)
    return this.isubn(-num);
  if (this.negative !== 0) {
    if (this.length === 1 && (this.words[0] | 0) <= num) {
      this.words[0] = num - (this.words[0] | 0);
      this.negative = 0;
      return this;
    }
    this.negative = 0;
    this.isubn(num);
    this.negative = 1;
    return this;
  }
  return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;
  for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
    this.words[i] -= 67108864;
    if (i === this.length - 1) {
      this.words[i + 1] = 1;
    } else {
      this.words[i + 1]++;
    }
  }
  this.length = Math.max(this.length, i + 1);
  return this;
};
BN.prototype.isubn = function isubn(num) {
  assert2(typeof num === "number");
  assert2(num < 67108864);
  if (num < 0)
    return this.iaddn(-num);
  if (this.negative !== 0) {
    this.negative = 0;
    this.iaddn(num);
    this.negative = 1;
    return this;
  }
  this.words[0] -= num;
  if (this.length === 1 && this.words[0] < 0) {
    this.words[0] = -this.words[0];
    this.negative = 1;
  } else {
    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 67108864;
      this.words[i + 1] -= 1;
    }
  }
  return this._strip();
};
BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
  this.negative = 0;
  return this;
};
BN.prototype.abs = function abs() {
  return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift) {
  var len = num.length + shift;
  var i;
  this._expand(len);
  var w24;
  var carry = 0;
  for (i = 0; i < num.length; i++) {
    w24 = (this.words[i + shift] | 0) + carry;
    var right = (num.words[i] | 0) * mul4;
    w24 -= right & 67108863;
    carry = (w24 >> 26) - (right / 67108864 | 0);
    this.words[i + shift] = w24 & 67108863;
  }
  for (; i < this.length - shift; i++) {
    w24 = (this.words[i + shift] | 0) + carry;
    carry = w24 >> 26;
    this.words[i + shift] = w24 & 67108863;
  }
  if (carry === 0)
    return this._strip();
  assert2(carry === -1);
  carry = 0;
  for (i = 0; i < this.length; i++) {
    w24 = -(this.words[i] | 0) + carry;
    carry = w24 >> 26;
    this.words[i] = w24 & 67108863;
  }
  this.negative = 1;
  return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;
  var a7 = this.clone();
  var b15 = num;
  var bhi = b15.words[b15.length - 1] | 0;
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b15 = b15.ushln(shift);
    a7.iushln(shift);
    bhi = b15.words[b15.length - 1] | 0;
  }
  var m20 = a7.length - b15.length;
  var q15;
  if (mode !== "mod") {
    q15 = new BN(null);
    q15.length = m20 + 1;
    q15.words = new Array(q15.length);
    for (var i = 0; i < q15.length; i++) {
      q15.words[i] = 0;
    }
  }
  var diff2 = a7.clone()._ishlnsubmul(b15, 1, m20);
  if (diff2.negative === 0) {
    a7 = diff2;
    if (q15) {
      q15.words[m20] = 1;
    }
  }
  for (var j13 = m20 - 1; j13 >= 0; j13--) {
    var qj = (a7.words[b15.length + j13] | 0) * 67108864 + (a7.words[b15.length + j13 - 1] | 0);
    qj = Math.min(qj / bhi | 0, 67108863);
    a7._ishlnsubmul(b15, qj, j13);
    while (a7.negative !== 0) {
      qj--;
      a7.negative = 0;
      a7._ishlnsubmul(b15, 1, j13);
      if (!a7.isZero()) {
        a7.negative ^= 1;
      }
    }
    if (q15) {
      q15.words[j13] = qj;
    }
  }
  if (q15) {
    q15._strip();
  }
  a7._strip();
  if (mode !== "div" && shift !== 0) {
    a7.iushrn(shift);
  }
  return {
    div: q15 || null,
    mod: a7
  };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
  assert2(!num.isZero());
  if (this.isZero()) {
    return {
      div: new BN(0),
      mod: new BN(0)
    };
  }
  var div2, mod114, res;
  if (this.negative !== 0 && num.negative === 0) {
    res = this.neg().divmod(num, mode);
    if (mode !== "mod") {
      div2 = res.div.neg();
    }
    if (mode !== "div") {
      mod114 = res.mod.neg();
      if (positive && mod114.negative !== 0) {
        mod114.iadd(num);
      }
    }
    return {
      div: div2,
      mod: mod114
    };
  }
  if (this.negative === 0 && num.negative !== 0) {
    res = this.divmod(num.neg(), mode);
    if (mode !== "mod") {
      div2 = res.div.neg();
    }
    return {
      div: div2,
      mod: res.mod
    };
  }
  if ((this.negative & num.negative) !== 0) {
    res = this.neg().divmod(num.neg(), mode);
    if (mode !== "div") {
      mod114 = res.mod.neg();
      if (positive && mod114.negative !== 0) {
        mod114.isub(num);
      }
    }
    return {
      div: res.div,
      mod: mod114
    };
  }
  if (num.length > this.length || this.cmp(num) < 0) {
    return {
      div: new BN(0),
      mod: this
    };
  }
  if (num.length === 1) {
    if (mode === "div") {
      return {
        div: this.divn(num.words[0]),
        mod: null
      };
    }
    if (mode === "mod") {
      return {
        div: null,
        mod: new BN(this.modrn(num.words[0]))
      };
    }
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modrn(num.words[0]))
    };
  }
  return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
  return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod14(num) {
  return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
  return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);
  if (dm.mod.isZero())
    return dm.div;
  var mod114 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
  var half = num.ushrn(1);
  var r2 = num.andln(1);
  var cmp2 = mod114.cmp(half);
  if (cmp2 < 0 || r2 === 1 && cmp2 === 0)
    return dm.div;
  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert2(num <= 67108863);
  var p7 = (1 << 26) % num;
  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    acc = (p7 * acc + (this.words[i] | 0)) % num;
  }
  return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
  return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert2(num <= 67108863);
  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w24 = (this.words[i] | 0) + carry * 67108864;
    this.words[i] = w24 / num | 0;
    carry = w24 % num;
  }
  this._strip();
  return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p7) {
  assert2(p7.negative === 0);
  assert2(!p7.isZero());
  var x17 = this;
  var y16 = p7.clone();
  if (x17.negative !== 0) {
    x17 = x17.umod(p7);
  } else {
    x17 = x17.clone();
  }
  var A14 = new BN(1);
  var B18 = new BN(0);
  var C11 = new BN(0);
  var D12 = new BN(1);
  var g17 = 0;
  while (x17.isEven() && y16.isEven()) {
    x17.iushrn(1);
    y16.iushrn(1);
    ++g17;
  }
  var yp = y16.clone();
  var xp = x17.clone();
  while (!x17.isZero()) {
    for (var i = 0, im = 1; (x17.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
      ;
    if (i > 0) {
      x17.iushrn(i);
      while (i-- > 0) {
        if (A14.isOdd() || B18.isOdd()) {
          A14.iadd(yp);
          B18.isub(xp);
        }
        A14.iushrn(1);
        B18.iushrn(1);
      }
    }
    for (var j13 = 0, jm = 1; (y16.words[0] & jm) === 0 && j13 < 26; ++j13, jm <<= 1)
      ;
    if (j13 > 0) {
      y16.iushrn(j13);
      while (j13-- > 0) {
        if (C11.isOdd() || D12.isOdd()) {
          C11.iadd(yp);
          D12.isub(xp);
        }
        C11.iushrn(1);
        D12.iushrn(1);
      }
    }
    if (x17.cmp(y16) >= 0) {
      x17.isub(y16);
      A14.isub(C11);
      B18.isub(D12);
    } else {
      y16.isub(x17);
      C11.isub(A14);
      D12.isub(B18);
    }
  }
  return {
    a: C11,
    b: D12,
    gcd: y16.iushln(g17)
  };
};
BN.prototype._invmp = function _invmp(p7) {
  assert2(p7.negative === 0);
  assert2(!p7.isZero());
  var a7 = this;
  var b15 = p7.clone();
  if (a7.negative !== 0) {
    a7 = a7.umod(p7);
  } else {
    a7 = a7.clone();
  }
  var x17 = new BN(1);
  var x22 = new BN(0);
  var delta = b15.clone();
  while (a7.cmpn(1) > 0 && b15.cmpn(1) > 0) {
    for (var i = 0, im = 1; (a7.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
      ;
    if (i > 0) {
      a7.iushrn(i);
      while (i-- > 0) {
        if (x17.isOdd()) {
          x17.iadd(delta);
        }
        x17.iushrn(1);
      }
    }
    for (var j13 = 0, jm = 1; (b15.words[0] & jm) === 0 && j13 < 26; ++j13, jm <<= 1)
      ;
    if (j13 > 0) {
      b15.iushrn(j13);
      while (j13-- > 0) {
        if (x22.isOdd()) {
          x22.iadd(delta);
        }
        x22.iushrn(1);
      }
    }
    if (a7.cmp(b15) >= 0) {
      a7.isub(b15);
      x17.isub(x22);
    } else {
      b15.isub(a7);
      x22.isub(x17);
    }
  }
  var res;
  if (a7.cmpn(1) === 0) {
    res = x17;
  } else {
    res = x22;
  }
  if (res.cmpn(0) < 0) {
    res.iadd(p7);
  }
  return res;
};
BN.prototype.gcd = function gcd(num) {
  if (this.isZero())
    return num.abs();
  if (num.isZero())
    return this.abs();
  var a7 = this.clone();
  var b15 = num.clone();
  a7.negative = 0;
  b15.negative = 0;
  for (var shift = 0; a7.isEven() && b15.isEven(); shift++) {
    a7.iushrn(1);
    b15.iushrn(1);
  }
  do {
    while (a7.isEven()) {
      a7.iushrn(1);
    }
    while (b15.isEven()) {
      b15.iushrn(1);
    }
    var r2 = a7.cmp(b15);
    if (r2 < 0) {
      var t2 = a7;
      a7 = b15;
      b15 = t2;
    } else if (r2 === 0 || b15.cmpn(1) === 0) {
      break;
    }
    a7.isub(b15);
  } while (true);
  return b15.iushln(shift);
};
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
  assert2(typeof bit === "number");
  var r2 = bit % 26;
  var s10 = (bit - r2) / 26;
  var q15 = 1 << r2;
  if (this.length <= s10) {
    this._expand(s10 + 1);
    this.words[s10] |= q15;
    return this;
  }
  var carry = q15;
  for (var i = s10; carry !== 0 && i < this.length; i++) {
    var w24 = this.words[i] | 0;
    w24 += carry;
    carry = w24 >>> 26;
    w24 &= 67108863;
    this.words[i] = w24;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};
BN.prototype.isZero = function isZero() {
  return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
  var negative = num < 0;
  if (this.negative !== 0 && !negative)
    return -1;
  if (this.negative === 0 && negative)
    return 1;
  this._strip();
  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    if (negative) {
      num = -num;
    }
    assert2(num <= 67108863, "Number is too big");
    var w24 = this.words[0] | 0;
    res = w24 === num ? 0 : w24 < num ? -1 : 1;
  }
  if (this.negative !== 0)
    return -res | 0;
  return res;
};
BN.prototype.cmp = function cmp(num) {
  if (this.negative !== 0 && num.negative === 0)
    return -1;
  if (this.negative === 0 && num.negative !== 0)
    return 1;
  var res = this.ucmp(num);
  if (this.negative !== 0)
    return -res | 0;
  return res;
};
BN.prototype.ucmp = function ucmp(num) {
  if (this.length > num.length)
    return 1;
  if (this.length < num.length)
    return -1;
  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a7 = this.words[i] | 0;
    var b15 = num.words[i] | 0;
    if (a7 === b15)
      continue;
    if (a7 < b15) {
      res = -1;
    } else if (a7 > b15) {
      res = 1;
    }
    break;
  }
  return res;
};
BN.prototype.gtn = function gtn(num) {
  return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
  return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
  return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
  return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
  return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
  return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
  return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
  return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
  return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
  return this.cmp(num) === 0;
};
BN.red = function red2(num) {
  return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
  assert2(!this.red, "Already a number in reduction context");
  assert2(this.negative === 0, "red works only with positives");
  return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
  assert2(this.red, "fromRed works only with numbers in reduction context");
  return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
  assert2(!this.red, "Already a number in reduction context");
  return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
  assert2(this.red, "redAdd works only with red numbers");
  return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
  assert2(this.red, "redIAdd works only with red numbers");
  return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
  assert2(this.red, "redSub works only with red numbers");
  return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
  assert2(this.red, "redISub works only with red numbers");
  return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
  assert2(this.red, "redShl works only with red numbers");
  return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
  assert2(this.red, "redMul works only with red numbers");
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
  assert2(this.red, "redMul works only with red numbers");
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
  assert2(this.red, "redSqr works only with red numbers");
  this.red._verify1(this);
  return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
  assert2(this.red, "redISqr works only with red numbers");
  this.red._verify1(this);
  return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
  assert2(this.red, "redSqrt works only with red numbers");
  this.red._verify1(this);
  return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
  assert2(this.red, "redInvm works only with red numbers");
  this.red._verify1(this);
  return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
  assert2(this.red, "redNeg works only with red numbers");
  this.red._verify1(this);
  return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
  assert2(this.red && !num.red, "redPow(normalNum)");
  this.red._verify1(this);
  return this.red.pow(this, num);
};
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};
function MPrime(name, p7) {
  this.name = name;
  this.p = new BN(p7, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).iushln(this.n).isub(this.p);
  this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
  var r2 = num;
  var rlen;
  do {
    this.split(r2, this.tmp);
    r2 = this.imulK(r2);
    r2 = r2.iadd(this.tmp);
    rlen = r2.bitLength();
  } while (rlen > this.n);
  var cmp2 = rlen < this.n ? -1 : r2.ucmp(this.p);
  if (cmp2 === 0) {
    r2.words[0] = 0;
    r2.length = 1;
  } else if (cmp2 > 0) {
    r2.isub(this.p);
  } else {
    if (r2.strip !== void 0) {
      r2.strip();
    } else {
      r2._strip();
    }
  }
  return r2;
};
MPrime.prototype.split = function split(input, out) {
  input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};
function K256() {
  MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits(K256, MPrime);
K256.prototype.split = function split2(input, output) {
  var mask = 4194303;
  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++) {
    output.words[i] = input.words[i];
  }
  output.length = outLen;
  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;
  for (i = 10; i < input.length; i++) {
    var next = input.words[i] | 0;
    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
    prev = next;
  }
  prev >>>= 22;
  input.words[i - 10] = prev;
  if (prev === 0 && input.length > 10) {
    input.length -= 10;
  } else {
    input.length -= 9;
  }
};
K256.prototype.imulK = function imulK2(num) {
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w24 = num.words[i] | 0;
    lo += w24 * 977;
    num.words[i] = lo & 67108863;
    lo = w24 * 64 + (lo / 67108864 | 0);
  }
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0) {
      num.length--;
    }
  }
  return num;
};
function P224() {
  MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits(P224, MPrime);
function P192() {
  MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits(P192, MPrime);
function P25519() {
  MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits(P25519, MPrime);
P25519.prototype.imulK = function imulK3(num) {
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = (num.words[i] | 0) * 19 + carry;
    var lo = hi & 67108863;
    hi >>>= 26;
    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0) {
    num.words[num.length++] = carry;
  }
  return num;
};
BN._prime = function prime(name) {
  if (primes[name])
    return primes[name];
  var prime2;
  if (name === "k256") {
    prime2 = new K256();
  } else if (name === "p224") {
    prime2 = new P224();
  } else if (name === "p192") {
    prime2 = new P192();
  } else if (name === "p25519") {
    prime2 = new P25519();
  } else {
    throw new Error("Unknown prime " + name);
  }
  primes[name] = prime2;
  return prime2;
};
function Red(m20) {
  if (typeof m20 === "string") {
    var prime2 = BN._prime(m20);
    this.m = prime2.p;
    this.prime = prime2;
  } else {
    assert2(m20.gtn(1), "modulus must be greater than 1");
    this.m = m20;
    this.prime = null;
  }
}
Red.prototype._verify1 = function _verify1(a7) {
  assert2(a7.negative === 0, "red works only with positives");
  assert2(a7.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a7, b15) {
  assert2((a7.negative | b15.negative) === 0, "red works only with positives");
  assert2(a7.red && a7.red === b15.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a7) {
  if (this.prime)
    return this.prime.ireduce(a7)._forceRed(this);
  move(a7, a7.umod(this.m)._forceRed(this));
  return a7;
};
Red.prototype.neg = function neg2(a7) {
  if (a7.isZero()) {
    return a7.clone();
  }
  return this.m.sub(a7)._forceRed(this);
};
Red.prototype.add = function add2(a7, b15) {
  this._verify2(a7, b15);
  var res = a7.add(b15);
  if (res.cmp(this.m) >= 0) {
    res.isub(this.m);
  }
  return res._forceRed(this);
};
Red.prototype.iadd = function iadd2(a7, b15) {
  this._verify2(a7, b15);
  var res = a7.iadd(b15);
  if (res.cmp(this.m) >= 0) {
    res.isub(this.m);
  }
  return res;
};
Red.prototype.sub = function sub2(a7, b15) {
  this._verify2(a7, b15);
  var res = a7.sub(b15);
  if (res.cmpn(0) < 0) {
    res.iadd(this.m);
  }
  return res._forceRed(this);
};
Red.prototype.isub = function isub2(a7, b15) {
  this._verify2(a7, b15);
  var res = a7.isub(b15);
  if (res.cmpn(0) < 0) {
    res.iadd(this.m);
  }
  return res;
};
Red.prototype.shl = function shl(a7, num) {
  this._verify1(a7);
  return this.imod(a7.ushln(num));
};
Red.prototype.imul = function imul2(a7, b15) {
  this._verify2(a7, b15);
  return this.imod(a7.imul(b15));
};
Red.prototype.mul = function mul2(a7, b15) {
  this._verify2(a7, b15);
  return this.imod(a7.mul(b15));
};
Red.prototype.isqr = function isqr2(a7) {
  return this.imul(a7, a7.clone());
};
Red.prototype.sqr = function sqr2(a7) {
  return this.mul(a7, a7);
};
Red.prototype.sqrt = function sqrt(a7) {
  if (a7.isZero())
    return a7.clone();
  var mod310 = this.m.andln(3);
  assert2(mod310 % 2 === 1);
  if (mod310 === 3) {
    var pow3 = this.m.add(new BN(1)).iushrn(2);
    return this.pow(a7, pow3);
  }
  var q15 = this.m.subn(1);
  var s10 = 0;
  while (!q15.isZero() && q15.andln(1) === 0) {
    s10++;
    q15.iushrn(1);
  }
  assert2(!q15.isZero());
  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();
  var lpow = this.m.subn(1).iushrn(1);
  var z15 = this.m.bitLength();
  z15 = new BN(2 * z15 * z15).toRed(this);
  while (this.pow(z15, lpow).cmp(nOne) !== 0) {
    z15.redIAdd(nOne);
  }
  var c13 = this.pow(z15, q15);
  var r2 = this.pow(a7, q15.addn(1).iushrn(1));
  var t2 = this.pow(a7, q15);
  var m20 = s10;
  while (t2.cmp(one) !== 0) {
    var tmp = t2;
    for (var i = 0; tmp.cmp(one) !== 0; i++) {
      tmp = tmp.redSqr();
    }
    assert2(i < m20);
    var b15 = this.pow(c13, new BN(1).iushln(m20 - i - 1));
    r2 = r2.redMul(b15);
    c13 = b15.redSqr();
    t2 = t2.redMul(c13);
    m20 = i;
  }
  return r2;
};
Red.prototype.invm = function invm2(a7) {
  var inv = a7._invmp(this.m);
  if (inv.negative !== 0) {
    inv.negative = 0;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};
Red.prototype.pow = function pow2(a7, num) {
  if (num.isZero())
    return new BN(1).toRed(this);
  if (num.cmpn(1) === 0)
    return a7.clone();
  var windowSize = 4;
  var wnd = new Array(1 << windowSize);
  wnd[0] = new BN(1).toRed(this);
  wnd[1] = a7;
  for (var i = 2; i < wnd.length; i++) {
    wnd[i] = this.mul(wnd[i - 1], a7);
  }
  var res = wnd[0];
  var current = 0;
  var currentLen = 0;
  var start = num.bitLength() % 26;
  if (start === 0) {
    start = 26;
  }
  for (i = num.length - 1; i >= 0; i--) {
    var word = num.words[i];
    for (var j13 = start - 1; j13 >= 0; j13--) {
      var bit = word >> j13 & 1;
      if (res !== wnd[0]) {
        res = this.sqr(res);
      }
      if (bit === 0 && current === 0) {
        currentLen = 0;
        continue;
      }
      current <<= 1;
      current |= bit;
      currentLen++;
      if (currentLen !== windowSize && (i !== 0 || j13 !== 0))
        continue;
      res = this.mul(res, wnd[current]);
      currentLen = 0;
      current = 0;
    }
    start = 26;
  }
  return res;
};
Red.prototype.convertTo = function convertTo(num) {
  var r2 = num.umod(this.m);
  return r2 === num ? r2.clone() : r2;
};
Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};
BN.mont = function mont(num) {
  return new Mont(num);
};
function Mont(m20) {
  Red.call(this, m20);
  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0) {
    this.shift += 26 - this.shift % 26;
  }
  this.r = new BN(1).iushln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);
  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv = this.minv.umod(this.r);
  this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);
Mont.prototype.convertTo = function convertTo2(num) {
  return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom2(num) {
  var r2 = this.imod(num.mul(this.rinv));
  r2.red = null;
  return r2;
};
Mont.prototype.imul = function imul3(a7, b15) {
  if (a7.isZero() || b15.isZero()) {
    a7.words[0] = 0;
    a7.length = 1;
    return a7;
  }
  var t2 = a7.imul(b15);
  var c13 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u12 = t2.isub(c13).iushrn(this.shift);
  var res = u12;
  if (u12.cmp(this.m) >= 0) {
    res = u12.isub(this.m);
  } else if (u12.cmpn(0) < 0) {
    res = u12.iadd(this.m);
  }
  return res._forceRed(this);
};
Mont.prototype.mul = function mul3(a7, b15) {
  if (a7.isZero() || b15.isZero())
    return new BN(0)._forceRed(this);
  var t2 = a7.mul(b15);
  var c13 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u12 = t2.isub(c13).iushrn(this.shift);
  var res = u12;
  if (u12.cmp(this.m) >= 0) {
    res = u12.isub(this.m);
  } else if (u12.cmpn(0) < 0) {
    res = u12.iadd(this.m);
  }
  return res._forceRed(this);
};
Mont.prototype.invm = function invm3(a7) {
  var res = this.imod(a7._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};
function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
Reporter.prototype.isError = function isError(obj2) {
  return obj2 instanceof ReporterError;
};
Reporter.prototype.save = function save() {
  const state = this._reporterState;
  return {
    obj: state.obj,
    pathLen: state.path.length
  };
};
Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key2) {
  return this._reporterState.path.push(key2);
};
Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key2, value) {
  const state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null) {
    state.obj[key2] = value;
  }
};
Reporter.prototype.path = function path() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;
  const prev = state.obj;
  state.obj = {};
  return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;
  const now = state.obj;
  state.obj = prev;
  return now;
};
Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;
  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return "[" + JSON.stringify(elem) + "]";
    }).join(""), msg.message || msg, msg.stack);
  }
  if (!state.options.partial) {
    throw err;
  }
  if (!inherited) {
    state.errors.push(err);
  }
  return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial) {
    return result;
  }
  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};
function ReporterError(path6, msg) {
  this.path = path6;
  this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: ReporterError,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + " at: " + (this.path || "(shallow)");
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ReporterError);
  }
  if (!this.stack) {
    try {
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};
function DecoderBuffer(base2, options) {
  Reporter.call(this, options);
  if (!Buffer2.isBuffer(base2)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = base2;
  this.offset = 0;
  this.length = base2.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
  constructor: {
    value: DecoderBuffer,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }
  const isCompatible = typeof data === "object" && Buffer2.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
  return isCompatible;
};
DecoderBuffer.prototype.save = function save2() {
  return {
    offset: this.offset,
    reporter: Reporter.prototype.save.call(this)
  };
};
DecoderBuffer.prototype.restore = function restore2(save3) {
  const res = new DecoderBuffer(this.base);
  res.offset = save3.offset;
  res.length = this.offset;
  this.offset = save3.offset;
  Reporter.prototype.restore.call(this, save3.reporter);
  return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt82(fail) {
  if (this.offset + 1 <= this.length) {
    return this.base.readUInt8(this.offset++, true);
  } else {
    return this.error(fail || "DecoderBuffer overrun");
  }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length)) {
    return this.error(fail || "DecoderBuffer overrun");
  }
  const res = new DecoderBuffer(this.base);
  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};
DecoderBuffer.prototype.raw = function raw(save3) {
  return this.base.slice(save3 ? save3.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item)) {
        item = new EncoderBuffer(item, reporter);
      }
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === "number") {
    if (!(0 <= value && value <= 255)) {
      return reporter.error("non-byte EncoderBuffer value");
    }
    this.value = value;
    this.length = 1;
  } else if (typeof value === "string") {
    this.value = value;
    this.length = Buffer2.byteLength(value);
  } else if (Buffer2.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error("Unsupported type: " + typeof value);
  }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }
  const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
  return isCompatible;
};
EncoderBuffer.prototype.join = function join2(out, offset) {
  if (!out) {
    out = Buffer2.alloc(this.length);
  }
  if (!offset) {
    offset = 0;
  }
  if (this.length === 0) {
    return out;
  }
  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === "number") {
      out[offset] = this.value;
    } else if (typeof this.value === "string") {
      out.write(this.value, offset);
    } else if (Buffer2.isBuffer(this.value)) {
      this.value.copy(out, offset);
    }
    offset += this.length;
  }
  return out;
};
var tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
];
var methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags);
var overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;
  state.name = name;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null;
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state["default"] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
var stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node.prototype.clone = function clone2() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};
Node.prototype._wrap = function wrap2() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone3 = new this.constructor(this);
      state.children.push(clone3);
      return clone3[method].apply(clone3, arguments);
    };
  }, this);
};
Node.prototype._init = function init2(body) {
  const state = this._baseState;
  assert(state.parent === null);
  body.call(this);
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assertEquals(state.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);
  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== "object" || arg.constructor !== Object) {
        return arg;
      }
      const res = {};
      Object.keys(arg).forEach(function(key2) {
        if (key2 == (key2 | 0)) {
          key2 |= 0;
        }
        const value = arg[key2];
        res[value] = key2;
      });
      return res;
    });
  }
};
overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + " not implemented for encoding: " + state.enc);
  };
});
tags.forEach(function(tag2) {
  Node.prototype[tag2] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    assert(state.tag === null);
    state.tag = tag2;
    this._useArgs(args);
    return this;
  };
});
Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;
  assert(state.use === null);
  state.use = item;
  return this;
};
Node.prototype.optional = function optional() {
  const state = this._baseState;
  state.optional = true;
  return this;
};
Node.prototype.def = function def(val) {
  const state = this._baseState;
  assert(state["default"] === null);
  state["default"] = val;
  state.optional = true;
  return this;
};
Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};
Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};
Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0) {
    this._useArgs(args);
  }
  return this;
};
Node.prototype.key = function key(newKey) {
  const state = this._baseState;
  assert(state.key === null);
  state.key = newKey;
  return this;
};
Node.prototype.any = function any() {
  const state = this._baseState;
  state.any = true;
  return this;
};
Node.prototype.choice = function choice(obj2) {
  const state = this._baseState;
  assert(state.choice === null);
  state.choice = obj2;
  this._useArgs(Object.keys(obj2).map(function(key2) {
    return obj2[key2];
  }));
  return this;
};
Node.prototype.contains = function contains(item) {
  const state = this._baseState;
  assert(state.use === null);
  state.contains = item;
  return this;
};
Node.prototype._decode = function decode2(input, options) {
  const state = this._baseState;
  if (state.parent === null) {
    return input.wrapResult(state.children[0]._decode(input, options));
  }
  let result = state["default"];
  let present = true;
  let prevKey = null;
  if (state.key !== null) {
    prevKey = input.enterKey(state.key);
  }
  if (state.optional) {
    let tag2 = null;
    if (state.explicit !== null) {
      tag2 = state.explicit;
    } else if (state.implicit !== null) {
      tag2 = state.implicit;
    } else if (state.tag !== null) {
      tag2 = state.tag;
    }
    if (tag2 === null && !state.any) {
      const save3 = input.save();
      try {
        if (state.choice === null) {
          this._decodeGeneric(state.tag, input, options);
        } else {
          this._decodeChoice(input, options);
        }
        present = true;
      } catch (_e2) {
        present = false;
      }
      input.restore(save3);
    } else {
      present = this._peekTag(input, tag2, state.any);
      if (input.isError(present)) {
        return present;
      }
    }
  }
  let prevObj;
  if (state.obj && present) {
    prevObj = input.enterObject();
  }
  if (present) {
    if (state.explicit !== null) {
      const explicit2 = this._decodeTag(input, state.explicit);
      if (input.isError(explicit2)) {
        return explicit2;
      }
      input = explicit2;
    }
    const start = input.offset;
    if (state.use === null && state.choice === null) {
      let save1;
      if (state.any) {
        save1 = input.save();
      }
      const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
      if (input.isError(body)) {
        return body;
      }
      if (state.any) {
        result = input.raw(save1);
      } else {
        input = body;
      }
    }
    if (options && options.track && state.tag !== null) {
      options.track(input.path(), start, input.length, "tagged");
    }
    if (options && options.track && state.tag !== null) {
      options.track(input.path(), input.offset, input.length, "content");
    }
    if (state.any) {
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }
    if (input.isError(result)) {
      return result;
    }
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        child._decode(input, options);
      });
    }
    if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  }
  if (state.obj && present) {
    result = input.leaveObject(prevObj);
  }
  if (state.key !== null && (result !== null || present === true)) {
    input.leaveKey(prevKey, state.key, result);
  } else if (prevKey !== null) {
    input.exitKey(prevKey);
  }
  return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag2, input, options) {
  const state = this._baseState;
  if (tag2 === "seq" || tag2 === "set") {
    return null;
  }
  if (tag2 === "seqof" || tag2 === "setof") {
    return this._decodeList(input, tag2, state.args[0], options);
  } else if (/str$/.test(tag2)) {
    return this._decodeStr(input, tag2, options);
  } else if (tag2 === "objid" && state.args) {
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  } else if (tag2 === "objid") {
    return this._decodeObjid(input, null, null, options);
  } else if (tag2 === "gentime" || tag2 === "utctime") {
    return this._decodeTime(input, tag2, options);
  } else if (tag2 === "null_") {
    return this._decodeNull(input, options);
  } else if (tag2 === "bool") {
    return this._decodeBool(input, options);
  } else if (tag2 === "objDesc") {
    return this._decodeStr(input, tag2, options);
  } else if (tag2 === "int" || tag2 === "enum") {
    return this._decodeInt(input, state.args && state.args[0], options);
  }
  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error("unknown tag: " + tag2);
  }
};
Node.prototype._getUse = function _getUse(entity, obj2) {
  const state = this._baseState;
  state.useDecoder = this._use(entity, obj2);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;
  Object.keys(state.choice).some(function(key2) {
    const save3 = input.save();
    const node = state.choice[key2];
    try {
      const value = node._decode(input, options);
      if (input.isError(value)) {
        return false;
      }
      result = {
        type: key2,
        value
      };
      match = true;
    } catch (_e2) {
      input.restore(save3);
      return false;
    }
    return true;
  }, this);
  if (!match) {
    return input.error("Choice not matched");
  }
  return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode3(data, reporter, parent) {
  const state = this._baseState;
  if (state["default"] !== null && state["default"] === data) {
    return;
  }
  const result = this._encodeValue(data, reporter, parent);
  if (result === void 0) {
    return;
  }
  if (this._skipDefault(result, reporter, parent)) {
    return;
  }
  return result;
};
Node.prototype._encodeValue = function encode4(data, reporter, parent) {
  const state = this._baseState;
  if (state.parent === null) {
    return state.children[0]._encode(data, reporter || new Reporter());
  }
  let result = null;
  this.reporter = reporter;
  if (state.optional && data === void 0) {
    if (state["default"] !== null) {
      data = state["default"];
    } else {
      return;
    }
  }
  let content = null;
  let primitive = false;
  if (state.any) {
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === "null_") {
        return child._encode(null, reporter, data);
      }
      if (child._baseState.key === null) {
        return reporter.error("Child should have a key");
      }
      const prevKey = reporter.enterKey(child._baseState.key);
      if (typeof data !== "object") {
        return reporter.error("Child expected, but input is not object");
      }
      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);
      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === "seqof" || state.tag === "setof") {
      if (!(state.args && state.args.length === 1)) {
        return reporter.error("Too many args for : " + state.tag);
      }
      if (!Array.isArray(data)) {
        return reporter.error("seqof/setof, but data is not Array");
      }
      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state2 = this._baseState;
        return this._getUse(state2.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }
  if (!state.any && state.choice === null) {
    const tag2 = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? "universal" : "context";
    if (tag2 === null) {
      if (state.use === null) {
        reporter.error("Tag could be omitted only for .use()");
      }
    } else {
      if (state.use === null) {
        result = this._encodeComposite(tag2, primitive, cls, content);
      }
    }
  }
  if (state.explicit !== null) {
    result = this._encodeComposite(state.explicit, false, "context", result);
  }
  return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;
  const node = state.choice[data.type];
  if (!node) {
    assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag2, data) {
  const state = this._baseState;
  if (/str$/.test(tag2)) {
    return this._encodeStr(data, tag2);
  } else if (tag2 === "objid" && state.args) {
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  } else if (tag2 === "objid") {
    return this._encodeObjid(data, null, null);
  } else if (tag2 === "gentime" || tag2 === "utctime") {
    return this._encodeTime(data, tag2);
  } else if (tag2 === "null_") {
    return this._encodeNull();
  } else if (tag2 === "int" || tag2 === "enum") {
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  } else if (tag2 === "bool") {
    return this._encodeBool(data);
  } else if (tag2 === "objDesc") {
    return this._encodeStr(data, tag2);
  } else {
    throw new Error("Unsupported tag: " + tag2);
  }
};
Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse(map) {
  const res = {};
  Object.keys(map).forEach(function(key2) {
    if ((key2 | 0) == key2) {
      key2 = key2 | 0;
    }
    const value = map[key2];
    res[value] = key2;
  });
  return res;
}
var tagClass = {
  0: "universal",
  1: "application",
  2: "context",
  3: "private"
};
var tagClassByName = reverse(tagClass);
var tag = {
  0: "end",
  1: "bool",
  2: "int",
  3: "bitstr",
  4: "octstr",
  5: "null_",
  6: "objid",
  7: "objDesc",
  8: "external",
  9: "real",
  10: "enum",
  11: "embed",
  12: "utf8str",
  13: "relativeOid",
  16: "seq",
  17: "set",
  18: "numstr",
  19: "printstr",
  20: "t61str",
  21: "videostr",
  22: "ia5str",
  23: "utctime",
  24: "gentime",
  25: "graphstr",
  26: "iso646str",
  27: "genstr",
  28: "unistr",
  29: "charstr",
  30: "bmpstr"
};
var tagByName = reverse(tag);
var mod142 = {
  tagClass,
  tagClassByName,
  tag,
  tagByName
};
function DEREncoder(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode5(data, reporter) {
  return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
  Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
  constructor: {
    value: DERNode,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag2, primitive, cls, content) {
  const encodedTag = encodeTag(tag2, primitive, cls, this.reporter);
  if (content.length < 128) {
    const header = Buffer2.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([
      header,
      content
    ]);
  }
  let lenOctets = 1;
  for (let i = content.length; i >= 256; i >>= 8) {
    lenOctets++;
  }
  const header1 = Buffer2.alloc(1 + 1 + lenOctets);
  header1[0] = encodedTag;
  header1[1] = 128 | lenOctets;
  for (let i12 = 1 + lenOctets, j13 = content.length; j13 > 0; i12--, j13 >>= 8) {
    header1[i12] = j13 & 255;
  }
  return this._createEncoderBuffer([
    header1,
    content
  ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag2) {
  if (tag2 === "bitstr") {
    return this._createEncoderBuffer([
      str.unused | 0,
      str.data
    ]);
  } else if (tag2 === "bmpstr") {
    const buf = Buffer2.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag2 === "numstr") {
    if (!this._isNumstr(str)) {
      return this.reporter.error("Encoding of string type: numstr supports only digits and space");
    }
    return this._createEncoderBuffer(str);
  } else if (tag2 === "printstr") {
    if (!this._isPrintstr(str)) {
      return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag2)) {
    return this._createEncoderBuffer(str);
  } else if (tag2 === "objDesc") {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error("Encoding of string type: " + tag2 + " unsupported");
  }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative9) {
  if (typeof id === "string") {
    if (!values) {
      return this.reporter.error("string objid given, but no values map found");
    }
    if (!values.hasOwnProperty(id)) {
      return this.reporter.error("objid not found in values map");
    }
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i12 = 0; i12 < id.length; i12++) {
      id[i12] |= 0;
    }
  }
  if (!Array.isArray(id)) {
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
  }
  if (!relative9) {
    if (id[1] >= 40) {
      return this.reporter.error("Second objid identifier OOB");
    }
    id.splice(0, 2, id[0] * 40 + id[1]);
  }
  let size = 0;
  for (let i22 = 0; i22 < id.length; i22++) {
    let ident = id[i22];
    for (size++; ident >= 128; ident >>= 7) {
      size++;
    }
  }
  const objid = Buffer2.alloc(size);
  let offset = objid.length - 1;
  for (let i32 = id.length - 1; i32 >= 0; i32--) {
    let ident1 = id[i32];
    objid[offset--] = ident1 & 127;
    while ((ident1 >>= 7) > 0) {
      objid[offset--] = 128 | ident1 & 127;
    }
  }
  return this._createEncoderBuffer(objid);
};
function two(num) {
  if (num < 10) {
    return "0" + num;
  } else {
    return num;
  }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag2) {
  let str;
  const date = new Date(time);
  if (tag2 === "gentime") {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else if (tag2 === "utctime") {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else {
    this.reporter.error("Encoding " + tag2 + " time is not supported yet");
  }
  return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === "string") {
    if (!values) {
      return this.reporter.error("String int or enum given, but no values map");
    }
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
    }
    num = values[num];
  }
  if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 128) {
      numArray.unshift(0);
    }
    num = Buffer2.from(numArray);
  }
  if (Buffer2.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0) {
      size++;
    }
    const out = Buffer2.alloc(size);
    num.copy(out);
    if (num.length === 0) {
      out[0] = 0;
    }
    return this._createEncoderBuffer(out);
  }
  if (num < 128) {
    return this._createEncoderBuffer(num);
  }
  if (num < 256) {
    return this._createEncoderBuffer([
      0,
      num
    ]);
  }
  let size1 = 1;
  for (let i = num; i >= 256; i >>= 8) {
    size1++;
  }
  const out1 = new Array(size1);
  for (let i12 = out1.length - 1; i12 >= 0; i12--) {
    out1[i12] = num & 255;
    num >>= 8;
  }
  if (out1[0] & 128) {
    out1.unshift(0);
  }
  return this._createEncoderBuffer(Buffer2.from(out1));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 255 : 0);
};
DERNode.prototype._use = function use2(entity, obj2) {
  if (typeof entity === "function") {
    entity = entity(obj2);
  }
  return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state["default"] === null) {
    return false;
  }
  const data = dataBuffer.join();
  if (state.defaultBuffer === void 0) {
    state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
  }
  if (data.length !== state.defaultBuffer.length) {
    return false;
  }
  for (i = 0; i < data.length; i++) {
    if (data[i] !== state.defaultBuffer[i]) {
      return false;
    }
  }
  return true;
};
function encodeTag(tag2, primitive, cls, reporter) {
  let res;
  if (tag2 === "seqof") {
    tag2 = "seq";
  } else if (tag2 === "setof") {
    tag2 = "set";
  }
  if (tagByName.hasOwnProperty(tag2)) {
    res = tagByName[tag2];
  } else if (typeof tag2 === "number" && (tag2 | 0) === tag2) {
    res = tag2;
  } else {
    return reporter.error("Unknown tag: " + tag2);
  }
  if (res >= 31) {
    return reporter.error("Multi-octet tag encoding unsupported");
  }
  if (!primitive) {
    res |= 32;
  }
  res |= tagClassByName[cls || "universal"] << 6;
  return res;
}
function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
  constructor: {
    value: PEMEncoder,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
PEMEncoder.prototype.encode = function encode6(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);
  const p7 = buf.toString("base64");
  const out = [
    "-----BEGIN " + options.label + "-----"
  ];
  for (let i = 0; i < p7.length; i += 64) {
    out.push(p7.slice(i, i + 64));
  }
  out.push("-----END " + options.label + "-----");
  return out.join("\n");
};
function DERDecoder(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode1();
  this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode3(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }
  return this.tree._decode(data, options);
};
function DERNode1(parent) {
  Node.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node.prototype, {
  constructor: {
    value: DERNode1,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DERNode1.prototype._peekTag = function peekTag(buffer, tag2, any2) {
  if (buffer.isEmpty()) {
    return false;
  }
  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag2 + '"');
  if (buffer.isError(decodedTag)) {
    return decodedTag;
  }
  buffer.restore(state);
  return decodedTag.tag === tag2 || decodedTag.tagStr === tag2 || decodedTag.tagStr + "of" === tag2 || any2;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer, tag2, any2) {
  const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag2 + '"');
  if (buffer.isError(decodedTag)) {
    return decodedTag;
  }
  let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag2 + '"');
  if (buffer.isError(len)) {
    return len;
  }
  if (!any2 && decodedTag.tag !== tag2 && decodedTag.tagStr !== tag2 && decodedTag.tagStr + "of" !== tag2) {
    return buffer.error('Failed to match tag: "' + tag2 + '"');
  }
  if (decodedTag.primitive || len !== null) {
    return buffer.skip(len, 'Failed to match body of: "' + tag2 + '"');
  }
  const state = buffer.save();
  const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res)) {
    return res;
  }
  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag2 + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (; ; ) {
    const tag2 = derDecodeTag(buffer, fail);
    if (buffer.isError(tag2)) {
      return tag2;
    }
    const len = derDecodeLen(buffer, tag2.primitive, fail);
    if (buffer.isError(len)) {
      return len;
    }
    let res;
    if (tag2.primitive || len !== null) {
      res = buffer.skip(len);
    } else {
      res = this._skipUntilEnd(buffer, fail);
    }
    if (buffer.isError(res)) {
      return res;
    }
    if (tag2.tagStr === "end") {
      break;
    }
  }
};
DERNode1.prototype._decodeList = function decodeList(buffer, _tag, decoder2, options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, "end");
    if (buffer.isError(possibleEnd)) {
      return possibleEnd;
    }
    const res = decoder2.decode(buffer, "der", options);
    if (buffer.isError(res) && possibleEnd) {
      break;
    }
    result.push(res);
  }
  return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer, tag2) {
  if (tag2 === "bitstr") {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused)) {
      return unused;
    }
    return {
      unused,
      data: buffer.raw()
    };
  } else if (tag2 === "bmpstr") {
    const raw2 = buffer.raw();
    if (raw2.length % 2 === 1) {
      return buffer.error("Decoding of string type: bmpstr length mismatch");
    }
    let str = "";
    for (let i = 0; i < raw2.length / 2; i++) {
      str += String.fromCharCode(raw2.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag2 === "numstr") {
    const numstr = buffer.raw().toString("ascii");
    if (!this._isNumstr(numstr)) {
      return buffer.error("Decoding of string type: numstr unsupported characters");
    }
    return numstr;
  } else if (tag2 === "octstr") {
    return buffer.raw();
  } else if (tag2 === "objDesc") {
    return buffer.raw();
  } else if (tag2 === "printstr") {
    const printstr = buffer.raw().toString("ascii");
    if (!this._isPrintstr(printstr)) {
      return buffer.error("Decoding of string type: printstr unsupported characters");
    }
    return printstr;
  } else if (/str$/.test(tag2)) {
    return buffer.raw().toString();
  } else {
    return buffer.error("Decoding of string type: " + tag2 + " unsupported");
  }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer, values, relative9) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 127;
    if ((subident & 128) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 128) {
    identifiers.push(ident);
  }
  const first = identifiers[0] / 40 | 0;
  const second = identifiers[0] % 40;
  if (relative9) {
    result = identifiers;
  } else {
    result = [
      first,
      second
    ].concat(identifiers.slice(1));
  }
  if (values) {
    let tmp = values[result.join(" ")];
    if (tmp === void 0) {
      tmp = values[result.join(".")];
    }
    if (tmp !== void 0) {
      result = tmp;
    }
  }
  return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer, tag2) {
  const str = buffer.raw().toString();
  let year2;
  let mon;
  let day2;
  let hour2;
  let min3;
  let sec;
  if (tag2 === "gentime") {
    year2 = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day2 = str.slice(6, 8) | 0;
    hour2 = str.slice(8, 10) | 0;
    min3 = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag2 === "utctime") {
    year2 = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day2 = str.slice(4, 6) | 0;
    hour2 = str.slice(6, 8) | 0;
    min3 = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year2 < 70) {
      year2 = 2e3 + year2;
    } else {
      year2 = 1900 + year2;
    }
  } else {
    return buffer.error("Decoding " + tag2 + " time is not supported yet");
  }
  return Date.UTC(year2, mon - 1, day2, hour2, min3, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
  return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res)) {
    return res;
  } else {
    return res !== 0;
  }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer, values) {
  const raw2 = buffer.raw();
  let res = new BN(raw2);
  if (values) {
    res = values[res.toString(10)] || res;
  }
  return res;
};
DERNode1.prototype._use = function use3(entity, obj2) {
  if (typeof entity === "function") {
    entity = entity(obj2);
  }
  return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
  let tag1 = buf.readUInt8(fail);
  if (buf.isError(tag1)) {
    return tag1;
  }
  const cls = tagClass[tag1 >> 6];
  const primitive = (tag1 & 32) === 0;
  if ((tag1 & 31) === 31) {
    let oct = tag1;
    tag1 = 0;
    while ((oct & 128) === 128) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct)) {
        return oct;
      }
      tag1 <<= 7;
      tag1 |= oct & 127;
    }
  } else {
    tag1 &= 31;
  }
  const tagStr = tag[tag1];
  return {
    cls,
    primitive,
    tag: tag1,
    tagStr
  };
}
function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len)) {
    return len;
  }
  if (!primitive && len === 128) {
    return null;
  }
  if ((len & 128) === 0) {
    return len;
  }
  const num = len & 127;
  if (num > 4) {
    return buf.error("length octect is too long");
  }
  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j13 = buf.readUInt8(fail);
    if (buf.isError(j13)) {
      return j13;
    }
    len |= j13;
  }
  return len;
}
function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
  constructor: {
    value: PEMDecoder,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
PEMDecoder.prototype.decode = function decode4(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);
  const label = options.label.toUpperCase();
  const re4 = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re4);
    if (match === null) {
      continue;
    }
    if (match[2] !== label) {
      continue;
    }
    if (start === -1) {
      if (match[1] !== "BEGIN") {
        break;
      }
      start = i;
    } else {
      if (match[1] !== "END") {
        break;
      }
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1) {
    throw new Error("PEM section not found for: " + label);
  }
  const base64 = lines.slice(start + 1, end).join("");
  base64.replace(/[^a-z0-9+/=]+/gi, "");
  const input = Buffer2.from(base64, "base64");
  return DERDecoder.prototype.decode.call(this, input, options);
};
var base = {
  DecoderBuffer,
  EncoderBuffer,
  Node,
  Reporter
};
var encoders = {
  der: DEREncoder,
  pem: PEMEncoder
};
var decoders = {
  der: DERDecoder,
  pem: PEMDecoder
};
var constants = {
  der: mod142
};
function define(name, body) {
  return new Entity(name, body);
}
function Entity(name, body) {
  this.name = name;
  this.body = body;
  this.decoders = {};
  this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;
  function Generated(entity) {
    this._initNamed(entity, name);
  }
  Generated.prototype = Object.create(Base.prototype, {
    constructor: {
      value: Generated,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Generated.prototype._initNamed = function _initNamed(entity, name2) {
    Base.call(this, entity, name2);
  };
  return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || "der";
  if (!this.decoders.hasOwnProperty(enc)) {
    this.decoders[enc] = this._createNamed(decoders[enc]);
  }
  return this.decoders[enc];
};
Entity.prototype.decode = function decode5(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || "der";
  if (!this.encoders.hasOwnProperty(enc)) {
    this.encoders[enc] = this._createNamed(encoders[enc]);
  }
  return this.encoders[enc];
};
Entity.prototype.encode = function encode7(data, enc, reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};
var __default6 = {
  base,
  bignum: BN,
  constants,
  decoders,
  define,
  encoders
};
var Time = define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = define("AttributeTypeValue", function() {
  this.seq().obj(this.key("type").objid(), this.key("value").any());
});
var AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
var SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
var RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
});
var RDNSequence = define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
});
var Name = define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = define("Validity", function() {
  this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
var Extension = define("Extension", function() {
  this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
var TBSCertificate = define("TBSCertificate", function() {
  this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
var X509Certificate = define("X509Certificate", function() {
  this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
var RSAPrivateKey = __default6.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
var RSAPublicKey = __default6.define("RSAPublicKey", function() {
  this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
var PublicKey = __default6.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
var AlgorithmIdentifier1 = __default6.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
var PrivateKey = __default6.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
var EncryptedPrivateKey = __default6.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
var DSAPrivateKey = __default6.define("DSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
var DSAparam = __default6.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = __default6.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
var ECParameters = __default6.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
var signature = __default6.define("signature", function() {
  this.seq().obj(this.key("r").int(), this.key("s").int());
});
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default7(okey, password) {
  const key2 = okey.toString();
  const match = key2.match(findProc);
  let decrypted;
  if (!match) {
    const match2 = key2.match(fullRegex);
    decrypted = Buffer2.from(match2[2].replace(/[\r\n]/g, ""), "base64");
  } else {
    const suite = "aes" + match[1];
    const iv = Buffer2.from(match[2], "hex");
    const cipherText = Buffer2.from(match[3].replace(/[\r\n]/g, ""), "base64");
    const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    const out = [];
    const cipher = createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer2.concat(out);
  }
  const tag2 = key2.match(startRegex)[1];
  return {
    tag: tag2,
    data: decrypted
  };
}
var aesid = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
  let password;
  if (typeof buffer === "object" && !Buffer2.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === "string") {
    buffer = Buffer2.from(buffer);
  }
  const stripped = __default7(buffer, password);
  const type = stripped.tag;
  let data = stripped.data;
  let subtype, ndata;
  switch (type) {
    case "CERTIFICATE":
      ndata = X509Certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      if (!ndata) {
        ndata = PublicKey.decode(data, "der");
      }
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: "ec",
            data: ndata
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
          return {
            type: "dsa",
            data: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "ENCRYPTED PRIVATE KEY":
      data = EncryptedPrivateKey.decode(data, "der");
      data = decrypt2(data, password);
    case "PRIVATE KEY":
      ndata = PrivateKey.decode(data, "der");
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: ndata.algorithm.curve,
            privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
          return {
            type: "dsa",
            params: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "RSA PUBLIC KEY":
      return RSAPublicKey.decode(data, "der");
    case "RSA PRIVATE KEY":
      return RSAPrivateKey.decode(data, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: DSAPrivateKey.decode(data, "der")
      };
    case "EC PRIVATE KEY":
      data = ECPrivateKey.decode(data, "der");
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default:
      throw new Error("unknown key type " + type);
  }
}
parseKeys.signature = signature;
function decrypt2(data, password) {
  const salt = data.algorithm.decrypt.kde.kdeparams.salt;
  const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
  const iv = data.algorithm.decrypt.cipher.iv;
  const cipherText = data.subjectPrivateKey;
  const keylen = parseInt(algo.split("-")[1], 10) / 8;
  const key2 = pbkdf2Sync(password, salt, iters, keylen, "sha1");
  const cipher = createDecipheriv(algo, key2, iv);
  const out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer2.concat(out);
}
var MAX_BYTES = 65536;
function randomBytes1(size, cb) {
  if (size > 4294967295) {
    throw new RangeError("requested too many random bytes");
  }
  const bytes = Buffer2.allocUnsafe(size);
  if (size > 0) {
    if (size > 65536) {
      for (let generated = 0; generated < size; generated += MAX_BYTES) {
        globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
      }
    } else {
      globalThis.crypto.getRandomValues(bytes);
    }
  }
  if (typeof cb === "function") {
    return nextTick1(function() {
      cb(null, bytes);
    });
  }
  return bytes;
}
function __default8(seed, len) {
  let t2 = Buffer2.alloc(0);
  let i = 0;
  let c13;
  while (t2.length < len) {
    c13 = i2ops(i++);
    t2 = Buffer2.concat([
      t2,
      createHash("sha1").update(seed).update(c13).digest()
    ]);
  }
  return t2.slice(0, len);
}
function i2ops(c13) {
  const out = Buffer2.allocUnsafe(4);
  out.writeUInt32BE(c13, 0);
  return out;
}
function xor1(a7, b15) {
  const len = a7.length;
  let i = -1;
  while (++i < len) {
    a7[i] ^= b15[i];
  }
  return a7;
}
function withPublic(paddedMsg, key2) {
  return Buffer2.from(paddedMsg.toRed(BN.mont(key2.modulus)).redPow(new BN(key2.publicExponent)).fromRed().toArray());
}
function blind(priv) {
  const r2 = getr(priv);
  const blinder = r2.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
  return {
    blinder,
    unblinder: r2.invm(priv.modulus)
  };
}
function getr(priv) {
  const len = priv.modulus.byteLength();
  let r2;
  do {
    r2 = new BN(randomBytes1(len));
  } while (r2.cmp(priv.modulus) >= 0 || !r2.umod(priv.prime1) || !r2.umod(priv.prime2));
  return r2;
}
function crt(msg, priv) {
  const blinds = blind(priv);
  const len = priv.modulus.byteLength();
  const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
  const c13 = blinded.toRed(BN.mont(priv.prime1));
  const c22 = blinded.toRed(BN.mont(priv.prime2));
  const qinv = priv.coefficient;
  const p7 = priv.prime1;
  const q15 = priv.prime2;
  const m110 = c13.redPow(priv.exponent1).fromRed();
  const m22 = c22.redPow(priv.exponent2).fromRed();
  const h16 = m110.isub(m22).imul(qinv).umod(p7).imul(q15);
  return m22.iadd(h16).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer2, "be", len);
}
crt.getr = getr;
function publicEncrypt(publicKey, msg, reverse2) {
  let padding;
  if (publicKey.padding) {
    padding = publicKey.padding;
  } else if (reverse2) {
    padding = 1;
  } else {
    padding = 4;
  }
  const key2 = parseKeys(publicKey);
  let paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key2, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key2, msg, reverse2);
  } else if (padding === 3) {
    paddedMsg = new BN(msg);
    if (paddedMsg.cmp(key2.modulus) >= 0) {
      throw new Error("data too long for modulus");
    }
  } else {
    throw new Error("unknown padding");
  }
  if (reverse2) {
    return crt(paddedMsg, key2);
  } else {
    return withPublic(paddedMsg, key2);
  }
}
function oaep(key2, msg) {
  const k15 = key2.modulus.byteLength();
  const mLen = msg.length;
  const iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
  const hLen = iHash.length;
  const hLen2 = 2 * hLen;
  if (mLen > k15 - hLen2 - 2) {
    throw new Error("message too long");
  }
  const ps = Buffer2.alloc(k15 - mLen - hLen2 - 2);
  const dblen = k15 - hLen - 1;
  const seed = randomBytes1(hLen);
  const maskedDb = xor1(Buffer2.concat([
    iHash,
    ps,
    Buffer2.alloc(1, 1),
    msg
  ], dblen), __default8(seed, dblen));
  const maskedSeed = xor1(seed, __default8(maskedDb, hLen));
  return new BN(Buffer2.concat([
    Buffer2.alloc(1),
    maskedSeed,
    maskedDb
  ], k15));
}
function pkcs1(key2, msg, reverse2) {
  const mLen = msg.length;
  const k15 = key2.modulus.byteLength();
  if (mLen > k15 - 11) {
    throw new Error("message too long");
  }
  let ps;
  if (reverse2) {
    ps = Buffer2.alloc(k15 - mLen - 3, 255);
  } else {
    ps = nonZero(k15 - mLen - 3);
  }
  return new BN(Buffer2.concat([
    Buffer2.from([
      0,
      reverse2 ? 1 : 2
    ]),
    ps,
    Buffer2.alloc(1),
    msg
  ], k15));
}
function nonZero(len) {
  const out = Buffer2.allocUnsafe(len);
  let i = 0;
  let cache = randomBytes1(len * 2);
  let cur = 0;
  let num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes1(len * 2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
function privateDecrypt(privateKey, enc, reverse2) {
  let padding;
  if (privateKey.padding) {
    padding = privateKey.padding;
  } else if (reverse2) {
    padding = 1;
  } else {
    padding = 4;
  }
  const key2 = parseKeys(privateKey);
  const k15 = key2.modulus.byteLength();
  if (enc.length > k15 || new BN(enc).cmp(key2.modulus) >= 0) {
    throw new Error("decryption error");
  }
  let msg;
  if (reverse2) {
    msg = withPublic(new BN(enc), key2);
  } else {
    msg = crt(enc, key2);
  }
  const zBuffer = Buffer2.alloc(k15 - msg.length);
  msg = Buffer2.concat([
    zBuffer,
    msg
  ], k15);
  if (padding === 4) {
    return oaep1(key2, msg);
  } else if (padding === 1) {
    return pkcs11(key2, msg, reverse2);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error("unknown padding");
  }
}
function oaep1(key2, msg) {
  const k15 = key2.modulus.byteLength();
  const iHash = createHash("sha1").update(Buffer2.alloc(0)).digest();
  const hLen = iHash.length;
  if (msg[0] !== 0) {
    throw new Error("decryption error");
  }
  const maskedSeed = msg.slice(1, hLen + 1);
  const maskedDb = msg.slice(hLen + 1);
  const seed = xor1(maskedSeed, __default8(maskedDb, hLen));
  const db = xor1(maskedDb, __default8(seed, k15 - hLen - 1));
  if (compare3(iHash, db.slice(0, hLen))) {
    throw new Error("decryption error");
  }
  let i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error("decryption error");
  }
  return db.slice(i);
}
function pkcs11(_key, msg, reverse2) {
  const p110 = msg.slice(0, 2);
  let i = 2;
  let status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  const ps = msg.slice(2, i - 1);
  if (p110.toString("hex") !== "0002" && !reverse2 || p110.toString("hex") !== "0001" && reverse2) {
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error("decryption error");
  }
  return msg.slice(i);
}
function compare3(a7, b15) {
  a7 = Buffer2.from(a7);
  b15 = Buffer2.from(b15);
  let dif = 0;
  let len = a7.length;
  if (a7.length !== b15.length) {
    dif++;
    len = Math.min(a7.length, b15.length);
  }
  let i = -1;
  while (++i < len) {
    dif += a7[i] ^ b15[i];
  }
  return dif;
}
function privateEncrypt(key2, buf) {
  return publicEncrypt(key2, buf, true);
}
function publicDecrypt(key2, buf) {
  return privateDecrypt(key2, buf, true);
}
var Cipheriv = class extends Transform {
  constructor(_cipher, _key, _iv, _options) {
    super();
    notImplemented("crypto.Cipheriv");
  }
  final(_outputEncoding) {
    notImplemented("crypto.Cipheriv.prototype.final");
  }
  getAuthTag() {
    notImplemented("crypto.Cipheriv.prototype.getAuthTag");
  }
  setAAD(_buffer, _options) {
    notImplemented("crypto.Cipheriv.prototype.setAAD");
  }
  setAutoPadding(_autoPadding) {
    notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
  }
  update(_data, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.Cipheriv.prototype.update");
  }
};
var Decipheriv = class extends Transform {
  constructor(_cipher, _key, _iv, _options) {
    super();
    notImplemented("crypto.Decipheriv");
  }
  final(_outputEncoding) {
    notImplemented("crypto.Decipheriv.prototype.final");
  }
  setAAD(_buffer, _options) {
    notImplemented("crypto.Decipheriv.prototype.setAAD");
  }
  setAuthTag(_buffer, _encoding) {
    notImplemented("crypto.Decipheriv.prototype.setAuthTag");
  }
  setAutoPadding(_autoPadding) {
    notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
  }
  update(_data, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.Decipheriv.prototype.update");
  }
};
function getCipherInfo(nameOrNid, options) {
  if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
    throw new ERR_INVALID_ARG_TYPE("nameOrNid", [
      "string",
      "number"
    ], nameOrNid);
  }
  if (typeof nameOrNid === "number") {
    validateInt32(nameOrNid, "nameOrNid");
  }
  let keyLength, ivLength;
  if (options !== void 0) {
    validateObject(options, "options");
    ({ keyLength, ivLength } = options);
    if (keyLength !== void 0) {
      validateInt32(keyLength, "options.keyLength");
    }
    if (ivLength !== void 0) {
      validateInt32(ivLength, "options.ivLength");
    }
  }
  notImplemented("crypto.getCipherInfo");
}
var Sign = class extends Writable {
  constructor(algorithm, _options) {
    validateString(algorithm, "algorithm");
    super();
    notImplemented("crypto.Sign");
  }
  sign(_privateKey, _outputEncoding) {
    notImplemented("crypto.Sign.prototype.sign");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Sign.prototype.update");
  }
};
var Verify = class extends Writable {
  constructor(algorithm, _options) {
    validateString(algorithm, "algorithm");
    super();
    notImplemented("crypto.Verify");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Sign.prototype.update");
  }
  verify(_object, _signature, _signatureEncoding) {
    notImplemented("crypto.Sign.prototype.sign");
  }
};
function signOneShot(_algorithm, _data, _key, _callback) {
  notImplemented("crypto.sign");
}
function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
  notImplemented("crypto.verify");
}
var X509Certificate1 = class {
  constructor(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer2.from(buffer);
    }
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE("buffer", [
        "string",
        "Buffer",
        "TypedArray",
        "DataView"
      ], buffer);
    }
    notImplemented("crypto.X509Certificate");
  }
  get ca() {
    notImplemented("crypto.X509Certificate.prototype.ca");
    return false;
  }
  checkEmail(_email, _options) {
    notImplemented("crypto.X509Certificate.prototype.checkEmail");
  }
  checkHost(_name, _options) {
    notImplemented("crypto.X509Certificate.prototype.checkHost");
  }
  checkIP(_ip) {
    notImplemented("crypto.X509Certificate.prototype.checkIP");
  }
  checkIssued(_otherCert) {
    notImplemented("crypto.X509Certificate.prototype.checkIssued");
  }
  checkPrivateKey(_privateKey) {
    notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
  }
  get fingerprint() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint");
    return "";
  }
  get fingerprint256() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint256");
    return "";
  }
  get fingerprint512() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint512");
    return "";
  }
  get infoAccess() {
    notImplemented("crypto.X509Certificate.prototype.infoAccess");
    return "";
  }
  get issuer() {
    notImplemented("crypto.X509Certificate.prototype.issuer");
    return "";
  }
  get issuerCertificate() {
    notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
    return {};
  }
  get keyUsage() {
    notImplemented("crypto.X509Certificate.prototype.keyUsage");
    return [];
  }
  get publicKey() {
    notImplemented("crypto.X509Certificate.prototype.publicKey");
    return {};
  }
  get raw() {
    notImplemented("crypto.X509Certificate.prototype.raw");
    return {};
  }
  get serialNumber() {
    notImplemented("crypto.X509Certificate.prototype.serialNumber");
    return "";
  }
  get subject() {
    notImplemented("crypto.X509Certificate.prototype.subject");
    return "";
  }
  get subjectAltName() {
    notImplemented("crypto.X509Certificate.prototype.subjectAltName");
    return "";
  }
  toJSON() {
    return this.toString();
  }
  toLegacyObject() {
    notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
  }
  toString() {
    notImplemented("crypto.X509Certificate.prototype.toString");
  }
  get validFrom() {
    notImplemented("crypto.X509Certificate.prototype.validFrom");
    return "";
  }
  get validTo() {
    notImplemented("crypto.X509Certificate.prototype.validTo");
    return "";
  }
  verify(_publicKey) {
    notImplemented("crypto.X509Certificate.prototype.verify");
  }
};
var Certificate = class {
  static exportChallenge(_spkac, _encoding) {
    notImplemented("crypto.Certificate.exportChallenge");
  }
  static exportPublicKey(_spkac, _encoding) {
    notImplemented("crypto.Certificate.exportPublicKey");
  }
  static verifySpkac(_spkac, _encoding) {
    notImplemented("crypto.Certificate.verifySpkac");
  }
};
var webcrypto = globalThis.crypto;
var fipsForced = getOptionValue("--force-fips");
function createCipheriv(cipher, key2, iv, options) {
  return new Cipheriv(cipher, key2, iv, options);
}
function createDecipheriv1(algorithm, key2, iv, options) {
  return new Decipheriv(algorithm, key2, iv, options);
}
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
  return new DiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding);
}
function createDiffieHellmanGroup(name) {
  return new DiffieHellmanGroup(name);
}
function createECDH(curve) {
  return new ECDH(curve);
}
function createHmac(hmac, key2, options) {
  return new Hmac(hmac, key2, options);
}
function createSign1(algorithm, options) {
  return new Sign(algorithm, options);
}
function createVerify(algorithm, options) {
  return new Verify(algorithm, options);
}
function setFipsForced(val) {
  if (val) {
    return;
  }
  throw new ERR_CRYPTO_FIPS_FORCED();
}
function getFipsForced() {
  return 1;
}
Object.defineProperty(crypto1, "defaultCipherList", {
  value: getOptionValue("--tls-cipher-list")
});
var getDiffieHellman = createDiffieHellmanGroup;
var getFips = fipsForced ? getFipsForced : getFipsCrypto;
var setFips = fipsForced ? setFipsForced : setFipsCrypto;
var __default9 = {
  Certificate,
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants: crypto1,
  createCipheriv,
  createDecipheriv: createDecipheriv1,
  createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  createSign: createSign1,
  createVerify,
  Decipheriv,
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,
  getDiffieHellman,
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,
  KeyObject,
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,
  Sign,
  sign: signOneShot,
  timingSafeEqual,
  Verify,
  verify: verifyOneShot,
  webcrypto,
  X509Certificate: X509Certificate1
};
var m2 = Object.create;
var p3 = Object.defineProperty;
var c2 = Object.getOwnPropertyDescriptor;
var g2 = Object.getOwnPropertyNames;
var w2 = Object.getPrototypeOf;
var _ = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var R1 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var v = (e, r2, t2, o6) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let a7 of g2(r2))
      !_.call(e, a7) && a7 !== t2 && p3(e, a7, {
        get: () => r2[a7],
        enumerable: !(o6 = c2(r2, a7)) || o6.enumerable
      });
  return e;
};
var u1 = (e, r2, t2) => (t2 = e != null ? m2(w2(e)) : {}, v(r2 || !e || !e.__esModule ? p3(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var i3 = R1(($17, d14) => {
  var s10;
  d14.exports = function(r2) {
    return s10 || (s10 = new n3(null)), s10.generate(r2);
  };
  function n3(e) {
    this.rand = e;
  }
  d14.exports.Rand = n3;
  n3.prototype.generate = function(r2) {
    return this._rand(r2);
  };
  n3.prototype._rand = function(r2) {
    if (this.rand.getBytes)
      return this.rand.getBytes(r2);
    for (var t2 = new Uint8Array(r2), o6 = 0; o6 < t2.length; o6++)
      t2[o6] = this.rand.getByte();
    return t2;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? n3.prototype._rand = function(r2) {
      var t2 = new Uint8Array(r2);
      return self.crypto.getRandomValues(t2), t2;
    } : self.msCrypto && self.msCrypto.getRandomValues ? n3.prototype._rand = function(r2) {
      var t2 = new Uint8Array(r2);
      return self.msCrypto.getRandomValues(t2), t2;
    } : typeof window == "object" && (n3.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (f8 = __default9, typeof f8.randomBytes != "function")
        throw new Error("Not supported");
      n3.prototype._rand = function(r2) {
        return f8.randomBytes(r2);
      };
    } catch {
    }
  var f8;
});
var l2 = u1(i3());
var y1 = u1(i3());
var { Rand: A } = y1;
var { default: B, ...x2 } = y1;
var C = l2.default ?? B ?? x2;
var x3 = Object.create;
var l3 = Object.defineProperty;
var y2 = Object.getOwnPropertyDescriptor;
var A1 = Object.getOwnPropertyNames;
var $2 = Object.getPrototypeOf;
var s1 = Object.prototype.hasOwnProperty;
var z = (r2, e) => () => (e || r2((e = {
  exports: {}
}).exports, e), e.exports);
var H1 = (r2, e, t2, n3) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f8 of A1(e))
      !s1.call(r2, f8) && f8 !== t2 && l3(r2, f8, {
        get: () => e[f8],
        enumerable: !(n3 = y2(e, f8)) || n3.enumerable
      });
  return r2;
};
var h2 = (r2, e, t2) => (t2 = r2 != null ? x3($2(r2)) : {}, H1(e || !r2 || !r2.__esModule ? l3(t2, "default", {
  value: r2,
  enumerable: true
}) : t2, r2));
var u2 = z((p7) => {
  "use strict";
  var o6 = p7;
  function C11(r2, e) {
    if (Array.isArray(r2))
      return r2.slice();
    if (!r2)
      return [];
    var t2 = [];
    if (typeof r2 != "string") {
      for (var n3 = 0; n3 < r2.length; n3++)
        t2[n3] = r2[n3] | 0;
      return t2;
    }
    if (e === "hex") {
      r2 = r2.replace(/[^a-z0-9]+/ig, ""), r2.length % 2 !== 0 && (r2 = "0" + r2);
      for (var n3 = 0; n3 < r2.length; n3 += 2)
        t2.push(parseInt(r2[n3] + r2[n3 + 1], 16));
    } else
      for (var n3 = 0; n3 < r2.length; n3++) {
        var f8 = r2.charCodeAt(n3), a7 = f8 >> 8, i = f8 & 255;
        a7 ? t2.push(a7, i) : t2.push(i);
      }
    return t2;
  }
  o6.toArray = C11;
  function c13(r2) {
    return r2.length === 1 ? "0" + r2 : r2;
  }
  o6.zero2 = c13;
  function v19(r2) {
    for (var e = "", t2 = 0; t2 < r2.length; t2++)
      e += c13(r2[t2].toString(16));
    return e;
  }
  o6.toHex = v19;
  o6.encode = function(e, t2) {
    return t2 === "hex" ? v19(e) : e;
  };
});
var d2 = h2(u2());
var I = h2(u2());
var { default: S, ...b1 } = I;
var q1 = d2.default ?? S ?? b1;
var _1 = Object.create;
var p4 = Object.defineProperty;
var g3 = Object.getOwnPropertyDescriptor;
var d3 = Object.getOwnPropertyNames;
var v1 = Object.getPrototypeOf;
var V = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (e, i) => (typeof require != "undefined" ? require : e)[i]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var x4 = (t2, e) => () => (e || t2((e = {
  exports: {}
}).exports, e), e.exports);
var A2 = (t2, e, i, r2) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let s10 of d3(e))
      !V.call(t2, s10) && s10 !== i && p4(t2, s10, {
        get: () => e[s10],
        enumerable: !(r2 = g3(e, s10)) || r2.enumerable
      });
  return t2;
};
var c3 = (t2, e, i) => (i = t2 != null ? _1(v1(t2)) : {}, A2(e || !t2 || !t2.__esModule ? p4(i, "default", {
  value: t2,
  enumerable: true
}) : i, t2));
var o = x4(($17, l22) => {
  "use strict";
  var w24 = Qe, a7 = q1, m20 = j;
  function n3(t2) {
    if (!(this instanceof n3))
      return new n3(t2);
    this.hash = t2.hash, this.predResist = !!t2.predResist, this.outLen = this.hash.outSize, this.minEntropy = t2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = a7.toArray(t2.entropy, t2.entropyEnc || "hex"), i = a7.toArray(t2.nonce, t2.nonceEnc || "hex"), r2 = a7.toArray(t2.pers, t2.persEnc || "hex");
    m20(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, i, r2);
  }
  l22.exports = n3;
  n3.prototype._init = function(e, i, r2) {
    var s10 = e.concat(i).concat(r2);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var h16 = 0; h16 < this.V.length; h16++)
      this.K[h16] = 0, this.V[h16] = 1;
    this._update(s10), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  n3.prototype._hmac = function() {
    return new w24.hmac(this.hash, this.K);
  };
  n3.prototype._update = function(e) {
    var i = this._hmac().update(this.V).update([
      0
    ]);
    e && (i = i.update(e)), this.K = i.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([
      1
    ]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  n3.prototype.reseed = function(e, i, r2, s10) {
    typeof i != "string" && (s10 = r2, r2 = i, i = null), e = a7.toArray(e, i), r2 = a7.toArray(r2, s10), m20(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(r2 || [])), this._reseed = 1;
  };
  n3.prototype.generate = function(e, i, r2, s10) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof i != "string" && (s10 = r2, r2 = i, i = null), r2 && (r2 = a7.toArray(r2, s10 || "hex"), this._update(r2));
    for (var h16 = []; h16.length < e; )
      this.V = this._hmac().update(this.V).digest(), h16 = h16.concat(this.V);
    var y16 = h16.slice(0, e);
    return this._update(r2), this._reseed++, a7.encode(y16, i);
  };
});
var f1 = c3(o());
var K2 = c3(o());
var { default: E1, ...q2 } = K2;
var I1 = f1.default ?? E1 ?? q2;
var pf = Object.create;
var Pe = Object.defineProperty;
var yf = Object.getOwnPropertyDescriptor;
var mf = Object.getOwnPropertyNames;
var Sf = Object.getPrototypeOf;
var gf = Object.prototype.hasOwnProperty;
((d14) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(d14, {
  get: (e, f8) => (typeof require != "undefined" ? require : e)[f8]
}) : d14)(function(d14) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + d14 + '" is not supported');
});
var M = (d14, e) => () => (e || d14((e = {
  exports: {}
}).exports, e), e.exports);
var Af = (d14, e, f8, r2) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let a7 of mf(e))
      !gf.call(d14, a7) && a7 !== f8 && Pe(d14, a7, {
        get: () => e[a7],
        enumerable: !(r2 = yf(e, a7)) || r2.enumerable
      });
  return d14;
};
var ze = (d14, e, f8) => (f8 = d14 != null ? pf(Sf(d14)) : {}, Af(e || !d14 || !d14.__esModule ? Pe(f8, "default", {
  value: d14,
  enumerable: true
}) : f8, d14));
var Re = M((Qf, xf) => {
  xf.exports = {
    name: "elliptic",
    version: "6.5.4",
    description: "EC cryptography",
    main: "lib/elliptic.js",
    files: [
      "lib"
    ],
    scripts: {
      lint: "eslint lib test",
      "lint:fix": "npm run lint -- --fix",
      unit: "istanbul test _mocha --reporter=spec test/index.js",
      test: "npm run lint && npm run unit",
      version: "grunt dist && git add dist/"
    },
    repository: {
      type: "git",
      url: "git@github.com:indutny/elliptic"
    },
    keywords: [
      "EC",
      "Elliptic",
      "curve",
      "Cryptography"
    ],
    author: "Fedor Indutny <fedor@indutny.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/indutny/elliptic/issues"
    },
    homepage: "https://github.com/indutny/elliptic",
    devDependencies: {
      brfs: "^2.0.2",
      coveralls: "^3.1.0",
      eslint: "^7.6.0",
      grunt: "^1.2.1",
      "grunt-browserify": "^5.3.0",
      "grunt-cli": "^1.3.2",
      "grunt-contrib-connect": "^3.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^5.0.0",
      "grunt-mocha-istanbul": "^5.0.2",
      "grunt-saucelabs": "^9.0.1",
      istanbul: "^0.4.5",
      mocha: "^8.0.1"
    },
    dependencies: {
      "bn.js": "^4.11.9",
      brorand: "^1.1.0",
      "hash.js": "^1.0.0",
      "hmac-drbg": "^1.0.1",
      inherits: "^2.0.4",
      "minimalistic-assert": "^1.0.1",
      "minimalistic-crypto-utils": "^1.0.1"
    }
  };
});
var z1 = M((Ne) => {
  "use strict";
  var B18 = Ne, If = ki, wf = j, fe4 = q1;
  B18.assert = wf;
  B18.toArray = fe4.toArray;
  B18.zero2 = fe4.zero2;
  B18.toHex = fe4.toHex;
  B18.encode = fe4.encode;
  function Mf(d14, e, f8) {
    var r2 = new Array(Math.max(d14.bitLength(), f8) + 1);
    r2.fill(0);
    for (var a7 = 1 << e + 1, c13 = d14.clone(), b15 = 0; b15 < r2.length; b15++) {
      var t2, i = c13.andln(a7 - 1);
      c13.isOdd() ? (i > (a7 >> 1) - 1 ? t2 = (a7 >> 1) - i : t2 = i, c13.isubn(t2)) : t2 = 0, r2[b15] = t2, c13.iushrn(1);
    }
    return r2;
  }
  B18.getNAF = Mf;
  function qf(d14, e) {
    var f8 = [
      [],
      []
    ];
    d14 = d14.clone(), e = e.clone();
    for (var r2 = 0, a7 = 0, c13; d14.cmpn(-r2) > 0 || e.cmpn(-a7) > 0; ) {
      var b15 = d14.andln(3) + r2 & 3, t2 = e.andln(3) + a7 & 3;
      b15 === 3 && (b15 = -1), t2 === 3 && (t2 = -1);
      var i;
      (b15 & 1) === 0 ? i = 0 : (c13 = d14.andln(7) + r2 & 7, (c13 === 3 || c13 === 5) && t2 === 2 ? i = -b15 : i = b15), f8[0].push(i);
      var s10;
      (t2 & 1) === 0 ? s10 = 0 : (c13 = e.andln(7) + a7 & 7, (c13 === 3 || c13 === 5) && b15 === 2 ? s10 = -t2 : s10 = t2), f8[1].push(s10), 2 * r2 === i + 1 && (r2 = 1 - r2), 2 * a7 === s10 + 1 && (a7 = 1 - a7), d14.iushrn(1), e.iushrn(1);
    }
    return f8;
  }
  B18.getJSF = qf;
  function _f(d14, e, f8) {
    var r2 = "_" + e;
    d14.prototype[e] = function() {
      return this[r2] !== void 0 ? this[r2] : this[r2] = f8.call(this);
    };
  }
  B18.cachedProperty = _f;
  function Pf(d14) {
    return typeof d14 == "string" ? B18.toArray(d14, "hex") : d14;
  }
  B18.parseBytes = Pf;
  function zf(d14) {
    return new If(d14, "hex", "le");
  }
  B18.intFromLE = zf;
});
var Q = M((fd, Ee2) => {
  "use strict";
  var X5 = ki, Z2 = z1(), de2 = Z2.getNAF, Rf = Z2.getJSF, re4 = Z2.assert;
  function L18(d14, e) {
    this.type = d14, this.p = new X5(e.p, 16), this.red = e.prime ? X5.red(e.prime) : X5.mont(this.p), this.zero = new X5(0).toRed(this.red), this.one = new X5(1).toRed(this.red), this.two = new X5(2).toRed(this.red), this.n = e.n && new X5(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var f8 = this.n && this.p.div(this.n);
    !f8 || f8.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  Ee2.exports = L18;
  L18.prototype.point = function() {
    throw new Error("Not implemented");
  };
  L18.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  L18.prototype._fixedNafMul = function(e, f8) {
    re4(e.precomputed);
    var r2 = e._getDoubles(), a7 = de2(f8, 1, this._bitLength), c13 = (1 << r2.step + 1) - (r2.step % 2 === 0 ? 2 : 1);
    c13 /= 3;
    var b15 = [], t2, i;
    for (t2 = 0; t2 < a7.length; t2 += r2.step) {
      i = 0;
      for (var s10 = t2 + r2.step - 1; s10 >= t2; s10--)
        i = (i << 1) + a7[s10];
      b15.push(i);
    }
    for (var n3 = this.jpoint(null, null, null), u12 = this.jpoint(null, null, null), o6 = c13; o6 > 0; o6--) {
      for (t2 = 0; t2 < b15.length; t2++)
        i = b15[t2], i === o6 ? u12 = u12.mixedAdd(r2.points[t2]) : i === -o6 && (u12 = u12.mixedAdd(r2.points[t2].neg()));
      n3 = n3.add(u12);
    }
    return n3.toP();
  };
  L18.prototype._wnafMul = function(e, f8) {
    var r2 = 4, a7 = e._getNAFPoints(r2);
    r2 = a7.wnd;
    for (var c13 = a7.points, b15 = de2(f8, r2, this._bitLength), t2 = this.jpoint(null, null, null), i = b15.length - 1; i >= 0; i--) {
      for (var s10 = 0; i >= 0 && b15[i] === 0; i--)
        s10++;
      if (i >= 0 && s10++, t2 = t2.dblp(s10), i < 0)
        break;
      var n3 = b15[i];
      re4(n3 !== 0), e.type === "affine" ? n3 > 0 ? t2 = t2.mixedAdd(c13[n3 - 1 >> 1]) : t2 = t2.mixedAdd(c13[-n3 - 1 >> 1].neg()) : n3 > 0 ? t2 = t2.add(c13[n3 - 1 >> 1]) : t2 = t2.add(c13[-n3 - 1 >> 1].neg());
    }
    return e.type === "affine" ? t2.toP() : t2;
  };
  L18.prototype._wnafMulAdd = function(e, f8, r2, a7, c13) {
    var b15 = this._wnafT1, t2 = this._wnafT2, i = this._wnafT3, s10 = 0, n3, u12, o6;
    for (n3 = 0; n3 < a7; n3++) {
      o6 = f8[n3];
      var v19 = o6._getNAFPoints(e);
      b15[n3] = v19.wnd, t2[n3] = v19.points;
    }
    for (n3 = a7 - 1; n3 >= 1; n3 -= 2) {
      var h16 = n3 - 1, l22 = n3;
      if (b15[h16] !== 1 || b15[l22] !== 1) {
        i[h16] = de2(r2[h16], b15[h16], this._bitLength), i[l22] = de2(r2[l22], b15[l22], this._bitLength), s10 = Math.max(i[h16].length, s10), s10 = Math.max(i[l22].length, s10);
        continue;
      }
      var S14 = [
        f8[h16],
        null,
        null,
        f8[l22]
      ];
      f8[h16].y.cmp(f8[l22].y) === 0 ? (S14[1] = f8[h16].add(f8[l22]), S14[2] = f8[h16].toJ().mixedAdd(f8[l22].neg())) : f8[h16].y.cmp(f8[l22].y.redNeg()) === 0 ? (S14[1] = f8[h16].toJ().mixedAdd(f8[l22]), S14[2] = f8[h16].add(f8[l22].neg())) : (S14[1] = f8[h16].toJ().mixedAdd(f8[l22]), S14[2] = f8[h16].toJ().mixedAdd(f8[l22].neg()));
      var p7 = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ], P13 = Rf(r2[h16], r2[l22]);
      for (s10 = Math.max(P13[0].length, s10), i[h16] = new Array(s10), i[l22] = new Array(s10), u12 = 0; u12 < s10; u12++) {
        var D12 = P13[0][u12] | 0, he3 = P13[1][u12] | 0;
        i[h16][u12] = p7[(D12 + 1) * 3 + (he3 + 1)], i[l22][u12] = 0, t2[h16] = S14;
      }
    }
    var F12 = this.jpoint(null, null, null), G11 = this._wnafT4;
    for (n3 = s10; n3 >= 0; n3--) {
      for (var ve2 = 0; n3 >= 0; ) {
        var _e2 = true;
        for (u12 = 0; u12 < a7; u12++)
          G11[u12] = i[u12][n3] | 0, G11[u12] !== 0 && (_e2 = false);
        if (!_e2)
          break;
        ve2++, n3--;
      }
      if (n3 >= 0 && ve2++, F12 = F12.dblp(ve2), n3 < 0)
        break;
      for (u12 = 0; u12 < a7; u12++) {
        var V8 = G11[u12];
        V8 !== 0 && (V8 > 0 ? o6 = t2[u12][V8 - 1 >> 1] : V8 < 0 && (o6 = t2[u12][-V8 - 1 >> 1].neg()), o6.type === "affine" ? F12 = F12.mixedAdd(o6) : F12 = F12.add(o6));
      }
    }
    for (n3 = 0; n3 < a7; n3++)
      t2[n3] = null;
    return c13 ? F12 : F12.toP();
  };
  function R13(d14, e) {
    this.curve = d14, this.type = e, this.precomputed = null;
  }
  L18.BasePoint = R13;
  R13.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  R13.prototype.validate = function() {
    return this.curve.validate(this);
  };
  L18.prototype.decodePoint = function(e, f8) {
    e = Z2.toArray(e, f8);
    var r2 = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r2) {
      e[0] === 6 ? re4(e[e.length - 1] % 2 === 0) : e[0] === 7 && re4(e[e.length - 1] % 2 === 1);
      var a7 = this.point(e.slice(1, 1 + r2), e.slice(1 + r2, 1 + 2 * r2));
      return a7;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r2)
      return this.pointFromX(e.slice(1, 1 + r2), e[0] === 3);
    throw new Error("Unknown point format");
  };
  R13.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  R13.prototype._encode = function(e) {
    var f8 = this.curve.p.byteLength(), r2 = this.getX().toArray("be", f8);
    return e ? [
      this.getY().isEven() ? 2 : 3
    ].concat(r2) : [
      4
    ].concat(r2, this.getY().toArray("be", f8));
  };
  R13.prototype.encode = function(e, f8) {
    return Z2.encode(this._encode(f8), e);
  };
  R13.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var f8 = {
      doubles: null,
      naf: null,
      beta: null
    };
    return f8.naf = this._getNAFPoints(8), f8.doubles = this._getDoubles(4, e), f8.beta = this._getBeta(), this.precomputed = f8, this;
  };
  R13.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var f8 = this.precomputed.doubles;
    return f8 ? f8.points.length >= Math.ceil((e.bitLength() + 1) / f8.step) : false;
  };
  R13.prototype._getDoubles = function(e, f8) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var r2 = [
      this
    ], a7 = this, c13 = 0; c13 < f8; c13 += e) {
      for (var b15 = 0; b15 < e; b15++)
        a7 = a7.dbl();
      r2.push(a7);
    }
    return {
      step: e,
      points: r2
    };
  };
  R13.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var f8 = [
      this
    ], r2 = (1 << e) - 1, a7 = r2 === 1 ? null : this.dbl(), c13 = 1; c13 < r2; c13++)
      f8[c13] = f8[c13 - 1].add(a7);
    return {
      wnd: e,
      points: f8
    };
  };
  R13.prototype._getBeta = function() {
    return null;
  };
  R13.prototype.dblp = function(e) {
    for (var f8 = this, r2 = 0; r2 < e; r2++)
      f8 = f8.dbl();
    return f8;
  };
});
var Fe = M((dd, Be2) => {
  "use strict";
  var Nf = z1(), m20 = ki, le3 = w, W2 = Q(), Ef = Nf.assert;
  function N6(d14) {
    W2.call(this, "short", d14), this.a = new m20(d14.a, 16).toRed(this.red), this.b = new m20(d14.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(d14), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  le3(N6, W2);
  Be2.exports = N6;
  N6.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var f8, r2;
      if (e.beta)
        f8 = new m20(e.beta, 16).toRed(this.red);
      else {
        var a7 = this._getEndoRoots(this.p);
        f8 = a7[0].cmp(a7[1]) < 0 ? a7[0] : a7[1], f8 = f8.toRed(this.red);
      }
      if (e.lambda)
        r2 = new m20(e.lambda, 16);
      else {
        var c13 = this._getEndoRoots(this.n);
        this.g.mul(c13[0]).x.cmp(this.g.x.redMul(f8)) === 0 ? r2 = c13[0] : (r2 = c13[1], Ef(this.g.mul(r2).x.cmp(this.g.x.redMul(f8)) === 0));
      }
      var b15;
      return e.basis ? b15 = e.basis.map(function(t2) {
        return {
          a: new m20(t2.a, 16),
          b: new m20(t2.b, 16)
        };
      }) : b15 = this._getEndoBasis(r2), {
        beta: f8,
        lambda: r2,
        basis: b15
      };
    }
  };
  N6.prototype._getEndoRoots = function(e) {
    var f8 = e === this.p ? this.red : m20.mont(e), r2 = new m20(2).toRed(f8).redInvm(), a7 = r2.redNeg(), c13 = new m20(3).toRed(f8).redNeg().redSqrt().redMul(r2), b15 = a7.redAdd(c13).fromRed(), t2 = a7.redSub(c13).fromRed();
    return [
      b15,
      t2
    ];
  };
  N6.prototype._getEndoBasis = function(e) {
    for (var f8 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r2 = e, a7 = this.n.clone(), c13 = new m20(1), b15 = new m20(0), t2 = new m20(0), i = new m20(1), s10, n3, u12, o6, v19, h16, l22, S14 = 0, p7, P13; r2.cmpn(0) !== 0; ) {
      var D12 = a7.div(r2);
      p7 = a7.sub(D12.mul(r2)), P13 = t2.sub(D12.mul(c13));
      var he3 = i.sub(D12.mul(b15));
      if (!u12 && p7.cmp(f8) < 0)
        s10 = l22.neg(), n3 = c13, u12 = p7.neg(), o6 = P13;
      else if (u12 && ++S14 === 2)
        break;
      l22 = p7, a7 = r2, r2 = p7, t2 = c13, c13 = P13, i = b15, b15 = he3;
    }
    v19 = p7.neg(), h16 = P13;
    var F12 = u12.sqr().add(o6.sqr()), G11 = v19.sqr().add(h16.sqr());
    return G11.cmp(F12) >= 0 && (v19 = s10, h16 = n3), u12.negative && (u12 = u12.neg(), o6 = o6.neg()), v19.negative && (v19 = v19.neg(), h16 = h16.neg()), [
      {
        a: u12,
        b: o6
      },
      {
        a: v19,
        b: h16
      }
    ];
  };
  N6.prototype._endoSplit = function(e) {
    var f8 = this.endo.basis, r2 = f8[0], a7 = f8[1], c13 = a7.b.mul(e).divRound(this.n), b15 = r2.b.neg().mul(e).divRound(this.n), t2 = c13.mul(r2.a), i = b15.mul(a7.a), s10 = c13.mul(r2.b), n3 = b15.mul(a7.b), u12 = e.sub(t2).sub(i), o6 = s10.add(n3).neg();
    return {
      k1: u12,
      k2: o6
    };
  };
  N6.prototype.pointFromX = function(e, f8) {
    e = new m20(e, 16), e.red || (e = e.toRed(this.red));
    var r2 = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), a7 = r2.redSqrt();
    if (a7.redSqr().redSub(r2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var c13 = a7.fromRed().isOdd();
    return (f8 && !c13 || !f8 && c13) && (a7 = a7.redNeg()), this.point(e, a7);
  };
  N6.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var f8 = e.x, r2 = e.y, a7 = this.a.redMul(f8), c13 = f8.redSqr().redMul(f8).redIAdd(a7).redIAdd(this.b);
    return r2.redSqr().redISub(c13).cmpn(0) === 0;
  };
  N6.prototype._endoWnafMulAdd = function(e, f8, r2) {
    for (var a7 = this._endoWnafT1, c13 = this._endoWnafT2, b15 = 0; b15 < e.length; b15++) {
      var t2 = this._endoSplit(f8[b15]), i = e[b15], s10 = i._getBeta();
      t2.k1.negative && (t2.k1.ineg(), i = i.neg(true)), t2.k2.negative && (t2.k2.ineg(), s10 = s10.neg(true)), a7[b15 * 2] = i, a7[b15 * 2 + 1] = s10, c13[b15 * 2] = t2.k1, c13[b15 * 2 + 1] = t2.k2;
    }
    for (var n3 = this._wnafMulAdd(1, a7, c13, b15 * 2, r2), u12 = 0; u12 < b15 * 2; u12++)
      a7[u12] = null, c13[u12] = null;
    return n3;
  };
  function A14(d14, e, f8, r2) {
    W2.BasePoint.call(this, d14, "affine"), e === null && f8 === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new m20(e, 16), this.y = new m20(f8, 16), r2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  le3(A14, W2.BasePoint);
  N6.prototype.point = function(e, f8, r2) {
    return new A14(this, e, f8, r2);
  };
  N6.prototype.pointFromJSON = function(e, f8) {
    return A14.fromJSON(this, e, f8);
  };
  A14.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var f8 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var r2 = this.curve, a7 = function(c13) {
          return r2.point(c13.x.redMul(r2.endo.beta), c13.y);
        };
        e.beta = f8, f8.precomputed = {
          beta: null,
          naf: e.naf && {
            wnd: e.naf.wnd,
            points: e.naf.points.map(a7)
          },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(a7)
          }
        };
      }
      return f8;
    }
  };
  A14.prototype.toJSON = function() {
    return this.precomputed ? [
      this.x,
      this.y,
      this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }
    ] : [
      this.x,
      this.y
    ];
  };
  A14.fromJSON = function(e, f8, r2) {
    typeof f8 == "string" && (f8 = JSON.parse(f8));
    var a7 = e.point(f8[0], f8[1], r2);
    if (!f8[2])
      return a7;
    function c13(t2) {
      return e.point(t2[0], t2[1], r2);
    }
    var b15 = f8[2];
    return a7.precomputed = {
      beta: null,
      doubles: b15.doubles && {
        step: b15.doubles.step,
        points: [
          a7
        ].concat(b15.doubles.points.map(c13))
      },
      naf: b15.naf && {
        wnd: b15.naf.wnd,
        points: [
          a7
        ].concat(b15.naf.points.map(c13))
      }
    }, a7;
  };
  A14.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  A14.prototype.isInfinity = function() {
    return this.inf;
  };
  A14.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var f8 = this.y.redSub(e.y);
    f8.cmpn(0) !== 0 && (f8 = f8.redMul(this.x.redSub(e.x).redInvm()));
    var r2 = f8.redSqr().redISub(this.x).redISub(e.x), a7 = f8.redMul(this.x.redSub(r2)).redISub(this.y);
    return this.curve.point(r2, a7);
  };
  A14.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var f8 = this.curve.a, r2 = this.x.redSqr(), a7 = e.redInvm(), c13 = r2.redAdd(r2).redIAdd(r2).redIAdd(f8).redMul(a7), b15 = c13.redSqr().redISub(this.x.redAdd(this.x)), t2 = c13.redMul(this.x.redSub(b15)).redISub(this.y);
    return this.curve.point(b15, t2);
  };
  A14.prototype.getX = function() {
    return this.x.fromRed();
  };
  A14.prototype.getY = function() {
    return this.y.fromRed();
  };
  A14.prototype.mul = function(e) {
    return e = new m20(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([
      this
    ], [
      e
    ]) : this.curve._wnafMul(this, e);
  };
  A14.prototype.mulAdd = function(e, f8, r2) {
    var a7 = [
      this,
      f8
    ], c13 = [
      e,
      r2
    ];
    return this.curve.endo ? this.curve._endoWnafMulAdd(a7, c13) : this.curve._wnafMulAdd(1, a7, c13, 2);
  };
  A14.prototype.jmulAdd = function(e, f8, r2) {
    var a7 = [
      this,
      f8
    ], c13 = [
      e,
      r2
    ];
    return this.curve.endo ? this.curve._endoWnafMulAdd(a7, c13, true) : this.curve._wnafMulAdd(1, a7, c13, 2, true);
  };
  A14.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  A14.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var f8 = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var r2 = this.precomputed, a7 = function(c13) {
        return c13.neg();
      };
      f8.precomputed = {
        naf: r2.naf && {
          wnd: r2.naf.wnd,
          points: r2.naf.points.map(a7)
        },
        doubles: r2.doubles && {
          step: r2.doubles.step,
          points: r2.doubles.points.map(a7)
        }
      };
    }
    return f8;
  };
  A14.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function w110(d14, e, f8, r2) {
    W2.BasePoint.call(this, d14, "jacobian"), e === null && f8 === null && r2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new m20(0)) : (this.x = new m20(e, 16), this.y = new m20(f8, 16), this.z = new m20(r2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  le3(w110, W2.BasePoint);
  N6.prototype.jpoint = function(e, f8, r2) {
    return new w110(this, e, f8, r2);
  };
  w110.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), f8 = e.redSqr(), r2 = this.x.redMul(f8), a7 = this.y.redMul(f8).redMul(e);
    return this.curve.point(r2, a7);
  };
  w110.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  w110.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var f8 = e.z.redSqr(), r2 = this.z.redSqr(), a7 = this.x.redMul(f8), c13 = e.x.redMul(r2), b15 = this.y.redMul(f8.redMul(e.z)), t2 = e.y.redMul(r2.redMul(this.z)), i = a7.redSub(c13), s10 = b15.redSub(t2);
    if (i.cmpn(0) === 0)
      return s10.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var n3 = i.redSqr(), u12 = n3.redMul(i), o6 = a7.redMul(n3), v19 = s10.redSqr().redIAdd(u12).redISub(o6).redISub(o6), h16 = s10.redMul(o6.redISub(v19)).redISub(b15.redMul(u12)), l22 = this.z.redMul(e.z).redMul(i);
    return this.curve.jpoint(v19, h16, l22);
  };
  w110.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var f8 = this.z.redSqr(), r2 = this.x, a7 = e.x.redMul(f8), c13 = this.y, b15 = e.y.redMul(f8).redMul(this.z), t2 = r2.redSub(a7), i = c13.redSub(b15);
    if (t2.cmpn(0) === 0)
      return i.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var s10 = t2.redSqr(), n3 = s10.redMul(t2), u12 = r2.redMul(s10), o6 = i.redSqr().redIAdd(n3).redISub(u12).redISub(u12), v19 = i.redMul(u12.redISub(o6)).redISub(c13.redMul(n3)), h16 = this.z.redMul(t2);
    return this.curve.jpoint(o6, v19, h16);
  };
  w110.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var f8;
    if (this.curve.zeroA || this.curve.threeA) {
      var r2 = this;
      for (f8 = 0; f8 < e; f8++)
        r2 = r2.dbl();
      return r2;
    }
    var a7 = this.curve.a, c13 = this.curve.tinv, b15 = this.x, t2 = this.y, i = this.z, s10 = i.redSqr().redSqr(), n3 = t2.redAdd(t2);
    for (f8 = 0; f8 < e; f8++) {
      var u12 = b15.redSqr(), o6 = n3.redSqr(), v19 = o6.redSqr(), h16 = u12.redAdd(u12).redIAdd(u12).redIAdd(a7.redMul(s10)), l22 = b15.redMul(o6), S14 = h16.redSqr().redISub(l22.redAdd(l22)), p7 = l22.redISub(S14), P13 = h16.redMul(p7);
      P13 = P13.redIAdd(P13).redISub(v19);
      var D12 = n3.redMul(i);
      f8 + 1 < e && (s10 = s10.redMul(v19)), b15 = S14, i = D12, n3 = P13;
    }
    return this.curve.jpoint(b15, n3.redMul(c13), i);
  };
  w110.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  w110.prototype._zeroDbl = function() {
    var e, f8, r2;
    if (this.zOne) {
      var a7 = this.x.redSqr(), c13 = this.y.redSqr(), b15 = c13.redSqr(), t2 = this.x.redAdd(c13).redSqr().redISub(a7).redISub(b15);
      t2 = t2.redIAdd(t2);
      var i = a7.redAdd(a7).redIAdd(a7), s10 = i.redSqr().redISub(t2).redISub(t2), n3 = b15.redIAdd(b15);
      n3 = n3.redIAdd(n3), n3 = n3.redIAdd(n3), e = s10, f8 = i.redMul(t2.redISub(s10)).redISub(n3), r2 = this.y.redAdd(this.y);
    } else {
      var u12 = this.x.redSqr(), o6 = this.y.redSqr(), v19 = o6.redSqr(), h16 = this.x.redAdd(o6).redSqr().redISub(u12).redISub(v19);
      h16 = h16.redIAdd(h16);
      var l22 = u12.redAdd(u12).redIAdd(u12), S14 = l22.redSqr(), p7 = v19.redIAdd(v19);
      p7 = p7.redIAdd(p7), p7 = p7.redIAdd(p7), e = S14.redISub(h16).redISub(h16), f8 = l22.redMul(h16.redISub(e)).redISub(p7), r2 = this.y.redMul(this.z), r2 = r2.redIAdd(r2);
    }
    return this.curve.jpoint(e, f8, r2);
  };
  w110.prototype._threeDbl = function() {
    var e, f8, r2;
    if (this.zOne) {
      var a7 = this.x.redSqr(), c13 = this.y.redSqr(), b15 = c13.redSqr(), t2 = this.x.redAdd(c13).redSqr().redISub(a7).redISub(b15);
      t2 = t2.redIAdd(t2);
      var i = a7.redAdd(a7).redIAdd(a7).redIAdd(this.curve.a), s10 = i.redSqr().redISub(t2).redISub(t2);
      e = s10;
      var n3 = b15.redIAdd(b15);
      n3 = n3.redIAdd(n3), n3 = n3.redIAdd(n3), f8 = i.redMul(t2.redISub(s10)).redISub(n3), r2 = this.y.redAdd(this.y);
    } else {
      var u12 = this.z.redSqr(), o6 = this.y.redSqr(), v19 = this.x.redMul(o6), h16 = this.x.redSub(u12).redMul(this.x.redAdd(u12));
      h16 = h16.redAdd(h16).redIAdd(h16);
      var l22 = v19.redIAdd(v19);
      l22 = l22.redIAdd(l22);
      var S14 = l22.redAdd(l22);
      e = h16.redSqr().redISub(S14), r2 = this.y.redAdd(this.z).redSqr().redISub(o6).redISub(u12);
      var p7 = o6.redSqr();
      p7 = p7.redIAdd(p7), p7 = p7.redIAdd(p7), p7 = p7.redIAdd(p7), f8 = h16.redMul(l22.redISub(e)).redISub(p7);
    }
    return this.curve.jpoint(e, f8, r2);
  };
  w110.prototype._dbl = function() {
    var e = this.curve.a, f8 = this.x, r2 = this.y, a7 = this.z, c13 = a7.redSqr().redSqr(), b15 = f8.redSqr(), t2 = r2.redSqr(), i = b15.redAdd(b15).redIAdd(b15).redIAdd(e.redMul(c13)), s10 = f8.redAdd(f8);
    s10 = s10.redIAdd(s10);
    var n3 = s10.redMul(t2), u12 = i.redSqr().redISub(n3.redAdd(n3)), o6 = n3.redISub(u12), v19 = t2.redSqr();
    v19 = v19.redIAdd(v19), v19 = v19.redIAdd(v19), v19 = v19.redIAdd(v19);
    var h16 = i.redMul(o6).redISub(v19), l22 = r2.redAdd(r2).redMul(a7);
    return this.curve.jpoint(u12, h16, l22);
  };
  w110.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), f8 = this.y.redSqr(), r2 = this.z.redSqr(), a7 = f8.redSqr(), c13 = e.redAdd(e).redIAdd(e), b15 = c13.redSqr(), t2 = this.x.redAdd(f8).redSqr().redISub(e).redISub(a7);
    t2 = t2.redIAdd(t2), t2 = t2.redAdd(t2).redIAdd(t2), t2 = t2.redISub(b15);
    var i = t2.redSqr(), s10 = a7.redIAdd(a7);
    s10 = s10.redIAdd(s10), s10 = s10.redIAdd(s10), s10 = s10.redIAdd(s10);
    var n3 = c13.redIAdd(t2).redSqr().redISub(b15).redISub(i).redISub(s10), u12 = f8.redMul(n3);
    u12 = u12.redIAdd(u12), u12 = u12.redIAdd(u12);
    var o6 = this.x.redMul(i).redISub(u12);
    o6 = o6.redIAdd(o6), o6 = o6.redIAdd(o6);
    var v19 = this.y.redMul(n3.redMul(s10.redISub(n3)).redISub(t2.redMul(i)));
    v19 = v19.redIAdd(v19), v19 = v19.redIAdd(v19), v19 = v19.redIAdd(v19);
    var h16 = this.z.redAdd(t2).redSqr().redISub(r2).redISub(i);
    return this.curve.jpoint(o6, v19, h16);
  };
  w110.prototype.mul = function(e, f8) {
    return e = new m20(e, f8), this.curve._wnafMul(this, e);
  };
  w110.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var f8 = this.z.redSqr(), r2 = e.z.redSqr();
    if (this.x.redMul(r2).redISub(e.x.redMul(f8)).cmpn(0) !== 0)
      return false;
    var a7 = f8.redMul(this.z), c13 = r2.redMul(e.z);
    return this.y.redMul(c13).redISub(e.y.redMul(a7)).cmpn(0) === 0;
  };
  w110.prototype.eqXToP = function(e) {
    var f8 = this.z.redSqr(), r2 = e.toRed(this.curve.red).redMul(f8);
    if (this.x.cmp(r2) === 0)
      return true;
    for (var a7 = e.clone(), c13 = this.curve.redN.redMul(f8); ; ) {
      if (a7.iadd(this.curve.n), a7.cmp(this.curve.p) >= 0)
        return false;
      if (r2.redIAdd(c13), this.x.cmp(r2) === 0)
        return true;
    }
  };
  w110.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  w110.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var Le1 = M((rd, je2) => {
  "use strict";
  var k15 = ki, Oe = w, ae3 = Q(), Bf = z1();
  function H9(d14) {
    ae3.call(this, "mont", d14), this.a = new k15(d14.a, 16).toRed(this.red), this.b = new k15(d14.b, 16).toRed(this.red), this.i4 = new k15(4).toRed(this.red).redInvm(), this.two = new k15(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Oe(H9, ae3);
  je2.exports = H9;
  H9.prototype.validate = function(e) {
    var f8 = e.normalize().x, r2 = f8.redSqr(), a7 = r2.redMul(f8).redAdd(r2.redMul(this.a)).redAdd(f8), c13 = a7.redSqrt();
    return c13.redSqr().cmp(a7) === 0;
  };
  function x17(d14, e, f8) {
    ae3.BasePoint.call(this, d14, "projective"), e === null && f8 === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new k15(e, 16), this.z = new k15(f8, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  Oe(x17, ae3.BasePoint);
  H9.prototype.decodePoint = function(e, f8) {
    return this.point(Bf.toArray(e, f8), 1);
  };
  H9.prototype.point = function(e, f8) {
    return new x17(this, e, f8);
  };
  H9.prototype.pointFromJSON = function(e) {
    return x17.fromJSON(this, e);
  };
  x17.prototype.precompute = function() {
  };
  x17.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  x17.fromJSON = function(e, f8) {
    return new x17(e, f8[0], f8[1] || e.one);
  };
  x17.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  x17.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  x17.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), f8 = e.redSqr(), r2 = this.x.redSub(this.z), a7 = r2.redSqr(), c13 = f8.redSub(a7), b15 = f8.redMul(a7), t2 = c13.redMul(a7.redAdd(this.curve.a24.redMul(c13)));
    return this.curve.point(b15, t2);
  };
  x17.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  x17.prototype.diffAdd = function(e, f8) {
    var r2 = this.x.redAdd(this.z), a7 = this.x.redSub(this.z), c13 = e.x.redAdd(e.z), b15 = e.x.redSub(e.z), t2 = b15.redMul(r2), i = c13.redMul(a7), s10 = f8.z.redMul(t2.redAdd(i).redSqr()), n3 = f8.x.redMul(t2.redISub(i).redSqr());
    return this.curve.point(s10, n3);
  };
  x17.prototype.mul = function(e) {
    for (var f8 = e.clone(), r2 = this, a7 = this.curve.point(null, null), c13 = this, b15 = []; f8.cmpn(0) !== 0; f8.iushrn(1))
      b15.push(f8.andln(1));
    for (var t2 = b15.length - 1; t2 >= 0; t2--)
      b15[t2] === 0 ? (r2 = r2.diffAdd(a7, c13), a7 = a7.dbl()) : (a7 = r2.diffAdd(a7, c13), r2 = r2.dbl());
    return a7;
  };
  x17.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  x17.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  x17.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  x17.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  x17.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var De = M((ad, Je) => {
  "use strict";
  var Ff = z1(), j13 = ki, Ce = w, te2 = Q(), Of = Ff.assert;
  function O9(d14) {
    this.twisted = (d14.a | 0) !== 1, this.mOneA = this.twisted && (d14.a | 0) === -1, this.extended = this.mOneA, te2.call(this, "edwards", d14), this.a = new j13(d14.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new j13(d14.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new j13(d14.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Of(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (d14.c | 0) === 1;
  }
  Ce(O9, te2);
  Je.exports = O9;
  O9.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  O9.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  O9.prototype.jpoint = function(e, f8, r2, a7) {
    return this.point(e, f8, r2, a7);
  };
  O9.prototype.pointFromX = function(e, f8) {
    e = new j13(e, 16), e.red || (e = e.toRed(this.red));
    var r2 = e.redSqr(), a7 = this.c2.redSub(this.a.redMul(r2)), c13 = this.one.redSub(this.c2.redMul(this.d).redMul(r2)), b15 = a7.redMul(c13.redInvm()), t2 = b15.redSqrt();
    if (t2.redSqr().redSub(b15).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var i = t2.fromRed().isOdd();
    return (f8 && !i || !f8 && i) && (t2 = t2.redNeg()), this.point(e, t2);
  };
  O9.prototype.pointFromY = function(e, f8) {
    e = new j13(e, 16), e.red || (e = e.toRed(this.red));
    var r2 = e.redSqr(), a7 = r2.redSub(this.c2), c13 = r2.redMul(this.d).redMul(this.c2).redSub(this.a), b15 = a7.redMul(c13.redInvm());
    if (b15.cmp(this.zero) === 0) {
      if (f8)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var t2 = b15.redSqrt();
    if (t2.redSqr().redSub(b15).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return t2.fromRed().isOdd() !== f8 && (t2 = t2.redNeg()), this.point(t2, e);
  };
  O9.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var f8 = e.x.redSqr(), r2 = e.y.redSqr(), a7 = f8.redMul(this.a).redAdd(r2), c13 = this.c2.redMul(this.one.redAdd(this.d.redMul(f8).redMul(r2)));
    return a7.cmp(c13) === 0;
  };
  function y16(d14, e, f8, r2, a7) {
    te2.BasePoint.call(this, d14, "projective"), e === null && f8 === null && r2 === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new j13(e, 16), this.y = new j13(f8, 16), this.z = r2 ? new j13(r2, 16) : this.curve.one, this.t = a7 && new j13(a7, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  Ce(y16, te2.BasePoint);
  O9.prototype.pointFromJSON = function(e) {
    return y16.fromJSON(this, e);
  };
  O9.prototype.point = function(e, f8, r2, a7) {
    return new y16(this, e, f8, r2, a7);
  };
  y16.fromJSON = function(e, f8) {
    return new y16(e, f8[0], f8[1], f8[2]);
  };
  y16.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  y16.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  y16.prototype._extDbl = function() {
    var e = this.x.redSqr(), f8 = this.y.redSqr(), r2 = this.z.redSqr();
    r2 = r2.redIAdd(r2);
    var a7 = this.curve._mulA(e), c13 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(f8), b15 = a7.redAdd(f8), t2 = b15.redSub(r2), i = a7.redSub(f8), s10 = c13.redMul(t2), n3 = b15.redMul(i), u12 = c13.redMul(i), o6 = t2.redMul(b15);
    return this.curve.point(s10, n3, o6, u12);
  };
  y16.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), f8 = this.x.redSqr(), r2 = this.y.redSqr(), a7, c13, b15, t2, i, s10;
    if (this.curve.twisted) {
      t2 = this.curve._mulA(f8);
      var n3 = t2.redAdd(r2);
      this.zOne ? (a7 = e.redSub(f8).redSub(r2).redMul(n3.redSub(this.curve.two)), c13 = n3.redMul(t2.redSub(r2)), b15 = n3.redSqr().redSub(n3).redSub(n3)) : (i = this.z.redSqr(), s10 = n3.redSub(i).redISub(i), a7 = e.redSub(f8).redISub(r2).redMul(s10), c13 = n3.redMul(t2.redSub(r2)), b15 = n3.redMul(s10));
    } else
      t2 = f8.redAdd(r2), i = this.curve._mulC(this.z).redSqr(), s10 = t2.redSub(i).redSub(i), a7 = this.curve._mulC(e.redISub(t2)).redMul(s10), c13 = this.curve._mulC(t2).redMul(f8.redISub(r2)), b15 = t2.redMul(s10);
    return this.curve.point(a7, c13, b15);
  };
  y16.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  y16.prototype._extAdd = function(e) {
    var f8 = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), r2 = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), a7 = this.t.redMul(this.curve.dd).redMul(e.t), c13 = this.z.redMul(e.z.redAdd(e.z)), b15 = r2.redSub(f8), t2 = c13.redSub(a7), i = c13.redAdd(a7), s10 = r2.redAdd(f8), n3 = b15.redMul(t2), u12 = i.redMul(s10), o6 = b15.redMul(s10), v19 = t2.redMul(i);
    return this.curve.point(n3, u12, v19, o6);
  };
  y16.prototype._projAdd = function(e) {
    var f8 = this.z.redMul(e.z), r2 = f8.redSqr(), a7 = this.x.redMul(e.x), c13 = this.y.redMul(e.y), b15 = this.curve.d.redMul(a7).redMul(c13), t2 = r2.redSub(b15), i = r2.redAdd(b15), s10 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(a7).redISub(c13), n3 = f8.redMul(t2).redMul(s10), u12, o6;
    return this.curve.twisted ? (u12 = f8.redMul(i).redMul(c13.redSub(this.curve._mulA(a7))), o6 = t2.redMul(i)) : (u12 = f8.redMul(i).redMul(c13.redSub(a7)), o6 = this.curve._mulC(t2).redMul(i)), this.curve.point(n3, u12, o6);
  };
  y16.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  y16.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  y16.prototype.mulAdd = function(e, f8, r2) {
    return this.curve._wnafMulAdd(1, [
      this,
      f8
    ], [
      e,
      r2
    ], 2, false);
  };
  y16.prototype.jmulAdd = function(e, f8, r2) {
    return this.curve._wnafMulAdd(1, [
      this,
      f8
    ], [
      e,
      r2
    ], 2, true);
  };
  y16.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  y16.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  y16.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  y16.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  y16.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  y16.prototype.eqXToP = function(e) {
    var f8 = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(f8) === 0)
      return true;
    for (var r2 = e.clone(), a7 = this.curve.redN.redMul(this.z); ; ) {
      if (r2.iadd(this.curve.n), r2.cmp(this.curve.p) >= 0)
        return false;
      if (f8.redIAdd(a7), this.x.cmp(f8) === 0)
        return true;
    }
  };
  y16.prototype.toP = y16.prototype.normalize;
  y16.prototype.mixedAdd = y16.prototype.add;
});
var pe = M((Xe) => {
  "use strict";
  var ce4 = Xe;
  ce4.base = Q();
  ce4.short = Fe();
  ce4.mont = Le1();
  ce4.edwards = De();
});
var Ye = M((cd, Te) => {
  Te.exports = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
});
var be = M((ke3) => {
  "use strict";
  var me2 = ke3, C11 = Qe, ye4 = pe(), jf = z1(), Ke2 = jf.assert;
  function We2(d14) {
    d14.type === "short" ? this.curve = new ye4.short(d14) : d14.type === "edwards" ? this.curve = new ye4.edwards(d14) : this.curve = new ye4.mont(d14), this.g = this.curve.g, this.n = this.curve.n, this.hash = d14.hash, Ke2(this.g.validate(), "Invalid curve"), Ke2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  me2.PresetCurve = We2;
  function J14(d14, e) {
    Object.defineProperty(me2, d14, {
      configurable: true,
      enumerable: true,
      get: function() {
        var f8 = new We2(e);
        return Object.defineProperty(me2, d14, {
          configurable: true,
          enumerable: true,
          value: f8
        }), f8;
      }
    });
  }
  J14("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: C11.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  J14("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: C11.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  J14("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: C11.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  J14("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: C11.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  J14("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: C11.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  J14("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: C11.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  J14("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: C11.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Se2;
  try {
    Se2 = Ye();
  } catch {
    Se2 = void 0;
  }
  J14("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: C11.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Se2
    ]
  });
});
var Ue = M((id, He4) => {
  "use strict";
  var Lf = ki, Cf = z1(), ge2 = Cf.assert;
  function q15(d14, e) {
    this.ec = d14, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  He4.exports = q15;
  q15.fromPublic = function(e, f8, r2) {
    return f8 instanceof q15 ? f8 : new q15(e, {
      pub: f8,
      pubEnc: r2
    });
  };
  q15.fromPrivate = function(e, f8, r2) {
    return f8 instanceof q15 ? f8 : new q15(e, {
      priv: f8,
      privEnc: r2
    });
  };
  q15.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
      result: false,
      reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
      result: true,
      reason: null
    } : {
      result: false,
      reason: "Public key * N != O"
    } : {
      result: false,
      reason: "Public key is not a point"
    };
  };
  q15.prototype.getPublic = function(e, f8) {
    return typeof e == "string" && (f8 = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), f8 ? this.pub.encode(f8, e) : this.pub;
  };
  q15.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  q15.prototype._importPrivate = function(e, f8) {
    this.priv = new Lf(e, f8 || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  q15.prototype._importPublic = function(e, f8) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? ge2(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ge2(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, f8);
  };
  q15.prototype.derive = function(e) {
    return e.validate() || ge2(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  q15.prototype.sign = function(e, f8, r2) {
    return this.ec.sign(e, this, f8, r2);
  };
  q15.prototype.verify = function(e, f8) {
    return this.ec.verify(e, f8, this);
  };
  q15.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var Ve = M((nd, Ge2) => {
  "use strict";
  var ie3 = ki, Ie = z1(), Jf = Ie.assert;
  function ne2(d14, e) {
    if (d14 instanceof ne2)
      return d14;
    this._importDER(d14, e) || (Jf(d14.r && d14.s, "Signature without r or s"), this.r = new ie3(d14.r, 16), this.s = new ie3(d14.s, 16), d14.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = d14.recoveryParam);
  }
  Ge2.exports = ne2;
  function Df() {
    this.place = 0;
  }
  function Ae3(d14, e) {
    var f8 = d14[e.place++];
    if (!(f8 & 128))
      return f8;
    var r2 = f8 & 15;
    if (r2 === 0 || r2 > 4)
      return false;
    for (var a7 = 0, c13 = 0, b15 = e.place; c13 < r2; c13++, b15++)
      a7 <<= 8, a7 |= d14[b15], a7 >>>= 0;
    return a7 <= 127 ? false : (e.place = b15, a7);
  }
  function $e2(d14) {
    for (var e = 0, f8 = d14.length - 1; !d14[e] && !(d14[e + 1] & 128) && e < f8; )
      e++;
    return e === 0 ? d14 : d14.slice(e);
  }
  ne2.prototype._importDER = function(e, f8) {
    e = Ie.toArray(e, f8);
    var r2 = new Df();
    if (e[r2.place++] !== 48)
      return false;
    var a7 = Ae3(e, r2);
    if (a7 === false || a7 + r2.place !== e.length || e[r2.place++] !== 2)
      return false;
    var c13 = Ae3(e, r2);
    if (c13 === false)
      return false;
    var b15 = e.slice(r2.place, c13 + r2.place);
    if (r2.place += c13, e[r2.place++] !== 2)
      return false;
    var t2 = Ae3(e, r2);
    if (t2 === false || e.length !== t2 + r2.place)
      return false;
    var i = e.slice(r2.place, t2 + r2.place);
    if (b15[0] === 0)
      if (b15[1] & 128)
        b15 = b15.slice(1);
      else
        return false;
    if (i[0] === 0)
      if (i[1] & 128)
        i = i.slice(1);
      else
        return false;
    return this.r = new ie3(b15), this.s = new ie3(i), this.recoveryParam = null, true;
  };
  function xe4(d14, e) {
    if (e < 128) {
      d14.push(e);
      return;
    }
    var f8 = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (d14.push(f8 | 128); --f8; )
      d14.push(e >>> (f8 << 3) & 255);
    d14.push(e);
  }
  ne2.prototype.toDER = function(e) {
    var f8 = this.r.toArray(), r2 = this.s.toArray();
    for (f8[0] & 128 && (f8 = [
      0
    ].concat(f8)), r2[0] & 128 && (r2 = [
      0
    ].concat(r2)), f8 = $e2(f8), r2 = $e2(r2); !r2[0] && !(r2[1] & 128); )
      r2 = r2.slice(1);
    var a7 = [
      2
    ];
    xe4(a7, f8.length), a7 = a7.concat(f8), a7.push(2), xe4(a7, r2.length);
    var c13 = a7.concat(r2), b15 = [
      48
    ];
    return xe4(b15, c13.length), b15 = b15.concat(c13), Ie.encode(b15, e);
  };
});
var ff = M((sd, ef) => {
  "use strict";
  var T12 = ki, Ze2 = I1, Xf = z1(), we2 = be(), Tf = C, Qe2 = Xf.assert, Me = Ue(), se3 = Ve();
  function E15(d14) {
    if (!(this instanceof E15))
      return new E15(d14);
    typeof d14 == "string" && (Qe2(Object.prototype.hasOwnProperty.call(we2, d14), "Unknown curve " + d14), d14 = we2[d14]), d14 instanceof we2.PresetCurve && (d14 = {
      curve: d14
    }), this.curve = d14.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = d14.curve.g, this.g.precompute(d14.curve.n.bitLength() + 1), this.hash = d14.hash || d14.curve.hash;
  }
  ef.exports = E15;
  E15.prototype.keyPair = function(e) {
    return new Me(this, e);
  };
  E15.prototype.keyFromPrivate = function(e, f8) {
    return Me.fromPrivate(this, e, f8);
  };
  E15.prototype.keyFromPublic = function(e, f8) {
    return Me.fromPublic(this, e, f8);
  };
  E15.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var f8 = new Ze2({
      hash: this.hash,
      pers: e.pers,
      persEnc: e.persEnc || "utf8",
      entropy: e.entropy || Tf(this.hash.hmacStrength),
      entropyEnc: e.entropy && e.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), r2 = this.n.byteLength(), a7 = this.n.sub(new T12(2)); ; ) {
      var c13 = new T12(f8.generate(r2));
      if (!(c13.cmp(a7) > 0))
        return c13.iaddn(1), this.keyFromPrivate(c13);
    }
  };
  E15.prototype._truncateToN = function(e, f8) {
    var r2 = e.byteLength() * 8 - this.n.bitLength();
    return r2 > 0 && (e = e.ushrn(r2)), !f8 && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  E15.prototype.sign = function(e, f8, r2, a7) {
    typeof r2 == "object" && (a7 = r2, r2 = null), a7 || (a7 = {}), f8 = this.keyFromPrivate(f8, r2), e = this._truncateToN(new T12(e, 16));
    for (var c13 = this.n.byteLength(), b15 = f8.getPrivate().toArray("be", c13), t2 = e.toArray("be", c13), i = new Ze2({
      hash: this.hash,
      entropy: b15,
      nonce: t2,
      pers: a7.pers,
      persEnc: a7.persEnc || "utf8"
    }), s10 = this.n.sub(new T12(1)), n3 = 0; ; n3++) {
      var u12 = a7.k ? a7.k(n3) : new T12(i.generate(this.n.byteLength()));
      if (u12 = this._truncateToN(u12, true), !(u12.cmpn(1) <= 0 || u12.cmp(s10) >= 0)) {
        var o6 = this.g.mul(u12);
        if (!o6.isInfinity()) {
          var v19 = o6.getX(), h16 = v19.umod(this.n);
          if (h16.cmpn(0) !== 0) {
            var l22 = u12.invm(this.n).mul(h16.mul(f8.getPrivate()).iadd(e));
            if (l22 = l22.umod(this.n), l22.cmpn(0) !== 0) {
              var S14 = (o6.getY().isOdd() ? 1 : 0) | (v19.cmp(h16) !== 0 ? 2 : 0);
              return a7.canonical && l22.cmp(this.nh) > 0 && (l22 = this.n.sub(l22), S14 ^= 1), new se3({
                r: h16,
                s: l22,
                recoveryParam: S14
              });
            }
          }
        }
      }
    }
  };
  E15.prototype.verify = function(e, f8, r2, a7) {
    e = this._truncateToN(new T12(e, 16)), r2 = this.keyFromPublic(r2, a7), f8 = new se3(f8, "hex");
    var c13 = f8.r, b15 = f8.s;
    if (c13.cmpn(1) < 0 || c13.cmp(this.n) >= 0 || b15.cmpn(1) < 0 || b15.cmp(this.n) >= 0)
      return false;
    var t2 = b15.invm(this.n), i = t2.mul(e).umod(this.n), s10 = t2.mul(c13).umod(this.n), n3;
    return this.curve._maxwellTrick ? (n3 = this.g.jmulAdd(i, r2.getPublic(), s10), n3.isInfinity() ? false : n3.eqXToP(c13)) : (n3 = this.g.mulAdd(i, r2.getPublic(), s10), n3.isInfinity() ? false : n3.getX().umod(this.n).cmp(c13) === 0);
  };
  E15.prototype.recoverPubKey = function(d14, e, f8, r2) {
    Qe2((3 & f8) === f8, "The recovery param is more than two bits"), e = new se3(e, r2);
    var a7 = this.n, c13 = new T12(d14), b15 = e.r, t2 = e.s, i = f8 & 1, s10 = f8 >> 1;
    if (b15.cmp(this.curve.p.umod(this.curve.n)) >= 0 && s10)
      throw new Error("Unable to find sencond key candinate");
    s10 ? b15 = this.curve.pointFromX(b15.add(this.curve.n), i) : b15 = this.curve.pointFromX(b15, i);
    var n3 = e.r.invm(a7), u12 = a7.sub(c13).mul(n3).umod(a7), o6 = t2.mul(n3).umod(a7);
    return this.g.mulAdd(u12, b15, o6);
  };
  E15.prototype.getKeyRecoveryParam = function(d14, e, f8, r2) {
    if (e = new se3(e, r2), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var a7 = 0; a7 < 4; a7++) {
      var c13;
      try {
        c13 = this.recoverPubKey(d14, e, a7);
      } catch {
        continue;
      }
      if (c13.eq(f8))
        return a7;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var tf = M((ud, af) => {
  "use strict";
  var ee2 = z1(), rf = ee2.assert, df = ee2.parseBytes, U7 = ee2.cachedProperty;
  function I13(d14, e) {
    this.eddsa = d14, this._secret = df(e.secret), d14.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = df(e.pub);
  }
  I13.fromPublic = function(e, f8) {
    return f8 instanceof I13 ? f8 : new I13(e, {
      pub: f8
    });
  };
  I13.fromSecret = function(e, f8) {
    return f8 instanceof I13 ? f8 : new I13(e, {
      secret: f8
    });
  };
  I13.prototype.secret = function() {
    return this._secret;
  };
  U7(I13, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  U7(I13, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  U7(I13, "privBytes", function() {
    var e = this.eddsa, f8 = this.hash(), r2 = e.encodingLength - 1, a7 = f8.slice(0, e.encodingLength);
    return a7[0] &= 248, a7[r2] &= 127, a7[r2] |= 64, a7;
  });
  U7(I13, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  U7(I13, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  U7(I13, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  I13.prototype.sign = function(e) {
    return rf(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  I13.prototype.verify = function(e, f8) {
    return this.eddsa.verify(e, f8, this);
  };
  I13.prototype.getSecret = function(e) {
    return rf(this._secret, "KeyPair is public only"), ee2.encode(this.secret(), e);
  };
  I13.prototype.getPublic = function(e) {
    return ee2.encode(this.pubBytes(), e);
  };
  af.exports = I13;
});
var bf = M((od, cf) => {
  "use strict";
  var Yf = ki, ue4 = z1(), Kf = ue4.assert, oe3 = ue4.cachedProperty, Wf = ue4.parseBytes;
  function Y7(d14, e) {
    this.eddsa = d14, typeof e != "object" && (e = Wf(e)), Array.isArray(e) && (e = {
      R: e.slice(0, d14.encodingLength),
      S: e.slice(d14.encodingLength)
    }), Kf(e.R && e.S, "Signature without R or S"), d14.isPoint(e.R) && (this._R = e.R), e.S instanceof Yf && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  oe3(Y7, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  oe3(Y7, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  oe3(Y7, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  oe3(Y7, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  Y7.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Y7.prototype.toHex = function() {
    return ue4.encode(this.toBytes(), "hex").toUpperCase();
  };
  cf.exports = Y7;
});
var hf = M((hd, of) => {
  "use strict";
  var kf = Qe, Hf = be(), $17 = z1(), Uf = $17.assert, sf = $17.parseBytes, uf = tf(), nf = bf();
  function _11(d14) {
    if (Uf(d14 === "ed25519", "only tested with ed25519 so far"), !(this instanceof _11))
      return new _11(d14);
    d14 = Hf[d14].curve, this.curve = d14, this.g = d14.g, this.g.precompute(d14.n.bitLength() + 1), this.pointClass = d14.point().constructor, this.encodingLength = Math.ceil(d14.n.bitLength() / 8), this.hash = kf.sha512;
  }
  of.exports = _11;
  _11.prototype.sign = function(e, f8) {
    e = sf(e);
    var r2 = this.keyFromSecret(f8), a7 = this.hashInt(r2.messagePrefix(), e), c13 = this.g.mul(a7), b15 = this.encodePoint(c13), t2 = this.hashInt(b15, r2.pubBytes(), e).mul(r2.priv()), i = a7.add(t2).umod(this.curve.n);
    return this.makeSignature({
      R: c13,
      S: i,
      Rencoded: b15
    });
  };
  _11.prototype.verify = function(e, f8, r2) {
    e = sf(e), f8 = this.makeSignature(f8);
    var a7 = this.keyFromPublic(r2), c13 = this.hashInt(f8.Rencoded(), a7.pubBytes(), e), b15 = this.g.mul(f8.S()), t2 = f8.R().add(a7.pub().mul(c13));
    return t2.eq(b15);
  };
  _11.prototype.hashInt = function() {
    for (var e = this.hash(), f8 = 0; f8 < arguments.length; f8++)
      e.update(arguments[f8]);
    return $17.intFromLE(e.digest()).umod(this.curve.n);
  };
  _11.prototype.keyFromPublic = function(e) {
    return uf.fromPublic(this, e);
  };
  _11.prototype.keyFromSecret = function(e) {
    return uf.fromSecret(this, e);
  };
  _11.prototype.makeSignature = function(e) {
    return e instanceof nf ? e : new nf(this, e);
  };
  _11.prototype.encodePoint = function(e) {
    var f8 = e.getY().toArray("le", this.encodingLength);
    return f8[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, f8;
  };
  _11.prototype.decodePoint = function(e) {
    e = $17.parseBytes(e);
    var f8 = e.length - 1, r2 = e.slice(0, f8).concat(e[f8] & -129), a7 = (e[f8] & 128) !== 0, c13 = $17.intFromLE(r2);
    return this.curve.pointFromY(c13, a7);
  };
  _11.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  _11.prototype.decodeInt = function(e) {
    return $17.intFromLE(e);
  };
  _11.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var qe = M((vf) => {
  "use strict";
  var K14 = vf;
  K14.version = Re().version;
  K14.utils = z1();
  K14.rand = C;
  K14.curve = pe();
  K14.curves = be();
  K14.ec = ff();
  K14.eddsa = hf();
});
var lf = ze(qe());
var $f = ze(qe());
var { default: Gf, ...Vf } = $f;
var ld = lf.default ?? Gf ?? Vf;
var v2 = Object.create;
var y3 = Object.defineProperty;
var g4 = Object.getOwnPropertyDescriptor;
var m3 = Object.getOwnPropertyNames;
var l4 = Object.getPrototypeOf;
var P = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (t2, r2) => (typeof require != "undefined" ? require : t2)[r2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var B1 = (e, t2) => () => (t2 || e((t2 = {
  exports: {}
}).exports, t2), t2.exports);
var b2 = (e, t2, r2, u12) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let s10 of m3(t2))
      !P.call(e, s10) && s10 !== r2 && y3(e, s10, {
        get: () => t2[s10],
        enumerable: !(u12 = g4(t2, s10)) || u12.enumerable
      });
  return e;
};
var o1 = (e, t2, r2) => (r2 = e != null ? v2(l4(e)) : {}, b2(t2 || !e || !e.__esModule ? y3(r2, "default", {
  value: e,
  enumerable: true
}) : r2, e));
var p5 = B1(($17, c13) => {
  var k15 = ld, d14 = ki;
  c13.exports = function(t2) {
    return new f8(t2);
  };
  var i = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  i.p224 = i.secp224r1;
  i.p256 = i.secp256r1 = i.prime256v1;
  i.p192 = i.secp192r1 = i.prime192v1;
  i.p384 = i.secp384r1;
  i.p521 = i.secp521r1;
  function f8(e) {
    this.curveType = i[e], this.curveType || (this.curveType = {
      name: e
    }), this.curve = new k15.ec(this.curveType.name), this.keys = void 0;
  }
  f8.prototype.generateKeys = function(e, t2) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(e, t2);
  };
  f8.prototype.computeSecret = function(e, t2, r2) {
    t2 = t2 || "utf8", Buffer2.isBuffer(e) || (e = new Buffer2(e, t2));
    var u12 = this.curve.keyFromPublic(e).getPublic(), s10 = u12.mul(this.keys.getPrivate()).getX();
    return n3(s10, r2, this.curveType.byteLength);
  };
  f8.prototype.getPublicKey = function(e, t2) {
    var r2 = this.keys.getPublic(t2 === "compressed", true);
    return t2 === "hybrid" && (r2[r2.length - 1] % 2 ? r2[0] = 7 : r2[0] = 6), n3(r2, e);
  };
  f8.prototype.getPrivateKey = function(e) {
    return n3(this.keys.getPrivate(), e);
  };
  f8.prototype.setPublicKey = function(e, t2) {
    return t2 = t2 || "utf8", Buffer2.isBuffer(e) || (e = new Buffer2(e, t2)), this.keys._importPublic(e), this;
  };
  f8.prototype.setPrivateKey = function(e, t2) {
    t2 = t2 || "utf8", Buffer2.isBuffer(e) || (e = new Buffer2(e, t2));
    var r2 = new d14(e);
    return r2 = r2.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r2), this;
  };
  function n3(e, t2, r2) {
    Array.isArray(e) || (e = e.toArray());
    var u12 = new Buffer2(e);
    if (r2 && u12.length < r2) {
      var s10 = new Buffer2(r2 - u12.length);
      s10.fill(0), u12 = Buffer2.concat([
        s10,
        u12
      ]);
    }
    return t2 ? u12.toString(t2) : u12;
  }
});
var h3 = o1(p5());
var w3 = o1(p5());
var { default: K3, ...L } = w3;
var A3 = h3.default ?? K3 ?? L;
var y4 = Object.create;
var p6 = Object.defineProperty;
var B2 = Object.getOwnPropertyDescriptor;
var S1 = Object.getOwnPropertyNames;
var d4 = Object.getPrototypeOf;
var g5 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var E2 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var T = (e, r2, t2, f8) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let u12 of S1(r2))
      !g5.call(e, u12) && u12 !== t2 && p6(e, u12, {
        get: () => r2[u12],
        enumerable: !(f8 = B2(r2, u12)) || f8.enumerable
      });
  return e;
};
var b3 = (e, r2, t2) => (t2 = e != null ? y4(d4(e)) : {}, T(r2 || !e || !e.__esModule ? p6(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var m4 = E2((l22, s10) => {
  var a7 = export_default, o6 = a7.Buffer;
  function c13(e, r2) {
    for (var t2 in e)
      r2[t2] = e[t2];
  }
  o6.from && o6.alloc && o6.allocUnsafe && o6.allocUnsafeSlow ? s10.exports = a7 : (c13(a7, l22), l22.Buffer = n3);
  function n3(e, r2, t2) {
    return o6(e, r2, t2);
  }
  n3.prototype = Object.create(o6.prototype);
  c13(o6, n3);
  n3.from = function(e, r2, t2) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return o6(e, r2, t2);
  };
  n3.alloc = function(e, r2, t2) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var f8 = o6(e);
    return r2 !== void 0 ? typeof t2 == "string" ? f8.fill(r2, t2) : f8.fill(r2) : f8.fill(0), f8;
  };
  n3.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return o6(e);
  };
  n3.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return a7.SlowBuffer(e);
  };
});
var i4 = b3(m4());
var w4 = b3(m4());
var { Blob: U, resolveObjectURL: $3, Buffer: L1, SlowBuffer: M1, transcode: j1, kMaxLength: O, kStringMaxLength: P1, btoa: _2, atob: k1, constants: q3, INSPECT_MAX_BYTES: C1 } = w4;
var { default: v3, ...x5 } = w4;
var I2 = i4.default ?? v3 ?? x5;
function addSignalListener(...args) {
  if (typeof Deno.addSignalListener == "function") {
    return Deno.addSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function removeSignalListener(...args) {
  if (typeof Deno.removeSignalListener == "function") {
    return Deno.removeSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function setRaw(...args) {
  if (typeof Deno.setRaw == "function") {
    return Deno.setRaw(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
async function connect(options) {
  return await Deno.connect(options);
}
function listen(options) {
  return Deno.listen(options);
}
function listenDatagram(options) {
  return Deno.listenDatagram(options);
}
function ListenerRef(listener, ...args) {
  if (typeof listener.ref == "function") {
    return listener.ref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function ListenerUnref(listener, ...args) {
  if (typeof listener.unref == "function") {
    return listener.unref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
var CHAR_FORWARD_SLASH = 47;
function assertPath(path6) {
  if (typeof path6 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path6)}`);
  }
}
function isPosixPathSeparator(code2) {
  return code2 === 47;
}
function isPathSeparator(code2) {
  return isPosixPathSeparator(code2) || code2 === 92;
}
function isWindowsDeviceRoot(code2) {
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
function normalizeString(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep9, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base2;
  if (dir === pathObject.root)
    return dir + base2;
  return dir + sep9 + base2;
}
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string) {
  return string.replaceAll(/[\s]/g, (c13) => {
    return WHITESPACE_ENCODINGS[c13] ?? c13;
  });
}
var sep = "\\";
var delimiter = ";";
function resolve(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno12 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno12.cwd();
    } else {
      if (typeof Deno12?.env?.get !== "function" || typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno12.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute9 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        isAbsolute9 = true;
        if (isPathSeparator(path6.charCodeAt(1))) {
          let j13 = 2;
          let last = j13;
          for (; j13 < len; ++j13) {
            if (isPathSeparator(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            const firstPart = path6.slice(last, j13);
            last = j13;
            for (; j13 < len; ++j13) {
              if (!isPathSeparator(path6.charCodeAt(j13)))
                break;
            }
            if (j13 < len && j13 !== last) {
              last = j13;
              for (; j13 < len; ++j13) {
                if (isPathSeparator(path6.charCodeAt(j13)))
                  break;
              }
              if (j13 === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j13;
              } else if (j13 !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j13)}`;
                rootEnd = j13;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path6.charCodeAt(1) === 58) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path6.charCodeAt(2))) {
              isAbsolute9 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      rootEnd = 1;
      isAbsolute9 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute9;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute9 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      isAbsolute9 = true;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          const firstPart = path6.slice(last, j13);
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j13 !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j13)}`;
              rootEnd = j13;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === 58) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            isAbsolute9 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(path6.slice(rootEnd), !isAbsolute9, "\\", isPathSeparator);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute9)
    tail = ".";
  if (tail.length > 0 && isPathSeparator(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute9) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute9) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator(code2)) {
    return true;
  } else if (isWindowsDeviceRoot(code2)) {
    if (len > 2 && path6.charCodeAt(1) === 58) {
      if (isPathSeparator(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join1(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert1(firstPart != null);
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize(joined);
}
function relative(from6, to) {
  assertPath(from6);
  assertPath(to);
  if (from6 === to)
    return "";
  const fromOrig = resolve(from6);
  const toOrig = resolve(to);
  if (fromOrig === toOrig)
    return "";
  from6 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from6 === to)
    return "";
  let fromStart = 0;
  let fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== 92)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from6.charCodeAt(fromEnd - 1) !== 92)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== 92)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== 92)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 92) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from6.charCodeAt(fromStart + i) === 92) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 92)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from6.charCodeAt(i) === 92) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === 92)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === 92) {
      if (resolvedPath.charCodeAt(1) === 92) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== 63 && code2 !== 46) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              return path6;
            }
            if (j13 !== last) {
              rootEnd = offset = j13 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === 58) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path6.charCodeAt(1) === 58)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname(path6) {
  assertPath(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === 58 && isWindowsDeviceRoot(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format1(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format("\\", pathObject);
}
function parse1(path6) {
  assertPath(path6);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = 1;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              rootEnd = j13;
            } else if (j13 !== last) {
              rootEnd = j13 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === 58) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl(path6) {
  if (!isAbsolute(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}
var mod15 = {
  sep,
  delimiter,
  resolve,
  normalize,
  isAbsolute,
  join: join1,
  relative,
  toNamespacedPath,
  dirname,
  basename,
  extname,
  format: format1,
  parse: parse1,
  fromFileUrl,
  toFileUrl
};
var sep1 = "/";
var delimiter1 = ":";
function resolve1(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno12 } = globalThis;
      if (typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno12.cwd();
    }
    assertPath(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize1(path6) {
  assertPath(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute9 = path6.charCodeAt(0) === 47;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === 47;
  path6 = normalizeString(path6, !isAbsolute9, "/", isPosixPathSeparator);
  if (path6.length === 0 && !isAbsolute9)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute9)
    return `/${path6}`;
  return path6;
}
function isAbsolute1(path6) {
  assertPath(path6);
  return path6.length > 0 && path6.charCodeAt(0) === 47;
}
function join22(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize1(joined);
}
function relative1(from6, to) {
  assertPath(from6);
  assertPath(to);
  if (from6 === to)
    return "";
  from6 = resolve1(from6);
  to = resolve1(to);
  if (from6 === to)
    return "";
  let fromStart = 1;
  const fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== 47)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== 47)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 47) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from6.charCodeAt(fromStart + i) === 47) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 47)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from6.charCodeAt(i) === 47) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === 47)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath1(path6) {
  return path6;
}
function dirname1(path6) {
  assertPath(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === 47;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === 47) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename1(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname1(path6) {
  assertPath(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format2(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format("/", pathObject);
}
function parse2(path6) {
  assertPath(path6);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  if (path6.length === 0)
    return ret;
  const isAbsolute9 = path6.charCodeAt(0) === 47;
  let start;
  if (isAbsolute9) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute9) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute9) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute9)
    ret.dir = "/";
  return ret;
}
function fromFileUrl1(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path6) {
  if (!isAbsolute1(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}
var mod16 = {
  sep: sep1,
  delimiter: delimiter1,
  resolve: resolve1,
  normalize: normalize1,
  isAbsolute: isAbsolute1,
  join: join22,
  relative: relative1,
  toNamespacedPath: toNamespacedPath1,
  dirname: dirname1,
  basename: basename1,
  extname: extname1,
  format: format2,
  parse: parse2,
  fromFileUrl: fromFileUrl1,
  toFileUrl: toFileUrl1
};
var path2 = isWindows ? mod15 : mod16;
var { join: join3, normalize: normalize2 } = path2;
var path1 = isWindows ? mod15 : mod16;
var { basename: basename2, delimiter: delimiter2, dirname: dirname2, extname: extname2, format: format3, fromFileUrl: fromFileUrl2, isAbsolute: isAbsolute2, join: join4, normalize: normalize3, parse: parse3, relative: relative2, resolve: resolve2, sep: sep2, toFileUrl: toFileUrl2, toNamespacedPath: toNamespacedPath2 } = path1;
function createWritableStdioStream(writer, name) {
  const stream = new Writable({
    write(buf, enc, cb) {
      if (!writer) {
        this.destroy(new Error(`Deno.${name} is not available in this environment`));
        return;
      }
      writer.writeSync(buf instanceof Uint8Array ? buf : Buffer2.from(buf, enc));
      cb();
    },
    destroy(err, cb) {
      cb(err);
      this._undestroy();
      if (!this._writableState.emitClose) {
        nextTick(() => this.emit("close"));
      }
    }
  });
  stream.fd = writer?.rid ?? -1;
  stream.destroySoon = stream.destroy;
  stream._isStdio = true;
  stream.once("close", () => writer?.close());
  Object.defineProperties(stream, {
    columns: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : void 0
    },
    rows: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : void 0
    },
    isTTY: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid)
    },
    getWindowSize: {
      enumerable: true,
      configurable: true,
      value: () => Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : void 0
    }
  });
  return stream;
}
var stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
var stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
var stdin = stdio.stdin = new Readable({
  highWaterMark: 0,
  emitClose: false,
  read(size) {
    const p7 = Buffer2.alloc(size || 16 * 1024);
    if (!Deno.stdin) {
      this.destroy(new Error("Deno.stdin is not available in this environment"));
      return;
    }
    Deno.stdin.read(p7).then((length) => {
      this.push(length === null ? null : p7.slice(0, length));
    }, (error2) => {
      this.destroy(error2);
    });
  }
});
stdin.on("close", () => Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
  enumerable: true,
  configurable: true,
  get() {
    return Deno.isatty?.(Deno.stdin.rid);
  }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable) => {
  setRaw?.(Deno.stdin?.rid, enable);
  stdin._isRawMode = enable;
  return stdin;
};
Object.defineProperty(stdin, "isRaw", {
  enumerable: true,
  configurable: true,
  get() {
    return stdin._isRawMode;
  }
});
function registerDestroyHook(_target, _asyncId, _prop) {
}
var constants1;
(function(constants7) {
  constants7[constants7["kInit"] = 0] = "kInit";
  constants7[constants7["kBefore"] = 1] = "kBefore";
  constants7[constants7["kAfter"] = 2] = "kAfter";
  constants7[constants7["kDestroy"] = 3] = "kDestroy";
  constants7[constants7["kPromiseResolve"] = 4] = "kPromiseResolve";
  constants7[constants7["kTotals"] = 5] = "kTotals";
  constants7[constants7["kCheck"] = 6] = "kCheck";
  constants7[constants7["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
  constants7[constants7["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
  constants7[constants7["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
  constants7[constants7["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
  constants7[constants7["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
  constants7[constants7["kStackLength"] = 12] = "kStackLength";
})(constants1 || (constants1 = {}));
var asyncHookFields = new Uint32Array(Object.keys(constants1).length);
function newAsyncId() {
  return ++asyncIdFields[constants1.kAsyncIdCounter];
}
var UidFields;
(function(UidFields2) {
  UidFields2[UidFields2["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
  UidFields2[UidFields2["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
  UidFields2[UidFields2["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
  UidFields2[UidFields2["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
  UidFields2[UidFields2["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
var asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType2) {
  providerType2[providerType2["NONE"] = 0] = "NONE";
  providerType2[providerType2["DIRHANDLE"] = 1] = "DIRHANDLE";
  providerType2[providerType2["DNSCHANNEL"] = 2] = "DNSCHANNEL";
  providerType2[providerType2["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
  providerType2[providerType2["FILEHANDLE"] = 4] = "FILEHANDLE";
  providerType2[providerType2["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
  providerType2[providerType2["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
  providerType2[providerType2["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
  providerType2[providerType2["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
  providerType2[providerType2["FSREQPROMISE"] = 9] = "FSREQPROMISE";
  providerType2[providerType2["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
  providerType2[providerType2["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
  providerType2[providerType2["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
  providerType2[providerType2["HTTP2SESSION"] = 13] = "HTTP2SESSION";
  providerType2[providerType2["HTTP2STREAM"] = 14] = "HTTP2STREAM";
  providerType2[providerType2["HTTP2PING"] = 15] = "HTTP2PING";
  providerType2[providerType2["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
  providerType2[providerType2["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
  providerType2[providerType2["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
  providerType2[providerType2["JSSTREAM"] = 19] = "JSSTREAM";
  providerType2[providerType2["JSUDPWRAP"] = 20] = "JSUDPWRAP";
  providerType2[providerType2["MESSAGEPORT"] = 21] = "MESSAGEPORT";
  providerType2[providerType2["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
  providerType2[providerType2["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
  providerType2[providerType2["PIPEWRAP"] = 24] = "PIPEWRAP";
  providerType2[providerType2["PROCESSWRAP"] = 25] = "PROCESSWRAP";
  providerType2[providerType2["PROMISE"] = 26] = "PROMISE";
  providerType2[providerType2["QUERYWRAP"] = 27] = "QUERYWRAP";
  providerType2[providerType2["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
  providerType2[providerType2["SIGNALWRAP"] = 29] = "SIGNALWRAP";
  providerType2[providerType2["STATWATCHER"] = 30] = "STATWATCHER";
  providerType2[providerType2["STREAMPIPE"] = 31] = "STREAMPIPE";
  providerType2[providerType2["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
  providerType2[providerType2["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
  providerType2[providerType2["TCPWRAP"] = 34] = "TCPWRAP";
  providerType2[providerType2["TTYWRAP"] = 35] = "TTYWRAP";
  providerType2[providerType2["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
  providerType2[providerType2["UDPWRAP"] = 37] = "UDPWRAP";
  providerType2[providerType2["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
  providerType2[providerType2["WORKER"] = 39] = "WORKER";
  providerType2[providerType2["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
  providerType2[providerType2["WRITEWRAP"] = 41] = "WRITEWRAP";
  providerType2[providerType2["ZLIB"] = 42] = "ZLIB";
})(providerType || (providerType = {}));
var kInvalidAsyncId = -1;
var AsyncWrap = class {
  provider = providerType.NONE;
  asyncId = kInvalidAsyncId;
  constructor(provider) {
    this.provider = provider;
    this.getAsyncId();
  }
  getAsyncId() {
    this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
    return this.asyncId;
  }
  getProviderType() {
    return this.provider;
  }
};
var mod17 = {
  async_hook_fields: asyncHookFields,
  asyncIdFields,
  registerDestroyHook,
  constants: constants1,
  newAsyncId,
  UidFields,
  providerType,
  AsyncWrap
};
var mod18 = {};
var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
var IPv4Reg = new RegExp(`^${v4Str}$`);
var v6Seg = "(?:[0-9a-fA-F]{1,4})";
var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
function isIPv4(ip) {
  return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
  return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
  if (isIPv4(ip)) {
    return 4;
  }
  if (isIPv6(ip)) {
    return 6;
  }
  return 0;
}
Symbol("normalizedArgs");
function ares_strerror(code2) {
  const errorText = [
    "Successful completion",
    "DNS server returned answer with no data",
    "DNS server claims query was misformatted",
    "DNS server returned general failure",
    "Domain name not found",
    "DNS server does not implement requested operation",
    "DNS server refused query",
    "Misformatted DNS query",
    "Misformatted domain name",
    "Unsupported address family",
    "Misformatted DNS reply",
    "Could not contact DNS servers",
    "Timeout while contacting DNS servers",
    "End of file",
    "Error reading file",
    "Out of memory",
    "Channel is being destroyed",
    "Misformatted string",
    "Illegal flags specified",
    "Given hostname is not numeric",
    "Illegal hints flags specified",
    "c-ares library initialization not yet performed",
    "Error loading iphlpapi.dll",
    "Could not find GetNetworkParams function",
    "DNS query cancelled"
  ];
  if (code2 >= 0 && code2 < errorText.length) {
    return errorText[code2];
  } else {
    return "unknown";
  }
}
var GetAddrInfoReqWrap = class extends AsyncWrap {
  family;
  hostname;
  callback;
  resolve;
  reject;
  oncomplete;
  constructor() {
    super(providerType.GETADDRINFOREQWRAP);
  }
};
function getaddrinfo(req, hostname, family, _hints, verbatim) {
  let addresses = [];
  const recordTypes = [];
  if (family === 0 || family === 4) {
    recordTypes.push("A");
  }
  if (family === 0 || family === 6) {
    recordTypes.push("AAAA");
  }
  (async () => {
    await Promise.allSettled(recordTypes.map((recordType) => Deno.resolveDns(hostname, recordType).then((records) => {
      records.forEach((record) => addresses.push(record));
    })));
    const error2 = addresses.length ? 0 : codeMap.get("EAI_NODATA");
    if (!verbatim) {
      addresses.sort((a7, b15) => {
        if (isIPv4(a7)) {
          return -1;
        } else if (isIPv4(b15)) {
          return 1;
        }
        return 0;
      });
    }
    if (isWindows && hostname === "localhost") {
      addresses = addresses.filter((address) => isIPv4(address));
    }
    req.oncomplete(error2, addresses);
  })();
  return 0;
}
var QueryReqWrap = class extends AsyncWrap {
  bindingName;
  hostname;
  ttl;
  callback;
  resolve;
  reject;
  oncomplete;
  constructor() {
    super(providerType.QUERYWRAP);
  }
};
function fqdnToHostname(fqdn) {
  return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
  const formatted = address.replace(/\b(?:0+:){2,}/, ":");
  const finalAddress = formatted.split(":").map((octet) => {
    if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
      return Number(octet.replaceAll(".", "")).toString(16);
    }
    return octet.replace(/\b0+/g, "");
  }).join(":");
  return finalAddress;
}
var ChannelWrap = class extends AsyncWrap {
  #servers = [];
  #timeout;
  #tries;
  constructor(timeout, tries) {
    super(providerType.DNSCHANNEL);
    this.#timeout = timeout;
    this.#tries = tries;
  }
  async #query(query, recordType) {
    let code1;
    let ret;
    if (this.#servers.length) {
      for (const [ipAddr, port] of this.#servers) {
        const resolveOptions = {
          nameServer: {
            ipAddr,
            port
          }
        };
        ({ code: code1, ret } = await this.#resolve(query, recordType, resolveOptions));
        if (code1 === 0 || code1 === codeMap.get("EAI_NODATA")) {
          break;
        }
      }
    } else {
      ({ code: code1, ret } = await this.#resolve(query, recordType));
    }
    return {
      code: code1,
      ret
    };
  }
  async #resolve(query1, recordType1, resolveOptions1) {
    let ret1 = [];
    let code11 = 0;
    try {
      ret1 = await Deno.resolveDns(query1, recordType1, resolveOptions1);
    } catch (e1) {
      if (e1 instanceof Deno.errors.NotFound) {
        code11 = codeMap.get("EAI_NODATA");
      } else {
        code11 = codeMap.get("UNKNOWN");
      }
    }
    return {
      code: code11,
      ret: ret1
    };
  }
  queryAny(req, name) {
    (async () => {
      const records = [];
      await Promise.allSettled([
        this.#query(name, "A").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "A",
            address: record
          }));
        }),
        this.#query(name, "AAAA").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "AAAA",
            address: compressIPv6(record)
          }));
        }),
        this.#query(name, "CAA").then(({ ret }) => {
          ret.forEach(({ critical, tag: tag2, value }) => records.push({
            type: "CAA",
            [tag2]: value,
            critical: +critical && 128
          }));
        }),
        this.#query(name, "CNAME").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "CNAME",
            value: record
          }));
        }),
        this.#query(name, "MX").then(({ ret }) => {
          ret.forEach(({ preference, exchange }) => records.push({
            type: "MX",
            priority: preference,
            exchange: fqdnToHostname(exchange)
          }));
        }),
        this.#query(name, "NAPTR").then(({ ret }) => {
          ret.forEach(({ order, preference, flags, services, regexp, replacement }) => records.push({
            type: "NAPTR",
            order,
            preference,
            flags,
            service: services,
            regexp,
            replacement
          }));
        }),
        this.#query(name, "NS").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "NS",
            value: fqdnToHostname(record)
          }));
        }),
        this.#query(name, "PTR").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "PTR",
            value: fqdnToHostname(record)
          }));
        }),
        this.#query(name, "SOA").then(({ ret }) => {
          ret.forEach(({ mname, rname, serial, refresh, retry, expire, minimum }) => records.push({
            type: "SOA",
            nsname: fqdnToHostname(mname),
            hostmaster: fqdnToHostname(rname),
            serial,
            refresh,
            retry,
            expire,
            minttl: minimum
          }));
        }),
        this.#query(name, "SRV").then(({ ret }) => {
          ret.forEach(({ priority, weight, port, target }) => records.push({
            type: "SRV",
            priority,
            weight,
            port,
            name: target
          }));
        }),
        this.#query(name, "TXT").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "TXT",
            entries: record
          }));
        })
      ]);
      const err = records.length ? 0 : codeMap.get("EAI_NODATA");
      req.oncomplete(err, records);
    })();
    return 0;
  }
  queryA(req, name) {
    this.#query(name, "A").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryAaaa(req, name) {
    this.#query(name, "AAAA").then(({ code: code2, ret }) => {
      const records = ret.map((record) => compressIPv6(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCaa(req, name) {
    this.#query(name, "CAA").then(({ code: code2, ret }) => {
      const records = ret.map(({ critical, tag: tag2, value }) => ({
        [tag2]: value,
        critical: +critical && 128
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCname(req, name) {
    this.#query(name, "CNAME").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryMx(req, name) {
    this.#query(name, "MX").then(({ code: code2, ret }) => {
      const records = ret.map(({ preference, exchange }) => ({
        priority: preference,
        exchange: fqdnToHostname(exchange)
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNaptr(req, name) {
    this.#query(name, "NAPTR").then(({ code: code2, ret }) => {
      const records = ret.map(({ order, preference, flags, services, regexp, replacement }) => ({
        flags,
        service: services,
        regexp,
        replacement,
        order,
        preference
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNs(req, name) {
    this.#query(name, "NS").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryPtr(req, name) {
    this.#query(name, "PTR").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  querySoa(req, name) {
    this.#query(name, "SOA").then(({ code: code2, ret }) => {
      let record = {};
      if (ret.length) {
        const { mname, rname, serial, refresh, retry, expire, minimum } = ret[0];
        record = {
          nsname: fqdnToHostname(mname),
          hostmaster: fqdnToHostname(rname),
          serial,
          refresh,
          retry,
          expire,
          minttl: minimum
        };
      }
      req.oncomplete(code2, record);
    });
    return 0;
  }
  querySrv(req, name) {
    this.#query(name, "SRV").then(({ code: code2, ret }) => {
      const records = ret.map(({ priority, weight, port, target }) => ({
        priority,
        weight,
        port,
        name: target
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryTxt(req, name) {
    this.#query(name, "TXT").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  getHostByAddr(_req, _name) {
    notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
  }
  getServers() {
    return this.#servers;
  }
  setServers(servers) {
    if (typeof servers === "string") {
      const tuples = [];
      for (let i = 0; i < servers.length; i += 2) {
        tuples.push([
          servers[i],
          parseInt(servers[i + 1])
        ]);
      }
      this.#servers = tuples;
    } else {
      this.#servers = servers.map(([_ipVersion, ip, port]) => [
        ip,
        port
      ]);
    }
    return 0;
  }
  setLocalAddress(_addr0, _addr1) {
    notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
  }
  cancel() {
    notImplemented("cares.ChannelWrap.prototype.cancel");
  }
};
var DNS_ESETSRVPENDING = -1e3;
var EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code2) {
  return code2 === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code2);
}
var mod19 = {
  GetAddrInfoReqWrap,
  getaddrinfo,
  QueryReqWrap,
  ChannelWrap,
  strerror
};
var mod20 = {};
var mod21 = {};
var mod22 = {};
var mod23 = {};
var mod24 = {};
var mod25 = {};
var mod26 = {};
var mod27 = {};
var mod28 = {};
var mod29 = {};
var mod30 = {};
var mod31 = {};
var mod32 = {};
var mod33 = {};
var mod34 = {};
var mod35 = {};
var mod36 = {};
var HandleWrap = class extends AsyncWrap {
  constructor(provider) {
    super(provider);
  }
  close(cb = () => {
  }) {
    this._onClose();
    cb();
  }
  ref() {
    unreachable();
  }
  unref() {
    unreachable();
  }
  _onClose() {
  }
};
var CR = "\r".charCodeAt(0);
var LF = "\n".charCodeAt(0);
async function writeAll(w24, arr) {
  let nwritten = 0;
  while (nwritten < arr.length) {
    nwritten += await w24.write(arr.subarray(nwritten));
  }
}
var StreamBaseStateFields;
(function(StreamBaseStateFields2) {
  StreamBaseStateFields2[StreamBaseStateFields2["kReadBytesOrError"] = 0] = "kReadBytesOrError";
  StreamBaseStateFields2[StreamBaseStateFields2["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
  StreamBaseStateFields2[StreamBaseStateFields2["kBytesWritten"] = 2] = "kBytesWritten";
  StreamBaseStateFields2[StreamBaseStateFields2["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
  StreamBaseStateFields2[StreamBaseStateFields2["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
var kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
var kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
var kBytesWritten = StreamBaseStateFields.kBytesWritten;
var kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
var kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
var streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
var WriteWrap = class extends AsyncWrap {
  handle;
  oncomplete;
  async;
  bytes;
  buffer;
  callback;
  _chunks;
  constructor() {
    super(providerType.WRITEWRAP);
  }
};
var ShutdownWrap = class extends AsyncWrap {
  handle;
  oncomplete;
  callback;
  constructor() {
    super(providerType.SHUTDOWNWRAP);
  }
};
var kStreamBaseField = Symbol("kStreamBaseField");
var SUGGESTED_SIZE = 64 * 1024;
var LibuvStreamWrap = class extends HandleWrap {
  [kStreamBaseField];
  reading;
  #reading = false;
  destroyed = false;
  writeQueueSize = 0;
  bytesRead = 0;
  bytesWritten = 0;
  onread;
  constructor(provider, stream) {
    super(provider);
    this.#attachToObject(stream);
  }
  readStart() {
    if (!this.#reading) {
      this.#reading = true;
      this.#read();
    }
    return 0;
  }
  readStop() {
    this.#reading = false;
    return 0;
  }
  shutdown(req) {
    const status = this._onClose();
    try {
      req.oncomplete(status);
    } catch {
    }
    return 0;
  }
  useUserBuffer(_userBuf) {
    notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
  }
  writeBuffer(req, data) {
    this.#write(req, data);
    return 0;
  }
  writev(req, chunks, allBuffers) {
    const count = allBuffers ? chunks.length : chunks.length >> 1;
    const buffers = new Array(count);
    if (!allBuffers) {
      for (let i = 0; i < count; i++) {
        const chunk = chunks[i * 2];
        if (Buffer2.isBuffer(chunk)) {
          buffers[i] = chunk;
        }
        const encoding = chunks[i * 2 + 1];
        buffers[i] = Buffer2.from(chunk, encoding);
      }
    } else {
      for (let i12 = 0; i12 < count; i12++) {
        buffers[i12] = chunks[i12];
      }
    }
    return this.writeBuffer(req, Buffer2.concat(buffers));
  }
  writeAsciiString(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUtf8String(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUcs2String(_req, _data) {
    notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
  }
  writeLatin1String(req, data) {
    const buffer = Buffer2.from(data, "latin1");
    return this.writeBuffer(req, buffer);
  }
  _onClose() {
    let status = 0;
    this.#reading = false;
    try {
      this[kStreamBaseField]?.close();
    } catch {
      status = codeMap.get("ENOTCONN");
    }
    return status;
  }
  #attachToObject(stream) {
    this[kStreamBaseField] = stream;
  }
  async #read() {
    let buf = new Uint8Array(SUGGESTED_SIZE);
    let nread;
    try {
      nread = await this[kStreamBaseField].read(buf);
    } catch (e2) {
      if (e2 instanceof Deno.errors.Interrupted || e2 instanceof Deno.errors.BadResource) {
        nread = codeMap.get("EOF");
      } else if (e2 instanceof Deno.errors.ConnectionReset || e2 instanceof Deno.errors.ConnectionAborted) {
        nread = codeMap.get("ECONNRESET");
      } else {
        nread = codeMap.get("UNKNOWN");
      }
      buf = new Uint8Array(0);
    }
    nread ??= codeMap.get("EOF");
    streamBaseState[kReadBytesOrError] = nread;
    if (nread > 0) {
      this.bytesRead += nread;
    }
    buf = buf.slice(0, nread);
    streamBaseState[kArrayBufferOffset] = 0;
    try {
      this.onread(buf, nread);
    } catch {
    }
    if (nread >= 0 && this.#reading) {
      this.#read();
    }
  }
  async #write(req, data) {
    const { byteLength: byteLength1 } = data;
    try {
      await writeAll(this[kStreamBaseField], data);
    } catch (e11) {
      let status;
      if (e11 instanceof Deno.errors.BadResource || e11 instanceof Deno.errors.BrokenPipe) {
        status = codeMap.get("EBADF");
      } else {
        status = codeMap.get("UNKNOWN");
      }
      try {
        req.oncomplete(status);
      } catch {
      }
      return;
    }
    streamBaseState[kBytesWritten] = byteLength1;
    this.bytesWritten += byteLength1;
    try {
      req.oncomplete(0);
    } catch {
    }
    return;
  }
};
var mod37 = {
  kReadBytesOrError,
  kArrayBufferOffset,
  kBytesWritten,
  kLastWriteWasAsync,
  kNumStreamBaseStateFields,
  streamBaseState,
  WriteWrap,
  ShutdownWrap,
  kStreamBaseField,
  LibuvStreamWrap
};
var ConnectionWrap = class extends LibuvStreamWrap {
  onconnection = null;
  constructor(provider, object) {
    super(provider, object);
  }
  afterConnect(req, status) {
    const isSuccessStatus = !status;
    const readable = isSuccessStatus;
    const writable = isSuccessStatus;
    try {
      req.oncomplete(status, this, req, readable, writable);
    } catch {
    }
    return;
  }
};
function ceilPowOf2(n3) {
  const roundPowOf2 = 1 << 31 - Math.clz32(n3);
  return roundPowOf2 < n3 ? roundPowOf2 * 2 : roundPowOf2;
}
var INITIAL_ACCEPT_BACKOFF_DELAY = 5;
var MAX_ACCEPT_BACKOFF_DELAY = 1e3;
var socketType;
(function(socketType4) {
  socketType4[socketType4["SOCKET"] = 0] = "SOCKET";
  socketType4[socketType4["SERVER"] = 1] = "SERVER";
  socketType4[socketType4["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
var Pipe = class extends ConnectionWrap {
  reading = false;
  ipc;
  #pendingInstances = 4;
  #address;
  #backlog;
  #listener;
  #connections = 0;
  #closed = false;
  #acceptBackoffDelay;
  constructor(type, conn) {
    let provider;
    let ipc;
    switch (type) {
      case socketType.SOCKET: {
        provider = providerType.PIPEWRAP;
        ipc = false;
        break;
      }
      case socketType.SERVER: {
        provider = providerType.PIPESERVERWRAP;
        ipc = false;
        break;
      }
      case socketType.IPC: {
        provider = providerType.PIPEWRAP;
        ipc = true;
        break;
      }
      default: {
        unreachable();
      }
    }
    super(provider, conn);
    this.ipc = ipc;
    if (conn && provider === providerType.PIPEWRAP) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.path;
    }
  }
  open(_fd) {
    notImplemented("Pipe.prototype.open");
  }
  bind(name) {
    this.#address = name;
    return 0;
  }
  connect(req, address) {
    if (isWindows) {
      notImplemented("Pipe.prototype.connect - Windows");
    }
    const connectOptions = {
      path: address,
      transport: "unix"
    };
    connect(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req.address = localAddr.path;
      this[kStreamBaseField] = conn;
      try {
        this.afterConnect(req, 0);
      } catch {
      }
    }, (e) => {
      let code2;
      if (e instanceof Deno.errors.NotFound) {
        code2 = codeMap.get("ENOENT");
      } else if (e instanceof Deno.errors.PermissionDenied) {
        code2 = codeMap.get("EACCES");
      } else {
        code2 = codeMap.get("ECONNREFUSED");
      }
      try {
        this.afterConnect(req, code2);
      } catch {
      }
    });
    return 0;
  }
  listen(backlog) {
    if (isWindows) {
      notImplemented("Pipe.prototype.listen - Windows");
    }
    this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
    const listenOptions = {
      path: this.#address,
      transport: "unix"
    };
    let listener;
    try {
      listener = listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.path;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref(this.#listener);
    }
  }
  setPendingInstances(instances) {
    this.#pendingInstances = instances;
  }
  fchmod(mode) {
    if (mode != constants2.UV_READABLE && mode != constants2.UV_WRITABLE && mode != (constants2.UV_WRITABLE | constants2.UV_READABLE)) {
      return codeMap.get("EINVAL");
    }
    let desired_mode = 0;
    if (mode & constants2.UV_READABLE) {
      desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
    }
    if (mode & constants2.UV_WRITABLE) {
      desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
    }
    try {
      Deno.chmodSync(this.#address, desired_mode);
    } catch {
      return codeMap.get("UNKNOWN");
    }
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= 1e3) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
    }
    await delay(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection;
    try {
      connection = await this.#listener.accept();
    } catch (e3) {
      if (e3 instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle = new Pipe(socketType.SOCKET, connection);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === providerType.PIPESERVERWRAP) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap.prototype._onClose.call(this);
  }
};
var PipeConnectWrap = class extends AsyncWrap {
  oncomplete;
  address;
  constructor() {
    super(providerType.PIPECONNECTWRAP);
  }
};
var constants2;
(function(constants7) {
  constants7[constants7["SOCKET"] = socketType.SOCKET] = "SOCKET";
  constants7[constants7["SERVER"] = socketType.SERVER] = "SERVER";
  constants7[constants7["IPC"] = socketType.IPC] = "IPC";
  constants7[constants7["UV_READABLE"] = 1] = "UV_READABLE";
  constants7[constants7["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants2 || (constants2 = {}));
var mod38 = {
  socketType,
  Pipe,
  PipeConnectWrap,
  constants: constants2
};
var mod39 = {};
var mod40 = {};
var mod41 = {};
var mod42 = {};
var mod43 = {};
var mod44 = {};
var asyncIdSymbol = Symbol("asyncIdSymbol");
var ownerSymbol = Symbol("ownerSymbol");
var mod45 = {
  asyncIdSymbol,
  ownerSymbol
};
var mod46 = {};
var socketType1;
(function(socketType4) {
  socketType4[socketType4["SOCKET"] = 0] = "SOCKET";
  socketType4[socketType4["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
var TCPConnectWrap = class extends AsyncWrap {
  oncomplete;
  address;
  port;
  localAddress;
  localPort;
  constructor() {
    super(providerType.TCPCONNECTWRAP);
  }
};
var constants3;
(function(constants7) {
  constants7[constants7["SOCKET"] = socketType1.SOCKET] = "SOCKET";
  constants7[constants7["SERVER"] = socketType1.SERVER] = "SERVER";
  constants7[constants7["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants3 || (constants3 = {}));
var TCP = class extends ConnectionWrap {
  [ownerSymbol] = null;
  reading = false;
  #address;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #backlog;
  #listener;
  #connections = 0;
  #closed = false;
  #acceptBackoffDelay;
  constructor(type, conn) {
    let provider;
    switch (type) {
      case socketType1.SOCKET: {
        provider = providerType.TCPWRAP;
        break;
      }
      case socketType1.SERVER: {
        provider = providerType.TCPSERVERWRAP;
        break;
      }
      default: {
        unreachable();
      }
    }
    super(provider, conn);
    if (conn && provider === providerType.TCPWRAP) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.hostname;
      this.#port = localAddr.port;
      const remoteAddr = conn.remoteAddr;
      this.#remoteAddress = remoteAddr.hostname;
      this.#remotePort = remoteAddr.port;
      this.#remoteFamily = isIP(remoteAddr.hostname);
    }
  }
  open(_fd) {
    notImplemented("TCP.prototype.open");
  }
  bind(address, port) {
    return this.#bind(address, port, 0);
  }
  bind6(address, port, flags) {
    return this.#bind(address, port, flags);
  }
  connect(req, address, port) {
    return this.#connect(req, address, port);
  }
  connect6(req, address, port) {
    return this.#connect(req, address, port);
  }
  listen(backlog) {
    this.#backlog = ceilPowOf2(backlog + 1);
    const listenOptions = {
      hostname: this.#address,
      port: this.#port,
      transport: "tcp"
    };
    let listener;
    try {
      listener = Deno.listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.hostname;
    this.#port = address.port;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref(this.#listener);
    }
  }
  getsockname(sockname) {
    if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
      return codeMap.get("EADDRNOTAVAIL");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = isIP(this.#address);
    return 0;
  }
  getpeername(peername) {
    if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
      return codeMap.get("EADDRNOTAVAIL");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  setNoDelay(_noDelay) {
    return 0;
  }
  setKeepAlive(_enable, _initialDelay) {
    return 0;
  }
  setSimultaneousAccepts(_enable) {
    notImplemented("TCP.prototype.setSimultaneousAccepts");
  }
  #bind(address, port1, _flags) {
    this.#address = address;
    this.#port = port1;
    return 0;
  }
  #connect(req1, address1, port11) {
    this.#remoteAddress = address1;
    this.#remotePort = port11;
    this.#remoteFamily = isIP(address1);
    const connectOptions = {
      hostname: address1,
      port: port11,
      transport: "tcp"
    };
    Deno.connect(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req1.localAddress = localAddr.hostname;
      this.#port = req1.localPort = localAddr.port;
      this[kStreamBaseField] = conn;
      try {
        this.afterConnect(req1, 0);
      } catch {
      }
    }, () => {
      try {
        this.afterConnect(req1, codeMap.get("ECONNREFUSED"));
      } catch {
      }
    });
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= 1e3) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
    }
    await delay(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection1;
    try {
      connection1 = await this.#listener.accept();
    } catch (e4) {
      if (e4 instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle1 = new TCP(socketType1.SOCKET, connection1);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle1);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#remoteAddress = void 0;
    this.#remoteFamily = void 0;
    this.#remotePort = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === providerType.TCPSERVERWRAP) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap.prototype._onClose.call(this);
  }
};
var mod47 = {
  TCPConnectWrap,
  constants: constants3,
  TCP
};
var mod48 = {};
var mod49 = {};
var mod50 = {};
var mod51 = {};
var AF_INET6 = 10;
var UDP_DGRAM_MAXSIZE = 64 * 1024;
var SendWrap = class extends AsyncWrap {
  list;
  address;
  port;
  callback;
  oncomplete;
  constructor() {
    super(providerType.UDPSENDWRAP);
  }
};
var UDP = class extends HandleWrap {
  [ownerSymbol] = null;
  #address;
  #family;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #listener;
  #receiving = false;
  #recvBufferSize = UDP_DGRAM_MAXSIZE;
  #sendBufferSize = UDP_DGRAM_MAXSIZE;
  onmessage;
  lookup;
  constructor() {
    super(providerType.UDPWRAP);
  }
  addMembership(_multicastAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.addMembership");
  }
  addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
  }
  bind(ip, port, flags) {
    return this.#doBind(ip, port, flags, 2);
  }
  bind6(ip, port, flags) {
    return this.#doBind(ip, port, flags, 10);
  }
  bufferSize(size, buffer, ctx) {
    let err;
    if (size > UDP_DGRAM_MAXSIZE) {
      err = "EINVAL";
    } else if (!this.#address) {
      err = isWindows ? "ENOTSOCK" : "EBADF";
    }
    if (err) {
      ctx.errno = codeMap.get(err);
      ctx.code = err;
      ctx.message = errorMap.get(ctx.errno)[1];
      ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
      return;
    }
    if (size !== 0) {
      size = isLinux ? size * 2 : size;
      if (buffer) {
        return this.#recvBufferSize = size;
      }
      return this.#sendBufferSize = size;
    }
    return buffer ? this.#recvBufferSize : this.#sendBufferSize;
  }
  connect(ip, port) {
    return this.#doConnect(ip, port, 2);
  }
  connect6(ip, port) {
    return this.#doConnect(ip, port, 10);
  }
  disconnect() {
    this.#remoteAddress = void 0;
    this.#remotePort = void 0;
    this.#remoteFamily = void 0;
    return 0;
  }
  dropMembership(_multicastAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.dropMembership");
  }
  dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
  }
  getpeername(peername) {
    if (this.#remoteAddress === void 0) {
      return codeMap.get("EBADF");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  getsockname(sockname) {
    if (this.#address === void 0) {
      return codeMap.get("EBADF");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = this.#family;
    return 0;
  }
  open(_fd) {
    notImplemented("udp.UDP.prototype.open");
  }
  recvStart() {
    if (!this.#receiving) {
      this.#receiving = true;
      this.#receive();
    }
    return 0;
  }
  recvStop() {
    this.#receiving = false;
    return 0;
  }
  ref() {
    notImplemented("udp.UDP.prototype.ref");
  }
  send(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, 2);
  }
  send6(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, 10);
  }
  setBroadcast(_bool) {
    notImplemented("udp.UDP.prototype.setBroadcast");
  }
  setMulticastInterface(_interfaceAddress) {
    notImplemented("udp.UDP.prototype.setMulticastInterface");
  }
  setMulticastLoopback(_bool) {
    notImplemented("udp.UDP.prototype.setMulticastLoopback");
  }
  setMulticastTTL(_ttl) {
    notImplemented("udp.UDP.prototype.setMulticastTTL");
  }
  setTTL(_ttl) {
    notImplemented("udp.UDP.prototype.setTTL");
  }
  unref() {
    notImplemented("udp.UDP.prototype.unref");
  }
  #doBind(ip, port2, _flags1, family) {
    const listenOptions = {
      port: port2,
      hostname: ip,
      transport: "udp"
    };
    let listener;
    try {
      listener = listenDatagram(listenOptions);
    } catch (e5) {
      if (e5 instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e5 instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address2 = listener.addr;
    this.#address = address2.hostname;
    this.#port = address2.port;
    this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
    this.#listener = listener;
    return 0;
  }
  #doConnect(ip1, port12, family1) {
    this.#remoteAddress = ip1;
    this.#remotePort = port12;
    this.#remoteFamily = family1 === AF_INET6 ? "IPv6" : "IPv4";
    return 0;
  }
  #doSend(req2, bufs, _count, args, _family) {
    let hasCallback;
    if (args.length === 3) {
      this.#remotePort = args[0];
      this.#remoteAddress = args[1];
      hasCallback = args[2];
    } else {
      hasCallback = args[0];
    }
    const addr = {
      hostname: this.#remoteAddress,
      port: this.#remotePort,
      transport: "udp"
    };
    const payload = new Uint8Array(Buffer2.concat(bufs.map((buf) => {
      if (typeof buf === "string") {
        return Buffer2.from(buf);
      }
      return Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength);
    })));
    (async () => {
      let sent;
      let err = null;
      try {
        sent = await this.#listener.send(payload, addr);
      } catch (e) {
        if (e instanceof Deno.errors.BadResource) {
          err = codeMap.get("EBADF");
        } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
          err = codeMap.get("EMSGSIZE");
        } else {
          err = codeMap.get("UNKNOWN");
        }
        sent = 0;
      }
      if (hasCallback) {
        try {
          req2.oncomplete(err, sent);
        } catch {
        }
      }
    })();
    return 0;
  }
  async #receive() {
    if (!this.#receiving) {
      return;
    }
    const p7 = new Uint8Array(this.#recvBufferSize);
    let buf1;
    let remoteAddr;
    let nread1;
    try {
      [buf1, remoteAddr] = await this.#listener.receive(p7);
      nread1 = buf1.length;
    } catch (e12) {
      if (e12 instanceof Deno.errors.Interrupted || e12 instanceof Deno.errors.BadResource) {
        nread1 = 0;
      } else {
        nread1 = codeMap.get("UNKNOWN");
      }
      buf1 = new Uint8Array(0);
      remoteAddr = null;
    }
    nread1 ??= 0;
    const rinfo = remoteAddr ? {
      address: remoteAddr.hostname,
      port: remoteAddr.port,
      family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
    } : void 0;
    try {
      this.onmessage(nread1, this, Buffer2.from(buf1), rinfo);
    } catch {
    }
    this.#receive();
  }
  _onClose() {
    this.#receiving = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#family = void 0;
    try {
      this.#listener.close();
    } catch {
    }
    this.#listener = void 0;
    return 0;
  }
};
var mod52 = {
  SendWrap,
  UDP
};
var mod53 = {};
var mod54 = {};
var mod55 = {};
var mod56 = {};
var modules = {
  "async_wrap": mod17,
  buffer: mod2,
  "cares_wrap": mod19,
  config: mod18,
  constants: mod4,
  contextify: mod20,
  credentials: mod21,
  crypto: mod6,
  errors: mod22,
  fs: mod23,
  "fs_dir": mod24,
  "fs_event_wrap": mod25,
  "heap_utils": mod26,
  "http_parser": mod27,
  icu: mod28,
  inspector: mod29,
  "js_stream": mod30,
  messaging: mod31,
  "module_wrap": mod32,
  "native_module": mod33,
  natives: mod34,
  options: mod35,
  os: mod36,
  performance: mod39,
  "pipe_wrap": mod38,
  "process_methods": mod40,
  report: mod41,
  serdes: mod42,
  "signal_wrap": mod43,
  "spawn_sync": mod44,
  "stream_wrap": mod37,
  "string_decoder": mod1,
  symbols: mod45,
  "task_queue": mod46,
  "tcp_wrap": mod47,
  timers: mod48,
  "tls_wrap": mod49,
  "trace_events": mod50,
  "tty_wrap": mod51,
  types: mod,
  "udp_wrap": mod52,
  url: mod53,
  util: mod3,
  uv: mod5,
  v8: mod54,
  worker: mod55,
  zlib: mod56
};
function getBinding(name) {
  const mod114 = modules[name];
  if (!mod114) {
    throw new Error(`No such module: ${name}`);
  }
  return mod114;
}
var kInternal = Symbol("internal properties");
var replaceUnderscoresRegex = /_/g;
var leadingDashesRegex = /^--?/;
var trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
  const allowedNodeEnvironmentFlags = [
    "--track-heap-objects",
    "--no-track-heap-objects",
    "--node-snapshot",
    "--no-node-snapshot",
    "--require",
    "--max-old-space-size",
    "--trace-exit",
    "--no-trace-exit",
    "--disallow-code-generation-from-strings",
    "--experimental-json-modules",
    "--no-experimental-json-modules",
    "--interpreted-frames-native-stack",
    "--inspect-brk",
    "--no-inspect-brk",
    "--trace-tls",
    "--no-trace-tls",
    "--stack-trace-limit",
    "--experimental-repl-await",
    "--no-experimental-repl-await",
    "--preserve-symlinks",
    "--no-preserve-symlinks",
    "--report-uncaught-exception",
    "--no-report-uncaught-exception",
    "--experimental-modules",
    "--no-experimental-modules",
    "--report-signal",
    "--jitless",
    "--inspect-port",
    "--heapsnapshot-near-heap-limit",
    "--tls-keylog",
    "--force-context-aware",
    "--no-force-context-aware",
    "--napi-modules",
    "--abort-on-uncaught-exception",
    "--diagnostic-dir",
    "--verify-base-objects",
    "--no-verify-base-objects",
    "--unhandled-rejections",
    "--perf-basic-prof",
    "--trace-atomics-wait",
    "--no-trace-atomics-wait",
    "--deprecation",
    "--no-deprecation",
    "--perf-basic-prof-only-functions",
    "--perf-prof",
    "--max-http-header-size",
    "--report-on-signal",
    "--no-report-on-signal",
    "--throw-deprecation",
    "--no-throw-deprecation",
    "--warnings",
    "--no-warnings",
    "--force-fips",
    "--no-force-fips",
    "--pending-deprecation",
    "--no-pending-deprecation",
    "--input-type",
    "--tls-max-v1.3",
    "--no-tls-max-v1.3",
    "--tls-min-v1.2",
    "--no-tls-min-v1.2",
    "--inspect",
    "--no-inspect",
    "--heapsnapshot-signal",
    "--trace-warnings",
    "--no-trace-warnings",
    "--trace-event-categories",
    "--experimental-worker",
    "--tls-max-v1.2",
    "--no-tls-max-v1.2",
    "--perf-prof-unwinding-info",
    "--preserve-symlinks-main",
    "--no-preserve-symlinks-main",
    "--policy-integrity",
    "--experimental-wasm-modules",
    "--no-experimental-wasm-modules",
    "--node-memory-debug",
    "--inspect-publish-uid",
    "--tls-min-v1.3",
    "--no-tls-min-v1.3",
    "--experimental-specifier-resolution",
    "--secure-heap",
    "--tls-min-v1.0",
    "--no-tls-min-v1.0",
    "--redirect-warnings",
    "--experimental-report",
    "--trace-event-file-pattern",
    "--trace-uncaught",
    "--no-trace-uncaught",
    "--experimental-loader",
    "--http-parser",
    "--dns-result-order",
    "--trace-sigint",
    "--no-trace-sigint",
    "--secure-heap-min",
    "--enable-fips",
    "--no-enable-fips",
    "--enable-source-maps",
    "--no-enable-source-maps",
    "--insecure-http-parser",
    "--no-insecure-http-parser",
    "--use-openssl-ca",
    "--no-use-openssl-ca",
    "--tls-cipher-list",
    "--experimental-top-level-await",
    "--no-experimental-top-level-await",
    "--openssl-config",
    "--icu-data-dir",
    "--v8-pool-size",
    "--report-on-fatalerror",
    "--no-report-on-fatalerror",
    "--title",
    "--tls-min-v1.1",
    "--no-tls-min-v1.1",
    "--report-filename",
    "--trace-deprecation",
    "--no-trace-deprecation",
    "--report-compact",
    "--no-report-compact",
    "--experimental-policy",
    "--experimental-import-meta-resolve",
    "--no-experimental-import-meta-resolve",
    "--zero-fill-buffers",
    "--no-zero-fill-buffers",
    "--report-dir",
    "--use-bundled-ca",
    "--no-use-bundled-ca",
    "--experimental-vm-modules",
    "--no-experimental-vm-modules",
    "--force-async-hooks-checks",
    "--no-force-async-hooks-checks",
    "--frozen-intrinsics",
    "--no-frozen-intrinsics",
    "--huge-max-old-generation-size",
    "--disable-proto",
    "--debug-arraybuffer-allocations",
    "--no-debug-arraybuffer-allocations",
    "--conditions",
    "--experimental-wasi-unstable-preview1",
    "--no-experimental-wasi-unstable-preview1",
    "--trace-sync-io",
    "--no-trace-sync-io",
    "--use-largepages",
    "--experimental-abortcontroller",
    "--debug-port",
    "--es-module-specifier-resolution",
    "--prof-process",
    "-C",
    "--loader",
    "--report-directory",
    "-r",
    "--trace-events-enabled"
  ];
  const trimLeadingDashes = (flag) => flag.replace(leadingDashesRegex, "");
  const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
  class NodeEnvironmentFlagsSet extends Set {
    constructor(array) {
      super();
      this[kInternal] = {
        array
      };
    }
    add() {
      return this;
    }
    delete() {
      return false;
    }
    clear() {
    }
    has(key2) {
      if (typeof key2 === "string") {
        key2 = key2.replace(replaceUnderscoresRegex, "-");
        if (leadingDashesRegex.test(key2)) {
          key2 = key2.replace(trailingValuesRegex, "");
          return this[kInternal].array.includes(key2);
        }
        return nodeFlags.includes(key2);
      }
      return false;
    }
    entries() {
      this[kInternal].set ??= new Set(this[kInternal].array);
      return this[kInternal].set.entries();
    }
    forEach(callback, thisArg = void 0) {
      this[kInternal].array.forEach((v19) => Reflect.apply(callback, thisArg, [
        v19,
        v19,
        this
      ]));
    }
    get size() {
      return this[kInternal].array.length;
    }
    values() {
      this[kInternal].set ??= new Set(this[kInternal].array);
      return this[kInternal].set.values();
    }
  }
  NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
  Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
  Object.freeze(NodeEnvironmentFlagsSet.prototype);
  return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
var notImplementedEvents = [
  "beforeExit",
  "disconnect",
  "message",
  "multipleResolves",
  "rejectionHandled",
  "uncaughtException",
  "uncaughtExceptionMonitor",
  "unhandledRejection",
  "worker"
];
var argv = [
  "",
  "",
  ...Deno.args
];
Object.defineProperty(argv, "0", {
  get: Deno.execPath
});
Object.defineProperty(argv, "1", {
  get: () => fromFileUrl2(Deno.mainModule)
});
var exit = (code2) => {
  if (code2 || code2 === 0) {
    if (typeof code2 === "string") {
      const parsedCode = parseInt(code2);
      process1.exitCode = isNaN(parsedCode) ? void 0 : parsedCode;
    } else {
      process1.exitCode = code2;
    }
  }
  if (!process1._exiting) {
    process1._exiting = true;
    process1.emit("exit", process1.exitCode || 0);
  }
  Deno.exit(process1.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
  const value = getOptionValue(option);
  if (value) {
    Object.defineProperty(process1, name, {
      writable: false,
      configurable: true,
      enumerable,
      value
    });
  }
}
function createWarningObject(warning, type, code2, ctor, detail) {
  assert1(typeof warning === "string");
  const warningErr = new Error(warning);
  warningErr.name = String(type || "Warning");
  if (code2 !== void 0) {
    warningErr.code = code2;
  }
  if (detail !== void 0) {
    warningErr.detail = detail;
  }
  Error.captureStackTrace(warningErr, ctor || process1.emitWarning);
  return warningErr;
}
function doEmitWarning(warning) {
  process1.emit("warning", warning);
}
function emitWarning(warning, type, code2, ctor) {
  let detail;
  if (type !== null && typeof type === "object" && !Array.isArray(type)) {
    ctor = type.ctor;
    code2 = type.code;
    if (typeof type.detail === "string") {
      detail = type.detail;
    }
    type = type.type || "Warning";
  } else if (typeof type === "function") {
    ctor = type;
    code2 = void 0;
    type = "Warning";
  }
  if (type !== void 0) {
    validateString(type, "type");
  }
  if (typeof code2 === "function") {
    ctor = code2;
    code2 = void 0;
  } else if (code2 !== void 0) {
    validateString(code2, "code");
  }
  if (typeof warning === "string") {
    warning = createWarningObject(warning, type, code2, ctor, detail);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE("warning", [
      "Error",
      "string"
    ], warning);
  }
  if (warning.name === "DeprecationWarning") {
    if (process1.noDeprecation) {
      return;
    }
    if (process1.throwDeprecation) {
      return process1.nextTick(() => {
        throw warning;
      });
    }
  }
  process1.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
  const milli = performance.now();
  const sec = Math.floor(milli / 1e3);
  const nano = Math.floor(milli * 1e6 - sec * 1e9);
  if (!time) {
    return [
      sec,
      nano
    ];
  }
  const [prevSec, prevNano] = time;
  return [
    sec - prevSec,
    nano - prevNano
  ];
}
hrtime.bigint = function() {
  const [sec, nano] = hrtime();
  return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage() {
  return {
    ...Deno.memoryUsage(),
    arrayBuffers: 0
  };
}
memoryUsage.rss = function() {
  return memoryUsage().rss;
};
function kill(pid2, sig = "SIGTERM") {
  if (pid2 != (pid2 | 0)) {
    throw new ERR_INVALID_ARG_TYPE("pid", "number", pid2);
  }
  if (typeof sig === "string") {
    try {
      Deno.kill(pid2, sig);
    } catch (e) {
      if (e instanceof TypeError) {
        throw new ERR_UNKNOWN_SIGNAL(sig);
      }
      throw e;
    }
  } else {
    throw new ERR_UNKNOWN_SIGNAL(sig.toString());
  }
  return true;
}
var Process = class extends EventEmitter {
  constructor() {
    super();
    globalThis.addEventListener("unload", () => {
      if (!process1._exiting) {
        process1._exiting = true;
        super.emit("exit", process1.exitCode || 0);
      }
    });
  }
  arch = arch;
  argv = argv;
  chdir = chdir;
  config = {
    target_defaults: {},
    variables: {}
  };
  cwd = cwd;
  env = env;
  execArgv = [];
  exit = exit;
  _exiting = _exiting;
  exitCode = void 0;
  mainModule = void 0;
  nextTick = nextTick1;
  on(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.on("${event}")`);
      super.on(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener(event, listener);
      }
    } else {
      super.on(event, listener);
    }
    return this;
  }
  off(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.off("${event}")`);
      super.off(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        removeSignalListener(event, listener);
      }
    } else {
      super.off(event, listener);
    }
    return this;
  }
  emit(event, ...args) {
    if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        Deno.kill(Deno.pid, event);
      }
    } else {
      return super.emit(event, ...args);
    }
    return true;
  }
  prependListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.prependListener("${event}")`);
      super.prependListener(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener(event, listener);
      }
    } else {
      super.prependListener(event, listener);
    }
    return this;
  }
  pid = pid;
  platform = platform;
  addListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.addListener("${event}")`);
    }
    return this.on(event, listener);
  }
  removeListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.removeListener("${event}")`);
    }
    return this.off(event, listener);
  }
  hrtime = hrtime;
  kill = kill;
  memoryUsage = memoryUsage;
  stderr = stderr;
  stdin = stdin;
  stdout = stdout;
  version = version;
  versions = versions;
  emitWarning = emitWarning;
  binding(name) {
    return getBinding(name);
  }
  umask() {
    return 18;
  }
  getuid() {
    return NaN;
  }
  getgid() {
    return NaN;
  }
  _eval = void 0;
  get execPath() {
    return argv[0];
  }
  #startTime = Date.now();
  uptime() {
    return (Date.now() - this.#startTime) / 1e3;
  }
  #allowedFlags = buildAllowedFlags();
  get allowedNodeEnvironmentFlags() {
    return this.#allowedFlags;
  }
  features = {
    inspector: false
  };
};
var process1 = new Process();
Object.defineProperty(process1, Symbol.toStringTag, {
  enumerable: false,
  writable: true,
  configurable: false,
  value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process1.removeListener;
process1.removeAllListeners;
var H0 = Object.create;
var X1 = Object.defineProperty;
var U0 = Object.getOwnPropertyDescriptor;
var z0 = Object.getOwnPropertyNames;
var G0 = Object.getPrototypeOf;
var $01 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (r2, h16) => (typeof require != "undefined" ? require : r2)[h16]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var w5 = (t2, r2) => () => (r2 || t2((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var K0 = (t2, r2, h16, e) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let i of z0(r2))
      !$01.call(t2, i) && i !== h16 && X1(t2, i, {
        get: () => r2[i],
        enumerable: !(e = U0(r2, i)) || e.enumerable
      });
  return t2;
};
var Y = (t2, r2, h16) => (h16 = t2 != null ? H0(G0(t2)) : {}, K0(r2 || !t2 || !t2.__esModule ? X1(h16, "default", {
  value: t2,
  enumerable: true
}) : h16, t2));
var I3 = w5((St2, T12) => {
  var Z2 = L1;
  function z15(t2, r2) {
    this._block = Z2.alloc(t2), this._finalSize = r2, this._blockSize = t2, this._len = 0;
  }
  z15.prototype.update = function(t2, r2) {
    typeof t2 == "string" && (r2 = r2 || "utf8", t2 = Z2.from(t2, r2));
    for (var h16 = this._block, e = this._blockSize, i = t2.length, _11 = this._len, s10 = 0; s10 < i; ) {
      for (var a7 = _11 % e, x17 = Math.min(i - s10, e - a7), c13 = 0; c13 < x17; c13++)
        h16[a7 + c13] = t2[s10 + c13];
      _11 += x17, s10 += x17, _11 % e === 0 && this._update(h16);
    }
    return this._len += i, this;
  };
  z15.prototype.digest = function(t2) {
    var r2 = this._len % this._blockSize;
    this._block[r2] = 128, this._block.fill(0, r2 + 1), r2 >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var h16 = this._len * 8;
    if (h16 <= 4294967295)
      this._block.writeUInt32BE(h16, this._blockSize - 4);
    else {
      var e = (h16 & 4294967295) >>> 0, i = (h16 - e) / 4294967296;
      this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(e, this._blockSize - 4);
    }
    this._update(this._block);
    var _11 = this._hash();
    return t2 ? _11.toString(t2) : _11;
  };
  z15.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  T12.exports = z15;
});
var t01 = w5((kt2, j13) => {
  var L0 = w, W2 = I3(), J0 = L1, M0 = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], N02 = new Array(80);
  function k15() {
    this.init(), this._w = N02, W2.call(this, 64, 56);
  }
  L0(k15, W2);
  k15.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function O02(t2) {
    return t2 << 5 | t2 >>> 27;
  }
  function P0(t2) {
    return t2 << 30 | t2 >>> 2;
  }
  function Q0(t2, r2, h16, e) {
    return t2 === 0 ? r2 & h16 | ~r2 & e : t2 === 2 ? r2 & h16 | r2 & e | h16 & e : r2 ^ h16 ^ e;
  }
  k15.prototype._update = function(t2) {
    for (var r2 = this._w, h16 = this._a | 0, e = this._b | 0, i = this._c | 0, _11 = this._d | 0, s10 = this._e | 0, a7 = 0; a7 < 16; ++a7)
      r2[a7] = t2.readInt32BE(a7 * 4);
    for (; a7 < 80; ++a7)
      r2[a7] = r2[a7 - 3] ^ r2[a7 - 8] ^ r2[a7 - 14] ^ r2[a7 - 16];
    for (var x17 = 0; x17 < 80; ++x17) {
      var c13 = ~~(x17 / 20), f8 = O02(h16) + Q0(c13, e, i, _11) + s10 + r2[x17] + M0[c13] | 0;
      s10 = _11, _11 = i, i = P0(e), e = h16, h16 = f8;
    }
    this._a = h16 + this._a | 0, this._b = e + this._b | 0, this._c = i + this._c | 0, this._d = _11 + this._d | 0, this._e = s10 + this._e | 0;
  };
  k15.prototype._hash = function() {
    var t2 = J0.allocUnsafe(20);
    return t2.writeInt32BE(this._a | 0, 0), t2.writeInt32BE(this._b | 0, 4), t2.writeInt32BE(this._c | 0, 8), t2.writeInt32BE(this._d | 0, 12), t2.writeInt32BE(this._e | 0, 16), t2;
  };
  j13.exports = k15;
});
var e0 = w5((mt2, h02) => {
  var R0 = w, r0 = I3(), V0 = L1, X0 = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], Y0 = new Array(80);
  function m20() {
    this.init(), this._w = Y0, r0.call(this, 64, 56);
  }
  R0(m20, r0);
  m20.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Z02(t2) {
    return t2 << 1 | t2 >>> 31;
  }
  function T0(t2) {
    return t2 << 5 | t2 >>> 27;
  }
  function W0(t2) {
    return t2 << 30 | t2 >>> 2;
  }
  function j0(t2, r2, h16, e) {
    return t2 === 0 ? r2 & h16 | ~r2 & e : t2 === 2 ? r2 & h16 | r2 & e | h16 & e : r2 ^ h16 ^ e;
  }
  m20.prototype._update = function(t2) {
    for (var r2 = this._w, h16 = this._a | 0, e = this._b | 0, i = this._c | 0, _11 = this._d | 0, s10 = this._e | 0, a7 = 0; a7 < 16; ++a7)
      r2[a7] = t2.readInt32BE(a7 * 4);
    for (; a7 < 80; ++a7)
      r2[a7] = Z02(r2[a7 - 3] ^ r2[a7 - 8] ^ r2[a7 - 14] ^ r2[a7 - 16]);
    for (var x17 = 0; x17 < 80; ++x17) {
      var c13 = ~~(x17 / 20), f8 = T0(h16) + j0(c13, e, i, _11) + s10 + r2[x17] + X0[c13] | 0;
      s10 = _11, _11 = i, i = W0(e), e = h16, h16 = f8;
    }
    this._a = h16 + this._a | 0, this._b = e + this._b | 0, this._c = i + this._c | 0, this._d = _11 + this._d | 0, this._e = s10 + this._e | 0;
  };
  m20.prototype._hash = function() {
    var t2 = V0.allocUnsafe(20);
    return t2.writeInt32BE(this._a | 0, 0), t2.writeInt32BE(this._b | 0, 4), t2.writeInt32BE(this._c | 0, 8), t2.writeInt32BE(this._d | 0, 12), t2.writeInt32BE(this._e | 0, 16), t2;
  };
  h02.exports = m20;
});
var K4 = w5((Ht, a0) => {
  var tt3 = w, i0 = I3(), rt3 = L1, ht4 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], et2 = new Array(64);
  function H9() {
    this.init(), this._w = et2, i0.call(this, 64, 56);
  }
  tt3(H9, i0);
  H9.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function it3(t2, r2, h16) {
    return h16 ^ t2 & (r2 ^ h16);
  }
  function at2(t2, r2, h16) {
    return t2 & r2 | h16 & (t2 | r2);
  }
  function st2(t2) {
    return (t2 >>> 2 | t2 << 30) ^ (t2 >>> 13 | t2 << 19) ^ (t2 >>> 22 | t2 << 10);
  }
  function _t2(t2) {
    return (t2 >>> 6 | t2 << 26) ^ (t2 >>> 11 | t2 << 21) ^ (t2 >>> 25 | t2 << 7);
  }
  function ft2(t2) {
    return (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
  }
  function xt(t2) {
    return (t2 >>> 17 | t2 << 15) ^ (t2 >>> 19 | t2 << 13) ^ t2 >>> 10;
  }
  H9.prototype._update = function(t2) {
    for (var r2 = this._w, h16 = this._a | 0, e = this._b | 0, i = this._c | 0, _11 = this._d | 0, s10 = this._e | 0, a7 = this._f | 0, x17 = this._g | 0, c13 = this._h | 0, f8 = 0; f8 < 16; ++f8)
      r2[f8] = t2.readInt32BE(f8 * 4);
    for (; f8 < 64; ++f8)
      r2[f8] = xt(r2[f8 - 2]) + r2[f8 - 7] + ft2(r2[f8 - 15]) + r2[f8 - 16] | 0;
    for (var v19 = 0; v19 < 64; ++v19) {
      var B18 = c13 + _t2(s10) + it3(s10, a7, x17) + ht4[v19] + r2[v19] | 0, C11 = st2(h16) + at2(h16, e, i) | 0;
      c13 = x17, x17 = a7, a7 = s10, s10 = _11 + B18 | 0, _11 = i, i = e, e = h16, h16 = B18 + C11 | 0;
    }
    this._a = h16 + this._a | 0, this._b = e + this._b | 0, this._c = i + this._c | 0, this._d = _11 + this._d | 0, this._e = s10 + this._e | 0, this._f = a7 + this._f | 0, this._g = x17 + this._g | 0, this._h = c13 + this._h | 0;
  };
  H9.prototype._hash = function() {
    var t2 = rt3.allocUnsafe(32);
    return t2.writeInt32BE(this._a, 0), t2.writeInt32BE(this._b, 4), t2.writeInt32BE(this._c, 8), t2.writeInt32BE(this._d, 12), t2.writeInt32BE(this._e, 16), t2.writeInt32BE(this._f, 20), t2.writeInt32BE(this._g, 24), t2.writeInt32BE(this._h, 28), t2;
  };
  a0.exports = H9;
});
var _0 = w5((Ut, s0) => {
  var ct3 = w, nt2 = K4(), bt2 = I3(), ot2 = L1, ut4 = new Array(64);
  function G11() {
    this.init(), this._w = ut4, bt2.call(this, 64, 56);
  }
  ct3(G11, nt2);
  G11.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  G11.prototype._hash = function() {
    var t2 = ot2.allocUnsafe(28);
    return t2.writeInt32BE(this._a, 0), t2.writeInt32BE(this._b, 4), t2.writeInt32BE(this._c, 8), t2.writeInt32BE(this._d, 12), t2.writeInt32BE(this._e, 16), t2.writeInt32BE(this._f, 20), t2.writeInt32BE(this._g, 24), t2;
  };
  s0.exports = G11;
});
var L2 = w5((zt2, u0) => {
  var dt2 = w, o0 = I3(), vt = L1, f02 = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], lt2 = new Array(160);
  function U7() {
    this.init(), this._w = lt2, o0.call(this, 128, 112);
  }
  dt2(U7, o0);
  U7.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function x0(t2, r2, h16) {
    return h16 ^ t2 & (r2 ^ h16);
  }
  function c02(t2, r2, h16) {
    return t2 & r2 | h16 & (t2 | r2);
  }
  function n0(t2, r2) {
    return (t2 >>> 28 | r2 << 4) ^ (r2 >>> 2 | t2 << 30) ^ (r2 >>> 7 | t2 << 25);
  }
  function b0(t2, r2) {
    return (t2 >>> 14 | r2 << 18) ^ (t2 >>> 18 | r2 << 14) ^ (r2 >>> 9 | t2 << 23);
  }
  function Bt(t2, r2) {
    return (t2 >>> 1 | r2 << 31) ^ (t2 >>> 8 | r2 << 24) ^ t2 >>> 7;
  }
  function pt2(t2, r2) {
    return (t2 >>> 1 | r2 << 31) ^ (t2 >>> 8 | r2 << 24) ^ (t2 >>> 7 | r2 << 25);
  }
  function Et(t2, r2) {
    return (t2 >>> 19 | r2 << 13) ^ (r2 >>> 29 | t2 << 3) ^ t2 >>> 6;
  }
  function wt(t2, r2) {
    return (t2 >>> 19 | r2 << 13) ^ (r2 >>> 29 | t2 << 3) ^ (t2 >>> 6 | r2 << 26);
  }
  function b15(t2, r2) {
    return t2 >>> 0 < r2 >>> 0 ? 1 : 0;
  }
  U7.prototype._update = function(t2) {
    for (var r2 = this._w, h16 = this._ah | 0, e = this._bh | 0, i = this._ch | 0, _11 = this._dh | 0, s10 = this._eh | 0, a7 = this._fh | 0, x17 = this._gh | 0, c13 = this._hh | 0, f8 = this._al | 0, v19 = this._bl | 0, B18 = this._cl | 0, C11 = this._dl | 0, p7 = this._el | 0, F12 = this._fl | 0, q15 = this._gl | 0, y16 = this._hl | 0, n3 = 0; n3 < 32; n3 += 2)
      r2[n3] = t2.readInt32BE(n3 * 4), r2[n3 + 1] = t2.readInt32BE(n3 * 4 + 4);
    for (; n3 < 160; n3 += 2) {
      var D12 = r2[n3 - 30], S14 = r2[n3 - 15 * 2 + 1], E0 = Bt(D12, S14), M14 = pt2(S14, D12);
      D12 = r2[n3 - 2 * 2], S14 = r2[n3 - 2 * 2 + 1];
      var w02 = Et(D12, S14), N6 = wt(S14, D12), C0 = r2[n3 - 7 * 2], A0 = r2[n3 - 7 * 2 + 1], I0 = r2[n3 - 16 * 2], O9 = r2[n3 - 16 * 2 + 1], d14 = M14 + A0 | 0, A14 = E0 + C0 + b15(d14, M14) | 0;
      d14 = d14 + N6 | 0, A14 = A14 + w02 + b15(d14, N6) | 0, d14 = d14 + O9 | 0, A14 = A14 + I0 + b15(d14, O9) | 0, r2[n3] = A14, r2[n3 + 1] = d14;
    }
    for (var g17 = 0; g17 < 160; g17 += 2) {
      A14 = r2[g17], d14 = r2[g17 + 1];
      var g02 = c02(h16, e, i), F0 = c02(f8, v19, B18), q0 = n0(h16, f8), P13 = n0(f8, h16), y0 = b0(s10, p7), D0 = b0(p7, s10), S02 = f02[g17], Q9 = f02[g17 + 1], k02 = x0(s10, a7, x17), R13 = x0(p7, F12, q15), o6 = y16 + D0 | 0, E15 = c13 + y0 + b15(o6, y16) | 0;
      o6 = o6 + R13 | 0, E15 = E15 + k02 + b15(o6, R13) | 0, o6 = o6 + Q9 | 0, E15 = E15 + S02 + b15(o6, Q9) | 0, o6 = o6 + d14 | 0, E15 = E15 + A14 + b15(o6, d14) | 0;
      var V8 = P13 + F0 | 0, m0 = q0 + g02 + b15(V8, P13) | 0;
      c13 = x17, y16 = q15, x17 = a7, q15 = F12, a7 = s10, F12 = p7, p7 = C11 + o6 | 0, s10 = _11 + E15 + b15(p7, C11) | 0, _11 = i, C11 = B18, i = e, B18 = v19, e = h16, v19 = f8, f8 = o6 + V8 | 0, h16 = E15 + m0 + b15(f8, o6) | 0;
    }
    this._al = this._al + f8 | 0, this._bl = this._bl + v19 | 0, this._cl = this._cl + B18 | 0, this._dl = this._dl + C11 | 0, this._el = this._el + p7 | 0, this._fl = this._fl + F12 | 0, this._gl = this._gl + q15 | 0, this._hl = this._hl + y16 | 0, this._ah = this._ah + h16 + b15(this._al, f8) | 0, this._bh = this._bh + e + b15(this._bl, v19) | 0, this._ch = this._ch + i + b15(this._cl, B18) | 0, this._dh = this._dh + _11 + b15(this._dl, C11) | 0, this._eh = this._eh + s10 + b15(this._el, p7) | 0, this._fh = this._fh + a7 + b15(this._fl, F12) | 0, this._gh = this._gh + x17 + b15(this._gl, q15) | 0, this._hh = this._hh + c13 + b15(this._hl, y16) | 0;
  };
  U7.prototype._hash = function() {
    var t2 = vt.allocUnsafe(64);
    function r2(h16, e, i) {
      t2.writeInt32BE(h16, i), t2.writeInt32BE(e, i + 4);
    }
    return r2(this._ah, this._al, 0), r2(this._bh, this._bl, 8), r2(this._ch, this._cl, 16), r2(this._dh, this._dl, 24), r2(this._eh, this._el, 32), r2(this._fh, this._fl, 40), r2(this._gh, this._gl, 48), r2(this._hh, this._hl, 56), t2;
  };
  u0.exports = U7;
});
var v0 = w5((Gt, d0) => {
  var Ct = w, At2 = L2(), It2 = I3(), gt3 = L1, Ft = new Array(160);
  function $17() {
    this.init(), this._w = Ft, It2.call(this, 128, 112);
  }
  Ct($17, At2);
  $17.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  $17.prototype._hash = function() {
    var t2 = gt3.allocUnsafe(48);
    function r2(h16, e, i) {
      t2.writeInt32BE(h16, i), t2.writeInt32BE(e, i + 4);
    }
    return r2(this._ah, this._al, 0), r2(this._bh, this._bl, 8), r2(this._ch, this._cl, 16), r2(this._dh, this._dl, 24), r2(this._eh, this._el, 32), r2(this._fh, this._fl, 40), t2;
  };
  d0.exports = $17;
});
var J1 = w5((l22, l0) => {
  var l22 = l0.exports = function(r2) {
    r2 = r2.toLowerCase();
    var h16 = l22[r2];
    if (!h16)
      throw new Error(r2 + " is not supported (we accept pull requests)");
    return new h16();
  };
  l22.sha = t01();
  l22.sha1 = e0();
  l22.sha224 = _0();
  l22.sha256 = K4();
  l22.sha384 = v0();
  l22.sha512 = L2();
});
var B0 = Y(J1());
var p0 = Y(J1());
var { sha: $t, sha1: Kt, sha224: Lt, sha256: Jt, sha384: Mt, sha512: Nt } = p0;
var { default: qt, ...yt } = p0;
var Ot = B0.default ?? qt ?? yt;
function addSignalListener1(...args) {
  if (typeof Deno.addSignalListener == "function") {
    return Deno.addSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function removeSignalListener1(...args) {
  if (typeof Deno.removeSignalListener == "function") {
    return Deno.removeSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function setRaw1(...args) {
  if (typeof Deno.setRaw == "function") {
    return Deno.setRaw(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
async function connect1(options) {
  return await Deno.connect(options);
}
function listen1(options) {
  return Deno.listen(options);
}
function listenDatagram1(options) {
  return Deno.listenDatagram(options);
}
function ListenerRef1(listener, ...args) {
  if (typeof listener.ref == "function") {
    return listener.ref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function ListenerUnref1(listener, ...args) {
  if (typeof listener.unref == "function") {
    return listener.unref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function delay1(ms, options = {}) {
  const { signal } = options;
  if (signal?.aborted) {
    return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
  }
  return new Promise((resolve9, reject) => {
    const abort = () => {
      clearTimeout(i);
      reject(new DOMException("Delay was aborted.", "AbortError"));
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve9();
    };
    const i = setTimeout(done, ms);
    signal?.addEventListener("abort", abort, {
      once: true
    });
  });
}
var { Deno: Deno2 } = globalThis;
typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
var DiffType1;
(function(DiffType3) {
  DiffType3["removed"] = "removed";
  DiffType3["common"] = "common";
  DiffType3["added"] = "added";
})(DiffType1 || (DiffType1 = {}));
var AssertionError1 = class extends Error {
  name = "AssertionError";
  constructor(message) {
    super(message);
  }
};
function unreachable1() {
  throw new AssertionError1("unreachable");
}
function notImplemented1(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  throw new Error(message);
}
function warnNotImplemented1(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  console.warn(message);
}
var _TextDecoder = TextDecoder;
var _TextEncoder = TextEncoder;
function spliceOne1(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function normalizeEncoding3(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases2(enc);
}
function slowCases2(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}
var _toString2 = Object.prototype.toString;
var _isObjectLike2 = (value) => value !== null && typeof value === "object";
var _isFunctionLike1 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer2(value) {
  return _isObjectLike2(value) && (_toString2.call(value) === "[object ArrayBuffer]" || _toString2.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Arguments]";
}
function isArrayBuffer2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction2(value) {
  return _isFunctionLike1(value) && _toString2.call(value) === "[object AsyncFunction]";
}
function isBooleanObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Boolean]";
}
function isBoxedPrimitive2(value) {
  return isBooleanObject2(value) || isStringObject2(value) || isNumberObject2(value) || isSymbolObject2(value) || isBigIntObject2(value);
}
function isDataView2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object DataView]";
}
function isDate2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Date]";
}
function isGeneratorFunction2(value) {
  return _isFunctionLike1(value) && _toString2.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Generator]";
}
function isMap2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Map]";
}
function isMapIterator2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Module]";
}
function isNativeError2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Error]";
}
function isNumberObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Number]";
}
function isBigIntObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object BigInt]";
}
function isPromise2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Promise]";
}
function isRegExp2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object RegExp]";
}
function isSet2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Set]";
}
function isSetIterator2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object String]";
}
function isSymbolObject2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Symbol]";
}
function isWeakMap2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object WeakMap]";
}
function isWeakSet2(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object WeakSet]";
}
var __default10 = {
  isAsyncFunction: isAsyncFunction2,
  isGeneratorFunction: isGeneratorFunction2,
  isAnyArrayBuffer: isAnyArrayBuffer2,
  isArrayBuffer: isArrayBuffer2,
  isArgumentsObject: isArgumentsObject2,
  isBoxedPrimitive: isBoxedPrimitive2,
  isDataView: isDataView2,
  isMap: isMap2,
  isMapIterator: isMapIterator2,
  isModuleNamespaceObject: isModuleNamespaceObject2,
  isNativeError: isNativeError2,
  isPromise: isPromise2,
  isSet: isSet2,
  isSetIterator: isSetIterator2,
  isWeakMap: isWeakMap2,
  isWeakSet: isWeakSet2,
  isRegExp: isRegExp2,
  isDate: isDate2,
  isStringObject: isStringObject2,
  isNumberObject: isNumberObject2,
  isBooleanObject: isBooleanObject2,
  isBigIntObject: isBigIntObject2
};
var mod57 = {
  isAnyArrayBuffer: isAnyArrayBuffer2,
  isArgumentsObject: isArgumentsObject2,
  isArrayBuffer: isArrayBuffer2,
  isAsyncFunction: isAsyncFunction2,
  isBooleanObject: isBooleanObject2,
  isBoxedPrimitive: isBoxedPrimitive2,
  isDataView: isDataView2,
  isDate: isDate2,
  isGeneratorFunction: isGeneratorFunction2,
  isGeneratorObject: isGeneratorObject2,
  isMap: isMap2,
  isMapIterator: isMapIterator2,
  isModuleNamespaceObject: isModuleNamespaceObject2,
  isNativeError: isNativeError2,
  isNumberObject: isNumberObject2,
  isBigIntObject: isBigIntObject2,
  isPromise: isPromise2,
  isRegExp: isRegExp2,
  isSet: isSet2,
  isSetIterator: isSetIterator2,
  isSharedArrayBuffer: isSharedArrayBuffer2,
  isStringObject: isStringObject2,
  isSymbolObject: isSymbolObject2,
  isWeakMap: isWeakMap2,
  isWeakSet: isWeakSet2,
  default: __default10
};
Symbol("kHandle");
var kKeyObject1 = Symbol("kKeyObject");
var kKeyType1 = Symbol("kKeyType");
function isKeyObject1(obj2) {
  return obj2 != null && obj2[kKeyType1] !== void 0;
}
function isCryptoKey1(obj2) {
  return obj2 != null && obj2[kKeyObject1] !== void 0;
}
var _toString3 = Object.prototype.toString;
var _isObjectLike3 = (value) => value !== null && typeof value === "object";
function isArrayBufferView1(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object BigUint64Array]";
}
function isFloat32Array1(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Float32Array]";
}
function isFloat64Array1(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Int32Array]";
}
function isTypedArray1(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike3(value) && reTypedTag.test(_toString3.call(value));
}
function isUint8Array1(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Uint32Array]";
}
var { isDate: isDate3, isArgumentsObject: isArgumentsObject3, isBigIntObject: isBigIntObject3, isBooleanObject: isBooleanObject3, isNumberObject: isNumberObject3, isStringObject: isStringObject3, isSymbolObject: isSymbolObject3, isNativeError: isNativeError3, isRegExp: isRegExp3, isAsyncFunction: isAsyncFunction3, isGeneratorFunction: isGeneratorFunction3, isGeneratorObject: isGeneratorObject3, isPromise: isPromise3, isMap: isMap3, isSet: isSet3, isMapIterator: isMapIterator3, isSetIterator: isSetIterator3, isWeakMap: isWeakMap3, isWeakSet: isWeakSet3, isArrayBuffer: isArrayBuffer3, isDataView: isDataView3, isSharedArrayBuffer: isSharedArrayBuffer3, isModuleNamespaceObject: isModuleNamespaceObject3, isAnyArrayBuffer: isAnyArrayBuffer3, isBoxedPrimitive: isBoxedPrimitive3 } = mod57;
var mod58 = {
  isCryptoKey: isCryptoKey1,
  isKeyObject: isKeyObject1,
  isArrayBufferView: isArrayBufferView1,
  isBigInt64Array,
  isBigUint64Array,
  isFloat32Array: isFloat32Array1,
  isFloat64Array: isFloat64Array1,
  isInt8Array,
  isInt16Array,
  isInt32Array,
  isTypedArray: isTypedArray1,
  isUint8Array: isUint8Array1,
  isUint8ClampedArray,
  isUint16Array,
  isUint32Array,
  isDate: isDate3,
  isArgumentsObject: isArgumentsObject3,
  isBigIntObject: isBigIntObject3,
  isBooleanObject: isBooleanObject3,
  isNumberObject: isNumberObject3,
  isStringObject: isStringObject3,
  isSymbolObject: isSymbolObject3,
  isNativeError: isNativeError3,
  isRegExp: isRegExp3,
  isAsyncFunction: isAsyncFunction3,
  isGeneratorFunction: isGeneratorFunction3,
  isGeneratorObject: isGeneratorObject3,
  isPromise: isPromise3,
  isMap: isMap3,
  isSet: isSet3,
  isMapIterator: isMapIterator3,
  isSetIterator: isSetIterator3,
  isWeakMap: isWeakMap3,
  isWeakSet: isWeakSet3,
  isArrayBuffer: isArrayBuffer3,
  isDataView: isDataView3,
  isSharedArrayBuffer: isSharedArrayBuffer3,
  isModuleNamespaceObject: isModuleNamespaceObject3,
  isAnyArrayBuffer: isAnyArrayBuffer3,
  isBoxedPrimitive: isBoxedPrimitive3
};
var codes1 = {};
function hideStackFrames1(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", {
    value: hidden
  });
  return fn;
}
function normalizeEncoding4(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases3(enc);
}
function slowCases3(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}
function isInt321(value) {
  return value === (value | 0);
}
function isUint321(value) {
  return value === value >>> 0;
}
var validateBuffer1 = hideStackFrames1((buffer, name = "buffer") => {
  if (!isArrayBufferView1(buffer)) {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, [
      "Buffer",
      "TypedArray",
      "DataView"
    ], buffer);
  }
});
hideStackFrames1((value, name, min3 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
var validateObject1 = hideStackFrames1((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
hideStackFrames1((value, name, min3 = -2147483648, max2 = 2147483647) => {
  if (!isInt321(value)) {
    if (typeof value !== "number") {
      throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
  if (value < min3 || value > max2) {
    throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
hideStackFrames1((value, name, positive) => {
  if (!isUint321(value)) {
    if (typeof value !== "number") {
      throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min3 = positive ? 1 : 0;
    throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min3} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes1.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString1(value, name) {
  if (typeof value !== "string") {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
function validateBoolean1(value, name) {
  if (typeof value !== "boolean") {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
}
hideStackFrames1((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v19) => typeof v19 === "string" ? `'${v19}'` : String(v19)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes1.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback1 = hideStackFrames1((callback) => {
  if (typeof callback !== "function") {
    throw new codes1.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal2 = hideStackFrames1((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction1 = hideStackFrames1((value, name) => {
  if (typeof value !== "function") {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
hideStackFrames1((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes1.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
function guessHandleType1(_fd) {
  notImplemented1("util.guessHandleType");
}
var isNumericLookup1 = {};
function isArrayIndex1(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup1[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup1[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup1[value] = false;
        }
      }
      return isNumericLookup1[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties1(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k15) => !isArrayIndex1(k15));
  }
  if (filter === 0) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & 1 && !desc.writable) {
      continue;
    }
    if (filter & 2 && !desc.enumerable) {
      continue;
    }
    if (filter & 4 && !desc.configurable) {
      continue;
    }
    if (filter & 8 && typeof key2 === "string") {
      continue;
    }
    if (filter & 16 && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}
var mod59 = function() {
  return {
    guessHandleType: guessHandleType1,
    ALL_PROPERTIES: 0,
    ONLY_WRITABLE: 1,
    ONLY_ENUMERABLE: 2,
    ONLY_CONFIGURABLE: 4,
    ONLY_ENUM_WRITABLE: 6,
    SKIP_STRINGS: 8,
    SKIP_SYMBOLS: 16,
    isArrayIndex: isArrayIndex1,
    getOwnNonIndexProperties: getOwnNonIndexProperties1
  };
}();
var kObjectType1 = 0;
var kArrayExtrasType1 = 2;
var kRejected1 = 2;
var meta1 = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject1 = (v19) => typeof v19 === "undefined" && v19 !== void 0;
var strEscapeSequencesRegExp1 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer1 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle1 = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle1 = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp1 = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp1 = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp1 = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp2 = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp1 = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions1 = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions1(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect22(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor1,
    showHidden: inspectDefaultOptions1.showHidden,
    depth: inspectDefaultOptions1.depth,
    colors: inspectDefaultOptions1.colors,
    customInspect: inspectDefaultOptions1.customInspect,
    showProxy: inspectDefaultOptions1.showProxy,
    maxArrayLength: inspectDefaultOptions1.maxArrayLength,
    maxStringLength: inspectDefaultOptions1.maxStringLength,
    breakLength: inspectDefaultOptions1.breakLength,
    compact: inspectDefaultOptions1.compact,
    sorted: inspectDefaultOptions1.sorted,
    getters: inspectDefaultOptions1.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions1.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor1;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue1(ctx, value, 0);
}
var customInspectSymbol2 = Symbol.for("nodejs.util.inspect.custom");
inspect22.custom = customInspectSymbol2;
Object.defineProperty(inspect22, "defaultOptions", {
  get() {
    return inspectDefaultOptions1;
  },
  set(options) {
    validateObject1(options, "options");
    return Object.assign(inspectDefaultOptions1, options);
  }
});
var defaultFG1 = 39;
var defaultBG1 = 49;
inspect22.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [
    0,
    0
  ],
  bold: [
    1,
    22
  ],
  dim: [
    2,
    22
  ],
  italic: [
    3,
    23
  ],
  underline: [
    4,
    24
  ],
  blink: [
    5,
    25
  ],
  inverse: [
    7,
    27
  ],
  hidden: [
    8,
    28
  ],
  strikethrough: [
    9,
    29
  ],
  doubleunderline: [
    21,
    24
  ],
  black: [
    30,
    defaultFG1
  ],
  red: [
    31,
    defaultFG1
  ],
  green: [
    32,
    defaultFG1
  ],
  yellow: [
    33,
    defaultFG1
  ],
  blue: [
    34,
    defaultFG1
  ],
  magenta: [
    35,
    defaultFG1
  ],
  cyan: [
    36,
    defaultFG1
  ],
  white: [
    37,
    defaultFG1
  ],
  bgBlack: [
    40,
    defaultBG1
  ],
  bgRed: [
    41,
    defaultBG1
  ],
  bgGreen: [
    42,
    defaultBG1
  ],
  bgYellow: [
    43,
    defaultBG1
  ],
  bgBlue: [
    44,
    defaultBG1
  ],
  bgMagenta: [
    45,
    defaultBG1
  ],
  bgCyan: [
    46,
    defaultBG1
  ],
  bgWhite: [
    47,
    defaultBG1
  ],
  framed: [
    51,
    54
  ],
  overlined: [
    53,
    55
  ],
  gray: [
    90,
    defaultFG1
  ],
  redBright: [
    91,
    defaultFG1
  ],
  greenBright: [
    92,
    defaultFG1
  ],
  yellowBright: [
    93,
    defaultFG1
  ],
  blueBright: [
    94,
    defaultFG1
  ],
  magentaBright: [
    95,
    defaultFG1
  ],
  cyanBright: [
    96,
    defaultFG1
  ],
  whiteBright: [
    97,
    defaultFG1
  ],
  bgGray: [
    100,
    defaultBG1
  ],
  bgRedBright: [
    101,
    defaultBG1
  ],
  bgGreenBright: [
    102,
    defaultBG1
  ],
  bgYellowBright: [
    103,
    defaultBG1
  ],
  bgBlueBright: [
    104,
    defaultBG1
  ],
  bgMagentaBright: [
    105,
    defaultBG1
  ],
  bgCyanBright: [
    106,
    defaultBG1
  ],
  bgWhiteBright: [
    107,
    defaultBG1
  ]
});
function defineColorAlias1(target, alias) {
  Object.defineProperty(inspect22.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias1("gray", "grey");
defineColorAlias1("gray", "blackBright");
defineColorAlias1("bgGray", "bgGrey");
defineColorAlias1("bgGray", "bgBlackBright");
defineColorAlias1("dim", "faint");
defineColorAlias1("strikethrough", "crossedout");
defineColorAlias1("strikethrough", "strikeThrough");
defineColorAlias1("strikethrough", "crossedOut");
defineColorAlias1("hidden", "conceal");
defineColorAlias1("inverse", "swapColors");
defineColorAlias1("inverse", "swapcolors");
defineColorAlias1("doubleunderline", "doubleUnderline");
inspect22.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes1(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn1 = (str) => meta1[str.charCodeAt(0)];
function strEscape1(str) {
  let escapeTest = strEscapeSequencesRegExp1;
  let escapeReplace = strEscapeSequencesReplacer1;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle1;
      escapeReplace = strEscapeSequencesReplacerSingle1;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes1(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn1);
    return addQuotes1(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta1[point];
      } else {
        result += `${str.slice(last, i)}${meta1[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes1(result, singleQuote);
}
function stylizeWithColor1(str, styleType) {
  const style = inspect22.styles[styleType];
  if (style !== void 0) {
    const color = inspect22.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor1(str) {
  return str;
}
function formatValue1(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject1(value)) {
    return formatPrimitive1(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol2];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect22 && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions1(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue1(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw1(ctx, value, recurseTimes, typedArray);
}
function formatRaw1(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName1(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base2 = "";
  let formatter = getEmptyFormatArray1;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? 0 : 2;
  let extrasType = 0;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix1(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties1(value, filter);
      braces = [
        `${prefix}[`,
        "]"
      ];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType1;
      formatter = formatArray1;
    } else if (isSet3(value)) {
      const size = value.size;
      const prefix1 = getPrefix1(constructor, tag2, "Set", `(${size})`);
      keys = getKeys1(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet1.bind(null, value) : formatSet1.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix1}{}`;
      }
      braces = [
        `${prefix1}{`,
        "}"
      ];
    } else if (isMap3(value)) {
      const size1 = value.size;
      const prefix2 = getPrefix1(constructor, tag2, "Map", `(${size1})`);
      keys = getKeys1(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap1.bind(null, value) : formatMap1.bind(null, value.entries());
      if (size1 === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix2}{}`;
      }
      braces = [
        `${prefix2}{`,
        "}"
      ];
    } else if (isTypedArray1(value)) {
      keys = getOwnNonIndexProperties1(value, filter);
      const bound = value;
      const fallback = "";
      const size2 = value.length;
      const prefix3 = getPrefix1(constructor, tag2, fallback, `(${size2})`);
      braces = [
        `${prefix3}[`,
        "]"
      ];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray1.bind(null, bound, size2);
      extrasType = kArrayExtrasType1;
    } else if (isMapIterator3(value)) {
      keys = getKeys1(value, ctx.showHidden);
      braces = getIteratorBraces1("Map", tag2);
      formatter = formatIterator1.bind(null, braces);
    } else if (isSetIterator3(value)) {
      keys = getKeys1(value, ctx.showHidden);
      braces = getIteratorBraces1("Set", tag2);
      formatter = formatIterator1.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys1(value, ctx.showHidden);
    braces = [
      "{",
      "}"
    ];
    if (constructor === "Object") {
      if (isArgumentsObject3(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix1(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base2 = getFunctionBase1(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "special");
      }
    } else if (isRegExp3(value)) {
      base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix4 = getPrefix1(constructor, tag2, "RegExp");
      if (prefix4 !== "RegExp ") {
        base2 = `${prefix4}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base2, "regexp");
      }
    } else if (isDate3(value)) {
      base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix5 = getPrefix1(constructor, tag2, "Date");
      if (prefix5 !== "Date ") {
        base2 = `${prefix5}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "date");
      }
    } else if (value instanceof Error) {
      base2 = formatError1(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else if (isAnyArrayBuffer3(value)) {
      const arrayType = isArrayBuffer3(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix6 = getPrefix1(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer1;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix6 + `{ byteLength: ${formatNumber1(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix6}{`;
      Array.prototype.unshift(keys, "byteLength");
    } else if (isDataView3(value)) {
      braces[0] = `${getPrefix1(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise3(value)) {
      braces[0] = `${getPrefix1(constructor, tag2, "Promise")}{`;
      formatter = formatPromise1;
    } else if (isWeakSet3(value)) {
      braces[0] = `${getPrefix1(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet1 : formatWeakCollection1;
    } else if (isWeakMap3(value)) {
      braces[0] = `${getPrefix1(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap1 : formatWeakCollection1;
    } else if (isModuleNamespaceObject3(value)) {
      braces[0] = `${getPrefix1(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject1.bind(null, keys);
    } else if (isBoxedPrimitive3(value)) {
      base2 = getBoxedBase1(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle1(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle1(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle1(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty1(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName1 = getCtxStyle1(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize1(ctx, err, constructorName1, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base2 = base2 === "" ? reference : `${reference} ${base2}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === 0) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString1(ctx, output, base2, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects1 = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties1(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects1.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty1(ctx, obj2, recurseTimes, key2, 0, desc, main);
      if (ctx.colors) {
        Array.prototype.push(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push(output, value);
      }
    }
    Array.prototype.pop(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName1(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject1(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof1(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects1.has(descriptor.value.name))) {
        addPrototypeProperties1(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName1(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect22(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive1(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape1(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape1(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber1(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt1(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray1() {
  return [];
}
function isInstanceof1(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix1(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray1(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray1(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty1(ctx, value, recurseTimes, i, 1));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle1(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix1(constructor, tag2, fallback);
}
function getKeys1(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet1(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v19 of value) {
    Array.prototype.push(output, formatValue1(ctx, v19, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap1(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k15, 1: v19 } of value) {
    output.push(`${formatValue1(ctx, k15, recurseTimes)} => ${formatValue1(ctx, v19, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray1(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber1 : formatBigInt1;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue1(ctx, value[key2], recurseTimes, true);
      Array.prototype.push(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces1(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [
    `[${tag2}] {`,
    "}"
  ];
}
function formatIterator1(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner1(ctx, recurseTimes, entries, 2);
  }
  return formatSetIterInner1(ctx, recurseTimes, entries, 1);
}
function getFunctionBase1(value, constructor, tag2) {
  const stringified = Function.prototype.toString(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice6 = stringified.slice(5, -1);
    const bracketIndex = slice6.indexOf("{");
    if (bracketIndex !== -1 && (!slice6.slice(0, bracketIndex).includes("(") || classRegExp2.test(slice6.replace(stripCommentsRegExp1)))) {
      return getClassBase1(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction3(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction3(value)) {
    type = `Async${type}`;
  }
  let base2 = `[${type}`;
  if (constructor === null) {
    base2 += " (null prototype)";
  }
  if (value.name === "") {
    base2 += " (anonymous)";
  } else {
    base2 += `: ${value.name}`;
  }
  base2 += "]";
  if (constructor !== type && constructor !== null) {
    base2 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base2 += ` [${tag2}]`;
  }
  return base2;
}
function formatError1(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name1 of [
      "name",
      "message",
      "stack"
    ]) {
      const index = keys.indexOf(name1);
      if (index !== -1 && stack.includes(err[name1])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix1(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos1 = 0;
      while (nodeModule = nodeModulesRegExp1.exec(line)) {
        newStack += line.slice(pos1, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos1 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos1 === 0 ? line : line.slice(pos1);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice1;
function formatArrayBuffer1(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [
      ctx.stylize("(detached)", "special")
    ];
  }
  let str = hexSlice1(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [
    `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
  ];
}
function formatNumber1(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise1(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === 0) {
    output = [
      ctx.stylize("<pending>", "special")
    ];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue1(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected1 ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection1(ctx) {
  return [
    ctx.stylize("<items unknown>", "special")
  ];
}
function formatWeakSet1(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner1(ctx, recurseTimes, entries, 0);
}
function formatWeakMap1(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner1(ctx, recurseTimes, entries, 0);
}
function formatProperty1(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || {
    value: value[key2],
    enumerable: true
  };
  if (desc.value !== void 0) {
    const diff2 = ctx.compact !== true || type !== 0 ? 2 : 3;
    ctx.indentationLvl += diff2;
    str = formatValue1(ctx, desc.value, recurseTimes);
    if (diff2 === 3 && ctx.breakLength < getStringWidth1(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff2;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s10 = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s10(`[${label}:`, sp)} ${s10("null", "null")}${s10("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s10(`[${label}]`, sp)} ${formatValue1(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive1(s10, tmp, ctx);
          str = `${s10(`[${label}:`, sp)} ${primitive}${s10("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s10(`[${label}:`, sp)} ${message}${s10("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === 1) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp1 = key2.toString().replace(strEscapeSequencesReplacer1, escapeFn1);
    name = `[${ctx.stylize(tmp1, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp2 = key2.replace(strEscapeSequencesReplacer1, escapeFn1);
    name = `[${tmp2}]`;
  } else if (keyStrRegExp1.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape1(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize1(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp1 = /\u001b\[\d\d?m/g;
function removeColors1(str) {
  return str.replace(colorRegExp1, "");
}
function isBelowBreakLength1(ctx, output, start, base2) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors1(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base2 === "" || !base2.includes("\n");
}
function formatBigInt1(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject1(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty1(ctx, value, recurseTimes, keys[i], kObjectType1);
    } catch (_err) {
      const tmp = {
        [keys[i]]: ""
      };
      output[i] = formatProperty1(ctx, tmp, recurseTimes, keys[i], kObjectType1);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray1(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp1.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty1(ctx, value, recurseTimes, key2, 1));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending1 = remaining > 1 ? "s" : "";
      const message1 = `<${remaining} empty item${ending1}>`;
      output.push(ctx.stylize(message1, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase1(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject3(value)) {
    type = "Number";
  } else if (isStringObject3(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject3(value)) {
    type = "Boolean";
  } else if (isBigIntObject3(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base2 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base2 += " (null prototype)";
    } else {
      base2 += ` (${constructor})`;
    }
  }
  base2 += `: ${formatPrimitive1(stylizeNoColor1, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base2 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor1) {
    return base2;
  }
  return ctx.stylize(base2, type.toLowerCase());
}
function getClassBase1(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base2 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base2 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base2 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base2 += ` extends ${superName}`;
    }
  } else {
    base2 += " extends [null prototype]";
  }
  return `[${base2}]`;
}
function reduceToSingleString1(ctx, output, base2, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === 2 && entries > 6) {
        output = groupArrayElements1(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base2.length + 10;
        if (isBelowBreakLength1(ctx, output, start, base2)) {
          return `${base2 ? `${base2} ` : ""}${braces[0]} ${join5(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base2 ? `${base2} ` : ""}${braces[0]}${indentation}  ${join5(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  }
  if (isBelowBreakLength1(ctx, output, 0, base2)) {
    return `${braces[0]}${base2 ? ` ${base2}` : ""} ${join5(output, ", ")} ` + braces[1];
  }
  const indentation1 = " ".repeat(ctx.indentationLvl);
  const ln = base2 === "" && braces[0].length === 1 ? " " : `${base2 ? ` ${base2}` : ""}
${indentation1}  `;
  return `${braces[0]}${ln}${join5(output, `,
${indentation1}  `)} ${braces[1]}`;
}
function join5(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements1(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth1(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + 2;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i12 = 0; i12 < columns; i12++) {
      let lineMaxLength = 0;
      for (let j13 = i12; j13 < output.length; j13 += columns) {
        if (dataLen[j13] > lineMaxLength) {
          lineMaxLength = dataLen[j13];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i12] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i22 = 0; i22 < output.length; i22++) {
        if (typeof value[i22] !== "number" && typeof value[i22] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i32 = 0; i32 < outputLength; i32 += columns) {
      const max2 = Math.min(i32 + columns, outputLength);
      let str = "";
      let j13 = i32;
      for (; j13 < max2 - 1; j13++) {
        const padding = maxLineLength[j13 - i32] + output[j13].length - dataLen[j13];
        str += `${output[j13]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding1 = maxLineLength[j13 - i32] + output[j13].length - dataLen[j13] - 2;
        str += output[j13].padStart(padding1, " ");
      } else {
        str += output[j13];
      }
      Array.prototype.push(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner1(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === 0) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue1(ctx, entries[pos], recurseTimes)} => ${formatValue1(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos1 = i * 2;
      const res = [
        formatValue1(ctx, entries[pos1], recurseTimes),
        formatValue1(ctx, entries[pos1 + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString1(ctx, res, "", [
        "[",
        "]"
      ], kArrayExtrasType1, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner1(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue1(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === 0 && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern1 = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi1 = new RegExp(ansiPattern1, "g");
function getStringWidth1(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters1(str);
  }
  str = str.normalize("NFC");
  for (const __char of str[Symbol.iterator]()) {
    const code2 = __char.codePointAt(0);
    if (isFullWidthCodePoint1(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint1(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint1 = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint1 = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function hasBuiltInToString(value) {
  const proxyTarget = void 0;
  if (proxyTarget !== void 0) {
    value = proxyTarget;
  }
  if (typeof value.toString !== "function") {
    return true;
  }
  if (Object.prototype.hasOwnProperty.call(value, "toString")) {
    return false;
  }
  let pointer = value;
  do {
    pointer = Object.getPrototypeOf(pointer);
  } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
  const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
  return descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects1.has(descriptor.value.name);
}
var firstErrorLine = (error2) => error2.message.split("\n", 1)[0];
var CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a7 = {};
        a7.a = a7;
        JSON.stringify(a7);
      } catch (circularError) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
      }
    }
    if (err.name === "TypeError" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return "[Circular]";
    }
    throw err;
  }
}
function format4(...args) {
  return formatWithOptionsInternal(void 0, args);
}
function formatWithOptions(inspectOptions, ...args) {
  if (typeof inspectOptions !== "object" || inspectOptions === null) {
    throw new codes1.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
  }
  return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
  return formatNumber1(stylizeNoColor1, number, options?.numericSeparator ?? inspectDefaultOptions1.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
  return formatBigInt1(stylizeNoColor1, bigint, options?.numericSeparator ?? inspectDefaultOptions1.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
  const first = args[0];
  let a7 = 0;
  let str = "";
  let join15 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a7 + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              const tempArg = args[++a7];
              if (typeof tempArg === "number") {
                tempStr = formatNumberNoColor(tempArg, inspectOptions);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
              } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect22(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            case 106:
              tempStr = tryStringify(args[++a7]);
              break;
            case 100:
              const tempNum = args[++a7];
              if (typeof tempNum === "bigint") {
                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
              }
              break;
            case 79:
              tempStr = inspect22(args[++a7], inspectOptions);
              break;
            case 111:
              tempStr = inspect22(args[++a7], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105:
              const tempInteger = args[++a7];
              if (typeof tempInteger === "bigint") {
                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
              }
              break;
            case 102:
              const tempFloat = args[++a7];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
              }
              break;
            case 99:
              a7 += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a7++;
      join15 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a7 < args.length) {
    const value = args[a7];
    str += join15;
    str += typeof value !== "string" ? inspect22(value, inspectOptions) : value;
    join15 = " ";
    a7++;
  }
  return str;
}
function stripVTControlCharacters1(str) {
  validateString1(str, "str");
  return str.replace(ansi1, "");
}
Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty1 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty1.enumerable = true;
function once22(callback) {
  let called = false;
  return function(...args) {
    if (called)
      return;
    called = true;
    Reflect.apply(callback, this, args);
  };
}
function createDeferredPromise1() {
  let resolve9;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve9 = res;
    reject = rej;
  });
  return {
    promise,
    resolve: resolve9,
    reject
  };
}
var codesWarned = /* @__PURE__ */ new Set();
function deprecate(fn, msg, code2) {
  if (code2 !== void 0) {
    validateString1(code2, "code");
  }
  let warned = false;
  function deprecated(...args) {
    if (!warned) {
      warned = true;
      if (code2 !== void 0) {
        if (!codesWarned.has(code2)) {
          process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
          codesWarned.add(code2);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args, new.target);
    }
    return Reflect.apply(fn, this, args);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol1 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol1 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify1(original) {
  validateFunction1(original, "original");
  if (original[kCustomPromisifiedSymbol1]) {
    const fn = original[kCustomPromisifiedSymbol1];
    validateFunction1(fn, "util.promisify.custom");
    return Object.defineProperty(fn, kCustomPromisifiedSymbol1, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol1];
  function fn1(...args) {
    return new Promise((resolve9, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve9(obj2);
        } else {
          resolve9(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
  Object.defineProperty(fn1, kCustomPromisifiedSymbol1, {
    value: fn1,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify1.custom = kCustomPromisifiedSymbol1;
var core1;
if (Deno?.core) {
  core1 = Deno.core;
} else {
  core1 = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}
var _exiting1 = false;
var kSize1 = 2048;
var kMask1 = 2048 - 1;
var FixedCircularBuffer1 = class {
  bottom;
  top;
  list;
  next;
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize1);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask1) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask1;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask1;
    return nextItem;
  }
};
var FixedQueue1 = class {
  head;
  tail;
  constructor() {
    this.head = this.tail = new FixedCircularBuffer1();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer1();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};
var queue1 = new FixedQueue1();
var _nextTick1;
if (typeof core1.setNextTickCallback !== "undefined") {
  let runNextTicks1 = function() {
    if (!core1.hasTickScheduled()) {
      core1.runMicrotasks();
    }
    if (!core1.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections1();
    return true;
  }, processTicksAndRejections1 = function() {
    let tock;
    do {
      while (tock = queue1.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core1.runMicrotasks();
    } while (!queue1.isEmpty());
    core1.setHasTickScheduled(false);
  }, __nextTickNative1 = function(callback, ...args) {
    validateCallback1(callback);
    if (_exiting1) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [
          args[0]
        ];
        break;
      case 2:
        args_ = [
          args[0],
          args[1]
        ];
        break;
      case 3:
        args_ = [
          args[0],
          args[1],
          args[2]
        ];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue1.isEmpty()) {
      core1.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue1.push(tickObject);
  };
  runNextTicks12 = runNextTicks1, processTicksAndRejections12 = processTicksAndRejections1, __nextTickNative12 = __nextTickNative1;
  core1.setNextTickCallback(processTicksAndRejections1);
  core1.setMacrotaskCallback(runNextTicks1);
  _nextTick1 = __nextTickNative1;
} else {
  let __nextTickQueueMicrotask1 = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  __nextTickQueueMicrotask12 = __nextTickQueueMicrotask1;
  _nextTick1 = __nextTickQueueMicrotask1;
}
var runNextTicks12;
var processTicksAndRejections12;
var __nextTickNative12;
var __nextTickQueueMicrotask12;
function nextTick3(callback, ...args) {
  _nextTick1(callback, ...args);
}
var NodeFalsyValueRejectionError = class extends Error {
  reason;
  code = "ERR_FALSY_VALUE_REJECTION";
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError = class extends TypeError {
  code = "ERR_INVALID_ARG_TYPE";
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
  }
};
function callbackify(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError('"original"');
  }
  const callbackified = function(...args) {
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError("last");
    }
    const cb = (...args2) => {
      maybeCb.apply(this, args2);
    };
    original.apply(this, args).then((ret) => {
      nextTick3(cb.bind(this, null, ret));
    }, (rej) => {
      rej = rej || new NodeFalsyValueRejectionError(rej);
      nextTick3(cb.bind(this, rej));
    });
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}
var State1;
(function(State3) {
  State3[State3["PASSTHROUGH"] = 0] = "PASSTHROUGH";
  State3[State3["PERCENT"] = 1] = "PERCENT";
  State3[State3["POSITIONAL"] = 2] = "POSITIONAL";
  State3[State3["PRECISION"] = 3] = "PRECISION";
  State3[State3["WIDTH"] = 4] = "WIDTH";
})(State1 || (State1 = {}));
var WorP1;
(function(WorP3) {
  WorP3[WorP3["WIDTH"] = 0] = "WIDTH";
  WorP3[WorP3["PRECISION"] = 1] = "PRECISION";
})(WorP1 || (WorP1 = {}));
var Flags1 = class {
  plus;
  dash;
  sharp;
  space;
  zero;
  lessthan;
  width = -1;
  precision = -1;
};
var min1 = Math.min;
var UNICODE_REPLACEMENT_CHARACTER1 = "\uFFFD";
var FLOAT_REGEXP1 = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F1;
(function(F12) {
  F12[F12["sign"] = 1] = "sign";
  F12[F12["mantissa"] = 2] = "mantissa";
  F12[F12["fractional"] = 3] = "fractional";
  F12[F12["esign"] = 4] = "esign";
  F12[F12["exponent"] = 5] = "exponent";
})(F1 || (F1 = {}));
var Printf1 = class {
  format;
  args;
  i;
  state = State1.PASSTHROUGH;
  verb = "";
  buf = "";
  argNum = 0;
  flags = new Flags1();
  haveSeen;
  tmpError;
  constructor(format12, ...args) {
    this.format = format12;
    this.args = args;
    this.haveSeen = Array.from({
      length: args.length
    });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c13 = this.format[this.i];
      switch (this.state) {
        case State1.PASSTHROUGH:
          if (c13 === "%") {
            this.state = State1.PERCENT;
          } else {
            this.buf += c13;
          }
          break;
        case State1.PERCENT:
          if (c13 === "%") {
            this.buf += c13;
            this.state = State1.PASSTHROUGH;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags1();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c13 = this.format[this.i];
      switch (this.state) {
        case State1.PERCENT:
          switch (c13) {
            case "[":
              this.handlePositional();
              this.state = State1.POSITIONAL;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c13 && c13 <= "9" || c13 === "." || c13 === "*") {
                if (c13 === ".") {
                  this.flags.precision = 0;
                  this.state = State1.PRECISION;
                  this.i++;
                } else {
                  this.state = State1.WIDTH;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case State1.POSITIONAL:
          if (c13 === "*") {
            const worp = this.flags.precision === -1 ? WorP1.WIDTH : WorP1.PRECISION;
            this.handleWidthOrPrecisionRef(worp);
            this.state = State1.PERCENT;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case WorP1.WIDTH:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === WorP1.WIDTH ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c13 = fmt[this.i];
      switch (this.state) {
        case State1.WIDTH:
          switch (c13) {
            case ".":
              this.flags.precision = 0;
              this.state = State1.PRECISION;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(WorP1.WIDTH);
              break;
            default: {
              const val = parseInt(c13);
              if (isNaN(val)) {
                this.i--;
                this.state = State1.PERCENT;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case State1.PRECISION: {
          if (c13 === "*") {
            this.handleWidthOrPrecisionRef(WorP1.PRECISION);
            break;
          }
          const val1 = parseInt(c13);
          if (isNaN(val1)) {
            this.i--;
            this.state = State1.PERCENT;
            return;
          }
          flags.precision *= 10;
          flags.precision += val1;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format12 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format12[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format12[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = State1.PASSTHROUGH;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s10) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s10.padEnd(this.flags.width, padding);
    }
    return s10.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign2;
    if (neg3) {
      sign2 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign2 = this.flags.plus ? "+" : " ";
    } else {
      sign2 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign2 + nStr;
    }
    const pad2 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign2.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad2);
    } else {
      nStr = nStr.padStart(len, pad2);
    }
    if (zero) {
      nStr = sign2 + nStr;
    }
    return nStr;
  }
  fmtNumber(n3, radix, upcase = false) {
    let num = Math.abs(n3).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n3 === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n3 < 0);
  }
  fmtNumberCodePoint(n3) {
    let s10 = "";
    try {
      s10 = String.fromCodePoint(n3);
    } catch {
      s10 = UNICODE_REPLACEMENT_CHARACTER1;
    }
    return this.pad(s10);
  }
  fmtFloatSpecial(n3) {
    if (isNaN(n3)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n3 === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n3 === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [
      fractional,
      round
    ];
  }
  fmtFloatE(n3, upcase = false) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    const m20 = n3.toExponential().match(FLOAT_REGEXP1);
    if (!m20) {
      throw Error("can't happen, bug");
    }
    let fractional = m20[F1.fractional];
    const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m20[F1.exponent];
    let esign = m20[F1.esign];
    let mantissa = parseInt(m20[F1.mantissa]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r2 = parseInt(esign + e) + 1;
        e = r2.toString();
        esign = r2 < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n3 < 0);
  }
  fmtFloatF(n3) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    function expandNumber(n4) {
      if (Number.isSafeInteger(n4)) {
        return n4.toString() + ".";
      }
      const t2 = n4.toExponential().split("e");
      let m20 = t2[0].replace(".", "");
      const e = parseInt(t2[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m20;
      } else {
        const splIdx = e + 1;
        while (m20.length < splIdx) {
          m20 += "0";
        }
        return m20.substr(0, splIdx) + "." + m20.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n3));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n3 < 0);
  }
  fmtFloatG(n3, upcase = false) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    let P13 = this.flags.precision !== -1 ? this.flags.precision : 6;
    P13 = P13 === 0 ? 1 : P13;
    const m20 = n3.toExponential().match(FLOAT_REGEXP1);
    if (!m20) {
      throw Error("can't happen");
    }
    const X5 = parseInt(m20[F1.exponent]) * (m20[F1.esign] === "-" ? -1 : 1);
    let nStr = "";
    if (P13 > X5 && X5 >= -4) {
      this.flags.precision = P13 - (X5 + 1);
      nStr = this.fmtFloatF(n3);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P13 - 1;
      nStr = this.fmtFloatE(n3);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s10) {
    if (this.flags.precision !== -1) {
      s10 = s10.substr(0, this.flags.precision);
    }
    return this.pad(s10);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min1(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c13 = (val.charCodeAt(i) & 255).toString(16);
          hex += c13.length === 1 ? `0${c13}` : c13;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? {
        depth: this.flags.precision
      } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p7 = this.flags.precision;
      return p7 === -1 ? val.toString() : val.toString().substr(0, p7);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf1(format12, ...args) {
  const printf = new Printf1(format12, ...args);
  return printf.doPrintf();
}
var debugImpls1;
var testEnabled1;
function initializeDebugEnv1(debugEnv3) {
  debugImpls1 = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled1 = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled1 = () => false;
  }
}
function emitWarningIfNeeded1(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop1 = () => {
};
function debuglogImpl1(enabled2, set) {
  if (debugImpls1[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded1(set);
      debugImpls1[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect22(arg)).join(" ");
        console.error(sprintf1("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls1[set] = noop1;
    }
  }
  return debugImpls1[set];
}
function debuglog1(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled1(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl1(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv1;
try {
  debugEnv1 = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error1) {
  if (error1 instanceof Deno.errors.PermissionDenied) {
    debugEnv1 = "";
  } else {
    throw error1;
  }
}
initializeDebugEnv1(debugEnv1);
var osType1 = (() => {
  const { Deno: Deno12 } = globalThis;
  if (typeof Deno12?.build?.os === "string") {
    return Deno12.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows1 = osType1 === "windows";
var isLinux1 = osType1 === "linux";
function uvTranslateSysError1(sysErrno) {
  switch (sysErrno) {
    case 5:
      return "EACCES";
    case 998:
      return "EACCES";
    case 10013:
      return "EACCES";
    case 1920:
      return "EACCES";
    case 1227:
      return "EADDRINUSE";
    case 10048:
      return "EADDRINUSE";
    case 10049:
      return "EADDRNOTAVAIL";
    case 10047:
      return "EAFNOSUPPORT";
    case 10035:
      return "EAGAIN";
    case 10037:
      return "EALREADY";
    case 1004:
      return "EBADF";
    case 6:
      return "EBADF";
    case 33:
      return "EBUSY";
    case 231:
      return "EBUSY";
    case 32:
      return "EBUSY";
    case 995:
      return "ECANCELED";
    case 10004:
      return "ECANCELED";
    case 1113:
      return "ECHARSET";
    case 1236:
      return "ECONNABORTED";
    case 10053:
      return "ECONNABORTED";
    case 1225:
      return "ECONNREFUSED";
    case 10061:
      return "ECONNREFUSED";
    case 64:
      return "ECONNRESET";
    case 10054:
      return "ECONNRESET";
    case 183:
      return "EEXIST";
    case 80:
      return "EEXIST";
    case 111:
      return "EFAULT";
    case 10014:
      return "EFAULT";
    case 1232:
      return "EHOSTUNREACH";
    case 10065:
      return "EHOSTUNREACH";
    case 122:
      return "EINVAL";
    case 13:
      return "EINVAL";
    case 123:
      return "EINVAL";
    case 87:
      return "EINVAL";
    case 10022:
      return "EINVAL";
    case 10046:
      return "EINVAL";
    case 1102:
      return "EIO";
    case 1111:
      return "EIO";
    case 23:
      return "EIO";
    case 1166:
      return "EIO";
    case 1165:
      return "EIO";
    case 1393:
      return "EIO";
    case 1129:
      return "EIO";
    case 1101:
      return "EIO";
    case 31:
      return "EIO";
    case 1106:
      return "EIO";
    case 1117:
      return "EIO";
    case 1104:
      return "EIO";
    case 205:
      return "EIO";
    case 110:
      return "EIO";
    case 1103:
      return "EIO";
    case 156:
      return "EIO";
    case 10056:
      return "EISCONN";
    case 1921:
      return "ELOOP";
    case 4:
      return "EMFILE";
    case 10024:
      return "EMFILE";
    case 10040:
      return "EMSGSIZE";
    case 206:
      return "ENAMETOOLONG";
    case 1231:
      return "ENETUNREACH";
    case 10051:
      return "ENETUNREACH";
    case 10055:
      return "ENOBUFS";
    case 161:
      return "ENOENT";
    case 267:
      return "ENOTDIR";
    case 203:
      return "ENOENT";
    case 2:
      return "ENOENT";
    case 15:
      return "ENOENT";
    case 4392:
      return "ENOENT";
    case 126:
      return "ENOENT";
    case 3:
      return "ENOENT";
    case 11001:
      return "ENOENT";
    case 11004:
      return "ENOENT";
    case 8:
      return "ENOMEM";
    case 14:
      return "ENOMEM";
    case 82:
      return "ENOSPC";
    case 112:
      return "ENOSPC";
    case 277:
      return "ENOSPC";
    case 1100:
      return "ENOSPC";
    case 39:
      return "ENOSPC";
    case 2250:
      return "ENOTCONN";
    case 10057:
      return "ENOTCONN";
    case 145:
      return "ENOTEMPTY";
    case 10038:
      return "ENOTSOCK";
    case 50:
      return "ENOTSUP";
    case 109:
      return "EOF";
    case 1314:
      return "EPERM";
    case 230:
      return "EPIPE";
    case 232:
      return "EPIPE";
    case 233:
      return "EPIPE";
    case 10058:
      return "EPIPE";
    case 10043:
      return "EPROTONOSUPPORT";
    case 19:
      return "EROFS";
    case 121:
      return "ETIMEDOUT";
    case 10060:
      return "ETIMEDOUT";
    case 17:
      return "EXDEV";
    case 1:
      return "EISDIR";
    case 208:
      return "E2BIG";
    case 10044:
      return "ESOCKTNOSUPPORT";
    default:
      return "UNKNOWN";
  }
}
var os1 = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
var fs1 = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};
var crypto2 = {
  OPENSSL_VERSION_NUMBER: 269488319,
  SSL_OP_ALL: 2147485780,
  SSL_OP_ALLOW_NO_DHE_KEX: 1024,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
  SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
  SSL_OP_CISCO_ANYCONNECT: 32768,
  SSL_OP_COOKIE_EXCHANGE: 8192,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
  SSL_OP_EPHEMERAL_RSA: 0,
  SSL_OP_LEGACY_SERVER_CONNECT: 4,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
  SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
  SSL_OP_NETSCAPE_CA_DN_BUG: 0,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NO_COMPRESSION: 131072,
  SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
  SSL_OP_NO_QUERY_MTU: 4096,
  SSL_OP_NO_RENEGOTIATION: 1073741824,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
  SSL_OP_NO_SSLv2: 0,
  SSL_OP_NO_SSLv3: 33554432,
  SSL_OP_NO_TICKET: 16384,
  SSL_OP_NO_TLSv1: 67108864,
  SSL_OP_NO_TLSv1_1: 268435456,
  SSL_OP_NO_TLSv1_2: 134217728,
  SSL_OP_NO_TLSv1_3: 536870912,
  SSL_OP_PKCS1_CHECK_1: 0,
  SSL_OP_PKCS1_CHECK_2: 0,
  SSL_OP_PRIORITIZE_CHACHA: 2097152,
  SSL_OP_SINGLE_DH_USE: 0,
  SSL_OP_SINGLE_ECDH_USE: 0,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
  SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
  SSL_OP_TLS_D5_BUG: 0,
  SSL_OP_TLS_ROLLBACK_BUG: 8388608,
  ENGINE_METHOD_RSA: 1,
  ENGINE_METHOD_DSA: 2,
  ENGINE_METHOD_DH: 4,
  ENGINE_METHOD_RAND: 8,
  ENGINE_METHOD_EC: 2048,
  ENGINE_METHOD_CIPHERS: 64,
  ENGINE_METHOD_DIGESTS: 128,
  ENGINE_METHOD_PKEY_METHS: 512,
  ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
  ENGINE_METHOD_ALL: 65535,
  ENGINE_METHOD_NONE: 0,
  DH_CHECK_P_NOT_SAFE_PRIME: 2,
  DH_CHECK_P_NOT_PRIME: 1,
  DH_UNABLE_TO_CHECK_GENERATOR: 4,
  DH_NOT_SUITABLE_GENERATOR: 8,
  ALPN_ENABLED: 1,
  RSA_PKCS1_PADDING: 1,
  RSA_SSLV23_PADDING: 2,
  RSA_NO_PADDING: 3,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_X931_PADDING: 5,
  RSA_PKCS1_PSS_PADDING: 6,
  RSA_PSS_SALTLEN_DIGEST: -1,
  RSA_PSS_SALTLEN_MAX_SIGN: -2,
  RSA_PSS_SALTLEN_AUTO: -2,
  defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
  TLS1_VERSION: 769,
  TLS1_1_VERSION: 770,
  TLS1_2_VERSION: 771,
  TLS1_3_VERSION: 772,
  POINT_CONVERSION_COMPRESSED: 2,
  POINT_CONVERSION_UNCOMPRESSED: 4,
  POINT_CONVERSION_HYBRID: 6
};
var zlib1 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
var trace1 = {
  TRACE_EVENT_PHASE_BEGIN: 66,
  TRACE_EVENT_PHASE_END: 69,
  TRACE_EVENT_PHASE_COMPLETE: 88,
  TRACE_EVENT_PHASE_INSTANT: 73,
  TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
  TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
  TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
  TRACE_EVENT_PHASE_ASYNC_END: 70,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
  TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
  TRACE_EVENT_PHASE_FLOW_STEP: 116,
  TRACE_EVENT_PHASE_FLOW_END: 102,
  TRACE_EVENT_PHASE_METADATA: 77,
  TRACE_EVENT_PHASE_COUNTER: 67,
  TRACE_EVENT_PHASE_SAMPLE: 80,
  TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
  TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
  TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
  TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
  TRACE_EVENT_PHASE_MARK: 82,
  TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
  TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
  TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
  TRACE_EVENT_PHASE_LINK_IDS: 61
};
var mod60 = {
  os: os1,
  fs: fs1,
  crypto: crypto2,
  zlib: zlib1,
  trace: trace1
};
var UV_EEXIST1 = os1.errno.EEXIST;
var UV_ENOENT1 = os1.errno.ENOENT;
var codeToErrorWindows1 = [
  [
    -4093,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -4092,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -4091,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -4090,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -4089,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -4088,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -4084,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -4083,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -4082,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -4081,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -4079,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -4078,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -4077,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -4076,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -4075,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -4074,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -4036,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -4073,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4072,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -4071,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -4070,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -4069,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -4068,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -4067,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -4066,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -4065,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -4064,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -4063,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -4062,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -4061,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -4060,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -4059,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -4058,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -4057,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -4056,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -4035,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -4055,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -4054,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -4053,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -4052,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -4051,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -4050,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -4049,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -4048,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -4047,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -4046,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -4045,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -4044,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -4034,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -4043,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -4042,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -4041,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -4040,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -4039,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -4038,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -4037,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -4033,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -4032,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -4031,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -4030,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -4029,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -4028,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -4027,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeWindows1 = codeToErrorWindows1.map(([status, [error2]]) => [
  error2,
  status
]);
var codeToErrorDarwin1 = [
  [
    -7,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -13,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -48,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -49,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -47,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -35,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -37,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -9,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -16,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -89,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -53,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -61,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -54,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -39,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -17,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -14,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -27,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -65,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -22,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -5,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -56,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -21,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -62,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -24,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -40,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -63,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -50,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -51,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -23,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -55,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -19,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -2,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -12,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -4056,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -42,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -28,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -78,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -57,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -20,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -66,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -38,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -45,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -1,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -32,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -100,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -43,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -41,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -34,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -30,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -58,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -29,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -3,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -60,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -26,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -18,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -6,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -31,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -64,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -4030,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -25,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -79,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -92,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeDarwin1 = codeToErrorDarwin1.map(([status, [code2]]) => [
  code2,
  status
]);
var codeToErrorLinux1 = [
  [
    -7,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -13,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -98,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -99,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -97,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -11,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -114,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -9,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -16,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -125,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -103,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -111,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -104,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -89,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -17,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -14,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -27,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -113,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -22,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -5,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -106,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -21,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -40,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -24,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -90,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -36,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -100,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -101,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -23,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -105,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -19,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -2,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -12,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -64,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -92,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -28,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -38,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -107,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -20,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -39,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -88,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -95,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -1,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -32,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -71,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -93,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -91,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -34,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -30,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -108,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -29,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -3,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -110,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -26,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -18,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -6,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -31,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -112,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -121,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -25,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -4028,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -84,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeLinux1 = codeToErrorLinux1.map(([status, [code2]]) => [
  code2,
  status
]);
var errorMap1 = new Map(osType1 === "windows" ? codeToErrorWindows1 : osType1 === "darwin" ? codeToErrorDarwin1 : osType1 === "linux" ? codeToErrorLinux1 : unreachable1());
var codeMap1 = new Map(osType1 === "windows" ? errorToCodeWindows1 : osType1 === "darwin" ? errorToCodeDarwin1 : osType1 === "linux" ? errorToCodeLinux1 : unreachable1());
function mapSysErrnoToUvErrno1(sysErrno) {
  if (osType1 === "windows") {
    const code2 = uvTranslateSysError1(sysErrno);
    return codeMap1.get(code2) ?? -sysErrno;
  } else {
    return -sysErrno;
  }
}
var UV_EAI_MEMORY1 = codeMap1.get("EAI_MEMORY");
var UV_UNKNOWN1 = codeMap1.get("UNKNOWN");
var UV_EBADF1 = codeMap1.get("EBADF");
var UV_EINVAL1 = codeMap1.get("EINVAL");
var UV_ENOTSOCK1 = codeMap1.get("ENOTSOCK");
var mod61 = {
  UV_EEXIST: UV_EEXIST1,
  UV_ENOENT: UV_ENOENT1,
  errorMap: errorMap1,
  codeMap: codeMap1,
  mapSysErrnoToUvErrno: mapSysErrnoToUvErrno1,
  UV_EAI_MEMORY: UV_EAI_MEMORY1,
  UV_UNKNOWN: UV_UNKNOWN1,
  UV_EBADF: UV_EBADF1,
  UV_EINVAL: UV_EINVAL1,
  UV_ENOTSOCK: UV_ENOTSOCK1
};
var __default11 = {
  ...mod58
};
var Encodings1;
(function(Encodings4) {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
})(Encodings1 || (Encodings1 = {}));
var encodings1 = [];
encodings1[Encodings1.ASCII] = "ascii";
encodings1[Encodings1.BASE64] = "base64";
encodings1[Encodings1.BASE64URL] = "base64url";
encodings1[Encodings1.BUFFER] = "buffer";
encodings1[Encodings1.HEX] = "hex";
encodings1[Encodings1.LATIN1] = "latin1";
encodings1[Encodings1.UCS2] = "utf16le";
encodings1[Encodings1.UTF8] = "utf8";
var __default12 = {
  encodings: encodings1
};
var mod62 = {
  encodings: encodings1,
  default: __default12
};
function indexOfNeedle1(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s10 = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s10)
      continue;
    const pin = i;
    let matched = 1;
    let j13 = i;
    while (matched < needle.length) {
      j13++;
      if (source[j13] !== needle[j13 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}
function numberToBytes1(n3) {
  if (n3 === 0)
    return new Uint8Array([
      0
    ]);
  const bytes = [];
  bytes.unshift(n3 & 255);
  while (n3 >= 256) {
    n3 = n3 >>> 8;
    bytes.unshift(n3 & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex1(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x17 = 0; x17 <= searchableBufferLastIndex; x17++) {
    if (searchableBuffer[searchableBufferLastIndex - x17] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x17;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x17 = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x17;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer1(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings1[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex1(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle1(targetBuffer, buffer, byteOffset);
}
function indexOfNumber1(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes1(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer1(targetBuffer, numberToBytes1(number), byteOffset, Encodings1.UTF8, forwardDirection);
}
var __default13 = {
  indexOfBuffer: indexOfBuffer1,
  indexOfNumber: indexOfNumber1
};
var mod63 = {
  indexOfBuffer: indexOfBuffer1,
  indexOfNumber: indexOfNumber1,
  numberToBytes: numberToBytes1,
  default: __default13
};
var base64abc1 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode32(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l22 = uint8.length;
  for (i = 2; i < l22; i += 3) {
    result += base64abc1[uint8[i - 2] >> 2];
    result += base64abc1[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc1[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc1[uint8[i] & 63];
  }
  if (i === l22 + 1) {
    result += base64abc1[uint8[i - 2] >> 2];
    result += base64abc1[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l22) {
    result += base64abc1[uint8[i - 2] >> 2];
    result += base64abc1[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc1[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode22(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
function addPaddingToBase64url1(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase641(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url1(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url1(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode42(data) {
  return convertBase64ToBase64url1(encode32(data));
}
function decode32(b64url) {
  return decode22(convertBase64urlToBase641(b64url));
}
function asciiToBytes1(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes1(str) {
  str = base64clean1(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode22(str);
}
var INVALID_BASE64_RE1 = /[^+/0-9A-Za-z-_]/g;
function base64clean1(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE1, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes1(str) {
  str = base64clean1(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode32(str);
}
function hexToBytes1(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a7 = Number.parseInt(str[i * 2], 16);
    const b15 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a7) && Number.isNaN(b15)) {
      break;
    }
    byteArray[i] = a7 << 4 | b15;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes1(str, units) {
  let c13, hi, lo;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c13 = str.charCodeAt(i);
    hi = c13 >> 8;
    lo = c13 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii1(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le1(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
var utf8Encoder1 = new TextEncoder();
var float32Array1 = new Float32Array(1);
var uInt8Float32Array1 = new Uint8Array(float32Array1.buffer);
var float64Array1 = new Float64Array(1);
var uInt8Float64Array1 = new Uint8Array(float64Array1.buffer);
float32Array1[0] = -1;
var bigEndian1 = uInt8Float32Array1[3] === 0;
function readUInt48LE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE1(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE1(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards1(buffer, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buffer.length - 8);
  }
  uInt8Float64Array1[7] = first;
  uInt8Float64Array1[6] = buffer[++offset];
  uInt8Float64Array1[5] = buffer[++offset];
  uInt8Float64Array1[4] = buffer[++offset];
  uInt8Float64Array1[3] = buffer[++offset];
  uInt8Float64Array1[2] = buffer[++offset];
  uInt8Float64Array1[1] = buffer[++offset];
  uInt8Float64Array1[0] = last;
  return float64Array1[0];
}
function readDoubleForwards1(buffer, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buffer.length - 8);
  }
  uInt8Float64Array1[0] = first;
  uInt8Float64Array1[1] = buffer[++offset];
  uInt8Float64Array1[2] = buffer[++offset];
  uInt8Float64Array1[3] = buffer[++offset];
  uInt8Float64Array1[4] = buffer[++offset];
  uInt8Float64Array1[5] = buffer[++offset];
  uInt8Float64Array1[6] = buffer[++offset];
  uInt8Float64Array1[7] = last;
  return float64Array1[0];
}
function writeDoubleForwards1(buffer, val, offset = 0) {
  val = +val;
  checkBounds2(buffer, offset, 7);
  float64Array1[0] = val;
  buffer[offset++] = uInt8Float64Array1[0];
  buffer[offset++] = uInt8Float64Array1[1];
  buffer[offset++] = uInt8Float64Array1[2];
  buffer[offset++] = uInt8Float64Array1[3];
  buffer[offset++] = uInt8Float64Array1[4];
  buffer[offset++] = uInt8Float64Array1[5];
  buffer[offset++] = uInt8Float64Array1[6];
  buffer[offset++] = uInt8Float64Array1[7];
  return offset;
}
function writeDoubleBackwards1(buffer, val, offset = 0) {
  val = +val;
  checkBounds2(buffer, offset, 7);
  float64Array1[0] = val;
  buffer[offset++] = uInt8Float64Array1[7];
  buffer[offset++] = uInt8Float64Array1[6];
  buffer[offset++] = uInt8Float64Array1[5];
  buffer[offset++] = uInt8Float64Array1[4];
  buffer[offset++] = uInt8Float64Array1[3];
  buffer[offset++] = uInt8Float64Array1[2];
  buffer[offset++] = uInt8Float64Array1[1];
  buffer[offset++] = uInt8Float64Array1[0];
  return offset;
}
function readFloatBackwards1(buffer, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buffer.length - 4);
  }
  uInt8Float32Array1[3] = first;
  uInt8Float32Array1[2] = buffer[++offset];
  uInt8Float32Array1[1] = buffer[++offset];
  uInt8Float32Array1[0] = last;
  return float32Array1[0];
}
function readFloatForwards1(buffer, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buffer.length - 4);
  }
  uInt8Float32Array1[0] = first;
  uInt8Float32Array1[1] = buffer[++offset];
  uInt8Float32Array1[2] = buffer[++offset];
  uInt8Float32Array1[3] = last;
  return float32Array1[0];
}
function writeFloatForwards1(buffer, val, offset = 0) {
  val = +val;
  checkBounds2(buffer, offset, 3);
  float32Array1[0] = val;
  buffer[offset++] = uInt8Float32Array1[0];
  buffer[offset++] = uInt8Float32Array1[1];
  buffer[offset++] = uInt8Float32Array1[2];
  buffer[offset++] = uInt8Float32Array1[3];
  return offset;
}
function writeFloatBackwards1(buffer, val, offset = 0) {
  val = +val;
  checkBounds2(buffer, offset, 3);
  float32Array1[0] = val;
  buffer[offset++] = uInt8Float32Array1[3];
  buffer[offset++] = uInt8Float32Array1[2];
  buffer[offset++] = uInt8Float32Array1[1];
  buffer[offset++] = uInt8Float32Array1[0];
  return offset;
}
function readInt24LE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE1(buf, offset = 0) {
  validateNumber1(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf81(str) {
  return utf8Encoder1.encode(str).length;
}
function base64ByteLength1(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap1 = /* @__PURE__ */ Object.create(null);
for (let i5 = 0; i5 < encodings1.length; ++i5) {
  encodingsMap1[encodings1[i5]] = i5;
}
var encodingOps1 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap1.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, asciiToBytes1(val), byteOffset, encodingsMap1.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength1(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap1.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, base64ToBytes1(val), byteOffset, encodingsMap1.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength1(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap1.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, base64UrlToBytes1(val), byteOffset, encodingsMap1.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap1.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, hexToBytes1(val), byteOffset, encodingsMap1.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap1.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, asciiToBytes1(val), byteOffset, encodingsMap1.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap1.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, utf16leToBytes1(val), byteOffset, encodingsMap1.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf81,
    encoding: "utf8",
    encodingVal: encodingsMap1.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, utf8Encoder1.encode(val), byteOffset, encodingsMap1.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap1.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer1(buf, utf16leToBytes1(val), byteOffset, encodingsMap1.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps1(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps1.utf8;
      if (encoding === "ucs2")
        return encodingOps1.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps1.utf8;
      if (encoding === "ascii")
        return encodingOps1.ascii;
      if (encoding === "ucs-2")
        return encodingOps1.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps1.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps1.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps1.latin1;
      }
      if (encoding === "base64")
        return encodingOps1.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps1.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps1.base64url;
      }
      break;
  }
}
function _copyActual1(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError1(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber1(value, type);
    throw new codes1.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes1.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber1(value, name) {
  if (typeof value !== "number") {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds2(buf, offset, byteLength3) {
  validateNumber1(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
    boundsError1(offset, buf.length - (byteLength3 + 1));
  }
}
function checkInt1(value, min3, max2, buf, offset, byteLength3) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength3 > 3) {
      if (min3 === 0 || min3 === 0n) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength3 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}) and < 2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes1.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds2(buf, offset, byteLength3);
}
function toInteger1(n3, defaultVal) {
  n3 = +n3;
  if (!Number.isNaN(n3) && n3 >= Number.MIN_SAFE_INTEGER && n3 <= Number.MAX_SAFE_INTEGER) {
    return n3 % 1 === 0 ? n3 : Math.floor(n3);
  }
  return defaultVal;
}
function writeU_Int81(buf, value, offset, min3, max2) {
  value = +value;
  validateNumber1(offset, "offset");
  if (value > max2 || value < min3) {
    throw new codes1.ERR_OUT_OF_RANGE("value", `>= ${min3} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError1(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset1(value, name, min3 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes1.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes1.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes1.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
}
function writeU_Int48LE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE1(buf, value, offset, min3, max2) {
  value = +value;
  checkInt1(value, min3, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
var kMaxLength1 = 2147483647;
var MAX_UINT321 = 2 ** 32;
var customInspectSymbol3 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES1 = 50;
Object.defineProperty(Buffer1.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer1.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer1.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer1.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer1(length) {
  if (length > 2147483647) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer1.prototype);
  return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes1.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe1(arg);
  }
  return _from2(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from2(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString1(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer3(value)) {
      return fromArrayBuffer1(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from2(valueOf, encodingOrOffset, length);
    }
    const b15 = fromObject1(value);
    if (b15) {
      return b15;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString1(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes1.ERR_INVALID_ARG_TYPE("first argument", [
    "string",
    "Buffer",
    "ArrayBuffer",
    "Array",
    "Array-like Object"
  ], value);
}
Buffer1.from = function from2(value, encodingOrOffset, length) {
  return _from2(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize2(size) {
  validateNumber1(size, "size");
  if (!(size >= 0 && size <= 2147483647)) {
    throw new codes1.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc1(size, fill6, encoding) {
  assertSize2(size);
  const buffer = createBuffer1(size);
  if (fill6 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes1.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill6, encoding);
  }
  return buffer;
}
Buffer1.alloc = function alloc2(size, fill6, encoding) {
  return _alloc1(size, fill6, encoding);
};
function _allocUnsafe1(size) {
  assertSize2(size);
  return createBuffer1(size < 0 ? 0 : checked1(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe2(size) {
  return _allocUnsafe1(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow2(size) {
  return _allocUnsafe1(size);
};
function fromString1(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer1.isEncoding(encoding)) {
    throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength22(string, encoding) | 0;
  let buf = createBuffer1(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike1(array) {
  const length = array.length < 0 ? 0 : checked1(array.length) | 0;
  const buf = createBuffer1(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject1(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer3(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer1(0);
    }
    return fromArrayLike1(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike1(obj2.data);
  }
}
function checked1(length) {
  if (length >= 2147483647) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer1(length) {
  assertSize2(length);
  return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer1, Uint8Array);
Buffer1.isBuffer = function isBuffer2(b15) {
  return b15 != null && b15._isBuffer === true && b15 !== Buffer1.prototype;
};
Buffer1.compare = function compare4(a7, b15) {
  if (isInstance1(a7, Uint8Array)) {
    a7 = Buffer1.from(a7, a7.offset, a7.byteLength);
  }
  if (isInstance1(b15, Uint8Array)) {
    b15 = Buffer1.from(b15, b15.offset, b15.byteLength);
  }
  if (!Buffer1.isBuffer(a7) || !Buffer1.isBuffer(b15)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a7 === b15) {
    return 0;
  }
  let x17 = a7.length;
  let y16 = b15.length;
  for (let i = 0, len = Math.min(x17, y16); i < len; ++i) {
    if (a7[i] !== b15[i]) {
      x17 = a7[i];
      y16 = b15[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
Buffer1.isEncoding = function isEncoding2(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding4(encoding) !== void 0;
};
Buffer1.concat = function concat2(list, length) {
  if (!Array.isArray(list)) {
    throw new codes1.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer1.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset1(length, "length");
  }
  const buffer = Buffer1.allocUnsafe(length);
  let pos = 0;
  for (let i12 = 0; i12 < list.length; i12++) {
    const buf = list[i12];
    if (!isUint8Array1(buf)) {
      throw new codes1.ERR_INVALID_ARG_TYPE(`list[${i12}]`, [
        "Buffer",
        "Uint8Array"
      ], list[i12]);
    }
    pos += _copyActual1(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength22(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView1(string) || isAnyArrayBuffer3(string)) {
      return string.byteLength;
    }
    throw new codes1.ERR_INVALID_ARG_TYPE("string", [
      "string",
      "Buffer",
      "ArrayBuffer"
    ], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf81(string);
  }
  const ops = getEncodingOps1(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf81(string);
  }
  return ops.byteLength(string);
}
Buffer1.byteLength = byteLength22;
Buffer1.prototype._isBuffer = true;
function swap1(b15, n3, m20) {
  const i = b15[n3];
  b15[n3] = b15[m20];
  b15[m20] = i;
}
Buffer1.prototype.swap16 = function swap162() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap1(this, i, i + 1);
  }
  return this;
};
Buffer1.prototype.swap32 = function swap322() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap1(this, i, i + 3);
    swap1(this, i + 1, i + 2);
  }
  return this;
};
Buffer1.prototype.swap64 = function swap642() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap1(this, i, i + 7);
    swap1(this, i + 1, i + 6);
    swap1(this, i + 2, i + 5);
    swap1(this, i + 3, i + 4);
  }
  return this;
};
Buffer1.prototype.toString = function toString3(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps1(encoding);
  if (ops === void 0) {
    throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals2(b15) {
  if (!isUint8Array1(b15)) {
    throw new codes1.ERR_INVALID_ARG_TYPE("otherBuffer", [
      "Buffer",
      "Uint8Array"
    ], b15);
  }
  if (this === b15) {
    return true;
  }
  return Buffer1.compare(this, b15) === 0;
};
Buffer1.prototype.inspect = function inspect3() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES1;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol3) {
  Buffer1.prototype[customInspectSymbol3] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare5(target, start, end, thisStart, thisEnd) {
  if (isInstance1(target, Uint8Array)) {
    target = Buffer1.from(target, target.offset, target.byteLength);
  }
  if (!Buffer1.isBuffer(target)) {
    throw new codes1.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset1(start, "targetStart", 0, kMaxLength1);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset1(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset1(start, "sourceStart", 0, kMaxLength1);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset1(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes1.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x17 = thisEnd - thisStart;
  let y16 = end - start;
  const len = Math.min(x17, y16);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x17 = thisCopy[i];
      y16 = targetCopy[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf1(buffer, val, byteOffset, encoding, dir) {
  validateBuffer1(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber1(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps1.utf8;
  } else {
    ops = getEncodingOps1(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array1(val)) {
    const encodingVal = ops === void 0 ? encodingsMap1.utf8 : ops.encodingVal;
    return indexOfBuffer1(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes1.ERR_INVALID_ARG_TYPE("value", [
    "number",
    "string",
    "Buffer",
    "Uint8Array"
  ], val);
}
Buffer1.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf1(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf1(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii1(this);
  } else {
    return bytesToAscii1(this.slice(offset, length));
  }
};
Buffer1.prototype.asciiWrite = function asciiWrite2(string, offset, length) {
  return blitBuffer1(asciiToBytes1(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode32(this);
  } else {
    return encode32(this.slice(offset, length));
  }
};
Buffer1.prototype.base64Write = function base64Write2(string, offset, length) {
  return blitBuffer1(base64ToBytes1(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode42(this);
  } else {
    return encode42(this.slice(offset, length));
  }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite2(string, offset, length) {
  return blitBuffer1(base64UrlToBytes1(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite2(string, offset, length) {
  return blitBuffer1(hexToBytes1(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice3(string, offset, length) {
  return _hexSlice1(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice2(string, offset, length) {
  return _latin1Slice1(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write2(string, offset, length) {
  return blitBuffer1(asciiToBytes1(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le1(this);
  } else {
    return bytesToUtf16le1(this.slice(offset, length));
  }
};
Buffer1.prototype.ucs2Write = function ucs2Write2(string, offset, length) {
  return blitBuffer1(utf16leToBytes1(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice2(string, offset, length) {
  return _utf8Slice1(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write3(string, offset, length) {
  return blitBuffer1(utf8ToBytes1(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset1(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset1(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps1(encoding);
  if (ops === void 0) {
    throw new codes1.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer1(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes1.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer1.prototype);
  return buffer;
}
function _utf8Slice1(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray1(res);
}
var MAX_ARGUMENTS_LENGTH1 = 4096;
function decodeCodePointsArray1(codePoints) {
  const len = codePoints.length;
  if (len <= 4096) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH1));
  }
  return res;
}
function _latin1Slice1(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice1(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable1[buf[i]];
  }
  return out;
}
Buffer1.prototype.slice = function slice2(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer1.prototype);
  return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE2(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48LE1(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40LE1(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24LE1(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE2(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48BE1(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40BE1(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24BE1(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt83(offset = 0) {
  validateNumber1(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError1(offset, this.length - 1);
  }
  return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE1;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE2(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE2(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE1;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod1(function readBigUInt64LE2(offset) {
  offset = offset >>> 0;
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 8);
  }
  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod1(function readBigUInt64BE2(offset) {
  offset = offset >>> 0;
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE2(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48LE1(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40LE1(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24LE1(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE2(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes1.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48BE1(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40BE1(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24BE1(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt82(offset = 0) {
  validateNumber1(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError1(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer1.prototype.readInt16LE = function readInt16LE2(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer1.prototype.readInt16BE = function readInt16BE2(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer1.prototype.readInt32LE = function readInt32LE2(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE2(offset = 0) {
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod1(function readBigInt64LE2(offset) {
  offset = offset >>> 0;
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod1(function readBigInt64BE2(offset) {
  offset = offset >>> 0;
  validateNumber1(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError1(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE2(offset) {
  return bigEndian1 ? readFloatBackwards1(this, offset) : readFloatForwards1(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE2(offset) {
  return bigEndian1 ? readFloatForwards1(this, offset) : readFloatBackwards1(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE2(offset) {
  return bigEndian1 ? readDoubleBackwards1(this, offset) : readDoubleForwards1(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE2(offset) {
  return bigEndian1 ? readDoubleForwards1(this, offset) : readDoubleBackwards1(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE1(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE1(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE1(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE1(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE1(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int81(this, value, offset, 0, 255);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE1(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE1(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE1(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE1(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE1(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int81(this, value, offset, 0, 255);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt82(value, offset = 0) {
  return writeU_Int81(this, value, offset, 0, 255);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE2(value, offset = 0) {
  return writeU_Int16LE1(this, value, offset, 0, 65535);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE2(value, offset = 0) {
  return writeU_Int16BE1(this, value, offset, 0, 65535);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE2(value, offset = 0) {
  return _writeUInt32LE1(this, value, offset, 0, 4294967295);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE2(value, offset = 0) {
  return _writeUInt32BE1(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE1(buf, value, offset, min3, max2) {
  checkIntBI1(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE1(buf, value, offset, min3, max2) {
  checkIntBI1(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod1(function writeBigUInt64LE2(value, offset = 0) {
  return wrtBigUInt64LE1(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod1(function writeBigUInt64BE2(value, offset = 0) {
  return wrtBigUInt64BE1(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE1(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE1(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE1(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE1(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE1(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int81(this, value, offset, -128, 127);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE1(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE1(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE1(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE1(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE1(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int81(this, value, offset, -128, 127);
  }
  boundsError1(byteLength3, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt82(value, offset = 0) {
  return writeU_Int81(this, value, offset, -128, 127);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE2(value, offset = 0) {
  return writeU_Int16LE1(this, value, offset, -32768, 32767);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE2(value, offset = 0) {
  return writeU_Int16BE1(this, value, offset, -32768, 32767);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE2(value, offset = 0) {
  return writeU_Int32LE1(this, value, offset, -2147483648, 2147483647);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE2(value, offset = 0) {
  return writeU_Int32BE1(this, value, offset, -2147483648, 2147483647);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod1(function writeBigInt64LE2(value, offset = 0) {
  return wrtBigUInt64LE1(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod1(function writeBigInt64BE2(value, offset = 0) {
  return wrtBigUInt64BE1(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE2(value, offset) {
  return bigEndian1 ? writeFloatBackwards1(this, value, offset) : writeFloatForwards1(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE2(value, offset) {
  return bigEndian1 ? writeFloatForwards1(this, value, offset) : writeFloatBackwards1(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE2(value, offset) {
  return bigEndian1 ? writeDoubleBackwards1(this, value, offset) : writeDoubleForwards1(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE2(value, offset) {
  return bigEndian1 ? writeDoubleForwards1(this, value, offset) : writeDoubleBackwards1(this, value, offset);
};
Buffer1.prototype.copy = function copy3(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array1(this)) {
    throw new codes1.ERR_INVALID_ARG_TYPE("source", [
      "Buffer",
      "Uint8Array"
    ], this);
  }
  if (!isUint8Array1(target)) {
    throw new codes1.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger1(targetStart, 0);
    if (targetStart < 0) {
      throw new codes1.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger1(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes1.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT321) {
      throw new codes1.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT321}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger1(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes1.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT321) {
      throw new codes1.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT321}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer1.prototype.fill = function fill2(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes1.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds3(buf, offset, byteLength23) {
  validateNumber1(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength23] === void 0) {
    boundsError1(offset, buf.length - (byteLength23 + 1));
  }
}
function checkIntBI1(value, min3, max2, buf, offset, byteLength23) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength23 > 3) {
      if (min3 === 0 || min3 === BigInt(0)) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength23 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength23 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength23 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes1.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds3(buf, offset, byteLength23);
}
function utf8ToBytes1(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer1(src, dst, offset, byteLength3) {
  let i;
  const length = byteLength3 === void 0 ? src.length : byteLength3;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance1(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable1 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j13 = 0; j13 < 16; ++j13) {
      table[i16 + j13] = alphabet[i] + alphabet[j13];
    }
  }
  return table;
}();
function defineBigIntMethod1(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined1 : fn;
}
function BufferBigIntNotDefined1() {
  throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType1;
(function(valueType3) {
  valueType3[valueType3["noIterator"] = 0] = "noIterator";
  valueType3[valueType3["isArray"] = 1] = "isArray";
  valueType3[valueType3["isSet"] = 2] = "isSet";
  valueType3[valueType3["isMap"] = 3] = "isMap";
})(valueType1 || (valueType1 = {}));
var memo1;
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual1(val1, val2, true);
}
function innerDeepEqual1(val1, val2, strict, memos = memo1) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? 2 : 2 | 16;
    const keys1 = getOwnNonIndexProperties1(val1, filter);
    const keys2 = getOwnNonIndexProperties1(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck1(val1, val2, strict, memos, valueType1.isArray, keys1);
  } else if (val1Tag === "[object Object]") {
    return keyCheck1(val1, val2, strict, memos, valueType1.noIterator);
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps1(val1, val2)) {
      return false;
    }
  } else if (isNativeError3(val1) || val1 instanceof Error) {
    if (!isNativeError3(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView1(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) => Object.getOwnPropertySymbols(val).map((item) => item.toString()).toString();
    if (isTypedArray1(val1) && isTypedArray1(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
      return false;
    }
    if (!strict && (isFloat32Array1(val1) || isFloat64Array1(val1))) {
      if (!areSimilarFloatArrays1(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays1(val1, val2)) {
      return false;
    }
    const filter1 = strict ? 2 : 2 | 16;
    const keysVal1 = getOwnNonIndexProperties1(val1, filter1);
    const keysVal2 = getOwnNonIndexProperties1(val2, filter1);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck1(val1, val2, strict, memos, valueType1.noIterator, keysVal1);
  } else if (isSet3(val1)) {
    if (!isSet3(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck1(val1, val2, strict, memos, valueType1.isSet);
  } else if (isMap3(val1)) {
    if (!isMap3(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck1(val1, val2, strict, memos, valueType1.isMap);
  } else if (isAnyArrayBuffer3(val1)) {
    if (!isAnyArrayBuffer3(val2) || !areEqualArrayBuffers1(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive3(val1)) {
    if (!isEqualBoxedPrimitive1(val1, val2)) {
      return false;
    }
  } else if (Array.isArray(val2) || isArrayBufferView1(val2) || isSet3(val2) || isMap3(val2) || isDate3(val2) || isRegExp3(val2) || isAnyArrayBuffer3(val2) || isBoxedPrimitive3(val2) || isNativeError3(val2) || val2 instanceof Error) {
    return false;
  }
  return keyCheck1(val1, val2, strict, memos, valueType1.noIterator);
}
function keyCheck1(val1, val2, strict, memos, iterationType, aKeys = []) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key2 = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key2)) {
          if (!val2.propertyIsEnumerable(key2)) {
            return false;
          }
          aKeys.push(key2.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key2)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables1(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB1.length !== 0 && getEnumerables1(val2, symbolKeysB1).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === valueType1.noIterator || iterationType === valueType1.isArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv1(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function areSimilarRegExps1(a7, b15) {
  return a7.source === b15.source && a7.flags === b15.flags && a7.lastIndex === b15.lastIndex;
}
function areSimilarFloatArrays1(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays1(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers1(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive1(a7, b15) {
  if (Object.getOwnPropertyNames(a7).length !== Object.getOwnPropertyNames(b15).length) {
    return false;
  }
  if (Object.getOwnPropertySymbols(a7).length !== Object.getOwnPropertySymbols(b15).length) {
    return false;
  }
  if (isNumberObject3(a7)) {
    return isNumberObject3(b15) && Object.is(Number.prototype.valueOf.call(a7), Number.prototype.valueOf.call(b15));
  }
  if (isStringObject3(a7)) {
    return isStringObject3(b15) && String.prototype.valueOf.call(a7) === String.prototype.valueOf.call(b15);
  }
  if (isBooleanObject3(a7)) {
    return isBooleanObject3(b15) && Boolean.prototype.valueOf.call(a7) === Boolean.prototype.valueOf.call(b15);
  }
  if (isBigIntObject3(a7)) {
    return isBigIntObject3(b15) && BigInt.prototype.valueOf.call(a7) === BigInt.prototype.valueOf.call(b15);
  }
  if (isSymbolObject3(a7)) {
    return isSymbolObject3(b15) && Symbol.prototype.valueOf.call(a7) === Symbol.prototype.valueOf.call(b15);
  }
  throw Error(`Unknown boxed type`);
}
function getEnumerables1(val, keys) {
  return keys.filter((key2) => val.propertyIsEnumerable(key2));
}
function objEquiv1(obj1, obj2, strict, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === valueType1.isSet) {
    if (!setEquiv1(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType1.isMap) {
    if (!mapEquiv1(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType1.isArray) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (!obj2.hasOwnProperty(i) || !innerDeepEqual1(obj1[i], obj2[i], strict, memos)) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key2 = keys1[i];
          if (!obj2.hasOwnProperty(key2) || !innerDeepEqual1(obj1[key2], obj2[key2], strict, memos)) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key1 = keys[i];
    if (!innerDeepEqual1(obj1[key1], obj2[key1], strict, memos)) {
      return false;
    }
  }
  return true;
}
function findLooseMatchingPrimitives1(primitive) {
  switch (typeof primitive) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      primitive = +primitive;
    case "number":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim1(set1, set2, primitive) {
  const altValue = findLooseMatchingPrimitives1(primitive);
  if (altValue != null)
    return altValue;
  return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement1(set, val1, strict, memos) {
  for (const val2 of set) {
    if (innerDeepEqual1(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function setEquiv1(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === "object" && item !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict)
        return false;
      if (!setMightHaveLoosePrim1(set1, set2, item)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    }
  }
  if (set !== null) {
    for (const item1 of set2) {
      if (typeof item1 === "object" && item1 !== null) {
        if (!setHasEqualElement1(set, item1, strict, memos))
          return false;
      } else if (!strict && !set1.has(item1) && !setHasEqualElement1(set, item1, strict, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapMightHaveLoosePrimitive1(map1, map2, primitive, item, memos) {
  const altValue = findLooseMatchingPrimitives1(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (curB === void 0 && !map2.has(altValue) || !innerDeepEqual1(item, curB, false, memo1)) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual1(item, curB, false, memos);
}
function mapEquiv1(map1, map2, strict, memos) {
  let set = null;
  for (const { 0: key2, 1: item1 } of map1) {
    if (typeof key2 === "object" && key2 !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key2);
    } else {
      const item2 = map2.get(key2);
      if (item2 === void 0 && !map2.has(key2) || !innerDeepEqual1(item1, item2, strict, memos)) {
        if (strict)
          return false;
        if (!mapMightHaveLoosePrimitive1(map1, map2, key2, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      }
    }
  }
  if (set !== null) {
    for (const { 0: key1, 1: item } of map2) {
      if (typeof key1 === "object" && key1 !== null) {
        if (!mapHasEqualEntry1(set, map1, key1, item, strict, memos)) {
          return false;
        }
      } else if (!strict && (!map1.has(key1) || !innerDeepEqual1(map1.get(key1), item, false, memos)) && !mapHasEqualEntry1(set, map1, key1, item, false, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry1(set, map, key1, item1, strict, memos) {
  for (const key2 of set) {
    if (innerDeepEqual1(key1, key2, strict, memos) && innerDeepEqual1(item1, map.get(key2), strict, memos)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
var NumberIsSafeInteger1 = Number.isSafeInteger;
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isNumber1(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function isUndefined(value) {
  return value === void 0;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isError2(e) {
  return e instanceof Error;
}
function isFunction(value) {
  return typeof value === "function";
}
function isRegExp4(value) {
  return __default11.isRegExp(value);
}
function isDate4(value) {
  return __default11.isDate(value);
}
function isPrimitive(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer3(value) {
  return Buffer1.isBuffer(value);
}
function _extend(target, source) {
  if (source === null || typeof source !== "object")
    return target;
  const keys = Object.keys(source);
  let i = keys.length;
  while (i--) {
    target[keys[i]] = source[keys[i]];
  }
  return target;
}
function getSystemErrorName1(code2) {
  if (typeof code2 !== "number") {
    throw new codes1.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger1(code2)) {
    throw new codes1.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap1.get(code2)?.[0];
}
function inherits1(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new codes1.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new codes1.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new codes1.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad(n3) {
  return n3.toString().padStart(2, "0");
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  const d14 = new Date();
  const t2 = [
    pad(d14.getHours()),
    pad(d14.getMinutes()),
    pad(d14.getSeconds())
  ].join(":");
  return `${d14.getDate()} ${months[d14.getMonth()]} ${t2}`;
}
function log(...args) {
  console.log("%s - %s", timestamp(), format4(...args));
}
var __default14 = {
  format: format4,
  formatWithOptions,
  inspect: inspect22,
  isArray,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber: isNumber1,
  isString,
  isSymbol,
  isUndefined,
  isObject,
  isError: isError2,
  isFunction,
  isRegExp: isRegExp4,
  isDate: isDate4,
  isPrimitive,
  isBuffer: isBuffer3,
  _extend,
  getSystemErrorName: getSystemErrorName1,
  deprecate,
  callbackify,
  promisify: promisify1,
  inherits: inherits1,
  types: __default11,
  stripVTControlCharacters: stripVTControlCharacters1,
  TextDecoder: _TextDecoder,
  TextEncoder: _TextEncoder,
  log,
  debuglog: debuglog1,
  isDeepStrictEqual
};
var DenoStdInternalError1 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert3(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError1(msg);
  }
}
var { errno: { ENOTDIR: ENOTDIR1, ENOENT: ENOENT1 } } = os1;
var kIsNodeError1 = Symbol("kIsNodeError");
var classRegExp3 = /^([A-Z][a-z0-9]*)+$/;
var kTypes1 = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
var AbortError1 = class extends Error {
  code;
  constructor() {
    super("The operation was aborted");
    this.code = "ABORT_ERR";
    this.name = "AbortError";
  }
};
function addNumericalSeparator1(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace1 = hideStackFrames1(function captureLargerStackTrace3(err) {
  Error.captureStackTrace(err);
  return err;
});
hideStackFrames1(function uvExceptionWithHostPort2(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet1(err) || uvUnmappedError1;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace1(ex);
});
hideStackFrames1(function errnoException2(err, syscall, original) {
  const code2 = getSystemErrorName1(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace1(ex);
});
function uvErrmapGet1(name) {
  return errorMap1.get(name);
}
var uvUnmappedError1 = [
  "UNKNOWN",
  "unknown error"
];
hideStackFrames1(function uvException2(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet1(ctx.errno) || uvUnmappedError1;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace1(err);
});
hideStackFrames1(function exceptionWithHostPort2(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName1(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace1(ex);
});
hideStackFrames1(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap1.get("EAI_NODATA") || code2 === codeMap1.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName1(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace1(ex);
});
var NodeErrorAbstraction1 = class extends Error {
  code;
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError1 = class extends NodeErrorAbstraction1 {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError1 = class extends NodeErrorAbstraction1 {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError1 = class extends NodeErrorAbstraction1 {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError1 = class extends NodeErrorAbstraction1 {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace1(this);
    Object.defineProperties(this, {
      [kIsNodeError1]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode1(key2, msgPrfix) {
  return class NodeError extends NodeSystemError1 {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
makeSystemErrorWithCode1("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType1(name, expected) {
  expected = Array.isArray(expected) ? expected : [
    expected
  ];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types2 = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes1.includes(value)) {
      types2.push(value.toLocaleLowerCase());
    } else if (classRegExp3.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types2.indexOf("object");
    if (pos !== -1) {
      types2.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types2.length > 0) {
    if (types2.length > 2) {
      const last = types2.pop();
      msg += `one of type ${types2.join(", ")}, or ${last}`;
    } else if (types2.length === 2) {
      msg += `one of type ${types2[0]} or ${types2[1]}`;
    } else {
      msg += `of type ${types2[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last1 = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last1}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last2 = other.pop();
      msg += `one of ${other.join(", ")}, or ${last2}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE1 = class extends NodeRangeError1 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType1(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper1(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE1 = class extends NodeTypeError1 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType1(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper1(actual)}`);
  }
};
__publicField(ERR_INVALID_ARG_TYPE1, "RangeError", ERR_INVALID_ARG_TYPE_RANGE1);
var ERR_INVALID_ARG_VALUE_RANGE1 = class extends NodeRangeError1 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect22(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE1 = class extends NodeTypeError1 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect22(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
__publicField(ERR_INVALID_ARG_VALUE1, "RangeError", ERR_INVALID_ARG_VALUE_RANGE1);
function invalidArgTypeHelper1(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect22(input, {
      depth: -1
    })}`;
  }
  let inspected = inspect22(input, {
    colors: false
  });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE1 = class extends RangeError {
  code = "ERR_OUT_OF_RANGE";
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert3(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator1(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator1(received);
      }
      received += "n";
    } else {
      received = inspect22(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS1 = class extends NodeRangeError1 {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_INVALID_CALLBACK1 = class extends NodeTypeError1 {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect22(object)}`);
  }
};
var ERR_IPC_CHANNEL_CLOSED1 = class extends NodeError1 {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_METHOD_NOT_IMPLEMENTED1 = class extends NodeError1 {
  constructor(x17) {
    super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x17} method is not implemented`);
  }
};
var ERR_MISSING_ARGS1 = class extends NodeTypeError1 {
  constructor(...args) {
    let msg = "The ";
    const len = args.length;
    const wrap3 = (a7) => `"${a7}"`;
    args = args.map((a7) => Array.isArray(a7) ? a7.map(wrap3).join(" or ") : wrap3(a7));
    switch (len) {
      case 1:
        msg += `${args[0]} argument`;
        break;
      case 2:
        msg += `${args[0]} and ${args[1]} arguments`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += `, and ${args[len - 1]} arguments`;
        break;
    }
    super("ERR_MISSING_ARGS", `${msg} must be specified`);
  }
};
var ERR_MULTIPLE_CALLBACK1 = class extends NodeError1 {
  constructor() {
    super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
  }
};
var ERR_SOCKET_BAD_PORT1 = class extends NodeRangeError1 {
  constructor(name, port, allowZero = true) {
    assert3(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_STREAM_ALREADY_FINISHED1 = class extends NodeError1 {
  constructor(x17) {
    super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x17} after a stream was finished`);
  }
};
var ERR_STREAM_CANNOT_PIPE1 = class extends NodeError1 {
  constructor() {
    super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
  }
};
var ERR_STREAM_DESTROYED1 = class extends NodeError1 {
  constructor(x17) {
    super("ERR_STREAM_DESTROYED", `Cannot call ${x17} after a stream was destroyed`);
  }
};
var ERR_STREAM_NULL_VALUES1 = class extends NodeTypeError1 {
  constructor() {
    super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
  }
};
var ERR_STREAM_PREMATURE_CLOSE1 = class extends NodeError1 {
  constructor() {
    super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
  }
};
var ERR_STREAM_PUSH_AFTER_EOF1 = class extends NodeError1 {
  constructor() {
    super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
  }
};
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT1 = class extends NodeError1 {
  constructor() {
    super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
  }
};
var ERR_STREAM_WRITE_AFTER_END1 = class extends NodeError1 {
  constructor() {
    super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
  }
};
var ERR_UNHANDLED_ERROR1 = class extends NodeError1 {
  constructor(x17) {
    super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x17})`);
  }
};
var ERR_UNKNOWN_ENCODING1 = class extends NodeTypeError1 {
  constructor(x17) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x17}`);
  }
};
var ERR_UNKNOWN_SIGNAL1 = class extends NodeTypeError1 {
  constructor(x17) {
    super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x17}`);
  }
};
function buildReturnPropertyType1(value) {
  if (value && value.constructor && value.constructor.name) {
    return `instance of ${value.constructor.name}`;
  } else {
    return `type ${typeof value}`;
  }
}
var ERR_INVALID_RETURN_VALUE1 = class extends NodeTypeError1 {
  constructor(input, name, value) {
    super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType1(value)}.`);
  }
};
function aggregateTwoErrors1(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      outerError.errors.push(innerError);
      return outerError;
    }
    const err = new AggregateError([
      outerError,
      innerError
    ], outerError.message);
    err.code = outerError.code;
    return err;
  }
  return innerError || outerError;
}
codes1.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED1;
codes1.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE1;
codes1.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE1;
codes1.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK1;
codes1.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE1;
codes1.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT1;
codes1.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS1;
codes1.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING1;
hideStackFrames1(function genericNodeError2(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});
var kRejection1 = Symbol.for("nodejs.rejection");
var kCapture1 = Symbol("kCapture");
var kErrorMonitor1 = Symbol("events.errorMonitor");
var kMaxEventTargetListeners1 = Symbol("events.maxEventTargetListeners");
var kMaxEventTargetListenersWarned1 = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter1(opts) {
  EventEmitter1.init.call(this, opts);
}
EventEmitter1.on = on1;
EventEmitter1.once = once32;
EventEmitter1.getEventListeners = getEventListeners1;
EventEmitter1.EventEmitter = EventEmitter1;
EventEmitter1.usingDomains = false;
EventEmitter1.captureRejectionSymbol = kRejection1;
EventEmitter1.captureRejectionSymbol;
EventEmitter1.errorMonitor;
Object.defineProperty(EventEmitter1, "captureRejections", {
  get() {
    return EventEmitter1.prototype[kCapture1];
  },
  set(value) {
    validateBoolean1(value, "EventEmitter.captureRejections");
    EventEmitter1.prototype[kCapture1] = value;
  },
  enumerable: true
});
EventEmitter1.errorMonitor = kErrorMonitor1;
Object.defineProperty(EventEmitter1.prototype, kCapture1, {
  value: false,
  writable: true,
  enumerable: false
});
EventEmitter1.prototype._events = void 0;
EventEmitter1.prototype._eventsCount = 0;
EventEmitter1.prototype._maxListeners = void 0;
var defaultMaxListeners1 = 10;
function checkListener1(listener) {
  validateFunction1(listener, "listener");
}
Object.defineProperty(EventEmitter1, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners1;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
      throw new ERR_OUT_OF_RANGE1("defaultMaxListeners", "a non-negative number", arg);
    }
    defaultMaxListeners1 = arg;
  }
});
Object.defineProperties(EventEmitter1, {
  kMaxEventTargetListeners: {
    value: kMaxEventTargetListeners1,
    enumerable: false,
    configurable: false,
    writable: false
  },
  kMaxEventTargetListenersWarned: {
    value: kMaxEventTargetListenersWarned1,
    enumerable: false,
    configurable: false,
    writable: false
  }
});
EventEmitter1.setMaxListeners = function(n3 = defaultMaxListeners1, ...eventTargets) {
  if (typeof n3 !== "number" || n3 < 0 || Number.isNaN(n3)) {
    throw new ERR_OUT_OF_RANGE1("n", "a non-negative number", n3);
  }
  if (eventTargets.length === 0) {
    defaultMaxListeners1 = n3;
  } else {
    for (let i = 0; i < eventTargets.length; i++) {
      const target = eventTargets[i];
      if (target instanceof EventTarget) {
        target[kMaxEventTargetListeners1] = n3;
        target[kMaxEventTargetListenersWarned1] = false;
      } else if (typeof target.setMaxListeners === "function") {
        target.setMaxListeners(n3);
      } else {
        throw new ERR_INVALID_ARG_TYPE1("eventTargets", [
          "EventEmitter",
          "EventTarget"
        ], target);
      }
    }
  }
};
EventEmitter1.init = function(opts) {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
  if (opts?.captureRejections) {
    validateBoolean1(opts.captureRejections, "options.captureRejections");
    this[kCapture1] = Boolean(opts.captureRejections);
  } else {
    this[kCapture1] = EventEmitter1.prototype[kCapture1];
  }
};
function addCatch1(that, promise, type, args) {
  if (!that[kCapture1]) {
    return;
  }
  try {
    const then = promise.then;
    if (typeof then === "function") {
      then.call(promise, void 0, function(err) {
        process.nextTick(emitUnhandledRejectionOrErr1, that, err, type, args);
      });
    }
  } catch (err) {
    that.emit("error", err);
  }
}
function emitUnhandledRejectionOrErr1(ee2, err, type, args) {
  if (typeof ee2[kRejection1] === "function") {
    ee2[kRejection1](err, type, ...args);
  } else {
    const prev = ee2[kCapture1];
    try {
      ee2[kCapture1] = false;
      ee2.emit("error", err);
    } finally {
      ee2[kCapture1] = prev;
    }
  }
}
EventEmitter1.prototype.setMaxListeners = function setMaxListeners2(n3) {
  if (typeof n3 !== "number" || n3 < 0 || Number.isNaN(n3)) {
    throw new ERR_OUT_OF_RANGE1("n", "a non-negative number", n3);
  }
  this._maxListeners = n3;
  return this;
};
function _getMaxListeners1(that) {
  if (that._maxListeners === void 0) {
    return EventEmitter1.defaultMaxListeners;
  }
  return that._maxListeners;
}
EventEmitter1.prototype.getMaxListeners = function getMaxListeners2() {
  return _getMaxListeners1(this);
};
EventEmitter1.prototype.emit = function emit2(type, ...args) {
  let doError = type === "error";
  const events = this._events;
  if (events !== void 0) {
    if (doError && events[kErrorMonitor1] !== void 0) {
      this.emit(kErrorMonitor1, ...args);
    }
    doError = doError && events.error === void 0;
  } else if (!doError) {
    return false;
  }
  if (doError) {
    let er2;
    if (args.length > 0) {
      er2 = args[0];
    }
    if (er2 instanceof Error) {
      try {
        const capture = {};
        Error.captureStackTrace(capture, EventEmitter1.prototype.emit);
      } catch {
      }
      throw er2;
    }
    let stringifiedEr;
    try {
      stringifiedEr = inspect22(er2);
    } catch {
      stringifiedEr = er2;
    }
    const err = new ERR_UNHANDLED_ERROR1(stringifiedEr);
    err.context = er2;
    throw err;
  }
  const handler = events[type];
  if (handler === void 0) {
    return false;
  }
  if (typeof handler === "function") {
    const result = handler.apply(this, args);
    if (result !== void 0 && result !== null) {
      addCatch1(this, result, type, args);
    }
  } else {
    const len = handler.length;
    const listeners3 = arrayClone1(handler);
    for (let i = 0; i < len; ++i) {
      const result1 = listeners3[i].apply(this, args);
      if (result1 !== void 0 && result1 !== null) {
        addCatch1(this, result1, type, args);
      }
    }
  }
  return true;
};
function _addListener1(target, type, listener, prepend) {
  let m20;
  let events;
  let existing;
  checkListener1(listener);
  events = target._events;
  if (events === void 0) {
    events = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ?? listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === void 0) {
    events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [
        listener,
        existing
      ] : [
        existing,
        listener
      ];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m20 = _getMaxListeners1(target);
    if (m20 > 0 && existing.length > m20 && !existing.warned) {
      existing.warned = true;
      const w24 = new Error(`Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners added to ${inspect22(target, {
        depth: -1
      })}. Use emitter.setMaxListeners() to increase limit`);
      w24.name = "MaxListenersExceededWarning";
      w24.emitter = target;
      w24.type = type;
      w24.count = existing.length;
      process.emitWarning(w24);
    }
  }
  return target;
}
EventEmitter1.prototype.addListener = function addListener2(type, listener) {
  return _addListener1(this, type, listener, false);
};
EventEmitter1.prototype.on = EventEmitter1.prototype.addListener;
EventEmitter1.prototype.prependListener = function prependListener3(type, listener) {
  return _addListener1(this, type, listener, true);
};
function onceWrapper1() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) {
      return this.listener.call(this.target);
    }
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap1(target, type, listener) {
  const state = {
    fired: false,
    wrapFn: void 0,
    target,
    type,
    listener
  };
  const wrapped = onceWrapper1.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter1.prototype.once = function once3(type, listener) {
  checkListener1(listener);
  this.on(type, _onceWrap1(this, type, listener));
  return this;
};
EventEmitter1.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
  checkListener1(listener);
  this.prependListener(type, _onceWrap1(this, type, listener));
  return this;
};
EventEmitter1.prototype.removeListener = function removeListener2(type, listener) {
  checkListener1(listener);
  const events = this._events;
  if (events === void 0) {
    return this;
  }
  const list = events[type];
  if (list === void 0) {
    return this;
  }
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
    } else {
      delete events[type];
      if (events.removeListener) {
        this.emit("removeListener", type, list.listener || listener);
      }
    }
  } else if (typeof list !== "function") {
    let position = -1;
    for (let i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        position = i;
        break;
      }
    }
    if (position < 0) {
      return this;
    }
    if (position === 0) {
      list.shift();
    } else {
      spliceOne1(list, position);
    }
    if (list.length === 1) {
      events[type] = list[0];
    }
    if (events.removeListener !== void 0) {
      this.emit("removeListener", type, listener);
    }
  }
  return this;
};
EventEmitter1.prototype.off = EventEmitter1.prototype.removeListener;
EventEmitter1.prototype.removeAllListeners = function removeAllListeners2(type) {
  const events = this._events;
  if (events === void 0) {
    return this;
  }
  if (events.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== void 0) {
      if (--this._eventsCount === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
      } else {
        delete events[type];
      }
    }
    return this;
  }
  if (arguments.length === 0) {
    for (const key2 of Reflect.ownKeys(events)) {
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  const listeners3 = events[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3 !== void 0) {
    for (let i = listeners3.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners3[i]);
    }
  }
  return this;
};
function _listeners1(target, type, unwrap) {
  const events = target._events;
  if (events === void 0) {
    return [];
  }
  const evlistener = events[type];
  if (evlistener === void 0) {
    return [];
  }
  if (typeof evlistener === "function") {
    return unwrap ? [
      evlistener.listener || evlistener
    ] : [
      evlistener
    ];
  }
  return unwrap ? unwrapListeners1(evlistener) : arrayClone1(evlistener);
}
EventEmitter1.prototype.listeners = function listeners2(type) {
  return _listeners1(this, type, true);
};
EventEmitter1.prototype.rawListeners = function rawListeners2(type) {
  return _listeners1(this, type, false);
};
EventEmitter1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  }
  return listenerCount1.call(emitter, type);
};
EventEmitter1.prototype.listenerCount = listenerCount1;
function listenerCount1(type) {
  const events = this._events;
  if (events !== void 0) {
    const evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter1.prototype.eventNames = function eventNames2() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone1(arr) {
  switch (arr.length) {
    case 2:
      return [
        arr[0],
        arr[1]
      ];
    case 3:
      return [
        arr[0],
        arr[1],
        arr[2]
      ];
    case 4:
      return [
        arr[0],
        arr[1],
        arr[2],
        arr[3]
      ];
    case 5:
      return [
        arr[0],
        arr[1],
        arr[2],
        arr[3],
        arr[4]
      ];
    case 6:
      return [
        arr[0],
        arr[1],
        arr[2],
        arr[3],
        arr[4],
        arr[5]
      ];
  }
  return arr.slice();
}
function unwrapListeners1(arr) {
  const ret = arrayClone1(arr);
  for (let i = 0; i < ret.length; ++i) {
    const orig = ret[i].listener;
    if (typeof orig === "function") {
      ret[i] = orig;
    }
  }
  return ret;
}
function getEventListeners1(emitterOrTarget, type) {
  if (typeof emitterOrTarget.listeners === "function") {
    return emitterOrTarget.listeners(type);
  }
  if (emitterOrTarget instanceof EventTarget) {
    const root = emitterOrTarget[kEvents].get(type);
    const listeners3 = [];
    let handler = root?.next;
    while (handler?.listener !== void 0) {
      const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
      listeners3.push(listener);
      handler = handler.next;
    }
    return listeners3;
  }
  throw new ERR_INVALID_ARG_TYPE1("emitter", [
    "EventEmitter",
    "EventTarget"
  ], emitterOrTarget);
}
async function once32(emitter, name, options = {}) {
  const signal = options?.signal;
  validateAbortSignal2(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError1();
  }
  return new Promise((resolve9, reject) => {
    const errorListener = (err) => {
      emitter.removeListener(name, resolver);
      if (signal != null) {
        eventTargetAgnosticRemoveListener1(signal, "abort", abortListener);
      }
      reject(err);
    };
    const resolver = (...args) => {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      if (signal != null) {
        eventTargetAgnosticRemoveListener1(signal, "abort", abortListener);
      }
      resolve9(args);
    };
    eventTargetAgnosticAddListener1(emitter, name, resolver, {
      once: true
    });
    if (name !== "error" && typeof emitter.once === "function") {
      emitter.once("error", errorListener);
    }
    function abortListener() {
      eventTargetAgnosticRemoveListener1(emitter, name, resolver);
      eventTargetAgnosticRemoveListener1(emitter, "error", errorListener);
      reject(new AbortError1());
    }
    if (signal != null) {
      eventTargetAgnosticAddListener1(signal, "abort", abortListener, {
        once: true
      });
    }
  });
}
var AsyncIteratorPrototype1 = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}).prototype);
function createIterResult1(value, done) {
  return {
    value,
    done
  };
}
function eventTargetAgnosticRemoveListener1(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function") {
    emitter.removeListener(name, listener);
  } else if (typeof emitter.removeEventListener === "function") {
    emitter.removeEventListener(name, listener, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE1("emitter", "EventEmitter", emitter);
  }
}
function eventTargetAgnosticAddListener1(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags?.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, (arg) => {
      listener(arg);
    }, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE1("emitter", "EventEmitter", emitter);
  }
}
function on1(emitter, event, options) {
  const signal = options?.signal;
  validateAbortSignal2(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError1();
  }
  const unconsumedEvents = [];
  const unconsumedPromises = [];
  let error2 = null;
  let finished2 = false;
  const iterator = Object.setPrototypeOf({
    next() {
      const value = unconsumedEvents.shift();
      if (value) {
        return Promise.resolve(createIterResult1(value, false));
      }
      if (error2) {
        const p7 = Promise.reject(error2);
        error2 = null;
        return p7;
      }
      if (finished2) {
        return Promise.resolve(createIterResult1(void 0, true));
      }
      return new Promise(function(resolve9, reject) {
        unconsumedPromises.push({
          resolve: resolve9,
          reject
        });
      });
    },
    return() {
      eventTargetAgnosticRemoveListener1(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener1(emitter, "error", errorHandler);
      if (signal) {
        eventTargetAgnosticRemoveListener1(signal, "abort", abortListener, {
          once: true
        });
      }
      finished2 = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult1(void 0, true));
      }
      return Promise.resolve(createIterResult1(void 0, true));
    },
    throw(err) {
      if (!err || !(err instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE1("EventEmitter.AsyncIterator", "Error", err);
      }
      error2 = err;
      eventTargetAgnosticRemoveListener1(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener1(emitter, "error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  }, AsyncIteratorPrototype1);
  eventTargetAgnosticAddListener1(emitter, event, eventHandler);
  if (event !== "error" && typeof emitter.on === "function") {
    emitter.on("error", errorHandler);
  }
  if (signal) {
    eventTargetAgnosticAddListener1(signal, "abort", abortListener, {
      once: true
    });
  }
  return iterator;
  function abortListener() {
    errorHandler(new AbortError1());
  }
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult1(args, false));
    } else {
      unconsumedEvents.push(args);
    }
  }
  function errorHandler(err) {
    finished2 = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error2 = err;
    }
    iterator.return();
  }
}
var { hasOwn: hasOwn1 } = Object;
function get1(obj2, key2) {
  if (hasOwn1(obj2, key2)) {
    return obj2[key2];
  }
}
function getForce1(obj2, key2) {
  const v19 = get1(obj2, key2);
  assert3(v19 != null);
  return v19;
}
function isNumber2(x17) {
  if (typeof x17 === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(String(x17)))
    return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x17));
}
function hasKey1(obj2, keys) {
  let o6 = obj2;
  keys.slice(0, -1).forEach((key3) => {
    o6 = get1(o6, key3) ?? {};
  });
  const key2 = keys[keys.length - 1];
  return key2 in o6;
}
function parse4(args, { "--": doubleDash = false, alias = {}, boolean: __boolean = false, default: defaults = {}, stopEarly = false, string = [], collect = [], unknown = (i) => i } = {}) {
  const flags = {
    bools: {},
    strings: {},
    unknownFn: unknown,
    allBools: false,
    collect: {}
  };
  if (__boolean !== void 0) {
    if (typeof __boolean === "boolean") {
      flags.allBools = !!__boolean;
    } else {
      const booleanArgs = typeof __boolean === "string" ? [
        __boolean
      ] : __boolean;
      for (const key2 of booleanArgs.filter(Boolean)) {
        flags.bools[key2] = true;
      }
    }
  }
  const aliases = {};
  if (alias !== void 0) {
    for (const key1 in alias) {
      const val = getForce1(alias, key1);
      if (typeof val === "string") {
        aliases[key1] = [
          val
        ];
      } else {
        aliases[key1] = val;
      }
      for (const alias1 of getForce1(aliases, key1)) {
        aliases[alias1] = [
          key1
        ].concat(aliases[key1].filter((y16) => alias1 !== y16));
      }
    }
  }
  if (string !== void 0) {
    const stringArgs = typeof string === "string" ? [
      string
    ] : string;
    for (const key2 of stringArgs.filter(Boolean)) {
      flags.strings[key2] = true;
      const alias2 = get1(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.strings[al] = true;
        }
      }
    }
  }
  if (collect !== void 0) {
    const collectArgs = typeof collect === "string" ? [
      collect
    ] : collect;
    for (const key3 of collectArgs.filter(Boolean)) {
      flags.collect[key3] = true;
      const alias3 = get1(aliases, key3);
      if (alias3) {
        for (const al1 of alias3) {
          flags.collect[al1] = true;
        }
      }
    }
  }
  const argv2 = {
    _: []
  };
  function argDefined(key2, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || get1(flags.bools, key2) || !!get1(flags.strings, key2) || !!get1(aliases, key2);
  }
  function setKey(obj2, name, value, collect2 = true) {
    let o6 = obj2;
    const keys = name.split(".");
    keys.slice(0, -1).forEach(function(key3) {
      if (get1(o6, key3) === void 0) {
        o6[key3] = {};
      }
      o6 = get1(o6, key3);
    });
    const key2 = keys[keys.length - 1];
    const collectable = collect2 && !!get1(flags.collect, name);
    if (!collectable) {
      o6[key2] = value;
    } else if (get1(o6, key2) === void 0) {
      o6[key2] = [
        value
      ];
    } else if (Array.isArray(get1(o6, key2))) {
      o6[key2].push(value);
    } else {
      o6[key2] = [
        get1(o6, key2),
        value
      ];
    }
  }
  function setArg(key2, val, arg = void 0, collect2) {
    if (arg && flags.unknownFn && !argDefined(key2, arg)) {
      if (flags.unknownFn(arg, key2, val) === false)
        return;
    }
    const value = !get1(flags.strings, key2) && isNumber2(val) ? Number(val) : val;
    setKey(argv2, key2, value, collect2);
    const alias2 = get1(aliases, key2);
    if (alias2) {
      for (const x17 of alias2) {
        setKey(argv2, x17, value, collect2);
      }
    }
  }
  function aliasIsBoolean(key2) {
    return getForce1(aliases, key2).some((x17) => typeof get1(flags.bools, x17) === "boolean");
  }
  let notFlags = [];
  if (args.includes("--")) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (/^--.+=/.test(arg)) {
      const m20 = arg.match(/^--([^=]+)=(.*)$/s);
      assert3(m20 != null);
      const [, key4, value] = m20;
      if (flags.bools[key4]) {
        const booleanValue = value !== "false";
        setArg(key4, booleanValue, arg);
      } else {
        setArg(key4, value, arg);
      }
    } else if (/^--no-.+/.test(arg)) {
      const m110 = arg.match(/^--no-(.+)/);
      assert3(m110 != null);
      setArg(m110[1], false, arg, false);
    } else if (/^--.+/.test(arg)) {
      const m22 = arg.match(/^--(.+)/);
      assert3(m22 != null);
      const [, key5] = m22;
      const next = args[i + 1];
      if (next !== void 0 && !/^-/.test(next) && !get1(flags.bools, key5) && !flags.allBools && (get1(aliases, key5) ? !aliasIsBoolean(key5) : true)) {
        setArg(key5, next, arg);
        i++;
      } else if (/^(true|false)$/.test(next)) {
        setArg(key5, next === "true", arg);
        i++;
      } else {
        setArg(key5, get1(flags.strings, key5) ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      const letters = arg.slice(1, -1).split("");
      let broken = false;
      for (let j13 = 0; j13 < letters.length; j13++) {
        const next1 = arg.slice(j13 + 2);
        if (next1 === "-") {
          setArg(letters[j13], next1, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letters[j13]) && /=/.test(next1)) {
          setArg(letters[j13], next1.split(/=(.+)/)[1], arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letters[j13]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next1)) {
          setArg(letters[j13], next1, arg);
          broken = true;
          break;
        }
        if (letters[j13 + 1] && letters[j13 + 1].match(/\W/)) {
          setArg(letters[j13], arg.slice(j13 + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letters[j13], get1(flags.strings, letters[j13]) ? "" : true, arg);
        }
      }
      const [key6] = arg.slice(-1);
      if (!broken && key6 !== "-") {
        if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get1(flags.bools, key6) && (get1(aliases, key6) ? !aliasIsBoolean(key6) : true)) {
          setArg(key6, args[i + 1], arg);
          i++;
        } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
          setArg(key6, args[i + 1] === "true", arg);
          i++;
        } else {
          setArg(key6, get1(flags.strings, key6) ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv2._.push(flags.strings["_"] ?? !isNumber2(arg) ? arg : Number(arg));
      }
      if (stopEarly) {
        argv2._.push(...args.slice(i + 1));
        break;
      }
    }
  }
  for (const [key7, value1] of Object.entries(defaults)) {
    if (!hasKey1(argv2, key7.split("."))) {
      setKey(argv2, key7, value1);
      if (aliases[key7]) {
        for (const x17 of aliases[key7]) {
          setKey(argv2, x17, value1);
        }
      }
    }
  }
  for (const key8 of Object.keys(flags.bools)) {
    if (!hasKey1(argv2, key8.split("."))) {
      const value2 = get1(flags.collect, key8) ? [] : false;
      setKey(argv2, key8, value2, false);
    }
  }
  for (const key9 of Object.keys(flags.strings)) {
    if (!hasKey1(argv2, key9.split(".")) && get1(flags.collect, key9)) {
      setKey(argv2, key9, [], false);
    }
  }
  if (doubleDash) {
    argv2["--"] = [];
    for (const key10 of notFlags) {
      argv2["--"].push(key10);
    }
  } else {
    for (const key11 of notFlags) {
      argv2._.push(key11);
    }
  }
  return argv2;
}
function getOptions1() {
  const args = parse4(Deno.args);
  const options = new Map(Object.entries(args).map(([key2, value]) => [
    key2,
    {
      value
    }
  ]));
  return {
    options
  };
}
var optionsMap1;
function getOptionsFromBinding1() {
  if (!optionsMap1) {
    ({ options: optionsMap1 } = getOptions1());
  }
  return optionsMap1;
}
function getOptionValue1(optionName) {
  const options = getOptionsFromBinding1();
  if (optionName.startsWith("--no-")) {
    const option = options.get("--" + optionName.slice(5));
    return option && !option.value;
  }
  return options.get(optionName)?.value;
}
var CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path6) {
  if (typeof path6 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path6)}`);
  }
}
function isPosixPathSeparator1(code2) {
  return code2 === 47;
}
function isPathSeparator1(code2) {
  return isPosixPathSeparator1(code2) || code2 === 92;
}
function isWindowsDeviceRoot1(code2) {
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
function normalizeString1(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH1;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format1(sep9, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base2;
  if (dir === pathObject.root)
    return dir + base2;
  return dir + sep9 + base2;
}
var WHITESPACE_ENCODINGS1 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace1(string) {
  return string.replaceAll(/[\s]/g, (c13) => {
    return WHITESPACE_ENCODINGS1[c13] ?? c13;
  });
}
var sep3 = "\\";
var delimiter3 = ";";
function resolve3(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno12 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno12.cwd();
    } else {
      if (typeof Deno12?.env?.get !== "function" || typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno12.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath1(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute9 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator1(code2)) {
        isAbsolute9 = true;
        if (isPathSeparator1(path6.charCodeAt(1))) {
          let j13 = 2;
          let last = j13;
          for (; j13 < len; ++j13) {
            if (isPathSeparator1(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            const firstPart = path6.slice(last, j13);
            last = j13;
            for (; j13 < len; ++j13) {
              if (!isPathSeparator1(path6.charCodeAt(j13)))
                break;
            }
            if (j13 < len && j13 !== last) {
              last = j13;
              for (; j13 < len; ++j13) {
                if (isPathSeparator1(path6.charCodeAt(j13)))
                  break;
              }
              if (j13 === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j13;
              } else if (j13 !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j13)}`;
                rootEnd = j13;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot1(code2)) {
        if (path6.charCodeAt(1) === 58) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator1(path6.charCodeAt(2))) {
              isAbsolute9 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator1(code2)) {
      rootEnd = 1;
      isAbsolute9 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute9;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path6) {
  assertPath1(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute9 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator1(code2)) {
      isAbsolute9 = true;
      if (isPathSeparator1(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator1(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          const firstPart = path6.slice(last, j13);
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator1(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator1(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j13 !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j13)}`;
              rootEnd = j13;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot1(code2)) {
      if (path6.charCodeAt(1) === 58) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator1(path6.charCodeAt(2))) {
            isAbsolute9 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator1(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString1(path6.slice(rootEnd), !isAbsolute9, "\\", isPathSeparator1);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute9)
    tail = ".";
  if (tail.length > 0 && isPathSeparator1(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute9) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute9) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute3(path6) {
  assertPath1(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator1(code2)) {
    return true;
  } else if (isWindowsDeviceRoot1(code2)) {
    if (len > 2 && path6.charCodeAt(1) === 58) {
      if (isPathSeparator1(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join6(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath1(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert3(firstPart != null);
  if (isPathSeparator1(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator1(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator1(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator1(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize4(joined);
}
function relative3(from6, to) {
  assertPath1(from6);
  assertPath1(to);
  if (from6 === to)
    return "";
  const fromOrig = resolve3(from6);
  const toOrig = resolve3(to);
  if (fromOrig === toOrig)
    return "";
  from6 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from6 === to)
    return "";
  let fromStart = 0;
  let fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== 92)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from6.charCodeAt(fromEnd - 1) !== 92)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== 92)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== 92)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 92) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from6.charCodeAt(fromStart + i) === 92) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 92)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from6.charCodeAt(i) === 92) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === 92)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath3(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve3(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === 92) {
      if (resolvedPath.charCodeAt(1) === 92) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== 63 && code2 !== 46) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname3(path6) {
  assertPath1(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator1(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator1(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator1(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator1(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator1(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              return path6;
            }
            if (j13 !== last) {
              rootEnd = offset = j13 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot1(code2)) {
      if (path6.charCodeAt(1) === 58) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator1(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator1(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator1(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename3(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath1(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot1(drive)) {
      if (path6.charCodeAt(1) === 58)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator1(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator1(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname3(path6) {
  assertPath1(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator1(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format5(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format1("\\", pathObject);
}
function parse5(path6) {
  assertPath1(path6);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator1(code2)) {
      rootEnd = 1;
      if (isPathSeparator1(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator1(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator1(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator1(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              rootEnd = j13;
            } else if (j13 !== last) {
              rootEnd = j13 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot1(code2)) {
      if (path6.charCodeAt(1) === 58) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator1(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator1(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator1(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl3(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl3(path6) {
  if (!isAbsolute3(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}
var mod64 = {
  sep: sep3,
  delimiter: delimiter3,
  resolve: resolve3,
  normalize: normalize4,
  isAbsolute: isAbsolute3,
  join: join6,
  relative: relative3,
  toNamespacedPath: toNamespacedPath3,
  dirname: dirname3,
  basename: basename3,
  extname: extname3,
  format: format5,
  parse: parse5,
  fromFileUrl: fromFileUrl3,
  toFileUrl: toFileUrl3
};
var sep4 = "/";
var delimiter4 = ":";
function resolve4(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno12 } = globalThis;
      if (typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno12.cwd();
    }
    assertPath1(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH1;
  }
  resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize5(path6) {
  assertPath1(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute9 = path6.charCodeAt(0) === 47;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === 47;
  path6 = normalizeString1(path6, !isAbsolute9, "/", isPosixPathSeparator1);
  if (path6.length === 0 && !isAbsolute9)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute9)
    return `/${path6}`;
  return path6;
}
function isAbsolute4(path6) {
  assertPath1(path6);
  return path6.length > 0 && path6.charCodeAt(0) === 47;
}
function join7(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath1(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize5(joined);
}
function relative4(from6, to) {
  assertPath1(from6);
  assertPath1(to);
  if (from6 === to)
    return "";
  from6 = resolve4(from6);
  to = resolve4(to);
  if (from6 === to)
    return "";
  let fromStart = 1;
  const fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== 47)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== 47)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 47) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from6.charCodeAt(fromStart + i) === 47) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 47)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from6.charCodeAt(i) === 47) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === 47)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath4(path6) {
  return path6;
}
function dirname4(path6) {
  assertPath1(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === 47;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === 47) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename4(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath1(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname4(path6) {
  assertPath1(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format6(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format1("/", pathObject);
}
function parse6(path6) {
  assertPath1(path6);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  if (path6.length === 0)
    return ret;
  const isAbsolute9 = path6.charCodeAt(0) === 47;
  let start;
  if (isAbsolute9) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute9) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute9) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute9)
    ret.dir = "/";
  return ret;
}
function fromFileUrl4(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path6) {
  if (!isAbsolute4(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace1(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}
var mod65 = {
  sep: sep4,
  delimiter: delimiter4,
  resolve: resolve4,
  normalize: normalize5,
  isAbsolute: isAbsolute4,
  join: join7,
  relative: relative4,
  toNamespacedPath: toNamespacedPath4,
  dirname: dirname4,
  basename: basename4,
  extname: extname4,
  format: format6,
  parse: parse6,
  fromFileUrl: fromFileUrl4,
  toFileUrl: toFileUrl4
};
var path22 = isWindows1 ? mod64 : mod65;
var { join: join8, normalize: normalize6 } = path22;
var path3 = isWindows1 ? mod64 : mod65;
var { basename: basename5, delimiter: delimiter5, dirname: dirname5, extname: extname5, format: format7, fromFileUrl: fromFileUrl5, isAbsolute: isAbsolute5, join: join9, normalize: normalize7, parse: parse7, relative: relative5, resolve: resolve5, sep: sep5, toFileUrl: toFileUrl5, toNamespacedPath: toNamespacedPath5 } = path3;
function _arch1() {
  if (Deno.build.arch == "x86_64") {
    return "x64";
  } else if (Deno.build.arch == "aarch64") {
    return "arm64";
  } else {
    throw Error("unreachable");
  }
}
var arch1 = _arch1();
var chdir1 = Deno.chdir;
var cwd1 = Deno.cwd;
var nextTick4 = nextTick3;
var env1 = new Proxy({}, {
  get(_target, prop) {
    return Deno.env.get(String(prop));
  },
  ownKeys: () => Reflect.ownKeys(Deno.env.toObject()),
  getOwnPropertyDescriptor: (_target, name) => {
    const e = Deno.env.toObject();
    if (name in Deno.env.toObject()) {
      const o6 = {
        enumerable: true,
        configurable: true
      };
      if (typeof name === "string") {
        o6.value = e[name];
      }
      return o6;
    }
  },
  set(_target, prop, value) {
    Deno.env.set(String(prop), String(value));
    return value;
  }
});
var pid1 = Deno.pid;
var platform1 = isWindows1 ? "win32" : Deno.build.os;
var version1 = "v16.11.1";
var versions1 = {
  node: "16.11.1",
  uv: "1.42.0",
  zlib: "1.2.11",
  brotli: "1.0.9",
  ares: "1.17.2",
  modules: "93",
  nghttp2: "1.45.1",
  napi: "8",
  llhttp: "6.0.4",
  openssl: "1.1.1l",
  cldr: "39.0",
  icu: "69.1",
  tz: "2021a",
  unicode: "13.0",
  ...Deno.version
};
function _uint8ArrayToBuffer1(chunk) {
  return Buffer1.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function isRequest2(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse1(stream) {
  return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable2(stream) {
  return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable2(stream) {
  return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished1(stream) {
  if (stream.writableFinished)
    return true;
  const wState = stream._writableState;
  if (!wState || wState.errored)
    return false;
  return wState.finished || wState.ended && wState.length === 0;
}
var nop3 = () => {
};
function isReadableEnded2(stream) {
  if (stream.readableEnded)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos1(stream, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  } else if (options == null) {
    options = {};
  } else {
    validateObject1(options, "options");
  }
  validateFunction1(callback, "callback");
  validateAbortSignal2(options.signal, "options.signal");
  callback = once22(callback);
  const readable = options.readable || options.readable !== false && isReadable2(stream);
  const writable = options.writable || options.writable !== false && isWritable2(stream);
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  const onlegacyfinish = () => {
    if (!stream.writable)
      onfinish();
  };
  let willEmitClose = isServerResponse1(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable2(stream) === readable && isWritable2(stream) === writable;
  let writableFinished = stream.writableFinished || wState && wState.finished;
  const onfinish = () => {
    writableFinished = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.readable || readable))
      return;
    if (!readable || readableEnded)
      callback.call(stream);
  };
  let readableEnded = stream.readableEnded || rState && rState.endEmitted;
  const onend = () => {
    readableEnded = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.writable || writable))
      return;
    if (!writable || writableFinished)
      callback.call(stream);
  };
  const onerror = (err) => {
    callback.call(stream, err);
  };
  const onclose = () => {
    if (readable && !readableEnded) {
      if (!isReadableEnded2(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE1());
      }
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished1(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE1());
      }
    }
    callback.call(stream);
  };
  const onrequest = () => {
    stream.req.on("finish", onfinish);
  };
  if (isRequest2(stream)) {
    stream.on("complete", onfinish);
    if (!willEmitClose) {
      stream.on("abort", onclose);
    }
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !wState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  if (!willEmitClose && typeof stream.aborted === "boolean") {
    stream.on("aborted", onclose);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (options.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
  if (closed) {
    nextTick3(() => {
      callback();
    });
  }
  const cleanup = () => {
    callback = nop3;
    stream.removeListener("aborted", onclose);
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
  if (options.signal && !closed) {
    const abort = () => {
      const endCallback = callback;
      cleanup();
      endCallback.call(stream, new AbortError1());
    };
    if (options.signal.aborted) {
      nextTick3(abort);
    } else {
      const originalCallback = callback;
      callback = once22((...args) => {
        options.signal.removeEventListener("abort", abort);
        originalCallback.apply(stream, args);
      });
      options.signal.addEventListener("abort", abort);
    }
  }
  return cleanup;
}
var validateAbortSignal3 = (signal, name) => {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    throw new ERR_INVALID_ARG_TYPE1(name, "AbortSignal", signal);
  }
};
function isStream1(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function");
}
function addAbortSignal1(signal, stream) {
  validateAbortSignal3(signal, "signal");
  if (!isStream1(stream)) {
    throw new ERR_INVALID_ARG_TYPE1("stream", "stream.Stream", stream);
  }
  return addAbortSignalNoValidate1(signal, stream);
}
function addAbortSignalNoValidate1(signal, stream) {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    return stream;
  }
  const onAbort = () => {
    stream.destroy(new AbortError1());
  };
  if (signal.aborted) {
    onAbort();
  } else {
    signal.addEventListener("abort", onAbort);
    eos1(stream, () => signal.removeEventListener("abort", onAbort));
  }
  return stream;
}
var kDestroy1 = Symbol("kDestroy");
var kConstruct1 = Symbol("kConstruct");
function checkError1(err, w24, r2) {
  if (err) {
    err.stack;
    if (w24 && !w24.errored) {
      w24.errored = err;
    }
    if (r2 && !r2.errored) {
      r2.errored = err;
    }
  }
}
function destroy3(err, cb) {
  const r2 = this._readableState;
  const w24 = this._writableState;
  const s10 = w24 || r2;
  if (w24 && w24.destroyed || r2 && r2.destroyed) {
    if (typeof cb === "function") {
      cb();
    }
    return this;
  }
  checkError1(err, w24, r2);
  if (w24) {
    w24.destroyed = true;
  }
  if (r2) {
    r2.destroyed = true;
  }
  if (!s10.constructed) {
    this.once(kDestroy1, function(er2) {
      _destroy1(this, aggregateTwoErrors1(er2, err), cb);
    });
  } else {
    _destroy1(this, err, cb);
  }
  return this;
}
function _destroy1(self1, err, cb) {
  let called = false;
  function onDestroy(err2) {
    if (called) {
      return;
    }
    called = true;
    const r2 = self1._readableState;
    const w24 = self1._writableState;
    checkError1(err2, w24, r2);
    if (w24) {
      w24.closed = true;
    }
    if (r2) {
      r2.closed = true;
    }
    if (typeof cb === "function") {
      cb(err2);
    }
    if (err2) {
      nextTick3(emitErrorCloseNT1, self1, err2);
    } else {
      nextTick3(emitCloseNT1, self1);
    }
  }
  try {
    const result = self1._destroy(err || null, onDestroy);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onDestroy, null);
        }, function(err2) {
          nextTick3(onDestroy, err2);
        });
      }
    }
  } catch (err1) {
    onDestroy(err1);
  }
}
function emitErrorCloseNT1(self1, err) {
  emitErrorNT1(self1, err);
  emitCloseNT1(self1);
}
function emitCloseNT1(self1) {
  const r2 = self1._readableState;
  const w24 = self1._writableState;
  if (w24) {
    w24.closeEmitted = true;
  }
  if (r2) {
    r2.closeEmitted = true;
  }
  if (w24 && w24.emitClose || r2 && r2.emitClose) {
    self1.emit("close");
  }
}
function emitErrorNT1(self1, err) {
  const r2 = self1._readableState;
  const w24 = self1._writableState;
  if (w24 && w24.errorEmitted || r2 && r2.errorEmitted) {
    return;
  }
  if (w24) {
    w24.errorEmitted = true;
  }
  if (r2) {
    r2.errorEmitted = true;
  }
  self1.emit("error", err);
}
function undestroy1() {
  const r2 = this._readableState;
  const w24 = this._writableState;
  if (r2) {
    r2.constructed = true;
    r2.closed = false;
    r2.closeEmitted = false;
    r2.destroyed = false;
    r2.errored = null;
    r2.errorEmitted = false;
    r2.reading = false;
    r2.ended = false;
    r2.endEmitted = false;
  }
  if (w24) {
    w24.constructed = true;
    w24.destroyed = false;
    w24.closed = false;
    w24.closeEmitted = false;
    w24.errored = null;
    w24.errorEmitted = false;
    w24.ended = false;
    w24.ending = false;
    w24.finalCalled = false;
    w24.prefinished = false;
    w24.finished = false;
  }
}
function errorOrDestroy3(stream, err, sync) {
  const r2 = stream._readableState;
  const w24 = stream._writableState;
  if (w24 && w24.destroyed || r2 && r2.destroyed) {
    return this;
  }
  if (r2 && r2.autoDestroy || w24 && w24.autoDestroy) {
    stream.destroy(err);
  } else if (err) {
    err.stack;
    if (w24 && !w24.errored) {
      w24.errored = err;
    }
    if (r2 && !r2.errored) {
      r2.errored = err;
    }
    if (sync) {
      nextTick3(emitErrorNT1, stream, err);
    } else {
      emitErrorNT1(stream, err);
    }
  }
}
function construct1(stream, cb) {
  if (typeof stream._construct !== "function") {
    return;
  }
  const r2 = stream._readableState;
  const w24 = stream._writableState;
  if (r2) {
    r2.constructed = false;
  }
  if (w24) {
    w24.constructed = false;
  }
  stream.once(kConstruct1, cb);
  if (stream.listenerCount(kConstruct1) > 1) {
    return;
  }
  nextTick3(constructNT1, stream);
}
function constructNT1(stream) {
  let called = false;
  function onConstruct(err) {
    if (called) {
      errorOrDestroy3(stream, err ?? new ERR_MULTIPLE_CALLBACK1());
      return;
    }
    called = true;
    const r2 = stream._readableState;
    const w24 = stream._writableState;
    const s10 = w24 || r2;
    if (r2) {
      r2.constructed = true;
    }
    if (w24) {
      w24.constructed = true;
    }
    if (s10.destroyed) {
      stream.emit(kDestroy1, err);
    } else if (err) {
      errorOrDestroy3(stream, err, true);
    } else {
      nextTick3(emitConstructNT1, stream);
    }
  }
  try {
    const result = stream._construct(onConstruct);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onConstruct, null);
        }, function(err) {
          nextTick3(onConstruct, err);
        });
      }
    }
  } catch (err) {
    onConstruct(err);
  }
}
function emitConstructNT1(stream) {
  stream.emit(kConstruct1);
}
function isRequest3(stream) {
  return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer2(stream, err) {
  if (!stream)
    return;
  if (isRequest3(stream))
    return stream.abort();
  if (isRequest3(stream.req))
    return stream.req.abort();
  if (typeof stream.destroy === "function")
    return stream.destroy(err);
  if (typeof stream.close === "function")
    return stream.close();
}
var __default15 = {
  construct: construct1,
  destroyer: destroyer2,
  destroy: destroy3,
  undestroy: undestroy1,
  errorOrDestroy: errorOrDestroy3
};
var kIsDisturbed1 = Symbol("kIsDisturbed");
function isReadableNodeStream1(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function" && typeof obj2.on === "function" && (!obj2._writableState || obj2._readableState?.readable !== false) && (!obj2._writableState || obj2._readableState));
}
function isWritableNodeStream1(obj2) {
  return !!(obj2 && typeof obj2.write === "function" && typeof obj2.on === "function" && (!obj2._readableState || obj2._writableState?.writable !== false));
}
function isDuplexNodeStream1(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function" && obj2._readableState && typeof obj2.on === "function" && typeof obj2.write === "function");
}
function isNodeStream1(obj2) {
  return obj2 && (obj2._readableState || obj2._writableState || typeof obj2.write === "function" && typeof obj2.on === "function" || typeof obj2.pipe === "function" && typeof obj2.on === "function");
}
function isIterable1(obj2, isAsync) {
  if (obj2 == null)
    return false;
  if (isAsync === true)
    return typeof obj2[Symbol.asyncIterator] === "function";
  if (isAsync === false)
    return typeof obj2[Symbol.iterator] === "function";
  return typeof obj2[Symbol.asyncIterator] === "function" || typeof obj2[Symbol.iterator] === "function";
}
function isDestroyed1(stream) {
  if (!isNodeStream1(stream))
    return null;
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded1(stream) {
  if (!isWritableNodeStream1(stream))
    return null;
  if (stream.writableEnded === true)
    return true;
  const wState = stream._writableState;
  if (wState?.errored)
    return false;
  if (typeof wState?.ended !== "boolean")
    return null;
  return wState.ended;
}
function isReadableEnded3(stream) {
  if (!isReadableNodeStream1(stream))
    return null;
  if (stream.readableEnded === true)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  if (typeof rState?.ended !== "boolean")
    return null;
  return rState.ended;
}
function isReadableFinished1(stream, strict) {
  if (!isReadableNodeStream1(stream))
    return null;
  const rState = stream._readableState;
  if (rState?.errored)
    return false;
  if (typeof rState?.endEmitted !== "boolean")
    return null;
  return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed1(stream) {
  return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed1]));
}
function isReadable3(stream) {
  const r2 = isReadableNodeStream1(stream);
  if (r2 === null || typeof stream?.readable !== "boolean")
    return null;
  if (isDestroyed1(stream))
    return false;
  return r2 && stream.readable && !isReadableFinished1(stream);
}
function isWritable3(stream) {
  const r2 = isWritableNodeStream1(stream);
  if (r2 === null || typeof stream?.writable !== "boolean")
    return null;
  if (isDestroyed1(stream))
    return false;
  return r2 && stream.writable && !isWritableEnded1(stream);
}
var stdio1 = {};
function isBlob1(object) {
  return object instanceof Blob;
}
function _from3(Readable2, iterable, opts) {
  let iterator;
  if (typeof iterable === "string" || iterable instanceof Buffer1) {
    return new Readable2({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable);
        this.push(null);
      }
    });
  }
  let isAsync;
  if (iterable && iterable[Symbol.asyncIterator]) {
    isAsync = true;
    iterator = iterable[Symbol.asyncIterator]();
  } else if (iterable && iterable[Symbol.iterator]) {
    isAsync = false;
    iterator = iterable[Symbol.iterator]();
  } else {
    throw new ERR_INVALID_ARG_TYPE1("iterable", [
      "Iterable"
    ], iterable);
  }
  const readable = new Readable2({
    objectMode: true,
    highWaterMark: 1,
    ...opts
  });
  let reading = false;
  readable._read = function() {
    if (!reading) {
      reading = true;
      next();
    }
  };
  readable._destroy = function(error2, cb) {
    close(error2).then(() => nextTick4(cb, error2), (e) => nextTick4(cb, e || error2));
  };
  async function close(error2) {
    const hadError = error2 !== void 0 && error2 !== null;
    const hasThrow = typeof iterator.throw === "function";
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error2);
      await value;
      if (done) {
        return;
      }
    }
    if (typeof iterator.return === "function") {
      const { value: value1 } = await iterator.return();
      await value1;
    }
  }
  async function next() {
    for (; ; ) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next();
        if (done) {
          readable.push(null);
        } else {
          const res = value && typeof value.then === "function" ? await value : value;
          if (res === null) {
            reading = false;
            throw new ERR_STREAM_NULL_VALUES1();
          } else if (readable.push(res)) {
            continue;
          } else {
            reading = false;
          }
        }
      } catch (err) {
        readable.destroy(err);
      }
      break;
    }
  }
  return readable;
}
function highWaterMarkFrom1(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark1(objectMode) {
  return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark1(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom1(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!Number.isInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
      throw new ERR_INVALID_ARG_VALUE1(name, hwm);
    }
    return Math.floor(hwm);
  }
  return getDefaultHighWaterMark1(state.objectMode);
}
function Stream1(opts) {
  EventEmitter1.call(this, opts);
}
Object.setPrototypeOf(Stream1.prototype, EventEmitter1.prototype);
Object.setPrototypeOf(Stream1, EventEmitter1);
Stream1.prototype.pipe = function(dest, options) {
  const source = this;
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause();
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  let didOnEnd = false;
  function onend() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er2) {
    cleanup();
    if (EventEmitter1.listenerCount(this, "error") === 0) {
      this.emit("error", er2);
    }
  }
  prependListener1(source, "error", onerror);
  prependListener1(dest, "error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
function prependListener1(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  }
  if (!emitter._events || !emitter._events[event]) {
    emitter.on(event, fn);
  } else if (Array.isArray(emitter._events[event])) {
    emitter._events[event].unshift(fn);
  } else {
    emitter._events[event] = [
      fn,
      emitter._events[event]
    ];
  }
}
var NotImplemented1;
(function(NotImplemented2) {
  NotImplemented2[NotImplemented2["ascii"] = 0] = "ascii";
  NotImplemented2[NotImplemented2["latin1"] = 1] = "latin1";
  NotImplemented2[NotImplemented2["utf16le"] = 2] = "utf16le";
})(NotImplemented1 || (NotImplemented1 = {}));
function normalizeEncoding5(enc) {
  const encoding = normalizeEncoding3(enc ?? null);
  if (encoding && encoding in NotImplemented1)
    notImplemented1(encoding);
  if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
    throw new Error(`Unknown encoding: ${enc}`);
  }
  return String(encoding);
}
function utf8CheckByte1(__byte) {
  if (__byte <= 127)
    return 0;
  else if (__byte >> 5 === 6)
    return 2;
  else if (__byte >> 4 === 14)
    return 3;
  else if (__byte >> 3 === 30)
    return 4;
  return __byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete1(self1, buf, i) {
  let j13 = buf.length - 1;
  if (j13 < i)
    return 0;
  let nb = utf8CheckByte1(buf[j13]);
  if (nb >= 0) {
    if (nb > 0)
      self1.lastNeed = nb - 1;
    return nb;
  }
  if (--j13 < i || nb === -2)
    return 0;
  nb = utf8CheckByte1(buf[j13]);
  if (nb >= 0) {
    if (nb > 0)
      self1.lastNeed = nb - 2;
    return nb;
  }
  if (--j13 < i || nb === -2)
    return 0;
  nb = utf8CheckByte1(buf[j13]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self1.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes1(self1, buf) {
  if ((buf[0] & 192) !== 128) {
    self1.lastNeed = 0;
    return "\uFFFD";
  }
  if (self1.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self1.lastNeed = 1;
      return "\uFFFD";
    }
    if (self1.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self1.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}
function utf8FillLastComplete1(buf) {
  const p7 = this.lastTotal - this.lastNeed;
  const r2 = utf8CheckExtraBytes1(this, buf);
  if (r2 !== void 0)
    return r2;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p7, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p7, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete1(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text1(buf, i) {
  const total = utf8CheckIncomplete1(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  const end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i, end);
}
function utf8End1(buf) {
  const r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + "\uFFFD";
  return r2;
}
function utf8Write1(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  if (buf.length === 0)
    return "";
  let r2;
  let i;
  if (this.lastNeed) {
    r2 = this.fillLast(buf);
    if (r2 === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r2 ? r2 + this.text(buf, i) : this.text(buf, i);
  return r2 || "";
}
function base64Text1(buf, i) {
  const n3 = (buf.length - i) % 3;
  if (n3 === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n3;
  this.lastTotal = 3;
  if (n3 === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n3);
}
function base64End1(buf) {
  const r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  }
  return r2;
}
function simpleWrite1(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  return buf.toString(this.encoding);
}
function simpleEnd1(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var StringDecoderBase1 = class {
  lastChar;
  lastNeed;
  lastTotal;
  constructor(encoding, nb) {
    this.encoding = encoding;
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer1.allocUnsafe(nb);
  }
  encoding;
};
var Base64Decoder1 = class extends StringDecoderBase1 {
  end = base64End1;
  fillLast = utf8FillLastIncomplete1;
  text = base64Text1;
  write = utf8Write1;
  constructor(encoding) {
    super(normalizeEncoding5(encoding), 3);
  }
};
var GenericDecoder1 = class extends StringDecoderBase1 {
  end = simpleEnd1;
  fillLast = void 0;
  text = utf8Text1;
  write = simpleWrite1;
  constructor(encoding) {
    super(normalizeEncoding5(encoding), 4);
  }
};
var Utf8Decoder1 = class extends StringDecoderBase1 {
  end = utf8End1;
  fillLast = utf8FillLastComplete1;
  text = utf8Text1;
  write = utf8Write1;
  constructor(encoding) {
    super(normalizeEncoding5(encoding), 4);
  }
};
var StringDecoder1 = class {
  encoding;
  end;
  fillLast;
  lastChar;
  lastNeed;
  lastTotal;
  text;
  write;
  constructor(encoding) {
    let decoder2;
    switch (encoding) {
      case "utf8":
        decoder2 = new Utf8Decoder1(encoding);
        break;
      case "base64":
        decoder2 = new Base64Decoder1(encoding);
        break;
      default:
        decoder2 = new GenericDecoder1(encoding);
    }
    this.encoding = decoder2.encoding;
    this.end = decoder2.end;
    this.fillLast = decoder2.fillLast;
    this.lastChar = decoder2.lastChar;
    this.lastNeed = decoder2.lastNeed;
    this.lastTotal = decoder2.lastTotal;
    this.text = decoder2.text;
    this.write = decoder2.write;
  }
};
var PStringDecoder1 = new Proxy(StringDecoder1, {
  apply(_target, thisArg, args) {
    return Object.assign(thisArg, new StringDecoder1(...args));
  }
});
var __default16 = {
  StringDecoder: PStringDecoder1
};
var BufferList1 = class {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(v19) {
    const entry = {
      data: v19,
      next: null
    };
    if (this.length > 0) {
      this.tail.next = entry;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    ++this.length;
  }
  unshift(v19) {
    const entry = {
      data: v19,
      next: this.head
    };
    if (this.length === 0) {
      this.tail = entry;
    }
    this.head = entry;
    ++this.length;
  }
  shift() {
    if (this.length === 0) {
      return;
    }
    const ret = this.head.data;
    if (this.length === 1) {
      this.head = this.tail = null;
    } else {
      this.head = this.head.next;
    }
    --this.length;
    return ret;
  }
  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }
  join(s10) {
    if (this.length === 0) {
      return "";
    }
    let p7 = this.head;
    let ret = "" + p7.data;
    while (p7 = p7.next) {
      ret += s10 + p7.data;
    }
    return ret;
  }
  concat(n3) {
    if (this.length === 0) {
      return Buffer1.alloc(0);
    }
    const ret = Buffer1.allocUnsafe(n3 >>> 0);
    let p7 = this.head;
    let i = 0;
    while (p7) {
      ret.set(p7.data, i);
      i += p7.data.length;
      p7 = p7.next;
    }
    return ret;
  }
  consume(n3, hasStrings) {
    const data = this.head.data;
    if (n3 < data.length) {
      const slice6 = data.slice(0, n3);
      this.head.data = data.slice(n3);
      return slice6;
    }
    if (n3 === data.length) {
      return this.shift();
    }
    return hasStrings ? this._getString(n3) : this._getBuffer(n3);
  }
  first() {
    return this.head.data;
  }
  *[Symbol.iterator]() {
    for (let p7 = this.head; p7; p7 = p7.next) {
      yield p7.data;
    }
  }
  _getString(n3) {
    let ret = "";
    let p7 = this.head;
    let c13 = 0;
    do {
      const str = p7.data;
      if (n3 > str.length) {
        ret += str;
        n3 -= str.length;
      } else {
        if (n3 === str.length) {
          ret += str;
          ++c13;
          if (p7.next) {
            this.head = p7.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret += str.slice(0, n3);
          this.head = p7;
          p7.data = str.slice(n3);
        }
        break;
      }
      ++c13;
    } while (p7 = p7.next);
    this.length -= c13;
    return ret;
  }
  _getBuffer(n3) {
    const ret = Buffer1.allocUnsafe(n3);
    const retLen = n3;
    let p7 = this.head;
    let c13 = 0;
    do {
      const buf = p7.data;
      if (n3 > buf.length) {
        ret.set(buf, retLen - n3);
        n3 -= buf.length;
      } else {
        if (n3 === buf.length) {
          ret.set(buf, retLen - n3);
          ++c13;
          if (p7.next) {
            this.head = p7.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), retLen - n3);
          this.head = p7;
          p7.data = buf.slice(n3);
        }
        break;
      }
      ++c13;
    } while (p7 = p7.next);
    this.length -= c13;
    return ret;
  }
  [inspect22.custom](_11, options) {
    return inspect22(this, {
      ...options,
      depth: 0,
      customInspect: false
    });
  }
};
var debug1 = debuglog1("stream", (fn) => {
  debug1 = fn;
});
var kPaused1 = Symbol("kPaused");
Object.setPrototypeOf(Readable1.prototype, Stream1.prototype);
Object.setPrototypeOf(Readable1, Stream1);
var nop4 = () => {
};
var { errorOrDestroy: errorOrDestroy4 } = __default15;
function ReadableState1(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = stream instanceof Stream1.Duplex;
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark1(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark1(false);
  this.buffer = new BufferList1();
  this.length = 0;
  this.pipes = [];
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.constructed = true;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this[kPaused1] = null;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.destroyed = false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.awaitDrainWriters = null;
  this.multiAwaitDrain = false;
  this.readingMore = false;
  this.dataEmitted = false;
  this.decoder = null;
  this.encoding = null;
  if (options && options.encoding) {
    this.decoder = new StringDecoder1(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable1(options) {
  if (!(this instanceof Readable1)) {
    return new Readable1(options);
  }
  const isDuplex = this instanceof Stream1.Duplex;
  this._readableState = new ReadableState1(options, this, isDuplex);
  if (options) {
    if (typeof options.read === "function") {
      this._read = options.read;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal && !isDuplex) {
      addAbortSignalNoValidate1(options.signal, this);
    }
  }
  Stream1.call(this, options);
  __default15.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore1(this, this._readableState);
    }
  });
}
Readable1.prototype.destroy = __default15.destroy;
Readable1.prototype._undestroy = __default15.undestroy;
Readable1.prototype._destroy = function(err, cb) {
  cb(err);
};
Readable1.prototype[EventEmitter1.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Readable1.prototype.push = function(chunk, encoding) {
  return readableAddChunk1(this, chunk, encoding, false);
};
Readable1.prototype.unshift = function(chunk, encoding) {
  return readableAddChunk1(this, chunk, encoding, true);
};
function readableAddChunk1(stream, chunk, encoding, addToFront) {
  debug1("readableAddChunk", chunk);
  const state = stream._readableState;
  let err;
  if (!state.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          chunk = Buffer1.from(chunk, encoding).toString(state.encoding);
        } else {
          chunk = Buffer1.from(chunk, encoding);
          encoding = "";
        }
      }
    } else if (chunk instanceof Buffer1) {
      encoding = "";
    } else if (Stream1._isUint8Array(chunk)) {
      chunk = Stream1._uint8ArrayToBuffer(chunk);
      encoding = "";
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE1("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
      ], chunk);
    }
  }
  if (err) {
    errorOrDestroy4(stream, err);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk1(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (addToFront) {
      if (state.endEmitted) {
        errorOrDestroy4(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT1());
      } else {
        addChunk1(stream, state, chunk, true);
      }
    } else if (state.ended) {
      errorOrDestroy4(stream, new ERR_STREAM_PUSH_AFTER_EOF1());
    } else if (state.destroyed || state.errored) {
      return false;
    } else {
      state.reading = false;
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk);
        if (state.objectMode || chunk.length !== 0) {
          addChunk1(stream, state, chunk, false);
        } else {
          maybeReadMore1(stream, state);
        }
      } else {
        addChunk1(stream, state, chunk, false);
      }
    }
  } else if (!addToFront) {
    state.reading = false;
    maybeReadMore1(stream, state);
  }
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk1(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
    state.dataEmitted = true;
    stream.emit("data", chunk);
  } else {
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) {
      state.buffer.unshift(chunk);
    } else {
      state.buffer.push(chunk);
    }
    if (state.needReadable) {
      emitReadable1(stream);
    }
  }
  maybeReadMore1(stream, state);
}
Readable1.prototype.isPaused = function() {
  const state = this._readableState;
  return state[kPaused1] === true || state.flowing === false;
};
Readable1.prototype.setEncoding = function(enc) {
  const decoder2 = new StringDecoder1(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  const buffer = this._readableState.buffer;
  let content = "";
  for (const data of buffer) {
    content += decoder2.write(data);
  }
  buffer.clear();
  if (content !== "") {
    buffer.push(content);
  }
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM1 = 1073741824;
function computeNewHighWaterMark1(n3) {
  if (n3 >= 1073741824) {
    n3 = MAX_HWM1;
  } else {
    n3--;
    n3 |= n3 >>> 1;
    n3 |= n3 >>> 2;
    n3 |= n3 >>> 4;
    n3 |= n3 >>> 8;
    n3 |= n3 >>> 16;
    n3++;
  }
  return n3;
}
function howMuchToRead1(n3, state) {
  if (n3 <= 0 || state.length === 0 && state.ended) {
    return 0;
  }
  if (state.objectMode) {
    return 1;
  }
  if (Number.isNaN(n3)) {
    if (state.flowing && state.length) {
      return state.buffer.first().length;
    }
    return state.length;
  }
  if (n3 <= state.length) {
    return n3;
  }
  return state.ended ? state.length : 0;
}
Readable1.prototype.read = function(n3) {
  debug1("read", n3);
  if (n3 === void 0) {
    n3 = NaN;
  } else if (!Number.isInteger(n3)) {
    n3 = Number.parseInt(n3, 10);
  }
  const state = this._readableState;
  const nOrig = n3;
  if (n3 > state.highWaterMark) {
    state.highWaterMark = computeNewHighWaterMark1(n3);
  }
  if (n3 !== 0) {
    state.emittedReadable = false;
  }
  if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug1("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended) {
      endReadable1(this);
    } else {
      emitReadable1(this);
    }
    return null;
  }
  n3 = howMuchToRead1(n3, state);
  if (n3 === 0 && state.ended) {
    if (state.length === 0) {
      endReadable1(this);
    }
    return null;
  }
  let doRead = state.needReadable;
  debug1("need readable", doRead);
  if (state.length === 0 || state.length - n3 < state.highWaterMark) {
    doRead = true;
    debug1("length less than watermark", doRead);
  }
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false;
    debug1("reading, ended or constructing", doRead);
  } else if (doRead) {
    debug1("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0) {
      state.needReadable = true;
    }
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading) {
      n3 = howMuchToRead1(nOrig, state);
    }
  }
  let ret;
  if (n3 > 0) {
    ret = fromList1(n3, state);
  } else {
    ret = null;
  }
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n3 = 0;
  } else {
    state.length -= n3;
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
  }
  if (state.length === 0) {
    if (!state.ended) {
      state.needReadable = true;
    }
    if (nOrig !== n3 && state.ended) {
      endReadable1(this);
    }
  }
  if (ret !== null) {
    state.dataEmitted = true;
    this.emit("data", ret);
  }
  return ret;
};
function onEofChunk1(stream, state) {
  debug1("onEofChunk");
  if (state.ended)
    return;
  if (state.decoder) {
    const chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    emitReadable1(stream);
  } else {
    state.needReadable = false;
    state.emittedReadable = true;
    emitReadable_1(stream);
  }
}
function emitReadable1(stream) {
  const state = stream._readableState;
  debug1("emitReadable", state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug1("emitReadable", state.flowing);
    state.emittedReadable = true;
    nextTick3(emitReadable_1, stream);
  }
}
function emitReadable_1(stream) {
  const state = stream._readableState;
  debug1("emitReadable_", state.destroyed, state.length, state.ended);
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit("readable");
    state.emittedReadable = false;
  }
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow1(stream);
}
function maybeReadMore1(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true;
    nextTick3(maybeReadMore_1, stream, state);
  }
}
function maybeReadMore_1(stream, state) {
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    const len = state.length;
    debug1("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length) {
      break;
    }
  }
  state.readingMore = false;
}
Readable1.prototype._read = function(n3) {
  throw new ERR_METHOD_NOT_IMPLEMENTED1("_read()");
};
Readable1.prototype.pipe = function(dest, pipeOpts) {
  const src = this;
  const state = this._readableState;
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true;
      state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [
        state.awaitDrainWriters
      ] : []);
    }
  }
  state.pipes.push(dest);
  debug1("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio1.stdout && dest !== stdio1.stderr;
  const endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) {
    nextTick3(endFn);
  } else {
    src.once("end", endFn);
  }
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug1("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug1("onend");
    dest.end();
  }
  let ondrain;
  let cleanedUp = false;
  function cleanup() {
    debug1("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    if (ondrain) {
      dest.removeListener("drain", ondrain);
    }
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
      ondrain();
    }
  }
  function pause() {
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug1("false write response, pause", 0);
        state.awaitDrainWriters = dest;
        state.multiAwaitDrain = false;
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug1("false write response, pause", state.awaitDrainWriters.size);
        state.awaitDrainWriters.add(dest);
      }
      src.pause();
    }
    if (!ondrain) {
      ondrain = pipeOnDrain1(src, dest);
      dest.on("drain", ondrain);
    }
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug1("ondata");
    const ret = dest.write(chunk);
    debug1("dest.write", ret);
    if (ret === false) {
      pause();
    }
  }
  function onerror(er2) {
    debug1("onerror", er2);
    unpipe();
    dest.removeListener("error", onerror);
    if (EventEmitter1.listenerCount(dest, "error") === 0) {
      const s10 = dest._writableState || dest._readableState;
      if (s10 && !s10.errorEmitted) {
        errorOrDestroy4(dest, er2);
      } else {
        dest.emit("error", er2);
      }
    }
  }
  prependListener1(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug1("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug1("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause();
    }
  } else if (!state.flowing) {
    debug1("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain1(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState;
    if (state.awaitDrainWriters === dest) {
      debug1("pipeOnDrain", 1);
      state.awaitDrainWriters = null;
    } else if (state.multiAwaitDrain) {
      debug1("pipeOnDrain", state.awaitDrainWriters.size);
      state.awaitDrainWriters.delete(dest);
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && EventEmitter1.listenerCount(src, "data")) {
      state.flowing = true;
      flow1(src);
    }
  };
}
Readable1.prototype.unpipe = function(dest) {
  const state = this._readableState;
  const unpipeInfo = {
    hasUnpiped: false
  };
  if (state.pipes.length === 0) {
    return this;
  }
  if (!dest) {
    const dests = state.pipes;
    state.pipes = [];
    this.pause();
    for (let i = 0; i < dests.length; i++) {
      dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  const index = state.pipes.indexOf(dest);
  if (index === -1) {
    return this;
  }
  state.pipes.splice(index, 1);
  if (state.pipes.length === 0) {
    this.pause();
  }
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable1.prototype.on = function(ev, fn) {
  const res = Stream1.prototype.on.call(this, ev, fn);
  const state = this._readableState;
  if (ev === "data") {
    state.readableListening = this.listenerCount("readable") > 0;
    if (state.flowing !== false) {
      this.resume();
    }
  } else if (ev === "readable") {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug1("on readable", state.length, state.reading);
      if (state.length) {
        emitReadable1(this);
      } else if (!state.reading) {
        nextTick3(nReadingNextTick1, this);
      }
    }
  }
  return res;
};
Readable1.prototype.addListener = Readable1.prototype.on;
Readable1.prototype.removeListener = function(ev, fn) {
  const res = Stream1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    nextTick3(updateReadableListening1, this);
  }
  return res;
};
Readable1.prototype.off = Readable1.prototype.removeListener;
Readable1.prototype.removeAllListeners = function(ev) {
  const res = Stream1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    nextTick3(updateReadableListening1, this);
  }
  return res;
};
function updateReadableListening1(self1) {
  const state = self1._readableState;
  state.readableListening = self1.listenerCount("readable") > 0;
  if (state.resumeScheduled && state[kPaused1] === false) {
    state.flowing = true;
  } else if (self1.listenerCount("data") > 0) {
    self1.resume();
  } else if (!state.readableListening) {
    state.flowing = null;
  }
}
function nReadingNextTick1(self1) {
  debug1("readable nexttick read 0");
  self1.read(0);
}
Readable1.prototype.resume = function() {
  const state = this._readableState;
  if (!state.flowing) {
    debug1("resume");
    state.flowing = !state.readableListening;
    resume1(this, state);
  }
  state[kPaused1] = false;
  return this;
};
function resume1(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick3(resume_1, stream, state);
  }
}
function resume_1(stream, state) {
  debug1("resume", state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit("resume");
  flow1(stream);
  if (state.flowing && !state.reading) {
    stream.read(0);
  }
}
Readable1.prototype.pause = function() {
  debug1("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug1("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState[kPaused1] = true;
  return this;
};
function flow1(stream) {
  const state = stream._readableState;
  debug1("flow", state.flowing);
  while (state.flowing && stream.read() !== null)
    ;
}
Readable1.prototype.wrap = function(stream) {
  let paused = false;
  stream.on("data", (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true;
      stream.pause();
    }
  });
  stream.on("end", () => {
    this.push(null);
  });
  stream.on("error", (err) => {
    errorOrDestroy4(this, err);
  });
  stream.on("close", () => {
    this.destroy();
  });
  stream.on("destroy", () => {
    this.destroy();
  });
  this._read = () => {
    if (paused && stream.resume) {
      paused = false;
      stream.resume();
    }
  };
  const streamKeys = Object.keys(stream);
  for (let j13 = 1; j13 < streamKeys.length; j13++) {
    const i = streamKeys[j13];
    if (this[i] === void 0 && typeof stream[i] === "function") {
      this[i] = stream[i].bind(stream);
    }
  }
  return this;
};
Readable1.prototype[Symbol.asyncIterator] = function() {
  return streamToAsyncIterator1(this);
};
Readable1.prototype.iterator = function(options) {
  if (options !== void 0) {
    validateObject1(options, "options");
  }
  return streamToAsyncIterator1(this, options);
};
function streamToAsyncIterator1(stream, options) {
  if (typeof stream.read !== "function") {
    stream = Readable1.wrap(stream, {
      objectMode: true
    });
  }
  const iter = createAsyncIterator1(stream, options);
  iter.stream = stream;
  return iter;
}
async function* createAsyncIterator1(stream, options) {
  let callback = nop4;
  const opts = {
    destroyOnReturn: true,
    destroyOnError: true,
    ...options
  };
  function next(resolve9) {
    if (this === stream) {
      callback();
      callback = nop4;
    } else {
      callback = resolve9;
    }
  }
  const state = stream._readableState;
  let error2 = state.errored;
  let errorEmitted = state.errorEmitted;
  let endEmitted = state.endEmitted;
  let closeEmitted = state.closeEmitted;
  stream.on("readable", next).on("error", function(err) {
    error2 = err;
    errorEmitted = true;
    next.call(this);
  }).on("end", function() {
    endEmitted = true;
    next.call(this);
  }).on("close", function() {
    closeEmitted = true;
    next.call(this);
  });
  let errorThrown = false;
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read();
      if (chunk !== null) {
        yield chunk;
      } else if (errorEmitted) {
        throw error2;
      } else if (endEmitted) {
        break;
      } else if (closeEmitted) {
        break;
      } else {
        await new Promise(next);
      }
    }
  } catch (err) {
    if (opts.destroyOnError) {
      __default15.destroyer(stream, err);
    }
    errorThrown = true;
    throw err;
  } finally {
    if (!errorThrown && opts.destroyOnReturn) {
      if (state.autoDestroy || !endEmitted) {
        __default15.destroyer(stream, null);
      }
    }
  }
}
Object.defineProperties(Readable1.prototype, {
  readable: {
    get() {
      const r2 = this._readableState;
      return !!r2 && r2.readable !== false && !r2.destroyed && !r2.errorEmitted && !r2.endEmitted;
    },
    set(val) {
      if (this._readableState) {
        this._readableState.readable = !!val;
      }
    }
  },
  readableDidRead: {
    enumerable: false,
    get: function() {
      return this._readableState.dataEmitted;
    }
  },
  readableAborted: {
    enumerable: false,
    get: function() {
      return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
    }
  },
  readableHighWaterMark: {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  },
  readableBuffer: {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  },
  readableFlowing: {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  },
  readableLength: {
    enumerable: false,
    get() {
      return this._readableState.length;
    }
  },
  readableObjectMode: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false;
    }
  },
  readableEncoding: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null;
    }
  },
  destroyed: {
    enumerable: false,
    get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  },
  readableEnded: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false;
    }
  }
});
Object.defineProperties(ReadableState1.prototype, {
  pipesCount: {
    get() {
      return this.pipes.length;
    }
  },
  paused: {
    get() {
      return this[kPaused1] !== false;
    },
    set(value) {
      this[kPaused1] = !!value;
    }
  }
});
function fromList1(n3, state) {
  if (state.length === 0) {
    return null;
  }
  let ret;
  if (state.objectMode) {
    ret = state.buffer.shift();
  } else if (!n3 || n3 >= state.length) {
    if (state.decoder) {
      ret = state.buffer.join("");
    } else if (state.buffer.length === 1) {
      ret = state.buffer.first();
    } else {
      ret = state.buffer.concat(state.length);
    }
    state.buffer.clear();
  } else {
    ret = state.buffer.consume(n3, state.decoder);
  }
  return ret;
}
function endReadable1(stream) {
  const state = stream._readableState;
  debug1("endReadable", state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    nextTick3(endReadableNT1, state, stream);
  }
}
function endReadableNT1(state, stream) {
  debug1("endReadableNT", state.endEmitted, state.length);
  if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.emit("end");
    if (stream.writable && stream.allowHalfOpen === false) {
      nextTick3(endWritableNT1, stream);
    } else if (state.autoDestroy) {
      const wState = stream._writableState;
      const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
}
function endWritableNT1(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
  if (writable) {
    stream.end();
  }
}
function readableFrom1(iterable, opts) {
  return _from3(Readable1, iterable, opts);
}
function wrap1(src, options) {
  return new Readable1({
    objectMode: src.readableObjectMode ?? src.objectMode ?? true,
    ...options,
    destroy(err, callback) {
      __default15.destroyer(src, err);
      callback(err);
    }
  }).wrap(src);
}
Readable1._fromList = fromList1;
Readable1.ReadableState = ReadableState1;
Readable1.from = readableFrom1;
Readable1.wrap = wrap1;
var { errorOrDestroy: errorOrDestroy5 } = __default15;
function isDuplexStream1(maybe_duplex) {
  const isReadable4 = Readable1.prototype.isPrototypeOf(maybe_duplex);
  let prototype = maybe_duplex;
  let isDuplex = false;
  while (prototype?.constructor && prototype.constructor.name !== "Object") {
    if (prototype.constructor.name === "Duplex") {
      isDuplex = true;
      break;
    }
    prototype = Object.getPrototypeOf(prototype);
  }
  return isReadable4 && isDuplex;
}
Object.setPrototypeOf(Writable1.prototype, Stream1.prototype);
Object.setPrototypeOf(Writable1, Stream1);
function nop5() {
}
var kOnFinished1 = Symbol("kOnFinished");
function WritableState1(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = isDuplexStream1(stream);
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark1(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark1(false);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  const noDecode = !!(options && options.decodeStrings === false);
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = onwrite1.bind(void 0, stream);
  this.writecb = null;
  this.writelen = 0;
  this.afterWriteTickInfo = null;
  resetBuffer1(this);
  this.pendingcb = 0;
  this.constructed = true;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this[kOnFinished1] = [];
}
function resetBuffer1(state) {
  state.buffered = [];
  state.bufferedIndex = 0;
  state.allBuffers = true;
  state.allNoop = true;
}
WritableState1.prototype.getBuffer = function getBuffer2() {
  return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState1.prototype, "bufferedRequestCount", {
  get() {
    return this.buffered.length - this.bufferedIndex;
  }
});
function Writable1(options) {
  const isDuplex = isDuplexStream1(this);
  if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable1, this)) {
    return new Writable1(options);
  }
  this._writableState = new WritableState1(options, this, isDuplex);
  if (options) {
    if (typeof options.write === "function") {
      this._write = options.write;
    }
    if (typeof options.writev === "function") {
      this._writev = options.writev;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.final === "function") {
      this._final = options.final;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal) {
      addAbortSignalNoValidate1(options.signal, this);
    }
  }
  Stream1.call(this, options);
  __default15.construct(this, () => {
    const state = this._writableState;
    if (!state.writing) {
      clearBuffer1(this, state);
    }
    finishMaybe1(this, state);
  });
}
Object.defineProperty(Writable1, Symbol.hasInstance, {
  value: function(object) {
    if (Function.prototype[Symbol.hasInstance].call(this, object))
      return true;
    if (this !== Writable1)
      return false;
    return object && object._writableState instanceof WritableState1;
  }
});
Writable1.prototype.pipe = function() {
  errorOrDestroy5(this, new ERR_STREAM_CANNOT_PIPE1());
};
function _write1(stream, chunk, encoding, cb) {
  const state = stream._writableState;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = state.defaultEncoding;
  } else {
    if (!encoding) {
      encoding = state.defaultEncoding;
    } else if (encoding !== "buffer" && !Buffer1.isEncoding(encoding)) {
      throw new ERR_UNKNOWN_ENCODING1(encoding);
    }
    if (typeof cb !== "function") {
      cb = nop5;
    }
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES1();
  } else if (!state.objectMode) {
    if (typeof chunk === "string") {
      if (state.decodeStrings !== false) {
        chunk = Buffer1.from(chunk, encoding);
        encoding = "buffer";
      }
    } else if (chunk instanceof Buffer1) {
      encoding = "buffer";
    } else if (isUint8Array1(chunk)) {
      chunk = _uint8ArrayToBuffer1(chunk);
      encoding = "buffer";
    } else {
      throw new ERR_INVALID_ARG_TYPE1("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
      ], chunk);
    }
  }
  let err;
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END1();
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED1("write");
  }
  if (err) {
    nextTick3(cb, err);
    errorOrDestroy5(stream, err, true);
    return err;
  }
  state.pendingcb++;
  return writeOrBuffer1(stream, state, chunk, encoding, cb);
}
Writable1.prototype.write = function(chunk, encoding, cb) {
  return _write1(this, chunk, encoding, cb) === true;
};
Writable1.prototype.cork = function() {
  this._writableState.corked++;
};
Writable1.prototype.uncork = function() {
  const state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing) {
      clearBuffer1(this, state);
    }
  }
};
Writable1.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string") {
    encoding = encoding.toLowerCase();
  }
  if (!Buffer1.isEncoding(encoding)) {
    throw new ERR_UNKNOWN_ENCODING1(encoding);
  }
  this._writableState.defaultEncoding = encoding;
  return this;
};
function writeOrBuffer1(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  const ret = state.length < state.highWaterMark;
  if (!ret) {
    state.needDrain = true;
  }
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({
      chunk,
      encoding,
      callback
    });
    if (state.allBuffers && encoding !== "buffer") {
      state.allBuffers = false;
    }
    if (state.allNoop && callback !== nop5) {
      state.allNoop = false;
    }
  } else {
    state.writelen = len;
    state.writecb = callback;
    state.writing = true;
    state.sync = true;
    stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  return ret && !state.errored && !state.destroyed;
}
function doWrite1(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) {
    state.onwrite(new ERR_STREAM_DESTROYED1("write"));
  } else if (writev) {
    stream._writev(chunk, state.onwrite);
  } else {
    stream._write(chunk, encoding, state.onwrite);
  }
  state.sync = false;
}
function onwriteError1(stream, state, er2, cb) {
  --state.pendingcb;
  cb(er2);
  errorBuffer1(state);
  errorOrDestroy5(stream, er2);
}
function onwrite1(stream, er2) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;
  if (typeof cb !== "function") {
    errorOrDestroy5(stream, new ERR_MULTIPLE_CALLBACK1());
    return;
  }
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
  if (er2) {
    er2.stack;
    if (!state.errored) {
      state.errored = er2;
    }
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er2;
    }
    if (sync) {
      nextTick3(onwriteError1, stream, state, er2, cb);
    } else {
      onwriteError1(stream, state, er2, cb);
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer1(stream, state);
    }
    if (sync) {
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++;
      } else {
        state.afterWriteTickInfo = {
          count: 1,
          cb,
          stream,
          state
        };
        nextTick3(afterWriteTick1, state.afterWriteTickInfo);
      }
    } else {
      afterWrite1(stream, state, 1, cb);
    }
  }
}
function afterWriteTick1({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null;
  return afterWrite1(stream, state, count, cb);
}
function afterWrite1(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
  if (needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
  while (count-- > 0) {
    state.pendingcb--;
    cb();
  }
  if (state.destroyed) {
    errorBuffer1(state);
  }
  finishMaybe1(stream, state);
}
function errorBuffer1(state) {
  if (state.writing) {
    return;
  }
  for (let n3 = state.bufferedIndex; n3 < state.buffered.length; ++n3) {
    const { chunk, callback } = state.buffered[n3];
    const len = state.objectMode ? 1 : chunk.length;
    state.length -= len;
    callback(new ERR_STREAM_DESTROYED1("write"));
  }
  const onfinishCallbacks = state[kOnFinished1].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i](new ERR_STREAM_DESTROYED1("end"));
  }
  resetBuffer1(state);
}
function clearBuffer1(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return;
  }
  const { buffered, bufferedIndex, objectMode } = state;
  const bufferedLength = buffered.length - bufferedIndex;
  if (!bufferedLength) {
    return;
  }
  let i = bufferedIndex;
  state.bufferProcessing = true;
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1;
    const callback = state.allNoop ? nop5 : (err) => {
      for (let n3 = i; n3 < buffered.length; ++n3) {
        buffered[n3].callback(err);
      }
    };
    const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
    chunks.allBuffers = state.allBuffers;
    doWrite1(stream, state, true, state.length, chunks, "", callback);
    resetBuffer1(state);
  } else {
    do {
      const { chunk, encoding, callback: callback1 } = buffered[i];
      buffered[i++] = null;
      const len = objectMode ? 1 : chunk.length;
      doWrite1(stream, state, false, len, chunk, encoding, callback1);
    } while (i < buffered.length && !state.writing);
    if (i === buffered.length) {
      resetBuffer1(state);
    } else if (i > 256) {
      buffered.splice(0, i);
      state.bufferedIndex = 0;
    } else {
      state.bufferedIndex = i;
    }
  }
  state.bufferProcessing = false;
}
Writable1.prototype._write = function(chunk, encoding, cb) {
  if (this._writev) {
    this._writev([
      {
        chunk,
        encoding
      }
    ], cb);
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED1("_write()");
  }
};
Writable1.prototype._writev = null;
Writable1.prototype.end = function(chunk, encoding, cb) {
  const state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  let err;
  if (chunk !== null && chunk !== void 0) {
    const ret = _write1(this, chunk, encoding);
    if (ret instanceof Error) {
      err = ret;
    }
  }
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (err) {
  } else if (!state.errored && !state.ending) {
    state.ending = true;
    finishMaybe1(this, state, true);
    state.ended = true;
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED1("end");
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED1("end");
  }
  if (typeof cb === "function") {
    if (err || state.finished) {
      nextTick4(cb, err);
    } else {
      state[kOnFinished1].push(cb);
    }
  }
  return this;
};
function needFinish1(state) {
  return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal1(stream, state) {
  let called = false;
  function onFinish(err) {
    if (called) {
      errorOrDestroy5(stream, err ?? ERR_MULTIPLE_CALLBACK1());
      return;
    }
    called = true;
    state.pendingcb--;
    if (err) {
      const onfinishCallbacks = state[kOnFinished1].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err);
      }
      errorOrDestroy5(stream, err, state.sync);
    } else if (needFinish1(state)) {
      state.prefinished = true;
      stream.emit("prefinish");
      state.pendingcb++;
      nextTick3(finish1, stream, state);
    }
  }
  state.sync = true;
  state.pendingcb++;
  try {
    const result = stream._final(onFinish);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onFinish, null);
        }, function(err) {
          nextTick3(onFinish, err);
        });
      }
    }
  } catch (err) {
    onFinish(stream, state, err);
  }
  state.sync = false;
}
function prefinish2(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === "function" && !state.destroyed) {
      state.finalCalled = true;
      callFinal1(stream, state);
    } else {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
}
function finishMaybe1(stream, state, sync) {
  if (needFinish1(state)) {
    prefinish2(stream, state);
    if (state.pendingcb === 0 && needFinish1(state)) {
      state.pendingcb++;
      if (sync) {
        nextTick3(finish1, stream, state);
      } else {
        finish1(stream, state);
      }
    }
  }
}
function finish1(stream, state) {
  state.pendingcb--;
  state.finished = true;
  const onfinishCallbacks = state[kOnFinished1].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]();
  }
  stream.emit("finish");
  if (state.autoDestroy) {
    const rState = stream._readableState;
    const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
    if (autoDestroy) {
      stream.destroy();
    }
  }
}
Object.defineProperties(Writable1.prototype, {
  destroyed: {
    get() {
      return this._writableState ? this._writableState.destroyed : false;
    },
    set(value) {
      if (this._writableState) {
        this._writableState.destroyed = value;
      }
    }
  },
  writable: {
    get() {
      const w24 = this._writableState;
      return !!w24 && w24.writable !== false && !w24.destroyed && !w24.errored && !w24.ending && !w24.ended;
    },
    set(val) {
      if (this._writableState) {
        this._writableState.writable = !!val;
      }
    }
  },
  writableFinished: {
    get() {
      return this._writableState ? this._writableState.finished : false;
    }
  },
  writableObjectMode: {
    get() {
      return this._writableState ? this._writableState.objectMode : false;
    }
  },
  writableBuffer: {
    get() {
      return this._writableState && this._writableState.getBuffer();
    }
  },
  writableEnded: {
    get() {
      return this._writableState ? this._writableState.ending : false;
    }
  },
  writableNeedDrain: {
    get() {
      const wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    }
  },
  writableHighWaterMark: {
    get() {
      return this._writableState && this._writableState.highWaterMark;
    }
  },
  writableCorked: {
    get() {
      return this._writableState ? this._writableState.corked : 0;
    }
  },
  writableLength: {
    get() {
      return this._writableState && this._writableState.length;
    }
  }
});
var destroy4 = __default15.destroy;
Writable1.prototype.destroy = function(err, cb) {
  const state = this._writableState;
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished1].length)) {
    nextTick4(errorBuffer1, state);
  }
  destroy4.call(this, err, cb);
  return this;
};
Writable1.prototype._undestroy = __default15.undestroy;
Writable1.prototype._destroy = function(err, cb) {
  cb(err);
};
Writable1.prototype[EventEmitter1.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Writable1.WritableState = WritableState1;
Object.setPrototypeOf(Duplex1.prototype, Readable1.prototype);
Object.setPrototypeOf(Duplex1, Readable1);
{
  for (const method1 of Object.keys(Writable1.prototype)) {
    if (!Duplex1.prototype[method1]) {
      Duplex1.prototype[method1] = Writable1.prototype[method1];
    }
  }
}
function Duplex1(options) {
  if (!(this instanceof Duplex1)) {
    return new Duplex1(options);
  }
  Readable1.call(this, options);
  Writable1.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
    }
  }
}
Object.defineProperties(Duplex1.prototype, {
  writable: Object.getOwnPropertyDescriptor(Writable1.prototype, "writable"),
  writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableHighWaterMark"),
  writableObjectMode: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableObjectMode"),
  writableBuffer: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableBuffer"),
  writableLength: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableLength"),
  writableFinished: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableFinished"),
  writableCorked: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableCorked"),
  writableEnded: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableEnded"),
  writableNeedDrain: Object.getOwnPropertyDescriptor(Writable1.prototype, "writableNeedDrain"),
  destroyed: {
    get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set(value) {
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    }
  }
});
function isReadableStream1(object) {
  return object instanceof ReadableStream;
}
function isWritableStream1(object) {
  return object instanceof WritableStream;
}
Duplex1.fromWeb = function(pair, options) {
  validateObject1(pair, "pair");
  const { readable: readableStream, writable: writableStream } = pair;
  if (!isReadableStream1(readableStream)) {
    throw new ERR_INVALID_ARG_TYPE1("pair.readable", "ReadableStream", readableStream);
  }
  if (!isWritableStream1(writableStream)) {
    throw new ERR_INVALID_ARG_TYPE1("pair.writable", "WritableStream", writableStream);
  }
  validateObject1(options, "options");
  const { allowHalfOpen = false, objectMode = false, encoding, decodeStrings = true, highWaterMark, signal } = options;
  validateBoolean1(objectMode, "options.objectMode");
  if (encoding !== void 0 && !Buffer1.isEncoding(encoding)) {
    throw new ERR_INVALID_ARG_VALUE1(encoding, "options.encoding");
  }
  const writer = writableStream.getWriter();
  const reader = readableStream.getReader();
  let writableClosed = false;
  let readableClosed = false;
  const duplex = new Duplex1({
    allowHalfOpen,
    highWaterMark,
    objectMode,
    encoding,
    decodeStrings,
    signal,
    writev(chunks, callback) {
      function done(error2) {
        error2 = error2.filter((e) => e);
        try {
          callback(error2.length === 0 ? void 0 : error2);
        } catch (error1) {
          nextTick4(() => destroy(duplex, error1));
        }
      }
      writer.ready.then(() => Promise.All(chunks.map((data) => writer.write(data.chunk))).then(done, done), done);
    },
    write(chunk, encoding2, callback) {
      if (typeof chunk === "string" && decodeStrings && !objectMode) {
        chunk = Buffer1.from(chunk, encoding2);
        chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      }
      function done(error2) {
        try {
          callback(error2);
        } catch (error1) {
          destroy(duplex, error1);
        }
      }
      writer.ready.then(() => writer.write(chunk).then(done, done), done);
    },
    final(callback) {
      function done(error2) {
        try {
          callback(error2);
        } catch (error1) {
          nextTick4(() => destroy(duplex, error1));
        }
      }
      if (!writableClosed) {
        writer.close().then(done, done);
      }
    },
    read() {
      reader.read().then((chunk) => {
        if (chunk.done) {
          duplex.push(null);
        } else {
          duplex.push(chunk.value);
        }
      }, (error2) => destroy(duplex, error2));
    },
    destroy(error2, callback) {
      function done() {
        try {
          callback(error2);
        } catch (error1) {
          nextTick4(() => {
            throw error1;
          });
        }
      }
      async function closeWriter() {
        if (!writableClosed) {
          await writer.abort(error2);
        }
      }
      async function closeReader() {
        if (!readableClosed) {
          await reader.cancel(error2);
        }
      }
      if (!writableClosed || !readableClosed) {
        Promise.All([
          closeWriter(),
          closeReader()
        ]).then(done, done);
        return;
      }
      done();
    }
  });
  writer.closed.then(() => {
    writableClosed = true;
    if (!isWritableEnded1(duplex)) {
      destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE1());
    }
  }, (error2) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error2);
  });
  reader.closed.then(() => {
    readableClosed = true;
    if (!isReadableEnded3(duplex)) {
      duplex.push(null);
    }
  }, (error2) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error2);
  });
  return duplex;
};
var Duplexify1 = class extends Duplex1 {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function duplexify1(body, name) {
  if (isDuplexNodeStream1(body)) {
    return body;
  }
  if (isReadableNodeStream1(body)) {
    return _duplexify1({
      readable: body
    });
  }
  if (isWritableNodeStream1(body)) {
    return _duplexify1({
      writable: body
    });
  }
  if (isNodeStream1(body)) {
    return _duplexify1({
      writable: false,
      readable: false
    });
  }
  if (typeof body === "function") {
    const { value, write: write6, final: __final2, destroy: destroy12 } = fromAsyncGen1(body);
    if (isIterable1(value)) {
      return _from3(Duplexify1, value, {
        objectMode: true,
        write: write6,
        final: __final2,
        destroy: destroy12
      });
    }
    const then = value?.then;
    if (typeof then === "function") {
      let d14;
      const promise = then.call(value, (val) => {
        if (val != null) {
          throw new ERR_INVALID_RETURN_VALUE1("nully", "body", val);
        }
      }, (err) => {
        destroyer2(d14, err);
      });
      return d14 = new Duplexify1({
        objectMode: true,
        readable: false,
        write: write6,
        final(cb) {
          __final2(async () => {
            try {
              await promise;
              nextTick4(cb, null);
            } catch (err) {
              nextTick4(cb, err);
            }
          });
        },
        destroy: destroy12
      });
    }
    throw new ERR_INVALID_RETURN_VALUE1("Iterable, AsyncIterable or AsyncFunction", name, value);
  }
  if (isBlob1(body)) {
    return duplexify1(body.arrayBuffer());
  }
  if (isIterable1(body)) {
    return _from3(Duplexify1, body, {
      objectMode: true,
      writable: false
    });
  }
  if (typeof body?.writable === "object" || typeof body?.readable === "object") {
    const readable = body?.readable ? isReadableNodeStream1(body?.readable) ? body?.readable : duplexify1(body.readable) : void 0;
    const writable = body?.writable ? isWritableNodeStream1(body?.writable) ? body?.writable : duplexify1(body.writable) : void 0;
    return _duplexify1({
      readable,
      writable
    });
  }
  const then1 = body?.then;
  if (typeof then1 === "function") {
    let d14;
    then1.call(body, (val) => {
      if (val != null) {
        d14.push(val);
      }
      d14.push(null);
    }, (err) => {
      destroyer2(d14, err);
    });
    return d14 = new Duplexify1({
      objectMode: true,
      writable: false,
      read() {
      }
    });
  }
  throw new ERR_INVALID_ARG_TYPE1(name, [
    "Blob",
    "ReadableStream",
    "WritableStream",
    "Stream",
    "Iterable",
    "AsyncIterable",
    "Function",
    "{ readable, writable } pair",
    "Promise"
  ], body);
}
function fromAsyncGen1(fn) {
  let { promise, resolve: resolve9 } = createDeferredPromise1();
  const ac = new AbortController();
  const signal = ac.signal;
  const value = fn(async function* () {
    while (true) {
      const _promise = promise;
      promise = null;
      const { chunk, done, cb } = await _promise;
      nextTick3(cb);
      if (done)
        return;
      if (signal.aborted)
        throw new AbortError1();
      ({ promise, resolve: resolve9 } = createDeferredPromise1());
      yield chunk;
    }
  }(), {
    signal
  });
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve9;
      resolve9 = null;
      _resolve({
        chunk,
        done: false,
        cb
      });
    },
    final(cb) {
      const _resolve = resolve9;
      resolve9 = null;
      _resolve({
        done: true,
        cb
      });
    },
    destroy(err, cb) {
      ac.abort();
      cb(err);
    }
  };
}
function _duplexify1(pair) {
  const r2 = pair.readable && typeof pair.readable.read !== "function" ? Readable1.wrap(pair.readable) : pair.readable;
  const w24 = pair.writable;
  let readable = !!isReadable3(r2);
  let writable = !!isWritable3(w24);
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d14;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d14.destroy(err);
    } else if (!readable && !writable) {
      d14.destroy();
    }
  }
  d14 = new Duplexify1({
    readableObjectMode: !!r2?.readableObjectMode,
    writableObjectMode: !!w24?.writableObjectMode,
    readable,
    writable
  });
  if (writable) {
    eos1(w24, (err) => {
      writable = false;
      if (err) {
        destroyer2(r2, err);
      }
      onfinished(err);
    });
    d14._write = function(chunk, encoding, callback) {
      if (w24.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d14._final = function(callback) {
      w24.end();
      onfinish = callback;
    };
    w24.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    w24.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    eos1(r2, (err) => {
      readable = false;
      if (err) {
        destroyer2(r2, err);
      }
      onfinished(err);
    });
    r2.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    r2.on("end", function() {
      d14.push(null);
    });
    d14._read = function() {
      while (true) {
        const buf = r2.read();
        if (buf === null) {
          onreadable = d14._read;
          return;
        }
        if (!d14.push(buf)) {
          return;
        }
      }
    };
  }
  d14._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError1();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer2(w24, err);
      destroyer2(r2, err);
    }
  };
  return d14;
}
function duplexFrom1(body) {
  return duplexify1(body, "body");
}
Duplex1.from = duplexFrom1;
Object.setPrototypeOf(Transform1.prototype, Duplex1.prototype);
Object.setPrototypeOf(Transform1, Duplex1);
var kCallback1 = Symbol("kCallback");
function Transform1(options) {
  if (!(this instanceof Transform1)) {
    return new Transform1(options);
  }
  Duplex1.call(this, options);
  this._readableState.sync = false;
  this[kCallback1] = null;
  if (options) {
    if (typeof options.transform === "function") {
      this._transform = options.transform;
    }
    if (typeof options.flush === "function") {
      this._flush = options.flush;
    }
  }
  this.on("prefinish", prefinish3);
}
function __final1(cb) {
  let called = false;
  if (typeof this._flush === "function" && !this.destroyed) {
    const result = this._flush((er2, data) => {
      called = true;
      if (er2) {
        if (cb) {
          cb(er2);
        } else {
          this.destroy(er2);
        }
        return;
      }
      if (data != null) {
        this.push(data);
      }
      this.push(null);
      if (cb) {
        cb();
      }
    });
    if (result !== void 0 && result !== null) {
      try {
        const then = result.then;
        if (typeof then === "function") {
          then.call(result, (data) => {
            if (called) {
              return;
            }
            if (data != null) {
              this.push(data);
            }
            this.push(null);
            if (cb) {
              nextTick3(cb);
            }
          }, (err) => {
            if (cb) {
              nextTick3(cb, err);
            } else {
              nextTick3(() => this.destroy(err));
            }
          });
        }
      } catch (err) {
        nextTick3(() => this.destroy(err));
      }
    }
  } else {
    this.push(null);
    if (cb) {
      cb();
    }
  }
}
function prefinish3() {
  if (this._final !== __final1) {
    __final1.call(this);
  }
}
Transform1.prototype._final = __final1;
Transform1.prototype._transform = function(chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED1("_transform()");
};
Transform1.prototype._write = function(chunk, encoding, callback) {
  const rState = this._readableState;
  const wState = this._writableState;
  const length = rState.length;
  let called = false;
  const result = this._transform(chunk, encoding, (err, val) => {
    called = true;
    if (err) {
      callback(err);
      return;
    }
    if (val != null) {
      this.push(val);
    }
    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
      callback();
    } else {
      this[kCallback1] = callback;
    }
  });
  if (result !== void 0 && result != null) {
    try {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, (val) => {
          if (called) {
            return;
          }
          if (val != null) {
            this.push(val);
          }
          if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            nextTick4(callback);
          } else {
            this[kCallback1] = callback;
          }
        }, (err) => {
          nextTick4(callback, err);
        });
      }
    } catch (err) {
      nextTick4(callback, err);
    }
  }
};
Transform1.prototype._read = function() {
  if (this[kCallback1]) {
    const callback = this[kCallback1];
    this[kCallback1] = null;
    callback();
  }
};
Object.setPrototypeOf(PassThrough1.prototype, Transform1.prototype);
Object.setPrototypeOf(PassThrough1, Transform1);
function PassThrough1(options) {
  if (!(this instanceof PassThrough1)) {
    return new PassThrough1(options);
  }
  Transform1.call(this, options);
}
PassThrough1.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
function destroyer3(stream, reading, writing, callback) {
  callback = once22(callback);
  let finished2 = false;
  stream.on("close", () => {
    finished2 = true;
  });
  eos1(stream, {
    readable: reading,
    writable: writing
  }, (err) => {
    finished2 = !err;
    const rState = stream._readableState;
    if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
      stream.once("end", callback).once("error", callback);
    } else {
      callback(err);
    }
  });
  return (err) => {
    if (finished2)
      return;
    finished2 = true;
    __default15.destroyer(stream, err);
    callback(err || new ERR_STREAM_DESTROYED1("pipe"));
  };
}
function popCallback1(streams) {
  validateCallback1(streams[streams.length - 1]);
  return streams.pop();
}
function makeAsyncIterable1(val) {
  if (isIterable1(val)) {
    return val;
  } else if (isReadableNodeStream1(val)) {
    return fromReadable1(val);
  }
  throw new ERR_INVALID_ARG_TYPE1("val", [
    "Readable",
    "Iterable",
    "AsyncIterable"
  ], val);
}
async function* fromReadable1(val) {
  yield* Readable1.prototype[Symbol.asyncIterator].call(val);
}
async function pump1(iterable, writable, finish2) {
  let error2;
  let onresolve = null;
  const resume2 = (err) => {
    if (err) {
      error2 = err;
    }
    if (onresolve) {
      const callback = onresolve;
      onresolve = null;
      callback();
    }
  };
  const wait = () => new Promise((resolve9, reject) => {
    if (error2) {
      reject(error2);
    } else {
      onresolve = () => {
        if (error2) {
          reject(error2);
        } else {
          resolve9();
        }
      };
    }
  });
  writable.on("drain", resume2);
  const cleanup = eos1(writable, {
    readable: false
  }, resume2);
  try {
    if (writable.writableNeedDrain) {
      await wait();
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait();
      }
    }
    writable.end();
    await wait();
    finish2();
  } catch (err) {
    finish2(error2 !== err ? aggregateTwoErrors1(error2, err) : err);
  } finally {
    cleanup();
    writable.off("drain", resume2);
  }
}
function pipeline2(...streams) {
  const callback = once22(popCallback1(streams));
  if (Array.isArray(streams[0]) && streams.length === 1) {
    streams = streams[0];
  }
  return pipelineImpl1(streams, callback);
}
function pipelineImpl1(streams, callback, opts) {
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS1("streams");
  }
  const ac = new AbortController();
  const signal = ac.signal;
  const outerSignal = opts?.signal;
  validateAbortSignal2(outerSignal, "options.signal");
  function abort() {
    finishImpl(new AbortError1());
  }
  outerSignal?.addEventListener("abort", abort);
  let error2;
  let value;
  const destroys = [];
  let finishCount = 0;
  function finish2(err) {
    finishImpl(err, --finishCount === 0);
  }
  function finishImpl(err, __final2) {
    if (err && (!error2 || error2.code === "ERR_STREAM_PREMATURE_CLOSE")) {
      error2 = err;
    }
    if (!error2 && !__final2) {
      return;
    }
    while (destroys.length) {
      destroys.shift()(error2);
    }
    outerSignal?.removeEventListener("abort", abort);
    ac.abort();
    if (__final2) {
      callback(error2, value);
    }
  }
  let ret;
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i];
    const reading = i < streams.length - 1;
    const writing = i > 0;
    if (isNodeStream1(stream)) {
      finishCount++;
      destroys.push(destroyer3(stream, reading, writing, finish2));
    }
    if (i === 0) {
      if (typeof stream === "function") {
        ret = stream({
          signal
        });
        if (!isIterable1(ret)) {
          throw new ERR_INVALID_RETURN_VALUE1("Iterable, AsyncIterable or Stream", "source", ret);
        }
      } else if (isIterable1(stream) || isReadableNodeStream1(stream)) {
        ret = stream;
      } else {
        ret = Duplex1.from(stream);
      }
    } else if (typeof stream === "function") {
      ret = makeAsyncIterable1(ret);
      ret = stream(ret, {
        signal
      });
      if (reading) {
        if (!isIterable1(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE1("AsyncIterable", `transform[${i - 1}]`, ret);
        }
      } else {
        const pt2 = new PassThrough1({
          objectMode: true
        });
        const then = ret?.then;
        if (typeof then === "function") {
          then.call(ret, (val) => {
            value = val;
            pt2.end(val);
          }, (err) => {
            pt2.destroy(err);
          });
        } else if (isIterable1(ret, true)) {
          finishCount++;
          pump1(ret, pt2, finish2);
        } else {
          throw new ERR_INVALID_RETURN_VALUE1("AsyncIterable or Promise", "destination", ret);
        }
        ret = pt2;
        finishCount++;
        destroys.push(destroyer3(ret, false, true, finish2));
      }
    } else if (isNodeStream1(stream)) {
      if (isReadableNodeStream1(ret)) {
        ret.pipe(stream);
        if (stream === stdio1.stdout || stream === stdio1.stderr) {
          ret.on("end", () => stream.end());
        }
      } else {
        ret = makeAsyncIterable1(ret);
        finishCount++;
        pump1(ret, stream, finish2);
      }
      ret = stream;
    } else {
      ret = Duplex1.from(stream);
    }
  }
  if (signal?.aborted || outerSignal?.aborted) {
    nextTick3(abort);
  }
  return ret;
}
var ComposeDuplex1 = class extends Duplex1 {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function compose1(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS1("streams");
  }
  if (streams.length === 1) {
    return Duplex1.from(streams[0]);
  }
  const orgStreams = [
    ...streams
  ];
  if (typeof streams[0] === "function") {
    streams[0] = Duplex1.from(streams[0]);
  }
  if (typeof streams[streams.length - 1] === "function") {
    const idx = streams.length - 1;
    streams[idx] = Duplex1.from(streams[idx]);
  }
  for (let n3 = 0; n3 < streams.length; ++n3) {
    if (!isNodeStream1(streams[n3])) {
      continue;
    }
    if (n3 < streams.length - 1 && !isReadable3(streams[n3])) {
      throw new ERR_INVALID_ARG_VALUE1(`streams[${n3}]`, orgStreams[n3], "must be readable");
    }
    if (n3 > 0 && !isWritable3(streams[n3])) {
      throw new ERR_INVALID_ARG_VALUE1(`streams[${n3}]`, orgStreams[n3], "must be writable");
    }
  }
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d14;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d14.destroy(err);
    } else if (!readable && !writable) {
      d14.destroy();
    }
  }
  const head = streams[0];
  const tail = pipeline2(streams, onfinished);
  const writable = !!isWritable3(head);
  const readable = !!isReadable3(tail);
  d14 = new ComposeDuplex1({
    writableObjectMode: !!head?.writableObjectMode,
    readableObjectMode: !!tail?.writableObjectMode,
    writable,
    readable
  });
  if (writable) {
    d14._write = function(chunk, encoding, callback) {
      if (head.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d14._final = function(callback) {
      head.end();
      onfinish = callback;
    };
    head.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    tail.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    tail.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    tail.on("end", function() {
      d14.push(null);
    });
    d14._read = function() {
      while (true) {
        const buf = tail.read();
        if (buf === null) {
          onreadable = d14._read;
          return;
        }
        if (!d14.push(buf)) {
          return;
        }
      }
    };
  }
  d14._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError1();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer2(tail, err);
    }
  };
  return d14;
}
function pipeline3(...streams) {
  return new Promise((resolve9, reject) => {
    let signal;
    let end;
    const lastArg = streams[streams.length - 1];
    if (lastArg && typeof lastArg === "object" && !isNodeStream1(lastArg) && !isIterable1(lastArg)) {
      const options = streams.pop();
      signal = options.signal;
      end = options.end;
    }
    pipelineImpl1(streams, (err, value) => {
      if (err) {
        reject(err);
      } else {
        resolve9(value);
      }
    }, {
      signal,
      end
    });
  });
}
function finished1(stream, opts) {
  return new Promise((resolve9, reject) => {
    eos1(stream, opts, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve9();
      }
    });
  });
}
var __default17 = {
  finished: finished1,
  pipeline: pipeline3
};
var { custom: customPromisify1 } = promisify1;
Stream1.isDisturbed = isDisturbed1;
Stream1.Readable = Readable1;
Stream1.Writable = Writable1;
Stream1.Duplex = Duplex1;
Stream1.Transform = Transform1;
Stream1.PassThrough = PassThrough1;
Stream1.pipeline = pipeline2;
Stream1.addAbortSignal = addAbortSignal1;
Stream1.finished = eos1;
Stream1.destroy = destroyer2;
Stream1.compose = compose1;
Object.defineProperty(Stream1, "promises", {
  configurable: true,
  enumerable: true,
  get() {
    return __default17;
  }
});
Object.defineProperty(pipeline2, customPromisify1, {
  enumerable: true,
  get() {
    return __default17.pipeline;
  }
});
Object.defineProperty(eos1, customPromisify1, {
  enumerable: true,
  get() {
    return __default17.finished;
  }
});
Stream1.Stream = Stream1;
Stream1._isUint8Array = isUint8Array1;
Stream1._uint8ArrayToBuffer = _uint8ArrayToBuffer1;
function createWritableStdioStream1(writer, name) {
  const stream = new Writable1({
    write(buf, enc, cb) {
      if (!writer) {
        this.destroy(new Error(`Deno.${name} is not available in this environment`));
        return;
      }
      writer.writeSync(buf instanceof Uint8Array ? buf : Buffer1.from(buf, enc));
      cb();
    },
    destroy(err, cb) {
      cb(err);
      this._undestroy();
      if (!this._writableState.emitClose) {
        nextTick(() => this.emit("close"));
      }
    }
  });
  stream.fd = writer?.rid ?? -1;
  stream.destroySoon = stream.destroy;
  stream._isStdio = true;
  stream.once("close", () => writer?.close());
  Object.defineProperties(stream, {
    columns: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : void 0
    },
    rows: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : void 0
    },
    isTTY: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid)
    },
    getWindowSize: {
      enumerable: true,
      configurable: true,
      value: () => Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : void 0
    }
  });
  return stream;
}
var stderr1 = stdio1.stderr = createWritableStdioStream1(Deno.stderr, "stderr");
var stdout1 = stdio1.stdout = createWritableStdioStream1(Deno.stdout, "stdout");
var stdin1 = stdio1.stdin = new Readable1({
  highWaterMark: 0,
  emitClose: false,
  read(size) {
    const p7 = Buffer1.alloc(size || 16 * 1024);
    if (!Deno.stdin) {
      this.destroy(new Error("Deno.stdin is not available in this environment"));
      return;
    }
    Deno.stdin.read(p7).then((length) => {
      this.push(length === null ? null : p7.slice(0, length));
    }, (error2) => {
      this.destroy(error2);
    });
  }
});
stdin1.on("close", () => Deno.stdin?.close());
stdin1.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin1, "isTTY", {
  enumerable: true,
  configurable: true,
  get() {
    return Deno.isatty?.(Deno.stdin.rid);
  }
});
stdin1._isRawMode = false;
stdin1.setRawMode = (enable) => {
  setRaw1?.(Deno.stdin?.rid, enable);
  stdin1._isRawMode = enable;
  return stdin1;
};
Object.defineProperty(stdin1, "isRaw", {
  enumerable: true,
  configurable: true,
  get() {
    return stdin1._isRawMode;
  }
});
function registerDestroyHook1(_target, _asyncId, _prop) {
}
var constants4;
(function(constants7) {
  constants7[constants7["kInit"] = 0] = "kInit";
  constants7[constants7["kBefore"] = 1] = "kBefore";
  constants7[constants7["kAfter"] = 2] = "kAfter";
  constants7[constants7["kDestroy"] = 3] = "kDestroy";
  constants7[constants7["kPromiseResolve"] = 4] = "kPromiseResolve";
  constants7[constants7["kTotals"] = 5] = "kTotals";
  constants7[constants7["kCheck"] = 6] = "kCheck";
  constants7[constants7["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
  constants7[constants7["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
  constants7[constants7["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
  constants7[constants7["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
  constants7[constants7["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
  constants7[constants7["kStackLength"] = 12] = "kStackLength";
})(constants4 || (constants4 = {}));
var asyncHookFields1 = new Uint32Array(Object.keys(constants4).length);
function newAsyncId1() {
  return ++asyncIdFields1[constants4.kAsyncIdCounter];
}
var UidFields1;
(function(UidFields2) {
  UidFields2[UidFields2["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
  UidFields2[UidFields2["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
  UidFields2[UidFields2["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
  UidFields2[UidFields2["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
  UidFields2[UidFields2["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields1 || (UidFields1 = {}));
var asyncIdFields1 = new Float64Array(Object.keys(UidFields1).length);
asyncIdFields1[UidFields1.kAsyncIdCounter] = 1;
asyncIdFields1[UidFields1.kDefaultTriggerAsyncId] = -1;
var providerType1;
(function(providerType2) {
  providerType2[providerType2["NONE"] = 0] = "NONE";
  providerType2[providerType2["DIRHANDLE"] = 1] = "DIRHANDLE";
  providerType2[providerType2["DNSCHANNEL"] = 2] = "DNSCHANNEL";
  providerType2[providerType2["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
  providerType2[providerType2["FILEHANDLE"] = 4] = "FILEHANDLE";
  providerType2[providerType2["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
  providerType2[providerType2["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
  providerType2[providerType2["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
  providerType2[providerType2["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
  providerType2[providerType2["FSREQPROMISE"] = 9] = "FSREQPROMISE";
  providerType2[providerType2["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
  providerType2[providerType2["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
  providerType2[providerType2["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
  providerType2[providerType2["HTTP2SESSION"] = 13] = "HTTP2SESSION";
  providerType2[providerType2["HTTP2STREAM"] = 14] = "HTTP2STREAM";
  providerType2[providerType2["HTTP2PING"] = 15] = "HTTP2PING";
  providerType2[providerType2["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
  providerType2[providerType2["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
  providerType2[providerType2["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
  providerType2[providerType2["JSSTREAM"] = 19] = "JSSTREAM";
  providerType2[providerType2["JSUDPWRAP"] = 20] = "JSUDPWRAP";
  providerType2[providerType2["MESSAGEPORT"] = 21] = "MESSAGEPORT";
  providerType2[providerType2["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
  providerType2[providerType2["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
  providerType2[providerType2["PIPEWRAP"] = 24] = "PIPEWRAP";
  providerType2[providerType2["PROCESSWRAP"] = 25] = "PROCESSWRAP";
  providerType2[providerType2["PROMISE"] = 26] = "PROMISE";
  providerType2[providerType2["QUERYWRAP"] = 27] = "QUERYWRAP";
  providerType2[providerType2["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
  providerType2[providerType2["SIGNALWRAP"] = 29] = "SIGNALWRAP";
  providerType2[providerType2["STATWATCHER"] = 30] = "STATWATCHER";
  providerType2[providerType2["STREAMPIPE"] = 31] = "STREAMPIPE";
  providerType2[providerType2["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
  providerType2[providerType2["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
  providerType2[providerType2["TCPWRAP"] = 34] = "TCPWRAP";
  providerType2[providerType2["TTYWRAP"] = 35] = "TTYWRAP";
  providerType2[providerType2["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
  providerType2[providerType2["UDPWRAP"] = 37] = "UDPWRAP";
  providerType2[providerType2["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
  providerType2[providerType2["WORKER"] = 39] = "WORKER";
  providerType2[providerType2["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
  providerType2[providerType2["WRITEWRAP"] = 41] = "WRITEWRAP";
  providerType2[providerType2["ZLIB"] = 42] = "ZLIB";
})(providerType1 || (providerType1 = {}));
var kInvalidAsyncId1 = -1;
var AsyncWrap1 = class {
  provider = providerType1.NONE;
  asyncId = kInvalidAsyncId1;
  constructor(provider) {
    this.provider = provider;
    this.getAsyncId();
  }
  getAsyncId() {
    this.asyncId = this.asyncId === kInvalidAsyncId1 ? newAsyncId1() : this.asyncId;
    return this.asyncId;
  }
  getProviderType() {
    return this.provider;
  }
};
var mod66 = {
  async_hook_fields: asyncHookFields1,
  asyncIdFields: asyncIdFields1,
  registerDestroyHook: registerDestroyHook1,
  constants: constants4,
  newAsyncId: newAsyncId1,
  UidFields: UidFields1,
  providerType: providerType1,
  AsyncWrap: AsyncWrap1
};
var mod67 = {};
var v4Seg1 = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var v4Str1 = `(${v4Seg1}[.]){3}${v4Seg1}`;
var IPv4Reg1 = new RegExp(`^${v4Str1}$`);
var v6Seg1 = "(?:[0-9a-fA-F]{1,4})";
var IPv6Reg1 = new RegExp(`^((?:${v6Seg1}:){7}(?:${v6Seg1}|:)|(?:${v6Seg1}:){6}(?:${v4Str1}|:${v6Seg1}|:)|(?:${v6Seg1}:){5}(?::${v4Str1}|(:${v6Seg1}){1,2}|:)|(?:${v6Seg1}:){4}(?:(:${v6Seg1}){0,1}:${v4Str1}|(:${v6Seg1}){1,3}|:)|(?:${v6Seg1}:){3}(?:(:${v6Seg1}){0,2}:${v4Str1}|(:${v6Seg1}){1,4}|:)|(?:${v6Seg1}:){2}(?:(:${v6Seg1}){0,3}:${v4Str1}|(:${v6Seg1}){1,5}|:)|(?:${v6Seg1}:){1}(?:(:${v6Seg1}){0,4}:${v4Str1}|(:${v6Seg1}){1,6}|:)|(?::((?::${v6Seg1}){0,5}:${v4Str1}|(?::${v6Seg1}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
function isIPv41(ip) {
  return RegExp.prototype.test.call(IPv4Reg1, ip);
}
function isIPv61(ip) {
  return RegExp.prototype.test.call(IPv6Reg1, ip);
}
function isIP1(ip) {
  if (isIPv41(ip)) {
    return 4;
  }
  if (isIPv61(ip)) {
    return 6;
  }
  return 0;
}
Symbol("normalizedArgs");
function ares_strerror1(code2) {
  const errorText = [
    "Successful completion",
    "DNS server returned answer with no data",
    "DNS server claims query was misformatted",
    "DNS server returned general failure",
    "Domain name not found",
    "DNS server does not implement requested operation",
    "DNS server refused query",
    "Misformatted DNS query",
    "Misformatted domain name",
    "Unsupported address family",
    "Misformatted DNS reply",
    "Could not contact DNS servers",
    "Timeout while contacting DNS servers",
    "End of file",
    "Error reading file",
    "Out of memory",
    "Channel is being destroyed",
    "Misformatted string",
    "Illegal flags specified",
    "Given hostname is not numeric",
    "Illegal hints flags specified",
    "c-ares library initialization not yet performed",
    "Error loading iphlpapi.dll",
    "Could not find GetNetworkParams function",
    "DNS query cancelled"
  ];
  if (code2 >= 0 && code2 < errorText.length) {
    return errorText[code2];
  } else {
    return "unknown";
  }
}
var GetAddrInfoReqWrap1 = class extends AsyncWrap1 {
  family;
  hostname;
  callback;
  resolve;
  reject;
  oncomplete;
  constructor() {
    super(providerType1.GETADDRINFOREQWRAP);
  }
};
function getaddrinfo1(req, hostname, family, _hints, verbatim) {
  let addresses = [];
  const recordTypes = [];
  if (family === 0 || family === 4) {
    recordTypes.push("A");
  }
  if (family === 0 || family === 6) {
    recordTypes.push("AAAA");
  }
  (async () => {
    await Promise.allSettled(recordTypes.map((recordType) => Deno.resolveDns(hostname, recordType).then((records) => {
      records.forEach((record) => addresses.push(record));
    })));
    const error2 = addresses.length ? 0 : codeMap1.get("EAI_NODATA");
    if (!verbatim) {
      addresses.sort((a7, b15) => {
        if (isIPv41(a7)) {
          return -1;
        } else if (isIPv41(b15)) {
          return 1;
        }
        return 0;
      });
    }
    if (isWindows1 && hostname === "localhost") {
      addresses = addresses.filter((address) => isIPv41(address));
    }
    req.oncomplete(error2, addresses);
  })();
  return 0;
}
var QueryReqWrap1 = class extends AsyncWrap1 {
  bindingName;
  hostname;
  ttl;
  callback;
  resolve;
  reject;
  oncomplete;
  constructor() {
    super(providerType1.QUERYWRAP);
  }
};
function fqdnToHostname1(fqdn) {
  return fqdn.replace(/\.$/, "");
}
function compressIPv61(address) {
  const formatted = address.replace(/\b(?:0+:){2,}/, ":");
  const finalAddress = formatted.split(":").map((octet) => {
    if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
      return Number(octet.replaceAll(".", "")).toString(16);
    }
    return octet.replace(/\b0+/g, "");
  }).join(":");
  return finalAddress;
}
var ChannelWrap1 = class extends AsyncWrap1 {
  #servers = [];
  #timeout;
  #tries;
  constructor(timeout, tries) {
    super(providerType1.DNSCHANNEL);
    this.#timeout = timeout;
    this.#tries = tries;
  }
  async #query(query2, recordType2) {
    let code2;
    let ret2;
    if (this.#servers.length) {
      for (const [ipAddr1, port3] of this.#servers) {
        const resolveOptions2 = {
          nameServer: {
            ipAddr: ipAddr1,
            port: port3
          }
        };
        ({ code: code2, ret: ret2 } = await this.#resolve(query2, recordType2, resolveOptions2));
        if (code2 === 0 || code2 === codeMap1.get("EAI_NODATA")) {
          break;
        }
      }
    } else {
      ({ code: code2, ret: ret2 } = await this.#resolve(query2, recordType2));
    }
    return {
      code: code2,
      ret: ret2
    };
  }
  async #resolve(query11, recordType11, resolveOptions11) {
    let ret11 = [];
    let code12 = 0;
    try {
      ret11 = await Deno.resolveDns(query11, recordType11, resolveOptions11);
    } catch (e6) {
      if (e6 instanceof Deno.errors.NotFound) {
        code12 = codeMap1.get("EAI_NODATA");
      } else {
        code12 = codeMap1.get("UNKNOWN");
      }
    }
    return {
      code: code12,
      ret: ret11
    };
  }
  queryAny(req, name) {
    (async () => {
      const records = [];
      await Promise.allSettled([
        this.#query(name, "A").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "A",
            address: record
          }));
        }),
        this.#query(name, "AAAA").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "AAAA",
            address: compressIPv61(record)
          }));
        }),
        this.#query(name, "CAA").then(({ ret }) => {
          ret.forEach(({ critical, tag: tag2, value }) => records.push({
            type: "CAA",
            [tag2]: value,
            critical: +critical && 128
          }));
        }),
        this.#query(name, "CNAME").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "CNAME",
            value: record
          }));
        }),
        this.#query(name, "MX").then(({ ret }) => {
          ret.forEach(({ preference, exchange }) => records.push({
            type: "MX",
            priority: preference,
            exchange: fqdnToHostname1(exchange)
          }));
        }),
        this.#query(name, "NAPTR").then(({ ret }) => {
          ret.forEach(({ order, preference, flags, services, regexp, replacement }) => records.push({
            type: "NAPTR",
            order,
            preference,
            flags,
            service: services,
            regexp,
            replacement
          }));
        }),
        this.#query(name, "NS").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "NS",
            value: fqdnToHostname1(record)
          }));
        }),
        this.#query(name, "PTR").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "PTR",
            value: fqdnToHostname1(record)
          }));
        }),
        this.#query(name, "SOA").then(({ ret }) => {
          ret.forEach(({ mname, rname, serial, refresh, retry, expire, minimum }) => records.push({
            type: "SOA",
            nsname: fqdnToHostname1(mname),
            hostmaster: fqdnToHostname1(rname),
            serial,
            refresh,
            retry,
            expire,
            minttl: minimum
          }));
        }),
        this.#query(name, "SRV").then(({ ret }) => {
          ret.forEach(({ priority, weight, port, target }) => records.push({
            type: "SRV",
            priority,
            weight,
            port,
            name: target
          }));
        }),
        this.#query(name, "TXT").then(({ ret }) => {
          ret.forEach((record) => records.push({
            type: "TXT",
            entries: record
          }));
        })
      ]);
      const err = records.length ? 0 : codeMap1.get("EAI_NODATA");
      req.oncomplete(err, records);
    })();
    return 0;
  }
  queryA(req, name) {
    this.#query(name, "A").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryAaaa(req, name) {
    this.#query(name, "AAAA").then(({ code: code2, ret }) => {
      const records = ret.map((record) => compressIPv61(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCaa(req, name) {
    this.#query(name, "CAA").then(({ code: code2, ret }) => {
      const records = ret.map(({ critical, tag: tag2, value }) => ({
        [tag2]: value,
        critical: +critical && 128
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCname(req, name) {
    this.#query(name, "CNAME").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryMx(req, name) {
    this.#query(name, "MX").then(({ code: code2, ret }) => {
      const records = ret.map(({ preference, exchange }) => ({
        priority: preference,
        exchange: fqdnToHostname1(exchange)
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNaptr(req, name) {
    this.#query(name, "NAPTR").then(({ code: code2, ret }) => {
      const records = ret.map(({ order, preference, flags, services, regexp, replacement }) => ({
        flags,
        service: services,
        regexp,
        replacement,
        order,
        preference
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNs(req, name) {
    this.#query(name, "NS").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname1(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryPtr(req, name) {
    this.#query(name, "PTR").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname1(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  querySoa(req, name) {
    this.#query(name, "SOA").then(({ code: code2, ret }) => {
      let record = {};
      if (ret.length) {
        const { mname, rname, serial, refresh, retry, expire, minimum } = ret[0];
        record = {
          nsname: fqdnToHostname1(mname),
          hostmaster: fqdnToHostname1(rname),
          serial,
          refresh,
          retry,
          expire,
          minttl: minimum
        };
      }
      req.oncomplete(code2, record);
    });
    return 0;
  }
  querySrv(req, name) {
    this.#query(name, "SRV").then(({ code: code2, ret }) => {
      const records = ret.map(({ priority, weight, port, target }) => ({
        priority,
        weight,
        port,
        name: target
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryTxt(req, name) {
    this.#query(name, "TXT").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  getHostByAddr(_req, _name) {
    notImplemented1("cares.ChannelWrap.prototype.getHostByAddr");
  }
  getServers() {
    return this.#servers;
  }
  setServers(servers) {
    if (typeof servers === "string") {
      const tuples = [];
      for (let i = 0; i < servers.length; i += 2) {
        tuples.push([
          servers[i],
          parseInt(servers[i + 1])
        ]);
      }
      this.#servers = tuples;
    } else {
      this.#servers = servers.map(([_ipVersion, ip, port]) => [
        ip,
        port
      ]);
    }
    return 0;
  }
  setLocalAddress(_addr0, _addr1) {
    notImplemented1("cares.ChannelWrap.prototype.setLocalAddress");
  }
  cancel() {
    notImplemented1("cares.ChannelWrap.prototype.cancel");
  }
};
var DNS_ESETSRVPENDING1 = -1e3;
var EMSG_ESETSRVPENDING1 = "There are pending queries.";
function strerror1(code2) {
  return code2 === DNS_ESETSRVPENDING1 ? EMSG_ESETSRVPENDING1 : ares_strerror1(code2);
}
var mod68 = {
  GetAddrInfoReqWrap: GetAddrInfoReqWrap1,
  getaddrinfo: getaddrinfo1,
  QueryReqWrap: QueryReqWrap1,
  ChannelWrap: ChannelWrap1,
  strerror: strerror1
};
var mod69 = {};
var timingSafeEqual1 = (a7, b15) => {
  if (a7 instanceof DataView)
    a7 = Buffer1.from(a7.buffer);
  if (b15 instanceof DataView)
    b15 = Buffer1.from(b15.buffer);
  if (a7 instanceof ArrayBuffer)
    a7 = Buffer1.from(a7);
  if (b15 instanceof ArrayBuffer)
    b15 = Buffer1.from(b15);
  let result = 0;
  if (a7.byteLength !== b15.byteLength) {
    b15 = a7;
    result = 1;
  }
  for (let i = 0; i < a7.byteLength; i++) {
    result |= a7[i] ^ b15[i];
  }
  return result === 0;
};
function getFipsCrypto1() {
  notImplemented1("crypto.getFipsCrypto");
}
function setFipsCrypto1(_fips) {
  notImplemented1("crypto.setFipsCrypto");
}
var mod70 = {
  timingSafeEqual: timingSafeEqual1,
  getFipsCrypto: getFipsCrypto1,
  setFipsCrypto: setFipsCrypto1
};
var mod71 = {};
var mod72 = {};
var mod73 = {};
var mod74 = {};
var mod75 = {};
var mod76 = {};
var mod77 = {};
var mod78 = {};
var mod79 = {};
var mod80 = {};
var mod81 = {};
var mod82 = {};
var mod83 = {};
var mod84 = {};
var mod85 = {};
var mod86 = {};
var HandleWrap1 = class extends AsyncWrap1 {
  constructor(provider) {
    super(provider);
  }
  close(cb = () => {
  }) {
    this._onClose();
    cb();
  }
  ref() {
    unreachable1();
  }
  unref() {
    unreachable1();
  }
  _onClose() {
  }
};
var CR1 = "\r".charCodeAt(0);
var LF1 = "\n".charCodeAt(0);
async function writeAll1(w24, arr) {
  let nwritten = 0;
  while (nwritten < arr.length) {
    nwritten += await w24.write(arr.subarray(nwritten));
  }
}
var StreamBaseStateFields1;
(function(StreamBaseStateFields2) {
  StreamBaseStateFields2[StreamBaseStateFields2["kReadBytesOrError"] = 0] = "kReadBytesOrError";
  StreamBaseStateFields2[StreamBaseStateFields2["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
  StreamBaseStateFields2[StreamBaseStateFields2["kBytesWritten"] = 2] = "kBytesWritten";
  StreamBaseStateFields2[StreamBaseStateFields2["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
  StreamBaseStateFields2[StreamBaseStateFields2["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields1 || (StreamBaseStateFields1 = {}));
var kReadBytesOrError1 = StreamBaseStateFields1.kReadBytesOrError;
var kArrayBufferOffset1 = StreamBaseStateFields1.kArrayBufferOffset;
var kBytesWritten1 = StreamBaseStateFields1.kBytesWritten;
var kLastWriteWasAsync1 = StreamBaseStateFields1.kLastWriteWasAsync;
var kNumStreamBaseStateFields1 = StreamBaseStateFields1.kNumStreamBaseStateFields;
var streamBaseState1 = new Uint8Array(5);
streamBaseState1[kLastWriteWasAsync1] = 1;
var WriteWrap1 = class extends AsyncWrap1 {
  handle;
  oncomplete;
  async;
  bytes;
  buffer;
  callback;
  _chunks;
  constructor() {
    super(providerType1.WRITEWRAP);
  }
};
var ShutdownWrap1 = class extends AsyncWrap1 {
  handle;
  oncomplete;
  callback;
  constructor() {
    super(providerType1.SHUTDOWNWRAP);
  }
};
var kStreamBaseField1 = Symbol("kStreamBaseField");
var SUGGESTED_SIZE1 = 64 * 1024;
var LibuvStreamWrap1 = class extends HandleWrap1 {
  [kStreamBaseField1];
  reading;
  #reading = false;
  destroyed = false;
  writeQueueSize = 0;
  bytesRead = 0;
  bytesWritten = 0;
  onread;
  constructor(provider, stream) {
    super(provider);
    this.#attachToObject(stream);
  }
  readStart() {
    if (!this.#reading) {
      this.#reading = true;
      this.#read();
    }
    return 0;
  }
  readStop() {
    this.#reading = false;
    return 0;
  }
  shutdown(req) {
    const status = this._onClose();
    try {
      req.oncomplete(status);
    } catch {
    }
    return 0;
  }
  useUserBuffer(_userBuf) {
    notImplemented1("LibuvStreamWrap.prototype.useUserBuffer");
  }
  writeBuffer(req, data) {
    this.#write(req, data);
    return 0;
  }
  writev(req, chunks, allBuffers) {
    const count = allBuffers ? chunks.length : chunks.length >> 1;
    const buffers = new Array(count);
    if (!allBuffers) {
      for (let i = 0; i < count; i++) {
        const chunk = chunks[i * 2];
        if (Buffer1.isBuffer(chunk)) {
          buffers[i] = chunk;
        }
        const encoding = chunks[i * 2 + 1];
        buffers[i] = Buffer1.from(chunk, encoding);
      }
    } else {
      for (let i12 = 0; i12 < count; i12++) {
        buffers[i12] = chunks[i12];
      }
    }
    return this.writeBuffer(req, Buffer1.concat(buffers));
  }
  writeAsciiString(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUtf8String(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUcs2String(_req, _data) {
    notImplemented1("LibuvStreamWrap.prototype.writeUcs2String");
  }
  writeLatin1String(req, data) {
    const buffer = Buffer1.from(data, "latin1");
    return this.writeBuffer(req, buffer);
  }
  _onClose() {
    let status = 0;
    this.#reading = false;
    try {
      this[kStreamBaseField1]?.close();
    } catch {
      status = codeMap1.get("ENOTCONN");
    }
    return status;
  }
  #attachToObject(stream1) {
    this[kStreamBaseField1] = stream1;
  }
  async #read() {
    let buf2 = new Uint8Array(SUGGESTED_SIZE1);
    let nread2;
    try {
      nread2 = await this[kStreamBaseField1].read(buf2);
    } catch (e7) {
      if (e7 instanceof Deno.errors.Interrupted || e7 instanceof Deno.errors.BadResource) {
        nread2 = codeMap1.get("EOF");
      } else if (e7 instanceof Deno.errors.ConnectionReset || e7 instanceof Deno.errors.ConnectionAborted) {
        nread2 = codeMap1.get("ECONNRESET");
      } else {
        nread2 = codeMap1.get("UNKNOWN");
      }
      buf2 = new Uint8Array(0);
    }
    nread2 ??= codeMap1.get("EOF");
    streamBaseState1[kReadBytesOrError1] = nread2;
    if (nread2 > 0) {
      this.bytesRead += nread2;
    }
    buf2 = buf2.slice(0, nread2);
    streamBaseState1[kArrayBufferOffset1] = 0;
    try {
      this.onread(buf2, nread2);
    } catch {
    }
    if (nread2 >= 0 && this.#reading) {
      this.#read();
    }
  }
  async #write(req3, data1) {
    const { byteLength: byteLength3 } = data1;
    try {
      await writeAll1(this[kStreamBaseField1], data1);
    } catch (e13) {
      let status1;
      if (e13 instanceof Deno.errors.BadResource || e13 instanceof Deno.errors.BrokenPipe) {
        status1 = codeMap1.get("EBADF");
      } else {
        status1 = codeMap1.get("UNKNOWN");
      }
      try {
        req3.oncomplete(status1);
      } catch {
      }
      return;
    }
    streamBaseState1[kBytesWritten1] = byteLength3;
    this.bytesWritten += byteLength3;
    try {
      req3.oncomplete(0);
    } catch {
    }
    return;
  }
};
var mod87 = {
  kReadBytesOrError: kReadBytesOrError1,
  kArrayBufferOffset: kArrayBufferOffset1,
  kBytesWritten: kBytesWritten1,
  kLastWriteWasAsync: kLastWriteWasAsync1,
  kNumStreamBaseStateFields: kNumStreamBaseStateFields1,
  streamBaseState: streamBaseState1,
  WriteWrap: WriteWrap1,
  ShutdownWrap: ShutdownWrap1,
  kStreamBaseField: kStreamBaseField1,
  LibuvStreamWrap: LibuvStreamWrap1
};
var ConnectionWrap1 = class extends LibuvStreamWrap1 {
  onconnection = null;
  constructor(provider, object) {
    super(provider, object);
  }
  afterConnect(req, status) {
    const isSuccessStatus = !status;
    const readable = isSuccessStatus;
    const writable = isSuccessStatus;
    try {
      req.oncomplete(status, this, req, readable, writable);
    } catch {
    }
    return;
  }
};
function ceilPowOf21(n3) {
  const roundPowOf2 = 1 << 31 - Math.clz32(n3);
  return roundPowOf2 < n3 ? roundPowOf2 * 2 : roundPowOf2;
}
var INITIAL_ACCEPT_BACKOFF_DELAY1 = 5;
var MAX_ACCEPT_BACKOFF_DELAY1 = 1e3;
var socketType2;
(function(socketType4) {
  socketType4[socketType4["SOCKET"] = 0] = "SOCKET";
  socketType4[socketType4["SERVER"] = 1] = "SERVER";
  socketType4[socketType4["IPC"] = 2] = "IPC";
})(socketType2 || (socketType2 = {}));
var Pipe1 = class extends ConnectionWrap1 {
  reading = false;
  ipc;
  #pendingInstances = 4;
  #address;
  #backlog;
  #listener;
  #connections = 0;
  #closed = false;
  #acceptBackoffDelay;
  constructor(type, conn) {
    let provider;
    let ipc;
    switch (type) {
      case socketType2.SOCKET: {
        provider = providerType1.PIPEWRAP;
        ipc = false;
        break;
      }
      case socketType2.SERVER: {
        provider = providerType1.PIPESERVERWRAP;
        ipc = false;
        break;
      }
      case socketType2.IPC: {
        provider = providerType1.PIPEWRAP;
        ipc = true;
        break;
      }
      default: {
        unreachable1();
      }
    }
    super(provider, conn);
    this.ipc = ipc;
    if (conn && provider === providerType1.PIPEWRAP) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.path;
    }
  }
  open(_fd) {
    notImplemented1("Pipe.prototype.open");
  }
  bind(name) {
    this.#address = name;
    return 0;
  }
  connect(req, address) {
    if (isWindows1) {
      notImplemented1("Pipe.prototype.connect - Windows");
    }
    const connectOptions = {
      path: address,
      transport: "unix"
    };
    connect1(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req.address = localAddr.path;
      this[kStreamBaseField1] = conn;
      try {
        this.afterConnect(req, 0);
      } catch {
      }
    }, (e) => {
      let code2;
      if (e instanceof Deno.errors.NotFound) {
        code2 = codeMap1.get("ENOENT");
      } else if (e instanceof Deno.errors.PermissionDenied) {
        code2 = codeMap1.get("EACCES");
      } else {
        code2 = codeMap1.get("ECONNREFUSED");
      }
      try {
        this.afterConnect(req, code2);
      } catch {
      }
    });
    return 0;
  }
  listen(backlog) {
    if (isWindows1) {
      notImplemented1("Pipe.prototype.listen - Windows");
    }
    this.#backlog = isWindows1 ? this.#pendingInstances : ceilPowOf21(backlog + 1);
    const listenOptions = {
      path: this.#address,
      transport: "unix"
    };
    let listener;
    try {
      listener = listen1(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap1.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap1.get("EADDRNOTAVAIL");
      }
      return codeMap1.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.path;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef1(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref1(this.#listener);
    }
  }
  setPendingInstances(instances) {
    this.#pendingInstances = instances;
  }
  fchmod(mode) {
    if (mode != constants5.UV_READABLE && mode != constants5.UV_WRITABLE && mode != (constants5.UV_WRITABLE | constants5.UV_READABLE)) {
      return codeMap1.get("EINVAL");
    }
    let desired_mode = 0;
    if (mode & constants5.UV_READABLE) {
      desired_mode |= fs1.S_IRUSR | fs1.S_IRGRP | fs1.S_IROTH;
    }
    if (mode & constants5.UV_WRITABLE) {
      desired_mode |= fs1.S_IWUSR | fs1.S_IWGRP | fs1.S_IWOTH;
    }
    try {
      Deno.chmodSync(this.#address, desired_mode);
    } catch {
      return codeMap1.get("UNKNOWN");
    }
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY1;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= 1e3) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY1;
    }
    await delay1(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection2;
    try {
      connection2 = await this.#listener.accept();
    } catch (e8) {
      if (e8 instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap1.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle2 = new Pipe1(socketType2.SOCKET, connection2);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle2);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === providerType1.PIPESERVERWRAP) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap1.prototype._onClose.call(this);
  }
};
var PipeConnectWrap1 = class extends AsyncWrap1 {
  oncomplete;
  address;
  constructor() {
    super(providerType1.PIPECONNECTWRAP);
  }
};
var constants5;
(function(constants7) {
  constants7[constants7["SOCKET"] = socketType2.SOCKET] = "SOCKET";
  constants7[constants7["SERVER"] = socketType2.SERVER] = "SERVER";
  constants7[constants7["IPC"] = socketType2.IPC] = "IPC";
  constants7[constants7["UV_READABLE"] = 1] = "UV_READABLE";
  constants7[constants7["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants5 || (constants5 = {}));
var mod88 = {
  socketType: socketType2,
  Pipe: Pipe1,
  PipeConnectWrap: PipeConnectWrap1,
  constants: constants5
};
var mod89 = {};
var mod90 = {};
var mod91 = {};
var mod92 = {};
var mod93 = {};
var mod94 = {};
var asyncIdSymbol1 = Symbol("asyncIdSymbol");
var ownerSymbol1 = Symbol("ownerSymbol");
var mod95 = {
  asyncIdSymbol: asyncIdSymbol1,
  ownerSymbol: ownerSymbol1
};
var mod96 = {};
var socketType3;
(function(socketType4) {
  socketType4[socketType4["SOCKET"] = 0] = "SOCKET";
  socketType4[socketType4["SERVER"] = 1] = "SERVER";
})(socketType3 || (socketType3 = {}));
var TCPConnectWrap1 = class extends AsyncWrap1 {
  oncomplete;
  address;
  port;
  localAddress;
  localPort;
  constructor() {
    super(providerType1.TCPCONNECTWRAP);
  }
};
var constants6;
(function(constants7) {
  constants7[constants7["SOCKET"] = socketType3.SOCKET] = "SOCKET";
  constants7[constants7["SERVER"] = socketType3.SERVER] = "SERVER";
  constants7[constants7["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants6 || (constants6 = {}));
var TCP1 = class extends ConnectionWrap1 {
  [ownerSymbol1] = null;
  reading = false;
  #address;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #backlog;
  #listener;
  #connections = 0;
  #closed = false;
  #acceptBackoffDelay;
  constructor(type, conn) {
    let provider;
    switch (type) {
      case socketType3.SOCKET: {
        provider = providerType1.TCPWRAP;
        break;
      }
      case socketType3.SERVER: {
        provider = providerType1.TCPSERVERWRAP;
        break;
      }
      default: {
        unreachable1();
      }
    }
    super(provider, conn);
    if (conn && provider === providerType1.TCPWRAP) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.hostname;
      this.#port = localAddr.port;
      const remoteAddr = conn.remoteAddr;
      this.#remoteAddress = remoteAddr.hostname;
      this.#remotePort = remoteAddr.port;
      this.#remoteFamily = isIP1(remoteAddr.hostname);
    }
  }
  open(_fd) {
    notImplemented1("TCP.prototype.open");
  }
  bind(address, port) {
    return this.#bind(address, port, 0);
  }
  bind6(address, port, flags) {
    return this.#bind(address, port, flags);
  }
  connect(req, address, port) {
    return this.#connect(req, address, port);
  }
  connect6(req, address, port) {
    return this.#connect(req, address, port);
  }
  listen(backlog) {
    this.#backlog = ceilPowOf21(backlog + 1);
    const listenOptions = {
      hostname: this.#address,
      port: this.#port,
      transport: "tcp"
    };
    let listener;
    try {
      listener = Deno.listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap1.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap1.get("EADDRNOTAVAIL");
      }
      return codeMap1.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.hostname;
    this.#port = address.port;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef1(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref1(this.#listener);
    }
  }
  getsockname(sockname) {
    if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
      return codeMap1.get("EADDRNOTAVAIL");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = isIP1(this.#address);
    return 0;
  }
  getpeername(peername) {
    if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
      return codeMap1.get("EADDRNOTAVAIL");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  setNoDelay(_noDelay) {
    return 0;
  }
  setKeepAlive(_enable, _initialDelay) {
    return 0;
  }
  setSimultaneousAccepts(_enable) {
    notImplemented1("TCP.prototype.setSimultaneousAccepts");
  }
  #bind(address3, port4, _flags2) {
    this.#address = address3;
    this.#port = port4;
    return 0;
  }
  #connect(req4, address11, port13) {
    this.#remoteAddress = address11;
    this.#remotePort = port13;
    this.#remoteFamily = isIP1(address11);
    const connectOptions1 = {
      hostname: address11,
      port: port13,
      transport: "tcp"
    };
    Deno.connect(connectOptions1).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req4.localAddress = localAddr.hostname;
      this.#port = req4.localPort = localAddr.port;
      this[kStreamBaseField1] = conn;
      try {
        this.afterConnect(req4, 0);
      } catch {
      }
    }, () => {
      try {
        this.afterConnect(req4, codeMap1.get("ECONNREFUSED"));
      } catch {
      }
    });
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY1;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= 1e3) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY1;
    }
    await delay1(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection3;
    try {
      connection3 = await this.#listener.accept();
    } catch (e9) {
      if (e9 instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap1.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle3 = new TCP1(socketType3.SOCKET, connection3);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle3);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#remoteAddress = void 0;
    this.#remoteFamily = void 0;
    this.#remotePort = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === providerType1.TCPSERVERWRAP) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap1.prototype._onClose.call(this);
  }
};
var mod97 = {
  TCPConnectWrap: TCPConnectWrap1,
  constants: constants6,
  TCP: TCP1
};
var mod98 = {};
var mod99 = {};
var mod100 = {};
var mod101 = {};
var AF_INET61 = 10;
var UDP_DGRAM_MAXSIZE1 = 64 * 1024;
var SendWrap1 = class extends AsyncWrap1 {
  list;
  address;
  port;
  callback;
  oncomplete;
  constructor() {
    super(providerType1.UDPSENDWRAP);
  }
};
var UDP1 = class extends HandleWrap1 {
  [ownerSymbol1] = null;
  #address;
  #family;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #listener;
  #receiving = false;
  #recvBufferSize = UDP_DGRAM_MAXSIZE1;
  #sendBufferSize = UDP_DGRAM_MAXSIZE1;
  onmessage;
  lookup;
  constructor() {
    super(providerType1.UDPWRAP);
  }
  addMembership(_multicastAddress, _interfaceAddress) {
    notImplemented1("udp.UDP.prototype.addMembership");
  }
  addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented1("udp.UDP.prototype.addSourceSpecificMembership");
  }
  bind(ip, port, flags) {
    return this.#doBind(ip, port, flags, 2);
  }
  bind6(ip, port, flags) {
    return this.#doBind(ip, port, flags, 10);
  }
  bufferSize(size, buffer, ctx) {
    let err;
    if (size > UDP_DGRAM_MAXSIZE1) {
      err = "EINVAL";
    } else if (!this.#address) {
      err = isWindows1 ? "ENOTSOCK" : "EBADF";
    }
    if (err) {
      ctx.errno = codeMap1.get(err);
      ctx.code = err;
      ctx.message = errorMap1.get(ctx.errno)[1];
      ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
      return;
    }
    if (size !== 0) {
      size = isLinux1 ? size * 2 : size;
      if (buffer) {
        return this.#recvBufferSize = size;
      }
      return this.#sendBufferSize = size;
    }
    return buffer ? this.#recvBufferSize : this.#sendBufferSize;
  }
  connect(ip, port) {
    return this.#doConnect(ip, port, 2);
  }
  connect6(ip, port) {
    return this.#doConnect(ip, port, 10);
  }
  disconnect() {
    this.#remoteAddress = void 0;
    this.#remotePort = void 0;
    this.#remoteFamily = void 0;
    return 0;
  }
  dropMembership(_multicastAddress, _interfaceAddress) {
    notImplemented1("udp.UDP.prototype.dropMembership");
  }
  dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented1("udp.UDP.prototype.dropSourceSpecificMembership");
  }
  getpeername(peername) {
    if (this.#remoteAddress === void 0) {
      return codeMap1.get("EBADF");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  getsockname(sockname) {
    if (this.#address === void 0) {
      return codeMap1.get("EBADF");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = this.#family;
    return 0;
  }
  open(_fd) {
    notImplemented1("udp.UDP.prototype.open");
  }
  recvStart() {
    if (!this.#receiving) {
      this.#receiving = true;
      this.#receive();
    }
    return 0;
  }
  recvStop() {
    this.#receiving = false;
    return 0;
  }
  ref() {
    notImplemented1("udp.UDP.prototype.ref");
  }
  send(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, 2);
  }
  send6(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, 10);
  }
  setBroadcast(_bool) {
    notImplemented1("udp.UDP.prototype.setBroadcast");
  }
  setMulticastInterface(_interfaceAddress) {
    notImplemented1("udp.UDP.prototype.setMulticastInterface");
  }
  setMulticastLoopback(_bool) {
    notImplemented1("udp.UDP.prototype.setMulticastLoopback");
  }
  setMulticastTTL(_ttl) {
    notImplemented1("udp.UDP.prototype.setMulticastTTL");
  }
  setTTL(_ttl) {
    notImplemented1("udp.UDP.prototype.setTTL");
  }
  unref() {
    notImplemented1("udp.UDP.prototype.unref");
  }
  #doBind(ip2, port5, _flags3, family2) {
    const listenOptions1 = {
      port: port5,
      hostname: ip2,
      transport: "udp"
    };
    let listener1;
    try {
      listener1 = listenDatagram1(listenOptions1);
    } catch (e10) {
      if (e10 instanceof Deno.errors.AddrInUse) {
        return codeMap1.get("EADDRINUSE");
      } else if (e10 instanceof Deno.errors.AddrNotAvailable) {
        return codeMap1.get("EADDRNOTAVAIL");
      }
      return codeMap1.get("UNKNOWN");
    }
    const address4 = listener1.addr;
    this.#address = address4.hostname;
    this.#port = address4.port;
    this.#family = family2 === AF_INET61 ? "IPv6" : "IPv4";
    this.#listener = listener1;
    return 0;
  }
  #doConnect(ip11, port14, family11) {
    this.#remoteAddress = ip11;
    this.#remotePort = port14;
    this.#remoteFamily = family11 === AF_INET61 ? "IPv6" : "IPv4";
    return 0;
  }
  #doSend(req5, bufs1, _count1, args1, _family1) {
    let hasCallback1;
    if (args1.length === 3) {
      this.#remotePort = args1[0];
      this.#remoteAddress = args1[1];
      hasCallback1 = args1[2];
    } else {
      hasCallback1 = args1[0];
    }
    const addr1 = {
      hostname: this.#remoteAddress,
      port: this.#remotePort,
      transport: "udp"
    };
    const payload1 = new Uint8Array(Buffer1.concat(bufs1.map((buf) => {
      if (typeof buf === "string") {
        return Buffer1.from(buf);
      }
      return Buffer1.from(buf.buffer, buf.byteOffset, buf.byteLength);
    })));
    (async () => {
      let sent;
      let err = null;
      try {
        sent = await this.#listener.send(payload1, addr1);
      } catch (e) {
        if (e instanceof Deno.errors.BadResource) {
          err = codeMap1.get("EBADF");
        } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
          err = codeMap1.get("EMSGSIZE");
        } else {
          err = codeMap1.get("UNKNOWN");
        }
        sent = 0;
      }
      if (hasCallback1) {
        try {
          req5.oncomplete(err, sent);
        } catch {
        }
      }
    })();
    return 0;
  }
  async #receive() {
    if (!this.#receiving) {
      return;
    }
    const p8 = new Uint8Array(this.#recvBufferSize);
    let buf3;
    let remoteAddr1;
    let nread3;
    try {
      [buf3, remoteAddr1] = await this.#listener.receive(p8);
      nread3 = buf3.length;
    } catch (e14) {
      if (e14 instanceof Deno.errors.Interrupted || e14 instanceof Deno.errors.BadResource) {
        nread3 = 0;
      } else {
        nread3 = codeMap1.get("UNKNOWN");
      }
      buf3 = new Uint8Array(0);
      remoteAddr1 = null;
    }
    nread3 ??= 0;
    const rinfo1 = remoteAddr1 ? {
      address: remoteAddr1.hostname,
      port: remoteAddr1.port,
      family: isIP1(remoteAddr1.hostname) === 6 ? "IPv6" : "IPv4"
    } : void 0;
    try {
      this.onmessage(nread3, this, Buffer1.from(buf3), rinfo1);
    } catch {
    }
    this.#receive();
  }
  _onClose() {
    this.#receiving = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#family = void 0;
    try {
      this.#listener.close();
    } catch {
    }
    this.#listener = void 0;
    return 0;
  }
};
var mod102 = {
  SendWrap: SendWrap1,
  UDP: UDP1
};
var mod103 = {};
var mod104 = {};
var mod105 = {};
var mod106 = {};
var modules1 = {
  "async_wrap": mod66,
  buffer: mod63,
  "cares_wrap": mod68,
  config: mod67,
  constants: mod60,
  contextify: mod69,
  credentials: mod71,
  crypto: mod70,
  errors: mod72,
  fs: mod73,
  "fs_dir": mod74,
  "fs_event_wrap": mod75,
  "heap_utils": mod76,
  "http_parser": mod77,
  icu: mod78,
  inspector: mod79,
  "js_stream": mod80,
  messaging: mod81,
  "module_wrap": mod82,
  "native_module": mod83,
  natives: mod84,
  options: mod85,
  os: mod86,
  performance: mod89,
  "pipe_wrap": mod88,
  "process_methods": mod90,
  report: mod91,
  serdes: mod92,
  "signal_wrap": mod93,
  "spawn_sync": mod94,
  "stream_wrap": mod87,
  "string_decoder": mod62,
  symbols: mod95,
  "task_queue": mod96,
  "tcp_wrap": mod97,
  timers: mod98,
  "tls_wrap": mod99,
  "trace_events": mod100,
  "tty_wrap": mod101,
  types: mod57,
  "udp_wrap": mod102,
  url: mod103,
  util: mod59,
  uv: mod61,
  v8: mod104,
  worker: mod105,
  zlib: mod106
};
function getBinding1(name) {
  const mod114 = modules1[name];
  if (!mod114) {
    throw new Error(`No such module: ${name}`);
  }
  return mod114;
}
var kInternal1 = Symbol("internal properties");
var replaceUnderscoresRegex1 = /_/g;
var leadingDashesRegex1 = /^--?/;
var trailingValuesRegex1 = /=.*$/;
function buildAllowedFlags1() {
  const allowedNodeEnvironmentFlags = [
    "--track-heap-objects",
    "--no-track-heap-objects",
    "--node-snapshot",
    "--no-node-snapshot",
    "--require",
    "--max-old-space-size",
    "--trace-exit",
    "--no-trace-exit",
    "--disallow-code-generation-from-strings",
    "--experimental-json-modules",
    "--no-experimental-json-modules",
    "--interpreted-frames-native-stack",
    "--inspect-brk",
    "--no-inspect-brk",
    "--trace-tls",
    "--no-trace-tls",
    "--stack-trace-limit",
    "--experimental-repl-await",
    "--no-experimental-repl-await",
    "--preserve-symlinks",
    "--no-preserve-symlinks",
    "--report-uncaught-exception",
    "--no-report-uncaught-exception",
    "--experimental-modules",
    "--no-experimental-modules",
    "--report-signal",
    "--jitless",
    "--inspect-port",
    "--heapsnapshot-near-heap-limit",
    "--tls-keylog",
    "--force-context-aware",
    "--no-force-context-aware",
    "--napi-modules",
    "--abort-on-uncaught-exception",
    "--diagnostic-dir",
    "--verify-base-objects",
    "--no-verify-base-objects",
    "--unhandled-rejections",
    "--perf-basic-prof",
    "--trace-atomics-wait",
    "--no-trace-atomics-wait",
    "--deprecation",
    "--no-deprecation",
    "--perf-basic-prof-only-functions",
    "--perf-prof",
    "--max-http-header-size",
    "--report-on-signal",
    "--no-report-on-signal",
    "--throw-deprecation",
    "--no-throw-deprecation",
    "--warnings",
    "--no-warnings",
    "--force-fips",
    "--no-force-fips",
    "--pending-deprecation",
    "--no-pending-deprecation",
    "--input-type",
    "--tls-max-v1.3",
    "--no-tls-max-v1.3",
    "--tls-min-v1.2",
    "--no-tls-min-v1.2",
    "--inspect",
    "--no-inspect",
    "--heapsnapshot-signal",
    "--trace-warnings",
    "--no-trace-warnings",
    "--trace-event-categories",
    "--experimental-worker",
    "--tls-max-v1.2",
    "--no-tls-max-v1.2",
    "--perf-prof-unwinding-info",
    "--preserve-symlinks-main",
    "--no-preserve-symlinks-main",
    "--policy-integrity",
    "--experimental-wasm-modules",
    "--no-experimental-wasm-modules",
    "--node-memory-debug",
    "--inspect-publish-uid",
    "--tls-min-v1.3",
    "--no-tls-min-v1.3",
    "--experimental-specifier-resolution",
    "--secure-heap",
    "--tls-min-v1.0",
    "--no-tls-min-v1.0",
    "--redirect-warnings",
    "--experimental-report",
    "--trace-event-file-pattern",
    "--trace-uncaught",
    "--no-trace-uncaught",
    "--experimental-loader",
    "--http-parser",
    "--dns-result-order",
    "--trace-sigint",
    "--no-trace-sigint",
    "--secure-heap-min",
    "--enable-fips",
    "--no-enable-fips",
    "--enable-source-maps",
    "--no-enable-source-maps",
    "--insecure-http-parser",
    "--no-insecure-http-parser",
    "--use-openssl-ca",
    "--no-use-openssl-ca",
    "--tls-cipher-list",
    "--experimental-top-level-await",
    "--no-experimental-top-level-await",
    "--openssl-config",
    "--icu-data-dir",
    "--v8-pool-size",
    "--report-on-fatalerror",
    "--no-report-on-fatalerror",
    "--title",
    "--tls-min-v1.1",
    "--no-tls-min-v1.1",
    "--report-filename",
    "--trace-deprecation",
    "--no-trace-deprecation",
    "--report-compact",
    "--no-report-compact",
    "--experimental-policy",
    "--experimental-import-meta-resolve",
    "--no-experimental-import-meta-resolve",
    "--zero-fill-buffers",
    "--no-zero-fill-buffers",
    "--report-dir",
    "--use-bundled-ca",
    "--no-use-bundled-ca",
    "--experimental-vm-modules",
    "--no-experimental-vm-modules",
    "--force-async-hooks-checks",
    "--no-force-async-hooks-checks",
    "--frozen-intrinsics",
    "--no-frozen-intrinsics",
    "--huge-max-old-generation-size",
    "--disable-proto",
    "--debug-arraybuffer-allocations",
    "--no-debug-arraybuffer-allocations",
    "--conditions",
    "--experimental-wasi-unstable-preview1",
    "--no-experimental-wasi-unstable-preview1",
    "--trace-sync-io",
    "--no-trace-sync-io",
    "--use-largepages",
    "--experimental-abortcontroller",
    "--debug-port",
    "--es-module-specifier-resolution",
    "--prof-process",
    "-C",
    "--loader",
    "--report-directory",
    "-r",
    "--trace-events-enabled"
  ];
  const trimLeadingDashes = (flag) => flag.replace(leadingDashesRegex1, "");
  const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
  class NodeEnvironmentFlagsSet extends Set {
    constructor(array) {
      super();
      this[kInternal1] = {
        array
      };
    }
    add() {
      return this;
    }
    delete() {
      return false;
    }
    clear() {
    }
    has(key2) {
      if (typeof key2 === "string") {
        key2 = key2.replace(replaceUnderscoresRegex1, "-");
        if (leadingDashesRegex1.test(key2)) {
          key2 = key2.replace(trailingValuesRegex1, "");
          return this[kInternal1].array.includes(key2);
        }
        return nodeFlags.includes(key2);
      }
      return false;
    }
    entries() {
      this[kInternal1].set ??= new Set(this[kInternal1].array);
      return this[kInternal1].set.entries();
    }
    forEach(callback, thisArg = void 0) {
      this[kInternal1].array.forEach((v19) => Reflect.apply(callback, thisArg, [
        v19,
        v19,
        this
      ]));
    }
    get size() {
      return this[kInternal1].array.length;
    }
    values() {
      this[kInternal1].set ??= new Set(this[kInternal1].array);
      return this[kInternal1].set.values();
    }
  }
  NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
  Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
  Object.freeze(NodeEnvironmentFlagsSet.prototype);
  return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
var notImplementedEvents1 = [
  "beforeExit",
  "disconnect",
  "message",
  "multipleResolves",
  "rejectionHandled",
  "uncaughtException",
  "uncaughtExceptionMonitor",
  "unhandledRejection",
  "worker"
];
var argv1 = [
  "",
  "",
  ...Deno.args
];
Object.defineProperty(argv1, "0", {
  get: Deno.execPath
});
Object.defineProperty(argv1, "1", {
  get: () => fromFileUrl5(Deno.mainModule)
});
var exit1 = (code2) => {
  if (code2 || code2 === 0) {
    if (typeof code2 === "string") {
      const parsedCode = parseInt(code2);
      process2.exitCode = isNaN(parsedCode) ? void 0 : parsedCode;
    } else {
      process2.exitCode = code2;
    }
  }
  if (!process2._exiting) {
    process2._exiting = true;
    process2.emit("exit", process2.exitCode || 0);
  }
  Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias1(name, option, enumerable = true) {
  const value = getOptionValue1(option);
  if (value) {
    Object.defineProperty(process2, name, {
      writable: false,
      configurable: true,
      enumerable,
      value
    });
  }
}
function createWarningObject1(warning, type, code2, ctor, detail) {
  assert3(typeof warning === "string");
  const warningErr = new Error(warning);
  warningErr.name = String(type || "Warning");
  if (code2 !== void 0) {
    warningErr.code = code2;
  }
  if (detail !== void 0) {
    warningErr.detail = detail;
  }
  Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
  return warningErr;
}
function doEmitWarning1(warning) {
  process2.emit("warning", warning);
}
function emitWarning1(warning, type, code2, ctor) {
  let detail;
  if (type !== null && typeof type === "object" && !Array.isArray(type)) {
    ctor = type.ctor;
    code2 = type.code;
    if (typeof type.detail === "string") {
      detail = type.detail;
    }
    type = type.type || "Warning";
  } else if (typeof type === "function") {
    ctor = type;
    code2 = void 0;
    type = "Warning";
  }
  if (type !== void 0) {
    validateString1(type, "type");
  }
  if (typeof code2 === "function") {
    ctor = code2;
    code2 = void 0;
  } else if (code2 !== void 0) {
    validateString1(code2, "code");
  }
  if (typeof warning === "string") {
    warning = createWarningObject1(warning, type, code2, ctor, detail);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE1("warning", [
      "Error",
      "string"
    ], warning);
  }
  if (warning.name === "DeprecationWarning") {
    if (process2.noDeprecation) {
      return;
    }
    if (process2.throwDeprecation) {
      return process2.nextTick(() => {
        throw warning;
      });
    }
  }
  process2.nextTick(doEmitWarning1, warning);
}
function hrtime1(time) {
  const milli = performance.now();
  const sec = Math.floor(milli / 1e3);
  const nano = Math.floor(milli * 1e6 - sec * 1e9);
  if (!time) {
    return [
      sec,
      nano
    ];
  }
  const [prevSec, prevNano] = time;
  return [
    sec - prevSec,
    nano - prevNano
  ];
}
hrtime1.bigint = function() {
  const [sec, nano] = hrtime1();
  return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage1() {
  return {
    ...Deno.memoryUsage(),
    arrayBuffers: 0
  };
}
memoryUsage1.rss = function() {
  return memoryUsage1().rss;
};
function kill1(pid2, sig = "SIGTERM") {
  if (pid2 != (pid2 | 0)) {
    throw new ERR_INVALID_ARG_TYPE1("pid", "number", pid2);
  }
  if (typeof sig === "string") {
    try {
      Deno.kill(pid2, sig);
    } catch (e) {
      if (e instanceof TypeError) {
        throw new ERR_UNKNOWN_SIGNAL1(sig);
      }
      throw e;
    }
  } else {
    throw new ERR_UNKNOWN_SIGNAL1(sig.toString());
  }
  return true;
}
var Process1 = class extends EventEmitter1 {
  constructor() {
    super();
    globalThis.addEventListener("unload", () => {
      if (!process2._exiting) {
        process2._exiting = true;
        super.emit("exit", process2.exitCode || 0);
      }
    });
  }
  arch = arch1;
  argv = argv1;
  chdir = chdir1;
  config = {
    target_defaults: {},
    variables: {}
  };
  cwd = cwd1;
  env = env1;
  execArgv = [];
  exit = exit1;
  _exiting = _exiting1;
  exitCode = void 0;
  mainModule = void 0;
  nextTick = nextTick3;
  on(event, listener) {
    if (notImplementedEvents1.includes(event)) {
      warnNotImplemented1(`process.on("${event}")`);
      super.on(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener1(event, listener);
      }
    } else {
      super.on(event, listener);
    }
    return this;
  }
  off(event, listener) {
    if (notImplementedEvents1.includes(event)) {
      warnNotImplemented1(`process.off("${event}")`);
      super.off(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        removeSignalListener1(event, listener);
      }
    } else {
      super.off(event, listener);
    }
    return this;
  }
  emit(event, ...args) {
    if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        Deno.kill(Deno.pid, event);
      }
    } else {
      return super.emit(event, ...args);
    }
    return true;
  }
  prependListener(event, listener) {
    if (notImplementedEvents1.includes(event)) {
      warnNotImplemented1(`process.prependListener("${event}")`);
      super.prependListener(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener1(event, listener);
      }
    } else {
      super.prependListener(event, listener);
    }
    return this;
  }
  pid = pid1;
  platform = platform1;
  addListener(event, listener) {
    if (notImplementedEvents1.includes(event)) {
      warnNotImplemented1(`process.addListener("${event}")`);
    }
    return this.on(event, listener);
  }
  removeListener(event, listener) {
    if (notImplementedEvents1.includes(event)) {
      warnNotImplemented1(`process.removeListener("${event}")`);
    }
    return this.off(event, listener);
  }
  hrtime = hrtime1;
  kill = kill1;
  memoryUsage = memoryUsage1;
  stderr = stderr1;
  stdin = stdin1;
  stdout = stdout1;
  version = version1;
  versions = versions1;
  emitWarning = emitWarning1;
  binding(name) {
    return getBinding1(name);
  }
  umask() {
    return 18;
  }
  getuid() {
    return NaN;
  }
  getgid() {
    return NaN;
  }
  _eval = void 0;
  get execPath() {
    return argv1[0];
  }
  #startTime = Date.now();
  uptime() {
    return (Date.now() - this.#startTime) / 1e3;
  }
  #allowedFlags = buildAllowedFlags1();
  get allowedNodeEnvironmentFlags() {
    return this.#allowedFlags;
  }
  features = {
    inspector: false
  };
};
var process2 = new Process1();
Object.defineProperty(process2, Symbol.toStringTag, {
  enumerable: false,
  writable: true,
  configurable: false,
  value: "process"
});
addReadOnlyProcessAlias1("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias1("throwDeprecation", "--throw-deprecation");
process2.removeListener;
process2.removeAllListeners;
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
var s2 = Object.create;
var f2 = Object.defineProperty;
var p9 = Object.getOwnPropertyDescriptor;
var d5 = Object.getOwnPropertyNames;
var w6 = Object.getPrototypeOf;
var g6 = Object.prototype.hasOwnProperty;
var h4 = (r2, e) => () => (e || r2((e = {
  exports: {}
}).exports, e), e.exports);
var m5 = (r2, e, t2, a7) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o6 of d5(e))
      !g6.call(r2, o6) && o6 !== t2 && f2(r2, o6, {
        get: () => e[o6],
        enumerable: !(a7 = p9(e, o6)) || a7.enumerable
      });
  return r2;
};
var c4 = (r2, e, t2) => (t2 = r2 != null ? s2(w6(r2)) : {}, m5(e || !r2 || !r2.__esModule ? f2(t2, "default", {
  value: r2,
  enumerable: true
}) : t2, r2));
var l5 = h4((x17, u12) => {
  u12.exports = $17;
  function $17(r2, e) {
    if (n3("noDeprecation"))
      return r2;
    var t2 = false;
    function a7() {
      if (!t2) {
        if (n3("throwDeprecation"))
          throw new Error(e);
        n3("traceDeprecation") ? console.trace(e) : console.warn(e), t2 = true;
      }
      return r2.apply(this, arguments);
    }
    return a7;
  }
  function n3(r2) {
    try {
      if (!__global$.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = __global$.localStorage[r2];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var i6 = c4(l5());
var v4 = c4(l5());
var { default: D, ...S2 } = v4;
var y5 = i6.default ?? D ?? S2;
var __global$1 = globalThis || (typeof window !== "undefined" ? window : self);
var At = Object.create;
var De1 = Object.defineProperty;
var Ot1 = Object.getOwnPropertyDescriptor;
var Lt1 = Object.getOwnPropertyNames;
var Dt = Object.getPrototypeOf;
var qt1 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (t2, r2) => (typeof require != "undefined" ? require : t2)[r2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var c5 = (e, t2) => () => (t2 || e((t2 = {
  exports: {}
}).exports, t2), t2.exports);
var Pt = (e, t2, r2, i) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let n3 of Lt1(t2))
      !qt1.call(e, n3) && n3 !== r2 && De1(e, n3, {
        get: () => t2[n3],
        enumerable: !(i = Ot1(t2, n3)) || i.enumerable
      });
  return e;
};
var qe1 = (e, t2, r2) => (r2 = e != null ? At(Dt(e)) : {}, Pt(t2 || !e || !e.__esModule ? De1(r2, "default", {
  value: e,
  enumerable: true
}) : r2, e));
var fe = c5((wi2, Pe4) => {
  Pe4.exports = EventEmitter1.EventEmitter;
});
var xe = c5((Ri2, Ie) => {
  "use strict";
  function Ne(e, t2) {
    var r2 = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t2 && (i = i.filter(function(n3) {
        return Object.getOwnPropertyDescriptor(e, n3).enumerable;
      })), r2.push.apply(r2, i);
    }
    return r2;
  }
  function Nt2(e) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2] != null ? arguments[t2] : {};
      t2 % 2 ? Ne(Object(r2), true).forEach(function(i) {
        Ct(e, i, r2[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r2)) : Ne(Object(r2)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r2, i));
      });
    }
    return e;
  }
  function Ct(e, t2, r2) {
    return t2 in e ? Object.defineProperty(e, t2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[t2] = r2, e;
  }
  function It2(e, t2) {
    if (!(e instanceof t2))
      throw new TypeError("Cannot call a class as a function");
  }
  function Ce(e, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var i = t2[r2];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  function xt(e, t2, r2) {
    return t2 && Ce(e.prototype, t2), r2 && Ce(e, r2), e;
  }
  var kt2 = export_default, Y7 = kt2.Buffer, jt = __default14, oe3 = jt.inspect, Wt = oe3 && oe3.custom || "inspect";
  function Ut(e, t2, r2) {
    Y7.prototype.copy.call(e, t2, r2);
  }
  Ie.exports = function() {
    function e() {
      It2(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return xt(e, [
      {
        key: "push",
        value: function(r2) {
          var i = {
            data: r2,
            next: null
          };
          this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
        }
      },
      {
        key: "unshift",
        value: function(r2) {
          var i = {
            data: r2,
            next: this.head
          };
          this.length === 0 && (this.tail = i), this.head = i, ++this.length;
        }
      },
      {
        key: "shift",
        value: function() {
          if (this.length !== 0) {
            var r2 = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r2;
          }
        }
      },
      {
        key: "clear",
        value: function() {
          this.head = this.tail = null, this.length = 0;
        }
      },
      {
        key: "join",
        value: function(r2) {
          if (this.length === 0)
            return "";
          for (var i = this.head, n3 = "" + i.data; i = i.next; )
            n3 += r2 + i.data;
          return n3;
        }
      },
      {
        key: "concat",
        value: function(r2) {
          if (this.length === 0)
            return Y7.alloc(0);
          for (var i = Y7.allocUnsafe(r2 >>> 0), n3 = this.head, a7 = 0; n3; )
            Ut(n3.data, i, a7), a7 += n3.data.length, n3 = n3.next;
          return i;
        }
      },
      {
        key: "consume",
        value: function(r2, i) {
          var n3;
          return r2 < this.head.data.length ? (n3 = this.head.data.slice(0, r2), this.head.data = this.head.data.slice(r2)) : r2 === this.head.data.length ? n3 = this.shift() : n3 = i ? this._getString(r2) : this._getBuffer(r2), n3;
        }
      },
      {
        key: "first",
        value: function() {
          return this.head.data;
        }
      },
      {
        key: "_getString",
        value: function(r2) {
          var i = this.head, n3 = 1, a7 = i.data;
          for (r2 -= a7.length; i = i.next; ) {
            var f8 = i.data, o6 = r2 > f8.length ? f8.length : r2;
            if (o6 === f8.length ? a7 += f8 : a7 += f8.slice(0, r2), r2 -= o6, r2 === 0) {
              o6 === f8.length ? (++n3, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f8.slice(o6));
              break;
            }
            ++n3;
          }
          return this.length -= n3, a7;
        }
      },
      {
        key: "_getBuffer",
        value: function(r2) {
          var i = Y7.allocUnsafe(r2), n3 = this.head, a7 = 1;
          for (n3.data.copy(i), r2 -= n3.data.length; n3 = n3.next; ) {
            var f8 = n3.data, o6 = r2 > f8.length ? f8.length : r2;
            if (f8.copy(i, i.length - r2, 0, o6), r2 -= o6, r2 === 0) {
              o6 === f8.length ? (++a7, n3.next ? this.head = n3.next : this.head = this.tail = null) : (this.head = n3, n3.data = f8.slice(o6));
              break;
            }
            ++a7;
          }
          return this.length -= a7, i;
        }
      },
      {
        key: Wt,
        value: function(r2, i) {
          return oe3(this, Nt2({}, i, {
            depth: 0,
            customInspect: false
          }));
        }
      }
    ]), e;
  }();
});
var ue = c5((Ei, je2) => {
  "use strict";
  function Bt(e, t2) {
    var r2 = this, i = this._readableState && this._readableState.destroyed, n3 = this._writableState && this._writableState.destroyed;
    return i || n3 ? (t2 ? t2(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process2.nextTick(le3, this, e)) : process2.nextTick(le3, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(a7) {
      !t2 && a7 ? r2._writableState ? r2._writableState.errorEmitted ? process2.nextTick($17, r2) : (r2._writableState.errorEmitted = true, process2.nextTick(ke3, r2, a7)) : process2.nextTick(ke3, r2, a7) : t2 ? (process2.nextTick($17, r2), t2(a7)) : process2.nextTick($17, r2);
    }), this);
  }
  function ke3(e, t2) {
    le3(e, t2), $17(e);
  }
  function $17(e) {
    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
  }
  function Ft() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function le3(e, t2) {
    e.emit("error", t2);
  }
  function Ht(e, t2) {
    var r2 = e._readableState, i = e._writableState;
    r2 && r2.autoDestroy || i && i.autoDestroy ? e.destroy(t2) : e.emit("error", t2);
  }
  je2.exports = {
    destroy: Bt,
    undestroy: Ft,
    errorOrDestroy: Ht
  };
});
var O1 = c5((Si2, Be2) => {
  "use strict";
  function Gt(e, t2) {
    e.prototype = Object.create(t2.prototype), e.prototype.constructor = e, e.__proto__ = t2;
  }
  var Ue2 = {};
  function b15(e, t2, r2) {
    r2 || (r2 = Error);
    function i(a7, f8, o6) {
      return typeof t2 == "string" ? t2 : t2(a7, f8, o6);
    }
    var n3 = function(a7) {
      Gt(f8, a7);
      function f8(o6, d14, p7) {
        return a7.call(this, i(o6, d14, p7)) || this;
      }
      return f8;
    }(r2);
    n3.prototype.name = r2.name, n3.prototype.code = e, Ue2[e] = n3;
  }
  function We2(e, t2) {
    if (Array.isArray(e)) {
      var r2 = e.length;
      return e = e.map(function(i) {
        return String(i);
      }), r2 > 2 ? "one of ".concat(t2, " ").concat(e.slice(0, r2 - 1).join(", "), ", or ") + e[r2 - 1] : r2 === 2 ? "one of ".concat(t2, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t2, " ").concat(e[0]);
    } else
      return "of ".concat(t2, " ").concat(String(e));
  }
  function Vt(e, t2, r2) {
    return e.substr(!r2 || r2 < 0 ? 0 : +r2, t2.length) === t2;
  }
  function Yt(e, t2, r2) {
    return (r2 === void 0 || r2 > e.length) && (r2 = e.length), e.substring(r2 - t2.length, r2) === t2;
  }
  function $t2(e, t2, r2) {
    return typeof r2 != "number" && (r2 = 0), r2 + t2.length > e.length ? false : e.indexOf(t2, r2) !== -1;
  }
  b15("ERR_INVALID_OPT_VALUE", function(e, t2) {
    return 'The value "' + t2 + '" is invalid for option "' + e + '"';
  }, TypeError);
  b15("ERR_INVALID_ARG_TYPE", function(e, t2, r2) {
    var i;
    typeof t2 == "string" && Vt(t2, "not ") ? (i = "must not be", t2 = t2.replace(/^not /, "")) : i = "must be";
    var n3;
    if (Yt(e, " argument"))
      n3 = "The ".concat(e, " ").concat(i, " ").concat(We2(t2, "type"));
    else {
      var a7 = $t2(e, ".") ? "property" : "argument";
      n3 = 'The "'.concat(e, '" ').concat(a7, " ").concat(i, " ").concat(We2(t2, "type"));
    }
    return n3 += ". Received type ".concat(typeof r2), n3;
  }, TypeError);
  b15("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  b15("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
    return "The " + e + " method is not implemented";
  });
  b15("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  b15("ERR_STREAM_DESTROYED", function(e) {
    return "Cannot call " + e + " after a stream was destroyed";
  });
  b15("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  b15("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  b15("ERR_STREAM_WRITE_AFTER_END", "write after end");
  b15("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  b15("ERR_UNKNOWN_ENCODING", function(e) {
    return "Unknown encoding: " + e;
  }, TypeError);
  b15("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Be2.exports.codes = Ue2;
});
var se = c5((Ti, Fe3) => {
  "use strict";
  var Kt2 = O1().codes.ERR_INVALID_OPT_VALUE;
  function Xt(e, t2, r2) {
    return e.highWaterMark != null ? e.highWaterMark : t2 ? e[r2] : null;
  }
  function zt2(e, t2, r2, i) {
    var n3 = Xt(t2, i, r2);
    if (n3 != null) {
      if (!(isFinite(n3) && Math.floor(n3) === n3) || n3 < 0) {
        var a7 = i ? r2 : "highWaterMark";
        throw new Kt2(a7, n3);
      }
      return Math.floor(n3);
    }
    return e.objectMode ? 16 : 16 * 1024;
  }
  Fe3.exports = {
    getHighWaterMark: zt2
  };
});
var ce = c5((Mi2, Ke2) => {
  "use strict";
  Ke2.exports = s10;
  function Ge2(e) {
    var t2 = this;
    this.next = null, this.entry = null, this.finish = function() {
      Sr(t2, e);
    };
  }
  var I13;
  s10.WritableState = B18;
  var Jt2 = {
    deprecate: y5
  }, Ve3 = fe(), X5 = export_default.Buffer, Qt = __global$1.Uint8Array || function() {
  };
  function Zt(e) {
    return X5.from(e);
  }
  function er2(e) {
    return X5.isBuffer(e) || e instanceof Qt;
  }
  var he3 = ue(), tr2 = se(), rr2 = tr2.getHighWaterMark, S14 = O1().codes, ir2 = S14.ERR_INVALID_ARG_TYPE, nr2 = S14.ERR_METHOD_NOT_IMPLEMENTED, ar2 = S14.ERR_MULTIPLE_CALLBACK, fr = S14.ERR_STREAM_CANNOT_PIPE, or3 = S14.ERR_STREAM_DESTROYED, lr = S14.ERR_STREAM_NULL_VALUES, ur = S14.ERR_STREAM_WRITE_AFTER_END, sr = S14.ERR_UNKNOWN_ENCODING, x17 = he3.errorOrDestroy;
  w(s10, Ve3);
  function dr2() {
  }
  function B18(e, t2, r2) {
    I13 = I13 || L3(), e = e || {}, typeof r2 != "boolean" && (r2 = t2 instanceof I13), this.objectMode = !!e.objectMode, r2 && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = rr2(this, e, "writableHighWaterMark", r2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var i = e.decodeStrings === false;
    this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(n3) {
      yr2(t2, n3);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ge2(this);
  }
  B18.prototype.getBuffer = function() {
    for (var t2 = this.bufferedRequest, r2 = []; t2; )
      r2.push(t2), t2 = t2.next;
    return r2;
  };
  (function() {
    try {
      Object.defineProperty(B18.prototype, "buffer", {
        get: Jt2.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var K14;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (K14 = Function.prototype[Symbol.hasInstance], Object.defineProperty(s10, Symbol.hasInstance, {
    value: function(t2) {
      return K14.call(this, t2) ? true : this !== s10 ? false : t2 && t2._writableState instanceof B18;
    }
  })) : K14 = function(t2) {
    return t2 instanceof this;
  };
  function s10(e) {
    I13 = I13 || L3();
    var t2 = this instanceof I13;
    if (!t2 && !K14.call(s10, this))
      return new s10(e);
    this._writableState = new B18(e, this, t2), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), Ve3.call(this);
  }
  s10.prototype.pipe = function() {
    x17(this, new fr());
  };
  function hr2(e, t2) {
    var r2 = new ur();
    x17(e, r2), process2.nextTick(t2, r2);
  }
  function cr(e, t2, r2, i) {
    var n3;
    return r2 === null ? n3 = new lr() : typeof r2 != "string" && !t2.objectMode && (n3 = new ir2("chunk", [
      "string",
      "Buffer"
    ], r2)), n3 ? (x17(e, n3), process2.nextTick(i, n3), false) : true;
  }
  s10.prototype.write = function(e, t2, r2) {
    var i = this._writableState, n3 = false, a7 = !i.objectMode && er2(e);
    return a7 && !X5.isBuffer(e) && (e = Zt(e)), typeof t2 == "function" && (r2 = t2, t2 = null), a7 ? t2 = "buffer" : t2 || (t2 = i.defaultEncoding), typeof r2 != "function" && (r2 = dr2), i.ending ? hr2(this, r2) : (a7 || cr(this, i, e, r2)) && (i.pendingcb++, n3 = br3(this, i, a7, e, t2, r2)), n3;
  };
  s10.prototype.cork = function() {
    this._writableState.corked++;
  };
  s10.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Ye2(this, e));
  };
  s10.prototype.setDefaultEncoding = function(t2) {
    if (typeof t2 == "string" && (t2 = t2.toLowerCase()), !([
      "hex",
      "utf8",
      "utf-8",
      "ascii",
      "binary",
      "base64",
      "ucs2",
      "ucs-2",
      "utf16le",
      "utf-16le",
      "raw"
    ].indexOf((t2 + "").toLowerCase()) > -1))
      throw new sr(t2);
    return this._writableState.defaultEncoding = t2, this;
  };
  Object.defineProperty(s10.prototype, "writableBuffer", {
    enumerable: false,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function pr2(e, t2, r2) {
    return !e.objectMode && e.decodeStrings !== false && typeof t2 == "string" && (t2 = X5.from(t2, r2)), t2;
  }
  Object.defineProperty(s10.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function br3(e, t2, r2, i, n3, a7) {
    if (!r2) {
      var f8 = pr2(t2, i, n3);
      i !== f8 && (r2 = true, n3 = "buffer", i = f8);
    }
    var o6 = t2.objectMode ? 1 : i.length;
    t2.length += o6;
    var d14 = t2.length < t2.highWaterMark;
    if (d14 || (t2.needDrain = true), t2.writing || t2.corked) {
      var p7 = t2.lastBufferedRequest;
      t2.lastBufferedRequest = {
        chunk: i,
        encoding: n3,
        isBuf: r2,
        callback: a7,
        next: null
      }, p7 ? p7.next = t2.lastBufferedRequest : t2.bufferedRequest = t2.lastBufferedRequest, t2.bufferedRequestCount += 1;
    } else
      de2(e, t2, false, o6, i, n3, a7);
    return d14;
  }
  function de2(e, t2, r2, i, n3, a7, f8) {
    t2.writelen = i, t2.writecb = f8, t2.writing = true, t2.sync = true, t2.destroyed ? t2.onwrite(new or3("write")) : r2 ? e._writev(n3, t2.onwrite) : e._write(n3, a7, t2.onwrite), t2.sync = false;
  }
  function _r(e, t2, r2, i, n3) {
    --t2.pendingcb, r2 ? (process2.nextTick(n3, i), process2.nextTick(U7, e, t2), e._writableState.errorEmitted = true, x17(e, i)) : (n3(i), e._writableState.errorEmitted = true, x17(e, i), U7(e, t2));
  }
  function gr2(e) {
    e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  function yr2(e, t2) {
    var r2 = e._writableState, i = r2.sync, n3 = r2.writecb;
    if (typeof n3 != "function")
      throw new ar2();
    if (gr2(r2), t2)
      _r(e, r2, i, t2, n3);
    else {
      var a7 = $e2(r2) || e.destroyed;
      !a7 && !r2.corked && !r2.bufferProcessing && r2.bufferedRequest && Ye2(e, r2), i ? process2.nextTick(He4, e, r2, a7, n3) : He4(e, r2, a7, n3);
    }
  }
  function He4(e, t2, r2, i) {
    r2 || vr2(e, t2), t2.pendingcb--, i(), U7(e, t2);
  }
  function vr2(e, t2) {
    t2.length === 0 && t2.needDrain && (t2.needDrain = false, e.emit("drain"));
  }
  function Ye2(e, t2) {
    t2.bufferProcessing = true;
    var r2 = t2.bufferedRequest;
    if (e._writev && r2 && r2.next) {
      var i = t2.bufferedRequestCount, n3 = new Array(i), a7 = t2.corkedRequestsFree;
      a7.entry = r2;
      for (var f8 = 0, o6 = true; r2; )
        n3[f8] = r2, r2.isBuf || (o6 = false), r2 = r2.next, f8 += 1;
      n3.allBuffers = o6, de2(e, t2, true, t2.length, n3, "", a7.finish), t2.pendingcb++, t2.lastBufferedRequest = null, a7.next ? (t2.corkedRequestsFree = a7.next, a7.next = null) : t2.corkedRequestsFree = new Ge2(t2), t2.bufferedRequestCount = 0;
    } else {
      for (; r2; ) {
        var d14 = r2.chunk, p7 = r2.encoding, v19 = r2.callback, w24 = t2.objectMode ? 1 : d14.length;
        if (de2(e, t2, false, w24, d14, p7, v19), r2 = r2.next, t2.bufferedRequestCount--, t2.writing)
          break;
      }
      r2 === null && (t2.lastBufferedRequest = null);
    }
    t2.bufferedRequest = r2, t2.bufferProcessing = false;
  }
  s10.prototype._write = function(e, t2, r2) {
    r2(new nr2("_write()"));
  };
  s10.prototype._writev = null;
  s10.prototype.end = function(e, t2, r2) {
    var i = this._writableState;
    return typeof e == "function" ? (r2 = e, e = null, t2 = null) : typeof t2 == "function" && (r2 = t2, t2 = null), e != null && this.write(e, t2), i.corked && (i.corked = 1, this.uncork()), i.ending || Er2(this, i, r2), this;
  };
  Object.defineProperty(s10.prototype, "writableLength", {
    enumerable: false,
    get: function() {
      return this._writableState.length;
    }
  });
  function $e2(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  function wr2(e, t2) {
    e._final(function(r2) {
      t2.pendingcb--, r2 && x17(e, r2), t2.prefinished = true, e.emit("prefinish"), U7(e, t2);
    });
  }
  function Rr2(e, t2) {
    !t2.prefinished && !t2.finalCalled && (typeof e._final == "function" && !t2.destroyed ? (t2.pendingcb++, t2.finalCalled = true, process2.nextTick(wr2, e, t2)) : (t2.prefinished = true, e.emit("prefinish")));
  }
  function U7(e, t2) {
    var r2 = $e2(t2);
    if (r2 && (Rr2(e, t2), t2.pendingcb === 0 && (t2.finished = true, e.emit("finish"), t2.autoDestroy))) {
      var i = e._readableState;
      (!i || i.autoDestroy && i.endEmitted) && e.destroy();
    }
    return r2;
  }
  function Er2(e, t2, r2) {
    t2.ending = true, U7(e, t2), r2 && (t2.finished ? process2.nextTick(r2) : e.once("finish", r2)), t2.ended = true, e.writable = false;
  }
  function Sr(e, t2, r2) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var n3 = i.callback;
      t2.pendingcb--, n3(r2), i = i.next;
    }
    t2.corkedRequestsFree.next = e;
  }
  Object.defineProperty(s10.prototype, "destroyed", {
    enumerable: false,
    get: function() {
      return this._writableState === void 0 ? false : this._writableState.destroyed;
    },
    set: function(t2) {
      !this._writableState || (this._writableState.destroyed = t2);
    }
  });
  s10.prototype.destroy = he3.destroy;
  s10.prototype._undestroy = he3.undestroy;
  s10.prototype._destroy = function(e, t2) {
    t2(e);
  };
});
var L3 = c5((mi, ze3) => {
  "use strict";
  var Tr = Object.keys || function(e) {
    var t2 = [];
    for (var r2 in e)
      t2.push(r2);
    return t2;
  };
  ze3.exports = y16;
  var Xe = _e(), be3 = ce();
  w(y16, Xe);
  for (pe2 = Tr(be3.prototype), z15 = 0; z15 < pe2.length; z15++)
    J14 = pe2[z15], y16.prototype[J14] || (y16.prototype[J14] = be3.prototype[J14]);
  var pe2, J14, z15;
  function y16(e) {
    if (!(this instanceof y16))
      return new y16(e);
    Xe.call(this, e), be3.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Mr)));
  }
  Object.defineProperty(y16.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(y16.prototype, "writableBuffer", {
    enumerable: false,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(y16.prototype, "writableLength", {
    enumerable: false,
    get: function() {
      return this._writableState.length;
    }
  });
  function Mr() {
    this._writableState.ended || process2.nextTick(mr2, this);
  }
  function mr2(e) {
    e.end();
  }
  Object.defineProperty(y16.prototype, "destroyed", {
    enumerable: false,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(t2) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t2, this._writableState.destroyed = t2);
    }
  });
});
var Q1 = c5((Ai2, Ze2) => {
  "use strict";
  var Je = O1().codes.ERR_STREAM_PREMATURE_CLOSE;
  function Ar2(e) {
    var t2 = false;
    return function() {
      if (!t2) {
        t2 = true;
        for (var r2 = arguments.length, i = new Array(r2), n3 = 0; n3 < r2; n3++)
          i[n3] = arguments[n3];
        e.apply(this, i);
      }
    };
  }
  function Or() {
  }
  function Lr(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  function Qe2(e, t2, r2) {
    if (typeof t2 == "function")
      return Qe2(e, null, t2);
    t2 || (t2 = {}), r2 = Ar2(r2 || Or);
    var i = t2.readable || t2.readable !== false && e.readable, n3 = t2.writable || t2.writable !== false && e.writable, a7 = function() {
      e.writable || o6();
    }, f8 = e._writableState && e._writableState.finished, o6 = function() {
      n3 = false, f8 = true, i || r2.call(e);
    }, d14 = e._readableState && e._readableState.endEmitted, p7 = function() {
      i = false, d14 = true, n3 || r2.call(e);
    }, v19 = function(g17) {
      r2.call(e, g17);
    }, w24 = function() {
      var g17;
      if (i && !d14)
        return (!e._readableState || !e._readableState.ended) && (g17 = new Je()), r2.call(e, g17);
      if (n3 && !f8)
        return (!e._writableState || !e._writableState.ended) && (g17 = new Je()), r2.call(e, g17);
    }, A14 = function() {
      e.req.on("finish", o6);
    };
    return Lr(e) ? (e.on("complete", o6), e.on("abort", w24), e.req ? A14() : e.on("request", A14)) : n3 && !e._writableState && (e.on("end", a7), e.on("close", a7)), e.on("end", p7), e.on("finish", o6), t2.error !== false && e.on("error", v19), e.on("close", w24), function() {
      e.removeListener("complete", o6), e.removeListener("abort", w24), e.removeListener("request", A14), e.req && e.req.removeListener("finish", o6), e.removeListener("end", a7), e.removeListener("close", a7), e.removeListener("finish", o6), e.removeListener("end", p7), e.removeListener("error", v19), e.removeListener("close", w24);
    };
  }
  Ze2.exports = Qe2;
});
var tt = c5((Oi, et2) => {
  "use strict";
  var Z2;
  function T12(e, t2, r2) {
    return t2 in e ? Object.defineProperty(e, t2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[t2] = r2, e;
  }
  var Dr2 = Q1(), M14 = Symbol("lastResolve"), D12 = Symbol("lastReject"), F12 = Symbol("error"), ee2 = Symbol("ended"), q15 = Symbol("lastPromise"), ge2 = Symbol("handlePromise"), P13 = Symbol("stream");
  function m20(e, t2) {
    return {
      value: e,
      done: t2
    };
  }
  function qr2(e) {
    var t2 = e[M14];
    if (t2 !== null) {
      var r2 = e[P13].read();
      r2 !== null && (e[q15] = null, e[M14] = null, e[D12] = null, t2(m20(r2, false)));
    }
  }
  function Pr2(e) {
    process2.nextTick(qr2, e);
  }
  function Nr(e, t2) {
    return function(r2, i) {
      e.then(function() {
        if (t2[ee2]) {
          r2(m20(void 0, true));
          return;
        }
        t2[ge2](r2, i);
      }, i);
    };
  }
  var Cr = Object.getPrototypeOf(function() {
  }), Ir = Object.setPrototypeOf((Z2 = {
    get stream() {
      return this[P13];
    },
    next: function() {
      var t2 = this, r2 = this[F12];
      if (r2 !== null)
        return Promise.reject(r2);
      if (this[ee2])
        return Promise.resolve(m20(void 0, true));
      if (this[P13].destroyed)
        return new Promise(function(f8, o6) {
          process2.nextTick(function() {
            t2[F12] ? o6(t2[F12]) : f8(m20(void 0, true));
          });
        });
      var i = this[q15], n3;
      if (i)
        n3 = new Promise(Nr(i, this));
      else {
        var a7 = this[P13].read();
        if (a7 !== null)
          return Promise.resolve(m20(a7, false));
        n3 = new Promise(this[ge2]);
      }
      return this[q15] = n3, n3;
    }
  }, T12(Z2, Symbol.asyncIterator, function() {
    return this;
  }), T12(Z2, "return", function() {
    var t2 = this;
    return new Promise(function(r2, i) {
      t2[P13].destroy(null, function(n3) {
        if (n3) {
          i(n3);
          return;
        }
        r2(m20(void 0, true));
      });
    });
  }), Z2), Cr), xr2 = function(t2) {
    var r2, i = Object.create(Ir, (r2 = {}, T12(r2, P13, {
      value: t2,
      writable: true
    }), T12(r2, M14, {
      value: null,
      writable: true
    }), T12(r2, D12, {
      value: null,
      writable: true
    }), T12(r2, F12, {
      value: null,
      writable: true
    }), T12(r2, ee2, {
      value: t2._readableState.endEmitted,
      writable: true
    }), T12(r2, ge2, {
      value: function(a7, f8) {
        var o6 = i[P13].read();
        o6 ? (i[q15] = null, i[M14] = null, i[D12] = null, a7(m20(o6, false))) : (i[M14] = a7, i[D12] = f8);
      },
      writable: true
    }), r2));
    return i[q15] = null, Dr2(t2, function(n3) {
      if (n3 && n3.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var a7 = i[D12];
        a7 !== null && (i[q15] = null, i[M14] = null, i[D12] = null, a7(n3)), i[F12] = n3;
        return;
      }
      var f8 = i[M14];
      f8 !== null && (i[q15] = null, i[M14] = null, i[D12] = null, f8(m20(void 0, true))), i[ee2] = true;
    }), t2.on("readable", Pr2.bind(null, i)), i;
  };
  et2.exports = xr2;
});
var it = c5((Li2, rt3) => {
  rt3.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var _e = c5((qi, ct3) => {
  "use strict";
  ct3.exports = u12;
  var k15;
  u12.ReadableState = ot2;
  var Di = EventEmitter1.EventEmitter, ft2 = function(t2, r2) {
    return t2.listeners(r2).length;
  }, G11 = fe(), te2 = export_default.Buffer, kr2 = __global$1.Uint8Array || function() {
  };
  function jr(e) {
    return te2.from(e);
  }
  function Wr(e) {
    return te2.isBuffer(e) || e instanceof kr2;
  }
  var ye4 = __default14, l22;
  ye4 && ye4.debuglog ? l22 = ye4.debuglog("stream") : l22 = function() {
  };
  var Ur = xe(), Me = ue(), Br2 = se(), Fr2 = Br2.getHighWaterMark, re4 = O1().codes, Hr2 = re4.ERR_INVALID_ARG_TYPE, Gr = re4.ERR_STREAM_PUSH_AFTER_EOF, Vr = re4.ERR_METHOD_NOT_IMPLEMENTED, Yr = re4.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, j13, ve2, we2;
  w(u12, G11);
  var H9 = Me.errorOrDestroy, Re2 = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
  ];
  function $r(e, t2, r2) {
    if (typeof e.prependListener == "function")
      return e.prependListener(t2, r2);
    !e._events || !e._events[t2] ? e.on(t2, r2) : Array.isArray(e._events[t2]) ? e._events[t2].unshift(r2) : e._events[t2] = [
      r2,
      e._events[t2]
    ];
  }
  function ot2(e, t2, r2) {
    k15 = k15 || L3(), e = e || {}, typeof r2 != "boolean" && (r2 = t2 instanceof k15), this.objectMode = !!e.objectMode, r2 && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Fr2(this, e, "readableHighWaterMark", r2), this.buffer = new Ur(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (j13 || (j13 = __default16.StringDecoder), this.decoder = new j13(e.encoding), this.encoding = e.encoding);
  }
  function u12(e) {
    if (k15 = k15 || L3(), !(this instanceof u12))
      return new u12(e);
    var t2 = this instanceof k15;
    this._readableState = new ot2(e, this, t2), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), G11.call(this);
  }
  Object.defineProperty(u12.prototype, "destroyed", {
    enumerable: false,
    get: function() {
      return this._readableState === void 0 ? false : this._readableState.destroyed;
    },
    set: function(t2) {
      !this._readableState || (this._readableState.destroyed = t2);
    }
  });
  u12.prototype.destroy = Me.destroy;
  u12.prototype._undestroy = Me.undestroy;
  u12.prototype._destroy = function(e, t2) {
    t2(e);
  };
  u12.prototype.push = function(e, t2) {
    var r2 = this._readableState, i;
    return r2.objectMode ? i = true : typeof e == "string" && (t2 = t2 || r2.defaultEncoding, t2 !== r2.encoding && (e = te2.from(e, t2), t2 = ""), i = true), lt2(this, e, t2, false, i);
  };
  u12.prototype.unshift = function(e) {
    return lt2(this, e, null, true, false);
  };
  function lt2(e, t2, r2, i, n3) {
    l22("readableAddChunk", t2);
    var a7 = e._readableState;
    if (t2 === null)
      a7.reading = false, zr(e, a7);
    else {
      var f8;
      if (n3 || (f8 = Kr(a7, t2)), f8)
        H9(e, f8);
      else if (a7.objectMode || t2 && t2.length > 0)
        if (typeof t2 != "string" && !a7.objectMode && Object.getPrototypeOf(t2) !== te2.prototype && (t2 = jr(t2)), i)
          a7.endEmitted ? H9(e, new Yr()) : Ee2(e, a7, t2, true);
        else if (a7.ended)
          H9(e, new Gr());
        else {
          if (a7.destroyed)
            return false;
          a7.reading = false, a7.decoder && !r2 ? (t2 = a7.decoder.write(t2), a7.objectMode || t2.length !== 0 ? Ee2(e, a7, t2, false) : Te(e, a7)) : Ee2(e, a7, t2, false);
        }
      else
        i || (a7.reading = false, Te(e, a7));
    }
    return !a7.ended && (a7.length < a7.highWaterMark || a7.length === 0);
  }
  function Ee2(e, t2, r2, i) {
    t2.flowing && t2.length === 0 && !t2.sync ? (t2.awaitDrain = 0, e.emit("data", r2)) : (t2.length += t2.objectMode ? 1 : r2.length, i ? t2.buffer.unshift(r2) : t2.buffer.push(r2), t2.needReadable && ie3(e)), Te(e, t2);
  }
  function Kr(e, t2) {
    var r2;
    return !Wr(t2) && typeof t2 != "string" && t2 !== void 0 && !e.objectMode && (r2 = new Hr2("chunk", [
      "string",
      "Buffer",
      "Uint8Array"
    ], t2)), r2;
  }
  u12.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  u12.prototype.setEncoding = function(e) {
    j13 || (j13 = __default16.StringDecoder);
    var t2 = new j13(e);
    this._readableState.decoder = t2, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r2 = this._readableState.buffer.head, i = ""; r2 !== null; )
      i += t2.write(r2.data), r2 = r2.next;
    return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
  };
  var nt2 = 1073741824;
  function Xr(e) {
    return e >= nt2 ? e = nt2 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  function at2(e, t2) {
    return e <= 0 || t2.length === 0 && t2.ended ? 0 : t2.objectMode ? 1 : e !== e ? t2.flowing && t2.length ? t2.buffer.head.data.length : t2.length : (e > t2.highWaterMark && (t2.highWaterMark = Xr(e)), e <= t2.length ? e : t2.ended ? t2.length : (t2.needReadable = true, 0));
  }
  u12.prototype.read = function(e) {
    l22("read", e), e = parseInt(e, 10);
    var t2 = this._readableState, r2 = e;
    if (e !== 0 && (t2.emittedReadable = false), e === 0 && t2.needReadable && ((t2.highWaterMark !== 0 ? t2.length >= t2.highWaterMark : t2.length > 0) || t2.ended))
      return l22("read: emitReadable", t2.length, t2.ended), t2.length === 0 && t2.ended ? Se2(this) : ie3(this), null;
    if (e = at2(e, t2), e === 0 && t2.ended)
      return t2.length === 0 && Se2(this), null;
    var i = t2.needReadable;
    l22("need readable", i), (t2.length === 0 || t2.length - e < t2.highWaterMark) && (i = true, l22("length less than watermark", i)), t2.ended || t2.reading ? (i = false, l22("reading or ended", i)) : i && (l22("do read"), t2.reading = true, t2.sync = true, t2.length === 0 && (t2.needReadable = true), this._read(t2.highWaterMark), t2.sync = false, t2.reading || (e = at2(r2, t2)));
    var n3;
    return e > 0 ? n3 = dt2(e, t2) : n3 = null, n3 === null ? (t2.needReadable = t2.length <= t2.highWaterMark, e = 0) : (t2.length -= e, t2.awaitDrain = 0), t2.length === 0 && (t2.ended || (t2.needReadable = true), r2 !== e && t2.ended && Se2(this)), n3 !== null && this.emit("data", n3), n3;
  };
  function zr(e, t2) {
    if (l22("onEofChunk"), !t2.ended) {
      if (t2.decoder) {
        var r2 = t2.decoder.end();
        r2 && r2.length && (t2.buffer.push(r2), t2.length += t2.objectMode ? 1 : r2.length);
      }
      t2.ended = true, t2.sync ? ie3(e) : (t2.needReadable = false, t2.emittedReadable || (t2.emittedReadable = true, ut4(e)));
    }
  }
  function ie3(e) {
    var t2 = e._readableState;
    l22("emitReadable", t2.needReadable, t2.emittedReadable), t2.needReadable = false, t2.emittedReadable || (l22("emitReadable", t2.flowing), t2.emittedReadable = true, process2.nextTick(ut4, e));
  }
  function ut4(e) {
    var t2 = e._readableState;
    l22("emitReadable_", t2.destroyed, t2.length, t2.ended), !t2.destroyed && (t2.length || t2.ended) && (e.emit("readable"), t2.emittedReadable = false), t2.needReadable = !t2.flowing && !t2.ended && t2.length <= t2.highWaterMark, me2(e);
  }
  function Te(e, t2) {
    t2.readingMore || (t2.readingMore = true, process2.nextTick(Jr, e, t2));
  }
  function Jr(e, t2) {
    for (; !t2.reading && !t2.ended && (t2.length < t2.highWaterMark || t2.flowing && t2.length === 0); ) {
      var r2 = t2.length;
      if (l22("maybeReadMore read 0"), e.read(0), r2 === t2.length)
        break;
    }
    t2.readingMore = false;
  }
  u12.prototype._read = function(e) {
    H9(this, new Vr("_read()"));
  };
  u12.prototype.pipe = function(e, t2) {
    var r2 = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [
          i.pipes,
          e
        ];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, l22("pipe count=%d opts=%j", i.pipesCount, t2);
    var n3 = (!t2 || t2.end !== false) && e !== process2.stdout && e !== process2.stderr, a7 = n3 ? o6 : W2;
    i.endEmitted ? process2.nextTick(a7) : r2.once("end", a7), e.on("unpipe", f8);
    function f8(N6, C11) {
      l22("onunpipe"), N6 === r2 && C11 && C11.hasUnpiped === false && (C11.hasUnpiped = true, v19());
    }
    function o6() {
      l22("onend"), e.end();
    }
    var d14 = Qr(r2);
    e.on("drain", d14);
    var p7 = false;
    function v19() {
      l22("cleanup"), e.removeListener("close", R13), e.removeListener("finish", g17), e.removeListener("drain", d14), e.removeListener("error", A14), e.removeListener("unpipe", f8), r2.removeListener("end", o6), r2.removeListener("end", W2), r2.removeListener("data", w24), p7 = true, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d14();
    }
    r2.on("data", w24);
    function w24(N6) {
      l22("ondata");
      var C11 = e.write(N6);
      l22("dest.write", C11), C11 === false && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && ht4(i.pipes, e) !== -1) && !p7 && (l22("false write response, pause", i.awaitDrain), i.awaitDrain++), r2.pause());
    }
    function A14(N6) {
      l22("onerror", N6), W2(), e.removeListener("error", A14), ft2(e, "error") === 0 && H9(e, N6);
    }
    $r(e, "error", A14);
    function R13() {
      e.removeListener("finish", g17), W2();
    }
    e.once("close", R13);
    function g17() {
      l22("onfinish"), e.removeListener("close", R13), W2();
    }
    e.once("finish", g17);
    function W2() {
      l22("unpipe"), r2.unpipe(e);
    }
    return e.emit("pipe", r2), i.flowing || (l22("pipe resume"), r2.resume()), e;
  };
  function Qr(e) {
    return function() {
      var r2 = e._readableState;
      l22("pipeOnDrain", r2.awaitDrain), r2.awaitDrain && r2.awaitDrain--, r2.awaitDrain === 0 && ft2(e, "data") && (r2.flowing = true, me2(e));
    };
  }
  u12.prototype.unpipe = function(e) {
    var t2 = this._readableState, r2 = {
      hasUnpiped: false
    };
    if (t2.pipesCount === 0)
      return this;
    if (t2.pipesCount === 1)
      return e && e !== t2.pipes ? this : (e || (e = t2.pipes), t2.pipes = null, t2.pipesCount = 0, t2.flowing = false, e && e.emit("unpipe", this, r2), this);
    if (!e) {
      var i = t2.pipes, n3 = t2.pipesCount;
      t2.pipes = null, t2.pipesCount = 0, t2.flowing = false;
      for (var a7 = 0; a7 < n3; a7++)
        i[a7].emit("unpipe", this, {
          hasUnpiped: false
        });
      return this;
    }
    var f8 = ht4(t2.pipes, e);
    return f8 === -1 ? this : (t2.pipes.splice(f8, 1), t2.pipesCount -= 1, t2.pipesCount === 1 && (t2.pipes = t2.pipes[0]), e.emit("unpipe", this, r2), this);
  };
  u12.prototype.on = function(e, t2) {
    var r2 = G11.prototype.on.call(this, e, t2), i = this._readableState;
    return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== false && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = true, i.flowing = false, i.emittedReadable = false, l22("on readable", i.length, i.reading), i.length ? ie3(this) : i.reading || process2.nextTick(Zr, this)), r2;
  };
  u12.prototype.addListener = u12.prototype.on;
  u12.prototype.removeListener = function(e, t2) {
    var r2 = G11.prototype.removeListener.call(this, e, t2);
    return e === "readable" && process2.nextTick(st2, this), r2;
  };
  u12.prototype.removeAllListeners = function(e) {
    var t2 = G11.prototype.removeAllListeners.apply(this, arguments);
    return (e === "readable" || e === void 0) && process2.nextTick(st2, this), t2;
  };
  function st2(e) {
    var t2 = e._readableState;
    t2.readableListening = e.listenerCount("readable") > 0, t2.resumeScheduled && !t2.paused ? t2.flowing = true : e.listenerCount("data") > 0 && e.resume();
  }
  function Zr(e) {
    l22("readable nexttick read 0"), e.read(0);
  }
  u12.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (l22("resume"), e.flowing = !e.readableListening, ei(this, e)), e.paused = false, this;
  };
  function ei(e, t2) {
    t2.resumeScheduled || (t2.resumeScheduled = true, process2.nextTick(ti, e, t2));
  }
  function ti(e, t2) {
    l22("resume", t2.reading), t2.reading || e.read(0), t2.resumeScheduled = false, e.emit("resume"), me2(e), t2.flowing && !t2.reading && e.read(0);
  }
  u12.prototype.pause = function() {
    return l22("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (l22("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function me2(e) {
    var t2 = e._readableState;
    for (l22("flow", t2.flowing); t2.flowing && e.read() !== null; )
      ;
  }
  u12.prototype.wrap = function(e) {
    var t2 = this, r2 = this._readableState, i = false;
    e.on("end", function() {
      if (l22("wrapped end"), r2.decoder && !r2.ended) {
        var f8 = r2.decoder.end();
        f8 && f8.length && t2.push(f8);
      }
      t2.push(null);
    }), e.on("data", function(f8) {
      if (l22("wrapped data"), r2.decoder && (f8 = r2.decoder.write(f8)), !(r2.objectMode && f8 == null) && !(!r2.objectMode && (!f8 || !f8.length))) {
        var o6 = t2.push(f8);
        o6 || (i = true, e.pause());
      }
    });
    for (var n3 in e)
      this[n3] === void 0 && typeof e[n3] == "function" && (this[n3] = function(o6) {
        return function() {
          return e[o6].apply(e, arguments);
        };
      }(n3));
    for (var a7 = 0; a7 < Re2.length; a7++)
      e.on(Re2[a7], this.emit.bind(this, Re2[a7]));
    return this._read = function(f8) {
      l22("wrapped _read", f8), i && (i = false, e.resume());
    }, this;
  };
  typeof Symbol == "function" && (u12.prototype[Symbol.asyncIterator] = function() {
    return ve2 === void 0 && (ve2 = tt()), ve2(this);
  });
  Object.defineProperty(u12.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(u12.prototype, "readableBuffer", {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(u12.prototype, "readableFlowing", {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(t2) {
      this._readableState && (this._readableState.flowing = t2);
    }
  });
  u12._fromList = dt2;
  Object.defineProperty(u12.prototype, "readableLength", {
    enumerable: false,
    get: function() {
      return this._readableState.length;
    }
  });
  function dt2(e, t2) {
    if (t2.length === 0)
      return null;
    var r2;
    return t2.objectMode ? r2 = t2.buffer.shift() : !e || e >= t2.length ? (t2.decoder ? r2 = t2.buffer.join("") : t2.buffer.length === 1 ? r2 = t2.buffer.first() : r2 = t2.buffer.concat(t2.length), t2.buffer.clear()) : r2 = t2.buffer.consume(e, t2.decoder), r2;
  }
  function Se2(e) {
    var t2 = e._readableState;
    l22("endReadable", t2.endEmitted), t2.endEmitted || (t2.ended = true, process2.nextTick(ri, t2, e));
  }
  function ri(e, t2) {
    if (l22("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t2.readable = false, t2.emit("end"), e.autoDestroy)) {
      var r2 = t2._writableState;
      (!r2 || r2.autoDestroy && r2.finished) && t2.destroy();
    }
  }
  typeof Symbol == "function" && (u12.from = function(e, t2) {
    return we2 === void 0 && (we2 = it()), we2(u12, e, t2);
  });
  function ht4(e, t2) {
    for (var r2 = 0, i = e.length; r2 < i; r2++)
      if (e[r2] === t2)
        return r2;
    return -1;
  }
});
var Ae = c5((Pi, bt2) => {
  "use strict";
  bt2.exports = E15;
  var ne2 = O1().codes, ii = ne2.ERR_METHOD_NOT_IMPLEMENTED, ni2 = ne2.ERR_MULTIPLE_CALLBACK, ai2 = ne2.ERR_TRANSFORM_ALREADY_TRANSFORMING, fi = ne2.ERR_TRANSFORM_WITH_LENGTH_0, ae3 = L3();
  w(E15, ae3);
  function oi(e, t2) {
    var r2 = this._transformState;
    r2.transforming = false;
    var i = r2.writecb;
    if (i === null)
      return this.emit("error", new ni2());
    r2.writechunk = null, r2.writecb = null, t2 != null && this.push(t2), i(e);
    var n3 = this._readableState;
    n3.reading = false, (n3.needReadable || n3.length < n3.highWaterMark) && this._read(n3.highWaterMark);
  }
  function E15(e) {
    if (!(this instanceof E15))
      return new E15(e);
    ae3.call(this, e), this._transformState = {
      afterTransform: oi.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", li2);
  }
  function li2() {
    var e = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t2, r2) {
      pt2(e, t2, r2);
    }) : pt2(this, null, null);
  }
  E15.prototype.push = function(e, t2) {
    return this._transformState.needTransform = false, ae3.prototype.push.call(this, e, t2);
  };
  E15.prototype._transform = function(e, t2, r2) {
    r2(new ii("_transform()"));
  };
  E15.prototype._write = function(e, t2, r2) {
    var i = this._transformState;
    if (i.writecb = r2, i.writechunk = e, i.writeencoding = t2, !i.transforming) {
      var n3 = this._readableState;
      (i.needTransform || n3.needReadable || n3.length < n3.highWaterMark) && this._read(n3.highWaterMark);
    }
  };
  E15.prototype._read = function(e) {
    var t2 = this._transformState;
    t2.writechunk !== null && !t2.transforming ? (t2.transforming = true, this._transform(t2.writechunk, t2.writeencoding, t2.afterTransform)) : t2.needTransform = true;
  };
  E15.prototype._destroy = function(e, t2) {
    ae3.prototype._destroy.call(this, e, function(r2) {
      t2(r2);
    });
  };
  function pt2(e, t2, r2) {
    if (t2)
      return e.emit("error", t2);
    if (r2 != null && e.push(r2), e._writableState.length)
      throw new fi();
    if (e._transformState.transforming)
      throw new ai2();
    return e.push(null);
  }
});
var yt1 = c5((Ni, gt3) => {
  "use strict";
  gt3.exports = V8;
  var _t2 = Ae();
  w(V8, _t2);
  function V8(e) {
    if (!(this instanceof V8))
      return new V8(e);
    _t2.call(this, e);
  }
  V8.prototype._transform = function(e, t2, r2) {
    r2(null, e);
  };
});
var St = c5((Ci, Et) => {
  "use strict";
  var Oe;
  function ui(e) {
    var t2 = false;
    return function() {
      t2 || (t2 = true, e.apply(void 0, arguments));
    };
  }
  var Rt = O1().codes, si2 = Rt.ERR_MISSING_ARGS, di2 = Rt.ERR_STREAM_DESTROYED;
  function vt(e) {
    if (e)
      throw e;
  }
  function hi(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  function ci2(e, t2, r2, i) {
    i = ui(i);
    var n3 = false;
    e.on("close", function() {
      n3 = true;
    }), Oe === void 0 && (Oe = Q1()), Oe(e, {
      readable: t2,
      writable: r2
    }, function(f8) {
      if (f8)
        return i(f8);
      n3 = true, i();
    });
    var a7 = false;
    return function(f8) {
      if (!n3 && !a7) {
        if (a7 = true, hi(e))
          return e.abort();
        if (typeof e.destroy == "function")
          return e.destroy();
        i(f8 || new di2("pipe"));
      }
    };
  }
  function wt(e) {
    e();
  }
  function pi2(e, t2) {
    return e.pipe(t2);
  }
  function bi2(e) {
    return !e.length || typeof e[e.length - 1] != "function" ? vt : e.pop();
  }
  function _i2() {
    for (var e = arguments.length, t2 = new Array(e), r2 = 0; r2 < e; r2++)
      t2[r2] = arguments[r2];
    var i = bi2(t2);
    if (Array.isArray(t2[0]) && (t2 = t2[0]), t2.length < 2)
      throw new si2("streams");
    var n3, a7 = t2.map(function(f8, o6) {
      var d14 = o6 < t2.length - 1, p7 = o6 > 0;
      return ci2(f8, d14, p7, function(v19) {
        n3 || (n3 = v19), v19 && a7.forEach(wt), !d14 && (a7.forEach(wt), i(n3));
      });
    });
    return t2.reduce(pi2);
  }
  Et.exports = _i2;
});
var Le2 = c5((_11, Tt) => {
  _11 = Tt.exports = _e();
  _11.Stream = _11;
  _11.Readable = _11;
  _11.Writable = ce();
  _11.Duplex = L3();
  _11.Transform = Ae();
  _11.PassThrough = yt1();
  _11.finished = Q1();
  _11.pipeline = St();
});
var Mt1 = qe1(Le2());
var mt = qe1(Le2());
var { Stream: Ii, Readable: xi1, Writable: ki1, Duplex: ji, Transform: Wi, PassThrough: Ui, finished: Bi, pipeline: Fi } = mt;
var { default: gi1, ...yi } = mt;
var Hi = Mt1.default ?? gi1 ?? yi;
var g7 = Object.create;
var _3 = Object.defineProperty;
var b4 = Object.getOwnPropertyDescriptor;
var m6 = Object.getOwnPropertyNames;
var w7 = Object.getPrototypeOf;
var k2 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (e, r2) => (typeof require != "undefined" ? require : e)[r2]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var v5 = (t2, e) => () => (e || t2((e = {
  exports: {}
}).exports, e), e.exports);
var y6 = (t2, e, r2, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o6 of m6(e))
      !k2.call(t2, o6) && o6 !== r2 && _3(t2, o6, {
        get: () => e[o6],
        enumerable: !(i = b4(e, o6)) || i.enumerable
      });
  return t2;
};
var p10 = (t2, e, r2) => (r2 = t2 != null ? g7(w7(t2)) : {}, y6(e || !t2 || !t2.__esModule ? _3(r2, "default", {
  value: t2,
  enumerable: true
}) : r2, t2));
var u3 = v5(($17, a7) => {
  "use strict";
  var h16 = L1, c13 = Wi, O9 = w;
  function z15(t2, e) {
    if (!h16.isBuffer(t2) && typeof t2 != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function s10(t2) {
    c13.call(this), this._block = h16.allocUnsafe(t2), this._blockSize = t2, this._blockOffset = 0, this._length = [
      0,
      0,
      0,
      0
    ], this._finalized = false;
  }
  O9(s10, c13);
  s10.prototype._transform = function(t2, e, r2) {
    var i = null;
    try {
      this.update(t2, e);
    } catch (o6) {
      i = o6;
    }
    r2(i);
  };
  s10.prototype._flush = function(t2) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r2) {
      e = r2;
    }
    t2(e);
  };
  s10.prototype.update = function(t2, e) {
    if (z15(t2, "Data"), this._finalized)
      throw new Error("Digest already called");
    h16.isBuffer(t2) || (t2 = h16.from(t2, e));
    for (var r2 = this._block, i = 0; this._blockOffset + t2.length - i >= this._blockSize; ) {
      for (var o6 = this._blockOffset; o6 < this._blockSize; )
        r2[o6++] = t2[i++];
      this._update(), this._blockOffset = 0;
    }
    for (; i < t2.length; )
      r2[this._blockOffset++] = t2[i++];
    for (var n3 = 0, f8 = t2.length * 8; f8 > 0; ++n3)
      this._length[n3] += f8, f8 = this._length[n3] / 4294967296 | 0, f8 > 0 && (this._length[n3] -= 4294967296 * f8);
    return this;
  };
  s10.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  s10.prototype.digest = function(t2) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t2 !== void 0 && (e = e.toString(t2)), this._block.fill(0), this._blockOffset = 0;
    for (var r2 = 0; r2 < 4; ++r2)
      this._length[r2] = 0;
    return e;
  };
  s10.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  a7.exports = s10;
});
var d6 = p10(u3());
var B3 = p10(u3());
var { default: E3, ...x6 } = B3;
var q4 = d6.default ?? E3 ?? x6;
var M2 = Object.create;
var $4 = Object.defineProperty;
var P2 = Object.getOwnPropertyDescriptor;
var Y1 = Object.getOwnPropertyNames;
var C2 = Object.getPrototypeOf;
var F2 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (r2, s10) => (typeof require != "undefined" ? require : r2)[s10]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var G1 = (t2, r2) => () => (r2 || t2((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var J2 = (t2, r2, s10, i) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let a7 of Y1(r2))
      !F2.call(t2, a7) && a7 !== s10 && $4(t2, a7, {
        get: () => r2[a7],
        enumerable: !(i = P2(r2, a7)) || i.enumerable
      });
  return t2;
};
var g8 = (t2, r2, s10) => (s10 = t2 != null ? M2(C2(t2)) : {}, J2(r2 || !t2 || !t2.__esModule ? $4(s10, "default", {
  value: t2,
  enumerable: true
}) : s10, t2));
var O2 = G1((W2, U7) => {
  "use strict";
  var m20 = export_default.Buffer, K14 = w, z15 = q4, N6 = new Array(16), b15 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], x17 = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], k15 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], p7 = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], w110 = [
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ], E15 = [
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ];
  function I13() {
    z15.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  K14(I13, z15);
  I13.prototype._update = function() {
    for (var t2 = N6, r2 = 0; r2 < 16; ++r2)
      t2[r2] = this._block.readInt32LE(r2 * 4);
    for (var s10 = this._a | 0, i = this._b | 0, a7 = this._c | 0, h16 = this._d | 0, f8 = this._e | 0, _11 = this._a | 0, n3 = this._b | 0, c13 = this._c | 0, o6 = this._d | 0, l22 = this._e | 0, e = 0; e < 80; e += 1) {
      var d14, v19;
      e < 16 ? (d14 = q15(s10, i, a7, h16, f8, t2[b15[e]], w110[0], k15[e]), v19 = R13(_11, n3, c13, o6, l22, t2[x17[e]], E15[0], p7[e])) : e < 32 ? (d14 = y16(s10, i, a7, h16, f8, t2[b15[e]], w110[1], k15[e]), v19 = B18(_11, n3, c13, o6, l22, t2[x17[e]], E15[1], p7[e])) : e < 48 ? (d14 = A14(s10, i, a7, h16, f8, t2[b15[e]], w110[2], k15[e]), v19 = A14(_11, n3, c13, o6, l22, t2[x17[e]], E15[2], p7[e])) : e < 64 ? (d14 = B18(s10, i, a7, h16, f8, t2[b15[e]], w110[3], k15[e]), v19 = y16(_11, n3, c13, o6, l22, t2[x17[e]], E15[3], p7[e])) : (d14 = R13(s10, i, a7, h16, f8, t2[b15[e]], w110[4], k15[e]), v19 = q15(_11, n3, c13, o6, l22, t2[x17[e]], E15[4], p7[e])), s10 = f8, f8 = h16, h16 = u12(a7, 10), a7 = i, i = d14, _11 = l22, l22 = o6, o6 = u12(c13, 10), c13 = n3, n3 = v19;
    }
    var H9 = this._b + a7 + o6 | 0;
    this._b = this._c + h16 + l22 | 0, this._c = this._d + f8 + _11 | 0, this._d = this._e + s10 + n3 | 0, this._e = this._a + i + c13 | 0, this._a = H9;
  };
  I13.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t2 = m20.alloc ? m20.alloc(20) : new m20(20);
    return t2.writeInt32LE(this._a, 0), t2.writeInt32LE(this._b, 4), t2.writeInt32LE(this._c, 8), t2.writeInt32LE(this._d, 12), t2.writeInt32LE(this._e, 16), t2;
  };
  function u12(t2, r2) {
    return t2 << r2 | t2 >>> 32 - r2;
  }
  function q15(t2, r2, s10, i, a7, h16, f8, _11) {
    return u12(t2 + (r2 ^ s10 ^ i) + h16 + f8 | 0, _11) + a7 | 0;
  }
  function y16(t2, r2, s10, i, a7, h16, f8, _11) {
    return u12(t2 + (r2 & s10 | ~r2 & i) + h16 + f8 | 0, _11) + a7 | 0;
  }
  function A14(t2, r2, s10, i, a7, h16, f8, _11) {
    return u12(t2 + ((r2 | ~s10) ^ i) + h16 + f8 | 0, _11) + a7 | 0;
  }
  function B18(t2, r2, s10, i, a7, h16, f8, _11) {
    return u12(t2 + (r2 & i | s10 & ~i) + h16 + f8 | 0, _11) + a7 | 0;
  }
  function R13(t2, r2, s10, i, a7, h16, f8, _11) {
    return u12(t2 + (r2 ^ (s10 | ~i)) + h16 + f8 | 0, _11) + a7 | 0;
  }
  U7.exports = I13;
});
var D1 = g8(O2());
var Q2 = g8(O2());
var { default: S3, ...T1 } = Q2;
var X2 = D1.default ?? S3 ?? T1;
var I4 = Object.create;
var u4 = Object.defineProperty;
var w8 = Object.getOwnPropertyDescriptor;
var E4 = Object.getOwnPropertyNames;
var L4 = Object.getPrototypeOf;
var m7 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (i, f8) => (typeof require != "undefined" ? require : i)[f8]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var O3 = (t2, i) => () => (i || t2((i = {
  exports: {}
}).exports, i), i.exports);
var $5 = (t2, i, f8, x17) => {
  if (i && typeof i == "object" || typeof i == "function")
    for (let e of E4(i))
      !m7.call(t2, e) && e !== f8 && u4(t2, e, {
        get: () => i[e],
        enumerable: !(x17 = w8(i, e)) || x17.enumerable
      });
  return t2;
};
var l6 = (t2, i, f8) => (f8 = t2 != null ? I4(L4(t2)) : {}, $5(i || !t2 || !t2.__esModule ? u4(f8, "default", {
  value: t2,
  enumerable: true
}) : f8, t2));
var o2 = O3((M14, p7) => {
  "use strict";
  var g17 = w, k15 = q4, q15 = L1, y16 = new Array(16);
  function h16() {
    k15.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  g17(h16, k15);
  h16.prototype._update = function() {
    for (var t2 = y16, i = 0; i < 16; ++i)
      t2[i] = this._block.readInt32LE(i * 4);
    var f8 = this._a, x17 = this._b, e = this._c, a7 = this._d;
    f8 = c13(f8, x17, e, a7, t2[0], 3614090360, 7), a7 = c13(a7, f8, x17, e, t2[1], 3905402710, 12), e = c13(e, a7, f8, x17, t2[2], 606105819, 17), x17 = c13(x17, e, a7, f8, t2[3], 3250441966, 22), f8 = c13(f8, x17, e, a7, t2[4], 4118548399, 7), a7 = c13(a7, f8, x17, e, t2[5], 1200080426, 12), e = c13(e, a7, f8, x17, t2[6], 2821735955, 17), x17 = c13(x17, e, a7, f8, t2[7], 4249261313, 22), f8 = c13(f8, x17, e, a7, t2[8], 1770035416, 7), a7 = c13(a7, f8, x17, e, t2[9], 2336552879, 12), e = c13(e, a7, f8, x17, t2[10], 4294925233, 17), x17 = c13(x17, e, a7, f8, t2[11], 2304563134, 22), f8 = c13(f8, x17, e, a7, t2[12], 1804603682, 7), a7 = c13(a7, f8, x17, e, t2[13], 4254626195, 12), e = c13(e, a7, f8, x17, t2[14], 2792965006, 17), x17 = c13(x17, e, a7, f8, t2[15], 1236535329, 22), f8 = r2(f8, x17, e, a7, t2[1], 4129170786, 5), a7 = r2(a7, f8, x17, e, t2[6], 3225465664, 9), e = r2(e, a7, f8, x17, t2[11], 643717713, 14), x17 = r2(x17, e, a7, f8, t2[0], 3921069994, 20), f8 = r2(f8, x17, e, a7, t2[5], 3593408605, 5), a7 = r2(a7, f8, x17, e, t2[10], 38016083, 9), e = r2(e, a7, f8, x17, t2[15], 3634488961, 14), x17 = r2(x17, e, a7, f8, t2[4], 3889429448, 20), f8 = r2(f8, x17, e, a7, t2[9], 568446438, 5), a7 = r2(a7, f8, x17, e, t2[14], 3275163606, 9), e = r2(e, a7, f8, x17, t2[3], 4107603335, 14), x17 = r2(x17, e, a7, f8, t2[8], 1163531501, 20), f8 = r2(f8, x17, e, a7, t2[13], 2850285829, 5), a7 = r2(a7, f8, x17, e, t2[2], 4243563512, 9), e = r2(e, a7, f8, x17, t2[7], 1735328473, 14), x17 = r2(x17, e, a7, f8, t2[12], 2368359562, 20), f8 = d14(f8, x17, e, a7, t2[5], 4294588738, 4), a7 = d14(a7, f8, x17, e, t2[8], 2272392833, 11), e = d14(e, a7, f8, x17, t2[11], 1839030562, 16), x17 = d14(x17, e, a7, f8, t2[14], 4259657740, 23), f8 = d14(f8, x17, e, a7, t2[1], 2763975236, 4), a7 = d14(a7, f8, x17, e, t2[4], 1272893353, 11), e = d14(e, a7, f8, x17, t2[7], 4139469664, 16), x17 = d14(x17, e, a7, f8, t2[10], 3200236656, 23), f8 = d14(f8, x17, e, a7, t2[13], 681279174, 4), a7 = d14(a7, f8, x17, e, t2[0], 3936430074, 11), e = d14(e, a7, f8, x17, t2[3], 3572445317, 16), x17 = d14(x17, e, a7, f8, t2[6], 76029189, 23), f8 = d14(f8, x17, e, a7, t2[9], 3654602809, 4), a7 = d14(a7, f8, x17, e, t2[12], 3873151461, 11), e = d14(e, a7, f8, x17, t2[15], 530742520, 16), x17 = d14(x17, e, a7, f8, t2[2], 3299628645, 23), f8 = s10(f8, x17, e, a7, t2[0], 4096336452, 6), a7 = s10(a7, f8, x17, e, t2[7], 1126891415, 10), e = s10(e, a7, f8, x17, t2[14], 2878612391, 15), x17 = s10(x17, e, a7, f8, t2[5], 4237533241, 21), f8 = s10(f8, x17, e, a7, t2[12], 1700485571, 6), a7 = s10(a7, f8, x17, e, t2[3], 2399980690, 10), e = s10(e, a7, f8, x17, t2[10], 4293915773, 15), x17 = s10(x17, e, a7, f8, t2[1], 2240044497, 21), f8 = s10(f8, x17, e, a7, t2[8], 1873313359, 6), a7 = s10(a7, f8, x17, e, t2[15], 4264355552, 10), e = s10(e, a7, f8, x17, t2[6], 2734768916, 15), x17 = s10(x17, e, a7, f8, t2[13], 1309151649, 21), f8 = s10(f8, x17, e, a7, t2[4], 4149444226, 6), a7 = s10(a7, f8, x17, e, t2[11], 3174756917, 10), e = s10(e, a7, f8, x17, t2[2], 718787259, 15), x17 = s10(x17, e, a7, f8, t2[9], 3951481745, 21), this._a = this._a + f8 | 0, this._b = this._b + x17 | 0, this._c = this._c + e | 0, this._d = this._d + a7 | 0;
  };
  h16.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t2 = q15.allocUnsafe(16);
    return t2.writeInt32LE(this._a, 0), t2.writeInt32LE(this._b, 4), t2.writeInt32LE(this._c, 8), t2.writeInt32LE(this._d, 12), t2;
  };
  function n3(t2, i) {
    return t2 << i | t2 >>> 32 - i;
  }
  function c13(t2, i, f8, x17, e, a7, b15) {
    return n3(t2 + (i & f8 | ~i & x17) + e + a7 | 0, b15) + i | 0;
  }
  function r2(t2, i, f8, x17, e, a7, b15) {
    return n3(t2 + (i & x17 | f8 & ~x17) + e + a7 | 0, b15) + i | 0;
  }
  function d14(t2, i, f8, x17, e, a7, b15) {
    return n3(t2 + (i ^ f8 ^ x17) + e + a7 | 0, b15) + i | 0;
  }
  function s10(t2, i, f8, x17, e, a7, b15) {
    return n3(t2 + (f8 ^ (i | ~x17)) + e + a7 | 0, b15) + i | 0;
  }
  p7.exports = h16;
});
var v6 = l6(o2());
var A4 = l6(o2());
var { default: B4, ...U1 } = A4;
var R2 = v6.default ?? B4 ?? U1;
var n = Object.create;
var f3 = Object.defineProperty;
var p11 = Object.getOwnPropertyDescriptor;
var s3 = Object.getOwnPropertyNames;
var l7 = Object.getPrototypeOf;
var $6 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (t2, r2) => (typeof require != "undefined" ? require : t2)[r2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var x7 = (e, t2) => () => (t2 || e((t2 = {
  exports: {}
}).exports, t2), t2.exports);
var g9 = (e, t2, r2, d14) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let o6 of s3(t2))
      !$6.call(e, o6) && o6 !== r2 && f3(e, o6, {
        get: () => t2[o6],
        enumerable: !(d14 = p11(t2, o6)) || d14.enumerable
      });
  return e;
};
var a2 = (e, t2, r2) => (r2 = e != null ? n(l7(e)) : {}, g9(t2 || !e || !e.__esModule ? f3(r2, "default", {
  value: e,
  enumerable: true
}) : r2, e));
var u5 = x7((b15, i) => {
  var q15 = R2;
  i.exports = function(e) {
    return new q15().update(e).digest();
  };
});
var m8 = a2(u5());
var v7 = a2(u5());
var { default: w9, ...D2 } = v7;
var h5 = m8.default ?? w9 ?? D2;
var __global$2 = globalThis || (typeof window !== "undefined" ? window : self);
var __setImmediate$ = (cb, ...args) => setTimeout(cb, 0, ...args);
var Y2 = Object.create;
var I5 = Object.defineProperty;
var j2 = Object.getOwnPropertyDescriptor;
var rr1 = Object.getOwnPropertyNames;
var er1 = Object.getPrototypeOf;
var or2 = Object.prototype.hasOwnProperty;
((r2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r2, {
  get: (e, t2) => (typeof require != "undefined" ? require : e)[t2]
}) : r2)(function(r2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var l8 = (r2, e) => () => (e || r2((e = {
  exports: {}
}).exports, e), e.exports);
var tr1 = (r2, e, t2, n3) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o6 of rr1(e))
      !or2.call(r2, o6) && o6 !== t2 && I5(r2, o6, {
        get: () => e[o6],
        enumerable: !(n3 = j2(e, o6)) || n3.enumerable
      });
  return r2;
};
var K5 = (r2, e, t2) => (t2 = r2 != null ? Y2(er1(r2)) : {}, tr1(e || !r2 || !r2.__esModule ? I5(t2, "default", {
  value: r2,
  enumerable: true
}) : t2, r2));
var S4 = l8((wr2, F12) => {
  var nr2 = Math.pow(2, 30) - 1;
  F12.exports = function(r2, e) {
    if (typeof r2 != "number")
      throw new TypeError("Iterations not a number");
    if (r2 < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > nr2 || e !== e)
      throw new TypeError("Bad key length");
  };
});
var x8 = l8((qr2, L18) => {
  var d14;
  process1 && process1.browser ? d14 = "utf-8" : process1 && process1.version ? (U7 = parseInt(process1.version.split(".")[0].slice(1), 10), d14 = U7 >= 6 ? "utf-8" : "binary") : d14 = "utf-8";
  var U7;
  L18.exports = d14;
});
var P3 = l8((yr2, M14) => {
  var E15 = L1;
  M14.exports = function(r2, e, t2) {
    if (E15.isBuffer(r2))
      return r2;
    if (typeof r2 == "string")
      return E15.from(r2, e);
    if (ArrayBuffer.isView(r2))
      return E15.from(r2.buffer);
    throw new TypeError(t2 + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var A5 = l8((Sr, O9) => {
  var ar2 = h5, fr = X2, ur = Ot, s10 = L1, ir2 = S4(), $17 = x8(), C11 = P3(), sr = s10.alloc(128), m20 = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function N6(r2, e, t2) {
    var n3 = cr(r2), o6 = r2 === "sha512" || r2 === "sha384" ? 128 : 64;
    e.length > o6 ? e = n3(e) : e.length < o6 && (e = s10.concat([
      e,
      sr
    ], o6));
    for (var a7 = s10.allocUnsafe(o6 + m20[r2]), u12 = s10.allocUnsafe(o6 + m20[r2]), f8 = 0; f8 < o6; f8++)
      a7[f8] = e[f8] ^ 54, u12[f8] = e[f8] ^ 92;
    var i = s10.allocUnsafe(o6 + t2 + 4);
    a7.copy(i, 0, 0, o6), this.ipad1 = i, this.ipad2 = a7, this.opad = u12, this.alg = r2, this.blocksize = o6, this.hash = n3, this.size = m20[r2];
  }
  N6.prototype.run = function(r2, e) {
    r2.copy(e, this.blocksize);
    var t2 = this.hash(e);
    return t2.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function cr(r2) {
    function e(n3) {
      return ur(r2).update(n3).digest();
    }
    function t2(n3) {
      return new fr().update(n3).digest();
    }
    return r2 === "rmd160" || r2 === "ripemd160" ? t2 : r2 === "md5" ? ar2 : e;
  }
  function hr2(r2, e, t2, n3, o6) {
    ir2(t2, n3), r2 = C11(r2, $17, "Password"), e = C11(e, $17, "Salt"), o6 = o6 || "sha1";
    var a7 = new N6(o6, r2, e.length), u12 = s10.allocUnsafe(n3), f8 = s10.allocUnsafe(e.length + 4);
    e.copy(f8, 0, 0, e.length);
    for (var i = 0, B18 = m20[o6], W2 = Math.ceil(n3 / B18), w24 = 1; w24 <= W2; w24++) {
      f8.writeUInt32BE(w24, e.length);
      for (var q15 = a7.run(f8, a7.ipad1), y16 = q15, D12 = 1; D12 < t2; D12++) {
        y16 = a7.run(y16, a7.ipad2);
        for (var v19 = 0; v19 < B18; v19++)
          q15[v19] ^= y16[v19];
      }
      q15.copy(u12, i), i += B18;
    }
    return u12;
  }
  O9.exports = hr2;
});
var J3 = l8((xr2, G11) => {
  var X5 = L1, lr = S4(), R13 = x8(), Z2 = A5(), _11 = P3(), b15, p7 = __global$2.crypto && __global$2.crypto.subtle, pr2 = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, g17 = [];
  function vr2(r2) {
    if (process1 && !process1.browser || !p7 || !p7.importKey || !p7.deriveBits)
      return Promise.resolve(false);
    if (g17[r2] !== void 0)
      return g17[r2];
    b15 = b15 || X5.alloc(8);
    var e = k15(b15, b15, 10, 128, r2).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return g17[r2] = e, e;
  }
  var c13;
  function H9() {
    return c13 || (process1 && process1.nextTick ? c13 = process1.nextTick : __global$2.queueMicrotask ? c13 = __global$2.queueMicrotask : __setImmediate$ ? c13 = __setImmediate$ : c13 = __global$2.setTimeout, c13);
  }
  function k15(r2, e, t2, n3, o6) {
    return p7.importKey("raw", r2, {
      name: "PBKDF2"
    }, false, [
      "deriveBits"
    ]).then(function(a7) {
      return p7.deriveBits({
        name: "PBKDF2",
        salt: e,
        iterations: t2,
        hash: {
          name: o6
        }
      }, a7, n3 << 3);
    }).then(function(a7) {
      return X5.from(a7);
    });
  }
  function dr2(r2, e) {
    r2.then(function(t2) {
      H9()(function() {
        e(null, t2);
      });
    }, function(t2) {
      H9()(function() {
        e(t2);
      });
    });
  }
  G11.exports = function(r2, e, t2, n3, o6, a7) {
    typeof o6 == "function" && (a7 = o6, o6 = void 0), o6 = o6 || "sha1";
    var u12 = pr2[o6.toLowerCase()];
    if (!u12 || typeof __global$2.Promise != "function") {
      H9()(function() {
        var f8;
        try {
          f8 = Z2(r2, e, t2, n3, o6);
        } catch (i) {
          return a7(i);
        }
        a7(null, f8);
      });
      return;
    }
    if (lr(t2, n3), r2 = _11(r2, R13, "Password"), e = _11(e, R13, "Salt"), typeof a7 != "function")
      throw new Error("No callback provided to pbkdf2");
    dr2(vr2(u12).then(function(f8) {
      return f8 ? k15(r2, e, t2, n3, u12) : Z2(r2, e, t2, n3, o6);
    }), a7);
  };
});
var z2 = l8((T12) => {
  T12.pbkdf2 = J3();
  T12.pbkdf2Sync = A5();
});
var Q3 = K5(z2());
var V1 = K5(z2());
var { pbkdf2Sync: Pr, pbkdf2: Ar } = V1;
var { default: mr, ...br } = V1;
var gr1 = Q3.default ?? mr ?? br;
var h6 = Object.create;
var a3 = Object.defineProperty;
var p12 = Object.getOwnPropertyDescriptor;
var s4 = Object.getOwnPropertyNames;
var $7 = Object.getPrototypeOf;
var g10 = Object.prototype.hasOwnProperty;
var v8 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var x9 = (e, r2, t2, o6) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let f8 of s4(r2))
      !g10.call(e, f8) && f8 !== t2 && a3(e, f8, {
        get: () => r2[f8],
        enumerable: !(o6 = p12(r2, f8)) || o6.enumerable
      });
  return e;
};
var l9 = (e, r2, t2) => (t2 = e != null ? h6($7(e)) : {}, x9(r2 || !e || !e.__esModule ? a3(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var u6 = v8((b15, m20) => {
  m20.exports = function(r2, t2) {
    for (var o6 = Math.min(r2.length, t2.length), f8 = new Buffer2(o6), n3 = 0; n3 < o6; ++n3)
      f8[n3] = r2[n3] ^ t2[n3];
    return f8;
  };
});
var d7 = l9(u6());
var c6 = l9(u6());
var { default: w10, ...B5 } = c6;
var i7 = d7.default ?? w10 ?? B5;
var k3 = Object.create;
var v9 = Object.defineProperty;
var M3 = Object.getOwnPropertyDescriptor;
var q5 = Object.getOwnPropertyNames;
var w11 = Object.getPrototypeOf;
var x10 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var E5 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var d8 = (e, r2, t2, i) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let f8 of q5(r2))
      !x10.call(e, f8) && f8 !== t2 && v9(e, f8, {
        get: () => r2[f8],
        enumerable: !(i = M3(r2, f8)) || i.enumerable
      });
  return e;
};
var p13 = (e, r2, t2) => (t2 = e != null ? k3(w11(e)) : {}, d8(r2 || !e || !e.__esModule ? v9(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var y7 = E5((_11, h16) => {
  var l22 = L1, D12 = R2;
  function K14(e, r2, t2, i) {
    if (l22.isBuffer(e) || (e = l22.from(e, "binary")), r2 && (l22.isBuffer(r2) || (r2 = l22.from(r2, "binary")), r2.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var f8 = t2 / 8, u12 = l22.alloc(f8), m20 = l22.alloc(i || 0), o6 = l22.alloc(0); f8 > 0 || i > 0; ) {
      var n3 = new D12();
      n3.update(o6), n3.update(e), r2 && n3.update(r2), o6 = n3.digest();
      var a7 = 0;
      if (f8 > 0) {
        var b15 = u12.length - f8;
        a7 = Math.min(f8, o6.length), o6.copy(u12, b15, 0, a7), f8 -= a7;
      }
      if (a7 < o6.length && i > 0) {
        var $17 = m20.length - i, g17 = Math.min(i, o6.length - a7);
        o6.copy(m20, $17, a7, a7 + g17), i -= g17;
      }
    }
    return o6.fill(0), {
      key: u12,
      iv: m20
    };
  }
  h16.exports = K14;
});
var B6 = p13(y7());
var P4 = p13(y7());
var { default: R3, ...T2 } = P4;
var j3 = B6.default ?? R3 ?? T2;
var _4 = Object.create;
var a4 = Object.defineProperty;
var c7 = Object.getOwnPropertyDescriptor;
var g11 = Object.getOwnPropertyNames;
var y8 = Object.getPrototypeOf;
var w12 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (r2, i) => (typeof require != "undefined" ? require : r2)[i]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var m9 = (t2, r2) => () => (r2 || t2((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var v10 = (t2, r2, i, e) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let n3 of g11(r2))
      !w12.call(t2, n3) && n3 !== i && a4(t2, n3, {
        get: () => r2[n3],
        enumerable: !(e = c7(r2, n3)) || e.enumerable
      });
  return t2;
};
var f4 = (t2, r2, i) => (i = t2 != null ? _4(y8(t2)) : {}, v10(r2 || !t2 || !t2.__esModule ? a4(i, "default", {
  value: t2,
  enumerable: true
}) : i, t2));
var h7 = m9((B18, d14) => {
  var u12 = L1, p7 = Stream.Transform, D12 = __default4.StringDecoder, A14 = w;
  function o6(t2) {
    p7.call(this), this.hashMode = typeof t2 == "string", this.hashMode ? this[t2] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  A14(o6, p7);
  o6.prototype.update = function(t2, r2, i) {
    typeof t2 == "string" && (t2 = u12.from(t2, r2));
    var e = this._update(t2);
    return this.hashMode ? this : (i && (e = this._toString(e, i)), e);
  };
  o6.prototype.setAutoPadding = function() {
  };
  o6.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  o6.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  o6.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  o6.prototype._transform = function(t2, r2, i) {
    var e;
    try {
      this.hashMode ? this._update(t2) : this.push(this._update(t2));
    } catch (n3) {
      e = n3;
    } finally {
      i(e);
    }
  };
  o6.prototype._flush = function(t2) {
    var r2;
    try {
      this.push(this.__final());
    } catch (i) {
      r2 = i;
    }
    t2(r2);
  };
  o6.prototype._finalOrDigest = function(t2) {
    var r2 = this.__final() || u12.alloc(0);
    return t2 && (r2 = this._toString(r2, t2, true)), r2;
  };
  o6.prototype._toString = function(t2, r2, i) {
    if (this._decoder || (this._decoder = new D12(r2), this._encoding = r2), this._encoding !== r2)
      throw new Error("can't switch encodings");
    var e = this._decoder.write(t2);
    return i && (e += this._decoder.end()), e;
  };
  d14.exports = o6;
});
var l10 = f4(h7());
var S5 = f4(h7());
var { default: q6, ...T3 } = S5;
var M4 = l10.default ?? q6 ?? T3;
var He = Object.create;
var ie = Object.defineProperty;
var Ke = Object.getOwnPropertyDescriptor;
var Le3 = Object.getOwnPropertyNames;
var $e = Object.getPrototypeOf;
var Pe1 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var l11 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var Ze = (e, r2, t2, i) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let a7 of Le3(r2))
      !Pe1.call(e, a7) && a7 !== t2 && ie(e, a7, {
        get: () => r2[a7],
        enumerable: !(i = Ke(r2, a7)) || i.enumerable
      });
  return e;
};
var ae = (e, r2, t2) => (t2 = e != null ? He($e(e)) : {}, Ze(r2 || !e || !e.__esModule ? ie(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var ce1 = l11((O9) => {
  O9.encrypt = function(e, r2) {
    return e._cipher.encryptBlock(r2);
  };
  O9.decrypt = function(e, r2) {
    return e._cipher.decryptBlock(r2);
  };
});
var he = l11((M14) => {
  var ne2 = i7;
  M14.encrypt = function(e, r2) {
    var t2 = ne2(r2, e._prev);
    return e._prev = e._cipher.encryptBlock(t2), e._prev;
  };
  M14.decrypt = function(e, r2) {
    var t2 = e._prev;
    e._prev = r2;
    var i = e._cipher.decryptBlock(r2);
    return ne2(i, t2);
  };
});
var ue1 = l11((pe2) => {
  var I13 = L1, We2 = i7;
  function oe3(e, r2, t2) {
    var i = r2.length, a7 = We2(r2, e._cache);
    return e._cache = e._cache.slice(i), e._prev = I13.concat([
      e._prev,
      t2 ? r2 : a7
    ]), a7;
  }
  pe2.encrypt = function(e, r2, t2) {
    for (var i = I13.allocUnsafe(0), a7; r2.length; )
      if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = I13.allocUnsafe(0)), e._cache.length <= r2.length)
        a7 = e._cache.length, i = I13.concat([
          i,
          oe3(e, r2.slice(0, a7), t2)
        ]), r2 = r2.slice(a7);
      else {
        i = I13.concat([
          i,
          oe3(e, r2, t2)
        ]);
        break;
      }
    return i;
  };
});
var fe1 = l11((se3) => {
  var G11 = L1;
  function Je(e, r2, t2) {
    var i = e._cipher.encryptBlock(e._prev), a7 = i[0] ^ r2;
    return e._prev = G11.concat([
      e._prev.slice(1),
      G11.from([
        t2 ? r2 : a7
      ])
    ]), a7;
  }
  se3.encrypt = function(e, r2, t2) {
    for (var i = r2.length, a7 = G11.allocUnsafe(i), c13 = -1; ++c13 < i; )
      a7[c13] = Je(e, r2[c13], t2);
    return a7;
  };
});
var le = l11((ve2) => {
  var D12 = L1;
  function Qe2(e, r2, t2) {
    for (var i, a7 = -1, c13 = 8, n3 = 0, h16, u12; ++a7 < c13; )
      i = e._cipher.encryptBlock(e._prev), h16 = r2 & 1 << 7 - a7 ? 128 : 0, u12 = i[0] ^ h16, n3 += (u12 & 128) >> a7 % 8, e._prev = Ye2(e._prev, t2 ? h16 : u12);
    return n3;
  }
  function Ye2(e, r2) {
    var t2 = e.length, i = -1, a7 = D12.allocUnsafe(e.length);
    for (e = D12.concat([
      e,
      D12.from([
        r2
      ])
    ]); ++i < t2; )
      a7[i] = e[i] << 1 | e[i + 1] >> 7;
    return a7;
  }
  ve2.encrypt = function(e, r2, t2) {
    for (var i = r2.length, a7 = D12.allocUnsafe(i), c13 = -1; ++c13 < i; )
      a7[c13] = Qe2(e, r2[c13], t2);
    return a7;
  };
});
var ye = l11((_e2) => {
  var je2 = i7;
  function er2(e) {
    return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
  }
  _e2.encrypt = function(e, r2) {
    for (; e._cache.length < r2.length; )
      e._cache = Buffer2.concat([
        e._cache,
        er2(e)
      ]);
    var t2 = e._cache.slice(0, r2.length);
    return e._cache = e._cache.slice(r2.length), je2(r2, t2);
  };
});
var z3 = l11((Hr2, de2) => {
  function rr2(e) {
    for (var r2 = e.length, t2; r2--; )
      if (t2 = e.readUInt8(r2), t2 === 255)
        e.writeUInt8(0, r2);
      else {
        t2++, e.writeUInt8(t2, r2);
        break;
      }
  }
  de2.exports = rr2;
});
var K6 = l11((Be2) => {
  var tr2 = i7, ge2 = L1, ir2 = z3();
  function ar2(e) {
    var r2 = e._cipher.encryptBlockRaw(e._prev);
    return ir2(e._prev), r2;
  }
  var H9 = 16;
  Be2.encrypt = function(e, r2) {
    var t2 = Math.ceil(r2.length / H9), i = e._cache.length;
    e._cache = ge2.concat([
      e._cache,
      ge2.allocUnsafe(t2 * H9)
    ]);
    for (var a7 = 0; a7 < t2; a7++) {
      var c13 = ar2(e), n3 = i + a7 * H9;
      e._cache.writeUInt32BE(c13[0], n3 + 0), e._cache.writeUInt32BE(c13[1], n3 + 4), e._cache.writeUInt32BE(c13[2], n3 + 8), e._cache.writeUInt32BE(c13[3], n3 + 12);
    }
    var h16 = e._cache.slice(0, r2.length);
    return e._cache = e._cache.slice(r2.length), tr2(r2, h16);
  };
});
var L5 = l11((Lr, cr) => {
  cr.exports = {
    "aes-128-ecb": {
      cipher: "AES",
      key: 128,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-192-ecb": {
      cipher: "AES",
      key: 192,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-256-ecb": {
      cipher: "AES",
      key: 256,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-128-cbc": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-192-cbc": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-256-cbc": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes128: {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes192: {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes256: {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-128-cfb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-192-cfb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-256-cfb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-128-cfb8": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-192-cfb8": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-256-cfb8": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-128-cfb1": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-192-cfb1": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-256-cfb1": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-128-ofb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-192-ofb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-256-ofb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-128-ctr": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-192-ctr": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-256-ctr": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-128-gcm": {
      cipher: "AES",
      key: 128,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-192-gcm": {
      cipher: "AES",
      key: 192,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-256-gcm": {
      cipher: "AES",
      key: 256,
      iv: 12,
      mode: "GCM",
      type: "auth"
    }
  };
});
var P5 = l11(($r, me2) => {
  var nr2 = {
    ECB: ce1(),
    CBC: he(),
    CFB: ue1(),
    CFB8: fe1(),
    CFB1: le(),
    OFB: ye(),
    CTR: K6(),
    GCM: K6()
  }, F12 = L5();
  for ($17 in F12)
    F12[$17].module = nr2[F12[$17].mode];
  var $17;
  me2.exports = F12;
});
var k4 = l11((Pr2, we2) => {
  var R13 = L1;
  function W2(e) {
    R13.isBuffer(e) || (e = R13.from(e));
    for (var r2 = e.length / 4 | 0, t2 = new Array(r2), i = 0; i < r2; i++)
      t2[i] = e.readUInt32BE(i * 4);
    return t2;
  }
  function Z2(e) {
    for (var r2 = 0; r2 < e.length; e++)
      e[r2] = 0;
  }
  function Ee2(e, r2, t2, i, a7) {
    for (var c13 = t2[0], n3 = t2[1], h16 = t2[2], u12 = t2[3], p7 = e[0] ^ r2[0], f8 = e[1] ^ r2[1], y16 = e[2] ^ r2[2], d14 = e[3] ^ r2[3], s10, C11, S14, x17, E15 = 4, te2 = 1; te2 < a7; te2++)
      s10 = c13[p7 >>> 24] ^ n3[f8 >>> 16 & 255] ^ h16[y16 >>> 8 & 255] ^ u12[d14 & 255] ^ r2[E15++], C11 = c13[f8 >>> 24] ^ n3[y16 >>> 16 & 255] ^ h16[d14 >>> 8 & 255] ^ u12[p7 & 255] ^ r2[E15++], S14 = c13[y16 >>> 24] ^ n3[d14 >>> 16 & 255] ^ h16[p7 >>> 8 & 255] ^ u12[f8 & 255] ^ r2[E15++], x17 = c13[d14 >>> 24] ^ n3[p7 >>> 16 & 255] ^ h16[f8 >>> 8 & 255] ^ u12[y16 & 255] ^ r2[E15++], p7 = s10, f8 = C11, y16 = S14, d14 = x17;
    return s10 = (i[p7 >>> 24] << 24 | i[f8 >>> 16 & 255] << 16 | i[y16 >>> 8 & 255] << 8 | i[d14 & 255]) ^ r2[E15++], C11 = (i[f8 >>> 24] << 24 | i[y16 >>> 16 & 255] << 16 | i[d14 >>> 8 & 255] << 8 | i[p7 & 255]) ^ r2[E15++], S14 = (i[y16 >>> 24] << 24 | i[d14 >>> 16 & 255] << 16 | i[p7 >>> 8 & 255] << 8 | i[f8 & 255]) ^ r2[E15++], x17 = (i[d14 >>> 24] << 24 | i[p7 >>> 16 & 255] << 16 | i[f8 >>> 8 & 255] << 8 | i[y16 & 255]) ^ r2[E15++], s10 = s10 >>> 0, C11 = C11 >>> 0, S14 = S14 >>> 0, x17 = x17 >>> 0, [
      s10,
      C11,
      S14,
      x17
    ];
  }
  var hr2 = [
    0,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    27,
    54
  ], v19 = function() {
    for (var e = new Array(256), r2 = 0; r2 < 256; r2++)
      r2 < 128 ? e[r2] = r2 << 1 : e[r2] = r2 << 1 ^ 283;
    for (var t2 = [], i = [], a7 = [
      [],
      [],
      [],
      []
    ], c13 = [
      [],
      [],
      [],
      []
    ], n3 = 0, h16 = 0, u12 = 0; u12 < 256; ++u12) {
      var p7 = h16 ^ h16 << 1 ^ h16 << 2 ^ h16 << 3 ^ h16 << 4;
      p7 = p7 >>> 8 ^ p7 & 255 ^ 99, t2[n3] = p7, i[p7] = n3;
      var f8 = e[n3], y16 = e[f8], d14 = e[y16], s10 = e[p7] * 257 ^ p7 * 16843008;
      a7[0][n3] = s10 << 24 | s10 >>> 8, a7[1][n3] = s10 << 16 | s10 >>> 16, a7[2][n3] = s10 << 8 | s10 >>> 24, a7[3][n3] = s10, s10 = d14 * 16843009 ^ y16 * 65537 ^ f8 * 257 ^ n3 * 16843008, c13[0][p7] = s10 << 24 | s10 >>> 8, c13[1][p7] = s10 << 16 | s10 >>> 16, c13[2][p7] = s10 << 8 | s10 >>> 24, c13[3][p7] = s10, n3 === 0 ? n3 = h16 = 1 : (n3 = f8 ^ e[e[e[d14 ^ f8]]], h16 ^= e[e[h16]]);
    }
    return {
      SBOX: t2,
      INV_SBOX: i,
      SUB_MIX: a7,
      INV_SUB_MIX: c13
    };
  }();
  function g17(e) {
    this._key = W2(e), this._reset();
  }
  g17.blockSize = 4 * 4;
  g17.keySize = 256 / 8;
  g17.prototype.blockSize = g17.blockSize;
  g17.prototype.keySize = g17.keySize;
  g17.prototype._reset = function() {
    for (var e = this._key, r2 = e.length, t2 = r2 + 6, i = (t2 + 1) * 4, a7 = [], c13 = 0; c13 < r2; c13++)
      a7[c13] = e[c13];
    for (c13 = r2; c13 < i; c13++) {
      var n3 = a7[c13 - 1];
      c13 % r2 === 0 ? (n3 = n3 << 8 | n3 >>> 24, n3 = v19.SBOX[n3 >>> 24] << 24 | v19.SBOX[n3 >>> 16 & 255] << 16 | v19.SBOX[n3 >>> 8 & 255] << 8 | v19.SBOX[n3 & 255], n3 ^= hr2[c13 / r2 | 0] << 24) : r2 > 6 && c13 % r2 === 4 && (n3 = v19.SBOX[n3 >>> 24] << 24 | v19.SBOX[n3 >>> 16 & 255] << 16 | v19.SBOX[n3 >>> 8 & 255] << 8 | v19.SBOX[n3 & 255]), a7[c13] = a7[c13 - r2] ^ n3;
    }
    for (var h16 = [], u12 = 0; u12 < i; u12++) {
      var p7 = i - u12, f8 = a7[p7 - (u12 % 4 ? 0 : 4)];
      u12 < 4 || p7 <= 4 ? h16[u12] = f8 : h16[u12] = v19.INV_SUB_MIX[0][v19.SBOX[f8 >>> 24]] ^ v19.INV_SUB_MIX[1][v19.SBOX[f8 >>> 16 & 255]] ^ v19.INV_SUB_MIX[2][v19.SBOX[f8 >>> 8 & 255]] ^ v19.INV_SUB_MIX[3][v19.SBOX[f8 & 255]];
    }
    this._nRounds = t2, this._keySchedule = a7, this._invKeySchedule = h16;
  };
  g17.prototype.encryptBlockRaw = function(e) {
    return e = W2(e), Ee2(e, this._keySchedule, v19.SUB_MIX, v19.SBOX, this._nRounds);
  };
  g17.prototype.encryptBlock = function(e) {
    var r2 = this.encryptBlockRaw(e), t2 = R13.allocUnsafe(16);
    return t2.writeUInt32BE(r2[0], 0), t2.writeUInt32BE(r2[1], 4), t2.writeUInt32BE(r2[2], 8), t2.writeUInt32BE(r2[3], 12), t2;
  };
  g17.prototype.decryptBlock = function(e) {
    e = W2(e);
    var r2 = e[1];
    e[1] = e[3], e[3] = r2;
    var t2 = Ee2(e, this._invKeySchedule, v19.INV_SUB_MIX, v19.INV_SBOX, this._nRounds), i = R13.allocUnsafe(16);
    return i.writeUInt32BE(t2[0], 0), i.writeUInt32BE(t2[3], 4), i.writeUInt32BE(t2[2], 8), i.writeUInt32BE(t2[1], 12), i;
  };
  g17.prototype.scrub = function() {
    Z2(this._keySchedule), Z2(this._invKeySchedule), Z2(this._key);
  };
  we2.exports.AES = g17;
});
var xe1 = l11((Zr, Se2) => {
  var A14 = L1, or3 = A14.alloc(16, 0);
  function pr2(e) {
    return [
      e.readUInt32BE(0),
      e.readUInt32BE(4),
      e.readUInt32BE(8),
      e.readUInt32BE(12)
    ];
  }
  function Ce(e) {
    var r2 = A14.allocUnsafe(16);
    return r2.writeUInt32BE(e[0] >>> 0, 0), r2.writeUInt32BE(e[1] >>> 0, 4), r2.writeUInt32BE(e[2] >>> 0, 8), r2.writeUInt32BE(e[3] >>> 0, 12), r2;
  }
  function q15(e) {
    this.h = e, this.state = A14.alloc(16, 0), this.cache = A14.allocUnsafe(0);
  }
  q15.prototype.ghash = function(e) {
    for (var r2 = -1; ++r2 < e.length; )
      this.state[r2] ^= e[r2];
    this._multiply();
  };
  q15.prototype._multiply = function() {
    for (var e = pr2(this.h), r2 = [
      0,
      0,
      0,
      0
    ], t2, i, a7, c13 = -1; ++c13 < 128; ) {
      for (i = (this.state[~~(c13 / 8)] & 1 << 7 - c13 % 8) !== 0, i && (r2[0] ^= e[0], r2[1] ^= e[1], r2[2] ^= e[2], r2[3] ^= e[3]), a7 = (e[3] & 1) !== 0, t2 = 3; t2 > 0; t2--)
        e[t2] = e[t2] >>> 1 | (e[t2 - 1] & 1) << 31;
      e[0] = e[0] >>> 1, a7 && (e[0] = e[0] ^ 225 << 24);
    }
    this.state = Ce(r2);
  };
  q15.prototype.update = function(e) {
    this.cache = A14.concat([
      this.cache,
      e
    ]);
    for (var r2; this.cache.length >= 16; )
      r2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(r2);
  };
  q15.prototype.final = function(e, r2) {
    return this.cache.length && this.ghash(A14.concat([
      this.cache,
      or3
    ], 16)), this.ghash(Ce([
      0,
      e,
      0,
      r2
    ])), this.state;
  };
  Se2.exports = q15;
});
var J4 = l11((Wr, Ie) => {
  var ur = k4(), _11 = L1, Ae3 = M4, sr = w, Ue2 = xe1(), fr = i7, vr2 = z3();
  function lr(e, r2) {
    var t2 = 0;
    e.length !== r2.length && t2++;
    for (var i = Math.min(e.length, r2.length), a7 = 0; a7 < i; ++a7)
      t2 += e[a7] ^ r2[a7];
    return t2;
  }
  function _r(e, r2, t2) {
    if (r2.length === 12)
      return e._finID = _11.concat([
        r2,
        _11.from([
          0,
          0,
          0,
          1
        ])
      ]), _11.concat([
        r2,
        _11.from([
          0,
          0,
          0,
          2
        ])
      ]);
    var i = new Ue2(t2), a7 = r2.length, c13 = a7 % 16;
    i.update(r2), c13 && (c13 = 16 - c13, i.update(_11.alloc(c13, 0))), i.update(_11.alloc(8, 0));
    var n3 = a7 * 8, h16 = _11.alloc(8);
    h16.writeUIntBE(n3, 0, 8), i.update(h16), e._finID = i.state;
    var u12 = _11.from(e._finID);
    return vr2(u12), u12;
  }
  function w110(e, r2, t2, i) {
    Ae3.call(this);
    var a7 = _11.alloc(4, 0);
    this._cipher = new ur.AES(r2);
    var c13 = this._cipher.encryptBlock(a7);
    this._ghash = new Ue2(c13), t2 = _r(this, t2, c13), this._prev = _11.from(t2), this._cache = _11.allocUnsafe(0), this._secCache = _11.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = false;
  }
  sr(w110, Ae3);
  w110.prototype._update = function(e) {
    if (!this._called && this._alen) {
      var r2 = 16 - this._alen % 16;
      r2 < 16 && (r2 = _11.alloc(r2, 0), this._ghash.update(r2));
    }
    this._called = true;
    var t2 = this._mode.encrypt(this, e);
    return this._decrypt ? this._ghash.update(e) : this._ghash.update(t2), this._len += e.length, t2;
  };
  w110.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var e = fr(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && lr(e, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = e, this._cipher.scrub();
  };
  w110.prototype.getAuthTag = function() {
    if (this._decrypt || !_11.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  w110.prototype.setAuthTag = function(r2) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = r2;
  };
  w110.prototype.setAAD = function(r2) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(r2), this._alen += r2.length;
  };
  Ie.exports = w110;
});
var Y3 = l11((Jr, qe4) => {
  var yr2 = k4(), Q9 = L1, ke3 = M4, dr2 = w;
  function X5(e, r2, t2, i) {
    ke3.call(this), this._cipher = new yr2.AES(r2), this._prev = Q9.from(t2), this._cache = Q9.allocUnsafe(0), this._secCache = Q9.allocUnsafe(0), this._decrypt = i, this._mode = e;
  }
  dr2(X5, ke3);
  X5.prototype._update = function(e) {
    return this._mode.encrypt(this, e, this._decrypt);
  };
  X5.prototype._final = function() {
    this._cipher.scrub();
  };
  qe4.exports = X5;
});
var Fe1 = l11((j13) => {
  var be3 = P5(), gr2 = J4(), m20 = L1, Br2 = Y3(), Te = M4, mr2 = k4(), Er2 = j3, wr2 = w;
  function b15(e, r2, t2) {
    Te.call(this), this._cache = new N6(), this._cipher = new mr2.AES(r2), this._prev = m20.from(t2), this._mode = e, this._autopadding = true;
  }
  wr2(b15, Te);
  b15.prototype._update = function(e) {
    this._cache.add(e);
    for (var r2, t2, i = []; r2 = this._cache.get(); )
      t2 = this._mode.encrypt(this, r2), i.push(t2);
    return m20.concat(i);
  };
  var Cr = m20.alloc(16, 16);
  b15.prototype._final = function() {
    var e = this._cache.flush();
    if (this._autopadding)
      return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
    if (!e.equals(Cr))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  b15.prototype.setAutoPadding = function(e) {
    return this._autopadding = !!e, this;
  };
  function N6() {
    this.cache = m20.allocUnsafe(0);
  }
  N6.prototype.add = function(e) {
    this.cache = m20.concat([
      this.cache,
      e
    ]);
  };
  N6.prototype.get = function() {
    if (this.cache.length > 15) {
      var e = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), e;
    }
    return null;
  };
  N6.prototype.flush = function() {
    for (var e = 16 - this.cache.length, r2 = m20.allocUnsafe(e), t2 = -1; ++t2 < e; )
      r2.writeUInt8(e, t2);
    return m20.concat([
      this.cache,
      r2
    ]);
  };
  function De5(e, r2, t2) {
    var i = be3[e.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof r2 == "string" && (r2 = m20.from(r2)), r2.length !== i.key / 8)
      throw new TypeError("invalid key length " + r2.length);
    if (typeof t2 == "string" && (t2 = m20.from(t2)), i.mode !== "GCM" && t2.length !== i.iv)
      throw new TypeError("invalid iv length " + t2.length);
    return i.type === "stream" ? new Br2(i.module, r2, t2) : i.type === "auth" ? new gr2(i.module, r2, t2) : new b15(i.module, r2, t2);
  }
  function Sr(e, r2) {
    var t2 = be3[e.toLowerCase()];
    if (!t2)
      throw new TypeError("invalid suite type");
    var i = Er2(r2, false, t2.key, t2.iv);
    return De5(e, i.key, i.iv);
  }
  j13.createCipheriv = De5;
  j13.createCipher = Sr;
});
var Ve1 = l11((ee2) => {
  var xr2 = J4(), U7 = L1, Re2 = P5(), Ar2 = Y3(), Xe = M4, Ur = k4(), Ir = j3, kr2 = w;
  function T12(e, r2, t2) {
    Xe.call(this), this._cache = new V8(), this._last = void 0, this._cipher = new Ur.AES(r2), this._prev = U7.from(t2), this._mode = e, this._autopadding = true;
  }
  kr2(T12, Xe);
  T12.prototype._update = function(e) {
    this._cache.add(e);
    for (var r2, t2, i = []; r2 = this._cache.get(this._autopadding); )
      t2 = this._mode.decrypt(this, r2), i.push(t2);
    return U7.concat(i);
  };
  T12.prototype._final = function() {
    var e = this._cache.flush();
    if (this._autopadding)
      return qr2(this._mode.decrypt(this, e));
    if (e)
      throw new Error("data not multiple of block length");
  };
  T12.prototype.setAutoPadding = function(e) {
    return this._autopadding = !!e, this;
  };
  function V8() {
    this.cache = U7.allocUnsafe(0);
  }
  V8.prototype.add = function(e) {
    this.cache = U7.concat([
      this.cache,
      e
    ]);
  };
  V8.prototype.get = function(e) {
    var r2;
    if (e) {
      if (this.cache.length > 16)
        return r2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r2;
    } else if (this.cache.length >= 16)
      return r2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r2;
    return null;
  };
  V8.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function qr2(e) {
    var r2 = e[15];
    if (r2 < 1 || r2 > 16)
      throw new Error("unable to decrypt data");
    for (var t2 = -1; ++t2 < r2; )
      if (e[t2 + (16 - r2)] !== r2)
        throw new Error("unable to decrypt data");
    if (r2 !== 16)
      return e.slice(0, 16 - r2);
  }
  function Ne(e, r2, t2) {
    var i = Re2[e.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof t2 == "string" && (t2 = U7.from(t2)), i.mode !== "GCM" && t2.length !== i.iv)
      throw new TypeError("invalid iv length " + t2.length);
    if (typeof r2 == "string" && (r2 = U7.from(r2)), r2.length !== i.key / 8)
      throw new TypeError("invalid key length " + r2.length);
    return i.type === "stream" ? new Ar2(i.module, r2, t2, true) : i.type === "auth" ? new xr2(i.module, r2, t2, true) : new T12(i.module, r2, t2);
  }
  function br3(e, r2) {
    var t2 = Re2[e.toLowerCase()];
    if (!t2)
      throw new TypeError("invalid suite type");
    var i = Ir(r2, false, t2.key, t2.iv);
    return Ne(e, i.key, i.iv);
  }
  ee2.createDecipher = br3;
  ee2.createDecipheriv = Ne;
});
var re = l11((B18) => {
  var Oe = Fe1(), Me = Ve1(), Tr = L5();
  function Dr2() {
    return Object.keys(Tr);
  }
  B18.createCipher = B18.Cipher = Oe.createCipher;
  B18.createCipheriv = B18.Cipheriv = Oe.createCipheriv;
  B18.createDecipher = B18.Decipher = Me.createDecipher;
  B18.createDecipheriv = B18.Decipheriv = Me.createDecipheriv;
  B18.listCiphers = B18.getCiphers = Dr2;
});
var Ge = ae(re());
var ze1 = ae(re());
var { createCipher: et, Cipher: rt1, createCipheriv: tt1, Cipheriv: it1, createDecipher: at, Decipher: ct1, createDecipheriv: nt, Decipheriv: ht1, listCiphers: ot, getCiphers: pt } = ze1;
var { default: Fr, ...Rr } = ze1;
var ut1 = Ge.default ?? Fr ?? Rr;
var l12 = Object.create;
var y9 = Object.defineProperty;
var b5 = Object.getOwnPropertyDescriptor;
var w13 = Object.getOwnPropertyNames;
var d9 = Object.getPrototypeOf;
var T4 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var S6 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var k5 = (e, r2, t2, o6) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let u12 of w13(r2))
      !T4.call(e, u12) && u12 !== t2 && y9(e, u12, {
        get: () => r2[u12],
        enumerable: !(o6 = b5(r2, u12)) || o6.enumerable
      });
  return e;
};
var c8 = (e, r2, t2) => (t2 = e != null ? l12(d9(e)) : {}, k5(r2 || !e || !e.__esModule ? y9(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var s5 = S6((v19, g17) => {
  "use strict";
  var p7 = export_default, i = p7.Buffer, f8 = {}, n3;
  for (n3 in p7)
    !p7.hasOwnProperty(n3) || n3 === "SlowBuffer" || n3 === "Buffer" || (f8[n3] = p7[n3]);
  var a7 = f8.Buffer = {};
  for (n3 in i)
    !i.hasOwnProperty(n3) || n3 === "allocUnsafe" || n3 === "allocUnsafeSlow" || (a7[n3] = i[n3]);
  f8.Buffer.prototype = i.prototype;
  (!a7.from || a7.from === Uint8Array.from) && (a7.from = function(e, r2, t2) {
    if (typeof e == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
    if (e && typeof e.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    return i(e, r2, t2);
  });
  a7.alloc || (a7.alloc = function(e, r2, t2) {
    if (typeof e != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
    if (e < 0 || e >= 2 * (1 << 30))
      throw new RangeError('The value "' + e + '" is invalid for option "size"');
    var o6 = i(e);
    return !r2 || r2.length === 0 ? o6.fill(0) : typeof t2 == "string" ? o6.fill(r2, t2) : o6.fill(r2), o6;
  });
  if (!f8.kStringMaxLength)
    try {
      f8.kStringMaxLength = process2.binding("buffer").kStringMaxLength;
    } catch {
    }
  f8.constants || (f8.constants = {
    MAX_LENGTH: f8.kMaxLength
  }, f8.kStringMaxLength && (f8.constants.MAX_STRING_LENGTH = f8.kStringMaxLength));
  g17.exports = f8;
});
var h8 = c8(s5());
var m10 = c8(s5());
var { constants: A6 } = m10;
var { default: B7, ...L6 } = m10;
var E6 = h8.default ?? B7 ?? L6;
var Be = Object.create;
var J5 = Object.defineProperty;
var we = Object.getOwnPropertyDescriptor;
var De2 = Object.getOwnPropertyNames;
var ve = Object.getPrototypeOf;
var qe2 = Object.prototype.hasOwnProperty;
((o6) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(o6, {
  get: (e, t2) => (typeof require != "undefined" ? require : e)[t2]
}) : o6)(function(o6) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + o6 + '" is not supported');
});
var h9 = (o6, e) => () => (e || o6((e = {
  exports: {}
}).exports, e), e.exports);
var ke1 = (o6, e, t2, r2) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n3 of De2(e))
      !qe2.call(o6, n3) && n3 !== t2 && J5(o6, n3, {
        get: () => e[n3],
        enumerable: !(r2 = we(e, n3)) || r2.enumerable
      });
  return o6;
};
var V2 = (o6, e, t2) => (t2 = o6 != null ? Be(ve(o6)) : {}, ke1(e || !o6 || !o6.__esModule ? J5(t2, "default", {
  value: o6,
  enumerable: true
}) : t2, o6));
var k6 = h9((Z2) => {
  "use strict";
  var Ce = w;
  function y16(o6) {
    this._reporterState = {
      obj: null,
      path: [],
      options: o6 || {},
      errors: []
    };
  }
  Z2.Reporter = y16;
  y16.prototype.isError = function(e) {
    return e instanceof S14;
  };
  y16.prototype.save = function() {
    let e = this._reporterState;
    return {
      obj: e.obj,
      pathLen: e.path.length
    };
  };
  y16.prototype.restore = function(e) {
    let t2 = this._reporterState;
    t2.obj = e.obj, t2.path = t2.path.slice(0, e.pathLen);
  };
  y16.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  y16.prototype.exitKey = function(e) {
    let t2 = this._reporterState;
    t2.path = t2.path.slice(0, e - 1);
  };
  y16.prototype.leaveKey = function(e, t2, r2) {
    let n3 = this._reporterState;
    this.exitKey(e), n3.obj !== null && (n3.obj[t2] = r2);
  };
  y16.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  y16.prototype.enterObject = function() {
    let e = this._reporterState, t2 = e.obj;
    return e.obj = {}, t2;
  };
  y16.prototype.leaveObject = function(e) {
    let t2 = this._reporterState, r2 = t2.obj;
    return t2.obj = e, r2;
  };
  y16.prototype.error = function(e) {
    let t2, r2 = this._reporterState, n3 = e instanceof S14;
    if (n3 ? t2 = e : t2 = new S14(r2.path.map(function(i) {
      return "[" + JSON.stringify(i) + "]";
    }).join(""), e.message || e, e.stack), !r2.options.partial)
      throw t2;
    return n3 || r2.errors.push(t2), t2;
  };
  y16.prototype.wrapResult = function(e) {
    let t2 = this._reporterState;
    return t2.options.partial ? {
      result: this.isError(e) ? null : e,
      errors: t2.errors
    } : e;
  };
  function S14(o6, e) {
    this.path = o6, this.rethrow(e);
  }
  Ce(S14, Error);
  S14.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, S14), !this.stack)
      try {
        throw new Error(this.message);
      } catch (t2) {
        this.stack = t2.stack;
      }
    return this;
  };
});
var w14 = h9((O9) => {
  "use strict";
  var Ue2 = w, C11 = k6().Reporter, j13 = E6.Buffer;
  function g17(o6, e) {
    if (C11.call(this, e), !j13.isBuffer(o6)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = o6, this.offset = 0, this.length = o6.length;
  }
  Ue2(g17, C11);
  O9.DecoderBuffer = g17;
  g17.isDecoderBuffer = function(e) {
    return e instanceof g17 ? true : typeof e == "object" && j13.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  g17.prototype.save = function() {
    return {
      offset: this.offset,
      reporter: C11.prototype.save.call(this)
    };
  };
  g17.prototype.restore = function(e) {
    let t2 = new g17(this.base);
    return t2.offset = e.offset, t2.length = this.offset, this.offset = e.offset, C11.prototype.restore.call(this, e.reporter), t2;
  };
  g17.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  g17.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  g17.prototype.skip = function(e, t2) {
    if (!(this.offset + e <= this.length))
      return this.error(t2 || "DecoderBuffer overrun");
    let r2 = new g17(this.base);
    return r2._reporterState = this._reporterState, r2.offset = this.offset, r2.length = this.offset + e, this.offset += e, r2;
  };
  g17.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function B18(o6, e) {
    if (Array.isArray(o6))
      this.length = 0, this.value = o6.map(function(t2) {
        return B18.isEncoderBuffer(t2) || (t2 = new B18(t2, e)), this.length += t2.length, t2;
      }, this);
    else if (typeof o6 == "number") {
      if (!(0 <= o6 && o6 <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = o6, this.length = 1;
    } else if (typeof o6 == "string")
      this.value = o6, this.length = j13.byteLength(o6);
    else if (j13.isBuffer(o6))
      this.value = o6, this.length = o6.length;
    else
      return e.error("Unsupported type: " + typeof o6);
  }
  O9.EncoderBuffer = B18;
  B18.isEncoderBuffer = function(e) {
    return e instanceof B18 ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  B18.prototype.join = function(e, t2) {
    return e || (e = j13.alloc(this.length)), t2 || (t2 = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(r2) {
      r2.join(e, t2), t2 += r2.length;
    }) : (typeof this.value == "number" ? e[t2] = this.value : typeof this.value == "string" ? e.write(this.value, t2) : j13.isBuffer(this.value) && this.value.copy(e, t2), t2 += this.length)), e;
  };
});
var U2 = h9((tt3, Y7) => {
  "use strict";
  var Ne = k6().Reporter, Te = w14().EncoderBuffer, Oe = w14().DecoderBuffer, d14 = j, H9 = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], Ae3 = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(H9), Ie = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function f8(o6, e, t2) {
    let r2 = {};
    this._baseState = r2, r2.name = t2, r2.enc = o6, r2.parent = e || null, r2.children = null, r2.tag = null, r2.args = null, r2.reverseArgs = null, r2.choice = null, r2.optional = false, r2.any = false, r2.obj = false, r2.use = null, r2.useDecoder = null, r2.key = null, r2.default = null, r2.explicit = null, r2.implicit = null, r2.contains = null, r2.parent || (r2.children = [], this._wrap());
  }
  Y7.exports = f8;
  var Re2 = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  f8.prototype.clone = function() {
    let e = this._baseState, t2 = {};
    Re2.forEach(function(n3) {
      t2[n3] = e[n3];
    });
    let r2 = new this.constructor(t2.parent);
    return r2._baseState = t2, r2;
  };
  f8.prototype._wrap = function() {
    let e = this._baseState;
    Ae3.forEach(function(t2) {
      this[t2] = function() {
        let n3 = new this.constructor(this);
        return e.children.push(n3), n3[t2].apply(n3, arguments);
      };
    }, this);
  };
  f8.prototype._init = function(e) {
    let t2 = this._baseState;
    d14(t2.parent === null), e.call(this), t2.children = t2.children.filter(function(r2) {
      return r2._baseState.parent === this;
    }, this), d14.equal(t2.children.length, 1, "Root node can have only one child");
  };
  f8.prototype._useArgs = function(e) {
    let t2 = this._baseState, r2 = e.filter(function(n3) {
      return n3 instanceof this.constructor;
    }, this);
    e = e.filter(function(n3) {
      return !(n3 instanceof this.constructor);
    }, this), r2.length !== 0 && (d14(t2.children === null), t2.children = r2, r2.forEach(function(n3) {
      n3._baseState.parent = this;
    }, this)), e.length !== 0 && (d14(t2.args === null), t2.args = e, t2.reverseArgs = e.map(function(n3) {
      if (typeof n3 != "object" || n3.constructor !== Object)
        return n3;
      let i = {};
      return Object.keys(n3).forEach(function(s10) {
        s10 == (s10 | 0) && (s10 |= 0);
        let c13 = n3[s10];
        i[c13] = s10;
      }), i;
    }));
  };
  Ie.forEach(function(o6) {
    f8.prototype[o6] = function() {
      let t2 = this._baseState;
      throw new Error(o6 + " not implemented for encoding: " + t2.enc);
    };
  });
  H9.forEach(function(o6) {
    f8.prototype[o6] = function() {
      let t2 = this._baseState, r2 = Array.prototype.slice.call(arguments);
      return d14(t2.tag === null), t2.tag = o6, this._useArgs(r2), this;
    };
  });
  f8.prototype.use = function(e) {
    d14(e);
    let t2 = this._baseState;
    return d14(t2.use === null), t2.use = e, this;
  };
  f8.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  f8.prototype.def = function(e) {
    let t2 = this._baseState;
    return d14(t2.default === null), t2.default = e, t2.optional = true, this;
  };
  f8.prototype.explicit = function(e) {
    let t2 = this._baseState;
    return d14(t2.explicit === null && t2.implicit === null), t2.explicit = e, this;
  };
  f8.prototype.implicit = function(e) {
    let t2 = this._baseState;
    return d14(t2.explicit === null && t2.implicit === null), t2.implicit = e, this;
  };
  f8.prototype.obj = function() {
    let e = this._baseState, t2 = Array.prototype.slice.call(arguments);
    return e.obj = true, t2.length !== 0 && this._useArgs(t2), this;
  };
  f8.prototype.key = function(e) {
    let t2 = this._baseState;
    return d14(t2.key === null), t2.key = e, this;
  };
  f8.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  f8.prototype.choice = function(e) {
    let t2 = this._baseState;
    return d14(t2.choice === null), t2.choice = e, this._useArgs(Object.keys(e).map(function(r2) {
      return e[r2];
    })), this;
  };
  f8.prototype.contains = function(e) {
    let t2 = this._baseState;
    return d14(t2.use === null), t2.contains = e, this;
  };
  f8.prototype._decode = function(e, t2) {
    let r2 = this._baseState;
    if (r2.parent === null)
      return e.wrapResult(r2.children[0]._decode(e, t2));
    let n3 = r2.default, i = true, s10 = null;
    if (r2.key !== null && (s10 = e.enterKey(r2.key)), r2.optional) {
      let l22 = null;
      if (r2.explicit !== null ? l22 = r2.explicit : r2.implicit !== null ? l22 = r2.implicit : r2.tag !== null && (l22 = r2.tag), l22 === null && !r2.any) {
        let u12 = e.save();
        try {
          r2.choice === null ? this._decodeGeneric(r2.tag, e, t2) : this._decodeChoice(e, t2), i = true;
        } catch {
          i = false;
        }
        e.restore(u12);
      } else if (i = this._peekTag(e, l22, r2.any), e.isError(i))
        return i;
    }
    let c13;
    if (r2.obj && i && (c13 = e.enterObject()), i) {
      if (r2.explicit !== null) {
        let u12 = this._decodeTag(e, r2.explicit);
        if (e.isError(u12))
          return u12;
        e = u12;
      }
      let l110 = e.offset;
      if (r2.use === null && r2.choice === null) {
        let u22;
        r2.any && (u22 = e.save());
        let a7 = this._decodeTag(e, r2.implicit !== null ? r2.implicit : r2.tag, r2.any);
        if (e.isError(a7))
          return a7;
        r2.any ? n3 = e.raw(u22) : e = a7;
      }
      if (t2 && t2.track && r2.tag !== null && t2.track(e.path(), l110, e.length, "tagged"), t2 && t2.track && r2.tag !== null && t2.track(e.path(), e.offset, e.length, "content"), r2.any || (r2.choice === null ? n3 = this._decodeGeneric(r2.tag, e, t2) : n3 = this._decodeChoice(e, t2)), e.isError(n3))
        return n3;
      if (!r2.any && r2.choice === null && r2.children !== null && r2.children.forEach(function(a7) {
        a7._decode(e, t2);
      }), r2.contains && (r2.tag === "octstr" || r2.tag === "bitstr")) {
        let u32 = new Oe(n3);
        n3 = this._getUse(r2.contains, e._reporterState.obj)._decode(u32, t2);
      }
    }
    return r2.obj && i && (n3 = e.leaveObject(c13)), r2.key !== null && (n3 !== null || i === true) ? e.leaveKey(s10, r2.key, n3) : s10 !== null && e.exitKey(s10), n3;
  };
  f8.prototype._decodeGeneric = function(e, t2, r2) {
    let n3 = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(t2, e, n3.args[0], r2) : /str$/.test(e) ? this._decodeStr(t2, e, r2) : e === "objid" && n3.args ? this._decodeObjid(t2, n3.args[0], n3.args[1], r2) : e === "objid" ? this._decodeObjid(t2, null, null, r2) : e === "gentime" || e === "utctime" ? this._decodeTime(t2, e, r2) : e === "null_" ? this._decodeNull(t2, r2) : e === "bool" ? this._decodeBool(t2, r2) : e === "objDesc" ? this._decodeStr(t2, e, r2) : e === "int" || e === "enum" ? this._decodeInt(t2, n3.args && n3.args[0], r2) : n3.use !== null ? this._getUse(n3.use, t2._reporterState.obj)._decode(t2, r2) : t2.error("unknown tag: " + e);
  };
  f8.prototype._getUse = function(e, t2) {
    let r2 = this._baseState;
    return r2.useDecoder = this._use(e, t2), d14(r2.useDecoder._baseState.parent === null), r2.useDecoder = r2.useDecoder._baseState.children[0], r2.implicit !== r2.useDecoder._baseState.implicit && (r2.useDecoder = r2.useDecoder.clone(), r2.useDecoder._baseState.implicit = r2.implicit), r2.useDecoder;
  };
  f8.prototype._decodeChoice = function(e, t2) {
    let r2 = this._baseState, n3 = null, i = false;
    return Object.keys(r2.choice).some(function(s10) {
      let c13 = e.save(), l22 = r2.choice[s10];
      try {
        let u12 = l22._decode(e, t2);
        if (e.isError(u12))
          return false;
        n3 = {
          type: s10,
          value: u12
        }, i = true;
      } catch {
        return e.restore(c13), false;
      }
      return true;
    }, this), i ? n3 : e.error("Choice not matched");
  };
  f8.prototype._createEncoderBuffer = function(e) {
    return new Te(e, this.reporter);
  };
  f8.prototype._encode = function(e, t2, r2) {
    let n3 = this._baseState;
    if (n3.default !== null && n3.default === e)
      return;
    let i = this._encodeValue(e, t2, r2);
    if (i !== void 0 && !this._skipDefault(i, t2, r2))
      return i;
  };
  f8.prototype._encodeValue = function(e, t2, r2) {
    let n3 = this._baseState;
    if (n3.parent === null)
      return n3.children[0]._encode(e, t2 || new Ne());
    let i = null;
    if (this.reporter = t2, n3.optional && e === void 0)
      if (n3.default !== null)
        e = n3.default;
      else
        return;
    let s10 = null, c13 = false;
    if (n3.any)
      i = this._createEncoderBuffer(e);
    else if (n3.choice)
      i = this._encodeChoice(e, t2);
    else if (n3.contains)
      s10 = this._getUse(n3.contains, r2)._encode(e, t2), c13 = true;
    else if (n3.children)
      s10 = n3.children.map(function(l22) {
        if (l22._baseState.tag === "null_")
          return l22._encode(null, t2, e);
        if (l22._baseState.key === null)
          return t2.error("Child should have a key");
        let u12 = t2.enterKey(l22._baseState.key);
        if (typeof e != "object")
          return t2.error("Child expected, but input is not object");
        let a7 = l22._encode(e[l22._baseState.key], t2, e);
        return t2.leaveKey(u12), a7;
      }, this).filter(function(l22) {
        return l22;
      }), s10 = this._createEncoderBuffer(s10);
    else if (n3.tag === "seqof" || n3.tag === "setof") {
      if (!(n3.args && n3.args.length === 1))
        return t2.error("Too many args for : " + n3.tag);
      if (!Array.isArray(e))
        return t2.error("seqof/setof, but data is not Array");
      let l22 = this.clone();
      l22._baseState.implicit = null, s10 = this._createEncoderBuffer(e.map(function(u12) {
        let a7 = this._baseState;
        return this._getUse(a7.args[0], e)._encode(u12, t2);
      }, l22));
    } else
      n3.use !== null ? i = this._getUse(n3.use, r2)._encode(e, t2) : (s10 = this._encodePrimitive(n3.tag, e), c13 = true);
    if (!n3.any && n3.choice === null) {
      let l110 = n3.implicit !== null ? n3.implicit : n3.tag, u12 = n3.implicit === null ? "universal" : "context";
      l110 === null ? n3.use === null && t2.error("Tag could be omitted only for .use()") : n3.use === null && (i = this._encodeComposite(l110, c13, u12, s10));
    }
    return n3.explicit !== null && (i = this._encodeComposite(n3.explicit, false, "context", i)), i;
  };
  f8.prototype._encodeChoice = function(e, t2) {
    let r2 = this._baseState, n3 = r2.choice[e.type];
    return n3 || d14(false, e.type + " not found in " + JSON.stringify(Object.keys(r2.choice))), n3._encode(e.value, t2);
  };
  f8.prototype._encodePrimitive = function(e, t2) {
    let r2 = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(t2, e);
    if (e === "objid" && r2.args)
      return this._encodeObjid(t2, r2.reverseArgs[0], r2.args[1]);
    if (e === "objid")
      return this._encodeObjid(t2, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(t2, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(t2, r2.args && r2.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(t2);
    if (e === "objDesc")
      return this._encodeStr(t2, e);
    throw new Error("Unsupported tag: " + e);
  };
  f8.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  f8.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var N1 = h9((x17) => {
  "use strict";
  function Q9(o6) {
    let e = {};
    return Object.keys(o6).forEach(function(t2) {
      (t2 | 0) == t2 && (t2 = t2 | 0);
      let r2 = o6[t2];
      e[r2] = t2;
    }), e;
  }
  x17.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  };
  x17.tagClassByName = Q9(x17.tagClass);
  x17.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  };
  x17.tagByName = Q9(x17.tag);
});
var I6 = h9((nt2, ee2) => {
  "use strict";
  var Pe4 = w, E15 = E6.Buffer, W2 = U2(), A14 = N1();
  function X5(o6) {
    this.enc = "der", this.name = o6.name, this.entity = o6, this.tree = new b15(), this.tree._init(o6.body);
  }
  ee2.exports = X5;
  X5.prototype.encode = function(e, t2) {
    return this.tree._encode(e, t2).join();
  };
  function b15(o6) {
    W2.call(this, "der", o6);
  }
  Pe4(b15, W2);
  b15.prototype._encodeComposite = function(e, t2, r2, n3) {
    let i = Ke2(e, t2, r2, this.reporter);
    if (n3.length < 128) {
      let l22 = E15.alloc(2);
      return l22[0] = i, l22[1] = n3.length, this._createEncoderBuffer([
        l22,
        n3
      ]);
    }
    let s10 = 1;
    for (let l110 = n3.length; l110 >= 256; l110 >>= 8)
      s10++;
    let c13 = E15.alloc(1 + 1 + s10);
    c13[0] = i, c13[1] = 128 | s10;
    for (let l22 = 1 + s10, u12 = n3.length; u12 > 0; l22--, u12 >>= 8)
      c13[l22] = u12 & 255;
    return this._createEncoderBuffer([
      c13,
      n3
    ]);
  };
  b15.prototype._encodeStr = function(e, t2) {
    if (t2 === "bitstr")
      return this._createEncoderBuffer([
        e.unused | 0,
        e.data
      ]);
    if (t2 === "bmpstr") {
      let r2 = E15.alloc(e.length * 2);
      for (let n3 = 0; n3 < e.length; n3++)
        r2.writeUInt16BE(e.charCodeAt(n3), n3 * 2);
      return this._createEncoderBuffer(r2);
    } else
      return t2 === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : t2 === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t2) ? this._createEncoderBuffer(e) : t2 === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + t2 + " unsupported");
  };
  b15.prototype._encodeObjid = function(e, t2, r2) {
    if (typeof e == "string") {
      if (!t2)
        return this.reporter.error("string objid given, but no values map found");
      if (!t2.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = t2[e].split(/[\s.]+/g);
      for (let c13 = 0; c13 < e.length; c13++)
        e[c13] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let c13 = 0; c13 < e.length; c13++)
        e[c13] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!r2) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let n3 = 0;
    for (let c22 = 0; c22 < e.length; c22++) {
      let l22 = e[c22];
      for (n3++; l22 >= 128; l22 >>= 7)
        n3++;
    }
    let i = E15.alloc(n3), s10 = i.length - 1;
    for (let c32 = e.length - 1; c32 >= 0; c32--) {
      let l110 = e[c32];
      for (i[s10--] = l110 & 127; (l110 >>= 7) > 0; )
        i[s10--] = 128 | l110 & 127;
    }
    return this._createEncoderBuffer(i);
  };
  function m20(o6) {
    return o6 < 10 ? "0" + o6 : o6;
  }
  b15.prototype._encodeTime = function(e, t2) {
    let r2, n3 = new Date(e);
    return t2 === "gentime" ? r2 = [
      m20(n3.getUTCFullYear()),
      m20(n3.getUTCMonth() + 1),
      m20(n3.getUTCDate()),
      m20(n3.getUTCHours()),
      m20(n3.getUTCMinutes()),
      m20(n3.getUTCSeconds()),
      "Z"
    ].join("") : t2 === "utctime" ? r2 = [
      m20(n3.getUTCFullYear() % 100),
      m20(n3.getUTCMonth() + 1),
      m20(n3.getUTCDate()),
      m20(n3.getUTCHours()),
      m20(n3.getUTCMinutes()),
      m20(n3.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + t2 + " time is not supported yet"), this._encodeStr(r2, "octstr");
  };
  b15.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  b15.prototype._encodeInt = function(e, t2) {
    if (typeof e == "string") {
      if (!t2)
        return this.reporter.error("String int or enum given, but no values map");
      if (!t2.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = t2[e];
    }
    if (typeof e != "number" && !E15.isBuffer(e)) {
      let i = e.toArray();
      !e.sign && i[0] & 128 && i.unshift(0), e = E15.from(i);
    }
    if (E15.isBuffer(e)) {
      let i12 = e.length;
      e.length === 0 && i12++;
      let s10 = E15.alloc(i12);
      return e.copy(s10), e.length === 0 && (s10[0] = 0), this._createEncoderBuffer(s10);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([
        0,
        e
      ]);
    let r2 = 1;
    for (let i22 = e; i22 >= 256; i22 >>= 8)
      r2++;
    let n3 = new Array(r2);
    for (let i32 = n3.length - 1; i32 >= 0; i32--)
      n3[i32] = e & 255, e >>= 8;
    return n3[0] & 128 && n3.unshift(0), this._createEncoderBuffer(E15.from(n3));
  };
  b15.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  b15.prototype._use = function(e, t2) {
    return typeof e == "function" && (e = e(t2)), e._getEncoder("der").tree;
  };
  b15.prototype._skipDefault = function(e, t2, r2) {
    let n3 = this._baseState, i;
    if (n3.default === null)
      return false;
    let s10 = e.join();
    if (n3.defaultBuffer === void 0 && (n3.defaultBuffer = this._encodeValue(n3.default, t2, r2).join()), s10.length !== n3.defaultBuffer.length)
      return false;
    for (i = 0; i < s10.length; i++)
      if (s10[i] !== n3.defaultBuffer[i])
        return false;
    return true;
  };
  function Ke2(o6, e, t2, r2) {
    let n3;
    if (o6 === "seqof" ? o6 = "seq" : o6 === "setof" && (o6 = "set"), A14.tagByName.hasOwnProperty(o6))
      n3 = A14.tagByName[o6];
    else if (typeof o6 == "number" && (o6 | 0) === o6)
      n3 = o6;
    else
      return r2.error("Unknown tag: " + o6);
    return n3 >= 31 ? r2.error("Multi-octet tag encoding unsupported") : (e || (n3 |= 32), n3 |= A14.tagClassByName[t2 || "universal"] << 6, n3);
  }
});
var re1 = h9((ot2, te2) => {
  "use strict";
  var $e2 = w, R13 = I6();
  function P13(o6) {
    R13.call(this, o6), this.enc = "pem";
  }
  $e2(P13, R13);
  te2.exports = P13;
  P13.prototype.encode = function(e, t2) {
    let n3 = R13.prototype.encode.call(this, e).toString("base64"), i = [
      "-----BEGIN " + t2.label + "-----"
    ];
    for (let s10 = 0; s10 < n3.length; s10 += 64)
      i.push(n3.slice(s10, s10 + 64));
    return i.push("-----END " + t2.label + "-----"), i.join(`
`);
  };
});
var K7 = h9((oe3) => {
  "use strict";
  var ne2 = oe3;
  ne2.der = I6();
  ne2.pem = re1();
});
var M5 = h9((st2, fe4) => {
  "use strict";
  var Me = w, Fe3 = ki, ie3 = w14().DecoderBuffer, ce4 = U2(), se3 = N1();
  function le3(o6) {
    this.enc = "der", this.name = o6.name, this.entity = o6, this.tree = new _11(), this.tree._init(o6.body);
  }
  fe4.exports = le3;
  le3.prototype.decode = function(e, t2) {
    return ie3.isDecoderBuffer(e) || (e = new ie3(e, t2)), this.tree._decode(e, t2);
  };
  function _11(o6) {
    ce4.call(this, "der", o6);
  }
  Me(_11, ce4);
  _11.prototype._peekTag = function(e, t2, r2) {
    if (e.isEmpty())
      return false;
    let n3 = e.save(), i = $17(e, 'Failed to peek tag: "' + t2 + '"');
    return e.isError(i) ? i : (e.restore(n3), i.tag === t2 || i.tagStr === t2 || i.tagStr + "of" === t2 || r2);
  };
  _11.prototype._decodeTag = function(e, t2, r2) {
    let n3 = $17(e, 'Failed to decode tag of "' + t2 + '"');
    if (e.isError(n3))
      return n3;
    let i = ue4(e, n3.primitive, 'Failed to get length of "' + t2 + '"');
    if (e.isError(i))
      return i;
    if (!r2 && n3.tag !== t2 && n3.tagStr !== t2 && n3.tagStr + "of" !== t2)
      return e.error('Failed to match tag: "' + t2 + '"');
    if (n3.primitive || i !== null)
      return e.skip(i, 'Failed to match body of: "' + t2 + '"');
    let s10 = e.save(), c13 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(c13) ? c13 : (i = e.offset - s10.offset, e.restore(s10), e.skip(i, 'Failed to match body of: "' + t2 + '"'));
  };
  _11.prototype._skipUntilEnd = function(e, t2) {
    for (; ; ) {
      let r2 = $17(e, t2);
      if (e.isError(r2))
        return r2;
      let n3 = ue4(e, r2.primitive, t2);
      if (e.isError(n3))
        return n3;
      let i;
      if (r2.primitive || n3 !== null ? i = e.skip(n3) : i = this._skipUntilEnd(e, t2), e.isError(i))
        return i;
      if (r2.tagStr === "end")
        break;
    }
  };
  _11.prototype._decodeList = function(e, t2, r2, n3) {
    let i = [];
    for (; !e.isEmpty(); ) {
      let s10 = this._peekTag(e, "end");
      if (e.isError(s10))
        return s10;
      let c13 = r2.decode(e, "der", n3);
      if (e.isError(c13) && s10)
        break;
      i.push(c13);
    }
    return i;
  };
  _11.prototype._decodeStr = function(e, t2) {
    if (t2 === "bitstr") {
      let r2 = e.readUInt8();
      return e.isError(r2) ? r2 : {
        unused: r2,
        data: e.raw()
      };
    } else if (t2 === "bmpstr") {
      let r12 = e.raw();
      if (r12.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let n3 = "";
      for (let i = 0; i < r12.length / 2; i++)
        n3 += String.fromCharCode(r12.readUInt16BE(i * 2));
      return n3;
    } else if (t2 === "numstr") {
      let r2 = e.raw().toString("ascii");
      return this._isNumstr(r2) ? r2 : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (t2 === "octstr")
        return e.raw();
      if (t2 === "objDesc")
        return e.raw();
      if (t2 === "printstr") {
        let r3 = e.raw().toString("ascii");
        return this._isPrintstr(r3) ? r3 : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(t2) ? e.raw().toString() : e.error("Decoding of string type: " + t2 + " unsupported");
    }
  };
  _11.prototype._decodeObjid = function(e, t2, r2) {
    let n3, i = [], s10 = 0, c13 = 0;
    for (; !e.isEmpty(); )
      c13 = e.readUInt8(), s10 <<= 7, s10 |= c13 & 127, (c13 & 128) === 0 && (i.push(s10), s10 = 0);
    c13 & 128 && i.push(s10);
    let l22 = i[0] / 40 | 0, u12 = i[0] % 40;
    if (r2 ? n3 = i : n3 = [
      l22,
      u12
    ].concat(i.slice(1)), t2) {
      let a7 = t2[n3.join(" ")];
      a7 === void 0 && (a7 = t2[n3.join(".")]), a7 !== void 0 && (n3 = a7);
    }
    return n3;
  };
  _11.prototype._decodeTime = function(e, t2) {
    let r2 = e.raw().toString(), n3, i, s10, c13, l22, u12;
    if (t2 === "gentime")
      n3 = r2.slice(0, 4) | 0, i = r2.slice(4, 6) | 0, s10 = r2.slice(6, 8) | 0, c13 = r2.slice(8, 10) | 0, l22 = r2.slice(10, 12) | 0, u12 = r2.slice(12, 14) | 0;
    else if (t2 === "utctime")
      n3 = r2.slice(0, 2) | 0, i = r2.slice(2, 4) | 0, s10 = r2.slice(4, 6) | 0, c13 = r2.slice(6, 8) | 0, l22 = r2.slice(8, 10) | 0, u12 = r2.slice(10, 12) | 0, n3 < 70 ? n3 = 2e3 + n3 : n3 = 1900 + n3;
    else
      return e.error("Decoding " + t2 + " time is not supported yet");
    return Date.UTC(n3, i - 1, s10, c13, l22, u12, 0);
  };
  _11.prototype._decodeNull = function() {
    return null;
  };
  _11.prototype._decodeBool = function(e) {
    let t2 = e.readUInt8();
    return e.isError(t2) ? t2 : t2 !== 0;
  };
  _11.prototype._decodeInt = function(e, t2) {
    let r2 = e.raw(), n3 = new Fe3(r2);
    return t2 && (n3 = t2[n3.toString(10)] || n3), n3;
  };
  _11.prototype._use = function(e, t2) {
    return typeof e == "function" && (e = e(t2)), e._getDecoder("der").tree;
  };
  function $17(o6, e) {
    let t2 = o6.readUInt8(e);
    if (o6.isError(t2))
      return t2;
    let r2 = se3.tagClass[t2 >> 6], n3 = (t2 & 32) === 0;
    if ((t2 & 31) === 31) {
      let s10 = t2;
      for (t2 = 0; (s10 & 128) === 128; ) {
        if (s10 = o6.readUInt8(e), o6.isError(s10))
          return s10;
        t2 <<= 7, t2 |= s10 & 127;
      }
    } else
      t2 &= 31;
    let i = se3.tag[t2];
    return {
      cls: r2,
      primitive: n3,
      tag: t2,
      tagStr: i
    };
  }
  function ue4(o6, e, t2) {
    let r2 = o6.readUInt8(t2);
    if (o6.isError(r2))
      return r2;
    if (!e && r2 === 128)
      return null;
    if ((r2 & 128) === 0)
      return r2;
    let n3 = r2 & 127;
    if (n3 > 4)
      return o6.error("length octect is too long");
    r2 = 0;
    for (let i = 0; i < n3; i++) {
      r2 <<= 8;
      let s10 = o6.readUInt8(t2);
      if (o6.isError(s10))
        return s10;
      r2 |= s10;
    }
    return r2;
  }
});
var de = h9((ct3, ae3) => {
  "use strict";
  var Ge2 = w, Le5 = E6.Buffer, F12 = M5();
  function G11(o6) {
    F12.call(this, o6), this.enc = "pem";
  }
  Ge2(G11, F12);
  ae3.exports = G11;
  G11.prototype.decode = function(e, t2) {
    let r2 = e.toString().split(/[\r\n]+/g), n3 = t2.label.toUpperCase(), i = /^-----(BEGIN|END) ([^-]+)-----$/, s10 = -1, c13 = -1;
    for (let a7 = 0; a7 < r2.length; a7++) {
      let q15 = r2[a7].match(i);
      if (q15 !== null && q15[2] === n3)
        if (s10 === -1) {
          if (q15[1] !== "BEGIN")
            break;
          s10 = a7;
        } else {
          if (q15[1] !== "END")
            break;
          c13 = a7;
          break;
        }
    }
    if (s10 === -1 || c13 === -1)
      throw new Error("PEM section not found for: " + n3);
    let l22 = r2.slice(s10 + 1, c13).join("");
    l22.replace(/[^a-z0-9+/=]+/gi, "");
    let u12 = Le5.from(l22, "base64");
    return F12.prototype.decode.call(this, u12, t2);
  };
});
var L7 = h9((pe2) => {
  "use strict";
  var he3 = pe2;
  he3.der = M5();
  he3.pem = de();
});
var ye1 = h9((_e2) => {
  "use strict";
  var ze3 = K7(), Je = L7(), Ve3 = w, Ze2 = _e2;
  Ze2.define = function(e, t2) {
    return new D12(e, t2);
  };
  function D12(o6, e) {
    this.name = o6, this.body = e, this.decoders = {}, this.encoders = {};
  }
  D12.prototype._createNamed = function(e) {
    let t2 = this.name;
    function r2(n3) {
      this._initNamed(n3, t2);
    }
    return Ve3(r2, e), r2.prototype._initNamed = function(i, s10) {
      e.call(this, i, s10);
    }, new r2(this);
  };
  D12.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(Je[e])), this.decoders[e];
  };
  D12.prototype.decode = function(e, t2, r2) {
    return this._getDecoder(t2).decode(e, r2);
  };
  D12.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(ze3[e])), this.encoders[e];
  };
  D12.prototype.encode = function(e, t2, r2) {
    return this._getEncoder(t2).encode(e, r2);
  };
});
var me = h9((ge2) => {
  "use strict";
  var T12 = ge2;
  T12.Reporter = k6().Reporter;
  T12.DecoderBuffer = w14().DecoderBuffer;
  T12.EncoderBuffer = w14().EncoderBuffer;
  T12.Node = U2();
});
var xe2 = h9((Ee2) => {
  "use strict";
  var be3 = Ee2;
  be3._reverse = function(e) {
    let t2 = {};
    return Object.keys(e).forEach(function(r2) {
      (r2 | 0) == r2 && (r2 = r2 | 0);
      let n3 = e[r2];
      t2[n3] = r2;
    }), t2;
  };
  be3.der = N1();
});
var z4 = h9((Se2) => {
  "use strict";
  var v19 = Se2;
  v19.bignum = ki;
  v19.define = ye1().define;
  v19.base = me();
  v19.constants = xe2();
  v19.decoders = L7();
  v19.encoders = K7();
});
var je = V2(z4());
var He1 = V2(z4());
var { default: Ye1, ...Qe1 } = He1;
var ht2 = je.default ?? Ye1 ?? Qe1;
var Y4 = Object.create;
var j4 = Object.defineProperty;
var _5 = Object.getOwnPropertyDescriptor;
var $8 = Object.getOwnPropertyNames;
var U3 = Object.getPrototypeOf;
var F3 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (i, s10) => (typeof require != "undefined" ? require : i)[s10]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var v11 = (e, i) => () => (i || e((i = {
  exports: {}
}).exports, i), i.exports);
var z5 = (e, i, s10, n3) => {
  if (i && typeof i == "object" || typeof i == "function")
    for (let t2 of $8(i))
      !F3.call(e, t2) && t2 !== s10 && j4(e, t2, {
        get: () => i[t2],
        enumerable: !(n3 = _5(i, t2)) || n3.enumerable
      });
  return e;
};
var g12 = (e, i, s10) => (s10 = e != null ? Y4(U3(e)) : {}, z5(i || !e || !e.__esModule ? j4(s10, "default", {
  value: e,
  enumerable: true
}) : s10, e));
var I7 = v11((Ke2, A14) => {
  "use strict";
  var o6 = ht2, E15 = o6.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), G11 = o6.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), k15 = o6.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), L18 = o6.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(k15), this.key("subjectPublicKey").bitstr());
  }), X5 = o6.define("RelativeDistinguishedName", function() {
    this.setof(G11);
  }), H9 = o6.define("RDNSequence", function() {
    this.seqof(X5);
  }), q15 = o6.define("Name", function() {
    this.choice({
      rdnSequence: this.use(H9)
    });
  }), J14 = o6.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(E15), this.key("notAfter").use(E15));
  }), M14 = o6.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), O9 = o6.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(k15), this.key("issuer").use(q15), this.key("validity").use(J14), this.key("subject").use(q15), this.key("subjectPublicKeyInfo").use(L18), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(M14).optional());
  }), Q9 = o6.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(O9), this.key("signatureAlgorithm").use(k15), this.key("signatureValue").bitstr());
  });
  A14.exports = Q9;
});
var R4 = v11((y16) => {
  "use strict";
  var c13 = ht2;
  y16.certificate = I7();
  var W2 = c13.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  y16.RSAPrivateKey = W2;
  var Z2 = c13.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  y16.RSAPublicKey = Z2;
  var ee2 = c13.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(S14), this.key("subjectPublicKey").bitstr());
  });
  y16.PublicKey = ee2;
  var S14 = c13.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), te2 = c13.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(S14), this.key("subjectPrivateKey").octstr());
  });
  y16.PrivateKey = te2;
  var ie3 = c13.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  y16.EncryptedPrivateKey = ie3;
  var re4 = c13.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  y16.DSAPrivateKey = re4;
  y16.DSAparam = c13.define("DSAparam", function() {
    this.int();
  });
  var se3 = c13.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ae3), this.key("publicKey").optional().explicit(1).bitstr());
  });
  y16.ECPrivateKey = se3;
  var ae3 = c13.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  });
  y16.signature = c13.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var C3 = v11((je2, ne2) => {
  ne2.exports = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
  };
});
var T5 = v11((ge2, x17) => {
  var oe3 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, ce4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, ye4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, ue4 = j3, he3 = ut1, f8 = L1;
  x17.exports = function(e, i) {
    var s10 = e.toString(), n3 = s10.match(oe3), t2;
    if (n3) {
      var r2 = "aes" + n3[1], p7 = f8.from(n3[2], "hex"), b15 = f8.from(n3[3].replace(/[\r\n]/g, ""), "base64"), l22 = ue4(i, p7.slice(0, 8), parseInt(n3[1], 10)).key, d14 = [], P13 = he3.createDecipheriv(r2, l22, p7);
      d14.push(P13.update(b15)), d14.push(P13.final()), t2 = f8.concat(d14);
    } else {
      var u12 = s10.match(ye4);
      t2 = f8.from(u12[2].replace(/[\r\n]/g, ""), "base64");
    }
    var V8 = s10.match(ce4)[1];
    return {
      tag: V8,
      data: t2
    };
  };
});
var K8 = v11((Ee2, w24) => {
  var a7 = R4(), de2 = C3(), ve2 = T5(), pe2 = ut1, le3 = gr1, m20 = L1;
  w24.exports = D12;
  function D12(e) {
    var i;
    typeof e == "object" && !m20.isBuffer(e) && (i = e.passphrase, e = e.key), typeof e == "string" && (e = m20.from(e));
    var s10 = ve2(e, i), n3 = s10.tag, t2 = s10.data, u12, r2;
    switch (n3) {
      case "CERTIFICATE":
        r2 = a7.certificate.decode(t2, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (r2 || (r2 = a7.PublicKey.decode(t2, "der")), u12 = r2.algorithm.algorithm.join("."), u12) {
          case "1.2.840.113549.1.1.1":
            return a7.RSAPublicKey.decode(r2.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return r2.subjectPrivateKey = r2.subjectPublicKey, {
              type: "ec",
              data: r2
            };
          case "1.2.840.10040.4.1":
            return r2.algorithm.params.pub_key = a7.DSAparam.decode(r2.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: r2.algorithm.params
            };
          default:
            throw new Error("unknown key id " + u12);
        }
      case "ENCRYPTED PRIVATE KEY":
        t2 = a7.EncryptedPrivateKey.decode(t2, "der"), t2 = fe4(t2, i);
      case "PRIVATE KEY":
        switch (r2 = a7.PrivateKey.decode(t2, "der"), u12 = r2.algorithm.algorithm.join("."), u12) {
          case "1.2.840.113549.1.1.1":
            return a7.RSAPrivateKey.decode(r2.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: r2.algorithm.curve,
              privateKey: a7.ECPrivateKey.decode(r2.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return r2.algorithm.params.priv_key = a7.DSAparam.decode(r2.subjectPrivateKey, "der"), {
              type: "dsa",
              params: r2.algorithm.params
            };
          default:
            throw new Error("unknown key id " + u12);
        }
      case "RSA PUBLIC KEY":
        return a7.RSAPublicKey.decode(t2, "der");
      case "RSA PRIVATE KEY":
        return a7.RSAPrivateKey.decode(t2, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: a7.DSAPrivateKey.decode(t2, "der")
        };
      case "EC PRIVATE KEY":
        return t2 = a7.ECPrivateKey.decode(t2, "der"), {
          curve: t2.parameters.value,
          privateKey: t2.privateKey
        };
      default:
        throw new Error("unknown key type " + n3);
    }
  }
  D12.signature = a7.signature;
  function fe4(e, i) {
    var s10 = e.algorithm.decrypt.kde.kdeparams.salt, n3 = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), t2 = de2[e.algorithm.decrypt.cipher.algo.join(".")], u12 = e.algorithm.decrypt.cipher.iv, r2 = e.subjectPrivateKey, p7 = parseInt(t2.split("-")[1], 10) / 8, b15 = le3.pbkdf2Sync(i, s10, n3, p7, "sha1"), l22 = pe2.createDecipheriv(t2, b15, u12), d14 = [];
    return d14.push(l22.update(r2)), d14.push(l22.final()), m20.concat(d14);
  }
});
var B8 = g12(K8());
var N2 = g12(K8());
var { signature: qe3 } = N2;
var { default: be1, ...ke2 } = N2;
var Ae1 = B8.default ?? be1 ?? ke2;
var C4 = Object.create;
var l13 = Object.defineProperty;
var E7 = Object.getOwnPropertyDescriptor;
var H2 = Object.getOwnPropertyNames;
var R5 = Object.getPrototypeOf;
var b6 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (r2, a7) => (typeof require != "undefined" ? require : r2)[a7]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var v12 = (t2, r2) => () => (r2 || t2((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var z6 = (t2, r2, a7, h16) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let e of H2(r2))
      !b6.call(t2, e) && e !== a7 && l13(t2, e, {
        get: () => r2[e],
        enumerable: !(h16 = E7(r2, e)) || h16.enumerable
      });
  return t2;
};
var m11 = (t2, r2, a7) => (a7 = t2 != null ? C4(R5(t2)) : {}, z6(r2 || !t2 || !t2.__esModule ? l13(a7, "default", {
  value: t2,
  enumerable: true
}) : a7, t2));
var x11 = v12((F12, w110) => {
  "use strict";
  var L18 = w, i = L1, q15 = M4, O9 = i.alloc(128), n3 = 64;
  function d14(t2, r2) {
    q15.call(this, "digest"), typeof r2 == "string" && (r2 = i.from(r2)), this._alg = t2, this._key = r2, r2.length > n3 ? r2 = t2(r2) : r2.length < n3 && (r2 = i.concat([
      r2,
      O9
    ], n3));
    for (var a7 = this._ipad = i.allocUnsafe(n3), h16 = this._opad = i.allocUnsafe(n3), e = 0; e < n3; e++)
      a7[e] = r2[e] ^ 54, h16[e] = r2[e] ^ 92;
    this._hash = [
      a7
    ];
  }
  L18(d14, q15);
  d14.prototype._update = function(t2) {
    this._hash.push(t2);
  };
  d14.prototype._final = function() {
    var t2 = this._alg(i.concat(this._hash));
    return this._alg(i.concat([
      this._opad,
      t2
    ]));
  };
  w110.exports = d14;
});
var _6 = v12((G11, B18) => {
  "use strict";
  var S14 = w, Z2 = x11(), g17 = M4, f8 = L1, D12 = h5, p7 = X2, c13 = Ot, I13 = f8.alloc(128);
  function u12(t2, r2) {
    g17.call(this, "digest"), typeof r2 == "string" && (r2 = f8.from(r2));
    var a7 = t2 === "sha512" || t2 === "sha384" ? 128 : 64;
    if (this._alg = t2, this._key = r2, r2.length > a7) {
      var h16 = t2 === "rmd160" ? new p7() : c13(t2);
      r2 = h16.update(r2).digest();
    } else
      r2.length < a7 && (r2 = f8.concat([
        r2,
        I13
      ], a7));
    for (var e = this._ipad = f8.allocUnsafe(a7), $17 = this._opad = f8.allocUnsafe(a7), o6 = 0; o6 < a7; o6++)
      e[o6] = r2[o6] ^ 54, $17[o6] = r2[o6] ^ 92;
    this._hash = t2 === "rmd160" ? new p7() : c13(t2), this._hash.update(e);
  }
  S14(u12, g17);
  u12.prototype._update = function(t2) {
    this._hash.update(t2);
  };
  u12.prototype._final = function() {
    var t2 = this._hash.digest(), r2 = this._alg === "rmd160" ? new p7() : c13(this._alg);
    return r2.update(this._opad).update(t2).digest();
  };
  B18.exports = function(r2, a7) {
    return r2 = r2.toLowerCase(), r2 === "rmd160" || r2 === "ripemd160" ? new u12("rmd160", a7) : r2 === "md5" ? new Z2(D12, a7) : new u12(r2, a7);
  };
});
var U4 = m11(_6());
var M6 = m11(_6());
var { default: P6, ...j5 } = M6;
var J6 = U4.default ?? P6 ?? j5;
var __global$3 = globalThis || (typeof window !== "undefined" ? window : self);
var p14 = Object.create;
var l14 = Object.defineProperty;
var c9 = Object.getOwnPropertyDescriptor;
var d10 = Object.getOwnPropertyNames;
var y10 = Object.getPrototypeOf;
var b7 = Object.prototype.hasOwnProperty;
((r2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r2, {
  get: (o6, e) => (typeof require != "undefined" ? require : o6)[e]
}) : r2)(function(r2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var w15 = (r2, o6) => () => (o6 || r2((o6 = {
  exports: {}
}).exports, o6), o6.exports);
var x12 = (r2, o6, e, t2) => {
  if (o6 && typeof o6 == "object" || typeof o6 == "function")
    for (let n3 of d10(o6))
      !b7.call(r2, n3) && n3 !== e && l14(r2, n3, {
        get: () => o6[n3],
        enumerable: !(t2 = c9(o6, n3)) || t2.enumerable
      });
  return r2;
};
var i8 = (r2, o6, e) => (e = r2 != null ? p14(y10(r2)) : {}, x12(o6 || !r2 || !r2.__esModule ? l14(e, "default", {
  value: r2,
  enumerable: true
}) : e, r2));
var u7 = w15((V8, s10) => {
  "use strict";
  var f8 = 65536, B18 = 4294967295;
  function g17() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var h16 = L1, a7 = __global$3.crypto || __global$3.msCrypto;
  a7 && a7.getRandomValues ? s10.exports = E15 : s10.exports = g17;
  function E15(r2, o6) {
    if (r2 > B18)
      throw new RangeError("requested too many random bytes");
    var e = h16.allocUnsafe(r2);
    if (r2 > 0)
      if (r2 > f8)
        for (var t2 = 0; t2 < r2; t2 += f8)
          a7.getRandomValues(e.slice(t2, t2 + f8));
      else
        a7.getRandomValues(e);
    return typeof o6 == "function" ? process1.nextTick(function() {
      o6(null, e);
    }) : e;
  }
});
var m12 = i8(u7());
var R6 = i8(u7());
var { default: $9, ...T6 } = R6;
var q7 = m12.default ?? $9 ?? T6;
var ci1 = Object.create;
var ai1 = Object.defineProperty;
var wi1 = Object.getOwnPropertyDescriptor;
var yi1 = Object.getOwnPropertyNames;
var xi2 = Object.getPrototypeOf;
var _i1 = Object.prototype.hasOwnProperty;
((_11) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(_11, {
  get: (et2, v19) => (typeof require != "undefined" ? require : et2)[v19]
}) : _11)(function(_11) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + _11 + '" is not supported');
});
var Ai1 = (_11, et2) => () => (et2 || _11((et2 = {
  exports: {}
}).exports, et2), et2.exports);
var Bi1 = (_11, et2, v19, nt2) => {
  if (et2 && typeof et2 == "object" || typeof et2 == "function")
    for (let l22 of yi1(et2))
      !_i1.call(_11, l22) && l22 !== v19 && ai1(_11, l22, {
        get: () => et2[l22],
        enumerable: !(nt2 = wi1(et2, l22)) || nt2.enumerable
      });
  return _11;
};
var li1 = (_11, et2, v19) => (v19 = _11 != null ? ci1(xi2(_11)) : {}, Bi1(et2 || !_11 || !_11.__esModule ? ai1(v19, "default", {
  value: _11,
  enumerable: true
}) : v19, _11));
var It = Ai1((ui, Tt) => {
  (function(_11, et2) {
    "use strict";
    function v19(s10, t2) {
      if (!s10)
        throw new Error(t2 || "Assertion failed");
    }
    function nt2(s10, t2) {
      s10.super_ = t2;
      var r2 = function() {
      };
      r2.prototype = t2.prototype, s10.prototype = new r2(), s10.prototype.constructor = s10;
    }
    function l22(s10, t2, r2) {
      if (l22.isBN(s10))
        return s10;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, s10 !== null && ((t2 === "le" || t2 === "be") && (r2 = t2, t2 = 10), this._init(s10 || 0, t2 || 10, r2 || "be"));
    }
    typeof _11 == "object" ? _11.exports = l22 : et2.BN = l22, l22.BN = l22, l22.wordSize = 26;
    var at2;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? at2 = window.Buffer : at2 = export_default.Buffer;
    } catch {
    }
    l22.isBN = function(t2) {
      return t2 instanceof l22 ? true : t2 !== null && typeof t2 == "object" && t2.constructor.wordSize === l22.wordSize && Array.isArray(t2.words);
    }, l22.max = function(t2, r2) {
      return t2.cmp(r2) > 0 ? t2 : r2;
    }, l22.min = function(t2, r2) {
      return t2.cmp(r2) < 0 ? t2 : r2;
    }, l22.prototype._init = function(t2, r2, e) {
      if (typeof t2 == "number")
        return this._initNumber(t2, r2, e);
      if (typeof t2 == "object")
        return this._initArray(t2, r2, e);
      r2 === "hex" && (r2 = 16), v19(r2 === (r2 | 0) && r2 >= 2 && r2 <= 36), t2 = t2.toString().replace(/\s+/g, "");
      var h16 = 0;
      t2[0] === "-" && (h16++, this.negative = 1), h16 < t2.length && (r2 === 16 ? this._parseHex(t2, h16, e) : (this._parseBase(t2, r2, h16), e === "le" && this._initArray(this.toArray(), r2, e)));
    }, l22.prototype._initNumber = function(t2, r2, e) {
      t2 < 0 && (this.negative = 1, t2 = -t2), t2 < 67108864 ? (this.words = [
        t2 & 67108863
      ], this.length = 1) : t2 < 4503599627370496 ? (this.words = [
        t2 & 67108863,
        t2 / 67108864 & 67108863
      ], this.length = 2) : (v19(t2 < 9007199254740992), this.words = [
        t2 & 67108863,
        t2 / 67108864 & 67108863,
        1
      ], this.length = 3), e === "le" && this._initArray(this.toArray(), r2, e);
    }, l22.prototype._initArray = function(t2, r2, e) {
      if (v19(typeof t2.length == "number"), t2.length <= 0)
        return this.words = [
          0
        ], this.length = 1, this;
      this.length = Math.ceil(t2.length / 3), this.words = new Array(this.length);
      for (var h16 = 0; h16 < this.length; h16++)
        this.words[h16] = 0;
      var n3, a7, u12 = 0;
      if (e === "be")
        for (h16 = t2.length - 1, n3 = 0; h16 >= 0; h16 -= 3)
          a7 = t2[h16] | t2[h16 - 1] << 8 | t2[h16 - 2] << 16, this.words[n3] |= a7 << u12 & 67108863, this.words[n3 + 1] = a7 >>> 26 - u12 & 67108863, u12 += 24, u12 >= 26 && (u12 -= 26, n3++);
      else if (e === "le")
        for (h16 = 0, n3 = 0; h16 < t2.length; h16 += 3)
          a7 = t2[h16] | t2[h16 + 1] << 8 | t2[h16 + 2] << 16, this.words[n3] |= a7 << u12 & 67108863, this.words[n3 + 1] = a7 >>> 26 - u12 & 67108863, u12 += 24, u12 >= 26 && (u12 -= 26, n3++);
      return this._strip();
    };
    function zt2(s10, t2) {
      var r2 = s10.charCodeAt(t2);
      if (r2 >= 48 && r2 <= 57)
        return r2 - 48;
      if (r2 >= 65 && r2 <= 70)
        return r2 - 55;
      if (r2 >= 97 && r2 <= 102)
        return r2 - 87;
      v19(false, "Invalid character in " + s10);
    }
    function Et(s10, t2, r2) {
      var e = zt2(s10, r2);
      return r2 - 1 >= t2 && (e |= zt2(s10, r2 - 1) << 4), e;
    }
    l22.prototype._parseHex = function(t2, r2, e) {
      this.length = Math.ceil((t2.length - r2) / 6), this.words = new Array(this.length);
      for (var h16 = 0; h16 < this.length; h16++)
        this.words[h16] = 0;
      var n3 = 0, a7 = 0, u12;
      if (e === "be")
        for (h16 = t2.length - 1; h16 >= r2; h16 -= 2)
          u12 = Et(t2, r2, h16) << n3, this.words[a7] |= u12 & 67108863, n3 >= 18 ? (n3 -= 18, a7 += 1, this.words[a7] |= u12 >>> 26) : n3 += 8;
      else {
        var f8 = t2.length - r2;
        for (h16 = f8 % 2 === 0 ? r2 + 1 : r2; h16 < t2.length; h16 += 2)
          u12 = Et(t2, r2, h16) << n3, this.words[a7] |= u12 & 67108863, n3 >= 18 ? (n3 -= 18, a7 += 1, this.words[a7] |= u12 >>> 26) : n3 += 8;
      }
      this._strip();
    };
    function Ot2(s10, t2, r2, e) {
      for (var h16 = 0, n3 = 0, a7 = Math.min(s10.length, r2), u12 = t2; u12 < a7; u12++) {
        var f8 = s10.charCodeAt(u12) - 48;
        h16 *= e, f8 >= 49 ? n3 = f8 - 49 + 10 : f8 >= 17 ? n3 = f8 - 17 + 10 : n3 = f8, v19(f8 >= 0 && n3 < e, "Invalid character"), h16 += n3;
      }
      return h16;
    }
    l22.prototype._parseBase = function(t2, r2, e) {
      this.words = [
        0
      ], this.length = 1;
      for (var h16 = 0, n3 = 1; n3 <= 67108863; n3 *= r2)
        h16++;
      h16--, n3 = n3 / r2 | 0;
      for (var a7 = t2.length - e, u12 = a7 % h16, f8 = Math.min(a7, a7 - u12) + e, i = 0, o6 = e; o6 < f8; o6 += h16)
        i = Ot2(t2, o6, o6 + h16, r2), this.imuln(n3), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
      if (u12 !== 0) {
        var d14 = 1;
        for (i = Ot2(t2, o6, t2.length, r2), o6 = 0; o6 < u12; o6++)
          d14 *= r2;
        this.imuln(d14), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
      }
      this._strip();
    }, l22.prototype.copy = function(t2) {
      t2.words = new Array(this.length);
      for (var r2 = 0; r2 < this.length; r2++)
        t2.words[r2] = this.words[r2];
      t2.length = this.length, t2.negative = this.negative, t2.red = this.red;
    };
    function Kt2(s10, t2) {
      s10.words = t2.words, s10.length = t2.length, s10.negative = t2.negative, s10.red = t2.red;
    }
    if (l22.prototype._move = function(t2) {
      Kt2(t2, this);
    }, l22.prototype.clone = function() {
      var t2 = new l22(null);
      return this.copy(t2), t2;
    }, l22.prototype._expand = function(t2) {
      for (; this.length < t2; )
        this.words[this.length++] = 0;
      return this;
    }, l22.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, l22.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        l22.prototype[Symbol.for("nodejs.util.inspect.custom")] = ut4;
      } catch {
        l22.prototype.inspect = ut4;
      }
    else
      l22.prototype.inspect = ut4;
    function ut4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Ft = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], mi = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], pi2 = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    l22.prototype.toString = function(t2, r2) {
      t2 = t2 || 10, r2 = r2 | 0 || 1;
      var e;
      if (t2 === 16 || t2 === "hex") {
        e = "";
        for (var h16 = 0, n3 = 0, a7 = 0; a7 < this.length; a7++) {
          var u12 = this.words[a7], f8 = ((u12 << h16 | n3) & 16777215).toString(16);
          n3 = u12 >>> 24 - h16 & 16777215, h16 += 2, h16 >= 26 && (h16 -= 26, a7--), n3 !== 0 || a7 !== this.length - 1 ? e = Ft[6 - f8.length] + f8 + e : e = f8 + e;
        }
        for (n3 !== 0 && (e = n3.toString(16) + e); e.length % r2 !== 0; )
          e = "0" + e;
        return this.negative !== 0 && (e = "-" + e), e;
      }
      if (t2 === (t2 | 0) && t2 >= 2 && t2 <= 36) {
        var i = mi[t2], o6 = pi2[t2];
        e = "";
        var d14 = this.clone();
        for (d14.negative = 0; !d14.isZero(); ) {
          var m20 = d14.modrn(o6).toString(t2);
          d14 = d14.idivn(o6), d14.isZero() ? e = m20 + e : e = Ft[i - m20.length] + m20 + e;
        }
        for (this.isZero() && (e = "0" + e); e.length % r2 !== 0; )
          e = "0" + e;
        return this.negative !== 0 && (e = "-" + e), e;
      }
      v19(false, "Base should be between 2 and 36");
    }, l22.prototype.toNumber = function() {
      var t2 = this.words[0];
      return this.length === 2 ? t2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && v19(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t2 : t2;
    }, l22.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, at2 && (l22.prototype.toBuffer = function(t2, r2) {
      return this.toArrayLike(at2, t2, r2);
    }), l22.prototype.toArray = function(t2, r2) {
      return this.toArrayLike(Array, t2, r2);
    };
    var Mi2 = function(t2, r2) {
      return t2.allocUnsafe ? t2.allocUnsafe(r2) : new t2(r2);
    };
    l22.prototype.toArrayLike = function(t2, r2, e) {
      this._strip();
      var h16 = this.byteLength(), n3 = e || Math.max(1, h16);
      v19(h16 <= n3, "byte array longer than desired length"), v19(n3 > 0, "Requested array length <= 0");
      var a7 = Mi2(t2, n3), u12 = r2 === "le" ? "LE" : "BE";
      return this["_toArrayLike" + u12](a7, h16), a7;
    }, l22.prototype._toArrayLikeLE = function(t2, r2) {
      for (var e = 0, h16 = 0, n3 = 0, a7 = 0; n3 < this.length; n3++) {
        var u12 = this.words[n3] << a7 | h16;
        t2[e++] = u12 & 255, e < t2.length && (t2[e++] = u12 >> 8 & 255), e < t2.length && (t2[e++] = u12 >> 16 & 255), a7 === 6 ? (e < t2.length && (t2[e++] = u12 >> 24 & 255), h16 = 0, a7 = 0) : (h16 = u12 >>> 24, a7 += 2);
      }
      if (e < t2.length)
        for (t2[e++] = h16; e < t2.length; )
          t2[e++] = 0;
    }, l22.prototype._toArrayLikeBE = function(t2, r2) {
      for (var e = t2.length - 1, h16 = 0, n3 = 0, a7 = 0; n3 < this.length; n3++) {
        var u12 = this.words[n3] << a7 | h16;
        t2[e--] = u12 & 255, e >= 0 && (t2[e--] = u12 >> 8 & 255), e >= 0 && (t2[e--] = u12 >> 16 & 255), a7 === 6 ? (e >= 0 && (t2[e--] = u12 >> 24 & 255), h16 = 0, a7 = 0) : (h16 = u12 >>> 24, a7 += 2);
      }
      if (e >= 0)
        for (t2[e--] = h16; e >= 0; )
          t2[e--] = 0;
    }, Math.clz32 ? l22.prototype._countBits = function(t2) {
      return 32 - Math.clz32(t2);
    } : l22.prototype._countBits = function(t2) {
      var r2 = t2, e = 0;
      return r2 >= 4096 && (e += 13, r2 >>>= 13), r2 >= 64 && (e += 7, r2 >>>= 7), r2 >= 8 && (e += 4, r2 >>>= 4), r2 >= 2 && (e += 2, r2 >>>= 2), e + r2;
    }, l22.prototype._zeroBits = function(t2) {
      if (t2 === 0)
        return 26;
      var r2 = t2, e = 0;
      return (r2 & 8191) === 0 && (e += 13, r2 >>>= 13), (r2 & 127) === 0 && (e += 7, r2 >>>= 7), (r2 & 15) === 0 && (e += 4, r2 >>>= 4), (r2 & 3) === 0 && (e += 2, r2 >>>= 2), (r2 & 1) === 0 && e++, e;
    }, l22.prototype.bitLength = function() {
      var t2 = this.words[this.length - 1], r2 = this._countBits(t2);
      return (this.length - 1) * 26 + r2;
    };
    function gi2(s10) {
      for (var t2 = new Array(s10.bitLength()), r2 = 0; r2 < t2.length; r2++) {
        var e = r2 / 26 | 0, h16 = r2 % 26;
        t2[r2] = s10.words[e] >>> h16 & 1;
      }
      return t2;
    }
    l22.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var t2 = 0, r2 = 0; r2 < this.length; r2++) {
        var e = this._zeroBits(this.words[r2]);
        if (t2 += e, e !== 26)
          break;
      }
      return t2;
    }, l22.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, l22.prototype.toTwos = function(t2) {
      return this.negative !== 0 ? this.abs().inotn(t2).iaddn(1) : this.clone();
    }, l22.prototype.fromTwos = function(t2) {
      return this.testn(t2 - 1) ? this.notn(t2).iaddn(1).ineg() : this.clone();
    }, l22.prototype.isNeg = function() {
      return this.negative !== 0;
    }, l22.prototype.neg = function() {
      return this.clone().ineg();
    }, l22.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, l22.prototype.iuor = function(t2) {
      for (; this.length < t2.length; )
        this.words[this.length++] = 0;
      for (var r2 = 0; r2 < t2.length; r2++)
        this.words[r2] = this.words[r2] | t2.words[r2];
      return this._strip();
    }, l22.prototype.ior = function(t2) {
      return v19((this.negative | t2.negative) === 0), this.iuor(t2);
    }, l22.prototype.or = function(t2) {
      return this.length > t2.length ? this.clone().ior(t2) : t2.clone().ior(this);
    }, l22.prototype.uor = function(t2) {
      return this.length > t2.length ? this.clone().iuor(t2) : t2.clone().iuor(this);
    }, l22.prototype.iuand = function(t2) {
      var r2;
      this.length > t2.length ? r2 = t2 : r2 = this;
      for (var e = 0; e < r2.length; e++)
        this.words[e] = this.words[e] & t2.words[e];
      return this.length = r2.length, this._strip();
    }, l22.prototype.iand = function(t2) {
      return v19((this.negative | t2.negative) === 0), this.iuand(t2);
    }, l22.prototype.and = function(t2) {
      return this.length > t2.length ? this.clone().iand(t2) : t2.clone().iand(this);
    }, l22.prototype.uand = function(t2) {
      return this.length > t2.length ? this.clone().iuand(t2) : t2.clone().iuand(this);
    }, l22.prototype.iuxor = function(t2) {
      var r2, e;
      this.length > t2.length ? (r2 = this, e = t2) : (r2 = t2, e = this);
      for (var h16 = 0; h16 < e.length; h16++)
        this.words[h16] = r2.words[h16] ^ e.words[h16];
      if (this !== r2)
        for (; h16 < r2.length; h16++)
          this.words[h16] = r2.words[h16];
      return this.length = r2.length, this._strip();
    }, l22.prototype.ixor = function(t2) {
      return v19((this.negative | t2.negative) === 0), this.iuxor(t2);
    }, l22.prototype.xor = function(t2) {
      return this.length > t2.length ? this.clone().ixor(t2) : t2.clone().ixor(this);
    }, l22.prototype.uxor = function(t2) {
      return this.length > t2.length ? this.clone().iuxor(t2) : t2.clone().iuxor(this);
    }, l22.prototype.inotn = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = Math.ceil(t2 / 26) | 0, e = t2 % 26;
      this._expand(r2), e > 0 && r2--;
      for (var h16 = 0; h16 < r2; h16++)
        this.words[h16] = ~this.words[h16] & 67108863;
      return e > 0 && (this.words[h16] = ~this.words[h16] & 67108863 >> 26 - e), this._strip();
    }, l22.prototype.notn = function(t2) {
      return this.clone().inotn(t2);
    }, l22.prototype.setn = function(t2, r2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var e = t2 / 26 | 0, h16 = t2 % 26;
      return this._expand(e + 1), r2 ? this.words[e] = this.words[e] | 1 << h16 : this.words[e] = this.words[e] & ~(1 << h16), this._strip();
    }, l22.prototype.iadd = function(t2) {
      var r2;
      if (this.negative !== 0 && t2.negative === 0)
        return this.negative = 0, r2 = this.isub(t2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && t2.negative !== 0)
        return t2.negative = 0, r2 = this.isub(t2), t2.negative = 1, r2._normSign();
      var e, h16;
      this.length > t2.length ? (e = this, h16 = t2) : (e = t2, h16 = this);
      for (var n3 = 0, a7 = 0; a7 < h16.length; a7++)
        r2 = (e.words[a7] | 0) + (h16.words[a7] | 0) + n3, this.words[a7] = r2 & 67108863, n3 = r2 >>> 26;
      for (; n3 !== 0 && a7 < e.length; a7++)
        r2 = (e.words[a7] | 0) + n3, this.words[a7] = r2 & 67108863, n3 = r2 >>> 26;
      if (this.length = e.length, n3 !== 0)
        this.words[this.length] = n3, this.length++;
      else if (e !== this)
        for (; a7 < e.length; a7++)
          this.words[a7] = e.words[a7];
      return this;
    }, l22.prototype.add = function(t2) {
      var r2;
      return t2.negative !== 0 && this.negative === 0 ? (t2.negative = 0, r2 = this.sub(t2), t2.negative ^= 1, r2) : t2.negative === 0 && this.negative !== 0 ? (this.negative = 0, r2 = t2.sub(this), this.negative = 1, r2) : this.length > t2.length ? this.clone().iadd(t2) : t2.clone().iadd(this);
    }, l22.prototype.isub = function(t2) {
      if (t2.negative !== 0) {
        t2.negative = 0;
        var r2 = this.iadd(t2);
        return t2.negative = 1, r2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(t2), this.negative = 1, this._normSign();
      var e = this.cmp(t2);
      if (e === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var h16, n3;
      e > 0 ? (h16 = this, n3 = t2) : (h16 = t2, n3 = this);
      for (var a7 = 0, u12 = 0; u12 < n3.length; u12++)
        r2 = (h16.words[u12] | 0) - (n3.words[u12] | 0) + a7, a7 = r2 >> 26, this.words[u12] = r2 & 67108863;
      for (; a7 !== 0 && u12 < h16.length; u12++)
        r2 = (h16.words[u12] | 0) + a7, a7 = r2 >> 26, this.words[u12] = r2 & 67108863;
      if (a7 === 0 && u12 < h16.length && h16 !== this)
        for (; u12 < h16.length; u12++)
          this.words[u12] = h16.words[u12];
      return this.length = Math.max(this.length, u12), h16 !== this && (this.negative = 1), this._strip();
    }, l22.prototype.sub = function(t2) {
      return this.clone().isub(t2);
    };
    function Ht(s10, t2, r2) {
      r2.negative = t2.negative ^ s10.negative;
      var e = s10.length + t2.length | 0;
      r2.length = e, e = e - 1 | 0;
      var h16 = s10.words[0] | 0, n3 = t2.words[0] | 0, a7 = h16 * n3, u12 = a7 & 67108863, f8 = a7 / 67108864 | 0;
      r2.words[0] = u12;
      for (var i = 1; i < e; i++) {
        for (var o6 = f8 >>> 26, d14 = f8 & 67108863, m20 = Math.min(i, t2.length - 1), p7 = Math.max(0, i - s10.length + 1); p7 <= m20; p7++) {
          var M14 = i - p7 | 0;
          h16 = s10.words[M14] | 0, n3 = t2.words[p7] | 0, a7 = h16 * n3 + d14, o6 += a7 / 67108864 | 0, d14 = a7 & 67108863;
        }
        r2.words[i] = d14 | 0, f8 = o6 | 0;
      }
      return f8 !== 0 ? r2.words[i] = f8 | 0 : r2.length--, r2._strip();
    }
    var Pt2 = function(t2, r2, e) {
      var h16 = t2.words, n3 = r2.words, a7 = e.words, u12 = 0, f8, i, o6, d14 = h16[0] | 0, m20 = d14 & 8191, p7 = d14 >>> 13, M14 = h16[1] | 0, g17 = M14 & 8191, c13 = M14 >>> 13, ot2 = h16[2] | 0, w24 = ot2 & 8191, y16 = ot2 >>> 13, Jt2 = h16[3] | 0, b15 = Jt2 & 8191, A14 = Jt2 >>> 13, Wt = h16[4] | 0, B18 = Wt & 8191, S14 = Wt >>> 13, Gt = h16[5] | 0, k15 = Gt & 8191, q15 = Gt >>> 13, Qt = h16[6] | 0, R13 = Qt & 8191, L18 = Qt >>> 13, Vt = h16[7] | 0, Z2 = Vt & 8191, N6 = Vt >>> 13, Xt = h16[8] | 0, T12 = Xt & 8191, I13 = Xt >>> 13, Yt = h16[9] | 0, z15 = Yt & 8191, E15 = Yt >>> 13, jt = n3[0] | 0, O9 = jt & 8191, K14 = jt >>> 13, ti = n3[1] | 0, F12 = ti & 8191, H9 = ti >>> 13, ii = n3[2] | 0, P13 = ii & 8191, D12 = ii >>> 13, ri = n3[3] | 0, $17 = ri & 8191, U7 = ri >>> 13, ei = n3[4] | 0, C11 = ei & 8191, J14 = ei >>> 13, hi = n3[5] | 0, W2 = hi & 8191, G11 = hi >>> 13, fi = n3[6] | 0, Q9 = fi & 8191, V8 = fi >>> 13, ni2 = n3[7] | 0, X5 = ni2 & 8191, Y7 = ni2 >>> 13, oi = n3[8] | 0, j13 = oi & 8191, tt3 = oi >>> 13, si2 = n3[9] | 0, it3 = si2 & 8191, rt3 = si2 >>> 13;
      e.negative = t2.negative ^ r2.negative, e.length = 19, f8 = Math.imul(m20, O9), i = Math.imul(m20, K14), i = i + Math.imul(p7, O9) | 0, o6 = Math.imul(p7, K14);
      var mt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (mt2 >>> 26) | 0, mt2 &= 67108863, f8 = Math.imul(g17, O9), i = Math.imul(g17, K14), i = i + Math.imul(c13, O9) | 0, o6 = Math.imul(c13, K14), f8 = f8 + Math.imul(m20, F12) | 0, i = i + Math.imul(m20, H9) | 0, i = i + Math.imul(p7, F12) | 0, o6 = o6 + Math.imul(p7, H9) | 0;
      var pt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (pt2 >>> 26) | 0, pt2 &= 67108863, f8 = Math.imul(w24, O9), i = Math.imul(w24, K14), i = i + Math.imul(y16, O9) | 0, o6 = Math.imul(y16, K14), f8 = f8 + Math.imul(g17, F12) | 0, i = i + Math.imul(g17, H9) | 0, i = i + Math.imul(c13, F12) | 0, o6 = o6 + Math.imul(c13, H9) | 0, f8 = f8 + Math.imul(m20, P13) | 0, i = i + Math.imul(m20, D12) | 0, i = i + Math.imul(p7, P13) | 0, o6 = o6 + Math.imul(p7, D12) | 0;
      var Mt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (Mt2 >>> 26) | 0, Mt2 &= 67108863, f8 = Math.imul(b15, O9), i = Math.imul(b15, K14), i = i + Math.imul(A14, O9) | 0, o6 = Math.imul(A14, K14), f8 = f8 + Math.imul(w24, F12) | 0, i = i + Math.imul(w24, H9) | 0, i = i + Math.imul(y16, F12) | 0, o6 = o6 + Math.imul(y16, H9) | 0, f8 = f8 + Math.imul(g17, P13) | 0, i = i + Math.imul(g17, D12) | 0, i = i + Math.imul(c13, P13) | 0, o6 = o6 + Math.imul(c13, D12) | 0, f8 = f8 + Math.imul(m20, $17) | 0, i = i + Math.imul(m20, U7) | 0, i = i + Math.imul(p7, $17) | 0, o6 = o6 + Math.imul(p7, U7) | 0;
      var gt3 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (gt3 >>> 26) | 0, gt3 &= 67108863, f8 = Math.imul(B18, O9), i = Math.imul(B18, K14), i = i + Math.imul(S14, O9) | 0, o6 = Math.imul(S14, K14), f8 = f8 + Math.imul(b15, F12) | 0, i = i + Math.imul(b15, H9) | 0, i = i + Math.imul(A14, F12) | 0, o6 = o6 + Math.imul(A14, H9) | 0, f8 = f8 + Math.imul(w24, P13) | 0, i = i + Math.imul(w24, D12) | 0, i = i + Math.imul(y16, P13) | 0, o6 = o6 + Math.imul(y16, D12) | 0, f8 = f8 + Math.imul(g17, $17) | 0, i = i + Math.imul(g17, U7) | 0, i = i + Math.imul(c13, $17) | 0, o6 = o6 + Math.imul(c13, U7) | 0, f8 = f8 + Math.imul(m20, C11) | 0, i = i + Math.imul(m20, J14) | 0, i = i + Math.imul(p7, C11) | 0, o6 = o6 + Math.imul(p7, J14) | 0;
      var ct3 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (ct3 >>> 26) | 0, ct3 &= 67108863, f8 = Math.imul(k15, O9), i = Math.imul(k15, K14), i = i + Math.imul(q15, O9) | 0, o6 = Math.imul(q15, K14), f8 = f8 + Math.imul(B18, F12) | 0, i = i + Math.imul(B18, H9) | 0, i = i + Math.imul(S14, F12) | 0, o6 = o6 + Math.imul(S14, H9) | 0, f8 = f8 + Math.imul(b15, P13) | 0, i = i + Math.imul(b15, D12) | 0, i = i + Math.imul(A14, P13) | 0, o6 = o6 + Math.imul(A14, D12) | 0, f8 = f8 + Math.imul(w24, $17) | 0, i = i + Math.imul(w24, U7) | 0, i = i + Math.imul(y16, $17) | 0, o6 = o6 + Math.imul(y16, U7) | 0, f8 = f8 + Math.imul(g17, C11) | 0, i = i + Math.imul(g17, J14) | 0, i = i + Math.imul(c13, C11) | 0, o6 = o6 + Math.imul(c13, J14) | 0, f8 = f8 + Math.imul(m20, W2) | 0, i = i + Math.imul(m20, G11) | 0, i = i + Math.imul(p7, W2) | 0, o6 = o6 + Math.imul(p7, G11) | 0;
      var wt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, f8 = Math.imul(R13, O9), i = Math.imul(R13, K14), i = i + Math.imul(L18, O9) | 0, o6 = Math.imul(L18, K14), f8 = f8 + Math.imul(k15, F12) | 0, i = i + Math.imul(k15, H9) | 0, i = i + Math.imul(q15, F12) | 0, o6 = o6 + Math.imul(q15, H9) | 0, f8 = f8 + Math.imul(B18, P13) | 0, i = i + Math.imul(B18, D12) | 0, i = i + Math.imul(S14, P13) | 0, o6 = o6 + Math.imul(S14, D12) | 0, f8 = f8 + Math.imul(b15, $17) | 0, i = i + Math.imul(b15, U7) | 0, i = i + Math.imul(A14, $17) | 0, o6 = o6 + Math.imul(A14, U7) | 0, f8 = f8 + Math.imul(w24, C11) | 0, i = i + Math.imul(w24, J14) | 0, i = i + Math.imul(y16, C11) | 0, o6 = o6 + Math.imul(y16, J14) | 0, f8 = f8 + Math.imul(g17, W2) | 0, i = i + Math.imul(g17, G11) | 0, i = i + Math.imul(c13, W2) | 0, o6 = o6 + Math.imul(c13, G11) | 0, f8 = f8 + Math.imul(m20, Q9) | 0, i = i + Math.imul(m20, V8) | 0, i = i + Math.imul(p7, Q9) | 0, o6 = o6 + Math.imul(p7, V8) | 0;
      var yt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (yt2 >>> 26) | 0, yt2 &= 67108863, f8 = Math.imul(Z2, O9), i = Math.imul(Z2, K14), i = i + Math.imul(N6, O9) | 0, o6 = Math.imul(N6, K14), f8 = f8 + Math.imul(R13, F12) | 0, i = i + Math.imul(R13, H9) | 0, i = i + Math.imul(L18, F12) | 0, o6 = o6 + Math.imul(L18, H9) | 0, f8 = f8 + Math.imul(k15, P13) | 0, i = i + Math.imul(k15, D12) | 0, i = i + Math.imul(q15, P13) | 0, o6 = o6 + Math.imul(q15, D12) | 0, f8 = f8 + Math.imul(B18, $17) | 0, i = i + Math.imul(B18, U7) | 0, i = i + Math.imul(S14, $17) | 0, o6 = o6 + Math.imul(S14, U7) | 0, f8 = f8 + Math.imul(b15, C11) | 0, i = i + Math.imul(b15, J14) | 0, i = i + Math.imul(A14, C11) | 0, o6 = o6 + Math.imul(A14, J14) | 0, f8 = f8 + Math.imul(w24, W2) | 0, i = i + Math.imul(w24, G11) | 0, i = i + Math.imul(y16, W2) | 0, o6 = o6 + Math.imul(y16, G11) | 0, f8 = f8 + Math.imul(g17, Q9) | 0, i = i + Math.imul(g17, V8) | 0, i = i + Math.imul(c13, Q9) | 0, o6 = o6 + Math.imul(c13, V8) | 0, f8 = f8 + Math.imul(m20, X5) | 0, i = i + Math.imul(m20, Y7) | 0, i = i + Math.imul(p7, X5) | 0, o6 = o6 + Math.imul(p7, Y7) | 0;
      var xt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, f8 = Math.imul(T12, O9), i = Math.imul(T12, K14), i = i + Math.imul(I13, O9) | 0, o6 = Math.imul(I13, K14), f8 = f8 + Math.imul(Z2, F12) | 0, i = i + Math.imul(Z2, H9) | 0, i = i + Math.imul(N6, F12) | 0, o6 = o6 + Math.imul(N6, H9) | 0, f8 = f8 + Math.imul(R13, P13) | 0, i = i + Math.imul(R13, D12) | 0, i = i + Math.imul(L18, P13) | 0, o6 = o6 + Math.imul(L18, D12) | 0, f8 = f8 + Math.imul(k15, $17) | 0, i = i + Math.imul(k15, U7) | 0, i = i + Math.imul(q15, $17) | 0, o6 = o6 + Math.imul(q15, U7) | 0, f8 = f8 + Math.imul(B18, C11) | 0, i = i + Math.imul(B18, J14) | 0, i = i + Math.imul(S14, C11) | 0, o6 = o6 + Math.imul(S14, J14) | 0, f8 = f8 + Math.imul(b15, W2) | 0, i = i + Math.imul(b15, G11) | 0, i = i + Math.imul(A14, W2) | 0, o6 = o6 + Math.imul(A14, G11) | 0, f8 = f8 + Math.imul(w24, Q9) | 0, i = i + Math.imul(w24, V8) | 0, i = i + Math.imul(y16, Q9) | 0, o6 = o6 + Math.imul(y16, V8) | 0, f8 = f8 + Math.imul(g17, X5) | 0, i = i + Math.imul(g17, Y7) | 0, i = i + Math.imul(c13, X5) | 0, o6 = o6 + Math.imul(c13, Y7) | 0, f8 = f8 + Math.imul(m20, j13) | 0, i = i + Math.imul(m20, tt3) | 0, i = i + Math.imul(p7, j13) | 0, o6 = o6 + Math.imul(p7, tt3) | 0;
      var _t2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (_t2 >>> 26) | 0, _t2 &= 67108863, f8 = Math.imul(z15, O9), i = Math.imul(z15, K14), i = i + Math.imul(E15, O9) | 0, o6 = Math.imul(E15, K14), f8 = f8 + Math.imul(T12, F12) | 0, i = i + Math.imul(T12, H9) | 0, i = i + Math.imul(I13, F12) | 0, o6 = o6 + Math.imul(I13, H9) | 0, f8 = f8 + Math.imul(Z2, P13) | 0, i = i + Math.imul(Z2, D12) | 0, i = i + Math.imul(N6, P13) | 0, o6 = o6 + Math.imul(N6, D12) | 0, f8 = f8 + Math.imul(R13, $17) | 0, i = i + Math.imul(R13, U7) | 0, i = i + Math.imul(L18, $17) | 0, o6 = o6 + Math.imul(L18, U7) | 0, f8 = f8 + Math.imul(k15, C11) | 0, i = i + Math.imul(k15, J14) | 0, i = i + Math.imul(q15, C11) | 0, o6 = o6 + Math.imul(q15, J14) | 0, f8 = f8 + Math.imul(B18, W2) | 0, i = i + Math.imul(B18, G11) | 0, i = i + Math.imul(S14, W2) | 0, o6 = o6 + Math.imul(S14, G11) | 0, f8 = f8 + Math.imul(b15, Q9) | 0, i = i + Math.imul(b15, V8) | 0, i = i + Math.imul(A14, Q9) | 0, o6 = o6 + Math.imul(A14, V8) | 0, f8 = f8 + Math.imul(w24, X5) | 0, i = i + Math.imul(w24, Y7) | 0, i = i + Math.imul(y16, X5) | 0, o6 = o6 + Math.imul(y16, Y7) | 0, f8 = f8 + Math.imul(g17, j13) | 0, i = i + Math.imul(g17, tt3) | 0, i = i + Math.imul(c13, j13) | 0, o6 = o6 + Math.imul(c13, tt3) | 0, f8 = f8 + Math.imul(m20, it3) | 0, i = i + Math.imul(m20, rt3) | 0, i = i + Math.imul(p7, it3) | 0, o6 = o6 + Math.imul(p7, rt3) | 0;
      var bt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (bt2 >>> 26) | 0, bt2 &= 67108863, f8 = Math.imul(z15, F12), i = Math.imul(z15, H9), i = i + Math.imul(E15, F12) | 0, o6 = Math.imul(E15, H9), f8 = f8 + Math.imul(T12, P13) | 0, i = i + Math.imul(T12, D12) | 0, i = i + Math.imul(I13, P13) | 0, o6 = o6 + Math.imul(I13, D12) | 0, f8 = f8 + Math.imul(Z2, $17) | 0, i = i + Math.imul(Z2, U7) | 0, i = i + Math.imul(N6, $17) | 0, o6 = o6 + Math.imul(N6, U7) | 0, f8 = f8 + Math.imul(R13, C11) | 0, i = i + Math.imul(R13, J14) | 0, i = i + Math.imul(L18, C11) | 0, o6 = o6 + Math.imul(L18, J14) | 0, f8 = f8 + Math.imul(k15, W2) | 0, i = i + Math.imul(k15, G11) | 0, i = i + Math.imul(q15, W2) | 0, o6 = o6 + Math.imul(q15, G11) | 0, f8 = f8 + Math.imul(B18, Q9) | 0, i = i + Math.imul(B18, V8) | 0, i = i + Math.imul(S14, Q9) | 0, o6 = o6 + Math.imul(S14, V8) | 0, f8 = f8 + Math.imul(b15, X5) | 0, i = i + Math.imul(b15, Y7) | 0, i = i + Math.imul(A14, X5) | 0, o6 = o6 + Math.imul(A14, Y7) | 0, f8 = f8 + Math.imul(w24, j13) | 0, i = i + Math.imul(w24, tt3) | 0, i = i + Math.imul(y16, j13) | 0, o6 = o6 + Math.imul(y16, tt3) | 0, f8 = f8 + Math.imul(g17, it3) | 0, i = i + Math.imul(g17, rt3) | 0, i = i + Math.imul(c13, it3) | 0, o6 = o6 + Math.imul(c13, rt3) | 0;
      var At2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, f8 = Math.imul(z15, P13), i = Math.imul(z15, D12), i = i + Math.imul(E15, P13) | 0, o6 = Math.imul(E15, D12), f8 = f8 + Math.imul(T12, $17) | 0, i = i + Math.imul(T12, U7) | 0, i = i + Math.imul(I13, $17) | 0, o6 = o6 + Math.imul(I13, U7) | 0, f8 = f8 + Math.imul(Z2, C11) | 0, i = i + Math.imul(Z2, J14) | 0, i = i + Math.imul(N6, C11) | 0, o6 = o6 + Math.imul(N6, J14) | 0, f8 = f8 + Math.imul(R13, W2) | 0, i = i + Math.imul(R13, G11) | 0, i = i + Math.imul(L18, W2) | 0, o6 = o6 + Math.imul(L18, G11) | 0, f8 = f8 + Math.imul(k15, Q9) | 0, i = i + Math.imul(k15, V8) | 0, i = i + Math.imul(q15, Q9) | 0, o6 = o6 + Math.imul(q15, V8) | 0, f8 = f8 + Math.imul(B18, X5) | 0, i = i + Math.imul(B18, Y7) | 0, i = i + Math.imul(S14, X5) | 0, o6 = o6 + Math.imul(S14, Y7) | 0, f8 = f8 + Math.imul(b15, j13) | 0, i = i + Math.imul(b15, tt3) | 0, i = i + Math.imul(A14, j13) | 0, o6 = o6 + Math.imul(A14, tt3) | 0, f8 = f8 + Math.imul(w24, it3) | 0, i = i + Math.imul(w24, rt3) | 0, i = i + Math.imul(y16, it3) | 0, o6 = o6 + Math.imul(y16, rt3) | 0;
      var Bt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, f8 = Math.imul(z15, $17), i = Math.imul(z15, U7), i = i + Math.imul(E15, $17) | 0, o6 = Math.imul(E15, U7), f8 = f8 + Math.imul(T12, C11) | 0, i = i + Math.imul(T12, J14) | 0, i = i + Math.imul(I13, C11) | 0, o6 = o6 + Math.imul(I13, J14) | 0, f8 = f8 + Math.imul(Z2, W2) | 0, i = i + Math.imul(Z2, G11) | 0, i = i + Math.imul(N6, W2) | 0, o6 = o6 + Math.imul(N6, G11) | 0, f8 = f8 + Math.imul(R13, Q9) | 0, i = i + Math.imul(R13, V8) | 0, i = i + Math.imul(L18, Q9) | 0, o6 = o6 + Math.imul(L18, V8) | 0, f8 = f8 + Math.imul(k15, X5) | 0, i = i + Math.imul(k15, Y7) | 0, i = i + Math.imul(q15, X5) | 0, o6 = o6 + Math.imul(q15, Y7) | 0, f8 = f8 + Math.imul(B18, j13) | 0, i = i + Math.imul(B18, tt3) | 0, i = i + Math.imul(S14, j13) | 0, o6 = o6 + Math.imul(S14, tt3) | 0, f8 = f8 + Math.imul(b15, it3) | 0, i = i + Math.imul(b15, rt3) | 0, i = i + Math.imul(A14, it3) | 0, o6 = o6 + Math.imul(A14, rt3) | 0;
      var St2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (St2 >>> 26) | 0, St2 &= 67108863, f8 = Math.imul(z15, C11), i = Math.imul(z15, J14), i = i + Math.imul(E15, C11) | 0, o6 = Math.imul(E15, J14), f8 = f8 + Math.imul(T12, W2) | 0, i = i + Math.imul(T12, G11) | 0, i = i + Math.imul(I13, W2) | 0, o6 = o6 + Math.imul(I13, G11) | 0, f8 = f8 + Math.imul(Z2, Q9) | 0, i = i + Math.imul(Z2, V8) | 0, i = i + Math.imul(N6, Q9) | 0, o6 = o6 + Math.imul(N6, V8) | 0, f8 = f8 + Math.imul(R13, X5) | 0, i = i + Math.imul(R13, Y7) | 0, i = i + Math.imul(L18, X5) | 0, o6 = o6 + Math.imul(L18, Y7) | 0, f8 = f8 + Math.imul(k15, j13) | 0, i = i + Math.imul(k15, tt3) | 0, i = i + Math.imul(q15, j13) | 0, o6 = o6 + Math.imul(q15, tt3) | 0, f8 = f8 + Math.imul(B18, it3) | 0, i = i + Math.imul(B18, rt3) | 0, i = i + Math.imul(S14, it3) | 0, o6 = o6 + Math.imul(S14, rt3) | 0;
      var kt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, f8 = Math.imul(z15, W2), i = Math.imul(z15, G11), i = i + Math.imul(E15, W2) | 0, o6 = Math.imul(E15, G11), f8 = f8 + Math.imul(T12, Q9) | 0, i = i + Math.imul(T12, V8) | 0, i = i + Math.imul(I13, Q9) | 0, o6 = o6 + Math.imul(I13, V8) | 0, f8 = f8 + Math.imul(Z2, X5) | 0, i = i + Math.imul(Z2, Y7) | 0, i = i + Math.imul(N6, X5) | 0, o6 = o6 + Math.imul(N6, Y7) | 0, f8 = f8 + Math.imul(R13, j13) | 0, i = i + Math.imul(R13, tt3) | 0, i = i + Math.imul(L18, j13) | 0, o6 = o6 + Math.imul(L18, tt3) | 0, f8 = f8 + Math.imul(k15, it3) | 0, i = i + Math.imul(k15, rt3) | 0, i = i + Math.imul(q15, it3) | 0, o6 = o6 + Math.imul(q15, rt3) | 0;
      var qt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, f8 = Math.imul(z15, Q9), i = Math.imul(z15, V8), i = i + Math.imul(E15, Q9) | 0, o6 = Math.imul(E15, V8), f8 = f8 + Math.imul(T12, X5) | 0, i = i + Math.imul(T12, Y7) | 0, i = i + Math.imul(I13, X5) | 0, o6 = o6 + Math.imul(I13, Y7) | 0, f8 = f8 + Math.imul(Z2, j13) | 0, i = i + Math.imul(Z2, tt3) | 0, i = i + Math.imul(N6, j13) | 0, o6 = o6 + Math.imul(N6, tt3) | 0, f8 = f8 + Math.imul(R13, it3) | 0, i = i + Math.imul(R13, rt3) | 0, i = i + Math.imul(L18, it3) | 0, o6 = o6 + Math.imul(L18, rt3) | 0;
      var Rt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, f8 = Math.imul(z15, X5), i = Math.imul(z15, Y7), i = i + Math.imul(E15, X5) | 0, o6 = Math.imul(E15, Y7), f8 = f8 + Math.imul(T12, j13) | 0, i = i + Math.imul(T12, tt3) | 0, i = i + Math.imul(I13, j13) | 0, o6 = o6 + Math.imul(I13, tt3) | 0, f8 = f8 + Math.imul(Z2, it3) | 0, i = i + Math.imul(Z2, rt3) | 0, i = i + Math.imul(N6, it3) | 0, o6 = o6 + Math.imul(N6, rt3) | 0;
      var Lt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, f8 = Math.imul(z15, j13), i = Math.imul(z15, tt3), i = i + Math.imul(E15, j13) | 0, o6 = Math.imul(E15, tt3), f8 = f8 + Math.imul(T12, it3) | 0, i = i + Math.imul(T12, rt3) | 0, i = i + Math.imul(I13, it3) | 0, o6 = o6 + Math.imul(I13, rt3) | 0;
      var Zt = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      u12 = (o6 + (i >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, f8 = Math.imul(z15, it3), i = Math.imul(z15, rt3), i = i + Math.imul(E15, it3) | 0, o6 = Math.imul(E15, rt3);
      var Nt2 = (u12 + f8 | 0) + ((i & 8191) << 13) | 0;
      return u12 = (o6 + (i >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, a7[0] = mt2, a7[1] = pt2, a7[2] = Mt2, a7[3] = gt3, a7[4] = ct3, a7[5] = wt, a7[6] = yt2, a7[7] = xt, a7[8] = _t2, a7[9] = bt2, a7[10] = At2, a7[11] = Bt, a7[12] = St2, a7[13] = kt2, a7[14] = qt2, a7[15] = Rt, a7[16] = Lt2, a7[17] = Zt, a7[18] = Nt2, u12 !== 0 && (a7[19] = u12, e.length++), e;
    };
    Math.imul || (Pt2 = Ht);
    function Dt2(s10, t2, r2) {
      r2.negative = t2.negative ^ s10.negative, r2.length = s10.length + t2.length;
      for (var e = 0, h16 = 0, n3 = 0; n3 < r2.length - 1; n3++) {
        var a7 = h16;
        h16 = 0;
        for (var u12 = e & 67108863, f8 = Math.min(n3, t2.length - 1), i = Math.max(0, n3 - s10.length + 1); i <= f8; i++) {
          var o6 = n3 - i, d14 = s10.words[o6] | 0, m20 = t2.words[i] | 0, p7 = d14 * m20, M14 = p7 & 67108863;
          a7 = a7 + (p7 / 67108864 | 0) | 0, M14 = M14 + u12 | 0, u12 = M14 & 67108863, a7 = a7 + (M14 >>> 26) | 0, h16 += a7 >>> 26, a7 &= 67108863;
        }
        r2.words[n3] = u12, e = a7, a7 = h16;
      }
      return e !== 0 ? r2.words[n3] = e : r2.length--, r2._strip();
    }
    function $t2(s10, t2, r2) {
      return Dt2(s10, t2, r2);
    }
    l22.prototype.mulTo = function(t2, r2) {
      var e, h16 = this.length + t2.length;
      return this.length === 10 && t2.length === 10 ? e = Pt2(this, t2, r2) : h16 < 63 ? e = Ht(this, t2, r2) : h16 < 1024 ? e = Dt2(this, t2, r2) : e = $t2(this, t2, r2), e;
    };
    function ft2(s10, t2) {
      this.x = s10, this.y = t2;
    }
    ft2.prototype.makeRBT = function(t2) {
      for (var r2 = new Array(t2), e = l22.prototype._countBits(t2) - 1, h16 = 0; h16 < t2; h16++)
        r2[h16] = this.revBin(h16, e, t2);
      return r2;
    }, ft2.prototype.revBin = function(t2, r2, e) {
      if (t2 === 0 || t2 === e - 1)
        return t2;
      for (var h16 = 0, n3 = 0; n3 < r2; n3++)
        h16 |= (t2 & 1) << r2 - n3 - 1, t2 >>= 1;
      return h16;
    }, ft2.prototype.permute = function(t2, r2, e, h16, n3, a7) {
      for (var u12 = 0; u12 < a7; u12++)
        h16[u12] = r2[t2[u12]], n3[u12] = e[t2[u12]];
    }, ft2.prototype.transform = function(t2, r2, e, h16, n3, a7) {
      this.permute(a7, t2, r2, e, h16, n3);
      for (var u12 = 1; u12 < n3; u12 <<= 1)
        for (var f8 = u12 << 1, i = Math.cos(2 * Math.PI / f8), o6 = Math.sin(2 * Math.PI / f8), d14 = 0; d14 < n3; d14 += f8)
          for (var m20 = i, p7 = o6, M14 = 0; M14 < u12; M14++) {
            var g17 = e[d14 + M14], c13 = h16[d14 + M14], ot2 = e[d14 + M14 + u12], w24 = h16[d14 + M14 + u12], y16 = m20 * ot2 - p7 * w24;
            w24 = m20 * w24 + p7 * ot2, ot2 = y16, e[d14 + M14] = g17 + ot2, h16[d14 + M14] = c13 + w24, e[d14 + M14 + u12] = g17 - ot2, h16[d14 + M14 + u12] = c13 - w24, M14 !== f8 && (y16 = i * m20 - o6 * p7, p7 = i * p7 + o6 * m20, m20 = y16);
          }
    }, ft2.prototype.guessLen13b = function(t2, r2) {
      var e = Math.max(r2, t2) | 1, h16 = e & 1, n3 = 0;
      for (e = e / 2 | 0; e; e = e >>> 1)
        n3++;
      return 1 << n3 + 1 + h16;
    }, ft2.prototype.conjugate = function(t2, r2, e) {
      if (!(e <= 1))
        for (var h16 = 0; h16 < e / 2; h16++) {
          var n3 = t2[h16];
          t2[h16] = t2[e - h16 - 1], t2[e - h16 - 1] = n3, n3 = r2[h16], r2[h16] = -r2[e - h16 - 1], r2[e - h16 - 1] = -n3;
        }
    }, ft2.prototype.normalize13b = function(t2, r2) {
      for (var e = 0, h16 = 0; h16 < r2 / 2; h16++) {
        var n3 = Math.round(t2[2 * h16 + 1] / r2) * 8192 + Math.round(t2[2 * h16] / r2) + e;
        t2[h16] = n3 & 67108863, n3 < 67108864 ? e = 0 : e = n3 / 67108864 | 0;
      }
      return t2;
    }, ft2.prototype.convert13b = function(t2, r2, e, h16) {
      for (var n3 = 0, a7 = 0; a7 < r2; a7++)
        n3 = n3 + (t2[a7] | 0), e[2 * a7] = n3 & 8191, n3 = n3 >>> 13, e[2 * a7 + 1] = n3 & 8191, n3 = n3 >>> 13;
      for (a7 = 2 * r2; a7 < h16; ++a7)
        e[a7] = 0;
      v19(n3 === 0), v19((n3 & -8192) === 0);
    }, ft2.prototype.stub = function(t2) {
      for (var r2 = new Array(t2), e = 0; e < t2; e++)
        r2[e] = 0;
      return r2;
    }, ft2.prototype.mulp = function(t2, r2, e) {
      var h16 = 2 * this.guessLen13b(t2.length, r2.length), n3 = this.makeRBT(h16), a7 = this.stub(h16), u12 = new Array(h16), f8 = new Array(h16), i = new Array(h16), o6 = new Array(h16), d14 = new Array(h16), m20 = new Array(h16), p7 = e.words;
      p7.length = h16, this.convert13b(t2.words, t2.length, u12, h16), this.convert13b(r2.words, r2.length, o6, h16), this.transform(u12, a7, f8, i, h16, n3), this.transform(o6, a7, d14, m20, h16, n3);
      for (var M14 = 0; M14 < h16; M14++) {
        var g17 = f8[M14] * d14[M14] - i[M14] * m20[M14];
        i[M14] = f8[M14] * m20[M14] + i[M14] * d14[M14], f8[M14] = g17;
      }
      return this.conjugate(f8, i, h16), this.transform(f8, i, p7, a7, h16, n3), this.conjugate(p7, a7, h16), this.normalize13b(p7, h16), e.negative = t2.negative ^ r2.negative, e.length = t2.length + r2.length, e._strip();
    }, l22.prototype.mul = function(t2) {
      var r2 = new l22(null);
      return r2.words = new Array(this.length + t2.length), this.mulTo(t2, r2);
    }, l22.prototype.mulf = function(t2) {
      var r2 = new l22(null);
      return r2.words = new Array(this.length + t2.length), $t2(this, t2, r2);
    }, l22.prototype.imul = function(t2) {
      return this.clone().mulTo(t2, this);
    }, l22.prototype.imuln = function(t2) {
      var r2 = t2 < 0;
      r2 && (t2 = -t2), v19(typeof t2 == "number"), v19(t2 < 67108864);
      for (var e = 0, h16 = 0; h16 < this.length; h16++) {
        var n3 = (this.words[h16] | 0) * t2, a7 = (n3 & 67108863) + (e & 67108863);
        e >>= 26, e += n3 / 67108864 | 0, e += a7 >>> 26, this.words[h16] = a7 & 67108863;
      }
      return e !== 0 && (this.words[h16] = e, this.length++), r2 ? this.ineg() : this;
    }, l22.prototype.muln = function(t2) {
      return this.clone().imuln(t2);
    }, l22.prototype.sqr = function() {
      return this.mul(this);
    }, l22.prototype.isqr = function() {
      return this.imul(this.clone());
    }, l22.prototype.pow = function(t2) {
      var r2 = gi2(t2);
      if (r2.length === 0)
        return new l22(1);
      for (var e = this, h16 = 0; h16 < r2.length && r2[h16] === 0; h16++, e = e.sqr())
        ;
      if (++h16 < r2.length)
        for (var n3 = e.sqr(); h16 < r2.length; h16++, n3 = n3.sqr())
          r2[h16] !== 0 && (e = e.mul(n3));
      return e;
    }, l22.prototype.iushln = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = t2 % 26, e = (t2 - r2) / 26, h16 = 67108863 >>> 26 - r2 << 26 - r2, n3;
      if (r2 !== 0) {
        var a7 = 0;
        for (n3 = 0; n3 < this.length; n3++) {
          var u12 = this.words[n3] & h16, f8 = (this.words[n3] | 0) - u12 << r2;
          this.words[n3] = f8 | a7, a7 = u12 >>> 26 - r2;
        }
        a7 && (this.words[n3] = a7, this.length++);
      }
      if (e !== 0) {
        for (n3 = this.length - 1; n3 >= 0; n3--)
          this.words[n3 + e] = this.words[n3];
        for (n3 = 0; n3 < e; n3++)
          this.words[n3] = 0;
        this.length += e;
      }
      return this._strip();
    }, l22.prototype.ishln = function(t2) {
      return v19(this.negative === 0), this.iushln(t2);
    }, l22.prototype.iushrn = function(t2, r2, e) {
      v19(typeof t2 == "number" && t2 >= 0);
      var h16;
      r2 ? h16 = (r2 - r2 % 26) / 26 : h16 = 0;
      var n3 = t2 % 26, a7 = Math.min((t2 - n3) / 26, this.length), u12 = 67108863 ^ 67108863 >>> n3 << n3, f8 = e;
      if (h16 -= a7, h16 = Math.max(0, h16), f8) {
        for (var i = 0; i < a7; i++)
          f8.words[i] = this.words[i];
        f8.length = a7;
      }
      if (a7 !== 0)
        if (this.length > a7)
          for (this.length -= a7, i = 0; i < this.length; i++)
            this.words[i] = this.words[i + a7];
        else
          this.words[0] = 0, this.length = 1;
      var o6 = 0;
      for (i = this.length - 1; i >= 0 && (o6 !== 0 || i >= h16); i--) {
        var d14 = this.words[i] | 0;
        this.words[i] = o6 << 26 - n3 | d14 >>> n3, o6 = d14 & u12;
      }
      return f8 && o6 !== 0 && (f8.words[f8.length++] = o6), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, l22.prototype.ishrn = function(t2, r2, e) {
      return v19(this.negative === 0), this.iushrn(t2, r2, e);
    }, l22.prototype.shln = function(t2) {
      return this.clone().ishln(t2);
    }, l22.prototype.ushln = function(t2) {
      return this.clone().iushln(t2);
    }, l22.prototype.shrn = function(t2) {
      return this.clone().ishrn(t2);
    }, l22.prototype.ushrn = function(t2) {
      return this.clone().iushrn(t2);
    }, l22.prototype.testn = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = t2 % 26, e = (t2 - r2) / 26, h16 = 1 << r2;
      if (this.length <= e)
        return false;
      var n3 = this.words[e];
      return !!(n3 & h16);
    }, l22.prototype.imaskn = function(t2) {
      v19(typeof t2 == "number" && t2 >= 0);
      var r2 = t2 % 26, e = (t2 - r2) / 26;
      if (v19(this.negative === 0, "imaskn works only with positive numbers"), this.length <= e)
        return this;
      if (r2 !== 0 && e++, this.length = Math.min(e, this.length), r2 !== 0) {
        var h16 = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= h16;
      }
      return this._strip();
    }, l22.prototype.maskn = function(t2) {
      return this.clone().imaskn(t2);
    }, l22.prototype.iaddn = function(t2) {
      return v19(typeof t2 == "number"), v19(t2 < 67108864), t2 < 0 ? this.isubn(-t2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= t2 ? (this.words[0] = t2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t2), this.negative = 1, this) : this._iaddn(t2);
    }, l22.prototype._iaddn = function(t2) {
      this.words[0] += t2;
      for (var r2 = 0; r2 < this.length && this.words[r2] >= 67108864; r2++)
        this.words[r2] -= 67108864, r2 === this.length - 1 ? this.words[r2 + 1] = 1 : this.words[r2 + 1]++;
      return this.length = Math.max(this.length, r2 + 1), this;
    }, l22.prototype.isubn = function(t2) {
      if (v19(typeof t2 == "number"), v19(t2 < 67108864), t2 < 0)
        return this.iaddn(-t2);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(t2), this.negative = 1, this;
      if (this.words[0] -= t2, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var r2 = 0; r2 < this.length && this.words[r2] < 0; r2++)
          this.words[r2] += 67108864, this.words[r2 + 1] -= 1;
      return this._strip();
    }, l22.prototype.addn = function(t2) {
      return this.clone().iaddn(t2);
    }, l22.prototype.subn = function(t2) {
      return this.clone().isubn(t2);
    }, l22.prototype.iabs = function() {
      return this.negative = 0, this;
    }, l22.prototype.abs = function() {
      return this.clone().iabs();
    }, l22.prototype._ishlnsubmul = function(t2, r2, e) {
      var h16 = t2.length + e, n3;
      this._expand(h16);
      var a7, u12 = 0;
      for (n3 = 0; n3 < t2.length; n3++) {
        a7 = (this.words[n3 + e] | 0) + u12;
        var f8 = (t2.words[n3] | 0) * r2;
        a7 -= f8 & 67108863, u12 = (a7 >> 26) - (f8 / 67108864 | 0), this.words[n3 + e] = a7 & 67108863;
      }
      for (; n3 < this.length - e; n3++)
        a7 = (this.words[n3 + e] | 0) + u12, u12 = a7 >> 26, this.words[n3 + e] = a7 & 67108863;
      if (u12 === 0)
        return this._strip();
      for (v19(u12 === -1), u12 = 0, n3 = 0; n3 < this.length; n3++)
        a7 = -(this.words[n3] | 0) + u12, u12 = a7 >> 26, this.words[n3] = a7 & 67108863;
      return this.negative = 1, this._strip();
    }, l22.prototype._wordDiv = function(t2, r2) {
      var e = this.length - t2.length, h16 = this.clone(), n3 = t2, a7 = n3.words[n3.length - 1] | 0, u12 = this._countBits(a7);
      e = 26 - u12, e !== 0 && (n3 = n3.ushln(e), h16.iushln(e), a7 = n3.words[n3.length - 1] | 0);
      var f8 = h16.length - n3.length, i;
      if (r2 !== "mod") {
        i = new l22(null), i.length = f8 + 1, i.words = new Array(i.length);
        for (var o6 = 0; o6 < i.length; o6++)
          i.words[o6] = 0;
      }
      var d14 = h16.clone()._ishlnsubmul(n3, 1, f8);
      d14.negative === 0 && (h16 = d14, i && (i.words[f8] = 1));
      for (var m20 = f8 - 1; m20 >= 0; m20--) {
        var p7 = (h16.words[n3.length + m20] | 0) * 67108864 + (h16.words[n3.length + m20 - 1] | 0);
        for (p7 = Math.min(p7 / a7 | 0, 67108863), h16._ishlnsubmul(n3, p7, m20); h16.negative !== 0; )
          p7--, h16.negative = 0, h16._ishlnsubmul(n3, 1, m20), h16.isZero() || (h16.negative ^= 1);
        i && (i.words[m20] = p7);
      }
      return i && i._strip(), h16._strip(), r2 !== "div" && e !== 0 && h16.iushrn(e), {
        div: i || null,
        mod: h16
      };
    }, l22.prototype.divmod = function(t2, r2, e) {
      if (v19(!t2.isZero()), this.isZero())
        return {
          div: new l22(0),
          mod: new l22(0)
        };
      var h16, n3, a7;
      return this.negative !== 0 && t2.negative === 0 ? (a7 = this.neg().divmod(t2, r2), r2 !== "mod" && (h16 = a7.div.neg()), r2 !== "div" && (n3 = a7.mod.neg(), e && n3.negative !== 0 && n3.iadd(t2)), {
        div: h16,
        mod: n3
      }) : this.negative === 0 && t2.negative !== 0 ? (a7 = this.divmod(t2.neg(), r2), r2 !== "mod" && (h16 = a7.div.neg()), {
        div: h16,
        mod: a7.mod
      }) : (this.negative & t2.negative) !== 0 ? (a7 = this.neg().divmod(t2.neg(), r2), r2 !== "div" && (n3 = a7.mod.neg(), e && n3.negative !== 0 && n3.isub(t2)), {
        div: a7.div,
        mod: n3
      }) : t2.length > this.length || this.cmp(t2) < 0 ? {
        div: new l22(0),
        mod: this
      } : t2.length === 1 ? r2 === "div" ? {
        div: this.divn(t2.words[0]),
        mod: null
      } : r2 === "mod" ? {
        div: null,
        mod: new l22(this.modrn(t2.words[0]))
      } : {
        div: this.divn(t2.words[0]),
        mod: new l22(this.modrn(t2.words[0]))
      } : this._wordDiv(t2, r2);
    }, l22.prototype.div = function(t2) {
      return this.divmod(t2, "div", false).div;
    }, l22.prototype.mod = function(t2) {
      return this.divmod(t2, "mod", false).mod;
    }, l22.prototype.umod = function(t2) {
      return this.divmod(t2, "mod", true).mod;
    }, l22.prototype.divRound = function(t2) {
      var r2 = this.divmod(t2);
      if (r2.mod.isZero())
        return r2.div;
      var e = r2.div.negative !== 0 ? r2.mod.isub(t2) : r2.mod, h16 = t2.ushrn(1), n3 = t2.andln(1), a7 = e.cmp(h16);
      return a7 < 0 || n3 === 1 && a7 === 0 ? r2.div : r2.div.negative !== 0 ? r2.div.isubn(1) : r2.div.iaddn(1);
    }, l22.prototype.modrn = function(t2) {
      var r2 = t2 < 0;
      r2 && (t2 = -t2), v19(t2 <= 67108863);
      for (var e = (1 << 26) % t2, h16 = 0, n3 = this.length - 1; n3 >= 0; n3--)
        h16 = (e * h16 + (this.words[n3] | 0)) % t2;
      return r2 ? -h16 : h16;
    }, l22.prototype.modn = function(t2) {
      return this.modrn(t2);
    }, l22.prototype.idivn = function(t2) {
      var r2 = t2 < 0;
      r2 && (t2 = -t2), v19(t2 <= 67108863);
      for (var e = 0, h16 = this.length - 1; h16 >= 0; h16--) {
        var n3 = (this.words[h16] | 0) + e * 67108864;
        this.words[h16] = n3 / t2 | 0, e = n3 % t2;
      }
      return this._strip(), r2 ? this.ineg() : this;
    }, l22.prototype.divn = function(t2) {
      return this.clone().idivn(t2);
    }, l22.prototype.egcd = function(t2) {
      v19(t2.negative === 0), v19(!t2.isZero());
      var r2 = this, e = t2.clone();
      r2.negative !== 0 ? r2 = r2.umod(t2) : r2 = r2.clone();
      for (var h16 = new l22(1), n3 = new l22(0), a7 = new l22(0), u12 = new l22(1), f8 = 0; r2.isEven() && e.isEven(); )
        r2.iushrn(1), e.iushrn(1), ++f8;
      for (var i = e.clone(), o6 = r2.clone(); !r2.isZero(); ) {
        for (var d14 = 0, m20 = 1; (r2.words[0] & m20) === 0 && d14 < 26; ++d14, m20 <<= 1)
          ;
        if (d14 > 0)
          for (r2.iushrn(d14); d14-- > 0; )
            (h16.isOdd() || n3.isOdd()) && (h16.iadd(i), n3.isub(o6)), h16.iushrn(1), n3.iushrn(1);
        for (var p7 = 0, M14 = 1; (e.words[0] & M14) === 0 && p7 < 26; ++p7, M14 <<= 1)
          ;
        if (p7 > 0)
          for (e.iushrn(p7); p7-- > 0; )
            (a7.isOdd() || u12.isOdd()) && (a7.iadd(i), u12.isub(o6)), a7.iushrn(1), u12.iushrn(1);
        r2.cmp(e) >= 0 ? (r2.isub(e), h16.isub(a7), n3.isub(u12)) : (e.isub(r2), a7.isub(h16), u12.isub(n3));
      }
      return {
        a: a7,
        b: u12,
        gcd: e.iushln(f8)
      };
    }, l22.prototype._invmp = function(t2) {
      v19(t2.negative === 0), v19(!t2.isZero());
      var r2 = this, e = t2.clone();
      r2.negative !== 0 ? r2 = r2.umod(t2) : r2 = r2.clone();
      for (var h16 = new l22(1), n3 = new l22(0), a7 = e.clone(); r2.cmpn(1) > 0 && e.cmpn(1) > 0; ) {
        for (var u12 = 0, f8 = 1; (r2.words[0] & f8) === 0 && u12 < 26; ++u12, f8 <<= 1)
          ;
        if (u12 > 0)
          for (r2.iushrn(u12); u12-- > 0; )
            h16.isOdd() && h16.iadd(a7), h16.iushrn(1);
        for (var i = 0, o6 = 1; (e.words[0] & o6) === 0 && i < 26; ++i, o6 <<= 1)
          ;
        if (i > 0)
          for (e.iushrn(i); i-- > 0; )
            n3.isOdd() && n3.iadd(a7), n3.iushrn(1);
        r2.cmp(e) >= 0 ? (r2.isub(e), h16.isub(n3)) : (e.isub(r2), n3.isub(h16));
      }
      var d14;
      return r2.cmpn(1) === 0 ? d14 = h16 : d14 = n3, d14.cmpn(0) < 0 && d14.iadd(t2), d14;
    }, l22.prototype.gcd = function(t2) {
      if (this.isZero())
        return t2.abs();
      if (t2.isZero())
        return this.abs();
      var r2 = this.clone(), e = t2.clone();
      r2.negative = 0, e.negative = 0;
      for (var h16 = 0; r2.isEven() && e.isEven(); h16++)
        r2.iushrn(1), e.iushrn(1);
      do {
        for (; r2.isEven(); )
          r2.iushrn(1);
        for (; e.isEven(); )
          e.iushrn(1);
        var n3 = r2.cmp(e);
        if (n3 < 0) {
          var a7 = r2;
          r2 = e, e = a7;
        } else if (n3 === 0 || e.cmpn(1) === 0)
          break;
        r2.isub(e);
      } while (true);
      return e.iushln(h16);
    }, l22.prototype.invm = function(t2) {
      return this.egcd(t2).a.umod(t2);
    }, l22.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, l22.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, l22.prototype.andln = function(t2) {
      return this.words[0] & t2;
    }, l22.prototype.bincn = function(t2) {
      v19(typeof t2 == "number");
      var r2 = t2 % 26, e = (t2 - r2) / 26, h16 = 1 << r2;
      if (this.length <= e)
        return this._expand(e + 1), this.words[e] |= h16, this;
      for (var n3 = h16, a7 = e; n3 !== 0 && a7 < this.length; a7++) {
        var u12 = this.words[a7] | 0;
        u12 += n3, n3 = u12 >>> 26, u12 &= 67108863, this.words[a7] = u12;
      }
      return n3 !== 0 && (this.words[a7] = n3, this.length++), this;
    }, l22.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, l22.prototype.cmpn = function(t2) {
      var r2 = t2 < 0;
      if (this.negative !== 0 && !r2)
        return -1;
      if (this.negative === 0 && r2)
        return 1;
      this._strip();
      var e;
      if (this.length > 1)
        e = 1;
      else {
        r2 && (t2 = -t2), v19(t2 <= 67108863, "Number is too big");
        var h16 = this.words[0] | 0;
        e = h16 === t2 ? 0 : h16 < t2 ? -1 : 1;
      }
      return this.negative !== 0 ? -e | 0 : e;
    }, l22.prototype.cmp = function(t2) {
      if (this.negative !== 0 && t2.negative === 0)
        return -1;
      if (this.negative === 0 && t2.negative !== 0)
        return 1;
      var r2 = this.ucmp(t2);
      return this.negative !== 0 ? -r2 | 0 : r2;
    }, l22.prototype.ucmp = function(t2) {
      if (this.length > t2.length)
        return 1;
      if (this.length < t2.length)
        return -1;
      for (var r2 = 0, e = this.length - 1; e >= 0; e--) {
        var h16 = this.words[e] | 0, n3 = t2.words[e] | 0;
        if (h16 !== n3) {
          h16 < n3 ? r2 = -1 : h16 > n3 && (r2 = 1);
          break;
        }
      }
      return r2;
    }, l22.prototype.gtn = function(t2) {
      return this.cmpn(t2) === 1;
    }, l22.prototype.gt = function(t2) {
      return this.cmp(t2) === 1;
    }, l22.prototype.gten = function(t2) {
      return this.cmpn(t2) >= 0;
    }, l22.prototype.gte = function(t2) {
      return this.cmp(t2) >= 0;
    }, l22.prototype.ltn = function(t2) {
      return this.cmpn(t2) === -1;
    }, l22.prototype.lt = function(t2) {
      return this.cmp(t2) === -1;
    }, l22.prototype.lten = function(t2) {
      return this.cmpn(t2) <= 0;
    }, l22.prototype.lte = function(t2) {
      return this.cmp(t2) <= 0;
    }, l22.prototype.eqn = function(t2) {
      return this.cmpn(t2) === 0;
    }, l22.prototype.eq = function(t2) {
      return this.cmp(t2) === 0;
    }, l22.red = function(t2) {
      return new x17(t2);
    }, l22.prototype.toRed = function(t2) {
      return v19(!this.red, "Already a number in reduction context"), v19(this.negative === 0, "red works only with positives"), t2.convertTo(this)._forceRed(t2);
    }, l22.prototype.fromRed = function() {
      return v19(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, l22.prototype._forceRed = function(t2) {
      return this.red = t2, this;
    }, l22.prototype.forceRed = function(t2) {
      return v19(!this.red, "Already a number in reduction context"), this._forceRed(t2);
    }, l22.prototype.redAdd = function(t2) {
      return v19(this.red, "redAdd works only with red numbers"), this.red.add(this, t2);
    }, l22.prototype.redIAdd = function(t2) {
      return v19(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t2);
    }, l22.prototype.redSub = function(t2) {
      return v19(this.red, "redSub works only with red numbers"), this.red.sub(this, t2);
    }, l22.prototype.redISub = function(t2) {
      return v19(this.red, "redISub works only with red numbers"), this.red.isub(this, t2);
    }, l22.prototype.redShl = function(t2) {
      return v19(this.red, "redShl works only with red numbers"), this.red.shl(this, t2);
    }, l22.prototype.redMul = function(t2) {
      return v19(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.mul(this, t2);
    }, l22.prototype.redIMul = function(t2) {
      return v19(this.red, "redMul works only with red numbers"), this.red._verify2(this, t2), this.red.imul(this, t2);
    }, l22.prototype.redSqr = function() {
      return v19(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, l22.prototype.redISqr = function() {
      return v19(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, l22.prototype.redSqrt = function() {
      return v19(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, l22.prototype.redInvm = function() {
      return v19(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, l22.prototype.redNeg = function() {
      return v19(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, l22.prototype.redPow = function(t2) {
      return v19(this.red && !t2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t2);
    };
    var vt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ht4(s10, t2) {
      this.name = s10, this.p = new l22(t2, 16), this.n = this.p.bitLength(), this.k = new l22(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ht4.prototype._tmp = function() {
      var t2 = new l22(null);
      return t2.words = new Array(Math.ceil(this.n / 13)), t2;
    }, ht4.prototype.ireduce = function(t2) {
      var r2 = t2, e;
      do
        this.split(r2, this.tmp), r2 = this.imulK(r2), r2 = r2.iadd(this.tmp), e = r2.bitLength();
      while (e > this.n);
      var h16 = e < this.n ? -1 : r2.ucmp(this.p);
      return h16 === 0 ? (r2.words[0] = 0, r2.length = 1) : h16 > 0 ? r2.isub(this.p) : r2.strip !== void 0 ? r2.strip() : r2._strip(), r2;
    }, ht4.prototype.split = function(t2, r2) {
      t2.iushrn(this.n, 0, r2);
    }, ht4.prototype.imulK = function(t2) {
      return t2.imul(this.k);
    };
    function lt2() {
      ht4.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    nt2(lt2, ht4), lt2.prototype.split = function(t2, r2) {
      for (var e = 4194303, h16 = Math.min(t2.length, 9), n3 = 0; n3 < h16; n3++)
        r2.words[n3] = t2.words[n3];
      if (r2.length = h16, t2.length <= 9) {
        t2.words[0] = 0, t2.length = 1;
        return;
      }
      var a7 = t2.words[9];
      for (r2.words[r2.length++] = a7 & e, n3 = 10; n3 < t2.length; n3++) {
        var u12 = t2.words[n3] | 0;
        t2.words[n3 - 10] = (u12 & e) << 4 | a7 >>> 22, a7 = u12;
      }
      a7 >>>= 22, t2.words[n3 - 10] = a7, a7 === 0 && t2.length > 10 ? t2.length -= 10 : t2.length -= 9;
    }, lt2.prototype.imulK = function(t2) {
      t2.words[t2.length] = 0, t2.words[t2.length + 1] = 0, t2.length += 2;
      for (var r2 = 0, e = 0; e < t2.length; e++) {
        var h16 = t2.words[e] | 0;
        r2 += h16 * 977, t2.words[e] = r2 & 67108863, r2 = h16 * 64 + (r2 / 67108864 | 0);
      }
      return t2.words[t2.length - 1] === 0 && (t2.length--, t2.words[t2.length - 1] === 0 && t2.length--), t2;
    };
    function Ut() {
      ht4.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    nt2(Ut, ht4);
    function Ct() {
      ht4.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    nt2(Ct, ht4);
    function dt2() {
      ht4.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    nt2(dt2, ht4), dt2.prototype.imulK = function(t2) {
      for (var r2 = 0, e = 0; e < t2.length; e++) {
        var h16 = (t2.words[e] | 0) * 19 + r2, n3 = h16 & 67108863;
        h16 >>>= 26, t2.words[e] = n3, r2 = h16;
      }
      return r2 !== 0 && (t2.words[t2.length++] = r2), t2;
    }, l22._prime = function(t2) {
      if (vt[t2])
        return vt[t2];
      var r2;
      if (t2 === "k256")
        r2 = new lt2();
      else if (t2 === "p224")
        r2 = new Ut();
      else if (t2 === "p192")
        r2 = new Ct();
      else if (t2 === "p25519")
        r2 = new dt2();
      else
        throw new Error("Unknown prime " + t2);
      return vt[t2] = r2, r2;
    };
    function x17(s10) {
      if (typeof s10 == "string") {
        var t2 = l22._prime(s10);
        this.m = t2.p, this.prime = t2;
      } else
        v19(s10.gtn(1), "modulus must be greater than 1"), this.m = s10, this.prime = null;
    }
    x17.prototype._verify1 = function(t2) {
      v19(t2.negative === 0, "red works only with positives"), v19(t2.red, "red works only with red numbers");
    }, x17.prototype._verify2 = function(t2, r2) {
      v19((t2.negative | r2.negative) === 0, "red works only with positives"), v19(t2.red && t2.red === r2.red, "red works only with red numbers");
    }, x17.prototype.imod = function(t2) {
      return this.prime ? this.prime.ireduce(t2)._forceRed(this) : (Kt2(t2, t2.umod(this.m)._forceRed(this)), t2);
    }, x17.prototype.neg = function(t2) {
      return t2.isZero() ? t2.clone() : this.m.sub(t2)._forceRed(this);
    }, x17.prototype.add = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.add(r2);
      return e.cmp(this.m) >= 0 && e.isub(this.m), e._forceRed(this);
    }, x17.prototype.iadd = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.iadd(r2);
      return e.cmp(this.m) >= 0 && e.isub(this.m), e;
    }, x17.prototype.sub = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.sub(r2);
      return e.cmpn(0) < 0 && e.iadd(this.m), e._forceRed(this);
    }, x17.prototype.isub = function(t2, r2) {
      this._verify2(t2, r2);
      var e = t2.isub(r2);
      return e.cmpn(0) < 0 && e.iadd(this.m), e;
    }, x17.prototype.shl = function(t2, r2) {
      return this._verify1(t2), this.imod(t2.ushln(r2));
    }, x17.prototype.imul = function(t2, r2) {
      return this._verify2(t2, r2), this.imod(t2.imul(r2));
    }, x17.prototype.mul = function(t2, r2) {
      return this._verify2(t2, r2), this.imod(t2.mul(r2));
    }, x17.prototype.isqr = function(t2) {
      return this.imul(t2, t2.clone());
    }, x17.prototype.sqr = function(t2) {
      return this.mul(t2, t2);
    }, x17.prototype.sqrt = function(t2) {
      if (t2.isZero())
        return t2.clone();
      var r2 = this.m.andln(3);
      if (v19(r2 % 2 === 1), r2 === 3) {
        var e = this.m.add(new l22(1)).iushrn(2);
        return this.pow(t2, e);
      }
      for (var h16 = this.m.subn(1), n3 = 0; !h16.isZero() && h16.andln(1) === 0; )
        n3++, h16.iushrn(1);
      v19(!h16.isZero());
      var a7 = new l22(1).toRed(this), u12 = a7.redNeg(), f8 = this.m.subn(1).iushrn(1), i = this.m.bitLength();
      for (i = new l22(2 * i * i).toRed(this); this.pow(i, f8).cmp(u12) !== 0; )
        i.redIAdd(u12);
      for (var o6 = this.pow(i, h16), d14 = this.pow(t2, h16.addn(1).iushrn(1)), m20 = this.pow(t2, h16), p7 = n3; m20.cmp(a7) !== 0; ) {
        for (var M14 = m20, g17 = 0; M14.cmp(a7) !== 0; g17++)
          M14 = M14.redSqr();
        v19(g17 < p7);
        var c13 = this.pow(o6, new l22(1).iushln(p7 - g17 - 1));
        d14 = d14.redMul(c13), o6 = c13.redSqr(), m20 = m20.redMul(o6), p7 = g17;
      }
      return d14;
    }, x17.prototype.invm = function(t2) {
      var r2 = t2._invmp(this.m);
      return r2.negative !== 0 ? (r2.negative = 0, this.imod(r2).redNeg()) : this.imod(r2);
    }, x17.prototype.pow = function(t2, r2) {
      if (r2.isZero())
        return new l22(1).toRed(this);
      if (r2.cmpn(1) === 0)
        return t2.clone();
      var e = 4, h16 = new Array(1 << e);
      h16[0] = new l22(1).toRed(this), h16[1] = t2;
      for (var n3 = 2; n3 < h16.length; n3++)
        h16[n3] = this.mul(h16[n3 - 1], t2);
      var a7 = h16[0], u12 = 0, f8 = 0, i = r2.bitLength() % 26;
      for (i === 0 && (i = 26), n3 = r2.length - 1; n3 >= 0; n3--) {
        for (var o6 = r2.words[n3], d14 = i - 1; d14 >= 0; d14--) {
          var m20 = o6 >> d14 & 1;
          if (a7 !== h16[0] && (a7 = this.sqr(a7)), m20 === 0 && u12 === 0) {
            f8 = 0;
            continue;
          }
          u12 <<= 1, u12 |= m20, f8++, !(f8 !== e && (n3 !== 0 || d14 !== 0)) && (a7 = this.mul(a7, h16[u12]), f8 = 0, u12 = 0);
        }
        i = 26;
      }
      return a7;
    }, x17.prototype.convertTo = function(t2) {
      var r2 = t2.umod(this.m);
      return r2 === t2 ? r2.clone() : r2;
    }, x17.prototype.convertFrom = function(t2) {
      var r2 = t2.clone();
      return r2.red = null, r2;
    }, l22.mont = function(t2) {
      return new st2(t2);
    };
    function st2(s10) {
      x17.call(this, s10), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new l22(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    nt2(st2, x17), st2.prototype.convertTo = function(t2) {
      return this.imod(t2.ushln(this.shift));
    }, st2.prototype.convertFrom = function(t2) {
      var r2 = this.imod(t2.mul(this.rinv));
      return r2.red = null, r2;
    }, st2.prototype.imul = function(t2, r2) {
      if (t2.isZero() || r2.isZero())
        return t2.words[0] = 0, t2.length = 1, t2;
      var e = t2.imul(r2), h16 = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n3 = e.isub(h16).iushrn(this.shift), a7 = n3;
      return n3.cmp(this.m) >= 0 ? a7 = n3.isub(this.m) : n3.cmpn(0) < 0 && (a7 = n3.iadd(this.m)), a7._forceRed(this);
    }, st2.prototype.mul = function(t2, r2) {
      if (t2.isZero() || r2.isZero())
        return new l22(0)._forceRed(this);
      var e = t2.mul(r2), h16 = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n3 = e.isub(h16).iushrn(this.shift), a7 = n3;
      return n3.cmp(this.m) >= 0 ? a7 = n3.isub(this.m) : n3.cmpn(0) < 0 && (a7 = n3.iadd(this.m)), a7._forceRed(this);
    }, st2.prototype.invm = function(t2) {
      var r2 = this.imod(t2._invmp(this.m).mul(this.r2));
      return r2._forceRed(this);
    };
  })(typeof Tt > "u" || Tt, ui);
});
var vi = li1(It());
var di = li1(It());
var { BN: Ri } = di;
var { default: Si1, ...ki2 } = di;
var Li = vi.default ?? Si1 ?? ki2;
var v13 = Object.create;
var l15 = Object.defineProperty;
var B9 = Object.getOwnPropertyDescriptor;
var L8 = Object.getOwnPropertyNames;
var P7 = Object.getPrototypeOf;
var k7 = Object.prototype.hasOwnProperty;
((r2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r2, {
  get: (e, o6) => (typeof require != "undefined" ? require : e)[o6]
}) : r2)(function(r2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var p15 = (r2, e) => () => (e || r2((e = {
  exports: {}
}).exports, e), e.exports);
var A7 = (r2, e, o6, d14) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n3 of L8(e))
      !k7.call(r2, n3) && n3 !== o6 && l15(r2, n3, {
        get: () => e[n3],
        enumerable: !(d14 = B9(e, n3)) || d14.enumerable
      });
  return r2;
};
var i9 = (r2, e, o6) => (o6 = r2 != null ? v13(P7(r2)) : {}, A7(e || !r2 || !r2.__esModule ? l15(o6, "default", {
  value: r2,
  enumerable: true
}) : o6, r2));
var m13 = p15((D12, b15) => {
  var u12 = Li, E15 = q7;
  function N6(r2) {
    var e = f8(r2), o6 = e.toRed(u12.mont(r2.modulus)).redPow(new u12(r2.publicExponent)).fromRed();
    return {
      blinder: o6,
      unblinder: e.invm(r2.modulus)
    };
  }
  function f8(r2) {
    var e = r2.modulus.byteLength(), o6;
    do
      o6 = new u12(E15(e));
    while (o6.cmp(r2.modulus) >= 0 || !o6.umod(r2.prime1) || !o6.umod(r2.prime2));
    return o6;
  }
  function s10(r2, e) {
    var o6 = N6(e), d14 = e.modulus.byteLength(), n3 = new u12(r2).mul(o6.blinder).umod(e.modulus), x17 = n3.toRed(u12.mont(e.prime1)), R13 = n3.toRed(u12.mont(e.prime2)), g17 = e.coefficient, h16 = e.prime1, q15 = e.prime2, y16 = x17.redPow(e.exponent1).fromRed(), t2 = R13.redPow(e.exponent2).fromRed(), $17 = y16.isub(t2).imul(g17).umod(h16).imul(q15);
    return t2.iadd($17).imul(o6.unblinder).umod(e.modulus).toArrayLike(Buffer2, "be", d14);
  }
  s10.getr = f8;
  b15.exports = s10;
});
var c10 = i9(m13());
var w16 = i9(m13());
var { getr: F4 } = w16;
var { default: j6, ...z7 } = w16;
var G2 = c10.default ?? j6 ?? z7;
var c11 = Object.create;
var a5 = Object.defineProperty;
var m14 = Object.getOwnPropertyDescriptor;
var q8 = Object.getOwnPropertyNames;
var v14 = Object.getPrototypeOf;
var _7 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var w17 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var $10 = (e, r2, t2, o6) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let i of q8(r2))
      !_7.call(e, i) && i !== t2 && a5(e, i, {
        get: () => r2[i],
        enumerable: !(o6 = m14(r2, i)) || o6.enumerable
      });
  return e;
};
var h10 = (e, r2, t2) => (t2 = e != null ? c11(v14(e)) : {}, $10(r2 || !e || !e.__esModule ? a5(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var n1 = w17((E15, d14) => {
  "use strict";
  var l22 = w, x17 = R2, y16 = X2, D12 = Ot, f8 = M4;
  function u12(e) {
    f8.call(this, "digest"), this._hash = e;
  }
  l22(u12, f8);
  u12.prototype._update = function(e) {
    this._hash.update(e);
  };
  u12.prototype._final = function() {
    return this._hash.digest();
  };
  d14.exports = function(r2) {
    return r2 = r2.toLowerCase(), r2 === "md5" ? new x17() : r2 === "rmd160" || r2 === "ripemd160" ? new y16() : new u12(D12(r2));
  };
});
var p16 = h10(n1());
var H3 = h10(n1());
var { default: M7, ...B10 } = H3;
var I8 = p16.default ?? M7 ?? B10;
var O4 = Object.create;
var D3 = Object.defineProperty;
var z8 = Object.getOwnPropertyDescriptor;
var G3 = Object.getOwnPropertyNames;
var J7 = Object.getPrototypeOf;
var Q4 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, a7) => (typeof require != "undefined" ? require : r2)[a7]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var l16 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var X3 = (e, r2, a7, t2) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let i of G3(r2))
      !Q4.call(e, i) && i !== a7 && D3(e, i, {
        get: () => r2[i],
        enumerable: !(t2 = z8(r2, i)) || t2.enumerable
      });
  return e;
};
var q9 = (e, r2, a7) => (a7 = e != null ? O4(J7(e)) : {}, X3(r2 || !e || !e.__esModule ? D3(a7, "default", {
  value: e,
  enumerable: true
}) : a7, e));
var E8 = l16((Sr, Y7) => {
  Y7.exports = {
    "1.3.132.0.10": "secp256k1",
    "1.3.132.0.33": "p224",
    "1.2.840.10045.3.1.1": "p192",
    "1.2.840.10045.3.1.7": "p256",
    "1.3.132.0.34": "p384",
    "1.3.132.0.35": "p521"
  };
});
var L9 = l16((Ar2, A14) => {
  var d14 = L1, p7 = J6, Z2 = G2, rr2 = ld.ec, S14 = ki, er2 = Ae1, ar2 = E8();
  function tr2(e, r2, a7, t2, i) {
    var s10 = er2(r2);
    if (s10.curve) {
      if (t2 !== "ecdsa" && t2 !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ir2(e, s10);
    } else if (s10.type === "dsa") {
      if (t2 !== "dsa")
        throw new Error("wrong private key type");
      return nr2(e, s10, a7);
    } else if (t2 !== "rsa" && t2 !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    e = d14.concat([
      i,
      e
    ]);
    for (var c13 = s10.modulus.byteLength(), n3 = [
      0,
      1
    ]; e.length + n3.length + 1 < c13; )
      n3.push(255);
    n3.push(0);
    for (var h16 = -1; ++h16 < e.length; )
      n3.push(e[h16]);
    var o6 = Z2(n3, s10);
    return o6;
  }
  function ir2(e, r2) {
    var a7 = ar2[r2.curve.join(".")];
    if (!a7)
      throw new Error("unknown curve " + r2.curve.join("."));
    var t2 = new rr2(a7), i = t2.keyFromPrivate(r2.privateKey), s10 = i.sign(e);
    return d14.from(s10.toDER());
  }
  function nr2(e, r2, a7) {
    for (var t2 = r2.params.priv_key, i = r2.params.p, s10 = r2.params.q, c13 = r2.params.g, n3 = new S14(0), h16, o6 = H9(e, s10).mod(s10), f8 = false, v19 = W2(t2, s10, e, a7); f8 === false; )
      h16 = x17(s10, v19, a7), n3 = dr2(c13, h16, i, s10), f8 = h16.invm(s10).imul(o6.add(t2.mul(n3))).mod(s10), f8.cmpn(0) === 0 && (f8 = false, n3 = new S14(0));
    return sr(n3, f8);
  }
  function sr(e, r2) {
    e = e.toArray(), r2 = r2.toArray(), e[0] & 128 && (e = [
      0
    ].concat(e)), r2[0] & 128 && (r2 = [
      0
    ].concat(r2));
    var a7 = e.length + r2.length + 4, t2 = [
      48,
      a7,
      2,
      e.length
    ];
    return t2 = t2.concat(e, [
      2,
      r2.length
    ], r2), d14.from(t2);
  }
  function W2(e, r2, a7, t2) {
    if (e = d14.from(e.toArray()), e.length < r2.byteLength()) {
      var i = d14.alloc(r2.byteLength() - e.length);
      e = d14.concat([
        i,
        e
      ]);
    }
    var s10 = a7.length, c13 = hr2(a7, r2), n3 = d14.alloc(s10);
    n3.fill(1);
    var h16 = d14.alloc(s10);
    return h16 = p7(t2, h16).update(n3).update(d14.from([
      0
    ])).update(e).update(c13).digest(), n3 = p7(t2, h16).update(n3).digest(), h16 = p7(t2, h16).update(n3).update(d14.from([
      1
    ])).update(e).update(c13).digest(), n3 = p7(t2, h16).update(n3).digest(), {
      k: h16,
      v: n3
    };
  }
  function H9(e, r2) {
    var a7 = new S14(e), t2 = (e.length << 3) - r2.bitLength();
    return t2 > 0 && a7.ishrn(t2), a7;
  }
  function hr2(e, r2) {
    e = H9(e, r2), e = e.mod(r2);
    var a7 = d14.from(e.toArray());
    if (a7.length < r2.byteLength()) {
      var t2 = d14.alloc(r2.byteLength() - a7.length);
      a7 = d14.concat([
        t2,
        a7
      ]);
    }
    return a7;
  }
  function x17(e, r2, a7) {
    var t2, i;
    do {
      for (t2 = d14.alloc(0); t2.length * 8 < e.bitLength(); )
        r2.v = p7(a7, r2.k).update(r2.v).digest(), t2 = d14.concat([
          t2,
          r2.v
        ]);
      i = H9(t2, e), r2.k = p7(a7, r2.k).update(r2.v).update(d14.from([
        0
      ])).digest(), r2.v = p7(a7, r2.k).update(r2.v).digest();
    } while (i.cmp(e) !== -1);
    return i;
  }
  function dr2(e, r2, a7, t2) {
    return e.toRed(S14.mont(a7)).redPow(r2).fromRed().mod(t2);
  }
  A14.exports = tr2;
  A14.exports.getKey = W2;
  A14.exports.makeKey = x17;
});
var K9 = l16((Rr2, I13) => {
  var k15 = L1, m20 = ki, or3 = ld.ec, B18 = Ae1, ur = E8();
  function cr(e, r2, a7, t2, i) {
    var s10 = B18(a7);
    if (s10.type === "ec") {
      if (t2 !== "ecdsa" && t2 !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return fr(e, r2, s10);
    } else if (s10.type === "dsa") {
      if (t2 !== "dsa")
        throw new Error("wrong public key type");
      return vr2(e, r2, s10);
    } else if (t2 !== "rsa" && t2 !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    r2 = k15.concat([
      i,
      r2
    ]);
    for (var c13 = s10.modulus.byteLength(), n3 = [
      1
    ], h16 = 0; r2.length + n3.length + 2 < c13; )
      n3.push(255), h16++;
    n3.push(0);
    for (var o6 = -1; ++o6 < r2.length; )
      n3.push(r2[o6]);
    n3 = k15.from(n3);
    var f8 = m20.mont(s10.modulus);
    e = new m20(e).toRed(f8), e = e.redPow(new m20(s10.publicExponent)), e = k15.from(e.fromRed().toArray());
    var v19 = h16 < 8 ? 1 : 0;
    for (c13 = Math.min(e.length, n3.length), e.length !== n3.length && (v19 = 1), o6 = -1; ++o6 < c13; )
      v19 |= e[o6] ^ n3[o6];
    return v19 === 0;
  }
  function fr(e, r2, a7) {
    var t2 = ur[a7.data.algorithm.curve.join(".")];
    if (!t2)
      throw new Error("unknown curve " + a7.data.algorithm.curve.join("."));
    var i = new or3(t2), s10 = a7.data.subjectPrivateKey.data;
    return i.verify(r2, e, s10);
  }
  function vr2(e, r2, a7) {
    var t2 = a7.data.p, i = a7.data.q, s10 = a7.data.g, c13 = a7.data.pub_key, n3 = B18.signature.decode(e, "der"), h16 = n3.s, o6 = n3.r;
    V8(h16, i), V8(o6, i);
    var f8 = m20.mont(t2), v19 = h16.invm(i), F12 = s10.toRed(f8).redPow(new m20(r2).mul(v19).mod(i)).fromRed().mul(c13.toRed(f8).redPow(o6.mul(v19).mod(i)).fromRed()).mod(t2).mod(i);
    return F12.cmp(o6) === 0;
  }
  function V8(e, r2) {
    if (e.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (e.cmp(r2) >= r2)
      throw new Error("invalid sig");
  }
  I13.exports = cr;
});
var P8 = l16((_r, pr2) => {
  pr2.exports = {
    sha224WithRSAEncryption: {
      sign: "rsa",
      hash: "sha224",
      id: "302d300d06096086480165030402040500041c"
    },
    "RSA-SHA224": {
      sign: "ecdsa/rsa",
      hash: "sha224",
      id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption: {
      sign: "rsa",
      hash: "sha256",
      id: "3031300d060960864801650304020105000420"
    },
    "RSA-SHA256": {
      sign: "ecdsa/rsa",
      hash: "sha256",
      id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption: {
      sign: "rsa",
      hash: "sha384",
      id: "3041300d060960864801650304020205000430"
    },
    "RSA-SHA384": {
      sign: "ecdsa/rsa",
      hash: "sha384",
      id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption: {
      sign: "rsa",
      hash: "sha512",
      id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA512": {
      sign: "ecdsa/rsa",
      hash: "sha512",
      id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
      sign: "rsa",
      hash: "sha1",
      id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
      sign: "ecdsa",
      hash: "sha1",
      id: ""
    },
    sha256: {
      sign: "ecdsa",
      hash: "sha256",
      id: ""
    },
    sha224: {
      sign: "ecdsa",
      hash: "sha224",
      id: ""
    },
    sha384: {
      sign: "ecdsa",
      hash: "sha384",
      id: ""
    },
    sha512: {
      sign: "ecdsa",
      hash: "sha512",
      id: ""
    },
    "DSA-SHA": {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    "DSA-SHA1": {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    DSA: {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    "DSA-WITH-SHA224": {
      sign: "dsa",
      hash: "sha224",
      id: ""
    },
    "DSA-SHA224": {
      sign: "dsa",
      hash: "sha224",
      id: ""
    },
    "DSA-WITH-SHA256": {
      sign: "dsa",
      hash: "sha256",
      id: ""
    },
    "DSA-SHA256": {
      sign: "dsa",
      hash: "sha256",
      id: ""
    },
    "DSA-WITH-SHA384": {
      sign: "dsa",
      hash: "sha384",
      id: ""
    },
    "DSA-SHA384": {
      sign: "dsa",
      hash: "sha384",
      id: ""
    },
    "DSA-WITH-SHA512": {
      sign: "dsa",
      hash: "sha512",
      id: ""
    },
    "DSA-SHA512": {
      sign: "dsa",
      hash: "sha512",
      id: ""
    },
    "DSA-RIPEMD160": {
      sign: "dsa",
      hash: "rmd160",
      id: ""
    },
    ripemd160WithRSA: {
      sign: "rsa",
      hash: "rmd160",
      id: "3021300906052b2403020105000414"
    },
    "RSA-RIPEMD160": {
      sign: "rsa",
      hash: "rmd160",
      id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption: {
      sign: "rsa",
      hash: "md5",
      id: "3020300c06082a864886f70d020505000410"
    },
    "RSA-MD5": {
      sign: "rsa",
      hash: "md5",
      id: "3020300c06082a864886f70d020505000410"
    }
  };
});
var b8 = l16((Er2, N6) => {
  var R13 = L1, $17 = I8, _11 = Hi, C11 = w, gr2 = L9(), lr = K9(), g17 = P8();
  Object.keys(g17).forEach(function(e) {
    g17[e].id = R13.from(g17[e].id, "hex"), g17[e.toLowerCase()] = g17[e];
  });
  function w110(e) {
    _11.Writable.call(this);
    var r2 = g17[e];
    if (!r2)
      throw new Error("Unknown message digest");
    this._hashType = r2.hash, this._hash = $17(r2.hash), this._tag = r2.id, this._signType = r2.sign;
  }
  C11(w110, _11.Writable);
  w110.prototype._write = function(r2, a7, t2) {
    this._hash.update(r2), t2();
  };
  w110.prototype.update = function(r2, a7) {
    return typeof r2 == "string" && (r2 = R13.from(r2, a7)), this._hash.update(r2), this;
  };
  w110.prototype.sign = function(r2, a7) {
    this.end();
    var t2 = this._hash.digest(), i = gr2(t2, r2, this._hashType, this._signType, this._tag);
    return a7 ? i.toString(a7) : i;
  };
  function y16(e) {
    _11.Writable.call(this);
    var r2 = g17[e];
    if (!r2)
      throw new Error("Unknown message digest");
    this._hash = $17(r2.hash), this._tag = r2.id, this._signType = r2.sign;
  }
  C11(y16, _11.Writable);
  y16.prototype._write = function(r2, a7, t2) {
    this._hash.update(r2), t2();
  };
  y16.prototype.update = function(r2, a7) {
    return typeof r2 == "string" && (r2 = R13.from(r2, a7)), this._hash.update(r2), this;
  };
  y16.prototype.verify = function(r2, a7, t2) {
    typeof a7 == "string" && (a7 = R13.from(a7, t2)), this.end();
    var i = this._hash.digest();
    return lr(a7, i, r2, this._signType, this._tag);
  };
  function j13(e) {
    return new w110(e);
  }
  function M14(e) {
    return new y16(e);
  }
  N6.exports = {
    Sign: j13,
    Verify: M14,
    createSign: j13,
    createVerify: M14
  };
});
var T7 = q9(b8());
var U5 = q9(b8());
var { createSign: Hr, Sign: kr, createVerify: br1, Verify: Dr } = U5;
var { default: mr1, ...wr1 } = U5;
var qr = T7.default ?? mr1 ?? wr1;
var M8 = Object.create;
var w18 = Object.defineProperty;
var $11 = Object.getOwnPropertyDescriptor;
var L10 = Object.getOwnPropertyNames;
var S7 = Object.getPrototypeOf;
var D4 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var P9 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var z9 = (e, r2, t2, o6) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let n3 of L10(r2))
      !D4.call(e, n3) && n3 !== t2 && w18(e, n3, {
        get: () => r2[n3],
        enumerable: !(o6 = $11(r2, n3)) || o6.enumerable
      });
  return e;
};
var R7 = (e, r2, t2) => (t2 = e != null ? M8(S7(e)) : {}, z9(r2 || !e || !e.__esModule ? w18(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var h11 = P9((E15, _11) => {
  var u12 = ki, j13 = C;
  function v19(e) {
    this.rand = e || new j13.Rand();
  }
  _11.exports = v19;
  v19.create = function(r2) {
    return new v19(r2);
  };
  v19.prototype._randbelow = function(r2) {
    var t2 = r2.bitLength(), o6 = Math.ceil(t2 / 8);
    do
      var n3 = new u12(this.rand.generate(o6));
    while (n3.cmp(r2) >= 0);
    return n3;
  };
  v19.prototype._randrange = function(r2, t2) {
    var o6 = t2.sub(r2);
    return r2.add(this._randbelow(o6));
  };
  v19.prototype.test = function(r2, t2, o6) {
    var n3 = r2.bitLength(), c13 = u12.mont(r2), p7 = new u12(1).toRed(c13);
    t2 || (t2 = Math.max(1, n3 / 48 | 0));
    for (var i = r2.subn(1), f8 = 0; !i.testn(f8); f8++)
      ;
    for (var s10 = r2.shrn(f8), m20 = i.toRed(c13), l22 = true; t2 > 0; t2--) {
      var a7 = this._randrange(new u12(2), i);
      o6 && o6(a7);
      var d14 = a7.toRed(c13).redPow(s10);
      if (!(d14.cmp(p7) === 0 || d14.cmp(m20) === 0)) {
        for (var b15 = 1; b15 < f8; b15++) {
          if (d14 = d14.redSqr(), d14.cmp(p7) === 0)
            return false;
          if (d14.cmp(m20) === 0)
            break;
        }
        if (b15 === f8)
          return false;
      }
    }
    return l22;
  };
  v19.prototype.getDivisor = function(r2, t2) {
    var o6 = r2.bitLength(), n3 = u12.mont(r2), c13 = new u12(1).toRed(n3);
    t2 || (t2 = Math.max(1, o6 / 48 | 0));
    for (var p7 = r2.subn(1), i = 0; !p7.testn(i); i++)
      ;
    for (var f8 = r2.shrn(i), s10 = p7.toRed(n3); t2 > 0; t2--) {
      var m20 = this._randrange(new u12(2), p7), l22 = r2.gcd(m20);
      if (l22.cmpn(1) !== 0)
        return l22;
      var a7 = m20.toRed(n3).redPow(f8);
      if (!(a7.cmp(c13) === 0 || a7.cmp(s10) === 0)) {
        for (var d14 = 1; d14 < i; d14++) {
          if (a7 = a7.redSqr(), a7.cmp(c13) === 0)
            return a7.fromRed().subn(1).gcd(r2);
          if (a7.cmp(s10) === 0)
            break;
        }
        if (d14 === i)
          return a7 = a7.redSqr(), a7.fromRed().subn(1).gcd(r2);
      }
    }
    return false;
  };
});
var q10 = R7(h11());
var y11 = R7(h11());
var { create: F5 } = y11;
var { default: A8, ...B11 } = y11;
var G4 = q10.default ?? A8 ?? B11;
var O5 = Object.create;
var B12 = Object.defineProperty;
var V3 = Object.getOwnPropertyDescriptor;
var L11 = Object.getOwnPropertyNames;
var M9 = Object.getPrototypeOf;
var F6 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (f8, a7) => (typeof require != "undefined" ? require : f8)[a7]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var s6 = (e, f8) => () => (f8 || e((f8 = {
  exports: {}
}).exports, f8), f8.exports);
var I9 = (e, f8, a7, c13) => {
  if (f8 && typeof f8 == "object" || typeof f8 == "function")
    for (let d14 of L11(f8))
      !F6.call(e, d14) && d14 !== a7 && B12(e, d14, {
        get: () => f8[d14],
        enumerable: !(c13 = V3(f8, d14)) || c13.enumerable
      });
  return e;
};
var g13 = (e, f8, a7) => (a7 = e != null ? O5(M9(e)) : {}, I9(f8 || !e || !e.__esModule ? B12(a7, "default", {
  value: e,
  enumerable: true
}) : a7, e));
var _8 = s6((we2, R13) => {
  var W2 = q7;
  R13.exports = w24;
  w24.simpleSieve = v19;
  w24.fermatTest = h16;
  var b15 = ki, $17 = new b15(24), U7 = G4, P13 = new U7(), A14 = new b15(1), p7 = new b15(2), Y7 = new b15(5), le3 = new b15(16), pe2 = new b15(8), X5 = new b15(10), k15 = new b15(3), ve2 = new b15(7), z15 = new b15(11), H9 = new b15(4), he3 = new b15(12), l22 = null;
  function J14() {
    if (l22 !== null)
      return l22;
    var e = 1048576, f8 = [];
    f8[0] = 2;
    for (var a7 = 1, c13 = 3; c13 < e; c13 += 2) {
      for (var d14 = Math.ceil(Math.sqrt(c13)), i = 0; i < a7 && f8[i] <= d14 && c13 % f8[i] !== 0; i++)
        ;
      a7 !== i && f8[i] <= d14 || (f8[a7++] = c13);
    }
    return l22 = f8, f8;
  }
  function v19(e) {
    for (var f8 = J14(), a7 = 0; a7 < f8.length; a7++)
      if (e.modn(f8[a7]) === 0)
        return e.cmpn(f8[a7]) === 0;
    return true;
  }
  function h16(e) {
    var f8 = b15.mont(e);
    return p7.toRed(f8).redPow(e.subn(1)).fromRed().cmpn(1) === 0;
  }
  function w24(e, f8) {
    if (e < 16)
      return f8 === 2 || f8 === 5 ? new b15([
        140,
        123
      ]) : new b15([
        140,
        39
      ]);
    f8 = new b15(f8);
    for (var a7, c13; ; ) {
      for (a7 = new b15(W2(Math.ceil(e / 8))); a7.bitLength() > e; )
        a7.ishrn(1);
      if (a7.isEven() && a7.iadd(A14), a7.testn(1) || a7.iadd(p7), f8.cmp(p7)) {
        if (!f8.cmp(Y7))
          for (; a7.mod(X5).cmp(k15); )
            a7.iadd(H9);
      } else
        for (; a7.mod($17).cmp(z15); )
          a7.iadd(H9);
      if (c13 = a7.shrn(1), v19(c13) && v19(a7) && h16(c13) && h16(a7) && P13.test(c13) && P13.test(a7))
        return a7;
    }
  }
});
var D5 = s6((_e2, Q9) => {
  Q9.exports = {
    modp1: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    modp2: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    modp5: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    modp14: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    modp15: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    modp16: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    modp17: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    modp18: {
      gen: "02",
      prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
  };
});
var S8 = s6((ye4, N6) => {
  var r2 = ki, Z2 = G4, T12 = new Z2(), j13 = new r2(24), ee2 = new r2(11), fe4 = new r2(10), ae3 = new r2(3), ce4 = new r2(7), x17 = _8(), de2 = q7;
  N6.exports = t2;
  function be3(e, f8) {
    return f8 = f8 || "utf8", Buffer2.isBuffer(e) || (e = new Buffer2(e, f8)), this._pub = new r2(e), this;
  }
  function re4(e, f8) {
    return f8 = f8 || "utf8", Buffer2.isBuffer(e) || (e = new Buffer2(e, f8)), this._priv = new r2(e), this;
  }
  var o6 = {};
  function ie3(e, f8) {
    var a7 = f8.toString("hex"), c13 = [
      a7,
      e.toString(16)
    ].join("_");
    if (c13 in o6)
      return o6[c13];
    var d14 = 0;
    if (e.isEven() || !x17.simpleSieve || !x17.fermatTest(e) || !T12.test(e))
      return d14 += 1, a7 === "02" || a7 === "05" ? d14 += 8 : d14 += 4, o6[c13] = d14, d14;
    T12.test(e.shrn(1)) || (d14 += 2);
    var i;
    switch (a7) {
      case "02":
        e.mod(j13).cmp(ee2) && (d14 += 8);
        break;
      case "05":
        i = e.mod(fe4), i.cmp(ae3) && i.cmp(ce4) && (d14 += 8);
        break;
      default:
        d14 += 4;
    }
    return o6[c13] = d14, d14;
  }
  function t2(e, f8, a7) {
    this.setGenerator(f8), this.__prime = new r2(e), this._prime = r2.mont(this.__prime), this._primeLen = e.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, a7 ? (this.setPublicKey = be3, this.setPrivateKey = re4) : this._primeCode = 8;
  }
  Object.defineProperty(t2.prototype, "verifyError", {
    enumerable: true,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ie3(this.__prime, this.__gen)), this._primeCode;
    }
  });
  t2.prototype.generateKeys = function() {
    return this._priv || (this._priv = new r2(de2(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  t2.prototype.computeSecret = function(e) {
    e = new r2(e), e = e.toRed(this._prime);
    var f8 = e.redPow(this._priv).fromRed(), a7 = new Buffer2(f8.toArray()), c13 = this.getPrime();
    if (a7.length < c13.length) {
      var d14 = new Buffer2(c13.length - a7.length);
      d14.fill(0), a7 = Buffer2.concat([
        d14,
        a7
      ]);
    }
    return a7;
  };
  t2.prototype.getPublicKey = function(f8) {
    return m20(this._pub, f8);
  };
  t2.prototype.getPrivateKey = function(f8) {
    return m20(this._priv, f8);
  };
  t2.prototype.getPrime = function(e) {
    return m20(this.__prime, e);
  };
  t2.prototype.getGenerator = function(e) {
    return m20(this._gen, e);
  };
  t2.prototype.setGenerator = function(e, f8) {
    return f8 = f8 || "utf8", Buffer2.isBuffer(e) || (e = new Buffer2(e, f8)), this.__gen = e, this._gen = new r2(e), this;
  };
  function m20(e, f8) {
    var a7 = new Buffer2(e.toArray());
    return f8 ? a7.toString(f8) : a7;
  }
});
var E9 = s6((u12) => {
  var te2 = _8(), q15 = D5(), y16 = S8();
  function ne2(e) {
    var f8 = new Buffer2(q15[e].prime, "hex"), a7 = new Buffer2(q15[e].gen, "hex");
    return new y16(f8, a7);
  }
  var ue4 = {
    binary: true,
    hex: true,
    base64: true
  };
  function K14(e, f8, a7, c13) {
    return Buffer2.isBuffer(f8) || ue4[f8] === void 0 ? K14(e, "binary", f8, a7) : (f8 = f8 || "binary", c13 = c13 || "binary", a7 = a7 || new Buffer2([
      2
    ]), Buffer2.isBuffer(a7) || (a7 = new Buffer2(a7, c13)), typeof e == "number" ? new y16(te2(e, a7), a7, true) : (Buffer2.isBuffer(e) || (e = new Buffer2(e, f8)), new y16(e, a7, true)));
  }
  u12.DiffieHellmanGroup = u12.createDiffieHellmanGroup = u12.getDiffieHellman = ne2;
  u12.createDiffieHellman = u12.DiffieHellman = K14;
});
var G5 = g13(E9());
var C5 = g13(E9());
var { DiffieHellmanGroup: Be1, createDiffieHellmanGroup: ge, getDiffieHellman: Pe2, createDiffieHellman: He2, DiffieHellman: Re1 } = C5;
var { default: se1, ...oe } = C5;
var De3 = G5.default ?? se1 ?? oe;
var y12 = Object.create;
var r = Object.defineProperty;
var m15 = Object.getOwnPropertyDescriptor;
var a6 = Object.getOwnPropertyNames;
var b9 = Object.getPrototypeOf;
var l17 = Object.prototype.hasOwnProperty;
var p17 = (d14, e) => () => (e || d14((e = {
  exports: {}
}).exports, e), e.exports);
var u8 = (d14, e, t2, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let c13 of a6(e))
      !l17.call(d14, c13) && c13 !== t2 && r(d14, c13, {
        get: () => e[c13],
        enumerable: !(i = m15(e, c13)) || i.enumerable
      });
  return d14;
};
var f5 = (d14, e, t2) => (t2 = d14 != null ? y12(b9(d14)) : {}, u8(e || !d14 || !d14.__esModule ? r(t2, "default", {
  value: d14,
  enumerable: true
}) : t2, d14));
var o3 = p17((s10) => {
  s10["des-ecb"] = {
    key: 8,
    iv: 0
  };
  s10["des-cbc"] = s10.des = {
    key: 8,
    iv: 8
  };
  s10["des-ede3-cbc"] = s10.des3 = {
    key: 24,
    iv: 8
  };
  s10["des-ede3"] = {
    key: 24,
    iv: 0
  };
  s10["des-ede-cbc"] = {
    key: 16,
    iv: 8
  };
  s10["des-ede"] = {
    key: 16,
    iv: 0
  };
});
var k8 = f5(o3());
var v15 = f5(o3());
var { des: h12, des3: j7 } = v15;
var { default: $12, ...n2 } = v15;
var q11 = k8.default ?? $12 ?? n2;
var H4 = Object.create;
var S9 = Object.defineProperty;
var J8 = Object.getOwnPropertyDescriptor;
var K10 = Object.getOwnPropertyNames;
var L12 = Object.getPrototypeOf;
var Q5 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, c13) => (typeof require != "undefined" ? require : r2)[c13]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var p18 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var V4 = (e, r2, c13, a7) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let t2 of K10(r2))
      !Q5.call(e, t2) && t2 !== c13 && S9(e, t2, {
        get: () => r2[t2],
        enumerable: !(a7 = J8(r2, t2)) || a7.enumerable
      });
  return e;
};
var A9 = (e, r2, c13) => (c13 = e != null ? H4(L12(e)) : {}, V4(r2 || !e || !e.__esModule ? S9(c13, "default", {
  value: e,
  enumerable: true
}) : c13, e));
var b10 = p18((B18) => {
  B18.encrypt = function(e, r2) {
    return e._cipher.encryptBlock(r2);
  };
  B18.decrypt = function(e, r2) {
    return e._cipher.decryptBlock(r2);
  };
});
var s7 = p18((_11) => {
  var g17 = i7;
  _11.encrypt = function(e, r2) {
    var c13 = g17(r2, e._prev);
    return e._prev = e._cipher.encryptBlock(c13), e._prev;
  };
  _11.decrypt = function(e, r2) {
    var c13 = e._prev;
    e._prev = r2;
    var a7 = e._cipher.decryptBlock(r2);
    return g17(a7, c13);
  };
});
var w19 = p18((F12) => {
  var h16 = L1, W2 = i7;
  function q15(e, r2, c13) {
    var a7 = r2.length, t2 = W2(r2, e._cache);
    return e._cache = e._cache.slice(a7), e._prev = h16.concat([
      e._prev,
      c13 ? r2 : t2
    ]), t2;
  }
  F12.encrypt = function(e, r2, c13) {
    for (var a7 = h16.allocUnsafe(0), t2; r2.length; )
      if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = h16.allocUnsafe(0)), e._cache.length <= r2.length)
        t2 = e._cache.length, a7 = h16.concat([
          a7,
          q15(e, r2.slice(0, t2), c13)
        ]), r2 = r2.slice(t2);
      else {
        a7 = h16.concat([
          a7,
          q15(e, r2, c13)
        ]);
        break;
      }
    return a7;
  };
});
var x13 = p18((U7) => {
  var d14 = L1;
  function X5(e, r2, c13) {
    var a7 = e._cipher.encryptBlock(e._prev), t2 = a7[0] ^ r2;
    return e._prev = d14.concat([
      e._prev.slice(1),
      d14.from([
        c13 ? r2 : t2
      ])
    ]), t2;
  }
  U7.encrypt = function(e, r2, c13) {
    for (var a7 = r2.length, t2 = d14.allocUnsafe(a7), i = -1; ++i < a7; )
      t2[i] = X5(e, r2[i], c13);
    return t2;
  };
});
var f6 = p18((I13) => {
  var y16 = L1;
  function Y7(e, r2, c13) {
    for (var a7, t2 = -1, i = 8, o6 = 0, v19, m20; ++t2 < i; )
      a7 = e._cipher.encryptBlock(e._prev), v19 = r2 & 1 << 7 - t2 ? 128 : 0, m20 = a7[0] ^ v19, o6 += (m20 & 128) >> t2 % 8, e._prev = Z2(e._prev, c13 ? v19 : m20);
    return o6;
  }
  function Z2(e, r2) {
    var c13 = e.length, a7 = -1, t2 = y16.allocUnsafe(e.length);
    for (e = y16.concat([
      e,
      y16.from([
        r2
      ])
    ]); ++a7 < c13; )
      t2[a7] = e[a7] << 1 | e[a7 + 1] >> 7;
    return t2;
  }
  I13.encrypt = function(e, r2, c13) {
    for (var a7 = r2.length, t2 = y16.allocUnsafe(a7), i = -1; ++i < a7; )
      t2[i] = Y7(e, r2[i], c13);
    return t2;
  };
});
var R8 = p18((M14) => {
  var P13 = i7;
  function ee2(e) {
    return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
  }
  M14.encrypt = function(e, r2) {
    for (; e._cache.length < r2.length; )
      e._cache = Buffer2.concat([
        e._cache,
        ee2(e)
      ]);
    var c13 = e._cache.slice(0, r2.length);
    return e._cache = e._cache.slice(r2.length), P13(r2, c13);
  };
});
var O6 = p18((de2, G11) => {
  function re4(e) {
    for (var r2 = e.length, c13; r2--; )
      if (c13 = e.readUInt8(r2), c13 === 255)
        e.writeUInt8(0, r2);
      else {
        c13++, e.writeUInt8(c13, r2);
        break;
      }
  }
  G11.exports = re4;
});
var l18 = p18(($17) => {
  var ce4 = i7, T12 = L1, te2 = O6();
  function ae3(e) {
    var r2 = e._cipher.encryptBlockRaw(e._prev);
    return te2(e._prev), r2;
  }
  var k15 = 16;
  $17.encrypt = function(e, r2) {
    var c13 = Math.ceil(r2.length / k15), a7 = e._cache.length;
    e._cache = T12.concat([
      e._cache,
      T12.allocUnsafe(c13 * k15)
    ]);
    for (var t2 = 0; t2 < c13; t2++) {
      var i = ae3(e), o6 = a7 + t2 * k15;
      e._cache.writeUInt32BE(i[0], o6 + 0), e._cache.writeUInt32BE(i[1], o6 + 4), e._cache.writeUInt32BE(i[2], o6 + 8), e._cache.writeUInt32BE(i[3], o6 + 12);
    }
    var v19 = e._cache.slice(0, r2.length);
    return e._cache = e._cache.slice(r2.length), ce4(r2, v19);
  };
});
var z10 = p18((le3, ie3) => {
  ie3.exports = {
    "aes-128-ecb": {
      cipher: "AES",
      key: 128,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-192-ecb": {
      cipher: "AES",
      key: 192,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-256-ecb": {
      cipher: "AES",
      key: 256,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-128-cbc": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-192-cbc": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-256-cbc": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes128: {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes192: {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes256: {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-128-cfb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-192-cfb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-256-cfb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-128-cfb8": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-192-cfb8": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-256-cfb8": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-128-cfb1": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-192-cfb1": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-256-cfb1": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-128-ofb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-192-ofb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-256-ofb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-128-ctr": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-192-ctr": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-256-ctr": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-128-gcm": {
      cipher: "AES",
      key: 128,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-192-gcm": {
      cipher: "AES",
      key: 192,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-256-gcm": {
      cipher: "AES",
      key: 256,
      iv: 12,
      mode: "GCM",
      type: "auth"
    }
  };
});
var E10 = p18((Ce, N6) => {
  var pe2 = {
    ECB: b10(),
    CBC: s7(),
    CFB: w19(),
    CFB8: x13(),
    CFB1: f6(),
    OFB: R8(),
    CTR: l18(),
    GCM: l18()
  }, u12 = z10();
  for (C11 in u12)
    u12[C11].module = pe2[u12[C11].mode];
  var C11;
  N6.exports = u12;
});
var j8 = A9(E10());
var D6 = A9(E10());
var { aes128: Ee, aes192: Se, aes256: Ae2 } = D6;
var { default: ne, ...oe1 } = D6;
var be2 = j8.default ?? ne ?? oe1;
var He3 = Object.create;
var ie1 = Object.defineProperty;
var Ke1 = Object.getOwnPropertyDescriptor;
var Le4 = Object.getOwnPropertyNames;
var $e1 = Object.getPrototypeOf;
var Pe3 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, t2) => (typeof require != "undefined" ? require : r2)[t2]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var l19 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var Ze1 = (e, r2, t2, i) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let a7 of Le4(r2))
      !Pe3.call(e, a7) && a7 !== t2 && ie1(e, a7, {
        get: () => r2[a7],
        enumerable: !(i = Ke1(r2, a7)) || i.enumerable
      });
  return e;
};
var ae1 = (e, r2, t2) => (t2 = e != null ? He3($e1(e)) : {}, Ze1(r2 || !e || !e.__esModule ? ie1(t2, "default", {
  value: e,
  enumerable: true
}) : t2, e));
var ce2 = l19((O9) => {
  O9.encrypt = function(e, r2) {
    return e._cipher.encryptBlock(r2);
  };
  O9.decrypt = function(e, r2) {
    return e._cipher.decryptBlock(r2);
  };
});
var he1 = l19((M14) => {
  var ne2 = i7;
  M14.encrypt = function(e, r2) {
    var t2 = ne2(r2, e._prev);
    return e._prev = e._cipher.encryptBlock(t2), e._prev;
  };
  M14.decrypt = function(e, r2) {
    var t2 = e._prev;
    e._prev = r2;
    var i = e._cipher.decryptBlock(r2);
    return ne2(i, t2);
  };
});
var ue2 = l19((pe2) => {
  var I13 = L1, We2 = i7;
  function oe3(e, r2, t2) {
    var i = r2.length, a7 = We2(r2, e._cache);
    return e._cache = e._cache.slice(i), e._prev = I13.concat([
      e._prev,
      t2 ? r2 : a7
    ]), a7;
  }
  pe2.encrypt = function(e, r2, t2) {
    for (var i = I13.allocUnsafe(0), a7; r2.length; )
      if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = I13.allocUnsafe(0)), e._cache.length <= r2.length)
        a7 = e._cache.length, i = I13.concat([
          i,
          oe3(e, r2.slice(0, a7), t2)
        ]), r2 = r2.slice(a7);
      else {
        i = I13.concat([
          i,
          oe3(e, r2, t2)
        ]);
        break;
      }
    return i;
  };
});
var fe2 = l19((se3) => {
  var G11 = L1;
  function Je(e, r2, t2) {
    var i = e._cipher.encryptBlock(e._prev), a7 = i[0] ^ r2;
    return e._prev = G11.concat([
      e._prev.slice(1),
      G11.from([
        t2 ? r2 : a7
      ])
    ]), a7;
  }
  se3.encrypt = function(e, r2, t2) {
    for (var i = r2.length, a7 = G11.allocUnsafe(i), c13 = -1; ++c13 < i; )
      a7[c13] = Je(e, r2[c13], t2);
    return a7;
  };
});
var le1 = l19((ve2) => {
  var D12 = L1;
  function Qe2(e, r2, t2) {
    for (var i, a7 = -1, c13 = 8, n3 = 0, h16, u12; ++a7 < c13; )
      i = e._cipher.encryptBlock(e._prev), h16 = r2 & 1 << 7 - a7 ? 128 : 0, u12 = i[0] ^ h16, n3 += (u12 & 128) >> a7 % 8, e._prev = Ye2(e._prev, t2 ? h16 : u12);
    return n3;
  }
  function Ye2(e, r2) {
    var t2 = e.length, i = -1, a7 = D12.allocUnsafe(e.length);
    for (e = D12.concat([
      e,
      D12.from([
        r2
      ])
    ]); ++i < t2; )
      a7[i] = e[i] << 1 | e[i + 1] >> 7;
    return a7;
  }
  ve2.encrypt = function(e, r2, t2) {
    for (var i = r2.length, a7 = D12.allocUnsafe(i), c13 = -1; ++c13 < i; )
      a7[c13] = Qe2(e, r2[c13], t2);
    return a7;
  };
});
var ye2 = l19((_e2) => {
  var je2 = i7;
  function er2(e) {
    return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
  }
  _e2.encrypt = function(e, r2) {
    for (; e._cache.length < r2.length; )
      e._cache = Buffer2.concat([
        e._cache,
        er2(e)
      ]);
    var t2 = e._cache.slice(0, r2.length);
    return e._cache = e._cache.slice(r2.length), je2(r2, t2);
  };
});
var z11 = l19((Hr2, de2) => {
  function rr2(e) {
    for (var r2 = e.length, t2; r2--; )
      if (t2 = e.readUInt8(r2), t2 === 255)
        e.writeUInt8(0, r2);
      else {
        t2++, e.writeUInt8(t2, r2);
        break;
      }
  }
  de2.exports = rr2;
});
var K11 = l19((Be2) => {
  var tr2 = i7, ge2 = L1, ir2 = z11();
  function ar2(e) {
    var r2 = e._cipher.encryptBlockRaw(e._prev);
    return ir2(e._prev), r2;
  }
  var H9 = 16;
  Be2.encrypt = function(e, r2) {
    var t2 = Math.ceil(r2.length / H9), i = e._cache.length;
    e._cache = ge2.concat([
      e._cache,
      ge2.allocUnsafe(t2 * H9)
    ]);
    for (var a7 = 0; a7 < t2; a7++) {
      var c13 = ar2(e), n3 = i + a7 * H9;
      e._cache.writeUInt32BE(c13[0], n3 + 0), e._cache.writeUInt32BE(c13[1], n3 + 4), e._cache.writeUInt32BE(c13[2], n3 + 8), e._cache.writeUInt32BE(c13[3], n3 + 12);
    }
    var h16 = e._cache.slice(0, r2.length);
    return e._cache = e._cache.slice(r2.length), tr2(r2, h16);
  };
});
var L13 = l19((Lr, cr) => {
  cr.exports = {
    "aes-128-ecb": {
      cipher: "AES",
      key: 128,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-192-ecb": {
      cipher: "AES",
      key: 192,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-256-ecb": {
      cipher: "AES",
      key: 256,
      iv: 0,
      mode: "ECB",
      type: "block"
    },
    "aes-128-cbc": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-192-cbc": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-256-cbc": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes128: {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes192: {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    aes256: {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CBC",
      type: "block"
    },
    "aes-128-cfb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-192-cfb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-256-cfb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB",
      type: "stream"
    },
    "aes-128-cfb8": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-192-cfb8": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-256-cfb8": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB8",
      type: "stream"
    },
    "aes-128-cfb1": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-192-cfb1": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-256-cfb1": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CFB1",
      type: "stream"
    },
    "aes-128-ofb": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-192-ofb": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-256-ofb": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "OFB",
      type: "stream"
    },
    "aes-128-ctr": {
      cipher: "AES",
      key: 128,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-192-ctr": {
      cipher: "AES",
      key: 192,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-256-ctr": {
      cipher: "AES",
      key: 256,
      iv: 16,
      mode: "CTR",
      type: "stream"
    },
    "aes-128-gcm": {
      cipher: "AES",
      key: 128,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-192-gcm": {
      cipher: "AES",
      key: 192,
      iv: 12,
      mode: "GCM",
      type: "auth"
    },
    "aes-256-gcm": {
      cipher: "AES",
      key: 256,
      iv: 12,
      mode: "GCM",
      type: "auth"
    }
  };
});
var P10 = l19(($r, me2) => {
  var nr2 = {
    ECB: ce2(),
    CBC: he1(),
    CFB: ue2(),
    CFB8: fe2(),
    CFB1: le1(),
    OFB: ye2(),
    CTR: K11(),
    GCM: K11()
  }, F12 = L13();
  for ($17 in F12)
    F12[$17].module = nr2[F12[$17].mode];
  var $17;
  me2.exports = F12;
});
var k9 = l19((Pr2, we2) => {
  var R13 = L1;
  function W2(e) {
    R13.isBuffer(e) || (e = R13.from(e));
    for (var r2 = e.length / 4 | 0, t2 = new Array(r2), i = 0; i < r2; i++)
      t2[i] = e.readUInt32BE(i * 4);
    return t2;
  }
  function Z2(e) {
    for (var r2 = 0; r2 < e.length; e++)
      e[r2] = 0;
  }
  function Ee2(e, r2, t2, i, a7) {
    for (var c13 = t2[0], n3 = t2[1], h16 = t2[2], u12 = t2[3], p7 = e[0] ^ r2[0], f8 = e[1] ^ r2[1], y16 = e[2] ^ r2[2], d14 = e[3] ^ r2[3], s10, C11, S14, x17, E15 = 4, te2 = 1; te2 < a7; te2++)
      s10 = c13[p7 >>> 24] ^ n3[f8 >>> 16 & 255] ^ h16[y16 >>> 8 & 255] ^ u12[d14 & 255] ^ r2[E15++], C11 = c13[f8 >>> 24] ^ n3[y16 >>> 16 & 255] ^ h16[d14 >>> 8 & 255] ^ u12[p7 & 255] ^ r2[E15++], S14 = c13[y16 >>> 24] ^ n3[d14 >>> 16 & 255] ^ h16[p7 >>> 8 & 255] ^ u12[f8 & 255] ^ r2[E15++], x17 = c13[d14 >>> 24] ^ n3[p7 >>> 16 & 255] ^ h16[f8 >>> 8 & 255] ^ u12[y16 & 255] ^ r2[E15++], p7 = s10, f8 = C11, y16 = S14, d14 = x17;
    return s10 = (i[p7 >>> 24] << 24 | i[f8 >>> 16 & 255] << 16 | i[y16 >>> 8 & 255] << 8 | i[d14 & 255]) ^ r2[E15++], C11 = (i[f8 >>> 24] << 24 | i[y16 >>> 16 & 255] << 16 | i[d14 >>> 8 & 255] << 8 | i[p7 & 255]) ^ r2[E15++], S14 = (i[y16 >>> 24] << 24 | i[d14 >>> 16 & 255] << 16 | i[p7 >>> 8 & 255] << 8 | i[f8 & 255]) ^ r2[E15++], x17 = (i[d14 >>> 24] << 24 | i[p7 >>> 16 & 255] << 16 | i[f8 >>> 8 & 255] << 8 | i[y16 & 255]) ^ r2[E15++], s10 = s10 >>> 0, C11 = C11 >>> 0, S14 = S14 >>> 0, x17 = x17 >>> 0, [
      s10,
      C11,
      S14,
      x17
    ];
  }
  var hr2 = [
    0,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    27,
    54
  ], v19 = function() {
    for (var e = new Array(256), r2 = 0; r2 < 256; r2++)
      r2 < 128 ? e[r2] = r2 << 1 : e[r2] = r2 << 1 ^ 283;
    for (var t2 = [], i = [], a7 = [
      [],
      [],
      [],
      []
    ], c13 = [
      [],
      [],
      [],
      []
    ], n3 = 0, h16 = 0, u12 = 0; u12 < 256; ++u12) {
      var p7 = h16 ^ h16 << 1 ^ h16 << 2 ^ h16 << 3 ^ h16 << 4;
      p7 = p7 >>> 8 ^ p7 & 255 ^ 99, t2[n3] = p7, i[p7] = n3;
      var f8 = e[n3], y16 = e[f8], d14 = e[y16], s10 = e[p7] * 257 ^ p7 * 16843008;
      a7[0][n3] = s10 << 24 | s10 >>> 8, a7[1][n3] = s10 << 16 | s10 >>> 16, a7[2][n3] = s10 << 8 | s10 >>> 24, a7[3][n3] = s10, s10 = d14 * 16843009 ^ y16 * 65537 ^ f8 * 257 ^ n3 * 16843008, c13[0][p7] = s10 << 24 | s10 >>> 8, c13[1][p7] = s10 << 16 | s10 >>> 16, c13[2][p7] = s10 << 8 | s10 >>> 24, c13[3][p7] = s10, n3 === 0 ? n3 = h16 = 1 : (n3 = f8 ^ e[e[e[d14 ^ f8]]], h16 ^= e[e[h16]]);
    }
    return {
      SBOX: t2,
      INV_SBOX: i,
      SUB_MIX: a7,
      INV_SUB_MIX: c13
    };
  }();
  function g17(e) {
    this._key = W2(e), this._reset();
  }
  g17.blockSize = 4 * 4;
  g17.keySize = 256 / 8;
  g17.prototype.blockSize = g17.blockSize;
  g17.prototype.keySize = g17.keySize;
  g17.prototype._reset = function() {
    for (var e = this._key, r2 = e.length, t2 = r2 + 6, i = (t2 + 1) * 4, a7 = [], c13 = 0; c13 < r2; c13++)
      a7[c13] = e[c13];
    for (c13 = r2; c13 < i; c13++) {
      var n3 = a7[c13 - 1];
      c13 % r2 === 0 ? (n3 = n3 << 8 | n3 >>> 24, n3 = v19.SBOX[n3 >>> 24] << 24 | v19.SBOX[n3 >>> 16 & 255] << 16 | v19.SBOX[n3 >>> 8 & 255] << 8 | v19.SBOX[n3 & 255], n3 ^= hr2[c13 / r2 | 0] << 24) : r2 > 6 && c13 % r2 === 4 && (n3 = v19.SBOX[n3 >>> 24] << 24 | v19.SBOX[n3 >>> 16 & 255] << 16 | v19.SBOX[n3 >>> 8 & 255] << 8 | v19.SBOX[n3 & 255]), a7[c13] = a7[c13 - r2] ^ n3;
    }
    for (var h16 = [], u12 = 0; u12 < i; u12++) {
      var p7 = i - u12, f8 = a7[p7 - (u12 % 4 ? 0 : 4)];
      u12 < 4 || p7 <= 4 ? h16[u12] = f8 : h16[u12] = v19.INV_SUB_MIX[0][v19.SBOX[f8 >>> 24]] ^ v19.INV_SUB_MIX[1][v19.SBOX[f8 >>> 16 & 255]] ^ v19.INV_SUB_MIX[2][v19.SBOX[f8 >>> 8 & 255]] ^ v19.INV_SUB_MIX[3][v19.SBOX[f8 & 255]];
    }
    this._nRounds = t2, this._keySchedule = a7, this._invKeySchedule = h16;
  };
  g17.prototype.encryptBlockRaw = function(e) {
    return e = W2(e), Ee2(e, this._keySchedule, v19.SUB_MIX, v19.SBOX, this._nRounds);
  };
  g17.prototype.encryptBlock = function(e) {
    var r2 = this.encryptBlockRaw(e), t2 = R13.allocUnsafe(16);
    return t2.writeUInt32BE(r2[0], 0), t2.writeUInt32BE(r2[1], 4), t2.writeUInt32BE(r2[2], 8), t2.writeUInt32BE(r2[3], 12), t2;
  };
  g17.prototype.decryptBlock = function(e) {
    e = W2(e);
    var r2 = e[1];
    e[1] = e[3], e[3] = r2;
    var t2 = Ee2(e, this._invKeySchedule, v19.INV_SUB_MIX, v19.INV_SBOX, this._nRounds), i = R13.allocUnsafe(16);
    return i.writeUInt32BE(t2[0], 0), i.writeUInt32BE(t2[3], 4), i.writeUInt32BE(t2[2], 8), i.writeUInt32BE(t2[1], 12), i;
  };
  g17.prototype.scrub = function() {
    Z2(this._keySchedule), Z2(this._invKeySchedule), Z2(this._key);
  };
  we2.exports.AES = g17;
});
var xe3 = l19((Zr, Se2) => {
  var A14 = L1, or3 = A14.alloc(16, 0);
  function pr2(e) {
    return [
      e.readUInt32BE(0),
      e.readUInt32BE(4),
      e.readUInt32BE(8),
      e.readUInt32BE(12)
    ];
  }
  function Ce(e) {
    var r2 = A14.allocUnsafe(16);
    return r2.writeUInt32BE(e[0] >>> 0, 0), r2.writeUInt32BE(e[1] >>> 0, 4), r2.writeUInt32BE(e[2] >>> 0, 8), r2.writeUInt32BE(e[3] >>> 0, 12), r2;
  }
  function q15(e) {
    this.h = e, this.state = A14.alloc(16, 0), this.cache = A14.allocUnsafe(0);
  }
  q15.prototype.ghash = function(e) {
    for (var r2 = -1; ++r2 < e.length; )
      this.state[r2] ^= e[r2];
    this._multiply();
  };
  q15.prototype._multiply = function() {
    for (var e = pr2(this.h), r2 = [
      0,
      0,
      0,
      0
    ], t2, i, a7, c13 = -1; ++c13 < 128; ) {
      for (i = (this.state[~~(c13 / 8)] & 1 << 7 - c13 % 8) !== 0, i && (r2[0] ^= e[0], r2[1] ^= e[1], r2[2] ^= e[2], r2[3] ^= e[3]), a7 = (e[3] & 1) !== 0, t2 = 3; t2 > 0; t2--)
        e[t2] = e[t2] >>> 1 | (e[t2 - 1] & 1) << 31;
      e[0] = e[0] >>> 1, a7 && (e[0] = e[0] ^ 225 << 24);
    }
    this.state = Ce(r2);
  };
  q15.prototype.update = function(e) {
    this.cache = A14.concat([
      this.cache,
      e
    ]);
    for (var r2; this.cache.length >= 16; )
      r2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(r2);
  };
  q15.prototype.final = function(e, r2) {
    return this.cache.length && this.ghash(A14.concat([
      this.cache,
      or3
    ], 16)), this.ghash(Ce([
      0,
      e,
      0,
      r2
    ])), this.state;
  };
  Se2.exports = q15;
});
var J9 = l19((Wr, Ie) => {
  var ur = k9(), _11 = L1, Ae3 = M4, sr = w, Ue2 = xe3(), fr = i7, vr2 = z11();
  function lr(e, r2) {
    var t2 = 0;
    e.length !== r2.length && t2++;
    for (var i = Math.min(e.length, r2.length), a7 = 0; a7 < i; ++a7)
      t2 += e[a7] ^ r2[a7];
    return t2;
  }
  function _r(e, r2, t2) {
    if (r2.length === 12)
      return e._finID = _11.concat([
        r2,
        _11.from([
          0,
          0,
          0,
          1
        ])
      ]), _11.concat([
        r2,
        _11.from([
          0,
          0,
          0,
          2
        ])
      ]);
    var i = new Ue2(t2), a7 = r2.length, c13 = a7 % 16;
    i.update(r2), c13 && (c13 = 16 - c13, i.update(_11.alloc(c13, 0))), i.update(_11.alloc(8, 0));
    var n3 = a7 * 8, h16 = _11.alloc(8);
    h16.writeUIntBE(n3, 0, 8), i.update(h16), e._finID = i.state;
    var u12 = _11.from(e._finID);
    return vr2(u12), u12;
  }
  function w110(e, r2, t2, i) {
    Ae3.call(this);
    var a7 = _11.alloc(4, 0);
    this._cipher = new ur.AES(r2);
    var c13 = this._cipher.encryptBlock(a7);
    this._ghash = new Ue2(c13), t2 = _r(this, t2, c13), this._prev = _11.from(t2), this._cache = _11.allocUnsafe(0), this._secCache = _11.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = false;
  }
  sr(w110, Ae3);
  w110.prototype._update = function(e) {
    if (!this._called && this._alen) {
      var r2 = 16 - this._alen % 16;
      r2 < 16 && (r2 = _11.alloc(r2, 0), this._ghash.update(r2));
    }
    this._called = true;
    var t2 = this._mode.encrypt(this, e);
    return this._decrypt ? this._ghash.update(e) : this._ghash.update(t2), this._len += e.length, t2;
  };
  w110.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var e = fr(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && lr(e, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = e, this._cipher.scrub();
  };
  w110.prototype.getAuthTag = function() {
    if (this._decrypt || !_11.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  w110.prototype.setAuthTag = function(r2) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = r2;
  };
  w110.prototype.setAAD = function(r2) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(r2), this._alen += r2.length;
  };
  Ie.exports = w110;
});
var Y5 = l19((Jr, qe4) => {
  var yr2 = k9(), Q9 = L1, ke3 = M4, dr2 = w;
  function X5(e, r2, t2, i) {
    ke3.call(this), this._cipher = new yr2.AES(r2), this._prev = Q9.from(t2), this._cache = Q9.allocUnsafe(0), this._secCache = Q9.allocUnsafe(0), this._decrypt = i, this._mode = e;
  }
  dr2(X5, ke3);
  X5.prototype._update = function(e) {
    return this._mode.encrypt(this, e, this._decrypt);
  };
  X5.prototype._final = function() {
    this._cipher.scrub();
  };
  qe4.exports = X5;
});
var Fe2 = l19((j13) => {
  var be3 = P10(), gr2 = J9(), m20 = L1, Br2 = Y5(), Te = M4, mr2 = k9(), Er2 = j3, wr2 = w;
  function b15(e, r2, t2) {
    Te.call(this), this._cache = new N6(), this._cipher = new mr2.AES(r2), this._prev = m20.from(t2), this._mode = e, this._autopadding = true;
  }
  wr2(b15, Te);
  b15.prototype._update = function(e) {
    this._cache.add(e);
    for (var r2, t2, i = []; r2 = this._cache.get(); )
      t2 = this._mode.encrypt(this, r2), i.push(t2);
    return m20.concat(i);
  };
  var Cr = m20.alloc(16, 16);
  b15.prototype._final = function() {
    var e = this._cache.flush();
    if (this._autopadding)
      return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
    if (!e.equals(Cr))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  b15.prototype.setAutoPadding = function(e) {
    return this._autopadding = !!e, this;
  };
  function N6() {
    this.cache = m20.allocUnsafe(0);
  }
  N6.prototype.add = function(e) {
    this.cache = m20.concat([
      this.cache,
      e
    ]);
  };
  N6.prototype.get = function() {
    if (this.cache.length > 15) {
      var e = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), e;
    }
    return null;
  };
  N6.prototype.flush = function() {
    for (var e = 16 - this.cache.length, r2 = m20.allocUnsafe(e), t2 = -1; ++t2 < e; )
      r2.writeUInt8(e, t2);
    return m20.concat([
      this.cache,
      r2
    ]);
  };
  function De5(e, r2, t2) {
    var i = be3[e.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof r2 == "string" && (r2 = m20.from(r2)), r2.length !== i.key / 8)
      throw new TypeError("invalid key length " + r2.length);
    if (typeof t2 == "string" && (t2 = m20.from(t2)), i.mode !== "GCM" && t2.length !== i.iv)
      throw new TypeError("invalid iv length " + t2.length);
    return i.type === "stream" ? new Br2(i.module, r2, t2) : i.type === "auth" ? new gr2(i.module, r2, t2) : new b15(i.module, r2, t2);
  }
  function Sr(e, r2) {
    var t2 = be3[e.toLowerCase()];
    if (!t2)
      throw new TypeError("invalid suite type");
    var i = Er2(r2, false, t2.key, t2.iv);
    return De5(e, i.key, i.iv);
  }
  j13.createCipheriv = De5;
  j13.createCipher = Sr;
});
var Ve2 = l19((ee2) => {
  var xr2 = J9(), U7 = L1, Re2 = P10(), Ar2 = Y5(), Xe = M4, Ur = k9(), Ir = j3, kr2 = w;
  function T12(e, r2, t2) {
    Xe.call(this), this._cache = new V8(), this._last = void 0, this._cipher = new Ur.AES(r2), this._prev = U7.from(t2), this._mode = e, this._autopadding = true;
  }
  kr2(T12, Xe);
  T12.prototype._update = function(e) {
    this._cache.add(e);
    for (var r2, t2, i = []; r2 = this._cache.get(this._autopadding); )
      t2 = this._mode.decrypt(this, r2), i.push(t2);
    return U7.concat(i);
  };
  T12.prototype._final = function() {
    var e = this._cache.flush();
    if (this._autopadding)
      return qr2(this._mode.decrypt(this, e));
    if (e)
      throw new Error("data not multiple of block length");
  };
  T12.prototype.setAutoPadding = function(e) {
    return this._autopadding = !!e, this;
  };
  function V8() {
    this.cache = U7.allocUnsafe(0);
  }
  V8.prototype.add = function(e) {
    this.cache = U7.concat([
      this.cache,
      e
    ]);
  };
  V8.prototype.get = function(e) {
    var r2;
    if (e) {
      if (this.cache.length > 16)
        return r2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r2;
    } else if (this.cache.length >= 16)
      return r2 = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r2;
    return null;
  };
  V8.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function qr2(e) {
    var r2 = e[15];
    if (r2 < 1 || r2 > 16)
      throw new Error("unable to decrypt data");
    for (var t2 = -1; ++t2 < r2; )
      if (e[t2 + (16 - r2)] !== r2)
        throw new Error("unable to decrypt data");
    if (r2 !== 16)
      return e.slice(0, 16 - r2);
  }
  function Ne(e, r2, t2) {
    var i = Re2[e.toLowerCase()];
    if (!i)
      throw new TypeError("invalid suite type");
    if (typeof t2 == "string" && (t2 = U7.from(t2)), i.mode !== "GCM" && t2.length !== i.iv)
      throw new TypeError("invalid iv length " + t2.length);
    if (typeof r2 == "string" && (r2 = U7.from(r2)), r2.length !== i.key / 8)
      throw new TypeError("invalid key length " + r2.length);
    return i.type === "stream" ? new Ar2(i.module, r2, t2, true) : i.type === "auth" ? new xr2(i.module, r2, t2, true) : new T12(i.module, r2, t2);
  }
  function br3(e, r2) {
    var t2 = Re2[e.toLowerCase()];
    if (!t2)
      throw new TypeError("invalid suite type");
    var i = Ir(r2, false, t2.key, t2.iv);
    return Ne(e, i.key, i.iv);
  }
  ee2.createDecipher = br3;
  ee2.createDecipheriv = Ne;
});
var re2 = l19((B18) => {
  var Oe = Fe2(), Me = Ve2(), Tr = L13();
  function Dr2() {
    return Object.keys(Tr);
  }
  B18.createCipher = B18.Cipher = Oe.createCipher;
  B18.createCipheriv = B18.Cipheriv = Oe.createCipheriv;
  B18.createDecipher = B18.Decipher = Me.createDecipher;
  B18.createDecipheriv = B18.Decipheriv = Me.createDecipheriv;
  B18.listCiphers = B18.getCiphers = Dr2;
});
var Ge1 = ae1(re2());
var ze2 = ae1(re2());
var { createCipher: et1, Cipher: rt2, createCipheriv: tt2, Cipheriv: it2, createDecipher: at1, Decipher: ct2, createDecipheriv: nt1, Decipheriv: ht3, listCiphers: ot1, getCiphers: pt1 } = ze2;
var { default: Fr1, ...Rr1 } = ze2;
var ut2 = Ge1.default ?? Fr1 ?? Rr1;
var G6 = Object.create;
var I10 = Object.defineProperty;
var H5 = Object.getOwnPropertyDescriptor;
var J10 = Object.getOwnPropertyNames;
var L14 = Object.getPrototypeOf;
var Q6 = Object.prototype.hasOwnProperty;
((u12) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(u12, {
  get: (t2, r2) => (typeof require != "undefined" ? require : t2)[r2]
}) : u12)(function(u12) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + u12 + '" is not supported');
});
var _9 = (u12, t2) => () => (t2 || u12((t2 = {
  exports: {}
}).exports, t2), t2.exports);
var R9 = (u12, t2, r2, e) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let i of J10(t2))
      !Q6.call(u12, i) && i !== r2 && I10(u12, i, {
        get: () => t2[i],
        enumerable: !(e = H5(t2, i)) || e.enumerable
      });
  return u12;
};
var D7 = (u12, t2, r2) => (r2 = u12 != null ? G6(L14(u12)) : {}, R9(t2 || !u12 || !u12.__esModule ? I10(r2, "default", {
  value: u12,
  enumerable: true
}) : r2, u12));
var w20 = _9((f8) => {
  "use strict";
  f8.readUInt32BE = function(t2, r2) {
    var e = t2[0 + r2] << 24 | t2[1 + r2] << 16 | t2[2 + r2] << 8 | t2[3 + r2];
    return e >>> 0;
  };
  f8.writeUInt32BE = function(t2, r2, e) {
    t2[0 + e] = r2 >>> 24, t2[1 + e] = r2 >>> 16 & 255, t2[2 + e] = r2 >>> 8 & 255, t2[3 + e] = r2 & 255;
  };
  f8.ip = function(t2, r2, e, i) {
    for (var a7 = 0, p7 = 0, s10 = 6; s10 >= 0; s10 -= 2) {
      for (var n3 = 0; n3 <= 24; n3 += 8)
        a7 <<= 1, a7 |= r2 >>> n3 + s10 & 1;
      for (var n3 = 0; n3 <= 24; n3 += 8)
        a7 <<= 1, a7 |= t2 >>> n3 + s10 & 1;
    }
    for (var s10 = 6; s10 >= 0; s10 -= 2) {
      for (var n3 = 1; n3 <= 25; n3 += 8)
        p7 <<= 1, p7 |= r2 >>> n3 + s10 & 1;
      for (var n3 = 1; n3 <= 25; n3 += 8)
        p7 <<= 1, p7 |= t2 >>> n3 + s10 & 1;
    }
    e[i + 0] = a7 >>> 0, e[i + 1] = p7 >>> 0;
  };
  f8.rip = function(t2, r2, e, i) {
    for (var a7 = 0, p7 = 0, s10 = 0; s10 < 4; s10++)
      for (var n3 = 24; n3 >= 0; n3 -= 8)
        a7 <<= 1, a7 |= r2 >>> n3 + s10 & 1, a7 <<= 1, a7 |= t2 >>> n3 + s10 & 1;
    for (var s10 = 4; s10 < 8; s10++)
      for (var n3 = 24; n3 >= 0; n3 -= 8)
        p7 <<= 1, p7 |= r2 >>> n3 + s10 & 1, p7 <<= 1, p7 |= t2 >>> n3 + s10 & 1;
    e[i + 0] = a7 >>> 0, e[i + 1] = p7 >>> 0;
  };
  f8.pc1 = function(t2, r2, e, i) {
    for (var a7 = 0, p7 = 0, s10 = 7; s10 >= 5; s10--) {
      for (var n3 = 0; n3 <= 24; n3 += 8)
        a7 <<= 1, a7 |= r2 >> n3 + s10 & 1;
      for (var n3 = 0; n3 <= 24; n3 += 8)
        a7 <<= 1, a7 |= t2 >> n3 + s10 & 1;
    }
    for (var n3 = 0; n3 <= 24; n3 += 8)
      a7 <<= 1, a7 |= r2 >> n3 + s10 & 1;
    for (var s10 = 1; s10 <= 3; s10++) {
      for (var n3 = 0; n3 <= 24; n3 += 8)
        p7 <<= 1, p7 |= r2 >> n3 + s10 & 1;
      for (var n3 = 0; n3 <= 24; n3 += 8)
        p7 <<= 1, p7 |= t2 >> n3 + s10 & 1;
    }
    for (var n3 = 0; n3 <= 24; n3 += 8)
      p7 <<= 1, p7 |= t2 >> n3 + s10 & 1;
    e[i + 0] = a7 >>> 0, e[i + 1] = p7 >>> 0;
  };
  f8.r28shl = function(t2, r2) {
    return t2 << r2 & 268435455 | t2 >>> 28 - r2;
  };
  var S14 = [
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  f8.pc2 = function(t2, r2, e, i) {
    for (var a7 = 0, p7 = 0, s10 = S14.length >>> 1, n3 = 0; n3 < s10; n3++)
      a7 <<= 1, a7 |= t2 >>> S14[n3] & 1;
    for (var n3 = s10; n3 < S14.length; n3++)
      p7 <<= 1, p7 |= r2 >>> S14[n3] & 1;
    e[i + 0] = a7 >>> 0, e[i + 1] = p7 >>> 0;
  };
  f8.expand = function(t2, r2, e) {
    var i = 0, a7 = 0;
    i = (t2 & 1) << 5 | t2 >>> 27;
    for (var p7 = 23; p7 >= 15; p7 -= 4)
      i <<= 6, i |= t2 >>> p7 & 63;
    for (var p7 = 11; p7 >= 3; p7 -= 4)
      a7 |= t2 >>> p7 & 63, a7 <<= 6;
    a7 |= (t2 & 31) << 1 | t2 >>> 31, r2[e + 0] = i >>> 0, r2[e + 1] = a7 >>> 0;
  };
  var C11 = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  f8.substitute = function(t2, r2) {
    for (var e = 0, i = 0; i < 4; i++) {
      var a7 = t2 >>> 18 - i * 6 & 63, p7 = C11[i * 64 + a7];
      e <<= 4, e |= p7;
    }
    for (var i = 0; i < 4; i++) {
      var a7 = r2 >>> 18 - i * 6 & 63, p7 = C11[4 * 64 + i * 64 + a7];
      e <<= 4, e |= p7;
    }
    return e >>> 0;
  };
  var U7 = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  f8.permute = function(t2) {
    for (var r2 = 0, e = 0; e < U7.length; e++)
      r2 <<= 1, r2 |= t2 >>> U7[e] & 1;
    return r2 >>> 0;
  };
  f8.padSplit = function(t2, r2, e) {
    for (var i = t2.toString(2); i.length < r2; )
      i = "0" + i;
    for (var a7 = [], p7 = 0; p7 < r2; p7 += e)
      a7.push(i.slice(p7, p7 + e));
    return a7.join(" ");
  };
});
var g14 = _9((ct3, A14) => {
  "use strict";
  var W2 = j;
  function c13(u12) {
    this.options = u12, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  A14.exports = c13;
  c13.prototype._init = function() {
  };
  c13.prototype.update = function(t2) {
    return t2.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(t2) : this._updateEncrypt(t2);
  };
  c13.prototype._buffer = function(t2, r2) {
    for (var e = Math.min(this.buffer.length - this.bufferOff, t2.length - r2), i = 0; i < e; i++)
      this.buffer[this.bufferOff + i] = t2[r2 + i];
    return this.bufferOff += e, e;
  };
  c13.prototype._flushBuffer = function(t2, r2) {
    return this._update(this.buffer, 0, t2, r2), this.bufferOff = 0, this.blockSize;
  };
  c13.prototype._updateEncrypt = function(t2) {
    var r2 = 0, e = 0, i = (this.bufferOff + t2.length) / this.blockSize | 0, a7 = new Array(i * this.blockSize);
    this.bufferOff !== 0 && (r2 += this._buffer(t2, r2), this.bufferOff === this.buffer.length && (e += this._flushBuffer(a7, e)));
    for (var p7 = t2.length - (t2.length - r2) % this.blockSize; r2 < p7; r2 += this.blockSize)
      this._update(t2, r2, a7, e), e += this.blockSize;
    for (; r2 < t2.length; r2++, this.bufferOff++)
      this.buffer[this.bufferOff] = t2[r2];
    return a7;
  };
  c13.prototype._updateDecrypt = function(t2) {
    for (var r2 = 0, e = 0, i = Math.ceil((this.bufferOff + t2.length) / this.blockSize) - 1, a7 = new Array(i * this.blockSize); i > 0; i--)
      r2 += this._buffer(t2, r2), e += this._flushBuffer(a7, e);
    return r2 += this._buffer(t2, r2), a7;
  };
  c13.prototype.final = function(t2) {
    var r2;
    t2 && (r2 = this.update(t2));
    var e;
    return this.type === "encrypt" ? e = this._finalEncrypt() : e = this._finalDecrypt(), r2 ? r2.concat(e) : e;
  };
  c13.prototype._pad = function(t2, r2) {
    if (r2 === 0)
      return false;
    for (; r2 < t2.length; )
      t2[r2++] = 0;
    return true;
  };
  c13.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var t2 = new Array(this.blockSize);
    return this._update(this.buffer, 0, t2, 0), t2;
  };
  c13.prototype._unpad = function(t2) {
    return t2;
  };
  c13.prototype._finalDecrypt = function() {
    W2.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var t2 = new Array(this.blockSize);
    return this._flushBuffer(t2, 0), this._unpad(t2);
  };
});
var B13 = _9((ht4, $17) => {
  "use strict";
  var O9 = j, X5 = w, o6 = w20(), j13 = g14();
  function Y7() {
    this.tmp = new Array(2), this.keys = null;
  }
  function h16(u12) {
    j13.call(this, u12);
    var t2 = new Y7();
    this._desState = t2, this.deriveKeys(t2, u12.key);
  }
  X5(h16, j13);
  $17.exports = h16;
  h16.create = function(t2) {
    return new h16(t2);
  };
  var Z2 = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  h16.prototype.deriveKeys = function(t2, r2) {
    t2.keys = new Array(16 * 2), O9.equal(r2.length, this.blockSize, "Invalid key length");
    var e = o6.readUInt32BE(r2, 0), i = o6.readUInt32BE(r2, 4);
    o6.pc1(e, i, t2.tmp, 0), e = t2.tmp[0], i = t2.tmp[1];
    for (var a7 = 0; a7 < t2.keys.length; a7 += 2) {
      var p7 = Z2[a7 >>> 1];
      e = o6.r28shl(e, p7), i = o6.r28shl(i, p7), o6.pc2(e, i, t2.keys, a7);
    }
  };
  h16.prototype._update = function(t2, r2, e, i) {
    var a7 = this._desState, p7 = o6.readUInt32BE(t2, r2), s10 = o6.readUInt32BE(t2, r2 + 4);
    o6.ip(p7, s10, a7.tmp, 0), p7 = a7.tmp[0], s10 = a7.tmp[1], this.type === "encrypt" ? this._encrypt(a7, p7, s10, a7.tmp, 0) : this._decrypt(a7, p7, s10, a7.tmp, 0), p7 = a7.tmp[0], s10 = a7.tmp[1], o6.writeUInt32BE(e, p7, i), o6.writeUInt32BE(e, s10, i + 4);
  };
  h16.prototype._pad = function(t2, r2) {
    for (var e = t2.length - r2, i = r2; i < t2.length; i++)
      t2[i] = e;
    return true;
  };
  h16.prototype._unpad = function(t2) {
    for (var r2 = t2[t2.length - 1], e = t2.length - r2; e < t2.length; e++)
      O9.equal(t2[e], r2);
    return t2.slice(0, t2.length - r2);
  };
  h16.prototype._encrypt = function(t2, r2, e, i, a7) {
    for (var p7 = r2, s10 = e, n3 = 0; n3 < t2.keys.length; n3 += 2) {
      var b15 = t2.keys[n3], k15 = t2.keys[n3 + 1];
      o6.expand(s10, t2.tmp, 0), b15 ^= t2.tmp[0], k15 ^= t2.tmp[1];
      var E15 = o6.substitute(b15, k15), x17 = o6.permute(E15), q15 = s10;
      s10 = (p7 ^ x17) >>> 0, p7 = q15;
    }
    o6.rip(s10, p7, i, a7);
  };
  h16.prototype._decrypt = function(t2, r2, e, i, a7) {
    for (var p7 = e, s10 = r2, n3 = t2.keys.length - 2; n3 >= 0; n3 -= 2) {
      var b15 = t2.keys[n3], k15 = t2.keys[n3 + 1];
      o6.expand(p7, t2.tmp, 0), b15 ^= t2.tmp[0], k15 ^= t2.tmp[1];
      var E15 = o6.substitute(b15, k15), x17 = o6.permute(E15), q15 = p7;
      p7 = (s10 ^ x17) >>> 0, s10 = q15;
    }
    o6.rip(p7, s10, i, a7);
  };
});
var T8 = _9((K14) => {
  "use strict";
  var tt3 = j, rt3 = w, m20 = {};
  function et2(u12) {
    tt3.equal(u12.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var t2 = 0; t2 < this.iv.length; t2++)
      this.iv[t2] = u12[t2];
  }
  function nt2(u12) {
    function t2(a7) {
      u12.call(this, a7), this._cbcInit();
    }
    rt3(t2, u12);
    for (var r2 = Object.keys(m20), e = 0; e < r2.length; e++) {
      var i = r2[e];
      t2.prototype[i] = m20[i];
    }
    return t2.create = function(p7) {
      return new t2(p7);
    }, t2;
  }
  K14.instantiate = nt2;
  m20._cbcInit = function() {
    var t2 = new et2(this.options.iv);
    this._cbcState = t2;
  };
  m20._update = function(t2, r2, e, i) {
    var a7 = this._cbcState, p7 = this.constructor.super_.prototype, s10 = a7.iv;
    if (this.type === "encrypt") {
      for (var n3 = 0; n3 < this.blockSize; n3++)
        s10[n3] ^= t2[r2 + n3];
      p7._update.call(this, s10, 0, e, i);
      for (var n3 = 0; n3 < this.blockSize; n3++)
        s10[n3] = e[i + n3];
    } else {
      p7._update.call(this, t2, r2, e, i);
      for (var n3 = 0; n3 < this.blockSize; n3++)
        e[i + n3] ^= s10[n3];
      for (var n3 = 0; n3 < this.blockSize; n3++)
        s10[n3] = t2[r2 + n3];
    }
  };
});
var P11 = _9((lt2, N6) => {
  "use strict";
  var it3 = j, at2 = w, M14 = g14(), v19 = B13();
  function pt2(u12, t2) {
    it3.equal(t2.length, 24, "Invalid key length");
    var r2 = t2.slice(0, 8), e = t2.slice(8, 16), i = t2.slice(16, 24);
    u12 === "encrypt" ? this.ciphers = [
      v19.create({
        type: "encrypt",
        key: r2
      }),
      v19.create({
        type: "decrypt",
        key: e
      }),
      v19.create({
        type: "encrypt",
        key: i
      })
    ] : this.ciphers = [
      v19.create({
        type: "decrypt",
        key: i
      }),
      v19.create({
        type: "encrypt",
        key: e
      }),
      v19.create({
        type: "decrypt",
        key: r2
      })
    ];
  }
  function y16(u12) {
    M14.call(this, u12);
    var t2 = new pt2(this.type, this.options.key);
    this._edeState = t2;
  }
  at2(y16, M14);
  N6.exports = y16;
  y16.create = function(t2) {
    return new y16(t2);
  };
  y16.prototype._update = function(t2, r2, e, i) {
    var a7 = this._edeState;
    a7.ciphers[0]._update(t2, r2, e, i), a7.ciphers[1]._update(e, i, e, i), a7.ciphers[2]._update(e, i, e, i);
  };
  y16.prototype._pad = v19.prototype._pad;
  y16.prototype._unpad = v19.prototype._unpad;
});
var z12 = _9((d14) => {
  "use strict";
  d14.utils = w20();
  d14.Cipher = g14();
  d14.DES = B13();
  d14.CBC = T8();
  d14.EDE = P11();
});
var V5 = D7(z12());
var F7 = D7(z12());
var { utils: _t, Cipher: dt, DES: bt, CBC: kt, EDE: St1 } = F7;
var { default: ut3, ...st } = F7;
var gt2 = V5.default ?? ut3 ?? st;
var y13 = Object.create;
var m16 = Object.defineProperty;
var B14 = Object.getOwnPropertyDescriptor;
var C6 = Object.getOwnPropertyNames;
var b11 = Object.getPrototypeOf;
var D8 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, d14) => (typeof require != "undefined" ? require : r2)[d14]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var h13 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var _10 = (e, r2, d14, a7) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let t2 of C6(r2))
      !D8.call(e, t2) && t2 !== d14 && m16(e, t2, {
        get: () => r2[t2],
        enumerable: !(a7 = B14(r2, t2)) || a7.enumerable
      });
  return e;
};
var p19 = (e, r2, d14) => (d14 = e != null ? y13(b11(e)) : {}, _10(r2 || !e || !e.__esModule ? m16(d14, "default", {
  value: e,
  enumerable: true
}) : d14, e));
var u9 = h13((w110, E15) => {
  var v19 = M4, i = gt2, q15 = w, s10 = L1, f8 = {
    "des-ede3-cbc": i.CBC.instantiate(i.EDE),
    "des-ede3": i.EDE,
    "des-ede-cbc": i.CBC.instantiate(i.EDE),
    "des-ede": i.EDE,
    "des-cbc": i.CBC.instantiate(i.DES),
    "des-ecb": i.DES
  };
  f8.des = f8["des-cbc"];
  f8.des3 = f8["des-ede3-cbc"];
  E15.exports = n3;
  q15(n3, v19);
  function n3(e) {
    v19.call(this);
    var r2 = e.mode.toLowerCase(), d14 = f8[r2], a7;
    e.decrypt ? a7 = "decrypt" : a7 = "encrypt";
    var t2 = e.key;
    s10.isBuffer(t2) || (t2 = s10.from(t2)), (r2 === "des-ede" || r2 === "des-ede-cbc") && (t2 = s10.concat([
      t2,
      t2.slice(0, 8)
    ]));
    var c13 = e.iv;
    s10.isBuffer(c13) || (c13 = s10.from(c13)), this._des = d14.create({
      key: t2,
      iv: c13,
      type: a7
    });
  }
  n3.prototype._update = function(e) {
    return s10.from(this._des.update(e));
  };
  n3.prototype._final = function() {
    return s10.from(this._des.final());
  };
});
var l20 = p19(u9());
var $13 = p19(u9());
var { default: k10, ...S10 } = $13;
var L15 = l20.default ?? k10 ?? S10;
var s8 = Object.create;
var f7 = Object.defineProperty;
var L16 = Object.getOwnPropertyDescriptor;
var m17 = Object.getOwnPropertyNames;
var q12 = Object.getPrototypeOf;
var E11 = Object.prototype.hasOwnProperty;
((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, {
  get: (r2, i) => (typeof require != "undefined" ? require : r2)[i]
}) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var g15 = (e, r2) => () => (r2 || e((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var T9 = (e, r2, i, t2) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let p7 of m17(r2))
      !E11.call(e, p7) && p7 !== i && f7(e, p7, {
        get: () => r2[p7],
        enumerable: !(t2 = L16(r2, p7)) || t2.enumerable
      });
  return e;
};
var C7 = (e, r2, i) => (i = e != null ? s8(q12(e)) : {}, T9(r2 || !e || !e.__esModule ? f7(i, "default", {
  value: e,
  enumerable: true
}) : i, e));
var h14 = g15((a7) => {
  var y16 = L15, v19 = ut2, o6 = be2, c13 = q11, l22 = j3;
  function $17(e, r2) {
    e = e.toLowerCase();
    var i, t2;
    if (o6[e])
      i = o6[e].key, t2 = o6[e].iv;
    else if (c13[e])
      i = c13[e].key * 8, t2 = c13[e].iv;
    else
      throw new TypeError("invalid suite type");
    var p7 = l22(r2, false, i, t2);
    return d14(e, p7.key, p7.iv);
  }
  function b15(e, r2) {
    e = e.toLowerCase();
    var i, t2;
    if (o6[e])
      i = o6[e].key, t2 = o6[e].iv;
    else if (c13[e])
      i = c13[e].key * 8, t2 = c13[e].iv;
    else
      throw new TypeError("invalid suite type");
    var p7 = l22(r2, false, i, t2);
    return w24(e, p7.key, p7.iv);
  }
  function d14(e, r2, i) {
    if (e = e.toLowerCase(), o6[e])
      return v19.createCipheriv(e, r2, i);
    if (c13[e])
      return new y16({
        key: r2,
        iv: i,
        mode: e
      });
    throw new TypeError("invalid suite type");
  }
  function w24(e, r2, i) {
    if (e = e.toLowerCase(), o6[e])
      return v19.createDecipheriv(e, r2, i);
    if (c13[e])
      return new y16({
        key: r2,
        iv: i,
        mode: e,
        decrypt: true
      });
    throw new TypeError("invalid suite type");
  }
  function x17() {
    return Object.keys(c13).concat(v19.getCiphers());
  }
  a7.createCipher = a7.Cipher = $17;
  a7.createCipheriv = a7.Cipheriv = d14;
  a7.createDecipher = a7.Decipher = b15;
  a7.createDecipheriv = a7.Decipheriv = w24;
  a7.listCiphers = a7.getCiphers = x17;
});
var k11 = C7(h14());
var D9 = C7(h14());
var { createCipher: u10, Cipher: z13, createCipheriv: A10, Cipheriv: B15, createDecipher: F8, Decipher: G7, createDecipheriv: H6, Decipheriv: I11, listCiphers: J11, getCiphers: K12 } = D9;
var { default: M10, ...j9 } = D9;
var N3 = k11.default ?? M10 ?? j9;
var __global$4 = globalThis || (typeof window !== "undefined" ? window : self);
var A11 = Object.create;
var m18 = Object.defineProperty;
var S11 = Object.getOwnPropertyDescriptor;
var k12 = Object.getOwnPropertyNames;
var M11 = Object.getPrototypeOf;
var R10 = Object.prototype.hasOwnProperty;
((r2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r2, {
  get: (n3, e) => (typeof require != "undefined" ? require : n3)[e]
}) : r2)(function(r2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var $14 = (r2, n3) => () => (n3 || r2((n3 = {
  exports: {}
}).exports, n3), n3.exports);
var b12 = (r2, n3, e, t2) => {
  if (n3 && typeof n3 == "object" || typeof n3 == "function")
    for (let o6 of k12(n3))
      !R10.call(r2, o6) && o6 !== e && m18(r2, o6, {
        get: () => n3[o6],
        enumerable: !(t2 = S11(n3, o6)) || t2.enumerable
      });
  return r2;
};
var p20 = (r2, n3, e) => (e = r2 != null ? A11(M11(r2)) : {}, b12(n3 || !r2 || !r2.__esModule ? m18(e, "default", {
  value: r2,
  enumerable: true
}) : e, r2));
var i10 = $14((a7) => {
  "use strict";
  function c13() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var d14 = I2, w24 = q7, f8 = d14.Buffer, g17 = d14.kMaxLength, l22 = __global$4.crypto || __global$4.msCrypto, h16 = Math.pow(2, 32) - 1;
  function s10(r2, n3) {
    if (typeof r2 != "number" || r2 !== r2)
      throw new TypeError("offset must be a number");
    if (r2 > h16 || r2 < 0)
      throw new TypeError("offset must be a uint32");
    if (r2 > g17 || r2 > n3)
      throw new RangeError("offset out of range");
  }
  function E15(r2, n3, e) {
    if (typeof r2 != "number" || r2 !== r2)
      throw new TypeError("size must be a number");
    if (r2 > h16 || r2 < 0)
      throw new TypeError("size must be a uint32");
    if (r2 + n3 > e || r2 > g17)
      throw new RangeError("buffer too small");
  }
  l22 && l22.getRandomValues || !process1.browser ? (a7.randomFill = q15, a7.randomFillSync = L18) : (a7.randomFill = c13, a7.randomFillSync = c13);
  function q15(r2, n3, e, t2) {
    if (!f8.isBuffer(r2) && !(r2 instanceof __global$4.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof n3 == "function")
      t2 = n3, n3 = 0, e = r2.length;
    else if (typeof e == "function")
      t2 = e, e = r2.length - n3;
    else if (typeof t2 != "function")
      throw new TypeError('"cb" argument must be a function');
    return s10(n3, r2.length), E15(e, n3, r2.length), F12(r2, n3, e, t2);
  }
  function F12(r2, n3, e, t2) {
    if (process1.browser) {
      var o6 = r2.buffer, x17 = new Uint8Array(o6, n3, e);
      if (l22.getRandomValues(x17), t2) {
        process1.nextTick(function() {
          t2(null, r2);
        });
        return;
      }
      return r2;
    }
    if (t2) {
      w24(e, function(u12, U7) {
        if (u12)
          return t2(u12);
        U7.copy(r2, n3), t2(null, r2);
      });
      return;
    }
    var T12 = w24(e);
    return T12.copy(r2, n3), r2;
  }
  function L18(r2, n3, e) {
    if (typeof n3 > "u" && (n3 = 0), !f8.isBuffer(r2) && !(r2 instanceof __global$4.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return s10(n3, r2.length), e === void 0 && (e = r2.length - n3), E15(e, n3, r2.length), F12(r2, n3, e);
  }
});
var v16 = p20(i10());
var B16 = p20(i10());
var { randomFill: j10, randomFillSync: D10 } = B16;
var { default: V6, ...C8 } = B16;
var G8 = v16.default ?? V6 ?? C8;
var C9 = Object.create;
var b13 = Object.defineProperty;
var F9 = Object.getOwnPropertyDescriptor;
var G9 = Object.getOwnPropertyNames;
var J12 = Object.getPrototypeOf;
var O7 = Object.prototype.hasOwnProperty;
((t2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t2, {
  get: (r2, a7) => (typeof require != "undefined" ? require : r2)[a7]
}) : t2)(function(t2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t2 + '" is not supported');
});
var d11 = (t2, r2) => () => (r2 || t2((r2 = {
  exports: {}
}).exports, r2), r2.exports);
var Q7 = (t2, r2, a7, n3) => {
  if (r2 && typeof r2 == "object" || typeof r2 == "function")
    for (let e of G9(r2))
      !O7.call(t2, e) && e !== a7 && b13(t2, e, {
        get: () => r2[e],
        enumerable: !(n3 = F9(r2, e)) || n3.enumerable
      });
  return t2;
};
var x14 = (t2, r2, a7) => (a7 = t2 != null ? C9(J12(t2)) : {}, Q7(r2 || !t2 || !t2.__esModule ? b13(a7, "default", {
  value: t2,
  enumerable: true
}) : a7, t2));
var w21 = d11((sr, B18) => {
  var T12 = I8, h16 = L1;
  B18.exports = function(t2, r2) {
    for (var a7 = h16.alloc(0), n3 = 0, e; a7.length < r2; )
      e = V8(n3++), a7 = h16.concat([
        a7,
        T12("sha1").update(t2).update(e).digest()
      ]);
    return a7.slice(0, r2);
  };
  function V8(t2) {
    var r2 = h16.allocUnsafe(4);
    return r2.writeUInt32BE(t2, 0), r2;
  }
});
var g16 = d11((hr2, D12) => {
  D12.exports = function(r2, a7) {
    for (var n3 = r2.length, e = -1; ++e < n3; )
      r2[e] ^= a7[e];
    return r2;
  };
});
var m19 = d11((wr2, H9) => {
  var L18 = ki, W2 = L1;
  function X5(t2, r2) {
    return W2.from(t2.toRed(L18.mont(r2.modulus)).redPow(new L18(r2.publicExponent)).fromRed().toArray());
  }
  H9.exports = X5;
});
var N4 = d11((gr2, $17) => {
  var Y7 = Ae1, y16 = q7, _11 = I8, P13 = w21(), S14 = g16(), q15 = ki, K14 = m19(), rr2 = G2, c13 = L1;
  $17.exports = function(r2, a7, n3) {
    var e;
    r2.padding ? e = r2.padding : n3 ? e = 1 : e = 4;
    var i = Y7(r2), o6;
    if (e === 4)
      o6 = er2(i, a7);
    else if (e === 1)
      o6 = tr2(i, a7, n3);
    else if (e === 3) {
      if (o6 = new q15(a7), o6.cmp(i.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return n3 ? rr2(o6, i) : K14(o6, i);
  };
  function er2(t2, r2) {
    var a7 = t2.modulus.byteLength(), n3 = r2.length, e = _11("sha1").update(c13.alloc(0)).digest(), i = e.length, o6 = 2 * i;
    if (n3 > a7 - o6 - 2)
      throw new Error("message too long");
    var l22 = c13.alloc(a7 - n3 - o6 - 2), f8 = a7 - i - 1, p7 = y16(i), k15 = S14(c13.concat([
      e,
      l22,
      c13.alloc(1, 1),
      r2
    ], f8), P13(p7, f8)), j13 = S14(p7, P13(k15, i));
    return new q15(c13.concat([
      c13.alloc(1),
      j13,
      k15
    ], a7));
  }
  function tr2(t2, r2, a7) {
    var n3 = r2.length, e = t2.modulus.byteLength();
    if (n3 > e - 11)
      throw new Error("message too long");
    var i;
    return a7 ? i = c13.alloc(e - n3 - 3, 255) : i = ar2(e - n3 - 3), new q15(c13.concat([
      c13.from([
        0,
        a7 ? 1 : 2
      ]),
      i,
      c13.alloc(1),
      r2
    ], e));
  }
  function ar2(t2) {
    for (var r2 = c13.allocUnsafe(t2), a7 = 0, n3 = y16(t2 * 2), e = 0, i; a7 < t2; )
      e === n3.length && (n3 = y16(t2 * 2), e = 0), i = n3[e++], i && (r2[a7++] = i);
    return r2;
  }
});
var A12 = d11((mr2, z15) => {
  var nr2 = Ae1, U7 = w21(), M14 = g16(), R13 = ki, ir2 = G2, or3 = I8, ur = m19(), s10 = L1;
  z15.exports = function(r2, a7, n3) {
    var e;
    r2.padding ? e = r2.padding : n3 ? e = 1 : e = 4;
    var i = nr2(r2), o6 = i.modulus.byteLength();
    if (a7.length > o6 || new R13(a7).cmp(i.modulus) >= 0)
      throw new Error("decryption error");
    var l22;
    n3 ? l22 = ur(new R13(a7), i) : l22 = ir2(a7, i);
    var f8 = s10.alloc(o6 - l22.length);
    if (l22 = s10.concat([
      f8,
      l22
    ], o6), e === 4)
      return lr(i, l22);
    if (e === 1)
      return cr(i, l22, n3);
    if (e === 3)
      return l22;
    throw new Error("unknown padding");
  };
  function lr(t2, r2) {
    var a7 = t2.modulus.byteLength(), n3 = or3("sha1").update(s10.alloc(0)).digest(), e = n3.length;
    if (r2[0] !== 0)
      throw new Error("decryption error");
    var i = r2.slice(1, e + 1), o6 = r2.slice(e + 1), l22 = M14(i, U7(o6, e)), f8 = M14(o6, U7(l22, a7 - e - 1));
    if (fr(n3, f8.slice(0, e)))
      throw new Error("decryption error");
    for (var p7 = e; f8[p7] === 0; )
      p7++;
    if (f8[p7++] !== 1)
      throw new Error("decryption error");
    return f8.slice(p7);
  }
  function cr(t2, r2, a7) {
    for (var n3 = r2.slice(0, 2), e = 2, i = 0; r2[e++] !== 0; )
      if (e >= r2.length) {
        i++;
        break;
      }
    var o6 = r2.slice(2, e - 1);
    if ((n3.toString("hex") !== "0002" && !a7 || n3.toString("hex") !== "0001" && a7) && i++, o6.length < 8 && i++, i)
      throw new Error("decryption error");
    return r2.slice(e);
  }
  function fr(t2, r2) {
    t2 = s10.from(t2), r2 = s10.from(r2);
    var a7 = 0, n3 = t2.length;
    t2.length !== r2.length && (a7++, n3 = Math.min(t2.length, r2.length));
    for (var e = -1; ++e < n3; )
      a7 += t2[e] ^ r2[e];
    return a7;
  }
});
var E12 = d11((v19) => {
  v19.publicEncrypt = N4();
  v19.privateDecrypt = A12();
  v19.privateEncrypt = function(r2, a7) {
    return v19.publicEncrypt(r2, a7, true);
  };
  v19.publicDecrypt = function(r2, a7) {
    return v19.privateDecrypt(r2, a7, true);
  };
});
var I12 = x14(E12());
var Z = x14(E12());
var { publicEncrypt: qr1, privateDecrypt: Er1, privateEncrypt: kr1, publicDecrypt: br2 } = Z;
var { default: pr, ...vr1 } = Z;
var xr1 = I12.default ?? pr ?? vr1;
var R11 = Object.create;
var A13 = Object.defineProperty;
var o4 = Object.getOwnPropertyDescriptor;
var H7 = Object.getOwnPropertyNames;
var p21 = Object.getPrototypeOf;
var D11 = Object.prototype.hasOwnProperty;
var S12 = (h16, s10) => () => (s10 || h16((s10 = {
  exports: {}
}).exports, s10), s10.exports);
var W = (h16, s10, a7, n3) => {
  if (s10 && typeof s10 == "object" || typeof s10 == "function")
    for (let i of H7(s10))
      !D11.call(h16, i) && i !== a7 && A13(h16, i, {
        get: () => s10[i],
        enumerable: !(n3 = o4(s10, i)) || n3.enumerable
      });
  return h16;
};
var r1 = (h16, s10, a7) => (a7 = h16 != null ? R11(p21(h16)) : {}, W(s10 || !h16 || !h16.__esModule ? A13(a7, "default", {
  value: h16,
  enumerable: true
}) : a7, h16));
var t = S12((I13, m20) => {
  m20.exports = {
    sha224WithRSAEncryption: {
      sign: "rsa",
      hash: "sha224",
      id: "302d300d06096086480165030402040500041c"
    },
    "RSA-SHA224": {
      sign: "ecdsa/rsa",
      hash: "sha224",
      id: "302d300d06096086480165030402040500041c"
    },
    sha256WithRSAEncryption: {
      sign: "rsa",
      hash: "sha256",
      id: "3031300d060960864801650304020105000420"
    },
    "RSA-SHA256": {
      sign: "ecdsa/rsa",
      hash: "sha256",
      id: "3031300d060960864801650304020105000420"
    },
    sha384WithRSAEncryption: {
      sign: "rsa",
      hash: "sha384",
      id: "3041300d060960864801650304020205000430"
    },
    "RSA-SHA384": {
      sign: "ecdsa/rsa",
      hash: "sha384",
      id: "3041300d060960864801650304020205000430"
    },
    sha512WithRSAEncryption: {
      sign: "rsa",
      hash: "sha512",
      id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA512": {
      sign: "ecdsa/rsa",
      hash: "sha512",
      id: "3051300d060960864801650304020305000440"
    },
    "RSA-SHA1": {
      sign: "rsa",
      hash: "sha1",
      id: "3021300906052b0e03021a05000414"
    },
    "ecdsa-with-SHA1": {
      sign: "ecdsa",
      hash: "sha1",
      id: ""
    },
    sha256: {
      sign: "ecdsa",
      hash: "sha256",
      id: ""
    },
    sha224: {
      sign: "ecdsa",
      hash: "sha224",
      id: ""
    },
    sha384: {
      sign: "ecdsa",
      hash: "sha384",
      id: ""
    },
    sha512: {
      sign: "ecdsa",
      hash: "sha512",
      id: ""
    },
    "DSA-SHA": {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    "DSA-SHA1": {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    DSA: {
      sign: "dsa",
      hash: "sha1",
      id: ""
    },
    "DSA-WITH-SHA224": {
      sign: "dsa",
      hash: "sha224",
      id: ""
    },
    "DSA-SHA224": {
      sign: "dsa",
      hash: "sha224",
      id: ""
    },
    "DSA-WITH-SHA256": {
      sign: "dsa",
      hash: "sha256",
      id: ""
    },
    "DSA-SHA256": {
      sign: "dsa",
      hash: "sha256",
      id: ""
    },
    "DSA-WITH-SHA384": {
      sign: "dsa",
      hash: "sha384",
      id: ""
    },
    "DSA-SHA384": {
      sign: "dsa",
      hash: "sha384",
      id: ""
    },
    "DSA-WITH-SHA512": {
      sign: "dsa",
      hash: "sha512",
      id: ""
    },
    "DSA-SHA512": {
      sign: "dsa",
      hash: "sha512",
      id: ""
    },
    "DSA-RIPEMD160": {
      sign: "dsa",
      hash: "rmd160",
      id: ""
    },
    ripemd160WithRSA: {
      sign: "rsa",
      hash: "rmd160",
      id: "3021300906052b2403020105000414"
    },
    "RSA-RIPEMD160": {
      sign: "rsa",
      hash: "rmd160",
      id: "3021300906052b2403020105000414"
    },
    md5WithRSAEncryption: {
      sign: "rsa",
      hash: "md5",
      id: "3020300c06082a864886f70d020505000410"
    },
    "RSA-MD5": {
      sign: "rsa",
      hash: "md5",
      id: "3020300c06082a864886f70d020505000410"
    }
  };
});
var d12 = S12((u12, g17) => {
  g17.exports = t();
});
var c12 = r1(d12());
var e15 = r1(d12());
var { sha224WithRSAEncryption: l21, sha256WithRSAEncryption: T10, sha384WithRSAEncryption: $15, sha512WithRSAEncryption: b14, sha256: x15, sha224: M12, sha384: P12, sha512: q13, DSA: w22, ripemd160WithRSA: j11, md5WithRSAEncryption: k13 } = e15;
var { default: E13, ...y14 } = e15;
var v17 = c12.default ?? E13 ?? y14;
var C10 = Object.create;
var h15 = Object.defineProperty;
var H8 = Object.getOwnPropertyDescriptor;
var E14 = Object.getOwnPropertyNames;
var S13 = Object.getPrototypeOf;
var d13 = Object.prototype.hasOwnProperty;
((r2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(r2, {
  get: (i, c13) => (typeof require != "undefined" ? require : i)[c13]
}) : r2)(function(r2) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + r2 + '" is not supported');
});
var N5 = (r2, i) => () => (i || r2((i = {
  exports: {}
}).exports, i), i.exports);
var v18 = (r2, i, c13, f8) => {
  if (i && typeof i == "object" || typeof i == "function")
    for (let p7 of E14(i))
      !d13.call(r2, p7) && p7 !== c13 && h15(r2, p7, {
        get: () => i[p7],
        enumerable: !(f8 = H8(i, p7)) || f8.enumerable
      });
  return r2;
};
var o5 = (r2, i, c13) => (c13 = r2 != null ? C10(S13(r2)) : {}, v18(i || !r2 || !r2.__esModule ? h15(c13, "default", {
  value: r2,
  enumerable: true
}) : c13, r2));
var s9 = N5((e) => {
  "use strict";
  e.randomBytes = e.rng = e.pseudoRandomBytes = e.prng = q7;
  e.createHash = e.Hash = I8;
  e.createHmac = e.Hmac = J6;
  var g17 = v17, P13 = Object.keys(g17), A14 = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(P13);
  e.getHashes = function() {
    return A14;
  };
  var m20 = gr1;
  e.pbkdf2 = m20.pbkdf2;
  e.pbkdf2Sync = m20.pbkdf2Sync;
  var t2 = N3;
  e.Cipher = t2.Cipher;
  e.createCipher = t2.createCipher;
  e.Cipheriv = t2.Cipheriv;
  e.createCipheriv = t2.createCipheriv;
  e.Decipher = t2.Decipher;
  e.createDecipher = t2.createDecipher;
  e.Decipheriv = t2.Decipheriv;
  e.createDecipheriv = t2.createDecipheriv;
  e.getCiphers = t2.getCiphers;
  e.listCiphers = t2.listCiphers;
  var n3 = De3;
  e.DiffieHellmanGroup = n3.DiffieHellmanGroup;
  e.createDiffieHellmanGroup = n3.createDiffieHellmanGroup;
  e.getDiffieHellman = n3.getDiffieHellman;
  e.createDiffieHellman = n3.createDiffieHellman;
  e.DiffieHellman = n3.DiffieHellman;
  var l22 = qr;
  e.createSign = l22.createSign;
  e.Sign = l22.Sign;
  e.createVerify = l22.createVerify;
  e.Verify = l22.Verify;
  e.createECDH = A3;
  var D12 = xr1;
  e.publicEncrypt = D12.publicEncrypt;
  e.privateEncrypt = D12.privateEncrypt;
  e.publicDecrypt = D12.publicDecrypt;
  e.privateDecrypt = D12.privateDecrypt;
  var _11 = G8;
  e.randomFill = _11.randomFill;
  e.randomFillSync = _11.randomFillSync;
  e.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  };
  e.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  };
});
var u11 = o5(s9());
var y15 = o5(s9());
var { randomBytes: G10, rng: q14, pseudoRandomBytes: T11, prng: V7, createHash: B17, Hash: k14, createHmac: F10, Hmac: K13, getHashes: L17, pbkdf2: w23, pbkdf2Sync: M13, Cipher: $16, createCipher: U6, Cipheriv: j12, createCipheriv: x16, Decipher: X4, createDecipher: Y6, Decipheriv: z14, createDecipheriv: J13, getCiphers: Q8, listCiphers: W1, DiffieHellmanGroup: Z1, createDiffieHellmanGroup: ee, getDiffieHellman: re3, createDiffieHellman: ie2, DiffieHellman: ae2, createSign: te, Sign: ce3, createVerify: pe1, Verify: ne1, createECDH: le2, publicEncrypt: De4, privateEncrypt: se2, publicDecrypt: fe3, privateDecrypt: he2, randomFill: oe2, randomFillSync: me1, createCredentials: _e1, constants: ue3 } = y15;
var { default: O8, ...R12 } = y15;
var ye3 = u11.default ?? O8 ?? R12;
var mod107 = {
  default: ye3,
  Cipher: $16,
  Cipheriv: j12,
  Decipher: X4,
  Decipheriv: z14,
  DiffieHellman: ae2,
  DiffieHellmanGroup: Z1,
  Hash: k14,
  Hmac: K13,
  Sign: ce3,
  Verify: ne1,
  constants: ue3,
  createCipher: U6,
  createCipheriv: x16,
  createCredentials: _e1,
  createDecipher: Y6,
  createDecipheriv: J13,
  createDiffieHellman: ie2,
  createDiffieHellmanGroup: ee,
  createECDH: le2,
  createHash: B17,
  createHmac: F10,
  createSign: te,
  createVerify: pe1,
  getCiphers: Q8,
  getDiffieHellman: re3,
  getHashes: L17,
  listCiphers: W1,
  pbkdf2: w23,
  pbkdf2Sync: M13,
  privateDecrypt: he2,
  privateEncrypt: se2,
  prng: V7,
  pseudoRandomBytes: T11,
  publicDecrypt: fe3,
  publicEncrypt: De4,
  randomBytes: G10,
  randomFill: oe2,
  randomFillSync: me1,
  rng: q14
};
var codes2 = {};
var _toString4 = Object.prototype.toString;
var _isObjectLike4 = (value) => value !== null && typeof value === "object";
var _isFunctionLike2 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer4(value) {
  return _isObjectLike4(value) && (_toString4.call(value) === "[object ArrayBuffer]" || _toString4.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Arguments]";
}
function isArrayBuffer4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction4(value) {
  return _isFunctionLike2(value) && _toString4.call(value) === "[object AsyncFunction]";
}
function isBooleanObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Boolean]";
}
function isBoxedPrimitive4(value) {
  return isBooleanObject4(value) || isStringObject4(value) || isNumberObject4(value) || isSymbolObject4(value) || isBigIntObject4(value);
}
function isDataView4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object DataView]";
}
function isDate5(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Date]";
}
function isGeneratorFunction4(value) {
  return _isFunctionLike2(value) && _toString4.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Generator]";
}
function isMap4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Map]";
}
function isMapIterator4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Module]";
}
function isNativeError4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Error]";
}
function isNumberObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Number]";
}
function isBigIntObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object BigInt]";
}
function isPromise4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Promise]";
}
function isRegExp5(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object RegExp]";
}
function isSet4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Set]";
}
function isSetIterator4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object String]";
}
function isSymbolObject4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Symbol]";
}
function isWeakMap4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object WeakMap]";
}
function isWeakSet4(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object WeakSet]";
}
var __default18 = {
  isAsyncFunction: isAsyncFunction4,
  isGeneratorFunction: isGeneratorFunction4,
  isAnyArrayBuffer: isAnyArrayBuffer4,
  isArrayBuffer: isArrayBuffer4,
  isArgumentsObject: isArgumentsObject4,
  isBoxedPrimitive: isBoxedPrimitive4,
  isDataView: isDataView4,
  isMap: isMap4,
  isMapIterator: isMapIterator4,
  isModuleNamespaceObject: isModuleNamespaceObject4,
  isNativeError: isNativeError4,
  isPromise: isPromise4,
  isSet: isSet4,
  isSetIterator: isSetIterator4,
  isWeakMap: isWeakMap4,
  isWeakSet: isWeakSet4,
  isRegExp: isRegExp5,
  isDate: isDate5,
  isStringObject: isStringObject4,
  isNumberObject: isNumberObject4,
  isBooleanObject: isBooleanObject4,
  isBigIntObject: isBigIntObject4
};
var mod108 = {
  isAnyArrayBuffer: isAnyArrayBuffer4,
  isArgumentsObject: isArgumentsObject4,
  isArrayBuffer: isArrayBuffer4,
  isAsyncFunction: isAsyncFunction4,
  isBooleanObject: isBooleanObject4,
  isBoxedPrimitive: isBoxedPrimitive4,
  isDataView: isDataView4,
  isDate: isDate5,
  isGeneratorFunction: isGeneratorFunction4,
  isGeneratorObject: isGeneratorObject4,
  isMap: isMap4,
  isMapIterator: isMapIterator4,
  isModuleNamespaceObject: isModuleNamespaceObject4,
  isNativeError: isNativeError4,
  isNumberObject: isNumberObject4,
  isBigIntObject: isBigIntObject4,
  isPromise: isPromise4,
  isRegExp: isRegExp5,
  isSet: isSet4,
  isSetIterator: isSetIterator4,
  isSharedArrayBuffer: isSharedArrayBuffer4,
  isStringObject: isStringObject4,
  isSymbolObject: isSymbolObject4,
  isWeakMap: isWeakMap4,
  isWeakSet: isWeakSet4,
  default: __default18
};
Symbol("kHandle");
Symbol("kKeyObject");
Symbol("kKeyType");
var _toString5 = Object.prototype.toString;
var _isObjectLike5 = (value) => value !== null && typeof value === "object";
function isArrayBufferView2(value) {
  return ArrayBuffer.isView(value);
}
function isUint8Array2(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Uint8Array]";
}
var { isDate: isDate6, isArgumentsObject: isArgumentsObject5, isBigIntObject: isBigIntObject5, isBooleanObject: isBooleanObject5, isNumberObject: isNumberObject5, isStringObject: isStringObject5, isSymbolObject: isSymbolObject5, isNativeError: isNativeError5, isRegExp: isRegExp6, isAsyncFunction: isAsyncFunction5, isGeneratorFunction: isGeneratorFunction5, isGeneratorObject: isGeneratorObject5, isPromise: isPromise5, isMap: isMap5, isSet: isSet5, isMapIterator: isMapIterator5, isSetIterator: isSetIterator5, isWeakMap: isWeakMap5, isWeakSet: isWeakSet5, isArrayBuffer: isArrayBuffer5, isDataView: isDataView5, isSharedArrayBuffer: isSharedArrayBuffer5, isModuleNamespaceObject: isModuleNamespaceObject5, isAnyArrayBuffer: isAnyArrayBuffer5, isBoxedPrimitive: isBoxedPrimitive5 } = mod108;
function hideStackFrames2(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", {
    value: hidden
  });
  return fn;
}
function normalizeEncoding6(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases4(enc);
}
function slowCases4(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}
function isInt322(value) {
  return value === (value | 0);
}
function isUint322(value) {
  return value === value >>> 0;
}
var validateBuffer2 = hideStackFrames2((buffer, name = "buffer") => {
  if (!isArrayBufferView2(buffer)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, [
      "Buffer",
      "TypedArray",
      "DataView"
    ], buffer);
  }
});
hideStackFrames2((value, name, min3 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
hideStackFrames2((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
hideStackFrames2((value, name, min3 = -2147483648, max2 = 2147483647) => {
  if (!isInt322(value)) {
    if (typeof value !== "number") {
      throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
  if (value < min3 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
hideStackFrames2((value, name, positive) => {
  if (!isUint322(value)) {
    if (typeof value !== "number") {
      throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min3 = positive ? 1 : 0;
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min3} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes2.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
hideStackFrames2((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v19) => typeof v19 === "string" ? `'${v19}'` : String(v19)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
hideStackFrames2((callback) => {
  if (typeof callback !== "function") {
    throw new codes2.ERR_INVALID_CALLBACK(callback);
  }
});
hideStackFrames2((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction2 = hideStackFrames2((value, name) => {
  if (typeof value !== "function") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
hideStackFrames2((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty2 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty2.enumerable = true;
var kCustomPromisifiedSymbol2 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol2 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify2(original) {
  validateFunction2(original, "original");
  if (original[kCustomPromisifiedSymbol2]) {
    const fn = original[kCustomPromisifiedSymbol2];
    validateFunction2(fn, "util.promisify.custom");
    return Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol2];
  function fn1(...args) {
    return new Promise((resolve9, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve9(obj2);
        } else {
          resolve9(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
  Object.defineProperty(fn1, kCustomPromisifiedSymbol2, {
    value: fn1,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify2.custom = kCustomPromisifiedSymbol2;
var Encodings2;
(function(Encodings4) {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
})(Encodings2 || (Encodings2 = {}));
var encodings2 = [];
encodings2[Encodings2.ASCII] = "ascii";
encodings2[Encodings2.BASE64] = "base64";
encodings2[Encodings2.BASE64URL] = "base64url";
encodings2[Encodings2.BUFFER] = "buffer";
encodings2[Encodings2.HEX] = "hex";
encodings2[Encodings2.LATIN1] = "latin1";
encodings2[Encodings2.UCS2] = "utf16le";
encodings2[Encodings2.UTF8] = "utf8";
function indexOfNeedle2(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s10 = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s10)
      continue;
    const pin = i;
    let matched = 1;
    let j13 = i;
    while (matched < needle.length) {
      j13++;
      if (source[j13] !== needle[j13 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}
function numberToBytes2(n3) {
  if (n3 === 0)
    return new Uint8Array([
      0
    ]);
  const bytes = [];
  bytes.unshift(n3 & 255);
  while (n3 >= 256) {
    n3 = n3 >>> 8;
    bytes.unshift(n3 & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex2(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x17 = 0; x17 <= searchableBufferLastIndex; x17++) {
    if (searchableBuffer[searchableBufferLastIndex - x17] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x17;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x17 = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x17;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer2(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings2[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex2(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle2(targetBuffer, buffer, byteOffset);
}
function indexOfNumber2(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes2(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer2(targetBuffer, numberToBytes2(number), byteOffset, Encodings2.UTF8, forwardDirection);
}
var base64abc2 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode52(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l22 = uint8.length;
  for (i = 2; i < l22; i += 3) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc2[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc2[uint8[i] & 63];
  }
  if (i === l22 + 1) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l22) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc2[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode42(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
function addPaddingToBase64url2(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase642(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url2(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url2(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode62(data) {
  return convertBase64ToBase64url2(encode52(data));
}
function decode52(b64url) {
  return decode42(convertBase64urlToBase642(b64url));
}
function asciiToBytes2(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes2(str) {
  str = base64clean2(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode42(str);
}
var INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes2(str) {
  str = base64clean2(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode52(str);
}
function hexToBytes2(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a7 = Number.parseInt(str[i * 2], 16);
    const b15 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a7) && Number.isNaN(b15)) {
      break;
    }
    byteArray[i] = a7 << 4 | b15;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes2(str, units) {
  let c13, hi, lo;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c13 = str.charCodeAt(i);
    hi = c13 >> 8;
    lo = c13 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii2(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le2(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
var utf8Encoder2 = new TextEncoder();
var float32Array2 = new Float32Array(1);
var uInt8Float32Array2 = new Uint8Array(float32Array2.buffer);
var float64Array2 = new Float64Array(1);
var uInt8Float64Array2 = new Uint8Array(float64Array2.buffer);
float32Array2[0] = -1;
var bigEndian2 = uInt8Float32Array2[3] === 0;
function readUInt48LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 8);
  }
  uInt8Float64Array2[7] = first;
  uInt8Float64Array2[6] = buffer[++offset];
  uInt8Float64Array2[5] = buffer[++offset];
  uInt8Float64Array2[4] = buffer[++offset];
  uInt8Float64Array2[3] = buffer[++offset];
  uInt8Float64Array2[2] = buffer[++offset];
  uInt8Float64Array2[1] = buffer[++offset];
  uInt8Float64Array2[0] = last;
  return float64Array2[0];
}
function readDoubleForwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 8);
  }
  uInt8Float64Array2[0] = first;
  uInt8Float64Array2[1] = buffer[++offset];
  uInt8Float64Array2[2] = buffer[++offset];
  uInt8Float64Array2[3] = buffer[++offset];
  uInt8Float64Array2[4] = buffer[++offset];
  uInt8Float64Array2[5] = buffer[++offset];
  uInt8Float64Array2[6] = buffer[++offset];
  uInt8Float64Array2[7] = last;
  return float64Array2[0];
}
function writeDoubleForwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds4(buffer, offset, 7);
  float64Array2[0] = val;
  buffer[offset++] = uInt8Float64Array2[0];
  buffer[offset++] = uInt8Float64Array2[1];
  buffer[offset++] = uInt8Float64Array2[2];
  buffer[offset++] = uInt8Float64Array2[3];
  buffer[offset++] = uInt8Float64Array2[4];
  buffer[offset++] = uInt8Float64Array2[5];
  buffer[offset++] = uInt8Float64Array2[6];
  buffer[offset++] = uInt8Float64Array2[7];
  return offset;
}
function writeDoubleBackwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds4(buffer, offset, 7);
  float64Array2[0] = val;
  buffer[offset++] = uInt8Float64Array2[7];
  buffer[offset++] = uInt8Float64Array2[6];
  buffer[offset++] = uInt8Float64Array2[5];
  buffer[offset++] = uInt8Float64Array2[4];
  buffer[offset++] = uInt8Float64Array2[3];
  buffer[offset++] = uInt8Float64Array2[2];
  buffer[offset++] = uInt8Float64Array2[1];
  buffer[offset++] = uInt8Float64Array2[0];
  return offset;
}
function readFloatBackwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 4);
  }
  uInt8Float32Array2[3] = first;
  uInt8Float32Array2[2] = buffer[++offset];
  uInt8Float32Array2[1] = buffer[++offset];
  uInt8Float32Array2[0] = last;
  return float32Array2[0];
}
function readFloatForwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 4);
  }
  uInt8Float32Array2[0] = first;
  uInt8Float32Array2[1] = buffer[++offset];
  uInt8Float32Array2[2] = buffer[++offset];
  uInt8Float32Array2[3] = last;
  return float32Array2[0];
}
function writeFloatForwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds4(buffer, offset, 3);
  float32Array2[0] = val;
  buffer[offset++] = uInt8Float32Array2[0];
  buffer[offset++] = uInt8Float32Array2[1];
  buffer[offset++] = uInt8Float32Array2[2];
  buffer[offset++] = uInt8Float32Array2[3];
  return offset;
}
function writeFloatBackwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds4(buffer, offset, 3);
  float32Array2[0] = val;
  buffer[offset++] = uInt8Float32Array2[3];
  buffer[offset++] = uInt8Float32Array2[2];
  buffer[offset++] = uInt8Float32Array2[1];
  buffer[offset++] = uInt8Float32Array2[0];
  return offset;
}
function readInt24LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf82(str) {
  return utf8Encoder2.encode(str).length;
}
function base64ByteLength2(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap2 = /* @__PURE__ */ Object.create(null);
for (let i11 = 0; i11 < encodings2.length; ++i11) {
  encodingsMap2[encodings2[i11]] = i11;
}
var encodingOps2 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap2.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength2(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap2.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, base64ToBytes2(val), byteOffset, encodingsMap2.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength2(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap2.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, base64UrlToBytes2(val), byteOffset, encodingsMap2.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap2.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, hexToBytes2(val), byteOffset, encodingsMap2.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap2.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap2.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf82,
    encoding: "utf8",
    encodingVal: encodingsMap2.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf8Encoder2.encode(val), byteOffset, encodingsMap2.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap2.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps2(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps2.utf8;
      if (encoding === "ucs2")
        return encodingOps2.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps2.utf8;
      if (encoding === "ascii")
        return encodingOps2.ascii;
      if (encoding === "ucs-2")
        return encodingOps2.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps2.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps2.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps2.latin1;
      }
      if (encoding === "base64")
        return encodingOps2.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps2.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps2.base64url;
      }
      break;
  }
}
function _copyActual2(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError2(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber2(value, type);
    throw new codes2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber2(value, name) {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds4(buf, offset, byteLength3) {
  validateNumber2(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
    boundsError2(offset, buf.length - (byteLength3 + 1));
  }
}
function checkInt2(value, min3, max2, buf, offset, byteLength3) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength3 > 3) {
      if (min3 === 0 || min3 === 0n) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength3 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}) and < 2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds4(buf, offset, byteLength3);
}
function toInteger2(n3, defaultVal) {
  n3 = +n3;
  if (!Number.isNaN(n3) && n3 >= Number.MIN_SAFE_INTEGER && n3 <= Number.MAX_SAFE_INTEGER) {
    return n3 % 1 === 0 ? n3 : Math.floor(n3);
  }
  return defaultVal;
}
function writeU_Int82(buf, value, offset, min3, max2) {
  value = +value;
  validateNumber2(offset, "offset");
  if (value > max2 || value < min3) {
    throw new codes2.ERR_OUT_OF_RANGE("value", `>= ${min3} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError2(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset2(value, name, min3 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
}
function writeU_Int48LE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE2(buf, value, offset, min3, max2) {
  value = +value;
  checkInt2(value, min3, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
var kMaxLength2 = 2147483647;
var MAX_UINT322 = 2 ** 32;
var customInspectSymbol4 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES2 = 50;
Object.defineProperty(Buffer22.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer22.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer22.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer22.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer2(length) {
  if (length > 2147483647) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer22.prototype);
  return buf;
}
function Buffer22(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes2.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe2(arg);
  }
  return _from4(arg, encodingOrOffset, length);
}
Buffer22.poolSize = 8192;
function _from4(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString2(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer5(value)) {
      return fromArrayBuffer2(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from4(valueOf, encodingOrOffset, length);
    }
    const b15 = fromObject2(value);
    if (b15) {
      return b15;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString2(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes2.ERR_INVALID_ARG_TYPE("first argument", [
    "string",
    "Buffer",
    "ArrayBuffer",
    "Array",
    "Array-like Object"
  ], value);
}
Buffer22.from = function from3(value, encodingOrOffset, length) {
  return _from4(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer22.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer22, Uint8Array);
function assertSize3(size) {
  validateNumber2(size, "size");
  if (!(size >= 0 && size <= 2147483647)) {
    throw new codes2.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc2(size, fill6, encoding) {
  assertSize3(size);
  const buffer = createBuffer2(size);
  if (fill6 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes2.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill6, encoding);
  }
  return buffer;
}
Buffer22.alloc = function alloc3(size, fill6, encoding) {
  return _alloc2(size, fill6, encoding);
};
function _allocUnsafe2(size) {
  assertSize3(size);
  return createBuffer2(size < 0 ? 0 : checked2(size) | 0);
}
Buffer22.allocUnsafe = function allocUnsafe3(size) {
  return _allocUnsafe2(size);
};
Buffer22.allocUnsafeSlow = function allocUnsafeSlow3(size) {
  return _allocUnsafe2(size);
};
function fromString2(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer22.isEncoding(encoding)) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength4(string, encoding) | 0;
  let buf = createBuffer2(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike2(array) {
  const length = array.length < 0 ? 0 : checked2(array.length) | 0;
  const buf = createBuffer2(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject2(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer5(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer2(0);
    }
    return fromArrayLike2(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike2(obj2.data);
  }
}
function checked2(length) {
  if (length >= 2147483647) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer2(length) {
  assertSize3(length);
  return Buffer22.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer2, Uint8Array);
Buffer22.isBuffer = function isBuffer4(b15) {
  return b15 != null && b15._isBuffer === true && b15 !== Buffer22.prototype;
};
Buffer22.compare = function compare6(a7, b15) {
  if (isInstance2(a7, Uint8Array)) {
    a7 = Buffer22.from(a7, a7.offset, a7.byteLength);
  }
  if (isInstance2(b15, Uint8Array)) {
    b15 = Buffer22.from(b15, b15.offset, b15.byteLength);
  }
  if (!Buffer22.isBuffer(a7) || !Buffer22.isBuffer(b15)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a7 === b15) {
    return 0;
  }
  let x17 = a7.length;
  let y16 = b15.length;
  for (let i = 0, len = Math.min(x17, y16); i < len; ++i) {
    if (a7[i] !== b15[i]) {
      x17 = a7[i];
      y16 = b15[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
Buffer22.isEncoding = function isEncoding3(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding6(encoding) !== void 0;
};
Buffer22.concat = function concat3(list, length) {
  if (!Array.isArray(list)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer22.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset2(length, "length");
  }
  const buffer = Buffer22.allocUnsafe(length);
  let pos = 0;
  for (let i12 = 0; i12 < list.length; i12++) {
    const buf = list[i12];
    if (!isUint8Array2(buf)) {
      throw new codes2.ERR_INVALID_ARG_TYPE(`list[${i12}]`, [
        "Buffer",
        "Uint8Array"
      ], list[i12]);
    }
    pos += _copyActual2(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength4(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView2(string) || isAnyArrayBuffer5(string)) {
      return string.byteLength;
    }
    throw new codes2.ERR_INVALID_ARG_TYPE("string", [
      "string",
      "Buffer",
      "ArrayBuffer"
    ], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf82(string);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf82(string);
  }
  return ops.byteLength(string);
}
Buffer22.byteLength = byteLength4;
Buffer22.prototype._isBuffer = true;
function swap2(b15, n3, m20) {
  const i = b15[n3];
  b15[n3] = b15[m20];
  b15[m20] = i;
}
Buffer22.prototype.swap16 = function swap163() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap2(this, i, i + 1);
  }
  return this;
};
Buffer22.prototype.swap32 = function swap323() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap2(this, i, i + 3);
    swap2(this, i + 1, i + 2);
  }
  return this;
};
Buffer22.prototype.swap64 = function swap643() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap2(this, i, i + 7);
    swap2(this, i + 1, i + 6);
    swap2(this, i + 2, i + 5);
    swap2(this, i + 3, i + 4);
  }
  return this;
};
Buffer22.prototype.toString = function toString4(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer22.prototype.toLocaleString = Buffer22.prototype.toString;
Buffer22.prototype.equals = function equals3(b15) {
  if (!isUint8Array2(b15)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("otherBuffer", [
      "Buffer",
      "Uint8Array"
    ], b15);
  }
  if (this === b15) {
    return true;
  }
  return Buffer22.compare(this, b15) === 0;
};
Buffer22.prototype.inspect = function inspect4() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES2;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol4) {
  Buffer22.prototype[customInspectSymbol4] = Buffer22.prototype.inspect;
}
Buffer22.prototype.compare = function compare7(target, start, end, thisStart, thisEnd) {
  if (isInstance2(target, Uint8Array)) {
    target = Buffer22.from(target, target.offset, target.byteLength);
  }
  if (!Buffer22.isBuffer(target)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset2(start, "targetStart", 0, kMaxLength2);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset2(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset2(start, "sourceStart", 0, kMaxLength2);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset2(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes2.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x17 = thisEnd - thisStart;
  let y16 = end - start;
  const len = Math.min(x17, y16);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x17 = thisCopy[i];
      y16 = targetCopy[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  validateBuffer2(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber2(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps2.utf8;
  } else {
    ops = getEncodingOps2(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array2(val)) {
    const encodingVal = ops === void 0 ? encodingsMap2.utf8 : ops.encodingVal;
    return indexOfBuffer2(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes2.ERR_INVALID_ARG_TYPE("value", [
    "number",
    "string",
    "Buffer",
    "Uint8Array"
  ], val);
}
Buffer22.prototype.includes = function includes3(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer22.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer22.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
Buffer22.prototype.asciiSlice = function asciiSlice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii2(this);
  } else {
    return bytesToAscii2(this.slice(offset, length));
  }
};
Buffer22.prototype.asciiWrite = function asciiWrite3(string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer22.prototype.base64Slice = function base64Slice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode52(this);
  } else {
    return encode52(this.slice(offset, length));
  }
};
Buffer22.prototype.base64Write = function base64Write3(string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), this, offset, length);
};
Buffer22.prototype.base64urlSlice = function base64urlSlice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode62(this);
  } else {
    return encode62(this.slice(offset, length));
  }
};
Buffer22.prototype.base64urlWrite = function base64urlWrite3(string, offset, length) {
  return blitBuffer2(base64UrlToBytes2(string), this, offset, length);
};
Buffer22.prototype.hexWrite = function hexWrite3(string, offset, length) {
  return blitBuffer2(hexToBytes2(string, this.length - offset), this, offset, length);
};
Buffer22.prototype.hexSlice = function hexSlice4(string, offset, length) {
  return _hexSlice2(this, string, offset, length);
};
Buffer22.prototype.latin1Slice = function latin1Slice3(string, offset, length) {
  return _latin1Slice2(this, string, offset, length);
};
Buffer22.prototype.latin1Write = function latin1Write3(string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer22.prototype.ucs2Slice = function ucs2Slice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le2(this);
  } else {
    return bytesToUtf16le2(this.slice(offset, length));
  }
};
Buffer22.prototype.ucs2Write = function ucs2Write3(string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, this.length - offset), this, offset, length);
};
Buffer22.prototype.utf8Slice = function utf8Slice3(string, offset, length) {
  return _utf8Slice2(this, string, offset, length);
};
Buffer22.prototype.utf8Write = function utf8Write4(string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, this.length - offset), this, offset, length);
};
Buffer22.prototype.write = function write3(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset2(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset2(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer22.prototype.toJSON = function toJSON4() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer2(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer22.prototype);
  return buffer;
}
function _utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= 4096) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
  }
  return res;
}
function _latin1Slice2(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice2(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable2[buf[i]];
  }
  return out;
}
Buffer22.prototype.slice = function slice3(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer22.prototype);
  return newBuf;
};
Buffer22.prototype.readUintLE = Buffer22.prototype.readUIntLE = function readUIntLE3(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48LE2(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40LE2(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24LE2(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.readUintBE = Buffer22.prototype.readUIntBE = function readUIntBE3(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48BE2(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40BE2(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24BE2(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.readUint8 = Buffer22.prototype.readUInt8 = function readUInt84(offset = 0) {
  validateNumber2(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError2(offset, this.length - 1);
  }
  return val;
};
Buffer22.prototype.readUint16BE = Buffer22.prototype.readUInt16BE = readUInt16BE2;
Buffer22.prototype.readUint16LE = Buffer22.prototype.readUInt16LE = function readUInt16LE3(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer22.prototype.readUint32LE = Buffer22.prototype.readUInt32LE = function readUInt32LE3(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer22.prototype.readUint32BE = Buffer22.prototype.readUInt32BE = readUInt32BE2;
Buffer22.prototype.readBigUint64LE = Buffer22.prototype.readBigUInt64LE = defineBigIntMethod2(function readBigUInt64LE3(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer22.prototype.readBigUint64BE = Buffer22.prototype.readBigUInt64BE = defineBigIntMethod2(function readBigUInt64BE3(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer22.prototype.readIntLE = function readIntLE3(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48LE2(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40LE2(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24LE2(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.readIntBE = function readIntBE3(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48BE2(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40BE2(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24BE2(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.readInt8 = function readInt83(offset = 0) {
  validateNumber2(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError2(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer22.prototype.readInt16LE = function readInt16LE3(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer22.prototype.readInt16BE = function readInt16BE3(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer22.prototype.readInt32LE = function readInt32LE3(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer22.prototype.readInt32BE = function readInt32BE3(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer22.prototype.readBigInt64LE = defineBigIntMethod2(function readBigInt64LE3(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer22.prototype.readBigInt64BE = defineBigIntMethod2(function readBigInt64BE3(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer22.prototype.readFloatLE = function readFloatLE3(offset) {
  return bigEndian2 ? readFloatBackwards2(this, offset) : readFloatForwards2(this, offset);
};
Buffer22.prototype.readFloatBE = function readFloatBE3(offset) {
  return bigEndian2 ? readFloatForwards2(this, offset) : readFloatBackwards2(this, offset);
};
Buffer22.prototype.readDoubleLE = function readDoubleLE3(offset) {
  return bigEndian2 ? readDoubleBackwards2(this, offset) : readDoubleForwards2(this, offset);
};
Buffer22.prototype.readDoubleBE = function readDoubleBE3(offset) {
  return bigEndian2 ? readDoubleForwards2(this, offset) : readDoubleBackwards2(this, offset);
};
Buffer22.prototype.writeUintLE = Buffer22.prototype.writeUIntLE = function writeUIntLE3(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE2(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE2(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE2(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE2(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE2(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int82(this, value, offset, 0, 255);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.writeUintBE = Buffer22.prototype.writeUIntBE = function writeUIntBE3(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE2(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE2(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE2(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE2(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE2(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int82(this, value, offset, 0, 255);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.writeUint8 = Buffer22.prototype.writeUInt8 = function writeUInt83(value, offset = 0) {
  return writeU_Int82(this, value, offset, 0, 255);
};
Buffer22.prototype.writeUint16LE = Buffer22.prototype.writeUInt16LE = function writeUInt16LE3(value, offset = 0) {
  return writeU_Int16LE2(this, value, offset, 0, 65535);
};
Buffer22.prototype.writeUint16BE = Buffer22.prototype.writeUInt16BE = function writeUInt16BE3(value, offset = 0) {
  return writeU_Int16BE2(this, value, offset, 0, 65535);
};
Buffer22.prototype.writeUint32LE = Buffer22.prototype.writeUInt32LE = function writeUInt32LE3(value, offset = 0) {
  return _writeUInt32LE2(this, value, offset, 0, 4294967295);
};
Buffer22.prototype.writeUint32BE = Buffer22.prototype.writeUInt32BE = function writeUInt32BE3(value, offset = 0) {
  return _writeUInt32BE2(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE2(buf, value, offset, min3, max2) {
  checkIntBI2(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE2(buf, value, offset, min3, max2) {
  checkIntBI2(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer22.prototype.writeBigUint64LE = Buffer22.prototype.writeBigUInt64LE = defineBigIntMethod2(function writeBigUInt64LE3(value, offset = 0) {
  return wrtBigUInt64LE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer22.prototype.writeBigUint64BE = Buffer22.prototype.writeBigUInt64BE = defineBigIntMethod2(function writeBigUInt64BE3(value, offset = 0) {
  return wrtBigUInt64BE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer22.prototype.writeIntLE = function writeIntLE3(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE2(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE2(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE2(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE2(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE2(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int82(this, value, offset, -128, 127);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.writeIntBE = function writeIntBE3(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE2(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE2(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE2(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE2(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE2(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int82(this, value, offset, -128, 127);
  }
  boundsError2(byteLength3, 6, "byteLength");
};
Buffer22.prototype.writeInt8 = function writeInt83(value, offset = 0) {
  return writeU_Int82(this, value, offset, -128, 127);
};
Buffer22.prototype.writeInt16LE = function writeInt16LE3(value, offset = 0) {
  return writeU_Int16LE2(this, value, offset, -32768, 32767);
};
Buffer22.prototype.writeInt16BE = function writeInt16BE3(value, offset = 0) {
  return writeU_Int16BE2(this, value, offset, -32768, 32767);
};
Buffer22.prototype.writeInt32LE = function writeInt32LE3(value, offset = 0) {
  return writeU_Int32LE2(this, value, offset, -2147483648, 2147483647);
};
Buffer22.prototype.writeInt32BE = function writeInt32BE3(value, offset = 0) {
  return writeU_Int32BE2(this, value, offset, -2147483648, 2147483647);
};
Buffer22.prototype.writeBigInt64LE = defineBigIntMethod2(function writeBigInt64LE3(value, offset = 0) {
  return wrtBigUInt64LE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer22.prototype.writeBigInt64BE = defineBigIntMethod2(function writeBigInt64BE3(value, offset = 0) {
  return wrtBigUInt64BE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer22.prototype.writeFloatLE = function writeFloatLE3(value, offset) {
  return bigEndian2 ? writeFloatBackwards2(this, value, offset) : writeFloatForwards2(this, value, offset);
};
Buffer22.prototype.writeFloatBE = function writeFloatBE3(value, offset) {
  return bigEndian2 ? writeFloatForwards2(this, value, offset) : writeFloatBackwards2(this, value, offset);
};
Buffer22.prototype.writeDoubleLE = function writeDoubleLE3(value, offset) {
  return bigEndian2 ? writeDoubleBackwards2(this, value, offset) : writeDoubleForwards2(this, value, offset);
};
Buffer22.prototype.writeDoubleBE = function writeDoubleBE3(value, offset) {
  return bigEndian2 ? writeDoubleForwards2(this, value, offset) : writeDoubleBackwards2(this, value, offset);
};
Buffer22.prototype.copy = function copy4(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array2(this)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("source", [
      "Buffer",
      "Uint8Array"
    ], this);
  }
  if (!isUint8Array2(target)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger2(targetStart, 0);
    if (targetStart < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger2(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT322) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT322}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger2(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT322) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT322}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer22.prototype.fill = function fill3(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer22.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer22.isBuffer(val) ? val : Buffer22.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes2.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds5(buf, offset, byteLength23) {
  validateNumber2(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength23] === void 0) {
    boundsError2(offset, buf.length - (byteLength23 + 1));
  }
}
function checkIntBI2(value, min3, max2, buf, offset, byteLength23) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength23 > 3) {
      if (min3 === 0 || min3 === BigInt(0)) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength23 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength23 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength23 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds5(buf, offset, byteLength23);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer2(src, dst, offset, byteLength3) {
  let i;
  const length = byteLength3 === void 0 ? src.length : byteLength3;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance2(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable2 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j13 = 0; j13 < 16; ++j13) {
      table[i16 + j13] = alphabet[i] + alphabet[j13];
    }
  }
  return table;
}();
function defineBigIntMethod2(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined2 : fn;
}
function BufferBigIntNotDefined2() {
  throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var codes3 = {};
function hideStackFrames3(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", {
    value: hidden
  });
  return fn;
}
var _toString6 = Object.prototype.toString;
var _isObjectLike6 = (value) => value !== null && typeof value === "object";
var _isFunctionLike3 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer6(value) {
  return _isObjectLike6(value) && (_toString6.call(value) === "[object ArrayBuffer]" || _toString6.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Arguments]";
}
function isArrayBuffer6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction6(value) {
  return _isFunctionLike3(value) && _toString6.call(value) === "[object AsyncFunction]";
}
function isBooleanObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Boolean]";
}
function isBoxedPrimitive6(value) {
  return isBooleanObject6(value) || isStringObject6(value) || isNumberObject6(value) || isSymbolObject6(value) || isBigIntObject6(value);
}
function isDataView6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object DataView]";
}
function isDate7(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Date]";
}
function isGeneratorFunction6(value) {
  return _isFunctionLike3(value) && _toString6.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Generator]";
}
function isMap6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Map]";
}
function isMapIterator6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Module]";
}
function isNativeError6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Error]";
}
function isNumberObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Number]";
}
function isBigIntObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object BigInt]";
}
function isPromise6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Promise]";
}
function isRegExp7(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object RegExp]";
}
function isSet6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Set]";
}
function isSetIterator6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object String]";
}
function isSymbolObject6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Symbol]";
}
function isWeakMap6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object WeakMap]";
}
function isWeakSet6(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object WeakSet]";
}
var __default19 = {
  isAsyncFunction: isAsyncFunction6,
  isGeneratorFunction: isGeneratorFunction6,
  isAnyArrayBuffer: isAnyArrayBuffer6,
  isArrayBuffer: isArrayBuffer6,
  isArgumentsObject: isArgumentsObject6,
  isBoxedPrimitive: isBoxedPrimitive6,
  isDataView: isDataView6,
  isMap: isMap6,
  isMapIterator: isMapIterator6,
  isModuleNamespaceObject: isModuleNamespaceObject6,
  isNativeError: isNativeError6,
  isPromise: isPromise6,
  isSet: isSet6,
  isSetIterator: isSetIterator6,
  isWeakMap: isWeakMap6,
  isWeakSet: isWeakSet6,
  isRegExp: isRegExp7,
  isDate: isDate7,
  isStringObject: isStringObject6,
  isNumberObject: isNumberObject6,
  isBooleanObject: isBooleanObject6,
  isBigIntObject: isBigIntObject6
};
var mod109 = {
  isAnyArrayBuffer: isAnyArrayBuffer6,
  isArgumentsObject: isArgumentsObject6,
  isArrayBuffer: isArrayBuffer6,
  isAsyncFunction: isAsyncFunction6,
  isBooleanObject: isBooleanObject6,
  isBoxedPrimitive: isBoxedPrimitive6,
  isDataView: isDataView6,
  isDate: isDate7,
  isGeneratorFunction: isGeneratorFunction6,
  isGeneratorObject: isGeneratorObject6,
  isMap: isMap6,
  isMapIterator: isMapIterator6,
  isModuleNamespaceObject: isModuleNamespaceObject6,
  isNativeError: isNativeError6,
  isNumberObject: isNumberObject6,
  isBigIntObject: isBigIntObject6,
  isPromise: isPromise6,
  isRegExp: isRegExp7,
  isSet: isSet6,
  isSetIterator: isSetIterator6,
  isSharedArrayBuffer: isSharedArrayBuffer6,
  isStringObject: isStringObject6,
  isSymbolObject: isSymbolObject6,
  isWeakMap: isWeakMap6,
  isWeakSet: isWeakSet6,
  default: __default19
};
Symbol("kHandle");
var kKeyObject2 = Symbol("kKeyObject");
var kKeyType2 = Symbol("kKeyType");
function isKeyObject2(obj2) {
  return obj2 != null && obj2[kKeyType2] !== void 0;
}
function isCryptoKey2(obj2) {
  return obj2 != null && obj2[kKeyObject2] !== void 0;
}
var _toString7 = Object.prototype.toString;
var _isObjectLike7 = (value) => value !== null && typeof value === "object";
function isArrayBufferView3(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object BigUint64Array]";
}
function isFloat32Array2(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Float32Array]";
}
function isFloat64Array2(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Float64Array]";
}
function isInt8Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Int8Array]";
}
function isInt16Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Int16Array]";
}
function isInt32Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Int32Array]";
}
function isTypedArray2(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike7(value) && reTypedTag.test(_toString7.call(value));
}
function isUint8Array3(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Uint16Array]";
}
function isUint32Array1(value) {
  return _isObjectLike7(value) && _toString7.call(value) === "[object Uint32Array]";
}
var { isDate: isDate8, isArgumentsObject: isArgumentsObject7, isBigIntObject: isBigIntObject7, isBooleanObject: isBooleanObject7, isNumberObject: isNumberObject7, isStringObject: isStringObject7, isSymbolObject: isSymbolObject7, isNativeError: isNativeError7, isRegExp: isRegExp8, isAsyncFunction: isAsyncFunction7, isGeneratorFunction: isGeneratorFunction7, isGeneratorObject: isGeneratorObject7, isPromise: isPromise7, isMap: isMap7, isSet: isSet7, isMapIterator: isMapIterator7, isSetIterator: isSetIterator7, isWeakMap: isWeakMap7, isWeakSet: isWeakSet7, isArrayBuffer: isArrayBuffer7, isDataView: isDataView7, isSharedArrayBuffer: isSharedArrayBuffer7, isModuleNamespaceObject: isModuleNamespaceObject7, isAnyArrayBuffer: isAnyArrayBuffer7, isBoxedPrimitive: isBoxedPrimitive7 } = mod109;
var mod110 = {
  isCryptoKey: isCryptoKey2,
  isKeyObject: isKeyObject2,
  isArrayBufferView: isArrayBufferView3,
  isBigInt64Array: isBigInt64Array1,
  isBigUint64Array: isBigUint64Array1,
  isFloat32Array: isFloat32Array2,
  isFloat64Array: isFloat64Array2,
  isInt8Array: isInt8Array1,
  isInt16Array: isInt16Array1,
  isInt32Array: isInt32Array1,
  isTypedArray: isTypedArray2,
  isUint8Array: isUint8Array3,
  isUint8ClampedArray: isUint8ClampedArray1,
  isUint16Array: isUint16Array1,
  isUint32Array: isUint32Array1,
  isDate: isDate8,
  isArgumentsObject: isArgumentsObject7,
  isBigIntObject: isBigIntObject7,
  isBooleanObject: isBooleanObject7,
  isNumberObject: isNumberObject7,
  isStringObject: isStringObject7,
  isSymbolObject: isSymbolObject7,
  isNativeError: isNativeError7,
  isRegExp: isRegExp8,
  isAsyncFunction: isAsyncFunction7,
  isGeneratorFunction: isGeneratorFunction7,
  isGeneratorObject: isGeneratorObject7,
  isPromise: isPromise7,
  isMap: isMap7,
  isSet: isSet7,
  isMapIterator: isMapIterator7,
  isSetIterator: isSetIterator7,
  isWeakMap: isWeakMap7,
  isWeakSet: isWeakSet7,
  isArrayBuffer: isArrayBuffer7,
  isDataView: isDataView7,
  isSharedArrayBuffer: isSharedArrayBuffer7,
  isModuleNamespaceObject: isModuleNamespaceObject7,
  isAnyArrayBuffer: isAnyArrayBuffer7,
  isBoxedPrimitive: isBoxedPrimitive7
};
function normalizeEncoding7(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases5(enc);
}
function slowCases5(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}
function isInt323(value) {
  return value === (value | 0);
}
function isUint323(value) {
  return value === value >>> 0;
}
var validateBuffer3 = hideStackFrames3((buffer, name = "buffer") => {
  if (!isArrayBufferView3(buffer)) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, [
      "Buffer",
      "TypedArray",
      "DataView"
    ], buffer);
  }
});
hideStackFrames3((value, name, min3 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
var validateObject2 = hideStackFrames3((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
hideStackFrames3((value, name, min3 = -2147483648, max2 = 2147483647) => {
  if (!isInt323(value)) {
    if (typeof value !== "number") {
      throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
  if (value < min3 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
});
hideStackFrames3((value, name, positive) => {
  if (!isUint323(value)) {
    if (typeof value !== "number") {
      throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min3 = positive ? 1 : 0;
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min3} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes3.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString2(value, name) {
  if (typeof value !== "string") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
hideStackFrames3((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v19) => typeof v19 === "string" ? `'${v19}'` : String(v19)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback2 = hideStackFrames3((callback) => {
  if (typeof callback !== "function") {
    throw new codes3.ERR_INVALID_CALLBACK(callback);
  }
});
hideStackFrames3((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction3 = hideStackFrames3((value, name) => {
  if (typeof value !== "function") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
hideStackFrames3((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty3 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty3.enumerable = true;
var codesWarned1 = /* @__PURE__ */ new Set();
function deprecate1(fn, msg, code2) {
  if (code2 !== void 0) {
    validateString2(code2, "code");
  }
  let warned = false;
  function deprecated(...args) {
    if (!warned) {
      warned = true;
      if (code2 !== void 0) {
        if (!codesWarned1.has(code2)) {
          process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
          codesWarned1.add(code2);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args, new.target);
    }
    return Reflect.apply(fn, this, args);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol3 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol3 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify3(original) {
  validateFunction3(original, "original");
  if (original[kCustomPromisifiedSymbol3]) {
    const fn = original[kCustomPromisifiedSymbol3];
    validateFunction3(fn, "util.promisify.custom");
    return Object.defineProperty(fn, kCustomPromisifiedSymbol3, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol3];
  function fn1(...args) {
    return new Promise((resolve9, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve9(obj2);
        } else {
          resolve9(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
  Object.defineProperty(fn1, kCustomPromisifiedSymbol3, {
    value: fn1,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify3.custom = kCustomPromisifiedSymbol3;
var core2;
if (Deno?.core) {
  core2 = Deno.core;
} else {
  core2 = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}
var _exiting2 = false;
var kSize2 = 2048;
var kMask2 = 2048 - 1;
var FixedCircularBuffer2 = class {
  bottom;
  top;
  list;
  next;
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize2);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask2) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask2;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask2;
    return nextItem;
  }
};
var FixedQueue2 = class {
  head;
  tail;
  constructor() {
    this.head = this.tail = new FixedCircularBuffer2();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer2();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};
var queue2 = new FixedQueue2();
var _nextTick2;
if (typeof core2.setNextTickCallback !== "undefined") {
  let runNextTicks2 = function() {
    if (!core2.hasTickScheduled()) {
      core2.runMicrotasks();
    }
    if (!core2.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections2();
    return true;
  }, processTicksAndRejections2 = function() {
    let tock;
    do {
      while (tock = queue2.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core2.runMicrotasks();
    } while (!queue2.isEmpty());
    core2.setHasTickScheduled(false);
  }, __nextTickNative2 = function(callback, ...args) {
    validateCallback2(callback);
    if (_exiting2) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [
          args[0]
        ];
        break;
      case 2:
        args_ = [
          args[0],
          args[1]
        ];
        break;
      case 3:
        args_ = [
          args[0],
          args[1],
          args[2]
        ];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue2.isEmpty()) {
      core2.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue2.push(tickObject);
  };
  runNextTicks22 = runNextTicks2, processTicksAndRejections22 = processTicksAndRejections2, __nextTickNative22 = __nextTickNative2;
  core2.setNextTickCallback(processTicksAndRejections2);
  core2.setMacrotaskCallback(runNextTicks2);
  _nextTick2 = __nextTickNative2;
} else {
  let __nextTickQueueMicrotask2 = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  __nextTickQueueMicrotask22 = __nextTickQueueMicrotask2;
  _nextTick2 = __nextTickQueueMicrotask2;
}
var runNextTicks22;
var processTicksAndRejections22;
var __nextTickNative22;
var __nextTickQueueMicrotask22;
function nextTick5(callback, ...args) {
  _nextTick2(callback, ...args);
}
var NodeFalsyValueRejectionError1 = class extends Error {
  reason;
  code = "ERR_FALSY_VALUE_REJECTION";
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError1 = class extends TypeError {
  code = "ERR_INVALID_ARG_TYPE";
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
  }
};
function callbackify1(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError1('"original"');
  }
  const callbackified = function(...args) {
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError1("last");
    }
    const cb = (...args2) => {
      maybeCb.apply(this, args2);
    };
    original.apply(this, args).then((ret) => {
      nextTick5(cb.bind(this, null, ret));
    }, (rej) => {
      rej = rej || new NodeFalsyValueRejectionError1(rej);
      nextTick5(cb.bind(this, rej));
    });
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}
var State2;
(function(State3) {
  State3[State3["PASSTHROUGH"] = 0] = "PASSTHROUGH";
  State3[State3["PERCENT"] = 1] = "PERCENT";
  State3[State3["POSITIONAL"] = 2] = "POSITIONAL";
  State3[State3["PRECISION"] = 3] = "PRECISION";
  State3[State3["WIDTH"] = 4] = "WIDTH";
})(State2 || (State2 = {}));
var WorP2;
(function(WorP3) {
  WorP3[WorP3["WIDTH"] = 0] = "WIDTH";
  WorP3[WorP3["PRECISION"] = 1] = "PRECISION";
})(WorP2 || (WorP2 = {}));
var Flags2 = class {
  plus;
  dash;
  sharp;
  space;
  zero;
  lessthan;
  width = -1;
  precision = -1;
};
var min22 = Math.min;
var UNICODE_REPLACEMENT_CHARACTER2 = "\uFFFD";
var FLOAT_REGEXP2 = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F11;
(function(F12) {
  F12[F12["sign"] = 1] = "sign";
  F12[F12["mantissa"] = 2] = "mantissa";
  F12[F12["fractional"] = 3] = "fractional";
  F12[F12["esign"] = 4] = "esign";
  F12[F12["exponent"] = 5] = "exponent";
})(F11 || (F11 = {}));
var Printf2 = class {
  format;
  args;
  i;
  state = State2.PASSTHROUGH;
  verb = "";
  buf = "";
  argNum = 0;
  flags = new Flags2();
  haveSeen;
  tmpError;
  constructor(format12, ...args) {
    this.format = format12;
    this.args = args;
    this.haveSeen = Array.from({
      length: args.length
    });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c13 = this.format[this.i];
      switch (this.state) {
        case State2.PASSTHROUGH:
          if (c13 === "%") {
            this.state = State2.PERCENT;
          } else {
            this.buf += c13;
          }
          break;
        case State2.PERCENT:
          if (c13 === "%") {
            this.buf += c13;
            this.state = State2.PASSTHROUGH;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags2();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c13 = this.format[this.i];
      switch (this.state) {
        case State2.PERCENT:
          switch (c13) {
            case "[":
              this.handlePositional();
              this.state = State2.POSITIONAL;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c13 && c13 <= "9" || c13 === "." || c13 === "*") {
                if (c13 === ".") {
                  this.flags.precision = 0;
                  this.state = State2.PRECISION;
                  this.i++;
                } else {
                  this.state = State2.WIDTH;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case State2.POSITIONAL:
          if (c13 === "*") {
            const worp = this.flags.precision === -1 ? WorP2.WIDTH : WorP2.PRECISION;
            this.handleWidthOrPrecisionRef(worp);
            this.state = State2.PERCENT;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case WorP2.WIDTH:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === WorP2.WIDTH ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c13 = fmt[this.i];
      switch (this.state) {
        case State2.WIDTH:
          switch (c13) {
            case ".":
              this.flags.precision = 0;
              this.state = State2.PRECISION;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(WorP2.WIDTH);
              break;
            default: {
              const val = parseInt(c13);
              if (isNaN(val)) {
                this.i--;
                this.state = State2.PERCENT;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case State2.PRECISION: {
          if (c13 === "*") {
            this.handleWidthOrPrecisionRef(WorP2.PRECISION);
            break;
          }
          const val1 = parseInt(c13);
          if (isNaN(val1)) {
            this.i--;
            this.state = State2.PERCENT;
            return;
          }
          flags.precision *= 10;
          flags.precision += val1;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format12 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format12[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format12[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = State2.PASSTHROUGH;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s10) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s10.padEnd(this.flags.width, padding);
    }
    return s10.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign2;
    if (neg3) {
      sign2 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign2 = this.flags.plus ? "+" : " ";
    } else {
      sign2 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign2 + nStr;
    }
    const pad2 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign2.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad2);
    } else {
      nStr = nStr.padStart(len, pad2);
    }
    if (zero) {
      nStr = sign2 + nStr;
    }
    return nStr;
  }
  fmtNumber(n3, radix, upcase = false) {
    let num = Math.abs(n3).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n3 === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n3 < 0);
  }
  fmtNumberCodePoint(n3) {
    let s10 = "";
    try {
      s10 = String.fromCodePoint(n3);
    } catch {
      s10 = UNICODE_REPLACEMENT_CHARACTER2;
    }
    return this.pad(s10);
  }
  fmtFloatSpecial(n3) {
    if (isNaN(n3)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n3 === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n3 === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [
      fractional,
      round
    ];
  }
  fmtFloatE(n3, upcase = false) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    const m20 = n3.toExponential().match(FLOAT_REGEXP2);
    if (!m20) {
      throw Error("can't happen, bug");
    }
    let fractional = m20[F11.fractional];
    const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m20[F11.exponent];
    let esign = m20[F11.esign];
    let mantissa = parseInt(m20[F11.mantissa]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r2 = parseInt(esign + e) + 1;
        e = r2.toString();
        esign = r2 < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n3 < 0);
  }
  fmtFloatF(n3) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    function expandNumber(n4) {
      if (Number.isSafeInteger(n4)) {
        return n4.toString() + ".";
      }
      const t2 = n4.toExponential().split("e");
      let m20 = t2[0].replace(".", "");
      const e = parseInt(t2[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m20;
      } else {
        const splIdx = e + 1;
        while (m20.length < splIdx) {
          m20 += "0";
        }
        return m20.substr(0, splIdx) + "." + m20.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n3));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n3 < 0);
  }
  fmtFloatG(n3, upcase = false) {
    const special = this.fmtFloatSpecial(n3);
    if (special !== "") {
      return special;
    }
    let P13 = this.flags.precision !== -1 ? this.flags.precision : 6;
    P13 = P13 === 0 ? 1 : P13;
    const m20 = n3.toExponential().match(FLOAT_REGEXP2);
    if (!m20) {
      throw Error("can't happen");
    }
    const X5 = parseInt(m20[F11.exponent]) * (m20[F11.esign] === "-" ? -1 : 1);
    let nStr = "";
    if (P13 > X5 && X5 >= -4) {
      this.flags.precision = P13 - (X5 + 1);
      nStr = this.fmtFloatF(n3);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P13 - 1;
      nStr = this.fmtFloatE(n3);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s10) {
    if (this.flags.precision !== -1) {
      s10 = s10.substr(0, this.flags.precision);
    }
    return this.pad(s10);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min22(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c13 = (val.charCodeAt(i) & 255).toString(16);
          hex += c13.length === 1 ? `0${c13}` : c13;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? {
        depth: this.flags.precision
      } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p7 = this.flags.precision;
      return p7 === -1 ? val.toString() : val.toString().substr(0, p7);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf2(format12, ...args) {
  const printf = new Printf2(format12, ...args);
  return printf.doPrintf();
}
var { Deno: Deno3 } = globalThis;
typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
var DiffType2;
(function(DiffType3) {
  DiffType3["removed"] = "removed";
  DiffType3["common"] = "common";
  DiffType3["added"] = "added";
})(DiffType2 || (DiffType2 = {}));
var AssertionError2 = class extends Error {
  name = "AssertionError";
  constructor(message) {
    super(message);
  }
};
function unreachable2() {
  throw new AssertionError2("unreachable");
}
var DenoStdInternalError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert4(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError2(msg);
  }
}
function indexOfNeedle3(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s10 = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s10)
      continue;
    const pin = i;
    let matched = 1;
    let j13 = i;
    while (matched < needle.length) {
      j13++;
      if (source[j13] !== needle[j13 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}
var CR2 = "\r".charCodeAt(0);
var LF2 = "\n".charCodeAt(0);
var _TextDecoder1 = TextDecoder;
var _TextEncoder1 = TextEncoder;
var isNumericLookup2 = {};
function isArrayIndex2(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup2[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup2[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup2[value] = false;
        }
      }
      return isNumericLookup2[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties2(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k15) => !isArrayIndex2(k15));
  }
  if (filter === 0) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & 1 && !desc.writable) {
      continue;
    }
    if (filter & 2 && !desc.enumerable) {
      continue;
    }
    if (filter & 4 && !desc.configurable) {
      continue;
    }
    if (filter & 8 && typeof key2 === "string") {
      continue;
    }
    if (filter & 16 && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}
var kObjectType2 = 0;
var kArrayExtrasType2 = 2;
var kRejected2 = 2;
var meta2 = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject2 = (v19) => typeof v19 === "undefined" && v19 !== void 0;
var strEscapeSequencesRegExp2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp2 = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp2 = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp2 = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp4 = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp2 = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions2 = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions2(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect32(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor2,
    showHidden: inspectDefaultOptions2.showHidden,
    depth: inspectDefaultOptions2.depth,
    colors: inspectDefaultOptions2.colors,
    customInspect: inspectDefaultOptions2.customInspect,
    showProxy: inspectDefaultOptions2.showProxy,
    maxArrayLength: inspectDefaultOptions2.maxArrayLength,
    maxStringLength: inspectDefaultOptions2.maxStringLength,
    breakLength: inspectDefaultOptions2.breakLength,
    compact: inspectDefaultOptions2.compact,
    sorted: inspectDefaultOptions2.sorted,
    getters: inspectDefaultOptions2.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions2.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor2;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue2(ctx, value, 0);
}
var customInspectSymbol5 = Symbol.for("nodejs.util.inspect.custom");
inspect32.custom = customInspectSymbol5;
Object.defineProperty(inspect32, "defaultOptions", {
  get() {
    return inspectDefaultOptions2;
  },
  set(options) {
    validateObject2(options, "options");
    return Object.assign(inspectDefaultOptions2, options);
  }
});
var defaultFG2 = 39;
var defaultBG2 = 49;
inspect32.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [
    0,
    0
  ],
  bold: [
    1,
    22
  ],
  dim: [
    2,
    22
  ],
  italic: [
    3,
    23
  ],
  underline: [
    4,
    24
  ],
  blink: [
    5,
    25
  ],
  inverse: [
    7,
    27
  ],
  hidden: [
    8,
    28
  ],
  strikethrough: [
    9,
    29
  ],
  doubleunderline: [
    21,
    24
  ],
  black: [
    30,
    defaultFG2
  ],
  red: [
    31,
    defaultFG2
  ],
  green: [
    32,
    defaultFG2
  ],
  yellow: [
    33,
    defaultFG2
  ],
  blue: [
    34,
    defaultFG2
  ],
  magenta: [
    35,
    defaultFG2
  ],
  cyan: [
    36,
    defaultFG2
  ],
  white: [
    37,
    defaultFG2
  ],
  bgBlack: [
    40,
    defaultBG2
  ],
  bgRed: [
    41,
    defaultBG2
  ],
  bgGreen: [
    42,
    defaultBG2
  ],
  bgYellow: [
    43,
    defaultBG2
  ],
  bgBlue: [
    44,
    defaultBG2
  ],
  bgMagenta: [
    45,
    defaultBG2
  ],
  bgCyan: [
    46,
    defaultBG2
  ],
  bgWhite: [
    47,
    defaultBG2
  ],
  framed: [
    51,
    54
  ],
  overlined: [
    53,
    55
  ],
  gray: [
    90,
    defaultFG2
  ],
  redBright: [
    91,
    defaultFG2
  ],
  greenBright: [
    92,
    defaultFG2
  ],
  yellowBright: [
    93,
    defaultFG2
  ],
  blueBright: [
    94,
    defaultFG2
  ],
  magentaBright: [
    95,
    defaultFG2
  ],
  cyanBright: [
    96,
    defaultFG2
  ],
  whiteBright: [
    97,
    defaultFG2
  ],
  bgGray: [
    100,
    defaultBG2
  ],
  bgRedBright: [
    101,
    defaultBG2
  ],
  bgGreenBright: [
    102,
    defaultBG2
  ],
  bgYellowBright: [
    103,
    defaultBG2
  ],
  bgBlueBright: [
    104,
    defaultBG2
  ],
  bgMagentaBright: [
    105,
    defaultBG2
  ],
  bgCyanBright: [
    106,
    defaultBG2
  ],
  bgWhiteBright: [
    107,
    defaultBG2
  ]
});
function defineColorAlias2(target, alias) {
  Object.defineProperty(inspect32.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias2("gray", "grey");
defineColorAlias2("gray", "blackBright");
defineColorAlias2("bgGray", "bgGrey");
defineColorAlias2("bgGray", "bgBlackBright");
defineColorAlias2("dim", "faint");
defineColorAlias2("strikethrough", "crossedout");
defineColorAlias2("strikethrough", "strikeThrough");
defineColorAlias2("strikethrough", "crossedOut");
defineColorAlias2("hidden", "conceal");
defineColorAlias2("inverse", "swapColors");
defineColorAlias2("inverse", "swapcolors");
defineColorAlias2("doubleunderline", "doubleUnderline");
inspect32.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes2(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn2 = (str) => meta2[str.charCodeAt(0)];
function strEscape2(str) {
  let escapeTest = strEscapeSequencesRegExp2;
  let escapeReplace = strEscapeSequencesReplacer2;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle2;
      escapeReplace = strEscapeSequencesReplacerSingle2;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes2(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn2);
    return addQuotes2(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta2[point];
      } else {
        result += `${str.slice(last, i)}${meta2[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes2(result, singleQuote);
}
function stylizeWithColor2(str, styleType) {
  const style = inspect32.styles[styleType];
  if (style !== void 0) {
    const color = inspect32.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor2(str) {
  return str;
}
function formatValue2(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject2(value)) {
    return formatPrimitive2(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol5];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect32 && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions2(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue2(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw2(ctx, value, recurseTimes, typedArray);
}
function formatRaw2(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName2(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base2 = "";
  let formatter = getEmptyFormatArray2;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? 0 : 2;
  let extrasType = 0;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix2(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties2(value, filter);
      braces = [
        `${prefix}[`,
        "]"
      ];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType2;
      formatter = formatArray2;
    } else if (isSet7(value)) {
      const size = value.size;
      const prefix1 = getPrefix2(constructor, tag2, "Set", `(${size})`);
      keys = getKeys2(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet2.bind(null, value) : formatSet2.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix1}{}`;
      }
      braces = [
        `${prefix1}{`,
        "}"
      ];
    } else if (isMap7(value)) {
      const size1 = value.size;
      const prefix2 = getPrefix2(constructor, tag2, "Map", `(${size1})`);
      keys = getKeys2(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap2.bind(null, value) : formatMap2.bind(null, value.entries());
      if (size1 === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix2}{}`;
      }
      braces = [
        `${prefix2}{`,
        "}"
      ];
    } else if (isTypedArray2(value)) {
      keys = getOwnNonIndexProperties2(value, filter);
      const bound = value;
      const fallback = "";
      const size2 = value.length;
      const prefix3 = getPrefix2(constructor, tag2, fallback, `(${size2})`);
      braces = [
        `${prefix3}[`,
        "]"
      ];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray2.bind(null, bound, size2);
      extrasType = kArrayExtrasType2;
    } else if (isMapIterator7(value)) {
      keys = getKeys2(value, ctx.showHidden);
      braces = getIteratorBraces2("Map", tag2);
      formatter = formatIterator2.bind(null, braces);
    } else if (isSetIterator7(value)) {
      keys = getKeys2(value, ctx.showHidden);
      braces = getIteratorBraces2("Set", tag2);
      formatter = formatIterator2.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys2(value, ctx.showHidden);
    braces = [
      "{",
      "}"
    ];
    if (constructor === "Object") {
      if (isArgumentsObject7(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix2(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base2 = getFunctionBase2(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "special");
      }
    } else if (isRegExp8(value)) {
      base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix4 = getPrefix2(constructor, tag2, "RegExp");
      if (prefix4 !== "RegExp ") {
        base2 = `${prefix4}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base2, "regexp");
      }
    } else if (isDate8(value)) {
      base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix5 = getPrefix2(constructor, tag2, "Date");
      if (prefix5 !== "Date ") {
        base2 = `${prefix5}${base2}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base2, "date");
      }
    } else if (value instanceof Error) {
      base2 = formatError2(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else if (isAnyArrayBuffer7(value)) {
      const arrayType = isArrayBuffer7(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix6 = getPrefix2(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer2;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix6 + `{ byteLength: ${formatNumber2(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix6}{`;
      Array.prototype.unshift.call(keys, "byteLength");
    } else if (isDataView7(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise7(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "Promise")}{`;
      formatter = formatPromise2;
    } else if (isWeakSet7(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet2 : formatWeakCollection2;
    } else if (isWeakMap7(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap2 : formatWeakCollection2;
    } else if (isModuleNamespaceObject7(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject2.bind(null, keys);
    } else if (isBoxedPrimitive7(value)) {
      base2 = getBoxedBase2(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base2;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle2(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle2(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle2(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty2(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName1 = getCtxStyle2(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize2(ctx, err, constructorName1, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base2 = base2 === "" ? reference : `${reference} ${base2}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === 0) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString2(ctx, output, base2, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects2 = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties2(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach.call(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push.call(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty2(ctx, obj2, recurseTimes, key2, 0, desc, main);
      if (ctx.colors) {
        Array.prototype.push.call(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push.call(output, value);
      }
    }
    Array.prototype.pop.call(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName2(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject2(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof2(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects2.has(descriptor.value.name))) {
        addPrototypeProperties2(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName2(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect32(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive2(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape2(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape2(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber2(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt2(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray2() {
  return [];
}
function isInstanceof2(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix2(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray2(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray2(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty2(ctx, value, recurseTimes, i, 1));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle2(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix2(constructor, tag2, fallback);
}
function getKeys2(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet2(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v19 of value) {
    Array.prototype.push.call(output, formatValue2(ctx, v19, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap2(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k15, 1: v19 } of value) {
    output.push(`${formatValue2(ctx, k15, recurseTimes)} => ${formatValue2(ctx, v19, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray2(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber2 : formatBigInt2;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue2(ctx, value[key2], recurseTimes, true);
      Array.prototype.push.call(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces2(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [
    `[${tag2}] {`,
    "}"
  ];
}
function formatIterator2(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner2(ctx, recurseTimes, entries, 2);
  }
  return formatSetIterInner2(ctx, recurseTimes, entries, 1);
}
function getFunctionBase2(value, constructor, tag2) {
  const stringified = Function.prototype.toString.call(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice6 = stringified.slice(5, -1);
    const bracketIndex = slice6.indexOf("{");
    if (bracketIndex !== -1 && (!slice6.slice(0, bracketIndex).includes("(") || classRegExp4.test(slice6.replace(stripCommentsRegExp2)))) {
      return getClassBase2(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction7(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction7(value)) {
    type = `Async${type}`;
  }
  let base2 = `[${type}`;
  if (constructor === null) {
    base2 += " (null prototype)";
  }
  if (value.name === "") {
    base2 += " (anonymous)";
  } else {
    base2 += `: ${value.name}`;
  }
  base2 += "]";
  if (constructor !== type && constructor !== null) {
    base2 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base2 += ` [${tag2}]`;
  }
  return base2;
}
function formatError2(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name1 of [
      "name",
      "message",
      "stack"
    ]) {
      const index = keys.indexOf(name1);
      if (index !== -1 && stack.includes(err[name1])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix2(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos1 = 0;
      while (nodeModule = nodeModulesRegExp2.exec(line)) {
        newStack += line.slice(pos1, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos1 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos1 === 0 ? line : line.slice(pos1);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice22;
function formatArrayBuffer2(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [
      ctx.stylize("(detached)", "special")
    ];
  }
  let str = hexSlice22(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [
    `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
  ];
}
function formatNumber2(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise2(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === 0) {
    output = [
      ctx.stylize("<pending>", "special")
    ];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue2(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected2 ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection2(ctx) {
  return [
    ctx.stylize("<items unknown>", "special")
  ];
}
function formatWeakSet2(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner2(ctx, recurseTimes, entries, 0);
}
function formatWeakMap2(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner2(ctx, recurseTimes, entries, 0);
}
function formatProperty2(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || {
    value: value[key2],
    enumerable: true
  };
  if (desc.value !== void 0) {
    const diff2 = ctx.compact !== true || type !== 0 ? 2 : 3;
    ctx.indentationLvl += diff2;
    str = formatValue2(ctx, desc.value, recurseTimes);
    if (diff2 === 3 && ctx.breakLength < getStringWidth2(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff2;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s10 = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s10(`[${label}:`, sp)} ${s10("null", "null")}${s10("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s10(`[${label}]`, sp)} ${formatValue2(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive2(s10, tmp, ctx);
          str = `${s10(`[${label}:`, sp)} ${primitive}${s10("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s10(`[${label}:`, sp)} ${message}${s10("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === 1) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp1 = key2.toString().replace(strEscapeSequencesReplacer2, escapeFn2);
    name = `[${ctx.stylize(tmp1, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp2 = key2.replace(strEscapeSequencesReplacer2, escapeFn2);
    name = `[${tmp2}]`;
  } else if (keyStrRegExp2.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape2(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize2(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp2 = /\u001b\[\d\d?m/g;
function removeColors2(str) {
  return str.replace(colorRegExp2, "");
}
function isBelowBreakLength2(ctx, output, start, base2) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors2(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base2 === "" || !base2.includes("\n");
}
function formatBigInt2(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject2(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty2(ctx, value, recurseTimes, keys[i], kObjectType2);
    } catch (_err) {
      const tmp = {
        [keys[i]]: ""
      };
      output[i] = formatProperty2(ctx, tmp, recurseTimes, keys[i], kObjectType2);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray2(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp2.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty2(ctx, value, recurseTimes, key2, 1));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending1 = remaining > 1 ? "s" : "";
      const message1 = `<${remaining} empty item${ending1}>`;
      output.push(ctx.stylize(message1, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase2(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject7(value)) {
    type = "Number";
  } else if (isStringObject7(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject7(value)) {
    type = "Boolean";
  } else if (isBigIntObject7(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base2 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base2 += " (null prototype)";
    } else {
      base2 += ` (${constructor})`;
    }
  }
  base2 += `: ${formatPrimitive2(stylizeNoColor2, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base2 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor2) {
    return base2;
  }
  return ctx.stylize(base2, type.toLowerCase());
}
function getClassBase2(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base2 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base2 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base2 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base2 += ` extends ${superName}`;
    }
  } else {
    base2 += " extends [null prototype]";
  }
  return `[${base2}]`;
}
function reduceToSingleString2(ctx, output, base2, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === 2 && entries > 6) {
        output = groupArrayElements2(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base2.length + 10;
        if (isBelowBreakLength2(ctx, output, start, base2)) {
          return `${base2 ? `${base2} ` : ""}${braces[0]} ${join10(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base2 ? `${base2} ` : ""}${braces[0]}${indentation}  ${join10(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  }
  if (isBelowBreakLength2(ctx, output, 0, base2)) {
    return `${braces[0]}${base2 ? ` ${base2}` : ""} ${join10(output, ", ")} ` + braces[1];
  }
  const indentation1 = " ".repeat(ctx.indentationLvl);
  const ln = base2 === "" && braces[0].length === 1 ? " " : `${base2 ? ` ${base2}` : ""}
${indentation1}  `;
  return `${braces[0]}${ln}${join10(output, `,
${indentation1}  `)} ${braces[1]}`;
}
function join10(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements2(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth2(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + 2;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i12 = 0; i12 < columns; i12++) {
      let lineMaxLength = 0;
      for (let j13 = i12; j13 < output.length; j13 += columns) {
        if (dataLen[j13] > lineMaxLength) {
          lineMaxLength = dataLen[j13];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i12] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i22 = 0; i22 < output.length; i22++) {
        if (typeof value[i22] !== "number" && typeof value[i22] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i32 = 0; i32 < outputLength; i32 += columns) {
      const max2 = Math.min(i32 + columns, outputLength);
      let str = "";
      let j13 = i32;
      for (; j13 < max2 - 1; j13++) {
        const padding = maxLineLength[j13 - i32] + output[j13].length - dataLen[j13];
        str += `${output[j13]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding1 = maxLineLength[j13 - i32] + output[j13].length - dataLen[j13] - 2;
        str += output[j13].padStart(padding1, " ");
      } else {
        str += output[j13];
      }
      Array.prototype.push.call(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push.call(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner2(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === 0) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue2(ctx, entries[pos], recurseTimes)} => ${formatValue2(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos1 = i * 2;
      const res = [
        formatValue2(ctx, entries[pos1], recurseTimes),
        formatValue2(ctx, entries[pos1 + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString2(ctx, res, "", [
        "[",
        "]"
      ], kArrayExtrasType2, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner2(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue2(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === 0 && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern2 = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi2 = new RegExp(ansiPattern2, "g");
function getStringWidth2(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters2(str);
  }
  str = str.normalize("NFC");
  for (const __char of str[Symbol.iterator]()) {
    const code2 = __char.codePointAt(0);
    if (isFullWidthCodePoint2(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint2(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint2 = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint2 = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function hasBuiltInToString1(value) {
  const proxyTarget = void 0;
  if (proxyTarget !== void 0) {
    value = proxyTarget;
  }
  if (typeof value.toString !== "function") {
    return true;
  }
  if (Object.prototype.hasOwnProperty.call(value, "toString")) {
    return false;
  }
  let pointer = value;
  do {
    pointer = Object.getPrototypeOf(pointer);
  } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
  const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
  return descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name);
}
var firstErrorLine1 = (error2) => error2.message.split("\n", 1)[0];
var CIRCULAR_ERROR_MESSAGE1;
function tryStringify1(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    if (!CIRCULAR_ERROR_MESSAGE1) {
      try {
        const a7 = {};
        a7.a = a7;
        JSON.stringify(a7);
      } catch (circularError) {
        CIRCULAR_ERROR_MESSAGE1 = firstErrorLine1(circularError);
      }
    }
    if (err.name === "TypeError" && firstErrorLine1(err) === CIRCULAR_ERROR_MESSAGE1) {
      return "[Circular]";
    }
    throw err;
  }
}
function format8(...args) {
  return formatWithOptionsInternal1(void 0, args);
}
function formatWithOptions1(inspectOptions, ...args) {
  if (typeof inspectOptions !== "object" || inspectOptions === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
  }
  return formatWithOptionsInternal1(inspectOptions, args);
}
function formatNumberNoColor1(number, options) {
  return formatNumber2(stylizeNoColor2, number, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatBigIntNoColor1(bigint, options) {
  return formatBigInt2(stylizeNoColor2, bigint, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatWithOptionsInternal1(inspectOptions, args) {
  const first = args[0];
  let a7 = 0;
  let str = "";
  let join15 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a7 + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              const tempArg = args[++a7];
              if (typeof tempArg === "number") {
                tempStr = formatNumberNoColor1(tempArg, inspectOptions);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatBigIntNoColor1(tempArg, inspectOptions);
              } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString1(tempArg)) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect32(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            case 106:
              tempStr = tryStringify1(args[++a7]);
              break;
            case 100:
              const tempNum = args[++a7];
              if (typeof tempNum === "bigint") {
                tempStr = formatBigIntNoColor1(tempNum, inspectOptions);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor1(Number(tempNum), inspectOptions);
              }
              break;
            case 79:
              tempStr = inspect32(args[++a7], inspectOptions);
              break;
            case 111:
              tempStr = inspect32(args[++a7], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105:
              const tempInteger = args[++a7];
              if (typeof tempInteger === "bigint") {
                tempStr = formatBigIntNoColor1(tempInteger, inspectOptions);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor1(Number.parseInt(tempInteger), inspectOptions);
              }
              break;
            case 102:
              const tempFloat = args[++a7];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor1(Number.parseFloat(tempFloat), inspectOptions);
              }
              break;
            case 99:
              a7 += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a7++;
      join15 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a7 < args.length) {
    const value = args[a7];
    str += join15;
    str += typeof value !== "string" ? inspect32(value, inspectOptions) : value;
    join15 = " ";
    a7++;
  }
  return str;
}
function stripVTControlCharacters2(str) {
  validateString2(str, "str");
  return str.replace(ansi2, "");
}
var debugImpls2;
var testEnabled2;
function initializeDebugEnv2(debugEnv3) {
  debugImpls2 = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled2 = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled2 = () => false;
  }
}
function emitWarningIfNeeded2(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop2 = () => {
};
function debuglogImpl2(enabled2, set) {
  if (debugImpls2[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded2(set);
      debugImpls2[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect32(arg)).join(" ");
        console.error(sprintf2("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls2[set] = noop2;
    }
  }
  return debugImpls2[set];
}
function debuglog2(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled2(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl2(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv2;
try {
  debugEnv2 = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error2) {
  if (error2 instanceof Deno.errors.PermissionDenied) {
    debugEnv2 = "";
  } else {
    throw error2;
  }
}
initializeDebugEnv2(debugEnv2);
var osType2 = (() => {
  const { Deno: Deno12 } = globalThis;
  if (typeof Deno12?.build?.os === "string") {
    return Deno12.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows2 = osType2 === "windows";
var os2 = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
os2.errno.EEXIST;
os2.errno.ENOENT;
var codeToErrorWindows2 = [
  [
    -4093,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -4092,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -4091,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -4090,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -4089,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -4088,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -4084,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -4083,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -4082,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -4081,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -4079,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -4078,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -4077,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -4076,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -4075,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -4074,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -4036,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -4073,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4072,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -4071,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -4070,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -4069,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -4068,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -4067,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -4066,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -4065,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -4064,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -4063,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -4062,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -4061,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -4060,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -4059,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -4058,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -4057,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -4056,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -4035,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -4055,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -4054,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -4053,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -4052,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -4051,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -4050,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -4049,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -4048,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -4047,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -4046,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -4045,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -4044,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -4034,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -4043,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -4042,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -4041,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -4040,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -4039,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -4038,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -4037,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -4033,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -4032,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -4031,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -4030,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -4029,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -4028,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -4027,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeWindows2 = codeToErrorWindows2.map(([status, [error2]]) => [
  error2,
  status
]);
var codeToErrorDarwin2 = [
  [
    -7,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -13,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -48,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -49,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -47,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -35,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -37,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -9,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -16,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -89,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -53,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -61,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -54,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -39,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -17,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -14,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -27,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -65,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -22,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -5,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -56,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -21,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -62,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -24,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -40,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -63,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -50,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -51,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -23,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -55,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -19,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -2,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -12,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -4056,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -42,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -28,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -78,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -57,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -20,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -66,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -38,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -45,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -1,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -32,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -100,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -43,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -41,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -34,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -30,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -58,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -29,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -3,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -60,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -26,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -18,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -6,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -31,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -64,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -4030,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -25,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -79,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -92,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeDarwin2 = codeToErrorDarwin2.map(([status, [code2]]) => [
  code2,
  status
]);
var codeToErrorLinux2 = [
  [
    -7,
    [
      "E2BIG",
      "argument list too long"
    ]
  ],
  [
    -13,
    [
      "EACCES",
      "permission denied"
    ]
  ],
  [
    -98,
    [
      "EADDRINUSE",
      "address already in use"
    ]
  ],
  [
    -99,
    [
      "EADDRNOTAVAIL",
      "address not available"
    ]
  ],
  [
    -97,
    [
      "EAFNOSUPPORT",
      "address family not supported"
    ]
  ],
  [
    -11,
    [
      "EAGAIN",
      "resource temporarily unavailable"
    ]
  ],
  [
    -3e3,
    [
      "EAI_ADDRFAMILY",
      "address family not supported"
    ]
  ],
  [
    -3001,
    [
      "EAI_AGAIN",
      "temporary failure"
    ]
  ],
  [
    -3002,
    [
      "EAI_BADFLAGS",
      "bad ai_flags value"
    ]
  ],
  [
    -3013,
    [
      "EAI_BADHINTS",
      "invalid value for hints"
    ]
  ],
  [
    -3003,
    [
      "EAI_CANCELED",
      "request canceled"
    ]
  ],
  [
    -3004,
    [
      "EAI_FAIL",
      "permanent failure"
    ]
  ],
  [
    -3005,
    [
      "EAI_FAMILY",
      "ai_family not supported"
    ]
  ],
  [
    -3006,
    [
      "EAI_MEMORY",
      "out of memory"
    ]
  ],
  [
    -3007,
    [
      "EAI_NODATA",
      "no address"
    ]
  ],
  [
    -3008,
    [
      "EAI_NONAME",
      "unknown node or service"
    ]
  ],
  [
    -3009,
    [
      "EAI_OVERFLOW",
      "argument buffer overflow"
    ]
  ],
  [
    -3014,
    [
      "EAI_PROTOCOL",
      "resolved protocol is unknown"
    ]
  ],
  [
    -3010,
    [
      "EAI_SERVICE",
      "service not available for socket type"
    ]
  ],
  [
    -3011,
    [
      "EAI_SOCKTYPE",
      "socket type not supported"
    ]
  ],
  [
    -114,
    [
      "EALREADY",
      "connection already in progress"
    ]
  ],
  [
    -9,
    [
      "EBADF",
      "bad file descriptor"
    ]
  ],
  [
    -16,
    [
      "EBUSY",
      "resource busy or locked"
    ]
  ],
  [
    -125,
    [
      "ECANCELED",
      "operation canceled"
    ]
  ],
  [
    -4080,
    [
      "ECHARSET",
      "invalid Unicode character"
    ]
  ],
  [
    -103,
    [
      "ECONNABORTED",
      "software caused connection abort"
    ]
  ],
  [
    -111,
    [
      "ECONNREFUSED",
      "connection refused"
    ]
  ],
  [
    -104,
    [
      "ECONNRESET",
      "connection reset by peer"
    ]
  ],
  [
    -89,
    [
      "EDESTADDRREQ",
      "destination address required"
    ]
  ],
  [
    -17,
    [
      "EEXIST",
      "file already exists"
    ]
  ],
  [
    -14,
    [
      "EFAULT",
      "bad address in system call argument"
    ]
  ],
  [
    -27,
    [
      "EFBIG",
      "file too large"
    ]
  ],
  [
    -113,
    [
      "EHOSTUNREACH",
      "host is unreachable"
    ]
  ],
  [
    -4,
    [
      "EINTR",
      "interrupted system call"
    ]
  ],
  [
    -22,
    [
      "EINVAL",
      "invalid argument"
    ]
  ],
  [
    -5,
    [
      "EIO",
      "i/o error"
    ]
  ],
  [
    -106,
    [
      "EISCONN",
      "socket is already connected"
    ]
  ],
  [
    -21,
    [
      "EISDIR",
      "illegal operation on a directory"
    ]
  ],
  [
    -40,
    [
      "ELOOP",
      "too many symbolic links encountered"
    ]
  ],
  [
    -24,
    [
      "EMFILE",
      "too many open files"
    ]
  ],
  [
    -90,
    [
      "EMSGSIZE",
      "message too long"
    ]
  ],
  [
    -36,
    [
      "ENAMETOOLONG",
      "name too long"
    ]
  ],
  [
    -100,
    [
      "ENETDOWN",
      "network is down"
    ]
  ],
  [
    -101,
    [
      "ENETUNREACH",
      "network is unreachable"
    ]
  ],
  [
    -23,
    [
      "ENFILE",
      "file table overflow"
    ]
  ],
  [
    -105,
    [
      "ENOBUFS",
      "no buffer space available"
    ]
  ],
  [
    -19,
    [
      "ENODEV",
      "no such device"
    ]
  ],
  [
    -2,
    [
      "ENOENT",
      "no such file or directory"
    ]
  ],
  [
    -12,
    [
      "ENOMEM",
      "not enough memory"
    ]
  ],
  [
    -64,
    [
      "ENONET",
      "machine is not on the network"
    ]
  ],
  [
    -92,
    [
      "ENOPROTOOPT",
      "protocol not available"
    ]
  ],
  [
    -28,
    [
      "ENOSPC",
      "no space left on device"
    ]
  ],
  [
    -38,
    [
      "ENOSYS",
      "function not implemented"
    ]
  ],
  [
    -107,
    [
      "ENOTCONN",
      "socket is not connected"
    ]
  ],
  [
    -20,
    [
      "ENOTDIR",
      "not a directory"
    ]
  ],
  [
    -39,
    [
      "ENOTEMPTY",
      "directory not empty"
    ]
  ],
  [
    -88,
    [
      "ENOTSOCK",
      "socket operation on non-socket"
    ]
  ],
  [
    -95,
    [
      "ENOTSUP",
      "operation not supported on socket"
    ]
  ],
  [
    -1,
    [
      "EPERM",
      "operation not permitted"
    ]
  ],
  [
    -32,
    [
      "EPIPE",
      "broken pipe"
    ]
  ],
  [
    -71,
    [
      "EPROTO",
      "protocol error"
    ]
  ],
  [
    -93,
    [
      "EPROTONOSUPPORT",
      "protocol not supported"
    ]
  ],
  [
    -91,
    [
      "EPROTOTYPE",
      "protocol wrong type for socket"
    ]
  ],
  [
    -34,
    [
      "ERANGE",
      "result too large"
    ]
  ],
  [
    -30,
    [
      "EROFS",
      "read-only file system"
    ]
  ],
  [
    -108,
    [
      "ESHUTDOWN",
      "cannot send after transport endpoint shutdown"
    ]
  ],
  [
    -29,
    [
      "ESPIPE",
      "invalid seek"
    ]
  ],
  [
    -3,
    [
      "ESRCH",
      "no such process"
    ]
  ],
  [
    -110,
    [
      "ETIMEDOUT",
      "connection timed out"
    ]
  ],
  [
    -26,
    [
      "ETXTBSY",
      "text file is busy"
    ]
  ],
  [
    -18,
    [
      "EXDEV",
      "cross-device link not permitted"
    ]
  ],
  [
    -4094,
    [
      "UNKNOWN",
      "unknown error"
    ]
  ],
  [
    -4095,
    [
      "EOF",
      "end of file"
    ]
  ],
  [
    -6,
    [
      "ENXIO",
      "no such device or address"
    ]
  ],
  [
    -31,
    [
      "EMLINK",
      "too many links"
    ]
  ],
  [
    -112,
    [
      "EHOSTDOWN",
      "host is down"
    ]
  ],
  [
    -121,
    [
      "EREMOTEIO",
      "remote I/O error"
    ]
  ],
  [
    -25,
    [
      "ENOTTY",
      "inappropriate ioctl for device"
    ]
  ],
  [
    -4028,
    [
      "EFTYPE",
      "inappropriate file type or format"
    ]
  ],
  [
    -84,
    [
      "EILSEQ",
      "illegal byte sequence"
    ]
  ]
];
var errorToCodeLinux2 = codeToErrorLinux2.map(([status, [code2]]) => [
  code2,
  status
]);
var errorMap2 = new Map(osType2 === "windows" ? codeToErrorWindows2 : osType2 === "darwin" ? codeToErrorDarwin2 : osType2 === "linux" ? codeToErrorLinux2 : unreachable2());
var codeMap2 = new Map(osType2 === "windows" ? errorToCodeWindows2 : osType2 === "darwin" ? errorToCodeDarwin2 : osType2 === "linux" ? errorToCodeLinux2 : unreachable2());
codeMap2.get("EAI_MEMORY");
codeMap2.get("UNKNOWN");
codeMap2.get("EBADF");
codeMap2.get("EINVAL");
codeMap2.get("ENOTSOCK");
var __default20 = {
  ...mod110
};
var Encodings3;
(function(Encodings4) {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
})(Encodings3 || (Encodings3 = {}));
var encodings3 = [];
encodings3[Encodings3.ASCII] = "ascii";
encodings3[Encodings3.BASE64] = "base64";
encodings3[Encodings3.BASE64URL] = "base64url";
encodings3[Encodings3.BUFFER] = "buffer";
encodings3[Encodings3.HEX] = "hex";
encodings3[Encodings3.LATIN1] = "latin1";
encodings3[Encodings3.UCS2] = "utf16le";
encodings3[Encodings3.UTF8] = "utf8";
function numberToBytes3(n3) {
  if (n3 === 0)
    return new Uint8Array([
      0
    ]);
  const bytes = [];
  bytes.unshift(n3 & 255);
  while (n3 >= 256) {
    n3 = n3 >>> 8;
    bytes.unshift(n3 & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex3(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x17 = 0; x17 <= searchableBufferLastIndex; x17++) {
    if (searchableBuffer[searchableBufferLastIndex - x17] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x17;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x17 = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x17;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer3(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings3[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex3(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle3(targetBuffer, buffer, byteOffset);
}
function indexOfNumber3(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes3(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer3(targetBuffer, numberToBytes3(number), byteOffset, Encodings3.UTF8, forwardDirection);
}
var base64abc3 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode72(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l22 = uint8.length;
  for (i = 2; i < l22; i += 3) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc3[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc3[uint8[i] & 63];
  }
  if (i === l22 + 1) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l22) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc3[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode6(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}
function addPaddingToBase64url3(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase643(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url3(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url3(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode8(data) {
  return convertBase64ToBase64url3(encode72(data));
}
function decode7(b64url) {
  return decode6(convertBase64urlToBase643(b64url));
}
function asciiToBytes3(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes3(str) {
  str = base64clean3(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode6(str);
}
var INVALID_BASE64_RE3 = /[^+/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE3, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes3(str) {
  str = base64clean3(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode7(str);
}
function hexToBytes3(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a7 = Number.parseInt(str[i * 2], 16);
    const b15 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a7) && Number.isNaN(b15)) {
      break;
    }
    byteArray[i] = a7 << 4 | b15;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes3(str, units) {
  let c13, hi, lo;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c13 = str.charCodeAt(i);
    hi = c13 >> 8;
    lo = c13 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii3(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le3(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
var utf8Encoder3 = new TextEncoder();
var float32Array3 = new Float32Array(1);
var uInt8Float32Array3 = new Uint8Array(float32Array3.buffer);
var float64Array3 = new Float64Array(1);
var uInt8Float64Array3 = new Uint8Array(float64Array3.buffer);
float32Array3[0] = -1;
var bigEndian3 = uInt8Float32Array3[3] === 0;
function readUInt48LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 8);
  }
  uInt8Float64Array3[7] = first;
  uInt8Float64Array3[6] = buffer[++offset];
  uInt8Float64Array3[5] = buffer[++offset];
  uInt8Float64Array3[4] = buffer[++offset];
  uInt8Float64Array3[3] = buffer[++offset];
  uInt8Float64Array3[2] = buffer[++offset];
  uInt8Float64Array3[1] = buffer[++offset];
  uInt8Float64Array3[0] = last;
  return float64Array3[0];
}
function readDoubleForwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 8);
  }
  uInt8Float64Array3[0] = first;
  uInt8Float64Array3[1] = buffer[++offset];
  uInt8Float64Array3[2] = buffer[++offset];
  uInt8Float64Array3[3] = buffer[++offset];
  uInt8Float64Array3[4] = buffer[++offset];
  uInt8Float64Array3[5] = buffer[++offset];
  uInt8Float64Array3[6] = buffer[++offset];
  uInt8Float64Array3[7] = last;
  return float64Array3[0];
}
function writeDoubleForwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds6(buffer, offset, 7);
  float64Array3[0] = val;
  buffer[offset++] = uInt8Float64Array3[0];
  buffer[offset++] = uInt8Float64Array3[1];
  buffer[offset++] = uInt8Float64Array3[2];
  buffer[offset++] = uInt8Float64Array3[3];
  buffer[offset++] = uInt8Float64Array3[4];
  buffer[offset++] = uInt8Float64Array3[5];
  buffer[offset++] = uInt8Float64Array3[6];
  buffer[offset++] = uInt8Float64Array3[7];
  return offset;
}
function writeDoubleBackwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds6(buffer, offset, 7);
  float64Array3[0] = val;
  buffer[offset++] = uInt8Float64Array3[7];
  buffer[offset++] = uInt8Float64Array3[6];
  buffer[offset++] = uInt8Float64Array3[5];
  buffer[offset++] = uInt8Float64Array3[4];
  buffer[offset++] = uInt8Float64Array3[3];
  buffer[offset++] = uInt8Float64Array3[2];
  buffer[offset++] = uInt8Float64Array3[1];
  buffer[offset++] = uInt8Float64Array3[0];
  return offset;
}
function readFloatBackwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 4);
  }
  uInt8Float32Array3[3] = first;
  uInt8Float32Array3[2] = buffer[++offset];
  uInt8Float32Array3[1] = buffer[++offset];
  uInt8Float32Array3[0] = last;
  return float32Array3[0];
}
function readFloatForwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 4);
  }
  uInt8Float32Array3[0] = first;
  uInt8Float32Array3[1] = buffer[++offset];
  uInt8Float32Array3[2] = buffer[++offset];
  uInt8Float32Array3[3] = last;
  return float32Array3[0];
}
function writeFloatForwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds6(buffer, offset, 3);
  float32Array3[0] = val;
  buffer[offset++] = uInt8Float32Array3[0];
  buffer[offset++] = uInt8Float32Array3[1];
  buffer[offset++] = uInt8Float32Array3[2];
  buffer[offset++] = uInt8Float32Array3[3];
  return offset;
}
function writeFloatBackwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds6(buffer, offset, 3);
  float32Array3[0] = val;
  buffer[offset++] = uInt8Float32Array3[3];
  buffer[offset++] = uInt8Float32Array3[2];
  buffer[offset++] = uInt8Float32Array3[1];
  buffer[offset++] = uInt8Float32Array3[0];
  return offset;
}
function readInt24LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf83(str) {
  return utf8Encoder3.encode(str).length;
}
function base64ByteLength3(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap3 = /* @__PURE__ */ Object.create(null);
for (let i12 = 0; i12 < encodings3.length; ++i12) {
  encodingsMap3[encodings3[i12]] = i12;
}
var encodingOps3 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap3.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength3(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap3.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, base64ToBytes3(val), byteOffset, encodingsMap3.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength3(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap3.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, base64UrlToBytes3(val), byteOffset, encodingsMap3.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap3.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, hexToBytes3(val), byteOffset, encodingsMap3.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap3.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap3.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf83,
    encoding: "utf8",
    encodingVal: encodingsMap3.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf8Encoder3.encode(val), byteOffset, encodingsMap3.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap3.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps3(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps3.utf8;
      if (encoding === "ucs2")
        return encodingOps3.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps3.utf8;
      if (encoding === "ascii")
        return encodingOps3.ascii;
      if (encoding === "ucs-2")
        return encodingOps3.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps3.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps3.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps3.latin1;
      }
      if (encoding === "base64")
        return encodingOps3.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps3.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps3.base64url;
      }
      break;
  }
}
function _copyActual3(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError3(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber3(value, type);
    throw new codes3.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes3.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber3(value, name) {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds6(buf, offset, byteLength3) {
  validateNumber3(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
    boundsError3(offset, buf.length - (byteLength3 + 1));
  }
}
function checkInt3(value, min3, max2, buf, offset, byteLength3) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength3 > 3) {
      if (min3 === 0 || min3 === 0n) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength3 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}) and < 2${n3} ** ${(byteLength3 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds6(buf, offset, byteLength3);
}
function toInteger3(n3, defaultVal) {
  n3 = +n3;
  if (!Number.isNaN(n3) && n3 >= Number.MIN_SAFE_INTEGER && n3 <= Number.MAX_SAFE_INTEGER) {
    return n3 % 1 === 0 ? n3 : Math.floor(n3);
  }
  return defaultVal;
}
function writeU_Int83(buf, value, offset, min3, max2) {
  value = +value;
  validateNumber3(offset, "offset");
  if (value > max2 || value < min3) {
    throw new codes3.ERR_OUT_OF_RANGE("value", `>= ${min3} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError3(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset3(value, name, min3 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min3 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min3} && <= ${max2}`, value);
  }
}
function writeU_Int48LE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE3(buf, value, offset, min3, max2) {
  value = +value;
  checkInt3(value, min3, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
var kMaxLength3 = 2147483647;
var MAX_UINT323 = 2 ** 32;
var customInspectSymbol6 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES3 = 50;
Object.defineProperty(Buffer3.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer3.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer3.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer3.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer3(length) {
  if (length > 2147483647) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer3.prototype);
  return buf;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes3.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe3(arg);
  }
  return _from5(arg, encodingOrOffset, length);
}
Buffer3.poolSize = 8192;
function _from5(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString3(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer7(value)) {
      return fromArrayBuffer3(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from5(valueOf, encodingOrOffset, length);
    }
    const b15 = fromObject3(value);
    if (b15) {
      return b15;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString3(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes3.ERR_INVALID_ARG_TYPE("first argument", [
    "string",
    "Buffer",
    "ArrayBuffer",
    "Array",
    "Array-like Object"
  ], value);
}
Buffer3.from = function from4(value, encodingOrOffset, length) {
  return _from5(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer3, Uint8Array);
function assertSize4(size) {
  validateNumber3(size, "size");
  if (!(size >= 0 && size <= 2147483647)) {
    throw new codes3.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc3(size, fill6, encoding) {
  assertSize4(size);
  const buffer = createBuffer3(size);
  if (fill6 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes3.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill6, encoding);
  }
  return buffer;
}
Buffer3.alloc = function alloc4(size, fill6, encoding) {
  return _alloc3(size, fill6, encoding);
};
function _allocUnsafe3(size) {
  assertSize4(size);
  return createBuffer3(size < 0 ? 0 : checked3(size) | 0);
}
Buffer3.allocUnsafe = function allocUnsafe4(size) {
  return _allocUnsafe3(size);
};
Buffer3.allocUnsafeSlow = function allocUnsafeSlow4(size) {
  return _allocUnsafe3(size);
};
function fromString3(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength5(string, encoding) | 0;
  let buf = createBuffer3(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike3(array) {
  const length = array.length < 0 ? 0 : checked3(array.length) | 0;
  const buf = createBuffer3(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject3(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer7(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer3(0);
    }
    return fromArrayLike3(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike3(obj2.data);
  }
}
function checked3(length) {
  if (length >= 2147483647) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer3(length) {
  assertSize4(length);
  return Buffer3.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer3, Uint8Array);
Buffer3.isBuffer = function isBuffer5(b15) {
  return b15 != null && b15._isBuffer === true && b15 !== Buffer3.prototype;
};
Buffer3.compare = function compare8(a7, b15) {
  if (isInstance3(a7, Uint8Array)) {
    a7 = Buffer3.from(a7, a7.offset, a7.byteLength);
  }
  if (isInstance3(b15, Uint8Array)) {
    b15 = Buffer3.from(b15, b15.offset, b15.byteLength);
  }
  if (!Buffer3.isBuffer(a7) || !Buffer3.isBuffer(b15)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a7 === b15) {
    return 0;
  }
  let x17 = a7.length;
  let y16 = b15.length;
  for (let i = 0, len = Math.min(x17, y16); i < len; ++i) {
    if (a7[i] !== b15[i]) {
      x17 = a7[i];
      y16 = b15[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
Buffer3.isEncoding = function isEncoding4(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding7(encoding) !== void 0;
};
Buffer3.concat = function concat4(list, length) {
  if (!Array.isArray(list)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer3.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset3(length, "length");
  }
  const buffer = Buffer3.allocUnsafe(length);
  let pos = 0;
  for (let i12 = 0; i12 < list.length; i12++) {
    const buf = list[i12];
    if (!isUint8Array3(buf)) {
      throw new codes3.ERR_INVALID_ARG_TYPE(`list[${i12}]`, [
        "Buffer",
        "Uint8Array"
      ], list[i12]);
    }
    pos += _copyActual3(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength5(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView3(string) || isAnyArrayBuffer7(string)) {
      return string.byteLength;
    }
    throw new codes3.ERR_INVALID_ARG_TYPE("string", [
      "string",
      "Buffer",
      "ArrayBuffer"
    ], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf83(string);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf83(string);
  }
  return ops.byteLength(string);
}
Buffer3.byteLength = byteLength5;
Buffer3.prototype._isBuffer = true;
function swap3(b15, n3, m20) {
  const i = b15[n3];
  b15[n3] = b15[m20];
  b15[m20] = i;
}
Buffer3.prototype.swap16 = function swap164() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap3(this, i, i + 1);
  }
  return this;
};
Buffer3.prototype.swap32 = function swap324() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap3(this, i, i + 3);
    swap3(this, i + 1, i + 2);
  }
  return this;
};
Buffer3.prototype.swap64 = function swap644() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap3(this, i, i + 7);
    swap3(this, i + 1, i + 6);
    swap3(this, i + 2, i + 5);
    swap3(this, i + 3, i + 4);
  }
  return this;
};
Buffer3.prototype.toString = function toString5(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
Buffer3.prototype.equals = function equals4(b15) {
  if (!isUint8Array3(b15)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("otherBuffer", [
      "Buffer",
      "Uint8Array"
    ], b15);
  }
  if (this === b15) {
    return true;
  }
  return Buffer3.compare(this, b15) === 0;
};
Buffer3.prototype.inspect = function inspect5() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES3;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol6) {
  Buffer3.prototype[customInspectSymbol6] = Buffer3.prototype.inspect;
}
Buffer3.prototype.compare = function compare9(target, start, end, thisStart, thisEnd) {
  if (isInstance3(target, Uint8Array)) {
    target = Buffer3.from(target, target.offset, target.byteLength);
  }
  if (!Buffer3.isBuffer(target)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset3(start, "targetStart", 0, kMaxLength3);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset3(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset3(start, "sourceStart", 0, kMaxLength3);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset3(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes3.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x17 = thisEnd - thisStart;
  let y16 = end - start;
  const len = Math.min(x17, y16);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x17 = thisCopy[i];
      y16 = targetCopy[i];
      break;
    }
  }
  if (x17 < y16) {
    return -1;
  }
  if (y16 < x17) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
  validateBuffer3(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber3(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps3.utf8;
  } else {
    ops = getEncodingOps3(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array3(val)) {
    const encodingVal = ops === void 0 ? encodingsMap3.utf8 : ops.encodingVal;
    return indexOfBuffer3(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes3.ERR_INVALID_ARG_TYPE("value", [
    "number",
    "string",
    "Buffer",
    "Uint8Array"
  ], val);
}
Buffer3.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer3.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer3.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
Buffer3.prototype.asciiSlice = function asciiSlice4(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii3(this);
  } else {
    return bytesToAscii3(this.slice(offset, length));
  }
};
Buffer3.prototype.asciiWrite = function asciiWrite4(string, offset, length) {
  return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer3.prototype.base64Slice = function base64Slice4(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode72(this);
  } else {
    return encode72(this.slice(offset, length));
  }
};
Buffer3.prototype.base64Write = function base64Write4(string, offset, length) {
  return blitBuffer3(base64ToBytes3(string), this, offset, length);
};
Buffer3.prototype.base64urlSlice = function base64urlSlice4(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode8(this);
  } else {
    return encode8(this.slice(offset, length));
  }
};
Buffer3.prototype.base64urlWrite = function base64urlWrite4(string, offset, length) {
  return blitBuffer3(base64UrlToBytes3(string), this, offset, length);
};
Buffer3.prototype.hexWrite = function hexWrite4(string, offset, length) {
  return blitBuffer3(hexToBytes3(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.hexSlice = function hexSlice5(string, offset, length) {
  return _hexSlice3(this, string, offset, length);
};
Buffer3.prototype.latin1Slice = function latin1Slice4(string, offset, length) {
  return _latin1Slice3(this, string, offset, length);
};
Buffer3.prototype.latin1Write = function latin1Write4(string, offset, length) {
  return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer3.prototype.ucs2Slice = function ucs2Slice4(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le3(this);
  } else {
    return bytesToUtf16le3(this.slice(offset, length));
  }
};
Buffer3.prototype.ucs2Write = function ucs2Write4(string, offset, length) {
  return blitBuffer3(utf16leToBytes3(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.utf8Slice = function utf8Slice4(string, offset, length) {
  return _utf8Slice3(this, string, offset, length);
};
Buffer3.prototype.utf8Write = function utf8Write5(string, offset, length) {
  return blitBuffer3(utf8ToBytes3(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.write = function write4(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset3(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset3(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer3.prototype.toJSON = function toJSON5() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer3(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer3.prototype);
  return buffer;
}
function _utf8Slice3(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  const len = codePoints.length;
  if (len <= 4096) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
  }
  return res;
}
function _latin1Slice3(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice3(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable3[buf[i]];
  }
  return out;
}
Buffer3.prototype.slice = function slice4(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer3.prototype);
  return newBuf;
};
Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE4(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48LE3(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40LE3(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24LE3(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE4(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readUInt48BE3(this, offset);
  }
  if (byteLength3 === 5) {
    return readUInt40BE3(this, offset);
  }
  if (byteLength3 === 3) {
    return readUInt24BE3(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readUInt8(offset);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt85(offset = 0) {
  validateNumber3(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError3(offset, this.length - 1);
  }
  return val;
};
Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = readUInt16BE3;
Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE4(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE4(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = readUInt32BE3;
Buffer3.prototype.readBigUint64LE = Buffer3.prototype.readBigUInt64LE = defineBigIntMethod3(function readBigUInt64LE4(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer3.prototype.readBigUint64BE = Buffer3.prototype.readBigUInt64BE = defineBigIntMethod3(function readBigUInt64BE4(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer3.prototype.readIntLE = function readIntLE4(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48LE3(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40LE3(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24LE3(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.readIntBE = function readIntBE4(offset, byteLength3) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength3 === 6) {
    return readInt48BE3(this, offset);
  }
  if (byteLength3 === 5) {
    return readInt40BE3(this, offset);
  }
  if (byteLength3 === 3) {
    return readInt24BE3(this, offset);
  }
  if (byteLength3 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength3 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength3 === 1) {
    return this.readInt8(offset);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.readInt8 = function readInt84(offset = 0) {
  validateNumber3(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError3(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer3.prototype.readInt16LE = function readInt16LE4(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer3.prototype.readInt16BE = function readInt16BE4(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer3.prototype.readInt32LE = function readInt32LE4(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer3.prototype.readInt32BE = function readInt32BE4(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer3.prototype.readBigInt64LE = defineBigIntMethod3(function readBigInt64LE4(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer3.prototype.readBigInt64BE = defineBigIntMethod3(function readBigInt64BE4(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer3.prototype.readFloatLE = function readFloatLE4(offset) {
  return bigEndian3 ? readFloatBackwards3(this, offset) : readFloatForwards3(this, offset);
};
Buffer3.prototype.readFloatBE = function readFloatBE4(offset) {
  return bigEndian3 ? readFloatForwards3(this, offset) : readFloatBackwards3(this, offset);
};
Buffer3.prototype.readDoubleLE = function readDoubleLE4(offset) {
  return bigEndian3 ? readDoubleBackwards3(this, offset) : readDoubleForwards3(this, offset);
};
Buffer3.prototype.readDoubleBE = function readDoubleBE4(offset) {
  return bigEndian3 ? readDoubleForwards3(this, offset) : readDoubleBackwards3(this, offset);
};
Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE4(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE3(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE3(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE3(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE3(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE3(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int83(this, value, offset, 0, 255);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE4(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE3(this, value, offset, 0, 281474976710655);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE3(this, value, offset, 0, 1099511627775);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE3(this, value, offset, 0, 16777215);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE3(this, value, offset, 0, 4294967295);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE3(this, value, offset, 0, 65535);
  }
  if (byteLength3 === 1) {
    return writeU_Int83(this, value, offset, 0, 255);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt84(value, offset = 0) {
  return writeU_Int83(this, value, offset, 0, 255);
};
Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE4(value, offset = 0) {
  return writeU_Int16LE3(this, value, offset, 0, 65535);
};
Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE4(value, offset = 0) {
  return writeU_Int16BE3(this, value, offset, 0, 65535);
};
Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE4(value, offset = 0) {
  return _writeUInt32LE3(this, value, offset, 0, 4294967295);
};
Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE4(value, offset = 0) {
  return _writeUInt32BE3(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE3(buf, value, offset, min3, max2) {
  checkIntBI3(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE3(buf, value, offset, min3, max2) {
  checkIntBI3(value, min3, max2, buf, offset, 7);
  let lo = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer3.prototype.writeBigUint64LE = Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod3(function writeBigUInt64LE4(value, offset = 0) {
  return wrtBigUInt64LE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeBigUint64BE = Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod3(function writeBigUInt64BE4(value, offset = 0) {
  return wrtBigUInt64BE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeIntLE = function writeIntLE4(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48LE3(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40LE3(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24LE3(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32LE3(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16LE3(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int83(this, value, offset, -128, 127);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.writeIntBE = function writeIntBE4(value, offset, byteLength3) {
  if (byteLength3 === 6) {
    return writeU_Int48BE3(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength3 === 5) {
    return writeU_Int40BE3(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength3 === 3) {
    return writeU_Int24BE3(this, value, offset, -8388608, 8388607);
  }
  if (byteLength3 === 4) {
    return writeU_Int32BE3(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength3 === 2) {
    return writeU_Int16BE3(this, value, offset, -32768, 32767);
  }
  if (byteLength3 === 1) {
    return writeU_Int83(this, value, offset, -128, 127);
  }
  boundsError3(byteLength3, 6, "byteLength");
};
Buffer3.prototype.writeInt8 = function writeInt84(value, offset = 0) {
  return writeU_Int83(this, value, offset, -128, 127);
};
Buffer3.prototype.writeInt16LE = function writeInt16LE4(value, offset = 0) {
  return writeU_Int16LE3(this, value, offset, -32768, 32767);
};
Buffer3.prototype.writeInt16BE = function writeInt16BE4(value, offset = 0) {
  return writeU_Int16BE3(this, value, offset, -32768, 32767);
};
Buffer3.prototype.writeInt32LE = function writeInt32LE4(value, offset = 0) {
  return writeU_Int32LE3(this, value, offset, -2147483648, 2147483647);
};
Buffer3.prototype.writeInt32BE = function writeInt32BE4(value, offset = 0) {
  return writeU_Int32BE3(this, value, offset, -2147483648, 2147483647);
};
Buffer3.prototype.writeBigInt64LE = defineBigIntMethod3(function writeBigInt64LE4(value, offset = 0) {
  return wrtBigUInt64LE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeBigInt64BE = defineBigIntMethod3(function writeBigInt64BE4(value, offset = 0) {
  return wrtBigUInt64BE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeFloatLE = function writeFloatLE4(value, offset) {
  return bigEndian3 ? writeFloatBackwards3(this, value, offset) : writeFloatForwards3(this, value, offset);
};
Buffer3.prototype.writeFloatBE = function writeFloatBE4(value, offset) {
  return bigEndian3 ? writeFloatForwards3(this, value, offset) : writeFloatBackwards3(this, value, offset);
};
Buffer3.prototype.writeDoubleLE = function writeDoubleLE4(value, offset) {
  return bigEndian3 ? writeDoubleBackwards3(this, value, offset) : writeDoubleForwards3(this, value, offset);
};
Buffer3.prototype.writeDoubleBE = function writeDoubleBE4(value, offset) {
  return bigEndian3 ? writeDoubleForwards3(this, value, offset) : writeDoubleBackwards3(this, value, offset);
};
Buffer3.prototype.copy = function copy5(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array3(this)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("source", [
      "Buffer",
      "Uint8Array"
    ], this);
  }
  if (!isUint8Array3(target)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("target", [
      "Buffer",
      "Uint8Array"
    ], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger3(targetStart, 0);
    if (targetStart < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger3(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT323) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT323}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger3(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT323) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT323}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer3.prototype.fill = function fill4(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes3.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds7(buf, offset, byteLength23) {
  validateNumber3(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength23] === void 0) {
    boundsError3(offset, buf.length - (byteLength23 + 1));
  }
}
function checkIntBI3(value, min3, max2, buf, offset, byteLength23) {
  if (value > max2 || value < min3) {
    const n3 = typeof min3 === "bigint" ? "n" : "";
    let range;
    if (byteLength23 > 3) {
      if (min3 === 0 || min3 === BigInt(0)) {
        range = `>= 0${n3} and < 2${n3} ** ${(byteLength23 + 1) * 8}${n3}`;
      } else {
        range = `>= -(2${n3} ** ${(byteLength23 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength23 + 1) * 8 - 1}${n3}`;
      }
    } else {
      range = `>= ${min3}${n3} and <= ${max2}${n3}`;
    }
    throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds7(buf, offset, byteLength23);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer3(src, dst, offset, byteLength3) {
  let i;
  const length = byteLength3 === void 0 ? src.length : byteLength3;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance3(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable3 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j13 = 0; j13 < 16; ++j13) {
      table[i16 + j13] = alphabet[i] + alphabet[j13];
    }
  }
  return table;
}();
function defineBigIntMethod3(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined3 : fn;
}
function BufferBigIntNotDefined3() {
  throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType2;
(function(valueType3) {
  valueType3[valueType3["noIterator"] = 0] = "noIterator";
  valueType3[valueType3["isArray"] = 1] = "isArray";
  valueType3[valueType3["isSet"] = 2] = "isSet";
  valueType3[valueType3["isMap"] = 3] = "isMap";
})(valueType2 || (valueType2 = {}));
var memo2;
function isDeepStrictEqual1(val1, val2) {
  return innerDeepEqual2(val1, val2, true);
}
function innerDeepEqual2(val1, val2, strict, memos = memo2) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? 2 : 2 | 16;
    const keys1 = getOwnNonIndexProperties2(val1, filter);
    const keys2 = getOwnNonIndexProperties2(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, valueType2.isArray, keys1);
  } else if (val1Tag === "[object Object]") {
    return keyCheck2(val1, val2, strict, memos, valueType2.noIterator);
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps2(val1, val2)) {
      return false;
    }
  } else if (isNativeError7(val1) || val1 instanceof Error) {
    if (!isNativeError7(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView3(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) => Object.getOwnPropertySymbols(val).map((item) => item.toString()).toString();
    if (isTypedArray2(val1) && isTypedArray2(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
      return false;
    }
    if (!strict && (isFloat32Array2(val1) || isFloat64Array2(val1))) {
      if (!areSimilarFloatArrays2(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays2(val1, val2)) {
      return false;
    }
    const filter1 = strict ? 2 : 2 | 16;
    const keysVal1 = getOwnNonIndexProperties2(val1, filter1);
    const keysVal2 = getOwnNonIndexProperties2(val2, filter1);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, valueType2.noIterator, keysVal1);
  } else if (isSet7(val1)) {
    if (!isSet7(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, valueType2.isSet);
  } else if (isMap7(val1)) {
    if (!isMap7(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, valueType2.isMap);
  } else if (isAnyArrayBuffer7(val1)) {
    if (!isAnyArrayBuffer7(val2) || !areEqualArrayBuffers2(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive7(val1)) {
    if (!isEqualBoxedPrimitive2(val1, val2)) {
      return false;
    }
  } else if (Array.isArray(val2) || isArrayBufferView3(val2) || isSet7(val2) || isMap7(val2) || isDate8(val2) || isRegExp8(val2) || isAnyArrayBuffer7(val2) || isBoxedPrimitive7(val2) || isNativeError7(val2) || val2 instanceof Error) {
    return false;
  }
  return keyCheck2(val1, val2, strict, memos, valueType2.noIterator);
}
function keyCheck2(val1, val2, strict, memos, iterationType, aKeys = []) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key2 = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key2)) {
          if (!val2.propertyIsEnumerable(key2)) {
            return false;
          }
          aKeys.push(key2.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key2)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables2(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB1.length !== 0 && getEnumerables2(val2, symbolKeysB1).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === valueType2.noIterator || iterationType === valueType2.isArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv2(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function areSimilarRegExps2(a7, b15) {
  return a7.source === b15.source && a7.flags === b15.flags && a7.lastIndex === b15.lastIndex;
}
function areSimilarFloatArrays2(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays2(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return Buffer3.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers2(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && Buffer3.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive2(a7, b15) {
  if (Object.getOwnPropertyNames(a7).length !== Object.getOwnPropertyNames(b15).length) {
    return false;
  }
  if (Object.getOwnPropertySymbols(a7).length !== Object.getOwnPropertySymbols(b15).length) {
    return false;
  }
  if (isNumberObject7(a7)) {
    return isNumberObject7(b15) && Object.is(Number.prototype.valueOf.call(a7), Number.prototype.valueOf.call(b15));
  }
  if (isStringObject7(a7)) {
    return isStringObject7(b15) && String.prototype.valueOf.call(a7) === String.prototype.valueOf.call(b15);
  }
  if (isBooleanObject7(a7)) {
    return isBooleanObject7(b15) && Boolean.prototype.valueOf.call(a7) === Boolean.prototype.valueOf.call(b15);
  }
  if (isBigIntObject7(a7)) {
    return isBigIntObject7(b15) && BigInt.prototype.valueOf.call(a7) === BigInt.prototype.valueOf.call(b15);
  }
  if (isSymbolObject7(a7)) {
    return isSymbolObject7(b15) && Symbol.prototype.valueOf.call(a7) === Symbol.prototype.valueOf.call(b15);
  }
  throw Error(`Unknown boxed type`);
}
function getEnumerables2(val, keys) {
  return keys.filter((key2) => val.propertyIsEnumerable(key2));
}
function objEquiv2(obj1, obj2, strict, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === valueType2.isSet) {
    if (!setEquiv2(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType2.isMap) {
    if (!mapEquiv2(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === valueType2.isArray) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (!obj2.hasOwnProperty(i) || !innerDeepEqual2(obj1[i], obj2[i], strict, memos)) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key2 = keys1[i];
          if (!obj2.hasOwnProperty(key2) || !innerDeepEqual2(obj1[key2], obj2[key2], strict, memos)) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key1 = keys[i];
    if (!innerDeepEqual2(obj1[key1], obj2[key1], strict, memos)) {
      return false;
    }
  }
  return true;
}
function findLooseMatchingPrimitives2(primitive) {
  switch (typeof primitive) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      primitive = +primitive;
    case "number":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim2(set1, set2, primitive) {
  const altValue = findLooseMatchingPrimitives2(primitive);
  if (altValue != null)
    return altValue;
  return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement2(set, val1, strict, memos) {
  for (const val2 of set) {
    if (innerDeepEqual2(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function setEquiv2(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === "object" && item !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict)
        return false;
      if (!setMightHaveLoosePrim2(set1, set2, item)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    }
  }
  if (set !== null) {
    for (const item1 of set2) {
      if (typeof item1 === "object" && item1 !== null) {
        if (!setHasEqualElement2(set, item1, strict, memos))
          return false;
      } else if (!strict && !set1.has(item1) && !setHasEqualElement2(set, item1, strict, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapMightHaveLoosePrimitive2(map1, map2, primitive, item, memos) {
  const altValue = findLooseMatchingPrimitives2(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (curB === void 0 && !map2.has(altValue) || !innerDeepEqual2(item, curB, false, memo2)) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual2(item, curB, false, memos);
}
function mapEquiv2(map1, map2, strict, memos) {
  let set = null;
  for (const { 0: key2, 1: item1 } of map1) {
    if (typeof key2 === "object" && key2 !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key2);
    } else {
      const item2 = map2.get(key2);
      if (item2 === void 0 && !map2.has(key2) || !innerDeepEqual2(item1, item2, strict, memos)) {
        if (strict)
          return false;
        if (!mapMightHaveLoosePrimitive2(map1, map2, key2, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      }
    }
  }
  if (set !== null) {
    for (const { 0: key1, 1: item } of map2) {
      if (typeof key1 === "object" && key1 !== null) {
        if (!mapHasEqualEntry2(set, map1, key1, item, strict, memos)) {
          return false;
        }
      } else if (!strict && (!map1.has(key1) || !innerDeepEqual2(map1.get(key1), item, false, memos)) && !mapHasEqualEntry2(set, map1, key1, item, false, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry2(set, map, key1, item1, strict, memos) {
  for (const key2 of set) {
    if (innerDeepEqual2(key1, key2, strict, memos) && innerDeepEqual2(item1, map.get(key2), strict, memos)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
var NumberIsSafeInteger2 = Number.isSafeInteger;
function isArray1(value) {
  return Array.isArray(value);
}
function isBoolean1(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull1(value) {
  return value === null;
}
function isNullOrUndefined1(value) {
  return value === null || value === void 0;
}
function isNumber3(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString1(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol1(value) {
  return typeof value === "symbol";
}
function isUndefined1(value) {
  return value === void 0;
}
function isObject1(value) {
  return value !== null && typeof value === "object";
}
function isError1(e) {
  return e instanceof Error;
}
function isFunction1(value) {
  return typeof value === "function";
}
function isRegExp9(value) {
  return __default20.isRegExp(value);
}
function isDate9(value) {
  return __default20.isDate(value);
}
function isPrimitive1(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer1(value) {
  return Buffer3.isBuffer(value);
}
function _extend1(target, source) {
  if (source === null || typeof source !== "object")
    return target;
  const keys = Object.keys(source);
  let i = keys.length;
  while (i--) {
    target[keys[i]] = source[keys[i]];
  }
  return target;
}
function getSystemErrorName2(code2) {
  if (typeof code2 !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger2(code2)) {
    throw new codes3.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap2.get(code2)?.[0];
}
function inherits2(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad1(n3) {
  return n3.toString().padStart(2, "0");
}
var months1 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp1() {
  const d14 = new Date();
  const t2 = [
    pad1(d14.getHours()),
    pad1(d14.getMinutes()),
    pad1(d14.getSeconds())
  ].join(":");
  return `${d14.getDate()} ${months1[d14.getMonth()]} ${t2}`;
}
function log1(...args) {
  console.log("%s - %s", timestamp1(), format8(...args));
}
var __default21 = {
  format: format8,
  formatWithOptions: formatWithOptions1,
  inspect: inspect32,
  isArray: isArray1,
  isBoolean: isBoolean1,
  isNull: isNull1,
  isNullOrUndefined: isNullOrUndefined1,
  isNumber: isNumber3,
  isString: isString1,
  isSymbol: isSymbol1,
  isUndefined: isUndefined1,
  isObject: isObject1,
  isError: isError1,
  isFunction: isFunction1,
  isRegExp: isRegExp9,
  isDate: isDate9,
  isPrimitive: isPrimitive1,
  isBuffer: isBuffer1,
  _extend: _extend1,
  getSystemErrorName: getSystemErrorName2,
  deprecate: deprecate1,
  callbackify: callbackify1,
  promisify: promisify3,
  inherits: inherits2,
  types: __default20,
  stripVTControlCharacters: stripVTControlCharacters2,
  TextDecoder: _TextDecoder1,
  TextEncoder: _TextEncoder1,
  log: log1,
  debuglog: debuglog2,
  isDeepStrictEqual: isDeepStrictEqual1
};
var { errno: { ENOTDIR: ENOTDIR2, ENOENT: ENOENT2 } } = os2;
var kIsNodeError2 = Symbol("kIsNodeError");
var classRegExp5 = /^([A-Z][a-z0-9]*)+$/;
var kTypes2 = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
function addNumericalSeparator2(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace22 = hideStackFrames3(function captureLargerStackTrace4(err) {
  Error.captureStackTrace(err);
  return err;
});
hideStackFrames3(function uvExceptionWithHostPort3(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet2(err) || uvUnmappedError2;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace22(ex);
});
hideStackFrames3(function errnoException3(err, syscall, original) {
  const code2 = getSystemErrorName2(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace22(ex);
});
function uvErrmapGet2(name) {
  return errorMap2.get(name);
}
var uvUnmappedError2 = [
  "UNKNOWN",
  "unknown error"
];
hideStackFrames3(function uvException3(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet2(ctx.errno) || uvUnmappedError2;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace22(err);
});
hideStackFrames3(function exceptionWithHostPort3(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName2(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace22(ex);
});
hideStackFrames3(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap2.get("EAI_NODATA") || code2 === codeMap2.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName2(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace22(ex);
});
var NodeErrorAbstraction2 = class extends Error {
  code;
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeURIError = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(URIError.prototype.name, code2, message);
    Object.setPrototypeOf(this, URIError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError2 = class extends NodeErrorAbstraction2 {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace22(this);
    Object.defineProperties(this, {
      [kIsNodeError2]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode2(key2, msgPrfix) {
  return class NodeError extends NodeSystemError2 {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
makeSystemErrorWithCode2("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType2(name, expected) {
  expected = Array.isArray(expected) ? expected : [
    expected
  ];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types2 = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes2.includes(value)) {
      types2.push(value.toLocaleLowerCase());
    } else if (classRegExp5.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types2.indexOf("object");
    if (pos !== -1) {
      types2.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types2.length > 0) {
    if (types2.length > 2) {
      const last = types2.pop();
      msg += `one of type ${types2.join(", ")}, or ${last}`;
    } else if (types2.length === 2) {
      msg += `one of type ${types2[0]} or ${types2[1]}`;
    } else {
      msg += `of type ${types2[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last1 = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last1}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last2 = other.pop();
      msg += `one of ${other.join(", ")}, or ${last2}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE2 = class extends NodeRangeError2 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType2(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE2 = class extends NodeTypeError2 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType2(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
  }
};
__publicField(ERR_INVALID_ARG_TYPE2, "RangeError", ERR_INVALID_ARG_TYPE_RANGE2);
var ERR_INVALID_ARG_VALUE_RANGE2 = class extends NodeRangeError2 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect32(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE2 = class extends NodeTypeError2 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect32(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
__publicField(ERR_INVALID_ARG_VALUE2, "RangeError", ERR_INVALID_ARG_VALUE_RANGE2);
function invalidArgTypeHelper2(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect32(input, {
      depth: -1
    })}`;
  }
  let inspected = inspect32(input, {
    colors: false
  });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE2 = class extends RangeError {
  code = "ERR_OUT_OF_RANGE";
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert4(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator2(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator2(received);
      }
      received += "n";
    } else {
      received = inspect32(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS2 = class extends NodeRangeError2 {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_INVALID_CALLBACK2 = class extends NodeTypeError2 {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect32(object)}`);
  }
};
var ERR_INVALID_URI = class extends NodeURIError {
  constructor() {
    super("ERR_INVALID_URI", `URI malformed`);
  }
};
var ERR_IPC_CHANNEL_CLOSED2 = class extends NodeError2 {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_SOCKET_BAD_PORT2 = class extends NodeRangeError2 {
  constructor(name, port, allowZero = true) {
    assert4(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_UNKNOWN_ENCODING2 = class extends NodeTypeError2 {
  constructor(x17) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x17}`);
  }
};
codes3.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED2;
codes3.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE2;
codes3.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE2;
codes3.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK2;
codes3.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE2;
codes3.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT2;
codes3.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS2;
codes3.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING2;
hideStackFrames3(function genericNodeError3(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_FORWARD_SLASH3 = 47;
function assertPath2(path6) {
  if (typeof path6 !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("path", [
      "string"
    ], path6);
  }
}
function isPosixPathSeparator2(code2) {
  return code2 === 47;
}
function isPathSeparator2(code2) {
  return isPosixPathSeparator2(code2) || code2 === 92;
}
function isWindowsDeviceRoot2(code2) {
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
function normalizeString2(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH3;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep9, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base2 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base2;
  if (dir === pathObject.root)
    return dir + base2;
  return dir + sep9 + base2;
}
var WHITESPACE_ENCODINGS2 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace2(string) {
  return string.replaceAll(/[\s]/g, (c13) => {
    return WHITESPACE_ENCODINGS2[c13] ?? c13;
  });
}
var sep6 = "\\";
var delimiter6 = ";";
function resolve6(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno12 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno12.cwd();
    } else {
      if (typeof Deno12?.env?.get !== "function" || typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno12.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath2(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute9 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator2(code2)) {
        isAbsolute9 = true;
        if (isPathSeparator2(path6.charCodeAt(1))) {
          let j13 = 2;
          let last = j13;
          for (; j13 < len; ++j13) {
            if (isPathSeparator2(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            const firstPart = path6.slice(last, j13);
            last = j13;
            for (; j13 < len; ++j13) {
              if (!isPathSeparator2(path6.charCodeAt(j13)))
                break;
            }
            if (j13 < len && j13 !== last) {
              last = j13;
              for (; j13 < len; ++j13) {
                if (isPathSeparator2(path6.charCodeAt(j13)))
                  break;
              }
              if (j13 === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j13;
              } else if (j13 !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j13)}`;
                rootEnd = j13;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot2(code2)) {
        if (path6.charCodeAt(1) === 58) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator2(path6.charCodeAt(2))) {
              isAbsolute9 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator2(code2)) {
      rootEnd = 1;
      isAbsolute9 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute9;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize8(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute9 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      isAbsolute9 = true;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator2(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          const firstPart = path6.slice(last, j13);
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator2(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator2(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j13 !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j13)}`;
              rootEnd = j13;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === 58) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            isAbsolute9 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString2(path6.slice(rootEnd), !isAbsolute9, "\\", isPathSeparator2);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute9)
    tail = ".";
  if (tail.length > 0 && isPathSeparator2(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute9) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute9) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute6(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator2(code2)) {
    return true;
  } else if (isWindowsDeviceRoot2(code2)) {
    if (len > 2 && path6.charCodeAt(1) === 58) {
      if (isPathSeparator2(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join11(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath2(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert4(firstPart != null);
  if (isPathSeparator2(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator2(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator2(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator2(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize8(joined);
}
function relative6(from6, to) {
  assertPath2(from6);
  assertPath2(to);
  if (from6 === to)
    return "";
  const fromOrig = resolve6(from6);
  const toOrig = resolve6(to);
  if (fromOrig === toOrig)
    return "";
  from6 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from6 === to)
    return "";
  let fromStart = 0;
  let fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== 92)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from6.charCodeAt(fromEnd - 1) !== 92)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== 92)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== 92)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 92) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from6.charCodeAt(fromStart + i) === 92) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 92)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from6.charCodeAt(i) === 92) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === 92)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath6(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve6(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === 92) {
      if (resolvedPath.charCodeAt(1) === 92) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== 63 && code2 !== 46) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname6(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator2(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator2(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator2(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              return path6;
            }
            if (j13 !== last) {
              rootEnd = offset = j13 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === 58) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator2(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename6(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("ext", [
      "string"
    ], ext);
  }
  assertPath2(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot2(drive)) {
      if (path6.charCodeAt(1) === 58)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator2(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator2(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname6(path6) {
  assertPath2(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format9(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ERR_INVALID_ARG_TYPE2("pathObject", [
      "Object"
    ], pathObject);
  }
  return _format2("\\", pathObject);
}
function parse8(path6) {
  assertPath2(path6);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = 1;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j13 = 2;
        let last = j13;
        for (; j13 < len; ++j13) {
          if (isPathSeparator2(path6.charCodeAt(j13)))
            break;
        }
        if (j13 < len && j13 !== last) {
          last = j13;
          for (; j13 < len; ++j13) {
            if (!isPathSeparator2(path6.charCodeAt(j13)))
              break;
          }
          if (j13 < len && j13 !== last) {
            last = j13;
            for (; j13 < len; ++j13) {
              if (isPathSeparator2(path6.charCodeAt(j13)))
                break;
            }
            if (j13 === len) {
              rootEnd = j13;
            } else if (j13 !== last) {
              rootEnd = j13 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === 58) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl6(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl6(path6) {
  if (!isAbsolute6(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}
var __default22 = {
  basename: basename6,
  delimiter: delimiter6,
  dirname: dirname6,
  extname: extname6,
  format: format9,
  fromFileUrl: fromFileUrl6,
  isAbsolute: isAbsolute6,
  join: join11,
  normalize: normalize8,
  parse: parse8,
  relative: relative6,
  resolve: resolve6,
  sep: sep6,
  toFileUrl: toFileUrl6,
  toNamespacedPath: toNamespacedPath6
};
var mod111 = {
  sep: sep6,
  delimiter: delimiter6,
  resolve: resolve6,
  normalize: normalize8,
  isAbsolute: isAbsolute6,
  join: join11,
  relative: relative6,
  toNamespacedPath: toNamespacedPath6,
  dirname: dirname6,
  basename: basename6,
  extname: extname6,
  format: format9,
  parse: parse8,
  fromFileUrl: fromFileUrl6,
  toFileUrl: toFileUrl6,
  default: __default22
};
var sep7 = "/";
var delimiter7 = ":";
function resolve7(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno12 } = globalThis;
      if (typeof Deno12?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno12.cwd();
    }
    assertPath2(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  }
  resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize9(path6) {
  assertPath2(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute9 = path6.charCodeAt(0) === 47;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === 47;
  path6 = normalizeString2(path6, !isAbsolute9, "/", isPosixPathSeparator2);
  if (path6.length === 0 && !isAbsolute9)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute9)
    return `/${path6}`;
  return path6;
}
function isAbsolute7(path6) {
  assertPath2(path6);
  return path6.length > 0 && path6.charCodeAt(0) === 47;
}
function join12(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath2(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize9(joined);
}
function relative7(from6, to) {
  assertPath2(from6);
  assertPath2(to);
  if (from6 === to)
    return "";
  from6 = resolve7(from6);
  to = resolve7(to);
  if (from6 === to)
    return "";
  let fromStart = 1;
  const fromEnd = from6.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from6.charCodeAt(fromStart) !== 47)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== 47)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === 47) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from6.charCodeAt(fromStart + i) === 47) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from6.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === 47)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from6.charCodeAt(i) === 47) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === 47)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath7(path6) {
  return path6;
}
function dirname7(path6) {
  assertPath2(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === 47;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === 47) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename7(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("ext", [
      "string"
    ], ext);
  }
  assertPath2(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname7(path6) {
  assertPath2(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format10(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ERR_INVALID_ARG_TYPE2("pathObject", [
      "Object"
    ], pathObject);
  }
  return _format2("/", pathObject);
}
function parse9(path6) {
  assertPath2(path6);
  const ret = {
    root: "",
    dir: "",
    base: "",
    ext: "",
    name: ""
  };
  if (path6.length === 0)
    return ret;
  const isAbsolute9 = path6.charCodeAt(0) === 47;
  let start;
  if (isAbsolute9) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === 47) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === 46) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute9) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute9) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute9)
    ret.dir = "/";
  return ret;
}
function fromFileUrl7(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl7(path6) {
  if (!isAbsolute7(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}
var __default23 = {
  basename: basename7,
  delimiter: delimiter7,
  dirname: dirname7,
  extname: extname7,
  format: format10,
  fromFileUrl: fromFileUrl7,
  isAbsolute: isAbsolute7,
  join: join12,
  normalize: normalize9,
  parse: parse9,
  relative: relative7,
  resolve: resolve7,
  sep: sep7,
  toFileUrl: toFileUrl7,
  toNamespacedPath: toNamespacedPath7
};
var mod112 = {
  sep: sep7,
  delimiter: delimiter7,
  resolve: resolve7,
  normalize: normalize9,
  isAbsolute: isAbsolute7,
  join: join12,
  relative: relative7,
  toNamespacedPath: toNamespacedPath7,
  dirname: dirname7,
  basename: basename7,
  extname: extname7,
  format: format10,
  parse: parse9,
  fromFileUrl: fromFileUrl7,
  toFileUrl: toFileUrl7,
  default: __default23
};
var path4 = isWindows2 ? mod111 : mod112;
var { join: join13, normalize: normalize10 } = path4;
var path5 = isWindows2 ? __default22 : __default23;
var { basename: basename8, delimiter: delimiter8, dirname: dirname8, extname: extname8, format: format11, fromFileUrl: fromFileUrl8, isAbsolute: isAbsolute8, join: join14, normalize: normalize11, parse: parse10, relative: relative8, resolve: resolve8, sep: sep8, toFileUrl: toFileUrl8, toNamespacedPath: toNamespacedPath8 } = path5;
var base1 = 36;
var damp = 700;
var delimiter9 = "-";
var regexNonASCII = /[^\0-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = 36 - 1;
function error3(type) {
  throw new RangeError(errors[type]);
}
function mapDomain(str, fn) {
  const parts = str.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    str = parts[1];
  }
  str = str.replace(regexSeparators, ".");
  const labels = str.split(".");
  const encoded = labels.map(fn).join(".");
  return result + encoded;
}
function ucs2decode(str) {
  const output = [];
  let counter = 0;
  const length = str.length;
  while (counter < length) {
    const value = str.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = str.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  let k15 = 0;
  delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
  delta += Math.floor(delta / numPoints);
  for (; delta > baseMinusTMin * 26 >> 1; k15 += base1) {
    delta = Math.floor(delta / baseMinusTMin);
  }
  return Math.floor(k15 + (baseMinusTMin + 1) * delta / (delta + 38));
}
function encode9(str) {
  const output = [];
  const input = ucs2decode(str);
  const inputLength = input.length;
  let n3 = 128;
  let delta = 0;
  let bias = 72;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(String.fromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter9);
  }
  while (handledCPCount < inputLength) {
    let m20 = 2147483647;
    for (const currentValue1 of input) {
      if (currentValue1 >= n3 && currentValue1 < m20) {
        m20 = currentValue1;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m20 - n3 > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
      error3("overflow");
    }
    delta += (m20 - n3) * handledCPCountPlusOne;
    n3 = m20;
    for (const currentValue2 of input) {
      if (currentValue2 < n3 && ++delta > 2147483647) {
        error3("overflow");
      }
      if (currentValue2 == n3) {
        let q15 = delta;
        for (let k15 = 36; ; k15 += base1) {
          const t2 = k15 <= bias ? 1 : k15 >= bias + 26 ? 26 : k15 - bias;
          if (q15 < t2) {
            break;
          }
          const qMinusT = q15 - t2;
          const baseMinusT = 36 - t2;
          output.push(String.fromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
          q15 = Math.floor(qMinusT / baseMinusT);
        }
        output.push(String.fromCharCode(digitToBasic(q15, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n3;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(str) {
    return regexNonASCII.test(str) ? "xn--" + encode9(str) : str;
  });
}
var hexTable1 = new Array(256);
for (let i13 = 0; i13 < 256; ++i13) {
  hexTable1[i13] = "%" + ((i13 < 16 ? "0" : "") + i13.toString(16)).toUpperCase();
}
new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function encodeStr2(str, noEscapeTable, hexTable2) {
  const len = str.length;
  if (len === 0)
    return "";
  let out = "";
  let lastPos = 0;
  for (let i = 0; i < len; i++) {
    let c13 = str.charCodeAt(i);
    if (c13 < 128) {
      if (noEscapeTable[c13] === 1)
        continue;
      if (lastPos < i)
        out += str.slice(lastPos, i);
      lastPos = i + 1;
      out += hexTable2[c13];
      continue;
    }
    if (lastPos < i)
      out += str.slice(lastPos, i);
    if (c13 < 2048) {
      lastPos = i + 1;
      out += hexTable2[192 | c13 >> 6] + hexTable2[128 | c13 & 63];
      continue;
    }
    if (c13 < 55296 || c13 >= 57344) {
      lastPos = i + 1;
      out += hexTable2[224 | c13 >> 12] + hexTable2[128 | c13 >> 6 & 63] + hexTable2[128 | c13 & 63];
      continue;
    }
    ++i;
    if (i >= len)
      throw new ERR_INVALID_URI();
    const c22 = str.charCodeAt(i) & 1023;
    lastPos = i + 1;
    c13 = 65536 + ((c13 & 1023) << 10 | c22);
    out += hexTable2[240 | c13 >> 18] + hexTable2[128 | c13 >> 12 & 63] + hexTable2[128 | c13 >> 6 & 63] + hexTable2[128 | c13 & 63];
  }
  if (lastPos === 0)
    return str;
  if (lastPos < len)
    return out + str.slice(lastPos);
  return out;
}
var decode8 = parse11;
var encode10 = stringify;
function qsEscape(str) {
  if (typeof str !== "string") {
    if (typeof str === "object") {
      str = String(str);
    } else {
      str += "";
    }
  }
  return encodeStr2(str, noEscape, hexTable1);
}
var escape = qsEscape;
var isHexTable = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function charCodes(str) {
  const ret = new Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode10) {
  if (key2.length > 0 && keyEncoded) {
    key2 = decode10(key2);
  }
  if (value.length > 0 && valEncoded) {
    value = decode10(value);
  }
  if (obj2[key2] === void 0) {
    obj2[key2] = value;
  } else {
    const curValue = obj2[key2];
    if (curValue.pop) {
      curValue[curValue.length] = value;
    } else {
      obj2[key2] = [
        curValue,
        value
      ];
    }
  }
}
function parse11(str, sep9 = "&", eq2 = "=", { decodeURIComponent: decodeURIComponent1 = unescape, maxKeys = 1e3 } = {}) {
  const obj2 = /* @__PURE__ */ Object.create(null);
  if (typeof str !== "string" || str.length === 0) {
    return obj2;
  }
  const sepCodes = !sep9 ? [
    38
  ] : charCodes(String(sep9));
  const eqCodes = !eq2 ? [
    61
  ] : charCodes(String(eq2));
  const sepLen = sepCodes.length;
  const eqLen = eqCodes.length;
  let pairs = 1e3;
  if (typeof maxKeys === "number") {
    pairs = maxKeys > 0 ? maxKeys : -1;
  }
  let decode10 = unescape;
  if (decodeURIComponent1) {
    decode10 = decodeURIComponent1;
  }
  const customDecode = decode10 !== unescape;
  let lastPos = 0;
  let sepIdx = 0;
  let eqIdx = 0;
  let key2 = "";
  let value = "";
  let keyEncoded = customDecode;
  let valEncoded = customDecode;
  const plusChar = customDecode ? "%20" : " ";
  let encodeCheck = 0;
  for (let i = 0; i < str.length; ++i) {
    const code2 = str.charCodeAt(i);
    if (code2 === sepCodes[sepIdx]) {
      if (++sepIdx === sepLen) {
        const end = i - sepIdx + 1;
        if (eqIdx < eqLen) {
          if (lastPos < end) {
            key2 += str.slice(lastPos, end);
          } else if (key2.length === 0) {
            if (--pairs === 0) {
              return obj2;
            }
            lastPos = i + 1;
            sepIdx = eqIdx = 0;
            continue;
          }
        } else if (lastPos < end) {
          value += str.slice(lastPos, end);
        }
        addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode10);
        if (--pairs === 0) {
          return obj2;
        }
        key2 = value = "";
        encodeCheck = 0;
        lastPos = i + 1;
        sepIdx = eqIdx = 0;
      }
    } else {
      sepIdx = 0;
      if (eqIdx < eqLen) {
        if (code2 === eqCodes[eqIdx]) {
          if (++eqIdx === eqLen) {
            const end1 = i - eqIdx + 1;
            if (lastPos < end1) {
              key2 += str.slice(lastPos, end1);
            }
            encodeCheck = 0;
            lastPos = i + 1;
          }
          continue;
        } else {
          eqIdx = 0;
          if (!keyEncoded) {
            if (code2 === 37) {
              encodeCheck = 1;
              continue;
            } else if (encodeCheck > 0) {
              if (isHexTable[code2] === 1) {
                if (++encodeCheck === 3) {
                  keyEncoded = true;
                }
                continue;
              } else {
                encodeCheck = 0;
              }
            }
          }
        }
        if (code2 === 43) {
          if (lastPos < i) {
            key2 += str.slice(lastPos, i);
          }
          key2 += plusChar;
          lastPos = i + 1;
          continue;
        }
      }
      if (code2 === 43) {
        if (lastPos < i) {
          value += str.slice(lastPos, i);
        }
        value += plusChar;
        lastPos = i + 1;
      } else if (!valEncoded) {
        if (code2 === 37) {
          encodeCheck = 1;
        } else if (encodeCheck > 0) {
          if (isHexTable[code2] === 1) {
            if (++encodeCheck === 3) {
              valEncoded = true;
            }
          } else {
            encodeCheck = 0;
          }
        }
      }
    }
  }
  if (lastPos < str.length) {
    if (eqIdx < eqLen) {
      key2 += str.slice(lastPos);
    } else if (sepIdx < sepLen) {
      value += str.slice(lastPos);
    }
  } else if (eqIdx === 0 && key2.length === 0) {
    return obj2;
  }
  addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode10);
  return obj2;
}
var noEscape = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
]);
function stringifyPrimitive(v19) {
  if (typeof v19 === "string") {
    return v19;
  }
  if (typeof v19 === "number" && isFinite(v19)) {
    return "" + v19;
  }
  if (typeof v19 === "bigint") {
    return "" + v19;
  }
  if (typeof v19 === "boolean") {
    return v19 ? "true" : "false";
  }
  return "";
}
function encodeStringifiedCustom(v19, encode13) {
  return encode13(stringifyPrimitive(v19));
}
function encodeStringified(v19, encode13) {
  if (typeof v19 === "string") {
    return v19.length ? encode13(v19) : "";
  }
  if (typeof v19 === "number" && isFinite(v19)) {
    return Math.abs(v19) < 1e21 ? "" + v19 : encode13("" + v19);
  }
  if (typeof v19 === "bigint") {
    return "" + v19;
  }
  if (typeof v19 === "boolean") {
    return v19 ? "true" : "false";
  }
  return "";
}
function stringify(obj2, sep9, eq2, options) {
  sep9 ||= "&";
  eq2 ||= "=";
  const encode13 = options ? options.encodeURIComponent : qsEscape;
  const convert = options ? encodeStringifiedCustom : encodeStringified;
  if (obj2 !== null && typeof obj2 === "object") {
    const keys = Object.keys(obj2);
    const len = keys.length;
    let fields = "";
    for (let i = 0; i < len; ++i) {
      const k15 = keys[i];
      const v19 = obj2[k15];
      let ks = convert(k15, encode13);
      ks += eq2;
      if (Array.isArray(v19)) {
        const vlen = v19.length;
        if (vlen === 0)
          continue;
        if (fields) {
          fields += sep9;
        }
        for (let j13 = 0; j13 < vlen; ++j13) {
          if (j13) {
            fields += sep9;
          }
          fields += ks;
          fields += convert(v19[j13], encode13);
        }
      } else {
        if (fields) {
          fields += sep9;
        }
        fields += ks;
        fields += convert(v19, encode13);
      }
    }
    return fields;
  }
  return "";
}
var unhexTable = new Int8Array([
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);
function unescapeBuffer(s10, decodeSpaces = false) {
  const out = new Buffer3(s10.length);
  let index = 0;
  let outIndex = 0;
  let currentChar;
  let nextChar;
  let hexHigh;
  let hexLow;
  const maxLength = s10.length - 2;
  let hasHex = false;
  while (index < s10.length) {
    currentChar = s10.charCodeAt(index);
    if (currentChar === 43 && decodeSpaces) {
      out[outIndex++] = 32;
      index++;
      continue;
    }
    if (currentChar === 37 && index < maxLength) {
      currentChar = s10.charCodeAt(++index);
      hexHigh = unhexTable[currentChar];
      if (!(hexHigh >= 0)) {
        out[outIndex++] = 37;
        continue;
      } else {
        nextChar = s10.charCodeAt(++index);
        hexLow = unhexTable[nextChar];
        if (!(hexLow >= 0)) {
          out[outIndex++] = 37;
          index--;
        } else {
          hasHex = true;
          currentChar = hexHigh * 16 + hexLow;
        }
      }
    }
    out[outIndex++] = currentChar;
    index++;
  }
  return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s10) {
  try {
    return decodeURIComponent(s10);
  } catch {
    return unescapeBuffer(s10).toString();
  }
}
var unescape = qsUnescape;
var __default24 = {
  parse: parse11,
  stringify,
  decode: decode8,
  encode: encode10,
  unescape,
  escape,
  unescapeBuffer
};
var protocolPattern = /^[a-z0-9.+-]+:/i;
var portPattern = /:[0-9]*$/;
var hostPattern = /^\/\/[^@/]+@[^@/]+/;
var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
var unsafeProtocol = /* @__PURE__ */ new Set([
  "javascript",
  "javascript:"
]);
var hostlessProtocol = /* @__PURE__ */ new Set([
  "javascript",
  "javascript:"
]);
var slashedProtocol = /* @__PURE__ */ new Set([
  "http",
  "http:",
  "https",
  "https:",
  "ftp",
  "ftp:",
  "gopher",
  "gopher:",
  "file",
  "file:",
  "ws",
  "ws:",
  "wss",
  "wss:"
]);
var noEscapeAuth = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
]);
var Url = class {
  protocol;
  slashes;
  auth;
  host;
  port;
  hostname;
  hash;
  search;
  query;
  pathname;
  path;
  href;
  constructor() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  #parseHost() {
    let host = this.host || "";
    let port6 = portPattern.exec(host);
    if (port6) {
      port6 = port6[0];
      if (port6 !== ":") {
        this.port = port6.slice(1);
      }
      host = host.slice(0, host.length - port6.length);
    }
    if (host)
      this.hostname = host;
  }
  resolve(relative9) {
    return this.resolveObject(parse12(relative9, false, true)).format();
  }
  resolveObject(relative9) {
    if (typeof relative9 === "string") {
      const rel = new Url();
      rel.urlParse(relative9, false, true);
      relative9 = rel;
    }
    const result = new Url();
    const tkeys = Object.keys(this);
    for (let tk = 0; tk < tkeys.length; tk++) {
      const tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative9.hash;
    if (relative9.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative9.slashes && !relative9.protocol) {
      const rkeys = Object.keys(relative9);
      for (let rk = 0; rk < rkeys.length; rk++) {
        const rkey = rkeys[rk];
        if (rkey !== "protocol")
          result[rkey] = relative9[rkey];
      }
      if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
        result.path = result.pathname = "/";
      }
      result.href = result.format();
      return result;
    }
    if (relative9.protocol && relative9.protocol !== result.protocol) {
      if (!slashedProtocol.has(relative9.protocol)) {
        const keys = Object.keys(relative9);
        for (let v19 = 0; v19 < keys.length; v19++) {
          const k15 = keys[v19];
          result[k15] = relative9[k15];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative9.protocol;
      if (!relative9.host && !/^file:?$/.test(relative9.protocol) && !hostlessProtocol.has(relative9.protocol)) {
        const relPath = (relative9.pathname || "").split("/");
        while (relPath.length && !(relative9.host = relPath.shift() || null))
          ;
        if (!relative9.host)
          relative9.host = "";
        if (!relative9.hostname)
          relative9.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative9.pathname;
      }
      result.search = relative9.search;
      result.query = relative9.query;
      result.host = relative9.host || "";
      result.auth = relative9.auth;
      result.hostname = relative9.hostname || relative9.host;
      result.port = relative9.port;
      if (result.pathname || result.search) {
        const p7 = result.pathname || "";
        const s10 = result.search || "";
        result.path = p7 + s10;
      }
      result.slashes = result.slashes || relative9.slashes;
      result.href = result.format();
      return result;
    }
    const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
    const isRelAbs = relative9.host || relative9.pathname && relative9.pathname.charAt(0) === "/";
    let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative9.pathname;
    const removeAllDots = mustEndAbs;
    let srcPath = result.pathname && result.pathname.split("/") || [];
    const relPath1 = relative9.pathname && relative9.pathname.split("/") || [];
    const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
    if (noLeadingSlashes) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative9.protocol) {
        relative9.hostname = null;
        relative9.port = null;
        result.auth = null;
        if (relative9.host) {
          if (relPath1[0] === "")
            relPath1[0] = relative9.host;
          else
            relPath1.unshift(relative9.host);
        }
        relative9.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath1[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      if (relative9.host || relative9.host === "") {
        if (result.host !== relative9.host)
          result.auth = null;
        result.host = relative9.host;
        result.port = relative9.port;
      }
      if (relative9.hostname || relative9.hostname === "") {
        if (result.hostname !== relative9.hostname)
          result.auth = null;
        result.hostname = relative9.hostname;
      }
      result.search = relative9.search;
      result.query = relative9.query;
      srcPath = relPath1;
    } else if (relPath1.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath1);
      result.search = relative9.search;
      result.query = relative9.query;
    } else if (relative9.search !== null && relative9.search !== void 0) {
      if (noLeadingSlashes) {
        result.hostname = result.host = srcPath.shift() || null;
        const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
        if (authInHost) {
          result.auth = authInHost.shift() || null;
          result.host = result.hostname = authInHost.shift() || null;
        }
      }
      result.search = relative9.search;
      result.query = relative9.query;
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    let last = srcPath.slice(-1)[0];
    const hasTrailingSlash = (result.host || relative9.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    let up = 0;
    for (let i = srcPath.length - 1; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      while (up--) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    const isAbsolute9 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (noLeadingSlashes) {
      result.hostname = result.host = isAbsolute9 ? "" : srcPath.length ? srcPath.shift() || null : "";
      const authInHost1 = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost1) {
        result.auth = authInHost1.shift() || null;
        result.host = result.hostname = authInHost1.shift() || null;
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute9) {
      srcPath.unshift("");
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join("/");
    }
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative9.auth || result.auth;
    result.slashes = result.slashes || relative9.slashes;
    result.href = result.format();
    return result;
  }
  format() {
    let auth = this.auth || "";
    if (auth) {
      auth = encodeStr2(auth, noEscapeAuth, hexTable1);
      auth += "@";
    }
    let protocol = this.protocol || "";
    let pathname = this.pathname || "";
    let hash = this.hash || "";
    let host = "";
    let query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query !== null && typeof this.query === "object") {
      query = __default24.stringify(this.query);
    }
    let search = this.search || query && "?" + query || "";
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
      protocol += ":";
    }
    let newPathname = "";
    let lastPos = 0;
    for (let i = 0; i < pathname.length; ++i) {
      switch (pathname.charCodeAt(i)) {
        case 35:
          if (i - lastPos > 0) {
            newPathname += pathname.slice(lastPos, i);
          }
          newPathname += "%23";
          lastPos = i + 1;
          break;
        case 63:
          if (i - lastPos > 0) {
            newPathname += pathname.slice(lastPos, i);
          }
          newPathname += "%3F";
          lastPos = i + 1;
          break;
      }
    }
    if (lastPos > 0) {
      if (lastPos !== pathname.length) {
        pathname = newPathname + pathname.slice(lastPos);
      } else
        pathname = newPathname;
    }
    if (this.slashes || slashedProtocol.has(protocol)) {
      if (this.slashes || host) {
        if (pathname && pathname.charCodeAt(0) !== 47) {
          pathname = "/" + pathname;
        }
        host = "//" + host;
      } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
        host = "//";
      }
    }
    search = search.replace(/#/g, "%23");
    if (hash && hash.charCodeAt(0) !== 35) {
      hash = "#" + hash;
    }
    if (search && search.charCodeAt(0) !== 63) {
      search = "?" + search;
    }
    return protocol + host + pathname + search + hash;
  }
  urlParse(url, parseQueryString, slashesDenoteHost) {
    let hasHash = false;
    let start = -1;
    let end = -1;
    let rest = "";
    let lastPos = 0;
    for (let i = 0, inWs = false, split3 = false; i < url.length; ++i) {
      const code2 = url.charCodeAt(i);
      const isWs = code2 === 32 || code2 === 9 || code2 === 13 || code2 === 10 || code2 === 12 || code2 === 160 || code2 === 65279;
      if (start === -1) {
        if (isWs)
          continue;
        lastPos = start = i;
      } else if (inWs) {
        if (!isWs) {
          end = -1;
          inWs = false;
        }
      } else if (isWs) {
        end = i;
        inWs = true;
      }
      if (!split3) {
        switch (code2) {
          case 35:
            hasHash = true;
          case 63:
            split3 = true;
            break;
          case 92:
            if (i - lastPos > 0)
              rest += url.slice(lastPos, i);
            rest += "/";
            lastPos = i + 1;
            break;
        }
      } else if (!hasHash && code2 === 35) {
        hasHash = true;
      }
    }
    if (start !== -1) {
      if (lastPos === start) {
        if (end === -1) {
          if (start === 0)
            rest = url;
          else
            rest = url.slice(start);
        } else {
          rest = url.slice(start, end);
        }
      } else if (end === -1 && lastPos < url.length) {
        rest += url.slice(lastPos);
      } else if (end !== -1 && lastPos < end) {
        rest += url.slice(lastPos, end);
      }
    }
    if (!slashesDenoteHost && !hasHash) {
      const simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = __default24.parse(this.search.slice(1));
          } else {
            this.query = this.search.slice(1);
          }
        } else if (parseQueryString) {
          this.search = null;
          this.query = /* @__PURE__ */ Object.create(null);
        }
        return this;
      }
    }
    let proto = protocolPattern.exec(rest);
    let lowerProto = "";
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.slice(proto.length);
    }
    let slashes;
    if (slashesDenoteHost || proto || hostPattern.test(rest)) {
      slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH2 && rest.charCodeAt(1) === CHAR_FORWARD_SLASH2;
      if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
        rest = rest.slice(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
      let hostEnd = -1;
      let atSign = -1;
      let nonHost = -1;
      for (let i12 = 0; i12 < rest.length; ++i12) {
        switch (rest.charCodeAt(i12)) {
          case 9:
          case 10:
          case 13:
          case 32:
          case 34:
          case 37:
          case 39:
          case 59:
          case 60:
          case 62:
          case 92:
          case 94:
          case 96:
          case 123:
          case 124:
          case 125:
            if (nonHost === -1)
              nonHost = i12;
            break;
          case 35:
          case 47:
          case 63:
            if (nonHost === -1)
              nonHost = i12;
            hostEnd = i12;
            break;
          case 64:
            atSign = i12;
            nonHost = -1;
            break;
        }
        if (hostEnd !== -1)
          break;
      }
      start = 0;
      if (atSign !== -1) {
        this.auth = decodeURIComponent(rest.slice(0, atSign));
        start = atSign + 1;
      }
      if (nonHost === -1) {
        this.host = rest.slice(start);
        rest = "";
      } else {
        this.host = rest.slice(start, nonHost);
        rest = rest.slice(nonHost);
      }
      this.#parseHost();
      if (typeof this.hostname !== "string")
        this.hostname = "";
      const hostname = this.hostname;
      const ipv6Hostname = isIpv6Hostname(hostname);
      if (!ipv6Hostname) {
        rest = getHostname(this, rest, hostname);
      }
      if (this.hostname.length > 255) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = toASCII(this.hostname);
      }
      const p7 = this.port ? ":" + this.port : "";
      const h16 = this.hostname || "";
      this.host = h16 + p7;
      if (ipv6Hostname) {
        this.hostname = this.hostname.slice(1, -1);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol.has(lowerProto)) {
      rest = autoEscapeStr(rest);
    }
    let questionIdx = -1;
    let hashIdx = -1;
    for (let i22 = 0; i22 < rest.length; ++i22) {
      const code1 = rest.charCodeAt(i22);
      if (code1 === 35) {
        this.hash = rest.slice(i22);
        hashIdx = i22;
        break;
      } else if (code1 === 63 && questionIdx === -1) {
        questionIdx = i22;
      }
    }
    if (questionIdx !== -1) {
      if (hashIdx === -1) {
        this.search = rest.slice(questionIdx);
        this.query = rest.slice(questionIdx + 1);
      } else {
        this.search = rest.slice(questionIdx, hashIdx);
        this.query = rest.slice(questionIdx + 1, hashIdx);
      }
      if (parseQueryString) {
        this.query = __default24.parse(this.query);
      }
    } else if (parseQueryString) {
      this.search = null;
      this.query = /* @__PURE__ */ Object.create(null);
    }
    const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
    const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
    if (firstIdx === -1) {
      if (rest.length > 0)
        this.pathname = rest;
    } else if (firstIdx > 0) {
      this.pathname = rest.slice(0, firstIdx);
    }
    if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      const p110 = this.pathname || "";
      const s10 = this.search || "";
      this.path = p110 + s10;
    }
    this.href = this.format();
    return this;
  }
};
function isIpv6Hostname(hostname) {
  return hostname.charCodeAt(0) === 91 && hostname.charCodeAt(hostname.length - 1) === 93;
}
function getHostname(self1, rest, hostname) {
  for (let i = 0; i < hostname.length; ++i) {
    const code2 = hostname.charCodeAt(i);
    const isValid = code2 >= 97 && code2 <= 122 || code2 === 46 || code2 >= 65 && code2 <= 90 || code2 >= 48 && code2 <= 57 || code2 === 45 || code2 === 43 || code2 === 95 || code2 > 127;
    if (!isValid) {
      self1.hostname = hostname.slice(0, i);
      return `/${hostname.slice(i)}${rest}`;
    }
  }
  return rest;
}
var escapedCodes = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%09",
  "%0A",
  "",
  "",
  "%0D",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%20",
  "",
  "%22",
  "",
  "",
  "",
  "",
  "%27",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%3C",
  "",
  "%3E",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%5C",
  "",
  "%5E",
  "",
  "%60",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%7B",
  "%7C",
  "%7D"
];
function autoEscapeStr(rest) {
  let escaped = "";
  let lastEscapedPos = 0;
  for (let i = 0; i < rest.length; ++i) {
    const escapedChar = escapedCodes[rest.charCodeAt(i)];
    if (escapedChar) {
      if (i > lastEscapedPos) {
        escaped += rest.slice(lastEscapedPos, i);
      }
      escaped += escapedChar;
      lastEscapedPos = i + 1;
    }
  }
  if (lastEscapedPos === 0) {
    return rest;
  }
  if (lastEscapedPos < rest.length) {
    escaped += rest.slice(lastEscapedPos);
  }
  return escaped;
}
function parse12(url, parseQueryString, slashesDenoteHost) {
  if (url instanceof Url)
    return url;
  const urlObject = new Url();
  urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
  return urlObject;
}
var isCryptoKey3 = (key2) => key2 instanceof CryptoKey;
var encoder = new TextEncoder();
var decoder = new TextDecoder();
function concat5(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + 32768)));
  }
  return btoa(arr.join(""));
};
var encode11 = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var JOSEError = class extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  code = "ERR_JOSE_GENERIC";
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
};
var JOSENotSupported = class extends JOSEError {
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
  code = "ERR_JOSE_NOT_SUPPORTED";
};
var JWSInvalid = class extends JOSEError {
  static get code() {
    return "ERR_JWS_INVALID";
  }
  code = "ERR_JWS_INVALID";
};
var JWTInvalid = class extends JOSEError {
  static get code() {
    return "ERR_JWT_INVALID";
  }
  code = "ERR_JWT_INVALID";
};
crypto.getRandomValues.bind(crypto);
function isCloudflareWorkers() {
  return typeof WebSocketPair === "function";
}
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key2, usages) {
  if (usages.length && !usages.some((expected) => key2.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key2, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key2.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key2.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key2.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected1 = parseInt(alg.slice(2), 10);
      const actual1 = getHashLength(key2.algorithm.hash);
      if (actual1 !== expected1)
        throw unusable(`SHA-${expected1}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key2.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected2 = parseInt(alg.slice(2), 10);
      const actual2 = getHashLength(key2.algorithm.hash);
      if (actual2 !== expected2)
        throw unusable(`SHA-${expected2}`, "algorithm.hash");
      break;
    }
    case (isCloudflareWorkers() && "EdDSA"): {
      if (!isAlgorithm(key2.algorithm, "NODE-ED25519"))
        throw unusable("NODE-ED25519");
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key2.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected3 = getNamedCurve(alg);
      const actual3 = key2.algorithm.namedCurve;
      if (actual3 !== expected3)
        throw unusable(expected3, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key2, usages);
}
var __default25 = (actual, ...types2) => {
  let msg = "Key must be ";
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
};
var types = [
  "CryptoKey"
];
var __default26 = (key2) => {
  return isCryptoKey3(key2);
};
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var __default27 = (alg, key2) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key2.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};
var __default28 = (b64, descriptor) => {
  const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
  return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
};
var symmetricTypeCheck = (key2) => {
  if (key2 instanceof Uint8Array)
    return;
  if (!__default26(key2)) {
    throw new TypeError(__default25(key2, ...types, "Uint8Array"));
  }
  if (key2.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (key2, usage) => {
  if (!__default26(key2)) {
    throw new TypeError(__default25(key2, ...types));
  }
  if (key2.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key2.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key2.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key2.algorithm && usage === "verify" && key2.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key2.algorithm && usage === "encrypt" && key2.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key2, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(key2);
  } else {
    asymmetricTypeCheck(key2, usage);
  }
};
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([
      ...Object.entries(recognizedOption),
      ...recognizedDefault.entries()
    ]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
Symbol();
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return {
        hash,
        name: "HMAC"
      };
    case "PS256":
    case "PS384":
    case "PS512":
      return {
        hash,
        name: "RSA-PSS",
        saltLength: alg.slice(-3) >> 3
      };
    case "RS256":
    case "RS384":
    case "RS512":
      return {
        hash,
        name: "RSASSA-PKCS1-v1_5"
      };
    case "ES256":
    case "ES384":
    case "ES512":
      return {
        hash,
        name: "ECDSA",
        namedCurve: algorithm.namedCurve
      };
    case (isCloudflareWorkers() && "EdDSA"):
      const { namedCurve } = algorithm;
      return {
        name: namedCurve,
        namedCurve
      };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
function getCryptoKey(alg, key2, usage) {
  if (isCryptoKey3(key2)) {
    checkSigCryptoKey(key2, alg, usage);
    return key2;
  }
  if (key2 instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(__default25(key2, ...types));
    }
    return crypto.subtle.importKey("raw", key2, {
      hash: `SHA-${alg.slice(-3)}`,
      name: "HMAC"
    }, false, [
      usage
    ]);
  }
  throw new TypeError(__default25(key2, ...types, "Uint8Array"));
}
var __default29 = (date) => Math.floor(date.getTime() / 1e3);
var hour = 60 * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var __default30 = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * 60);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};
var sign = async (alg, key2, data) => {
  const cryptoKey = await getCryptoKey(alg, key2, "sign");
  __default27(alg, cryptoKey);
  const signature2 = await crypto.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature2);
};
var FlattenedSign = class {
  _payload;
  _protectedHeader;
  _unprotectedHeader;
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key2, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([
      [
        "b64",
        true
      ]
    ]), options?.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    checkKeyType(alg, key2, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode11(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode11(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat5(protectedHeader, encoder.encode("."), payload);
    const signature2 = await sign(alg, key2, data);
    const jws = {
      signature: encode11(signature2),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};
var CompactSign = class {
  _flattened;
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key2, options) {
    const jws = await this._flattened.sign(key2, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};
var ProduceJWT = class {
  _payload;
  constructor(payload) {
    if (!isObject2(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = {
      ...this._payload,
      iss: issuer
    };
    return this;
  }
  setSubject(subject) {
    this._payload = {
      ...this._payload,
      sub: subject
    };
    return this;
  }
  setAudience(audience) {
    this._payload = {
      ...this._payload,
      aud: audience
    };
    return this;
  }
  setJti(jwtId) {
    this._payload = {
      ...this._payload,
      jti: jwtId
    };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = {
        ...this._payload,
        nbf: input
      };
    } else {
      this._payload = {
        ...this._payload,
        nbf: __default29(new Date()) + __default30(input)
      };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = {
        ...this._payload,
        exp: input
      };
    } else {
      this._payload = {
        ...this._payload,
        exp: __default29(new Date()) + __default30(input)
      };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = {
        ...this._payload,
        iat: __default29(new Date())
      };
    } else {
      this._payload = {
        ...this._payload,
        iat: input
      };
    }
    return this;
  }
};
var SignJWT = class extends ProduceJWT {
  _protectedHeader;
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key2, options) {
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key2, options);
  }
};
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init3() {
  inited = true;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code2.length; i < len; ++i) {
    lookup[i] = code2[i];
    revLookup[code2.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init3();
  }
  var i, j13, l22, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l22 = placeHolders > 0 ? len - 4 : len;
  var L18 = 0;
  for (i = 0, j13 = 0; i < l22; i += 4, j13 += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L18++] = tmp >> 16 & 255;
    arr[L18++] = tmp >> 8 & 255;
    arr[L18++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L18++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L18++] = tmp >> 8 & 255;
    arr[L18++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init3();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m20;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d14 = isLE ? -1 : 1;
  var s10 = buffer[offset + i];
  i += d14;
  e = s10 & (1 << -nBits) - 1;
  s10 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d14, nBits -= 8) {
  }
  m20 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m20 = m20 * 256 + buffer[offset + i], i += d14, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m20 ? NaN : (s10 ? -1 : 1) * Infinity;
  } else {
    m20 = m20 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s10 ? -1 : 1) * m20 * Math.pow(2, e - mLen);
}
function write5(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m20, c13;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt3 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d14 = isLE ? 1 : -1;
  var s10 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m20 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c13 = Math.pow(2, -e)) < 1) {
      e--;
      c13 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt3 / c13;
    } else {
      value += rt3 * Math.pow(2, 1 - eBias);
    }
    if (value * c13 >= 2) {
      e++;
      c13 /= 2;
    }
    if (e + eBias >= eMax) {
      m20 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m20 = (value * c13 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m20 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m20 & 255, i += d14, m20 /= 256, mLen -= 8) {
  }
  e = e << mLen | m20;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d14, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d14] |= s10 * 128;
}
var toString6 = {}.toString;
var isArray2 = Array.isArray || function(arr) {
  return toString6.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES4 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
function kMaxLength4() {
  return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer4(that, length) {
  if (kMaxLength4() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer4.prototype;
  } else {
    if (that === null) {
      that = new Buffer4(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer4(arg, encodingOrOffset, length) {
  if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
    return new Buffer4(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe5(this, arg);
  }
  return from5(this, arg, encodingOrOffset, length);
}
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
  arr.__proto__ = Buffer4.prototype;
  return arr;
};
function from5(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer4(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString4(that, value, encodingOrOffset);
  }
  return fromObject4(that, value);
}
Buffer4.from = function(value, encodingOrOffset, length) {
  return from5(null, value, encodingOrOffset, length);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
  Buffer4.prototype.__proto__ = Uint8Array.prototype;
  Buffer4.__proto__ = Uint8Array;
}
function assertSize5(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc5(that, size, fill22, encoding) {
  assertSize5(size);
  if (size <= 0) {
    return createBuffer4(that, size);
  }
  if (fill22 !== void 0) {
    return typeof encoding === "string" ? createBuffer4(that, size).fill(fill22, encoding) : createBuffer4(that, size).fill(fill22);
  }
  return createBuffer4(that, size);
}
Buffer4.alloc = function(size, fill22, encoding) {
  return alloc5(null, size, fill22, encoding);
};
function allocUnsafe5(that, size) {
  assertSize5(size);
  that = createBuffer4(that, size < 0 ? 0 : checked4(size) | 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer4.allocUnsafe = function(size) {
  return allocUnsafe5(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
  return allocUnsafe5(null, size);
};
function fromString4(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength6(string, encoding) | 0;
  that = createBuffer4(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike4(that, array) {
  var length = array.length < 0 ? 0 : checked4(array.length) | 0;
  that = createBuffer4(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer4(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer4.prototype;
  } else {
    that = fromArrayLike4(that, array);
  }
  return that;
}
function fromObject4(that, obj2) {
  if (internalIsBuffer(obj2)) {
    var len = checked4(obj2.length) | 0;
    that = createBuffer4(that, len);
    if (that.length === 0) {
      return that;
    }
    obj2.copy(that, 0, 0, len);
    return that;
  }
  if (obj2) {
    if (typeof ArrayBuffer !== "undefined" && obj2.buffer instanceof ArrayBuffer || "length" in obj2) {
      if (typeof obj2.length !== "number" || isnan(obj2.length)) {
        return createBuffer4(that, 0);
      }
      return fromArrayLike4(that, obj2);
    }
    if (obj2.type === "Buffer" && isArray2(obj2.data)) {
      return fromArrayLike4(that, obj2.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked4(length) {
  if (length >= kMaxLength4()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength4().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer4.isBuffer = isBuffer22;
function internalIsBuffer(b15) {
  return !!(b15 != null && b15._isBuffer);
}
Buffer4.compare = function compare10(a7, b15) {
  if (!internalIsBuffer(a7) || !internalIsBuffer(b15)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a7 === b15)
    return 0;
  var x17 = a7.length;
  var y16 = b15.length;
  for (var i = 0, len = Math.min(x17, y16); i < len; ++i) {
    if (a7[i] !== b15[i]) {
      x17 = a7[i];
      y16 = b15[i];
      break;
    }
  }
  if (x17 < y16)
    return -1;
  if (y16 < x17)
    return 1;
  return 0;
};
Buffer4.isEncoding = function isEncoding5(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer4.concat = function concat6(list, length) {
  if (!isArray2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  var i;
  if (length === void 0) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer4.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength6(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes4(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes4(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes4(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.byteLength = byteLength6;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice32(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice5(this, start, end);
      case "ascii":
        return asciiSlice5(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice5(this, start, end);
      case "base64":
        return base64Slice5(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.prototype._isBuffer = true;
function swap4(b15, n3, m20) {
  var i = b15[n3];
  b15[n3] = b15[m20];
  b15[m20] = i;
}
Buffer4.prototype.swap16 = function swap165() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap4(this, i, i + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap325() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap4(this, i, i + 3);
    swap4(this, i + 1, i + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap645() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap4(this, i, i + 7);
    swap4(this, i + 1, i + 6);
    swap4(this, i + 2, i + 5);
    swap4(this, i + 3, i + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString22() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice5(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer4.prototype.equals = function equals5(b15) {
  if (!internalIsBuffer(b15))
    throw new TypeError("Argument must be a Buffer");
  if (this === b15)
    return true;
  return Buffer4.compare(this, b15) === 0;
};
Buffer4.prototype.inspect = function inspect6() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES4;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer4.prototype.compare = function compare22(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x17 = thisEnd - thisStart;
  var y16 = end - start;
  var len = Math.min(x17, y16);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x17 = thisCopy[i];
      y16 = targetCopy[i];
      break;
    }
  }
  if (x17 < y16)
    return -1;
  if (y16 < x17)
    return 1;
  return 0;
};
function bidirectionalIndexOf4(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer4.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [
      val
    ], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i22) {
    if (indexSize === 1) {
      return buf[i22];
    } else {
      return buf.readUInt16BE(i22 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j13 = 0; j13 < valLength; j13++) {
        if (read2(arr, i + j13) !== read2(val, j13)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer4.prototype.includes = function includes5(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf5(val, byteOffset, encoding) {
  return bidirectionalIndexOf4(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf5(val, byteOffset, encoding) {
  return bidirectionalIndexOf4(this, val, byteOffset, encoding, false);
};
function hexWrite5(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write22(buf, string, offset, length) {
  return blitBuffer4(utf8ToBytes4(string, buf.length - offset), buf, offset, length);
}
function asciiWrite5(buf, string, offset, length) {
  return blitBuffer4(asciiToBytes4(string), buf, offset, length);
}
function latin1Write5(buf, string, offset, length) {
  return asciiWrite5(buf, string, offset, length);
}
function base64Write5(buf, string, offset, length) {
  return blitBuffer4(base64ToBytes4(string), buf, offset, length);
}
function ucs2Write5(buf, string, offset, length) {
  return blitBuffer4(utf16leToBytes4(string, buf.length - offset), buf, offset, length);
}
Buffer4.prototype.write = function write22(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite5(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write22(this, string, offset, length);
      case "ascii":
        return asciiWrite5(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write5(this, string, offset, length);
      case "base64":
        return base64Write5(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write5(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer4.prototype.toJSON = function toJSON6() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice5(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice5(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray4(res);
}
var MAX_ARGUMENTS_LENGTH4 = 4096;
function decodeCodePointsArray4(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH4) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH4));
  }
  return res;
}
function asciiSlice5(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice5(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice32(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer4.prototype.slice = function slice5(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer4.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer4(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer4.prototype.readUIntLE = function readUIntLE5(offset, byteLength23, noAssert) {
  offset = offset | 0;
  byteLength23 = byteLength23 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength23, this.length);
  var val = this[offset];
  var mul4 = 1;
  var i = 0;
  while (++i < byteLength23 && (mul4 *= 256)) {
    val += this[offset + i] * mul4;
  }
  return val;
};
Buffer4.prototype.readUIntBE = function readUIntBE5(offset, byteLength23, noAssert) {
  offset = offset | 0;
  byteLength23 = byteLength23 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength23, this.length);
  }
  var val = this[offset + --byteLength23];
  var mul4 = 1;
  while (byteLength23 > 0 && (mul4 *= 256)) {
    val += this[offset + --byteLength23] * mul4;
  }
  return val;
};
Buffer4.prototype.readUInt8 = function readUInt86(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer4.prototype.readUInt16LE = function readUInt16LE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer4.prototype.readUInt16BE = function readUInt16BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer4.prototype.readUInt32LE = function readUInt32LE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer4.prototype.readUInt32BE = function readUInt32BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer4.prototype.readIntLE = function readIntLE5(offset, byteLength23, noAssert) {
  offset = offset | 0;
  byteLength23 = byteLength23 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength23, this.length);
  var val = this[offset];
  var mul4 = 1;
  var i = 0;
  while (++i < byteLength23 && (mul4 *= 256)) {
    val += this[offset + i] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength23);
  return val;
};
Buffer4.prototype.readIntBE = function readIntBE5(offset, byteLength23, noAssert) {
  offset = offset | 0;
  byteLength23 = byteLength23 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength23, this.length);
  var i = byteLength23;
  var mul4 = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul4 *= 256)) {
    val += this[offset + --i] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength23);
  return val;
};
Buffer4.prototype.readInt8 = function readInt85(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer4.prototype.readInt16LE = function readInt16LE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt16BE = function readInt16BE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt32LE = function readInt32LE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer4.prototype.readInt32BE = function readInt32BE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer4.prototype.readFloatLE = function readFloatLE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer4.prototype.readFloatBE = function readFloatBE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE5(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt4(buf, value, offset, ext, max2, min3) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min3)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer4.prototype.writeUIntLE = function writeUIntLE5(value, offset, byteLength23, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength23 = byteLength23 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength23) - 1;
    checkInt4(this, value, offset, byteLength23, maxBytes, 0);
  }
  var mul4 = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength23 && (mul4 *= 256)) {
    this[offset + i] = value / mul4 & 255;
  }
  return offset + byteLength23;
};
Buffer4.prototype.writeUIntBE = function writeUIntBE5(value, offset, byteLength23, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength23 = byteLength23 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength23) - 1;
    checkInt4(this, value, offset, byteLength23, maxBytes, 0);
  }
  var i = byteLength23 - 1;
  var mul4 = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul4 *= 256)) {
    this[offset + i] = value / mul4 & 255;
  }
  return offset + byteLength23;
};
Buffer4.prototype.writeUInt8 = function writeUInt85(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 1, 255, 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j13 = Math.min(buf.length - offset, 2); i < j13; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer4.prototype.writeUInt16LE = function writeUInt16LE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer4.prototype.writeUInt16BE = function writeUInt16BE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j13 = Math.min(buf.length - offset, 4); i < j13; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer4.prototype.writeUInt32LE = function writeUInt32LE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer4.prototype.writeUInt32BE = function writeUInt32BE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer4.prototype.writeIntLE = function writeIntLE5(value, offset, byteLength23, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength23 - 1);
    checkInt4(this, value, offset, byteLength23, limit - 1, -limit);
  }
  var i = 0;
  var mul4 = 1;
  var sub3 = 0;
  this[offset] = value & 255;
  while (++i < byteLength23 && (mul4 *= 256)) {
    if (value < 0 && sub3 === 0 && this[offset + i - 1] !== 0) {
      sub3 = 1;
    }
    this[offset + i] = (value / mul4 >> 0) - sub3 & 255;
  }
  return offset + byteLength23;
};
Buffer4.prototype.writeIntBE = function writeIntBE5(value, offset, byteLength23, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength23 - 1);
    checkInt4(this, value, offset, byteLength23, limit - 1, -limit);
  }
  var i = byteLength23 - 1;
  var mul4 = 1;
  var sub3 = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul4 *= 256)) {
    if (value < 0 && sub3 === 0 && this[offset + i + 1] !== 0) {
      sub3 = 1;
    }
    this[offset + i] = (value / mul4 >> 0) - sub3 & 255;
  }
  return offset + byteLength23;
};
Buffer4.prototype.writeInt8 = function writeInt85(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 1, 127, -128);
  if (!Buffer4.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer4.prototype.writeInt16LE = function writeInt16LE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer4.prototype.writeInt16BE = function writeInt16BE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer4.prototype.writeInt32LE = function writeInt32LE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer4.prototype.writeInt32BE = function writeInt32BE5(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max2, min3) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write5(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer4.prototype.writeFloatLE = function writeFloatLE5(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE5(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write5(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer4.prototype.writeDoubleLE = function writeDoubleLE5(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE5(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer4.prototype.copy = function copy6(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};
Buffer4.prototype.fill = function fill5(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes4(new Buffer4(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE4 = /[^+\/0-9A-Za-z-_]/g;
function base64clean4(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE4, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n3) {
  if (n3 < 16)
    return "0" + n3.toString(16);
  return n3.toString(16);
}
function utf8ToBytes4(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes4(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes4(str, units) {
  var c13, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c13 = str.charCodeAt(i);
    hi = c13 >> 8;
    lo = c13 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes4(str) {
  return toByteArray(base64clean4(str));
}
function blitBuffer4(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer22(obj2) {
  return obj2 != null && (!!obj2._isBuffer || isFastBuffer(obj2) || isSlowBuffer(obj2));
}
function isFastBuffer(obj2) {
  return !!obj2.constructor && typeof obj2.constructor.isBuffer === "function" && obj2.constructor.isBuffer(obj2);
}
function isSlowBuffer(obj2) {
  return typeof obj2.readFloatLE === "function" && typeof obj2.slice === "function" && isFastBuffer(obj2.slice(0, 0));
}
var version2 = "1.0.0";
var encode12 = function encode22(buffer) {
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
var decode9 = function decode23(base64) {
  base64 += Array(5 - base64.length % 4).join("=");
  base64 = base64.replace(/\-/g, "+").replace(/\_/g, "/");
  return new Buffer4(base64, "base64");
};
var validate = function validate2(base64) {
  return /^[A-Za-z0-9\-_]+$/.test(base64);
};
var urlsafeBase64 = {
  version: version2,
  encode: encode12,
  decode: decode9,
  validate
};
var urlsafeBase64$1 = urlsafeBase64;
var decode$1 = urlsafeBase64$1.decode;
var encode$1 = urlsafeBase64$1.encode;
var validate$1 = urlsafeBase64$1.validate;
var version$1 = urlsafeBase64$1.version;
var mod113 = {
  default: urlsafeBase64$1,
  __moduleExports: urlsafeBase64$1,
  decode: decode$1,
  encode: encode$1,
  validate: validate$1,
  version: version$1
};
var importMeta = {
  url: "file:///Users/mcharlton/OtherCode/deno-web-push/mod.ts",
  main: import_meta.main
};
var crypto_default = mod107;
var WebPushConstants = {};
var supportedContentEncodings = {
  AES_GCM: "aesgcm",
  AES_128_GCM: "aes128gcm"
};
WebPushConstants.supportedContentEncodings = supportedContentEncodings;
var web_push_constants_default = WebPushConstants;
var DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;
var MAX_EXPIRATION_SECONDS = 24 * 60 * 60;
function generateVAPIDKeys() {
  const curve = crypto_default.createECDH("prime256v1");
  curve.generateKeys();
  let publicKeyBuffer = curve.getPublicKey();
  let privateKeyBuffer = curve.getPrivateKey();
  if (privateKeyBuffer.length < 32) {
    const padding = Buffer22.alloc(32 - privateKeyBuffer.length);
    padding.fill(0);
    privateKeyBuffer = Buffer22.concat([
      padding,
      privateKeyBuffer
    ]);
  }
  if (publicKeyBuffer.length < 65) {
    const padding1 = Buffer22.alloc(65 - publicKeyBuffer.length);
    padding1.fill(0);
    publicKeyBuffer = Buffer22.concat([
      padding1,
      publicKeyBuffer
    ]);
  }
  return {
    publicKey: encode$1(publicKeyBuffer),
    privateKey: encode$1(privateKeyBuffer)
  };
}
function validateSubject(subject) {
  if (!subject) {
    throw new Error("No subject set in vapidDetails.subject.");
  }
  if (typeof subject !== "string" || subject.length === 0) {
    throw new Error("The subject value must be a string containing a URL or mailto: address. " + subject);
  }
  if (subject.indexOf("mailto:") !== 0) {
    const subjectParseResult = parse12(subject, false, false);
    if (!subjectParseResult.hostname) {
      throw new Error("Vapid subject is not a url or mailto url. " + subject);
    }
  }
}
function validatePublicKey(publicKey) {
  if (!publicKey) {
    throw new Error("No key set vapidDetails.publicKey");
  }
  if (typeof publicKey !== "string") {
    throw new Error("Vapid public key is must be a URL safe Base 64 encoded string.");
  }
  if (!isUrlSafeBase64(publicKey)) {
    throw new Error('Vapid public key must be a URL safe Base 64 (without "=")');
  }
  publicKey = decode$1(publicKey);
  if (publicKey.length !== 65) {
    throw new Error("Vapid public key should be 65 bytes long when decoded.");
  }
}
function validatePrivateKey(privateKey) {
  if (!privateKey) {
    throw new Error("No key set in vapidDetails.privateKey");
  }
  if (typeof privateKey !== "string") {
    throw new Error("Vapid private key must be a URL safe Base 64 encoded string.");
  }
  if (!isUrlSafeBase64(privateKey)) {
    throw new Error('Vapid private key must be a URL safe Base 64 (without "=")');
  }
  privateKey = decode$1(privateKey);
  if (privateKey.length !== 32) {
    throw new Error("Vapid private key should be 32 bytes long when decoded.");
  }
}
function getFutureExpirationTimestamp(numSeconds) {
  const futureExp = new Date();
  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);
  return Math.floor(futureExp.getTime() / 1e3);
}
function validateExpiration(expiration) {
  if (!Number.isInteger(expiration)) {
    throw new Error("`expiration` value must be a number");
  }
  if (expiration < 0) {
    throw new Error("`expiration` must be a positive integer");
  }
  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);
  if (expiration >= maxExpirationTimestamp) {
    throw new Error("`expiration` value is greater than maximum of 24 hours");
  }
}
async function getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {
  if (!audience) {
    throw new Error("No audience could be generated for VAPID.");
  }
  if (typeof audience !== "string" || audience.length === 0) {
    throw new Error("The audience value must be a string containing the origin of a push service. " + audience);
  }
  const audienceParseResult = parse12(audience, false, false);
  if (!audienceParseResult.hostname) {
    throw new Error("VAPID audience is not a url. " + audience);
  }
  validateSubject(subject);
  validatePublicKey(publicKey);
  validatePrivateKey(privateKey);
  privateKey = decode$1(privateKey);
  if (expiration) {
    validateExpiration(expiration);
  } else {
    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);
  }
  const header = {
    typ: "JWT",
    alg: "ES256"
  };
  const jwtPayload = {
    aud: audience,
    exp: expiration,
    sub: subject
  };
  const jwt = await new SignJWT(jwtPayload).setProtectedHeader(header).sign(new __default21.TextEncoder().encode(__default28(privateKey, "EC PRIVATE KEY")));
  if (contentEncoding === supportedContentEncodings.AES_128_GCM) {
    return {
      Authorization: "vapid t=" + jwt + ", k=" + publicKey
    };
  }
  if (contentEncoding === supportedContentEncodings.AES_GCM) {
    return {
      Authorization: "WebPush " + jwt,
      "Crypto-Key": "p256ecdsa=" + publicKey
    };
  }
  throw new Error("Unsupported encoding type specified.");
}
var AES_GCM = "aes-128-gcm";
var PAD_SIZE = {
  aes128gcm: 1,
  aesgcm: 2
};
var TAG_LENGTH = 16;
var KEY_LENGTH = 16;
var NONCE_LENGTH = 12;
var SHA_256_LENGTH = 32;
var MODE_ENCRYPT = "encrypt";
var MODE_DECRYPT = "decrypt";
var keylog;
if (importMeta.env?.ECE_KEYLOG === "1") {
  keylog = function(m20, k15) {
    console.warn(m20 + " [" + k15.length + "]: " + encode$1(k15));
    return k15;
  };
} else {
  keylog = function(m20, k15) {
    return k15;
  };
}
function decode31(b15) {
  if (typeof b15 === "string") {
    return decode$1(b15);
  }
  return b15;
}
function HMAC_hash(key2, input) {
  const hmac = crypto_default.createHmac("sha256", key2);
  hmac.update(input);
  return hmac.digest();
}
function HKDF_extract(salt, ikm) {
  keylog("salt", salt);
  keylog("ikm", ikm);
  return keylog("extract", HMAC_hash(salt, ikm));
}
function HKDF_expand(prk, info2, l22) {
  keylog("prk", prk);
  keylog("info", info2);
  let output = Buffer22.alloc(0);
  let T12 = Buffer22.alloc(0);
  info2 = Buffer22.from(info2, "ascii");
  let counter = 0;
  const cbuf = Buffer22.alloc(1);
  while (output.length < l22) {
    cbuf.writeUIntBE(++counter, 0, 1);
    T12 = HMAC_hash(prk, Buffer22.concat([
      T12,
      info2,
      cbuf
    ]));
    output = Buffer22.concat([
      output,
      T12
    ]);
  }
  return keylog("expand", output.slice(0, l22));
}
function HKDF(salt, ikm, info2, len) {
  return HKDF_expand(HKDF_extract(salt, ikm), info2, len);
}
function info(base2, context) {
  const result = Buffer22.concat([
    Buffer22.from("Content-Encoding: " + base2 + "\0", "ascii"),
    context
  ]);
  keylog("info " + base2, result);
  return result;
}
function lengthPrefix(buffer) {
  const b15 = Buffer22.concat([
    Buffer22.alloc(2),
    buffer
  ]);
  b15.writeUIntBE(buffer.length, 0, 2);
  return b15;
}
function extractDH(header, mode) {
  const key2 = header.privateKey;
  let senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = key2.getPublicKey();
    receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    senderPubKey = header.dh;
    receiverPubKey = key2.getPublicKey();
  } else {
    throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
  }
  return {
    secret: key2.computeSecret(header.dh),
    context: Buffer22.concat([
      Buffer22.from(header.keylabel, "ascii"),
      Buffer22.from([
        0
      ]),
      lengthPrefix(receiverPubKey),
      lengthPrefix(senderPubKey)
    ])
  };
}
function extractSecretAndContext(header, mode) {
  let result = {
    secret: null,
    context: Buffer22.alloc(0)
  };
  if (header.key) {
    result.secret = header.key;
    if (result.secret !== null && result.secret.length !== KEY_LENGTH) {
      throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
    }
  } else if (header.dh) {
    result = extractDH(header, mode);
  } else if (header.keyid !== void 0) {
    result.secret = header.keymap[header.keyid];
  }
  if (!result.secret) {
    throw new Error("Unable to determine key");
  }
  keylog("secret", result.secret);
  keylog("context", result.context);
  if (header.authSecret) {
    result.secret = HKDF(header.authSecret, result.secret, info("auth", Buffer22.alloc(0)), SHA_256_LENGTH);
    keylog("authsecret", result.secret);
  }
  return result;
}
function webpushSecret(header, mode) {
  if (!header.authSecret) {
    throw new Error("No authentication secret for webpush");
  }
  keylog("authsecret", header.authSecret);
  let remotePubKey, senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = header.privateKey.getPublicKey();
    remotePubKey = receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    remotePubKey = senderPubKey = header.keyid;
    receiverPubKey = header.privateKey.getPublicKey();
  } else {
    throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
  }
  keylog("remote pubkey", remotePubKey);
  keylog("sender pubkey", senderPubKey);
  keylog("receiver pubkey", receiverPubKey);
  return keylog("secret dh", HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer22.concat([
    Buffer22.from("WebPush: info\0"),
    receiverPubKey,
    senderPubKey
  ]), SHA_256_LENGTH));
}
function extractSecret(header, mode, keyLookupCallback) {
  if (keyLookupCallback) {
    if (!isFunction2(keyLookupCallback)) {
      throw new Error("Callback is not a function");
    }
  }
  if (header.key) {
    if (header.key.length !== KEY_LENGTH) {
      throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
    }
    return keylog("secret key", header.key);
  }
  if (!header.privateKey) {
    let key2;
    if (!keyLookupCallback) {
      key2 = header.keymap && header.keymap[header.keyid];
    } else {
      key2 = keyLookupCallback(header.keyid);
    }
    if (!key2) {
      throw new Error('No saved key (keyid: "' + header.keyid + '")');
    }
    return key2;
  }
  return webpushSecret(header, mode);
}
function deriveKeyAndNonce(header, mode, lookupKeyCallback) {
  if (!header.salt) {
    throw new Error("must include a salt parameter for " + header.version);
  }
  let keyInfo;
  let nonceInfo;
  let secret;
  if (header.version === "aesgcm") {
    const s10 = extractSecretAndContext(header, mode, lookupKeyCallback);
    keyInfo = info("aesgcm", s10.context);
    nonceInfo = info("nonce", s10.context);
    secret = s10.secret;
  } else if (header.version === "aes128gcm") {
    keyInfo = Buffer22.from("Content-Encoding: aes128gcm\0");
    nonceInfo = Buffer22.from("Content-Encoding: nonce\0");
    secret = extractSecret(header, mode, lookupKeyCallback);
  } else {
    throw new Error("Unable to set context for mode " + header.version);
  }
  const prk = HKDF_extract(header.salt, secret);
  const result = {
    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),
    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)
  };
  keylog("key", result.key);
  keylog("nonce base", result.nonce);
  return result;
}
function parseParams(params) {
  const header = {};
  header.version = params.version || "aes128gcm";
  header.rs = parseInt(params.rs, 10);
  if (isNaN(header.rs)) {
    header.rs = 4096;
  }
  let overhead = PAD_SIZE[header.version];
  if (header.version === "aes128gcm") {
    overhead += TAG_LENGTH;
  }
  if (header.rs <= overhead) {
    throw new Error("The rs parameter has to be greater than " + overhead);
  }
  if (params.salt) {
    header.salt = decode31(params.salt);
    if (header.salt.length !== KEY_LENGTH) {
      throw new Error("The salt parameter must be " + KEY_LENGTH + " bytes");
    }
  }
  header.keyid = params.keyid;
  if (params.key) {
    header.key = decode31(params.key);
  } else {
    header.privateKey = params.privateKey;
    if (!header.privateKey) {
      header.keymap = params.keymap;
    }
    if (header.version !== "aes128gcm") {
      header.keylabel = params.keylabel || "P-256";
    }
    if (params.dh) {
      header.dh = decode31(params.dh);
    }
  }
  if (params.authSecret) {
    header.authSecret = decode31(params.authSecret);
  }
  return header;
}
function generateNonce(base2, counter) {
  const nonce = Buffer22.from(base2);
  const m20 = nonce.readUIntBE(nonce.length - 6, 6);
  const x17 = ((m20 ^ counter) & 16777215) + ((m20 / 16777216 ^ counter / 16777216) & 16777215) * 16777216;
  nonce.writeUIntBE(x17, nonce.length - 6, 6);
  keylog("nonce" + counter, nonce);
  return nonce;
}
function encryptRecord(key2, counter, buffer, pad2, header, last) {
  keylog("encrypt", buffer);
  pad2 = pad2 || 0;
  const nonce = generateNonce(key2.nonce, counter);
  const gcm = crypto_default.createCipheriv(AES_GCM, key2.key, nonce);
  const ciphertext = [];
  const padSize = PAD_SIZE[header.version];
  const padding = Buffer22.alloc(pad2 + padSize);
  padding.fill(0);
  if (header.version !== "aes128gcm") {
    padding.writeUIntBE(pad2, 0, padSize);
    keylog("padding", padding);
    ciphertext.push(gcm.update(padding));
    ciphertext.push(gcm.update(buffer));
    if (!last && padding.length + buffer.length < header.rs) {
      throw new Error("Unable to pad to record size");
    }
  } else {
    ciphertext.push(gcm.update(buffer));
    padding.writeUIntBE(last ? 2 : 1, 0, 1);
    keylog("padding", padding);
    ciphertext.push(gcm.update(padding));
  }
  gcm.final();
  const tag2 = gcm.getAuthTag();
  if (tag2.length !== TAG_LENGTH) {
    throw new Error("invalid tag generated");
  }
  ciphertext.push(tag2);
  return keylog("encrypted", Buffer22.concat(ciphertext));
}
function writeHeader(header) {
  const ints = Buffer22.alloc(5);
  const keyid = Buffer22.from(header.keyid || []);
  if (keyid.length > 255) {
    throw new Error("keyid is too large");
  }
  ints.writeUIntBE(header.rs, 0, 4);
  ints.writeUIntBE(keyid.length, 4, 1);
  return Buffer22.concat([
    header.salt,
    ints,
    keyid
  ]);
}
function encrypt7(buffer, params, keyLookupCallback) {
  if (!Buffer22.isBuffer(buffer)) {
    throw new Error("buffer argument must be a Buffer");
  }
  const header = parseParams(params);
  if (!header.salt) {
    header.salt = crypto_default.randomBytes(KEY_LENGTH);
  }
  let result;
  if (header.version === "aes128gcm") {
    if (header.privateKey && !header.keyid) {
      header.keyid = header.privateKey.getPublicKey();
    }
    result = writeHeader(header);
  } else {
    result = Buffer22.alloc(0);
  }
  const key2 = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);
  let start = 0;
  const padSize = PAD_SIZE[header.version];
  let overhead = padSize;
  if (header.version === "aes128gcm") {
    overhead += TAG_LENGTH;
  }
  let pad2 = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);
  let counter = 0;
  let last = false;
  while (!last) {
    let recordPad = Math.min(header.rs - overhead - 1, pad2);
    if (header.version !== "aes128gcm") {
      recordPad = Math.min((1 << padSize * 8) - 1, recordPad);
    }
    if (pad2 > 0 && recordPad === 0) {
      ++recordPad;
    }
    pad2 -= recordPad;
    const end = start + header.rs - overhead - recordPad;
    if (header.version !== "aes128gcm") {
      last = end > buffer.length;
    } else {
      last = end >= buffer.length;
    }
    last = last && pad2 <= 0;
    const block = encryptRecord(key2, counter, buffer.slice(start, end), recordPad, header, last);
    result = Buffer22.concat([
      result,
      block
    ]);
    start = end;
    ++counter;
  }
  return result;
}
function isFunction2(object) {
  return typeof object === "function";
}
var encrypt21 = function(userPublicKey, userAuth, payload, contentEncoding) {
  if (!userPublicKey) {
    throw new Error("No user public key provided for encryption.");
  }
  if (typeof userPublicKey !== "string") {
    throw new Error("The subscription p256dh value must be a string.");
  }
  if (mod113.decode(userPublicKey).length !== 65) {
    throw new Error("The subscription p256dh value should be 65 bytes long.");
  }
  if (!userAuth) {
    throw new Error("No user auth provided for encryption.");
  }
  if (typeof userAuth !== "string") {
    throw new Error("The subscription auth key must be a string.");
  }
  if (mod113.decode(userAuth).length < 16) {
    throw new Error("The subscription auth key should be at least 16 bytes long");
  }
  if (typeof payload !== "string" && !Buffer22.isBuffer(payload)) {
    throw new Error("Payload must be either a string or a Node Buffer.");
  }
  if (typeof payload === "string" || payload instanceof String) {
    payload = Buffer22.from(payload);
  }
  const localCurve = crypto_default.createECDH("prime256v1");
  const localPublicKey = localCurve.generateKeys();
  const salt = mod113.encode(crypto_default.randomBytes(16));
  const cipherText = encrypt7(payload, {
    version: contentEncoding,
    dh: userPublicKey,
    privateKey: localCurve,
    salt,
    authSecret: userAuth
  });
  return {
    localPublicKey,
    salt,
    cipherText
  };
};
function WebPushError(message, statusCode, headers, body, endpoint) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
  this.statusCode = statusCode;
  this.headers = headers;
  this.body = body;
  this.endpoint = endpoint;
}
__default21.inherits(WebPushError, Error);
var web_push_error_default = WebPushError;
var DEFAULT_TTL = 2419200;
var gcmAPIKey = "";
var vapidDetails;
function WebPushLib() {
}
WebPushLib.prototype.setGCMAPIKey = function(apiKey) {
  if (apiKey === null) {
    gcmAPIKey = null;
    return;
  }
  if (typeof apiKey === "undefined" || typeof apiKey !== "string" || apiKey.length === 0) {
    throw new Error("The GCM API Key should be a non-empty string or null.");
  }
  gcmAPIKey = apiKey;
};
WebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {
  if (arguments.length === 1 && arguments[0] === null) {
    vapidDetails = null;
    return;
  }
  validateSubject(subject);
  validatePublicKey(publicKey);
  validatePrivateKey(privateKey);
  vapidDetails = {
    subject,
    publicKey,
    privateKey
  };
};
WebPushLib.prototype.generateRequestDetails = async function(subscription, payload, options) {
  if (!subscription || !subscription.endpoint) {
    throw new Error("You must pass in a subscription with at least an endpoint.");
  }
  if (typeof subscription.endpoint !== "string" || subscription.endpoint.length === 0) {
    throw new Error("The subscription endpoint must be a string with a valid URL.");
  }
  if (payload) {
    if (typeof subscription !== "object" || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {
      throw new Error("To send a message with a payload, the subscription must have 'auth' and 'p256dh' keys.");
    }
  }
  let currentGCMAPIKey = gcmAPIKey;
  let currentVapidDetails = vapidDetails;
  let timeToLive = DEFAULT_TTL;
  let extraHeaders = {};
  let contentEncoding = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
  let proxy;
  let agent;
  let timeout;
  if (options) {
    const validOptionKeys = [
      "headers",
      "gcmAPIKey",
      "vapidDetails",
      "TTL",
      "contentEncoding",
      "proxy",
      "agent",
      "timeout"
    ];
    const optionKeys = Object.keys(options);
    for (let i = 0; i < optionKeys.length; i += 1) {
      const optionKey = optionKeys[i];
      if (validOptionKeys.indexOf(optionKey) === -1) {
        throw new Error("'" + optionKey + "' is an invalid option. The valid options are ['" + validOptionKeys.join("', '") + "'].");
      }
    }
    if (options.headers) {
      extraHeaders = options.headers;
      let duplicates = Object.keys(extraHeaders).filter(function(header) {
        return typeof options[header] !== "undefined";
      });
      if (duplicates.length > 0) {
        throw new Error("Duplicated headers defined [" + duplicates.join(",") + "]. Please either define the header in thetop level options OR in the 'headers' key.");
      }
    }
    if (options.gcmAPIKey) {
      currentGCMAPIKey = options.gcmAPIKey;
    }
    if (options.vapidDetails !== void 0) {
      currentVapidDetails = options.vapidDetails;
    }
    if (options.TTL !== void 0) {
      timeToLive = Number(options.TTL);
      if (timeToLive < 0) {
        throw new Error("TTL should be a number and should be at least 0");
      }
    }
    if (options.contentEncoding) {
      if (options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM || options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
        contentEncoding = options.contentEncoding;
      } else {
        throw new Error("Unsupported content encoding specified.");
      }
    }
    if (options.proxy) {
      if (typeof options.proxy === "string" || typeof options.proxy.host === "string") {
        proxy = options.proxy;
      } else {
        console.warn("Attempt to use proxy option, but invalid type it should be a string or proxy options object.");
      }
    }
    if (options.agent) {
      if (options.agent instanceof Agent) {
        if (proxy) {
          console.warn("Agent option will be ignored because proxy option is defined.");
        }
        agent = options.agent;
      } else {
        console.warn("Wrong type for the agent option, it should be an instance of https.Agent.");
      }
    }
    if (typeof options.timeout === "number") {
      timeout = options.timeout;
    }
  }
  if (typeof timeToLive === "undefined") {
    timeToLive = DEFAULT_TTL;
  }
  const requestDetails = {
    method: "POST",
    headers: {
      TTL: timeToLive
    }
  };
  Object.keys(extraHeaders).forEach(function(header) {
    requestDetails.headers[header] = extraHeaders[header];
  });
  let requestPayload = null;
  if (payload) {
    const encrypted = encrypt21(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);
    requestDetails.headers["Content-Length"] = encrypted.cipherText.length;
    requestDetails.headers["Content-Type"] = "application/octet-stream";
    if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM) {
      requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
    } else if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
      requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_GCM;
      requestDetails.headers.Encryption = "salt=" + encrypted.salt;
      requestDetails.headers["Crypto-Key"] = "dh=" + encode$1(encrypted.localPublicKey);
    }
    requestPayload = encrypted.cipherText;
  } else {
    requestDetails.headers["Content-Length"] = 0;
  }
  const isGCM = subscription.endpoint.indexOf("https://android.googleapis.com/gcm/send") === 0;
  const isFCM = subscription.endpoint.indexOf("https://fcm.googleapis.com/fcm/send") === 0;
  if (isGCM) {
    if (!currentGCMAPIKey) {
      console.warn("Attempt to send push notification to GCM endpoint, but no GCM key is defined. Please use setGCMApiKey() or add 'gcmAPIKey' as an option.");
    } else {
      requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
    }
  } else if (currentVapidDetails) {
    const parsedUrl = parse12(subscription.endpoint);
    const audience = parsedUrl.protocol + "//" + parsedUrl.host;
    const vapidHeaders = await getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);
    requestDetails.headers.Authorization = vapidHeaders.Authorization;
    if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
      if (requestDetails.headers["Crypto-Key"]) {
        requestDetails.headers["Crypto-Key"] += ";" + vapidHeaders["Crypto-Key"];
      } else {
        requestDetails.headers["Crypto-Key"] = vapidHeaders["Crypto-Key"];
      }
    }
  } else if (isFCM && currentGCMAPIKey) {
    requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
  }
  requestDetails.body = requestPayload;
  requestDetails.endpoint = subscription.endpoint;
  if (proxy) {
    requestDetails.proxy = proxy;
  }
  if (agent) {
    requestDetails.agent = agent;
  }
  if (timeout) {
    requestDetails.timeout = timeout;
  }
  return requestDetails;
};
WebPushLib.prototype.sendNotification = async function(subscription, payload, options) {
  let requestDetails;
  try {
    requestDetails = await this.generateRequestDetails(subscription, payload, options);
  
  } catch (err) {
    return Promise.reject(err);
  }
  console.log('requestDetails',requestDetails)
  return new Promise( function(resolve9, reject) {
    (async () => {
    const httpsOptions = {};
    const urlParts = parse12(requestDetails.endpoint, true, true);
    console.log('urlParts',urlParts)
    httpsOptions.hostname = urlParts.hostname;
    httpsOptions.port = urlParts.port;
    httpsOptions.path = urlParts.path;
    httpsOptions.headers = requestDetails.headers;
    httpsOptions.method = requestDetails.method;
    if (requestDetails.timeout) {
      httpsOptions.timeout = requestDetails.timeout;
    }
    if (requestDetails.agent) {
      httpsOptions.agent = requestDetails.agent;
    }
    if (requestDetails.body) {
      httpsOptions.body = requestDetails.body;
    }
    const pushResponse = await fetch(requestDetails.endpoint, httpsOptions).catch((e) => {
      reject(e);
      console.log('err',e)
    });
    console.log('pushResponse',pushResponse)
    if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {
      reject(new web_push_error_default("Received unexpected response code", pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));
    } else {
      const responseText2 = await pushResponse.text();
      resolve9({
        statusCode: pushResponse.statusCode,
        body: responseText2,
        headers: pushResponse.headers
      });
    }
  })();
  });
};
var web_push_lib_default = WebPushLib;
var webPush = new web_push_lib_default();
var setGCMAPIKey = webPush.setGCMAPIKey;
var setVapidDetails = webPush.setVapidDetails;
var generateRequestDetails = webPush.generateRequestDetails;
var sendNotification = webPush.sendNotification;
