"use strict";
if (typeof Deno === 'undefined') {
  globalThis.addEventListener = () => {};
  globalThis.Deno = {
    env: {
get: () => {}
    },
    args: [],
    errors: {
    PermissionDenied: Error
  },
  build:{
arch: 'x86_64'
}
};
}
globalThis.crypto= require('node:crypto').webcrypto;
const CryptoKey =  globalThis.crypto.CryptoKey;


var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from5, except, desc) => {
  if (from5 && typeof from5 === "object" || typeof from5 === "function") {
    for (let key2 of __getOwnPropNames(from5))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from5[key2], enumerable: !(desc = __getOwnPropDesc(from5, key2)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/index.ts
var src_exports = {};
__export(src_exports, {
  WebPushError: () => web_push_error_default,
  encrypt: () => encrypt9,
  generateRequestDetails: () => generateRequestDetails,
  generateVAPIDKeys: () => generateVAPIDKeys,
  getVapidHeaders: () => getVapidHeaders,
  sendNotification: () => sendNotification,
  setGCMAPIKey: () => setGCMAPIKey,
  setVapidDetails: () => setVapidDetails,
  supportedContentEncodings: () => supportedContentEncodings
});
module.exports = __toCommonJS(src_exports);

// deno:https://esm.sh/crypto-browserify?bundle
var crypto_browserify_bundle_exports = {};
__export(crypto_browserify_bundle_exports, {
  Cipher: () => P7,
  Cipheriv: () => C7,
  Decipher: () => L7,
  Decipheriv: () => z7,
  DiffieHellman: () => Z7,
  DiffieHellmanGroup: () => K7,
  Hash: () => q7,
  Hmac: () => R7,
  Sign: () => X7,
  Verify: () => J7,
  constants: () => a9,
  createCipher: () => T7,
  createCipheriv: () => N7,
  createCredentials: () => n9,
  createDecipher: () => O7,
  createDecipheriv: () => U7,
  createDiffieHellman: () => V7,
  createDiffieHellmanGroup: () => j7,
  createECDH: () => $7,
  createHash: () => A7,
  createHmac: () => B7,
  createSign: () => G7,
  createVerify: () => Y7,
  default: () => s9,
  getCiphers: () => H7,
  getDiffieHellman: () => W7,
  getHashes: () => I7,
  listCiphers: () => F7,
  pbkdf2: () => k7,
  pbkdf2Sync: () => D7,
  privateDecrypt: () => r9,
  privateEncrypt: () => e9,
  prng: () => E7,
  pseudoRandomBytes: () => S7,
  publicDecrypt: () => t9,
  publicEncrypt: () => Q7,
  randomBytes: () => x7,
  randomFill: () => i9,
  randomFillSync: () => f9,
  rng: () => M7
});

// deno:https://deno.land/std@0.147.0/_deno_unstable.ts
function addSignalListener(...args) {
  if (typeof Deno.addSignalListener == "function") {
    return Deno.addSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function removeSignalListener(...args) {
  if (typeof Deno.removeSignalListener == "function") {
    return Deno.removeSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function setRaw(...args) {
  if (typeof Deno.setRaw == "function") {
    return Deno.setRaw(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
async function connect(options) {
  return await Deno.connect(options);
}
function listen(options) {
  return Deno.listen(options);
}
function listenDatagram(options) {
  return Deno.listenDatagram(options);
}
function ListenerRef(listener, ...args) {
  if (typeof listener.ref == "function") {
    return listener.ref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function ListenerUnref(listener, ...args) {
  if (typeof listener.unref == "function") {
    return listener.unref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}

// deno:https://deno.land/std@0.147.0/async/deferred.ts
function deferred() {
  let methods2;
  let state = "pending";
  const promise = new Promise((resolve7, reject) => {
    methods2 = {
      async resolve(value) {
        await value;
        state = "fulfilled";
        resolve7(value);
      },
      reject(reason) {
        state = "rejected";
        reject(reason);
      }
    };
  });
  Object.defineProperty(promise, "state", { get: () => state });
  return Object.assign(promise, methods2);
}

// deno:https://deno.land/std@0.147.0/async/delay.ts
function delay(ms, options = {}) {
  const { signal } = options;
  if (signal?.aborted) {
    return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
  }
  return new Promise((resolve7, reject) => {
    const abort = () => {
      clearTimeout(i);
      reject(new DOMException("Delay was aborted.", "AbortError"));
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve7();
    };
    const i = setTimeout(done, ms);
    signal?.addEventListener("abort", abort, { once: true });
  });
}

// deno:https://deno.land/std@0.147.0/async/mux_async_iterator.ts
var MuxAsyncIterator = class {
  #iteratorCount = 0;
  #yields = [];
  #throws = [];
  #signal = deferred();
  add(iterable) {
    ++this.#iteratorCount;
    this.#callIteratorNext(iterable[Symbol.asyncIterator]());
  }
  async #callIteratorNext(iterator) {
    try {
      const { value, done } = await iterator.next();
      if (done) {
        --this.#iteratorCount;
      } else {
        this.#yields.push({ iterator, value });
      }
    } catch (e) {
      this.#throws.push(e);
    }
    this.#signal.resolve();
  }
  async *iterate() {
    while (this.#iteratorCount > 0) {
      await this.#signal;
      for (let i = 0; i < this.#yields.length; i++) {
        const { iterator, value } = this.#yields[i];
        yield value;
        this.#callIteratorNext(iterator);
      }
      if (this.#throws.length) {
        for (const e of this.#throws) {
          throw e;
        }
        this.#throws.length = 0;
      }
      this.#yields.length = 0;
      this.#signal = deferred();
    }
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// deno:https://deno.land/std@0.147.0/fmt/colors.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code2) {
  return enabled ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}` : str;
}
function bold(str) {
  return run(str, code([1], 22));
}
function red(str) {
  return run(str, code([31], 39));
}
function green(str) {
  return run(str, code([32], 39));
}
function white(str) {
  return run(str, code([37], 39));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([90], 39));
}
function bgRed(str) {
  return run(str, code([41], 49));
}
function bgGreen(str) {
  return run(str, code([42], 49));
}
var ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://deno.land/std@0.147.0/testing/_diff.ts
var REMOVED = 1;
var COMMON = 2;
var ADDED = 3;
function createCommon(A, B, reverse2) {
  const common2 = [];
  if (A.length === 0 || B.length === 0)
    return [];
  for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
    if (A[reverse2 ? A.length - i - 1 : i] === B[reverse2 ? B.length - i - 1 : i]) {
      common2.push(A[reverse2 ? A.length - i - 1 : i]);
    } else {
      return common2;
    }
  }
  return common2;
}
function diff(A, B) {
  const prefixCommon = createCommon(A, B);
  const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
  A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
  B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
  const swapped = B.length > A.length;
  [A, B] = swapped ? [B, A] : [A, B];
  const M = A.length;
  const N2 = B.length;
  if (!M && !N2 && !suffixCommon.length && !prefixCommon.length)
    return [];
  if (!N2) {
    return [
      ...prefixCommon.map((c) => ({ type: "common" /* common */, value: c })),
      ...A.map((a) => ({
        type: swapped ? "added" /* added */ : "removed" /* removed */,
        value: a
      })),
      ...suffixCommon.map((c) => ({ type: "common" /* common */, value: c }))
    ];
  }
  const offset = N2;
  const delta = M - N2;
  const size = M + N2 + 1;
  const fp = Array.from({ length: size }, () => ({ y: -1, id: -1 }));
  const routes = new Uint32Array((M * N2 + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p = -1;
  function backTrace(A2, B2, current, swapped2) {
    const M2 = A2.length;
    const N3 = B2.length;
    const result = [];
    let a = M2 - 1;
    let b = N3 - 1;
    let j = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while (true) {
      if (!j && !type)
        break;
      const prev = j;
      if (type === REMOVED) {
        result.unshift({
          type: swapped2 ? "removed" /* removed */ : "added" /* added */,
          value: B2[b]
        });
        b -= 1;
      } else if (type === ADDED) {
        result.unshift({
          type: swapped2 ? "added" /* added */ : "removed" /* removed */,
          value: A2[a]
        });
        a -= 1;
      } else {
        result.unshift({ type: "common" /* common */, value: A2[a] });
        a -= 1;
        b -= 1;
      }
      j = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k3, M2) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return { y: 0, id: 0 };
    }
    if (down && down.y === -1 || k3 === M2 || (slide && slide.y) > (down && down.y) + 1) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return { y: slide.y, id: ptr };
    } else {
      const prev = down.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return { y: down.y + 1, id: ptr };
    }
  }
  function snake(k3, slide, down, _offset, A2, B2) {
    const M2 = A2.length;
    const N3 = B2.length;
    if (k3 < -N3 || M2 < k3)
      return { y: -1, id: -1 };
    const fp2 = createFP(slide, down, k3, M2);
    while (fp2.y + k3 < M2 && fp2.y < N3 && A2[fp2.y + k3] === B2[fp2.y]) {
      const prev = fp2.id;
      ptr++;
      fp2.id = ptr;
      fp2.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp2;
  }
  while (fp[delta + offset].y < N2) {
    p = p + 1;
    for (let k3 = -p; k3 < delta; ++k3) {
      fp[k3 + offset] = snake(k3, fp[k3 - 1 + offset], fp[k3 + 1 + offset], offset, A, B);
    }
    for (let k3 = delta + p; k3 > delta; --k3) {
      fp[k3 + offset] = snake(k3, fp[k3 - 1 + offset], fp[k3 + 1 + offset], offset, A, B);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
  }
  return [
    ...prefixCommon.map((c) => ({ type: "common" /* common */, value: c })),
    ...backTrace(A, B, fp[delta + offset], swapped),
    ...suffixCommon.map((c) => ({ type: "common" /* common */, value: c }))
  ];
}
function diffstr(A, B) {
  function unescape2(string) {
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("	", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str) => str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      for (let i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token) => token);
    } else {
      const tokens = [], lines = string.split(/(\n|\r\n)/);
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      for (let i = 0; i < lines.length; i++) {
        if (i % 2) {
          tokens[tokens.length - 1] += lines[i];
        } else {
          tokens.push(lines[i]);
        }
      }
      return tokens;
    }
  }
  function createDetails(line, tokens) {
    return tokens.filter(({ type }) => type === line.type || type === "common" /* common */).map((result, i, t) => {
      if (result.type === "common" /* common */ && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
        result.type = t[i - 1].type;
      }
      return result;
    });
  }
  const diffResult = diff(tokenize(`${unescape2(A)}
`), tokenize(`${unescape2(B)}
`));
  const added = [], removed = [];
  for (const result of diffResult) {
    if (result.type === "added" /* added */) {
      added.push(result);
    }
    if (result.type === "removed" /* removed */) {
      removed.push(result);
    }
  }
  const aLines = added.length < removed.length ? added : removed;
  const bLines = aLines === removed ? added : removed;
  for (const a of aLines) {
    let tokens = [], b;
    while (bLines.length) {
      b = bLines.shift();
      tokens = diff(tokenize(a.value, { wordDiff: true }), tokenize(b?.value ?? "", { wordDiff: true }));
      if (tokens.some(({ type, value }) => type === "common" /* common */ && value.trim().length)) {
        break;
      }
    }
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}
function createColor(diffType, { background = false } = {}) {
  switch (diffType) {
    case "added" /* added */:
      return (s) => background ? bgGreen(white(s)) : green(bold(s));
    case "removed" /* removed */:
      return (s) => background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
function createSign(diffType) {
  switch (diffType) {
    case "added" /* added */:
      return "+   ";
    case "removed" /* removed */:
      return "-   ";
    default:
      return "    ";
  }
}
function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [], diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result) => {
    const c = createColor(result.type);
    const line = result.details?.map((detail) => detail.type !== "common" /* common */ ? createColor(detail.type, { background: true })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [diffMessages.join("")] : diffMessages);
  messages.push("");
  return messages;
}

// deno:https://deno.land/std@0.147.0/testing/_format.ts
function format(v) {
  const { Deno: Deno4 } = globalThis;
  return typeof Deno4?.inspect === "function" ? Deno4.inspect(v, {
    depth: Infinity,
    sorted: true,
    trailingComma: true,
    compact: false,
    iterableLimit: Infinity
  }) : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
}

// deno:https://deno.land/std@0.147.0/testing/asserts.ts
var CAN_NOT_DISPLAY = "[Cannot display]";
var AssertionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};
function isKeyedCollection(x) {
  return [Symbol.iterator, "size"].every((k3) => k3 in x);
}
function equal(c, d) {
  const seen = /* @__PURE__ */ new Map();
  return function compare9(a, b) {
    if (a && b && (a instanceof RegExp && b instanceof RegExp || a instanceof URL && b instanceof URL)) {
      return String(a) === String(b);
    }
    if (a instanceof Date && b instanceof Date) {
      const aTime = a.getTime();
      const bTime = b.getTime();
      if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
        return true;
      }
      return aTime === bTime;
    }
    if (typeof a === "number" && typeof b === "number") {
      return Number.isNaN(a) && Number.isNaN(b) || a === b;
    }
    if (Object.is(a, b)) {
      return true;
    }
    if (a && typeof a === "object" && b && typeof b === "object") {
      if (a && b && !constructorsEqual(a, b)) {
        return false;
      }
      if (a instanceof WeakMap || b instanceof WeakMap) {
        if (!(a instanceof WeakMap && b instanceof WeakMap))
          return false;
        throw new TypeError("cannot compare WeakMap instances");
      }
      if (a instanceof WeakSet || b instanceof WeakSet) {
        if (!(a instanceof WeakSet && b instanceof WeakSet))
          return false;
        throw new TypeError("cannot compare WeakSet instances");
      }
      if (seen.get(a) === b) {
        return true;
      }
      if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
        return false;
      }
      seen.set(a, b);
      if (isKeyedCollection(a) && isKeyedCollection(b)) {
        if (a.size !== b.size) {
          return false;
        }
        let unmatchedEntries = a.size;
        for (const [aKey, aValue] of a.entries()) {
          for (const [bKey, bValue] of b.entries()) {
            if (aKey === aValue && bKey === bValue && compare9(aKey, bKey) || compare9(aKey, bKey) && compare9(aValue, bValue)) {
              unmatchedEntries--;
              break;
            }
          }
        }
        return unmatchedEntries === 0;
      }
      const merged = { ...a, ...b };
      for (const key2 of [
        ...Object.getOwnPropertyNames(merged),
        ...Object.getOwnPropertySymbols(merged)
      ]) {
        if (!compare9(a && a[key2], b && b[key2])) {
          return false;
        }
        if (key2 in a && !(key2 in b) || key2 in b && !(key2 in a)) {
          return false;
        }
      }
      if (a instanceof WeakRef || b instanceof WeakRef) {
        if (!(a instanceof WeakRef && b instanceof WeakRef))
          return false;
        return compare9(a.deref(), b.deref());
      }
      return true;
    }
    return false;
  }(c, d);
}
function constructorsEqual(a, b) {
  return a.constructor === b.constructor || a.constructor === Object && !b.constructor || !a.constructor && b.constructor === Object;
}
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}
function assertEquals(actual, expected, msg) {
  if (equal(actual, expected)) {
    return;
  }
  let message = "";
  const actualString = format(actual);
  const expectedString = format(expected);
  try {
    const stringDiff = typeof actual === "string" && typeof expected === "string";
    const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
    const diffMsg = buildMessage(diffResult, { stringDiff }).join("\n");
    message = `Values are not equal:
${diffMsg}`;
  } catch {
    message = `
${red(CAN_NOT_DISPLAY)} + 

`;
  }
  if (msg) {
    message = msg;
  }
  throw new AssertionError(message);
}
function unreachable() {
  throw new AssertionError("unreachable");
}

// deno:https://deno.land/std@0.147.0/_util/assert.ts
var DenoStdInternalError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert2(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError(msg);
  }
}

// deno:https://deno.land/std@0.147.0/bytes/mod.ts
function indexOfNeedle(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s)
      continue;
    const pin = i;
    let matched = 1;
    let j = i;
    while (matched < needle.length) {
      j++;
      if (source[j] !== needle[j - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}

// deno:https://deno.land/std@0.147.0/io/buffer.ts
var MIN_READ = 32 * 1024;
var MAX_SIZE = 2 ** 32 - 2;
var CR = "\r".charCodeAt(0);
var LF = "\n".charCodeAt(0);

// deno:https://deno.land/std@0.147.0/streams/conversion.ts
var DEFAULT_BUFFER_SIZE = 32 * 1024;
async function writeAll(w, arr) {
  let nwritten = 0;
  while (nwritten < arr.length) {
    nwritten += await w.write(arr.subarray(nwritten));
  }
}

// deno:https://deno.land/std@0.147.0/node/_utils.ts
function notImplemented(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  throw new Error(message);
}
function warnNotImplemented(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  console.warn(message);
}
var _TextDecoder = TextDecoder;
var _TextEncoder = TextEncoder;
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function normalizeEncoding(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases(enc);
}
function slowCases(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal/util/types.ts
var types_exports2 = {};
__export(types_exports2, {
  isAnyArrayBuffer: () => isAnyArrayBuffer2,
  isArgumentsObject: () => isArgumentsObject2,
  isArrayBuffer: () => isArrayBuffer2,
  isArrayBufferView: () => isArrayBufferView,
  isAsyncFunction: () => isAsyncFunction2,
  isBigInt64Array: () => isBigInt64Array,
  isBigIntObject: () => isBigIntObject2,
  isBigUint64Array: () => isBigUint64Array,
  isBooleanObject: () => isBooleanObject2,
  isBoxedPrimitive: () => isBoxedPrimitive2,
  isCryptoKey: () => isCryptoKey,
  isDataView: () => isDataView2,
  isDate: () => isDate2,
  isFloat32Array: () => isFloat32Array,
  isFloat64Array: () => isFloat64Array,
  isGeneratorFunction: () => isGeneratorFunction2,
  isGeneratorObject: () => isGeneratorObject2,
  isInt16Array: () => isInt16Array,
  isInt32Array: () => isInt32Array,
  isInt8Array: () => isInt8Array,
  isKeyObject: () => isKeyObject,
  isMap: () => isMap2,
  isMapIterator: () => isMapIterator2,
  isModuleNamespaceObject: () => isModuleNamespaceObject2,
  isNativeError: () => isNativeError2,
  isNumberObject: () => isNumberObject2,
  isPromise: () => isPromise2,
  isRegExp: () => isRegExp2,
  isSet: () => isSet2,
  isSetIterator: () => isSetIterator2,
  isSharedArrayBuffer: () => isSharedArrayBuffer2,
  isStringObject: () => isStringObject2,
  isSymbolObject: () => isSymbolObject2,
  isTypedArray: () => isTypedArray,
  isUint16Array: () => isUint16Array,
  isUint32Array: () => isUint32Array,
  isUint8Array: () => isUint8Array,
  isUint8ClampedArray: () => isUint8ClampedArray,
  isWeakMap: () => isWeakMap2,
  isWeakSet: () => isWeakSet2
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/types.ts
var types_exports = {};
__export(types_exports, {
  default: () => types_default,
  isAnyArrayBuffer: () => isAnyArrayBuffer,
  isArgumentsObject: () => isArgumentsObject,
  isArrayBuffer: () => isArrayBuffer,
  isAsyncFunction: () => isAsyncFunction,
  isBigIntObject: () => isBigIntObject,
  isBooleanObject: () => isBooleanObject,
  isBoxedPrimitive: () => isBoxedPrimitive,
  isDataView: () => isDataView,
  isDate: () => isDate,
  isGeneratorFunction: () => isGeneratorFunction,
  isGeneratorObject: () => isGeneratorObject,
  isMap: () => isMap,
  isMapIterator: () => isMapIterator,
  isModuleNamespaceObject: () => isModuleNamespaceObject,
  isNativeError: () => isNativeError,
  isNumberObject: () => isNumberObject,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isSetIterator: () => isSetIterator,
  isSharedArrayBuffer: () => isSharedArrayBuffer,
  isStringObject: () => isStringObject,
  isSymbolObject: () => isSymbolObject,
  isWeakMap: () => isWeakMap,
  isWeakSet: () => isWeakSet
});
var _toString = Object.prototype.toString;
var _isObjectLike = (value) => value !== null && typeof value === "object";
var _isFunctionLike = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
  return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
  return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
var types_default = {
  isAsyncFunction,
  isGeneratorFunction,
  isAnyArrayBuffer,
  isArrayBuffer,
  isArgumentsObject,
  isBoxedPrimitive,
  isDataView,
  isMap,
  isMapIterator,
  isModuleNamespaceObject,
  isNativeError,
  isPromise,
  isSet,
  isSetIterator,
  isWeakMap,
  isWeakSet,
  isRegExp,
  isDate,
  isStringObject,
  isNumberObject,
  isBooleanObject,
  isBigIntObject
};

// deno:https://deno.land/std@0.147.0/node/internal/crypto/constants.ts
var kHandle = Symbol("kHandle");
var kKeyObject = Symbol("kKeyObject");

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_keys.ts
var kKeyType = Symbol("kKeyType");
function isKeyObject(obj2) {
  return obj2 != null && obj2[kKeyType] !== void 0;
}
function isCryptoKey(obj2) {
  return obj2 != null && obj2[kKeyObject] !== void 0;
}

// deno:https://deno.land/std@0.147.0/node/internal/util/types.ts
var _toString2 = Object.prototype.toString;
var _isObjectLike2 = (value) => value !== null && typeof value === "object";
function isArrayBufferView(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Int32Array]";
}
function isTypedArray(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike2(value) && reTypedTag.test(_toString2.call(value));
}
function isUint8Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint32Array]";
}
var {
  isDate: isDate2,
  isArgumentsObject: isArgumentsObject2,
  isBigIntObject: isBigIntObject2,
  isBooleanObject: isBooleanObject2,
  isNumberObject: isNumberObject2,
  isStringObject: isStringObject2,
  isSymbolObject: isSymbolObject2,
  isNativeError: isNativeError2,
  isRegExp: isRegExp2,
  isAsyncFunction: isAsyncFunction2,
  isGeneratorFunction: isGeneratorFunction2,
  isGeneratorObject: isGeneratorObject2,
  isPromise: isPromise2,
  isMap: isMap2,
  isSet: isSet2,
  isMapIterator: isMapIterator2,
  isSetIterator: isSetIterator2,
  isWeakMap: isWeakMap2,
  isWeakSet: isWeakSet2,
  isArrayBuffer: isArrayBuffer2,
  isDataView: isDataView2,
  isSharedArrayBuffer: isSharedArrayBuffer2,
  isModuleNamespaceObject: isModuleNamespaceObject2,
  isAnyArrayBuffer: isAnyArrayBuffer2,
  isBoxedPrimitive: isBoxedPrimitive2
} = types_exports;

// deno:https://deno.land/std@0.147.0/node/internal/error_codes.ts
var codes = {};

// deno:https://deno.land/std@0.147.0/node/internal/hide_stack_frames.ts
function hideStackFrames(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}

// deno:https://deno.land/std@0.147.0/node/internal/normalize_encoding.mjs
function normalizeEncoding2(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases2(enc);
}
function slowCases2(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal/validators.mjs
function isInt32(value) {
  return value === (value | 0);
}
function isUint32(value) {
  return value === value >>> 0;
}
var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
  if (!isArrayBufferView(buffer)) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
  }
});
var validateInteger = hideStackFrames((value, name, min4 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateObject = hideStackFrames((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt32 = hideStackFrames((value, name, min4 = -2147483648, max2 = 2147483647) => {
  if (!isInt32(value)) {
    if (typeof value !== "number") {
      throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
  if (value < min4 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateUint32 = hideStackFrames((value, name, positive) => {
  if (!isUint32(value)) {
    if (typeof value !== "number") {
      throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min4 = positive ? 1 : 0;
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
}
var validateOneOf = hideStackFrames((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v) => typeof v === "string" ? `'${v}'` : String(v)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback = hideStackFrames((callback) => {
  if (typeof callback !== "function") {
    throw new codes.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal = hideStackFrames((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction = hideStackFrames((value, name) => {
  if (typeof value !== "function") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
var validateArray = hideStackFrames((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/util.ts
var util_exports = {};
__export(util_exports, {
  ALL_PROPERTIES: () => ALL_PROPERTIES,
  ONLY_CONFIGURABLE: () => ONLY_CONFIGURABLE,
  ONLY_ENUMERABLE: () => ONLY_ENUMERABLE,
  ONLY_ENUM_WRITABLE: () => ONLY_ENUM_WRITABLE,
  ONLY_WRITABLE: () => ONLY_WRITABLE,
  SKIP_STRINGS: () => SKIP_STRINGS,
  SKIP_SYMBOLS: () => SKIP_SYMBOLS,
  getOwnNonIndexProperties: () => getOwnNonIndexProperties,
  guessHandleType: () => guessHandleType,
  isArrayIndex: () => isArrayIndex
});
function guessHandleType(_fd) {
  notImplemented("util.guessHandleType");
}
var ALL_PROPERTIES = 0;
var ONLY_WRITABLE = 1;
var ONLY_ENUMERABLE = 2;
var ONLY_CONFIGURABLE = 4;
var ONLY_ENUM_WRITABLE = 6;
var SKIP_STRINGS = 8;
var SKIP_SYMBOLS = 16;
var isNumericLookup = {};
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k3) => !isArrayIndex(k3));
  }
  if (filter === ALL_PROPERTIES) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & ONLY_WRITABLE && !desc.writable) {
      continue;
    }
    if (filter & ONLY_ENUMERABLE && !desc.enumerable) {
      continue;
    }
    if (filter & ONLY_CONFIGURABLE && !desc.configurable) {
      continue;
    }
    if (filter & SKIP_STRINGS && typeof key2 === "string") {
      continue;
    }
    if (filter & SKIP_SYMBOLS && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}

// deno:https://deno.land/std@0.147.0/node/internal/util/inspect.mjs
var kObjectType = 0;
var kArrayType = 1;
var kArrayExtrasType = 2;
var kMinLineLength = 16;
var kWeak = 0;
var kIterator = 1;
var kMapEntries = 2;
var kPending = 0;
var kRejected = 2;
var meta = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject = (v) => typeof v === "undefined" && v !== void 0;
var strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    maxStringLength: inspectDefaultOptions.maxStringLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue(ctx, value, 0);
}
var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
  get() {
    return inspectDefaultOptions;
  },
  set(options) {
    validateObject(options, "options");
    return Object.assign(inspectDefaultOptions, options);
  }
});
var defaultFG = 39;
var defaultBG = 49;
inspect.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  blink: [5, 25],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  doubleunderline: [21, 24],
  black: [30, defaultFG],
  red: [31, defaultFG],
  green: [32, defaultFG],
  yellow: [33, defaultFG],
  blue: [34, defaultFG],
  magenta: [35, defaultFG],
  cyan: [36, defaultFG],
  white: [37, defaultFG],
  bgBlack: [40, defaultBG],
  bgRed: [41, defaultBG],
  bgGreen: [42, defaultBG],
  bgYellow: [43, defaultBG],
  bgBlue: [44, defaultBG],
  bgMagenta: [45, defaultBG],
  bgCyan: [46, defaultBG],
  bgWhite: [47, defaultBG],
  framed: [51, 54],
  overlined: [53, 55],
  gray: [90, defaultFG],
  redBright: [91, defaultFG],
  greenBright: [92, defaultFG],
  yellowBright: [93, defaultFG],
  blueBright: [94, defaultFG],
  magentaBright: [95, defaultFG],
  cyanBright: [96, defaultFG],
  whiteBright: [97, defaultFG],
  bgGray: [100, defaultBG],
  bgRedBright: [101, defaultBG],
  bgGreenBright: [102, defaultBG],
  bgYellowBright: [103, defaultBG],
  bgBlueBright: [104, defaultBG],
  bgMagentaBright: [105, defaultBG],
  bgCyanBright: [106, defaultBG],
  bgWhiteBright: [107, defaultBG]
});
function defineColorAlias(target, alias) {
  Object.defineProperty(inspect.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn = (str) => meta[str.charCodeAt(0)];
function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style !== void 0) {
    const color = inspect.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor(str) {
  return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
    return formatPrimitive(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base3 = "";
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties(value, filter);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet2(value)) {
      const size = value.size;
      const prefix = getPrefix(constructor, tag2, "Set", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isMap2(value)) {
      const size = value.size;
      const prefix = getPrefix(constructor, tag2, "Map", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const bound = value;
      const fallback = "";
      if (constructor === null) {
      }
      const size = value.length;
      const prefix = getPrefix(constructor, tag2, fallback, `(${size})`);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray.bind(null, bound, size);
      extrasType = kArrayExtrasType;
    } else if (isMapIterator2(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Map", tag2);
      formatter = formatIterator.bind(null, braces);
    } else if (isSetIterator2(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Set", tag2);
      formatter = formatIterator.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ["{", "}"];
    if (constructor === "Object") {
      if (isArgumentsObject2(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base3 = getFunctionBase(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "special");
      }
    } else if (isRegExp2(value)) {
      base3 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix = getPrefix(constructor, tag2, "RegExp");
      if (prefix !== "RegExp ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base3, "regexp");
      }
    } else if (isDate2(value)) {
      base3 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix = getPrefix(constructor, tag2, "Date");
      if (prefix !== "Date ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "date");
      }
    } else if (value instanceof Error) {
      base3 = formatError(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else if (isAnyArrayBuffer2(value)) {
      const arrayType = isArrayBuffer2(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix = getPrefix(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      Array.prototype.unshift.call(keys, "byteLength");
    } else if (isDataView2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "Promise")}{`;
      formatter = formatPromise;
    } else if (isWeakSet2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
    } else if (isModuleNamespaceObject2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject.bind(null, keys);
    } else if (isBoxedPrimitive2(value)) {
      base3 = getBoxedBase(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base3 = base3 === "" ? reference : `${reference} ${base3}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString(ctx, output, base3, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach.call(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push.call(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty(ctx, obj2, recurseTimes, key2, kObjectType, desc, main);
      if (ctx.colors) {
        Array.prototype.push.call(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push.call(output, value);
      }
    }
    Array.prototype.pop.call(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects.has(descriptor.value.name))) {
        addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
  return [];
}
function isInstanceof(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix(constructor, tag2, fallback);
}
function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v of value) {
    Array.prototype.push.call(output, formatValue(ctx, v, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k3, 1: v } of value) {
    output.push(`${formatValue(ctx, k3, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue(ctx, value[key2], recurseTimes, true);
      Array.prototype.push.call(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [`[${tag2}] {`, "}"];
}
function formatIterator(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }
  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}
function getFunctionBase(value, constructor, tag2) {
  const stringified = Function.prototype.toString.call(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice5 = stringified.slice(5, -1);
    const bracketIndex = slice5.indexOf("{");
    if (bracketIndex !== -1 && (!slice5.slice(0, bracketIndex).includes("(") || classRegExp.test(slice5.replace(stripCommentsRegExp)))) {
      return getClassBase(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction2(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction2(value)) {
    type = `Async${type}`;
  }
  let base3 = `[${type}`;
  if (constructor === null) {
    base3 += " (null prototype)";
  }
  if (value.name === "") {
    base3 += " (anonymous)";
  } else {
    base3 += `: ${value.name}`;
  }
  base3 += "]";
  if (constructor !== type && constructor !== null) {
    base3 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  return base3;
}
function formatError(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name2 of ["name", "message", "stack"]) {
      const index = keys.indexOf(name2);
      if (index !== -1 && stack.includes(err[name2])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos2 = 0;
      while (nodeModule = nodeModulesRegExp.exec(line)) {
        newStack += line.slice(pos2, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos2 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos2 === 0 ? line : line.slice(pos2);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice;
function formatArrayBuffer(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [ctx.stylize("(detached)", "special")];
  }
  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [`${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`];
}
function formatNumber(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === kPending) {
    output = [ctx.stylize("<pending>", "special")];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection(ctx) {
  return [ctx.stylize("<items unknown>", "special")];
}
function formatWeakSet(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);
}
function formatWeakMap(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);
}
function formatProperty(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2], enumerable: true };
  if (desc.value !== void 0) {
    const diff3 = ctx.compact !== true || type !== kObjectType ? 2 : 3;
    ctx.indentationLvl += diff3;
    str = formatValue(ctx, desc.value, recurseTimes);
    if (diff3 === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff3;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === kArrayType) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp = key2.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp = key2.replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${tmp}]`;
  } else if (keyStrRegExp.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
  return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base3) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base3 === "" || !base3.includes("\n");
}
function formatBigInt(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
    } catch (_err) {
      const tmp = { [keys[i]]: "" };
      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty(ctx, value, recurseTimes, key2, kArrayType));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? "s" : "";
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject2(value)) {
    type = "Number";
  } else if (isStringObject2(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject2(value)) {
    type = "Boolean";
  } else if (isBigIntObject2(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base3 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base3 += " (null prototype)";
    } else {
      base3 += ` (${constructor})`;
    }
  }
  base3 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base3 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base3;
  }
  return ctx.stylize(base3, type.toLowerCase());
}
function getClassBase(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base3 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base3 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base3 += ` extends ${superName}`;
    }
  } else {
    base3 += " extends [null prototype]";
  }
  return `[${base3}]`;
}
function reduceToSingleString(ctx, output, base3, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base3.length + 10;
        if (isBelowBreakLength(ctx, output, start, base3)) {
          return `${base3 ? `${base3} ` : ""}${braces[0]} ${join(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation2 = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base3 ? `${base3} ` : ""}${braces[0]}${indentation2}  ${join(output, `,${indentation2}  `)}${indentation2}${braces[1]}`;
  }
  if (isBelowBreakLength(ctx, output, 0, base3)) {
    return `${braces[0]}${base3 ? ` ${base3}` : ""} ${join(output, ", ")} ` + braces[1];
  }
  const indentation = " ".repeat(ctx.indentationLvl);
  const ln = base3 === "" && braces[0].length === 1 ? " " : `${base3 ? ` ${base3}` : ""}
${indentation}  `;
  return `${braces[0]}${ln}${join(output, `,
${indentation}  `)} ${braces[1]}`;
}
function join(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + separatorSpace;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i2 = 0; i2 < columns; i2++) {
      let lineMaxLength = 0;
      for (let j = i2; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i2] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i2 = 0; i2 < output.length; i2++) {
        if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i2 = 0; i2 < outputLength; i2 += columns) {
      const max2 = Math.min(i2 + columns, outputLength);
      let str = "";
      let j = i2;
      for (; j < max2 - 1; j++) {
        const padding = maxLineLength[j - i2] + output[j].length - dataLen[j];
        str += `${output[j]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding = maxLineLength[j - i2] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, " ");
      } else {
        str += output[j];
      }
      Array.prototype.push.call(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push.call(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [
        formatValue(ctx, entries[pos], recurseTimes),
        formatValue(ctx, entries[pos + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString(ctx, res, "", ["[", "]"], kArrayExtrasType, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters(str);
  }
  str = str.normalize("NFC");
  for (const char of str[Symbol.iterator]()) {
    const code2 = char.codePointAt(0);
    if (isFullWidthCodePoint(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function hasBuiltInToString(value) {
  const proxyTarget = void 0;
  if (proxyTarget !== void 0) {
    value = proxyTarget;
  }
  if (typeof value.toString !== "function") {
    return true;
  }
  if (Object.prototype.hasOwnProperty.call(value, "toString")) {
    return false;
  }
  let pointer = value;
  do {
    pointer = Object.getPrototypeOf(pointer);
  } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
  const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
  return descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name);
}
var firstErrorLine = (error3) => error3.message.split("\n", 1)[0];
var CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (circularError) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
      }
    }
    if (err.name === "TypeError" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return "[Circular]";
    }
    throw err;
  }
}
function format2(...args) {
  return formatWithOptionsInternal(void 0, args);
}
function formatWithOptions(inspectOptions, ...args) {
  if (typeof inspectOptions !== "object" || inspectOptions === null) {
    throw new codes.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
  }
  return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
  return formatNumber(stylizeNoColor, number, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
  return formatBigInt(stylizeNoColor, bigint, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
  const first = args[0];
  let a = 0;
  let str = "";
  let join12 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              const tempArg = args[++a];
              if (typeof tempArg === "number") {
                tempStr = formatNumberNoColor(tempArg, inspectOptions);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
              } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            case 106:
              tempStr = tryStringify(args[++a]);
              break;
            case 100:
              const tempNum = args[++a];
              if (typeof tempNum === "bigint") {
                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
              }
              break;
            case 79:
              tempStr = inspect(args[++a], inspectOptions);
              break;
            case 111:
              tempStr = inspect(args[++a], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105:
              const tempInteger = args[++a];
              if (typeof tempInteger === "bigint") {
                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
              }
              break;
            case 102:
              const tempFloat = args[++a];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
              }
              break;
            case 99:
              a += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join12 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join12;
    str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
    join12 = " ";
    a++;
  }
  return str;
}
function stripVTControlCharacters(str) {
  validateString(str, "str");
  return str.replace(ansi, "");
}

// deno:https://deno.land/std@0.147.0/node/internal/util.mjs
var customInspectSymbol2 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
  let called = false;
  return function(...args) {
    if (called)
      return;
    called = true;
    Reflect.apply(callback, this, args);
  };
}
function createDeferredPromise() {
  let resolve7;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve7 = res;
    reject = rej;
  });
  return { promise, resolve: resolve7, reject };
}
var codesWarned = /* @__PURE__ */ new Set();
function deprecate(fn, msg, code2) {
  if (code2 !== void 0) {
    validateString(code2, "code");
  }
  let warned = false;
  function deprecated(...args) {
    if (!warned) {
      warned = true;
      if (code2 !== void 0) {
        if (!codesWarned.has(code2)) {
          process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
          codesWarned.add(code2);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args, new.target);
    }
    return Reflect.apply(fn, this, args);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
  validateFunction(original, "original");
  if (original[kCustomPromisifiedSymbol]) {
    const fn2 = original[kCustomPromisifiedSymbol];
    validateFunction(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol];
  function fn(...args) {
    return new Promise((resolve7, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve7(obj2);
        } else {
          resolve7(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;

// deno:https://deno.land/std@0.147.0/node/_core.ts
var core;
if (Deno?.core) {
  core = Deno.core;
} else {
  core = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}

// deno:https://deno.land/std@0.147.0/node/_process/exiting.ts
var _exiting = false;

// deno:https://deno.land/std@0.147.0/node/internal/fixed_queue.ts
var kSize = 2048;
var kMask = kSize - 1;
var FixedCircularBuffer = class {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask;
    return nextItem;
  }
};
var FixedQueue = class {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};

// deno:https://deno.land/std@0.147.0/node/_next_tick.ts
var queue = new FixedQueue();
var _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
  let runNextTicks = function() {
    if (!core.hasTickScheduled()) {
      core.runMicrotasks();
    }
    if (!core.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections();
    return true;
  }, processTicksAndRejections = function() {
    let tock;
    do {
      while (tock = queue.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core.runMicrotasks();
    } while (!queue.isEmpty());
    core.setHasTickScheduled(false);
  }, __nextTickNative = function(callback, ...args) {
    validateCallback(callback);
    if (_exiting) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [args[0]];
        break;
      case 2:
        args_ = [args[0], args[1]];
        break;
      case 3:
        args_ = [args[0], args[1], args[2]];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue.isEmpty()) {
      core.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue.push(tickObject);
  };
  core.setNextTickCallback(processTicksAndRejections);
  core.setMacrotaskCallback(runNextTicks);
  _nextTick = __nextTickNative;
} else {
  let __nextTickQueueMicrotask = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  _nextTick = __nextTickQueueMicrotask;
}
function nextTick2(callback, ...args) {
  _nextTick(callback, ...args);
}

// deno:https://deno.land/std@0.147.0/node/_util/_util_callbackify.ts
var NodeFalsyValueRejectionError = class extends Error {
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.code = "ERR_FALSY_VALUE_REJECTION";
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError = class extends TypeError {
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function callbackify(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError('"original"');
  }
  const callbackified = function(...args) {
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError("last");
    }
    const cb = (...args2) => {
      maybeCb.apply(this, args2);
    };
    original.apply(this, args).then((ret) => {
      nextTick2(cb.bind(this, null, ret));
    }, (rej) => {
      rej = rej || new NodeFalsyValueRejectionError(rej);
      nextTick2(cb.bind(this, rej));
    });
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}

// deno:https://deno.land/std@0.147.0/fmt/printf.ts
var Flags = class {
  constructor() {
    this.width = -1;
    this.precision = -1;
  }
};
var min = Math.min;
var UNICODE_REPLACEMENT_CHARACTER = "\uFFFD";
var DEFAULT_PRECISION = 6;
var FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var Printf = class {
  constructor(format11, ...args) {
    this.state = 0 /* PASSTHROUGH */;
    this.verb = "";
    this.buf = "";
    this.argNum = 0;
    this.flags = new Flags();
    this.format = format11;
    this.args = args;
    this.haveSeen = Array.from({ length: args.length });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c = this.format[this.i];
      switch (this.state) {
        case 0 /* PASSTHROUGH */:
          if (c === "%") {
            this.state = 1 /* PERCENT */;
          } else {
            this.buf += c;
          }
          break;
        case 1 /* PERCENT */:
          if (c === "%") {
            this.buf += c;
            this.state = 0 /* PASSTHROUGH */;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c = this.format[this.i];
      switch (this.state) {
        case 1 /* PERCENT */:
          switch (c) {
            case "[":
              this.handlePositional();
              this.state = 2 /* POSITIONAL */;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c && c <= "9" || c === "." || c === "*") {
                if (c === ".") {
                  this.flags.precision = 0;
                  this.state = 3 /* PRECISION */;
                  this.i++;
                } else {
                  this.state = 4 /* WIDTH */;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case 2 /* POSITIONAL */:
          if (c === "*") {
            const worp = this.flags.precision === -1 ? 0 /* WIDTH */ : 1 /* PRECISION */;
            this.handleWidthOrPrecisionRef(worp);
            this.state = 1 /* PERCENT */;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case 0 /* WIDTH */:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === 0 /* WIDTH */ ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c = fmt[this.i];
      switch (this.state) {
        case 4 /* WIDTH */:
          switch (c) {
            case ".":
              this.flags.precision = 0;
              this.state = 3 /* PRECISION */;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(0 /* WIDTH */);
              break;
            default: {
              const val = parseInt(c);
              if (isNaN(val)) {
                this.i--;
                this.state = 1 /* PERCENT */;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case 3 /* PRECISION */: {
          if (c === "*") {
            this.handleWidthOrPrecisionRef(1 /* PRECISION */);
            break;
          }
          const val = parseInt(c);
          if (isNaN(val)) {
            this.i--;
            this.state = 1 /* PERCENT */;
            return;
          }
          flags.precision *= 10;
          flags.precision += val;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format11 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format11[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format11[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = 0 /* PASSTHROUGH */;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s.padEnd(this.flags.width, padding);
    }
    return s.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign3;
    if (neg3) {
      sign3 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign3 = this.flags.plus ? "+" : " ";
    } else {
      sign3 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign3 + nStr;
    }
    const pad3 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign3.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad3);
    } else {
      nStr = nStr.padStart(len, pad3);
    }
    if (zero) {
      nStr = sign3 + nStr;
    }
    return nStr;
  }
  fmtNumber(n, radix, upcase = false) {
    let num = Math.abs(n).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n < 0);
  }
  fmtNumberCodePoint(n) {
    let s = "";
    try {
      s = String.fromCodePoint(n);
    } catch {
      s = UNICODE_REPLACEMENT_CHARACTER;
    }
    return this.pad(s);
  }
  fmtFloatSpecial(n) {
    if (isNaN(n)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [fractional, round];
  }
  fmtFloatE(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    const m = n.toExponential().match(FLOAT_REGEXP);
    if (!m) {
      throw Error("can't happen, bug");
    }
    let fractional = m[3 /* fractional */];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m[5 /* exponent */];
    let esign = m[4 /* esign */];
    let mantissa = parseInt(m[2 /* mantissa */]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r = parseInt(esign + e) + 1;
        e = r.toString();
        esign = r < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n < 0);
  }
  fmtFloatF(n) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    function expandNumber(n2) {
      if (Number.isSafeInteger(n2)) {
        return n2.toString() + ".";
      }
      const t = n2.toExponential().split("e");
      let m = t[0].replace(".", "");
      const e = parseInt(t[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m;
      } else {
        const splIdx = e + 1;
        while (m.length < splIdx) {
          m += "0";
        }
        return m.substr(0, splIdx) + "." + m.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n < 0);
  }
  fmtFloatG(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    let P = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    P = P === 0 ? 1 : P;
    const m = n.toExponential().match(FLOAT_REGEXP);
    if (!m) {
      throw Error("can't happen");
    }
    const X2 = parseInt(m[5 /* exponent */]) * (m[4 /* esign */] === "-" ? -1 : 1);
    let nStr = "";
    if (P > X2 && X2 >= -4) {
      this.flags.precision = P - (X2 + 1);
      nStr = this.fmtFloatF(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P - 1;
      nStr = this.fmtFloatE(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s) {
    if (this.flags.precision !== -1) {
      s = s.substr(0, this.flags.precision);
    }
    return this.pad(s);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c = (val.charCodeAt(i) & 255).toString(16);
          hex += c.length === 1 ? `0${c}` : c;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? { depth: this.flags.precision } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p = this.flags.precision;
      return p === -1 ? val.toString() : val.toString().substr(0, p);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf(format11, ...args) {
  const printf = new Printf(format11, ...args);
  return printf.doPrintf();
}

// deno:https://deno.land/std@0.147.0/node/internal/util/debuglog.ts
var debugImpls;
var testEnabled;
function initializeDebugEnv(debugEnv3) {
  debugImpls = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled = () => false;
  }
}
function emitWarningIfNeeded(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop = () => {
};
function debuglogImpl(enabled2, set) {
  if (debugImpls[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded(set);
      debugImpls[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect(arg)).join(" ");
        console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls[set] = noop;
    }
  }
  return debugImpls[set];
}
function debuglog(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv;
try {
  debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error3) {
  if (error3 instanceof Deno.errors.PermissionDenied) {
    debugEnv = "";
  } else {
    throw error3;
  }
}
initializeDebugEnv(debugEnv);

// deno:https://deno.land/std@0.147.0/node/internal_binding/uv.ts
var uv_exports = {};
__export(uv_exports, {
  UV_EAI_MEMORY: () => UV_EAI_MEMORY,
  UV_EBADF: () => UV_EBADF,
  UV_EEXIST: () => UV_EEXIST,
  UV_EINVAL: () => UV_EINVAL,
  UV_ENOENT: () => UV_ENOENT,
  UV_ENOTSOCK: () => UV_ENOTSOCK,
  UV_UNKNOWN: () => UV_UNKNOWN,
  codeMap: () => codeMap,
  errorMap: () => errorMap,
  mapSysErrnoToUvErrno: () => mapSysErrnoToUvErrno
});

// deno:https://deno.land/std@0.147.0/_util/os.ts
var osType = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";
var isLinux = osType === "linux";

// deno:https://deno.land/std@0.147.0/node/internal_binding/_winerror.ts
var ERROR_INVALID_FUNCTION = 1;
var ERROR_FILE_NOT_FOUND = 2;
var ERROR_PATH_NOT_FOUND = 3;
var ERROR_TOO_MANY_OPEN_FILES = 4;
var ERROR_ACCESS_DENIED = 5;
var ERROR_INVALID_HANDLE = 6;
var ERROR_NOT_ENOUGH_MEMORY = 8;
var ERROR_INVALID_DATA = 13;
var ERROR_OUTOFMEMORY = 14;
var ERROR_INVALID_DRIVE = 15;
var ERROR_NOT_SAME_DEVICE = 17;
var ERROR_WRITE_PROTECT = 19;
var ERROR_CRC = 23;
var ERROR_GEN_FAILURE = 31;
var ERROR_SHARING_VIOLATION = 32;
var ERROR_LOCK_VIOLATION = 33;
var ERROR_HANDLE_DISK_FULL = 39;
var ERROR_NOT_SUPPORTED = 50;
var ERROR_NETNAME_DELETED = 64;
var ERROR_FILE_EXISTS = 80;
var ERROR_CANNOT_MAKE = 82;
var ERROR_INVALID_PARAMETER = 87;
var ERROR_BROKEN_PIPE = 109;
var ERROR_OPEN_FAILED = 110;
var ERROR_BUFFER_OVERFLOW = 111;
var ERROR_DISK_FULL = 112;
var ERROR_SEM_TIMEOUT = 121;
var ERROR_INSUFFICIENT_BUFFER = 122;
var ERROR_INVALID_NAME = 123;
var ERROR_MOD_NOT_FOUND = 126;
var ERROR_DIR_NOT_EMPTY = 145;
var ERROR_SIGNAL_REFUSED = 156;
var ERROR_BAD_PATHNAME = 161;
var ERROR_ALREADY_EXISTS = 183;
var ERROR_ENVVAR_NOT_FOUND = 203;
var ERROR_NO_SIGNAL_SENT = 205;
var ERROR_FILENAME_EXCED_RANGE = 206;
var ERROR_META_EXPANSION_TOO_LONG = 208;
var ERROR_BAD_PIPE = 230;
var ERROR_PIPE_BUSY = 231;
var ERROR_NO_DATA = 232;
var ERROR_PIPE_NOT_CONNECTED = 233;
var ERROR_DIRECTORY = 267;
var ERROR_EA_TABLE_FULL = 277;
var ERROR_OPERATION_ABORTED = 995;
var ERROR_NOACCESS = 998;
var ERROR_INVALID_FLAGS = 1004;
var ERROR_END_OF_MEDIA = 1100;
var ERROR_FILEMARK_DETECTED = 1101;
var ERROR_BEGINNING_OF_MEDIA = 1102;
var ERROR_SETMARK_DETECTED = 1103;
var ERROR_NO_DATA_DETECTED = 1104;
var ERROR_INVALID_BLOCK_LENGTH = 1106;
var ERROR_BUS_RESET = 1111;
var ERROR_NO_UNICODE_TRANSLATION = 1113;
var ERROR_IO_DEVICE = 1117;
var ERROR_EOM_OVERFLOW = 1129;
var ERROR_DEVICE_REQUIRES_CLEANING = 1165;
var ERROR_DEVICE_DOOR_OPEN = 1166;
var ERROR_CONNECTION_REFUSED = 1225;
var ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227;
var ERROR_NETWORK_UNREACHABLE = 1231;
var ERROR_HOST_UNREACHABLE = 1232;
var ERROR_CONNECTION_ABORTED = 1236;
var ERROR_PRIVILEGE_NOT_HELD = 1314;
var ERROR_DISK_CORRUPT = 1393;
var ERROR_CANT_ACCESS_FILE = 1920;
var ERROR_CANT_RESOLVE_FILENAME = 1921;
var ERROR_NOT_CONNECTED = 2250;
var ERROR_INVALID_REPARSE_DATA = 4392;
var WSAEINTR = 10004;
var WSAEACCES = 10013;
var WSAEFAULT = 10014;
var WSAEINVAL = 10022;
var WSAEMFILE = 10024;
var WSAEWOULDBLOCK = 10035;
var WSAEALREADY = 10037;
var WSAENOTSOCK = 10038;
var WSAEMSGSIZE = 10040;
var WSAEPROTONOSUPPORT = 10043;
var WSAESOCKTNOSUPPORT = 10044;
var WSAEPFNOSUPPORT = 10046;
var WSAEAFNOSUPPORT = 10047;
var WSAEADDRINUSE = 10048;
var WSAEADDRNOTAVAIL = 10049;
var WSAENETUNREACH = 10051;
var WSAECONNABORTED = 10053;
var WSAECONNRESET = 10054;
var WSAENOBUFS = 10055;
var WSAEISCONN = 10056;
var WSAENOTCONN = 10057;
var WSAESHUTDOWN = 10058;
var WSAETIMEDOUT = 10060;
var WSAECONNREFUSED = 10061;
var WSAEHOSTUNREACH = 10065;
var WSAHOST_NOT_FOUND = 11001;
var WSANO_DATA = 11004;

// deno:https://deno.land/std@0.147.0/node/internal_binding/_libuv_winerror.ts
function uvTranslateSysError(sysErrno) {
  switch (sysErrno) {
    case ERROR_ACCESS_DENIED:
      return "EACCES";
    case ERROR_NOACCESS:
      return "EACCES";
    case WSAEACCES:
      return "EACCES";
    case ERROR_CANT_ACCESS_FILE:
      return "EACCES";
    case ERROR_ADDRESS_ALREADY_ASSOCIATED:
      return "EADDRINUSE";
    case WSAEADDRINUSE:
      return "EADDRINUSE";
    case WSAEADDRNOTAVAIL:
      return "EADDRNOTAVAIL";
    case WSAEAFNOSUPPORT:
      return "EAFNOSUPPORT";
    case WSAEWOULDBLOCK:
      return "EAGAIN";
    case WSAEALREADY:
      return "EALREADY";
    case ERROR_INVALID_FLAGS:
      return "EBADF";
    case ERROR_INVALID_HANDLE:
      return "EBADF";
    case ERROR_LOCK_VIOLATION:
      return "EBUSY";
    case ERROR_PIPE_BUSY:
      return "EBUSY";
    case ERROR_SHARING_VIOLATION:
      return "EBUSY";
    case ERROR_OPERATION_ABORTED:
      return "ECANCELED";
    case WSAEINTR:
      return "ECANCELED";
    case ERROR_NO_UNICODE_TRANSLATION:
      return "ECHARSET";
    case ERROR_CONNECTION_ABORTED:
      return "ECONNABORTED";
    case WSAECONNABORTED:
      return "ECONNABORTED";
    case ERROR_CONNECTION_REFUSED:
      return "ECONNREFUSED";
    case WSAECONNREFUSED:
      return "ECONNREFUSED";
    case ERROR_NETNAME_DELETED:
      return "ECONNRESET";
    case WSAECONNRESET:
      return "ECONNRESET";
    case ERROR_ALREADY_EXISTS:
      return "EEXIST";
    case ERROR_FILE_EXISTS:
      return "EEXIST";
    case ERROR_BUFFER_OVERFLOW:
      return "EFAULT";
    case WSAEFAULT:
      return "EFAULT";
    case ERROR_HOST_UNREACHABLE:
      return "EHOSTUNREACH";
    case WSAEHOSTUNREACH:
      return "EHOSTUNREACH";
    case ERROR_INSUFFICIENT_BUFFER:
      return "EINVAL";
    case ERROR_INVALID_DATA:
      return "EINVAL";
    case ERROR_INVALID_NAME:
      return "EINVAL";
    case ERROR_INVALID_PARAMETER:
      return "EINVAL";
    case WSAEINVAL:
      return "EINVAL";
    case WSAEPFNOSUPPORT:
      return "EINVAL";
    case ERROR_BEGINNING_OF_MEDIA:
      return "EIO";
    case ERROR_BUS_RESET:
      return "EIO";
    case ERROR_CRC:
      return "EIO";
    case ERROR_DEVICE_DOOR_OPEN:
      return "EIO";
    case ERROR_DEVICE_REQUIRES_CLEANING:
      return "EIO";
    case ERROR_DISK_CORRUPT:
      return "EIO";
    case ERROR_EOM_OVERFLOW:
      return "EIO";
    case ERROR_FILEMARK_DETECTED:
      return "EIO";
    case ERROR_GEN_FAILURE:
      return "EIO";
    case ERROR_INVALID_BLOCK_LENGTH:
      return "EIO";
    case ERROR_IO_DEVICE:
      return "EIO";
    case ERROR_NO_DATA_DETECTED:
      return "EIO";
    case ERROR_NO_SIGNAL_SENT:
      return "EIO";
    case ERROR_OPEN_FAILED:
      return "EIO";
    case ERROR_SETMARK_DETECTED:
      return "EIO";
    case ERROR_SIGNAL_REFUSED:
      return "EIO";
    case WSAEISCONN:
      return "EISCONN";
    case ERROR_CANT_RESOLVE_FILENAME:
      return "ELOOP";
    case ERROR_TOO_MANY_OPEN_FILES:
      return "EMFILE";
    case WSAEMFILE:
      return "EMFILE";
    case WSAEMSGSIZE:
      return "EMSGSIZE";
    case ERROR_FILENAME_EXCED_RANGE:
      return "ENAMETOOLONG";
    case ERROR_NETWORK_UNREACHABLE:
      return "ENETUNREACH";
    case WSAENETUNREACH:
      return "ENETUNREACH";
    case WSAENOBUFS:
      return "ENOBUFS";
    case ERROR_BAD_PATHNAME:
      return "ENOENT";
    case ERROR_DIRECTORY:
      return "ENOTDIR";
    case ERROR_ENVVAR_NOT_FOUND:
      return "ENOENT";
    case ERROR_FILE_NOT_FOUND:
      return "ENOENT";
    case ERROR_INVALID_DRIVE:
      return "ENOENT";
    case ERROR_INVALID_REPARSE_DATA:
      return "ENOENT";
    case ERROR_MOD_NOT_FOUND:
      return "ENOENT";
    case ERROR_PATH_NOT_FOUND:
      return "ENOENT";
    case WSAHOST_NOT_FOUND:
      return "ENOENT";
    case WSANO_DATA:
      return "ENOENT";
    case ERROR_NOT_ENOUGH_MEMORY:
      return "ENOMEM";
    case ERROR_OUTOFMEMORY:
      return "ENOMEM";
    case ERROR_CANNOT_MAKE:
      return "ENOSPC";
    case ERROR_DISK_FULL:
      return "ENOSPC";
    case ERROR_EA_TABLE_FULL:
      return "ENOSPC";
    case ERROR_END_OF_MEDIA:
      return "ENOSPC";
    case ERROR_HANDLE_DISK_FULL:
      return "ENOSPC";
    case ERROR_NOT_CONNECTED:
      return "ENOTCONN";
    case WSAENOTCONN:
      return "ENOTCONN";
    case ERROR_DIR_NOT_EMPTY:
      return "ENOTEMPTY";
    case WSAENOTSOCK:
      return "ENOTSOCK";
    case ERROR_NOT_SUPPORTED:
      return "ENOTSUP";
    case ERROR_BROKEN_PIPE:
      return "EOF";
    case ERROR_PRIVILEGE_NOT_HELD:
      return "EPERM";
    case ERROR_BAD_PIPE:
      return "EPIPE";
    case ERROR_NO_DATA:
      return "EPIPE";
    case ERROR_PIPE_NOT_CONNECTED:
      return "EPIPE";
    case WSAESHUTDOWN:
      return "EPIPE";
    case WSAEPROTONOSUPPORT:
      return "EPROTONOSUPPORT";
    case ERROR_WRITE_PROTECT:
      return "EROFS";
    case ERROR_SEM_TIMEOUT:
      return "ETIMEDOUT";
    case WSAETIMEDOUT:
      return "ETIMEDOUT";
    case ERROR_NOT_SAME_DEVICE:
      return "EXDEV";
    case ERROR_INVALID_FUNCTION:
      return "EISDIR";
    case ERROR_META_EXPANSION_TOO_LONG:
      return "E2BIG";
    case WSAESOCKTNOSUPPORT:
      return "ESOCKTNOSUPPORT";
    default:
      return "UNKNOWN";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/constants.ts
var constants_exports = {};
__export(constants_exports, {
  crypto: () => crypto,
  fs: () => fs,
  os: () => os,
  trace: () => trace,
  zlib: () => zlib
});
var os = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
var fs = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};
var crypto = {
  OPENSSL_VERSION_NUMBER: 269488319,
  SSL_OP_ALL: 2147485780,
  SSL_OP_ALLOW_NO_DHE_KEX: 1024,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
  SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
  SSL_OP_CISCO_ANYCONNECT: 32768,
  SSL_OP_COOKIE_EXCHANGE: 8192,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
  SSL_OP_EPHEMERAL_RSA: 0,
  SSL_OP_LEGACY_SERVER_CONNECT: 4,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
  SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
  SSL_OP_NETSCAPE_CA_DN_BUG: 0,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NO_COMPRESSION: 131072,
  SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
  SSL_OP_NO_QUERY_MTU: 4096,
  SSL_OP_NO_RENEGOTIATION: 1073741824,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
  SSL_OP_NO_SSLv2: 0,
  SSL_OP_NO_SSLv3: 33554432,
  SSL_OP_NO_TICKET: 16384,
  SSL_OP_NO_TLSv1: 67108864,
  SSL_OP_NO_TLSv1_1: 268435456,
  SSL_OP_NO_TLSv1_2: 134217728,
  SSL_OP_NO_TLSv1_3: 536870912,
  SSL_OP_PKCS1_CHECK_1: 0,
  SSL_OP_PKCS1_CHECK_2: 0,
  SSL_OP_PRIORITIZE_CHACHA: 2097152,
  SSL_OP_SINGLE_DH_USE: 0,
  SSL_OP_SINGLE_ECDH_USE: 0,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
  SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
  SSL_OP_TLS_D5_BUG: 0,
  SSL_OP_TLS_ROLLBACK_BUG: 8388608,
  ENGINE_METHOD_RSA: 1,
  ENGINE_METHOD_DSA: 2,
  ENGINE_METHOD_DH: 4,
  ENGINE_METHOD_RAND: 8,
  ENGINE_METHOD_EC: 2048,
  ENGINE_METHOD_CIPHERS: 64,
  ENGINE_METHOD_DIGESTS: 128,
  ENGINE_METHOD_PKEY_METHS: 512,
  ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
  ENGINE_METHOD_ALL: 65535,
  ENGINE_METHOD_NONE: 0,
  DH_CHECK_P_NOT_SAFE_PRIME: 2,
  DH_CHECK_P_NOT_PRIME: 1,
  DH_UNABLE_TO_CHECK_GENERATOR: 4,
  DH_NOT_SUITABLE_GENERATOR: 8,
  ALPN_ENABLED: 1,
  RSA_PKCS1_PADDING: 1,
  RSA_SSLV23_PADDING: 2,
  RSA_NO_PADDING: 3,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_X931_PADDING: 5,
  RSA_PKCS1_PSS_PADDING: 6,
  RSA_PSS_SALTLEN_DIGEST: -1,
  RSA_PSS_SALTLEN_MAX_SIGN: -2,
  RSA_PSS_SALTLEN_AUTO: -2,
  defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
  TLS1_VERSION: 769,
  TLS1_1_VERSION: 770,
  TLS1_2_VERSION: 771,
  TLS1_3_VERSION: 772,
  POINT_CONVERSION_COMPRESSED: 2,
  POINT_CONVERSION_UNCOMPRESSED: 4,
  POINT_CONVERSION_HYBRID: 6
};
var zlib = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
var trace = {
  TRACE_EVENT_PHASE_BEGIN: 66,
  TRACE_EVENT_PHASE_END: 69,
  TRACE_EVENT_PHASE_COMPLETE: 88,
  TRACE_EVENT_PHASE_INSTANT: 73,
  TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
  TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
  TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
  TRACE_EVENT_PHASE_ASYNC_END: 70,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
  TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
  TRACE_EVENT_PHASE_FLOW_STEP: 116,
  TRACE_EVENT_PHASE_FLOW_END: 102,
  TRACE_EVENT_PHASE_METADATA: 77,
  TRACE_EVENT_PHASE_COUNTER: 67,
  TRACE_EVENT_PHASE_SAMPLE: 80,
  TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
  TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
  TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
  TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
  TRACE_EVENT_PHASE_MARK: 82,
  TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
  TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
  TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
  TRACE_EVENT_PHASE_LINK_IDS: 61
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/uv.ts
var UV_EEXIST = os.errno.EEXIST;
var UV_ENOENT = os.errno.ENOENT;
var codeToErrorWindows = [
  [-4093, ["E2BIG", "argument list too long"]],
  [-4092, ["EACCES", "permission denied"]],
  [-4091, ["EADDRINUSE", "address already in use"]],
  [-4090, ["EADDRNOTAVAIL", "address not available"]],
  [-4089, ["EAFNOSUPPORT", "address family not supported"]],
  [-4088, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-4084, ["EALREADY", "connection already in progress"]],
  [-4083, ["EBADF", "bad file descriptor"]],
  [-4082, ["EBUSY", "resource busy or locked"]],
  [-4081, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-4079, ["ECONNABORTED", "software caused connection abort"]],
  [-4078, ["ECONNREFUSED", "connection refused"]],
  [-4077, ["ECONNRESET", "connection reset by peer"]],
  [-4076, ["EDESTADDRREQ", "destination address required"]],
  [-4075, ["EEXIST", "file already exists"]],
  [-4074, ["EFAULT", "bad address in system call argument"]],
  [-4036, ["EFBIG", "file too large"]],
  [-4073, ["EHOSTUNREACH", "host is unreachable"]],
  [-4072, ["EINTR", "interrupted system call"]],
  [-4071, ["EINVAL", "invalid argument"]],
  [-4070, ["EIO", "i/o error"]],
  [-4069, ["EISCONN", "socket is already connected"]],
  [-4068, ["EISDIR", "illegal operation on a directory"]],
  [-4067, ["ELOOP", "too many symbolic links encountered"]],
  [-4066, ["EMFILE", "too many open files"]],
  [-4065, ["EMSGSIZE", "message too long"]],
  [-4064, ["ENAMETOOLONG", "name too long"]],
  [-4063, ["ENETDOWN", "network is down"]],
  [-4062, ["ENETUNREACH", "network is unreachable"]],
  [-4061, ["ENFILE", "file table overflow"]],
  [-4060, ["ENOBUFS", "no buffer space available"]],
  [-4059, ["ENODEV", "no such device"]],
  [-4058, ["ENOENT", "no such file or directory"]],
  [-4057, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-4035, ["ENOPROTOOPT", "protocol not available"]],
  [-4055, ["ENOSPC", "no space left on device"]],
  [-4054, ["ENOSYS", "function not implemented"]],
  [-4053, ["ENOTCONN", "socket is not connected"]],
  [-4052, ["ENOTDIR", "not a directory"]],
  [-4051, ["ENOTEMPTY", "directory not empty"]],
  [-4050, ["ENOTSOCK", "socket operation on non-socket"]],
  [-4049, ["ENOTSUP", "operation not supported on socket"]],
  [-4048, ["EPERM", "operation not permitted"]],
  [-4047, ["EPIPE", "broken pipe"]],
  [-4046, ["EPROTO", "protocol error"]],
  [-4045, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-4044, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-4034, ["ERANGE", "result too large"]],
  [-4043, ["EROFS", "read-only file system"]],
  [-4042, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-4041, ["ESPIPE", "invalid seek"]],
  [-4040, ["ESRCH", "no such process"]],
  [-4039, ["ETIMEDOUT", "connection timed out"]],
  [-4038, ["ETXTBSY", "text file is busy"]],
  [-4037, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-4033, ["ENXIO", "no such device or address"]],
  [-4032, ["EMLINK", "too many links"]],
  [-4031, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-4029, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-4027, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeWindows = codeToErrorWindows.map(([status, [error3]]) => [error3, status]);
var codeToErrorDarwin = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-48, ["EADDRINUSE", "address already in use"]],
  [-49, ["EADDRNOTAVAIL", "address not available"]],
  [-47, ["EAFNOSUPPORT", "address family not supported"]],
  [-35, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-37, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-89, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-53, ["ECONNABORTED", "software caused connection abort"]],
  [-61, ["ECONNREFUSED", "connection refused"]],
  [-54, ["ECONNRESET", "connection reset by peer"]],
  [-39, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-65, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-56, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-62, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-40, ["EMSGSIZE", "message too long"]],
  [-63, ["ENAMETOOLONG", "name too long"]],
  [-50, ["ENETDOWN", "network is down"]],
  [-51, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-55, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-42, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-78, ["ENOSYS", "function not implemented"]],
  [-57, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-66, ["ENOTEMPTY", "directory not empty"]],
  [-38, ["ENOTSOCK", "socket operation on non-socket"]],
  [-45, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-100, ["EPROTO", "protocol error"]],
  [-43, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-41, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-58, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-60, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-64, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-79, ["EFTYPE", "inappropriate file type or format"]],
  [-92, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeDarwin = codeToErrorDarwin.map(([status, [code2]]) => [code2, status]);
var codeToErrorLinux = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-98, ["EADDRINUSE", "address already in use"]],
  [-99, ["EADDRNOTAVAIL", "address not available"]],
  [-97, ["EAFNOSUPPORT", "address family not supported"]],
  [-11, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-114, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-125, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-103, ["ECONNABORTED", "software caused connection abort"]],
  [-111, ["ECONNREFUSED", "connection refused"]],
  [-104, ["ECONNRESET", "connection reset by peer"]],
  [-89, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-113, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-106, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-40, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-90, ["EMSGSIZE", "message too long"]],
  [-36, ["ENAMETOOLONG", "name too long"]],
  [-100, ["ENETDOWN", "network is down"]],
  [-101, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-105, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-64, ["ENONET", "machine is not on the network"]],
  [-92, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-38, ["ENOSYS", "function not implemented"]],
  [-107, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-39, ["ENOTEMPTY", "directory not empty"]],
  [-88, ["ENOTSOCK", "socket operation on non-socket"]],
  [-95, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-71, ["EPROTO", "protocol error"]],
  [-93, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-91, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-108, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-110, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-112, ["EHOSTDOWN", "host is down"]],
  [-121, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-84, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeLinux = codeToErrorLinux.map(([status, [code2]]) => [code2, status]);
var errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
var codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
  if (osType === "windows") {
    const code2 = uvTranslateSysError(sysErrno);
    return codeMap.get(code2) ?? -sysErrno;
  } else {
    return -sysErrno;
  }
}
var UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
var UV_UNKNOWN = codeMap.get("UNKNOWN");
var UV_EBADF = codeMap.get("EBADF");
var UV_EINVAL = codeMap.get("EINVAL");
var UV_ENOTSOCK = codeMap.get("ENOTSOCK");

// deno:https://deno.land/std@0.147.0/node/util/types.ts
var types_default2 = { ...types_exports2 };

// deno:https://deno.land/std@0.147.0/node/internal_binding/string_decoder.ts
var string_decoder_exports = {};
__export(string_decoder_exports, {
  default: () => string_decoder_default,
  encodings: () => encodings
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/_node.ts
var Encodings = /* @__PURE__ */ ((Encodings4) => {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
  return Encodings4;
})(Encodings || {});

// deno:https://deno.land/std@0.147.0/node/internal_binding/string_decoder.ts
var encodings = [];
encodings[0 /* ASCII */] = "ascii";
encodings[2 /* BASE64 */] = "base64";
encodings[7 /* BASE64URL */] = "base64url";
encodings[6 /* BUFFER */] = "buffer";
encodings[5 /* HEX */] = "hex";
encodings[4 /* LATIN1 */] = "latin1";
encodings[3 /* UCS2 */] = "utf16le";
encodings[1 /* UTF8 */] = "utf8";
var string_decoder_default = { encodings };

// deno:https://deno.land/std@0.147.0/node/internal_binding/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  default: () => buffer_default,
  indexOfBuffer: () => indexOfBuffer,
  indexOfNumber: () => indexOfNumber,
  numberToBytes: () => numberToBytes
});
function numberToBytes(n) {
  if (n === 0)
    return new Uint8Array([0]);
  const bytes = [];
  bytes.unshift(n & 255);
  while (n >= 256) {
    n = n >>> 8;
    bytes.unshift(n & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x = 0; x <= searchableBufferLastIndex; x++) {
    if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, 1 /* UTF8 */, forwardDirection);
}
var buffer_default = { indexOfBuffer, indexOfNumber };

// deno:https://deno.land/std@0.147.0/encoding/base64.ts
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.147.0/encoding/base64url.ts
function addPaddingToBase64url(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase64(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode2(data) {
  return convertBase64ToBase64url(encode(data));
}
function decode2(b64url) {
  return decode(convertBase64urlToBase64(b64url));
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/_utils.ts
function asciiToBytes(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
  str = base64clean(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode(str);
}
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes(str) {
  str = base64clean(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode2(str);
}
function hexToBytes(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a = Number.parseInt(str[i * 2], 16);
    const b = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a) && Number.isNaN(b)) {
      break;
    }
    byteArray[i] = a << 4 | b;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
  let c, hi, lo2;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo2 = c % 256;
    byteArray.push(lo2);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

// deno:https://deno.land/std@0.147.0/node/internal/buffer.mjs
var utf8Encoder = new TextEncoder();
var float32Array = new Float32Array(1);
var uInt8Float32Array = new Uint8Array(float32Array.buffer);
var float64Array = new Float64Array(1);
var uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
var bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 8);
  }
  uInt8Float64Array[7] = first;
  uInt8Float64Array[6] = buffer[++offset];
  uInt8Float64Array[5] = buffer[++offset];
  uInt8Float64Array[4] = buffer[++offset];
  uInt8Float64Array[3] = buffer[++offset];
  uInt8Float64Array[2] = buffer[++offset];
  uInt8Float64Array[1] = buffer[++offset];
  uInt8Float64Array[0] = last;
  return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 8);
  }
  uInt8Float64Array[0] = first;
  uInt8Float64Array[1] = buffer[++offset];
  uInt8Float64Array[2] = buffer[++offset];
  uInt8Float64Array[3] = buffer[++offset];
  uInt8Float64Array[4] = buffer[++offset];
  uInt8Float64Array[5] = buffer[++offset];
  uInt8Float64Array[6] = buffer[++offset];
  uInt8Float64Array[7] = last;
  return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 7);
  float64Array[0] = val;
  buffer[offset++] = uInt8Float64Array[0];
  buffer[offset++] = uInt8Float64Array[1];
  buffer[offset++] = uInt8Float64Array[2];
  buffer[offset++] = uInt8Float64Array[3];
  buffer[offset++] = uInt8Float64Array[4];
  buffer[offset++] = uInt8Float64Array[5];
  buffer[offset++] = uInt8Float64Array[6];
  buffer[offset++] = uInt8Float64Array[7];
  return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 7);
  float64Array[0] = val;
  buffer[offset++] = uInt8Float64Array[7];
  buffer[offset++] = uInt8Float64Array[6];
  buffer[offset++] = uInt8Float64Array[5];
  buffer[offset++] = uInt8Float64Array[4];
  buffer[offset++] = uInt8Float64Array[3];
  buffer[offset++] = uInt8Float64Array[2];
  buffer[offset++] = uInt8Float64Array[1];
  buffer[offset++] = uInt8Float64Array[0];
  return offset;
}
function readFloatBackwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 4);
  }
  uInt8Float32Array[3] = first;
  uInt8Float32Array[2] = buffer[++offset];
  uInt8Float32Array[1] = buffer[++offset];
  uInt8Float32Array[0] = last;
  return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 4);
  }
  uInt8Float32Array[0] = first;
  uInt8Float32Array[1] = buffer[++offset];
  uInt8Float32Array[2] = buffer[++offset];
  uInt8Float32Array[3] = last;
  return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 3);
  float32Array[0] = val;
  buffer[offset++] = uInt8Float32Array[0];
  buffer[offset++] = uInt8Float32Array[1];
  buffer[offset++] = uInt8Float32Array[2];
  buffer[offset++] = uInt8Float32Array[3];
  return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 3);
  float32Array[0] = val;
  buffer[offset++] = uInt8Float32Array[3];
  buffer[offset++] = uInt8Float32Array[2];
  buffer[offset++] = uInt8Float32Array[1];
  buffer[offset++] = uInt8Float32Array[0];
  return offset;
}
function readInt24LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
  return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings.length; ++i) {
  encodingsMap[encodings[i]] = i;
}
var encodingOps = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf8,
    encoding: "utf8",
    encodingVal: encodingsMap.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps.utf8;
      if (encoding === "ucs2")
        return encodingOps.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps.utf8;
      if (encoding === "ascii")
        return encodingOps.ascii;
      if (encoding === "ucs-2")
        return encodingOps.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps.latin1;
      }
      if (encoding === "base64")
        return encodingOps.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps.base64url;
      }
      break;
  }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds(buf, offset, byteLength6) {
  validateNumber(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength6] === void 0) {
    boundsError(offset, buf.length - (byteLength6 + 1));
  }
}
function checkInt(value, min4, max2, buf, offset, byteLength6) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength6 > 3) {
      if (min4 === 0 || min4 === 0n) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength6 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset, byteLength6);
}
function toInteger(n, defaultVal) {
  n = +n;
  if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
    return n % 1 === 0 ? n : Math.floor(n);
  }
  return defaultVal;
}
function writeU_Int8(buf, value, offset, min4, max2) {
  value = +value;
  validateNumber(offset, "offset");
  if (value > max2 || value < min4) {
    throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min4} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset(value, name, min4 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
}
function writeU_Int48LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}

// deno:https://deno.land/std@0.147.0/node/_buffer.mjs
var kMaxLength = 2147483647;
var MAX_UINT32 = 2 ** 32;
var customInspectSymbol3 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer3.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer3.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer3.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer3.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > kMaxLength) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer3.prototype);
  return buf;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe(arg);
  }
  return _from(arg, encodingOrOffset, length);
}
Buffer3.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer2(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) {
      return b;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes.ERR_INVALID_ARG_TYPE("first argument", ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"], value);
}
Buffer3.from = function from(value, encodingOrOffset, length) {
  return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer3, Uint8Array);
function assertSize(size) {
  validateNumber(size, "size");
  if (!(size >= 0 && size <= kMaxLength)) {
    throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc(size, fill5, encoding) {
  assertSize(size);
  const buffer = createBuffer(size);
  if (fill5 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill5, encoding);
  }
  return buffer;
}
Buffer3.alloc = function alloc(size, fill5, encoding) {
  return _alloc(size, fill5, encoding);
};
function _allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer3.allocUnsafe = function allocUnsafe(size) {
  return _allocUnsafe(size);
};
Buffer3.allocUnsafeSlow = function allocUnsafeSlow(size) {
  return _allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength(string, encoding) | 0;
  let buf = createBuffer(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  const buf = createBuffer(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer2(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer(0);
    }
    return fromArrayLike(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike(obj2.data);
  }
}
function checked(length) {
  if (length >= kMaxLength) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  assertSize(length);
  return Buffer3.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer3.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer3.prototype;
};
Buffer3.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) {
    a = Buffer3.from(a, a.offset, a.byteLength);
  }
  if (isInstance(b, Uint8Array)) {
    b = Buffer3.from(b, b.offset, b.byteLength);
  }
  if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) {
    return 0;
  }
  let x = a.length;
  let y = b.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
};
Buffer3.isEncoding = function isEncoding(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding2(encoding) !== void 0;
};
Buffer3.concat = function concat2(list, length) {
  if (!Array.isArray(list)) {
    throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer3.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset(length, "length");
  }
  const buffer = Buffer3.allocUnsafe(length);
  let pos = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    if (!isUint8Array(buf)) {
      throw new codes.ERR_INVALID_ARG_TYPE(`list[${i}]`, ["Buffer", "Uint8Array"], list[i]);
    }
    pos += _copyActual(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView(string) || isAnyArrayBuffer2(string)) {
      return string.byteLength;
    }
    throw new codes.ERR_INVALID_ARG_TYPE("string", ["string", "Buffer", "ArrayBuffer"], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf8(string);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf8(string);
  }
  return ops.byteLength(string);
}
Buffer3.byteLength = byteLength;
Buffer3.prototype._isBuffer = true;
function swap(b, n, m) {
  const i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer3.prototype.swap16 = function swap16() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer3.prototype.swap32 = function swap32() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer3.prototype.swap64 = function swap64() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer3.prototype.toString = function toString(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
Buffer3.prototype.equals = function equals2(b) {
  if (!isUint8Array(b)) {
    throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", ["Buffer", "Uint8Array"], b);
  }
  if (this === b) {
    return true;
  }
  return Buffer3.compare(this, b) === 0;
};
Buffer3.prototype.inspect = function inspect2() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol3) {
  Buffer3.prototype[customInspectSymbol3] = Buffer3.prototype.inspect;
}
Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer3.from(target, target.offset, target.byteLength);
  }
  if (!Buffer3.isBuffer(target)) {
    throw new codes.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset(start, "targetStart", 0, kMaxLength);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset(start, "sourceStart", 0, kMaxLength);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x = thisEnd - thisStart;
  let y = end - start;
  const len = Math.min(x, y);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  validateBuffer(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps.utf8;
  } else {
    ops = getEncodingOps(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array(val)) {
    const encodingVal = ops === void 0 ? encodingsMap.utf8 : ops.encodingVal;
    return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes.ERR_INVALID_ARG_TYPE("value", ["number", "string", "Buffer", "Uint8Array"], val);
}
Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer3.prototype.asciiSlice = function asciiSlice(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii(this);
  } else {
    return bytesToAscii(this.slice(offset, length));
  }
};
Buffer3.prototype.asciiWrite = function asciiWrite(string, offset, length) {
  return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer3.prototype.base64Slice = function base64Slice(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode(this);
  } else {
    return encode(this.slice(offset, length));
  }
};
Buffer3.prototype.base64Write = function base64Write(string, offset, length) {
  return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer3.prototype.base64urlSlice = function base64urlSlice(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode2(this);
  } else {
    return encode2(this.slice(offset, length));
  }
};
Buffer3.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
  return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer3.prototype.hexWrite = function hexWrite(string, offset, length) {
  return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.hexSlice = function hexSlice2(string, offset, length) {
  return _hexSlice(this, string, offset, length);
};
Buffer3.prototype.latin1Slice = function latin1Slice(string, offset, length) {
  return _latin1Slice(this, string, offset, length);
};
Buffer3.prototype.latin1Write = function latin1Write(string, offset, length) {
  return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer3.prototype.ucs2Slice = function ucs2Slice(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le(this);
  } else {
    return bytesToUtf16le(this.slice(offset, length));
  }
};
Buffer3.prototype.ucs2Write = function ucs2Write(string, offset, length) {
  return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.utf8Slice = function utf8Slice(string, offset, length) {
  return _utf8Slice(this, string, offset, length);
};
Buffer3.prototype.utf8Write = function utf8Write(string, offset, length) {
  return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.write = function write(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer3.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer3.prototype);
  return buffer;
}
function _utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function _latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
Buffer3.prototype.slice = function slice(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer3.prototype);
  return newBuf;
};
Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48LE(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40LE(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24LE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48BE(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40BE(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24BE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset = 0) {
  validateNumber(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError(offset, this.length - 1);
  }
  return val;
};
Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = readUInt16BE;
Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = readUInt32BE;
Buffer3.prototype.readBigUint64LE = Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo2) + (BigInt(hi) << BigInt(32));
});
Buffer3.prototype.readBigUint64BE = Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo2);
});
Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48LE(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40LE(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24LE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48BE(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40BE(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24BE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readInt8 = function readInt8(offset = 0) {
  validateNumber(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer3.prototype.readInt16LE = function readInt16LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer3.prototype.readInt16BE = function readInt16BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer3.prototype.readInt32LE = function readInt32LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer3.prototype.readInt32BE = function readInt32BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer3.prototype.readFloatLE = function readFloatLE(offset) {
  return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer3.prototype.readFloatBE = function readFloatBE(offset) {
  return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer3.prototype.readDoubleLE = function readDoubleLE(offset) {
  return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer3.prototype.readDoubleBE = function readDoubleBE(offset) {
  return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, 0, 255);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, 0, 255);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
  return writeU_Int8(this, value, offset, 0, 255);
};
Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
  return writeU_Int16LE(this, value, offset, 0, 65535);
};
Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
  return writeU_Int16BE(this, value, offset, 0, 65535);
};
Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
  return _writeUInt32LE(this, value, offset, 0, 4294967295);
};
Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
  return _writeUInt32BE(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE(buf, value, offset, min4, max2) {
  checkIntBI(value, min4, max2, buf, offset, 7);
  let lo2 = Number(value & BigInt(4294967295));
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min4, max2) {
  checkIntBI(value, min4, max2, buf, offset, 7);
  let lo2 = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 6] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 5] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 4] = lo2;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer3.prototype.writeBigUint64LE = Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeBigUint64BE = Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, -128, 127);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, -128, 127);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeInt8 = function writeInt8(value, offset = 0) {
  return writeU_Int8(this, value, offset, -128, 127);
};
Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
  return writeU_Int16LE(this, value, offset, -32768, 32767);
};
Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
  return writeU_Int16BE(this, value, offset, -32768, 32767);
};
Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
  return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
};
Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
  return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
};
Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset) {
  return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset) {
  return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
  return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
  return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer3.prototype.copy = function copy2(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array(this)) {
    throw new codes.ERR_INVALID_ARG_TYPE("source", ["Buffer", "Uint8Array"], this);
  }
  if (!isUint8Array(target)) {
    throw new codes.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger(targetStart, 0);
    if (targetStart < 0) {
      throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT32) {
      throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT32) {
      throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer3.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds2(buf, offset, byteLength22) {
  validateNumber(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
    boundsError(offset, buf.length - (byteLength22 + 1));
  }
}
function checkIntBI(value, min4, max2, buf, offset, byteLength22) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength22 > 3) {
      if (min4 === 0 || min4 === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds2(buf, offset, byteLength22);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer(src, dst, offset, byteLength6) {
  let i;
  const length = byteLength6 === void 0 ? src.length : byteLength6;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();
function defineBigIntMethod(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
var atob2 = globalThis.atob;
var Blob2 = globalThis.Blob;
var btoa = globalThis.btoa;

// deno:https://deno.land/std@0.147.0/node/internal/util/comparisons.ts
var memo;
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, true);
}
function innerDeepEqual(val1, val2, strict, memos = memo) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keys1 = getOwnNonIndexProperties(val1, filter);
    const keys2 = getOwnNonIndexProperties(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 1 /* isArray */, keys1);
  } else if (val1Tag === "[object Object]") {
    return keyCheck(val1, val2, strict, memos, 0 /* noIterator */);
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError2(val1) || val1 instanceof Error) {
    if (!isNativeError2(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) => Object.getOwnPropertySymbols(val).map((item) => item.toString()).toString();
    if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
      return false;
    }
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keysVal1 = getOwnNonIndexProperties(val1, filter);
    const keysVal2 = getOwnNonIndexProperties(val2, filter);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 0 /* noIterator */, keysVal1);
  } else if (isSet2(val1)) {
    if (!isSet2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 2 /* isSet */);
  } else if (isMap2(val1)) {
    if (!isMap2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 3 /* isMap */);
  } else if (isAnyArrayBuffer2(val1)) {
    if (!isAnyArrayBuffer2(val2) || !areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive2(val1)) {
    if (!isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
  } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet2(val2) || isMap2(val2) || isDate2(val2) || isRegExp2(val2) || isAnyArrayBuffer2(val2) || isBoxedPrimitive2(val2) || isNativeError2(val2) || val2 instanceof Error) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, 0 /* noIterator */);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key2 = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key2)) {
          if (!val2.propertyIsEnumerable(key2)) {
            return false;
          }
          aKeys.push(key2.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key2)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === 0 /* noIterator */ || iterationType === 1 /* isArray */ && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function areSimilarRegExps(a, b) {
  return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return Buffer3.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && Buffer3.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
  if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
    return false;
  }
  if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
    return false;
  }
  if (isNumberObject2(a)) {
    return isNumberObject2(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
  }
  if (isStringObject2(a)) {
    return isStringObject2(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
  }
  if (isBooleanObject2(a)) {
    return isBooleanObject2(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
  }
  if (isBigIntObject2(a)) {
    return isBigIntObject2(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
  }
  if (isSymbolObject2(a)) {
    return isSymbolObject2(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
  }
  throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
  return keys.filter((key2) => val.propertyIsEnumerable(key2));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === 2 /* isSet */) {
    if (!setEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 3 /* isMap */) {
    if (!mapEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 1 /* isArray */) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (!obj2.hasOwnProperty(i) || !innerDeepEqual(obj1[i], obj2[i], strict, memos)) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key2 = keys1[i];
          if (!obj2.hasOwnProperty(key2) || !innerDeepEqual(obj1[key2], obj2[key2], strict, memos)) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (!innerDeepEqual(obj1[key2], obj2[key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function findLooseMatchingPrimitives(primitive) {
  switch (typeof primitive) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      primitive = +primitive;
    case "number":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null)
    return altValue;
  return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
  for (const val2 of set) {
    if (innerDeepEqual(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function setEquiv(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === "object" && item !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict)
        return false;
      if (!setMightHaveLoosePrim(set1, set2, item)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    }
  }
  if (set !== null) {
    for (const item of set2) {
      if (typeof item === "object" && item !== null) {
        if (!setHasEqualElement(set, item, strict, memos))
          return false;
      } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (curB === void 0 && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
  let set = null;
  for (const { 0: key2, 1: item1 } of map1) {
    if (typeof key2 === "object" && key2 !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key2);
    } else {
      const item2 = map2.get(key2);
      if (item2 === void 0 && !map2.has(key2) || !innerDeepEqual(item1, item2, strict, memos)) {
        if (strict)
          return false;
        if (!mapMightHaveLoosePrimitive(map1, map2, key2, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      }
    }
  }
  if (set !== null) {
    for (const { 0: key2, 1: item } of map2) {
      if (typeof key2 === "object" && key2 !== null) {
        if (!mapHasEqualEntry(set, map1, key2, item, strict, memos)) {
          return false;
        }
      } else if (!strict && (!map1.has(key2) || !innerDeepEqual(map1.get(key2), item, false, memos)) && !mapHasEqualEntry(set, map1, key2, item, false, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
  for (const key2 of set) {
    if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}

// deno:https://deno.land/std@0.147.0/node/util.ts
var NumberIsSafeInteger = Number.isSafeInteger;
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function isUndefined(value) {
  return value === void 0;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isError(e) {
  return e instanceof Error;
}
function isFunction(value) {
  return typeof value === "function";
}
function isRegExp3(value) {
  return types_default2.isRegExp(value);
}
function isDate3(value) {
  return types_default2.isDate(value);
}
function isPrimitive(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer2(value) {
  return Buffer3.isBuffer(value);
}
function _extend(target, source) {
  if (source === null || typeof source !== "object")
    return target;
  const keys = Object.keys(source);
  let i = keys.length;
  while (i--) {
    target[keys[i]] = source[keys[i]];
  }
  return target;
}
function getSystemErrorName(code2) {
  if (typeof code2 !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger(code2)) {
    throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap.get(code2)?.[0];
}
function inherits(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new codes.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new codes.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
var TextDecoder2 = _TextDecoder;
var TextEncoder2 = _TextEncoder;
function pad(n) {
  return n.toString().padStart(2, "0");
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  const d = new Date();
  const t = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return `${d.getDate()} ${months[d.getMonth()]} ${t}`;
}
function log(...args) {
  console.log("%s - %s", timestamp(), format2(...args));
}
var util_default = {
  format: format2,
  formatWithOptions,
  inspect,
  isArray,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isSymbol,
  isUndefined,
  isObject,
  isError,
  isFunction,
  isRegExp: isRegExp3,
  isDate: isDate3,
  isPrimitive,
  isBuffer: isBuffer2,
  _extend,
  getSystemErrorName,
  deprecate,
  callbackify,
  promisify,
  inherits,
  types: types_default2,
  stripVTControlCharacters,
  TextDecoder: TextDecoder2,
  TextEncoder: TextEncoder2,
  log,
  debuglog,
  isDeepStrictEqual
};

// deno:https://deno.land/std@0.147.0/node/internal/errors.ts
var {
  errno: { ENOTDIR, ENOENT }
} = os;
var kIsNodeError = Symbol("kIsNodeError");
var classRegExp2 = /^([A-Z][a-z0-9]*)+$/;
var kTypes = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
var AbortError = class extends Error {
  constructor() {
    super("The operation was aborted");
    this.code = "ABORT_ERR";
    this.name = "AbortError";
  }
};
function addNumericalSeparator(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace2(err) {
  Error.captureStackTrace(err);
  return err;
});
var uvExceptionWithHostPort = hideStackFrames(function uvExceptionWithHostPort2(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace(ex);
});
var errnoException = hideStackFrames(function errnoException2(err, syscall, original) {
  const code2 = getSystemErrorName(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
  return errorMap.get(name);
}
var uvUnmappedError = ["UNKNOWN", "unknown error"];
var uvException = hideStackFrames(function uvException2(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace(err);
});
var exceptionWithHostPort = hideStackFrames(function exceptionWithHostPort2(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace(ex);
});
var dnsException = hideStackFrames(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap.get("EAI_NODATA") || code2 === codeMap.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace(ex);
});
var NodeErrorAbstraction = class extends Error {
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError = class extends NodeErrorAbstraction {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace(this);
    Object.defineProperties(this, {
      [kIsNodeError]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode(key2, msgPrfix) {
  return class NodeError extends NodeSystemError {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
var ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
  expected = Array.isArray(expected) ? expected : [expected];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes.includes(value)) {
      types.push(value.toLocaleLowerCase());
    } else if (classRegExp2.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types.indexOf("object");
    if (pos !== -1) {
      types.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types.length > 0) {
    if (types.length > 2) {
      const last = types.pop();
      msg += `one of type ${types.join(", ")}, or ${last}`;
    } else if (types.length === 2) {
      msg += `one of type ${types[0]} or ${types[1]}`;
    } else {
      msg += `of type ${types[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last = other.pop();
      msg += `one of ${other.join(", ")}, or ${last}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE = class extends NodeRangeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE = class extends NodeTypeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
  }
};
ERR_INVALID_ARG_TYPE.RangeError = ERR_INVALID_ARG_TYPE_RANGE;
var ERR_INVALID_ARG_VALUE_RANGE = class extends NodeRangeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE = class extends NodeTypeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
ERR_INVALID_ARG_VALUE.RangeError = ERR_INVALID_ARG_VALUE_RANGE;
function invalidArgTypeHelper(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect(input, { depth: -1 })}`;
  }
  let inspected = inspect(input, { colors: false });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE = class extends RangeError {
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert2(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    this.code = "ERR_OUT_OF_RANGE";
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS = class extends NodeRangeError {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_CRYPTO_FIPS_FORCED = class extends NodeError {
  constructor() {
    super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
  }
};
var ERR_INVALID_CALLBACK = class extends NodeTypeError {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
  }
};
var ERR_INVALID_CURSOR_POS = class extends NodeTypeError {
  constructor() {
    super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
  }
};
var ERR_IPC_CHANNEL_CLOSED = class extends NodeError {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_METHOD_NOT_IMPLEMENTED = class extends NodeError {
  constructor(x) {
    super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
  }
};
var ERR_MISSING_ARGS = class extends NodeTypeError {
  constructor(...args) {
    let msg = "The ";
    const len = args.length;
    const wrap3 = (a) => `"${a}"`;
    args = args.map((a) => Array.isArray(a) ? a.map(wrap3).join(" or ") : wrap3(a));
    switch (len) {
      case 1:
        msg += `${args[0]} argument`;
        break;
      case 2:
        msg += `${args[0]} and ${args[1]} arguments`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += `, and ${args[len - 1]} arguments`;
        break;
    }
    super("ERR_MISSING_ARGS", `${msg} must be specified`);
  }
};
var ERR_MULTIPLE_CALLBACK = class extends NodeError {
  constructor() {
    super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
  }
};
var ERR_SOCKET_BAD_PORT = class extends NodeRangeError {
  constructor(name, port, allowZero = true) {
    assert2(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_STREAM_ALREADY_FINISHED = class extends NodeError {
  constructor(x) {
    super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
  }
};
var ERR_STREAM_CANNOT_PIPE = class extends NodeError {
  constructor() {
    super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
  }
};
var ERR_STREAM_DESTROYED = class extends NodeError {
  constructor(x) {
    super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
  }
};
var ERR_STREAM_NULL_VALUES = class extends NodeTypeError {
  constructor() {
    super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
  }
};
var ERR_STREAM_PREMATURE_CLOSE = class extends NodeError {
  constructor() {
    super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
  }
};
var ERR_STREAM_PUSH_AFTER_EOF = class extends NodeError {
  constructor() {
    super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
  }
};
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = class extends NodeError {
  constructor() {
    super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
  }
};
var ERR_STREAM_WRITE_AFTER_END = class extends NodeError {
  constructor() {
    super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
  }
};
var ERR_UNHANDLED_ERROR = class extends NodeError {
  constructor(x) {
    super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
  }
};
var ERR_UNKNOWN_ENCODING = class extends NodeTypeError {
  constructor(x) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
  }
};
var ERR_UNKNOWN_SIGNAL = class extends NodeTypeError {
  constructor(x) {
    super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
  }
};
function buildReturnPropertyType(value) {
  if (value && value.constructor && value.constructor.name) {
    return `instance of ${value.constructor.name}`;
  } else {
    return `type ${typeof value}`;
  }
}
var ERR_INVALID_RETURN_VALUE = class extends NodeTypeError {
  constructor(input, name, value) {
    super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType(value)}.`);
  }
};
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      outerError.errors.push(innerError);
      return outerError;
    }
    const err = new AggregateError([
      outerError,
      innerError
    ], outerError.message);
    err.code = outerError.code;
    return err;
  }
  return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
var genericNodeError = hideStackFrames(function genericNodeError2(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});

// deno:https://deno.land/std@0.147.0/node/_events.mjs
var kRejection = Symbol.for("nodejs.rejection");
var kCapture = Symbol("kCapture");
var kErrorMonitor = Symbol("events.errorMonitor");
var kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
var kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}
var events_default = EventEmitter;
EventEmitter.on = on;
EventEmitter.once = once3;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
var captureRejectionSymbol = EventEmitter.captureRejectionSymbol;
var errorMonitor = EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
  get() {
    return EventEmitter.prototype[kCapture];
  },
  set(value) {
    validateBoolean(value, "EventEmitter.captureRejections");
    EventEmitter.prototype[kCapture] = value;
  },
  enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
  value: false,
  writable: true,
  enumerable: false
});
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
      throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
    }
    defaultMaxListeners = arg;
  }
});
Object.defineProperties(EventEmitter, {
  kMaxEventTargetListeners: {
    value: kMaxEventTargetListeners,
    enumerable: false,
    configurable: false,
    writable: false
  },
  kMaxEventTargetListenersWarned: {
    value: kMaxEventTargetListenersWarned,
    enumerable: false,
    configurable: false,
    writable: false
  }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
  if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
    throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
  }
  if (eventTargets.length === 0) {
    defaultMaxListeners = n;
  } else {
    for (let i = 0; i < eventTargets.length; i++) {
      const target = eventTargets[i];
      if (target instanceof EventTarget) {
        target[kMaxEventTargetListeners] = n;
        target[kMaxEventTargetListenersWarned] = false;
      } else if (typeof target.setMaxListeners === "function") {
        target.setMaxListeners(n);
      } else {
        throw new ERR_INVALID_ARG_TYPE("eventTargets", ["EventEmitter", "EventTarget"], target);
      }
    }
  }
};
EventEmitter.init = function(opts) {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
  if (opts?.captureRejections) {
    validateBoolean(opts.captureRejections, "options.captureRejections");
    this[kCapture] = Boolean(opts.captureRejections);
  } else {
    this[kCapture] = EventEmitter.prototype[kCapture];
  }
};
function addCatch(that, promise, type, args) {
  if (!that[kCapture]) {
    return;
  }
  try {
    const then = promise.then;
    if (typeof then === "function") {
      then.call(promise, void 0, function(err) {
        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
      });
    }
  } catch (err) {
    that.emit("error", err);
  }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
  if (typeof ee[kRejection] === "function") {
    ee[kRejection](err, type, ...args);
  } else {
    const prev = ee[kCapture];
    try {
      ee[kCapture] = false;
      ee.emit("error", err);
    } finally {
      ee[kCapture] = prev;
    }
  }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
    throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0) {
    return EventEmitter.defaultMaxListeners;
  }
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
  let doError = type === "error";
  const events = this._events;
  if (events !== void 0) {
    if (doError && events[kErrorMonitor] !== void 0) {
      this.emit(kErrorMonitor, ...args);
    }
    doError = doError && events.error === void 0;
  } else if (!doError) {
    return false;
  }
  if (doError) {
    let er;
    if (args.length > 0) {
      er = args[0];
    }
    if (er instanceof Error) {
      try {
        const capture = {};
        Error.captureStackTrace(capture, EventEmitter.prototype.emit);
      } catch {
      }
      throw er;
    }
    let stringifiedEr;
    try {
      stringifiedEr = inspect(er);
    } catch {
      stringifiedEr = er;
    }
    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
    err.context = er;
    throw err;
  }
  const handler = events[type];
  if (handler === void 0) {
    return false;
  }
  if (typeof handler === "function") {
    const result = handler.apply(this, args);
    if (result !== void 0 && result !== null) {
      addCatch(this, result, type, args);
    }
  } else {
    const len = handler.length;
    const listeners2 = arrayClone(handler);
    for (let i = 0; i < len; ++i) {
      const result = listeners2[i].apply(this, args);
      if (result !== void 0 && result !== null) {
        addCatch(this, result, type, args);
      }
    }
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  let m;
  let events;
  let existing;
  checkListener(listener);
  events = target._events;
  if (events === void 0) {
    events = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ?? listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === void 0) {
    events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      const w = new Error(`Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners added to ${inspect(target, { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`);
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      process.emitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) {
      return this.listener.call(this.target);
    }
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  const state = { fired: false, wrapFn: void 0, target, type, listener };
  const wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  checkListener(listener);
  const events = this._events;
  if (events === void 0) {
    return this;
  }
  const list = events[type];
  if (list === void 0) {
    return this;
  }
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
    } else {
      delete events[type];
      if (events.removeListener) {
        this.emit("removeListener", type, list.listener || listener);
      }
    }
  } else if (typeof list !== "function") {
    let position = -1;
    for (let i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        position = i;
        break;
      }
    }
    if (position < 0) {
      return this;
    }
    if (position === 0) {
      list.shift();
    } else {
      spliceOne(list, position);
    }
    if (list.length === 1) {
      events[type] = list[0];
    }
    if (events.removeListener !== void 0) {
      this.emit("removeListener", type, listener);
    }
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  const events = this._events;
  if (events === void 0) {
    return this;
  }
  if (events.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== void 0) {
      if (--this._eventsCount === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
      } else {
        delete events[type];
      }
    }
    return this;
  }
  if (arguments.length === 0) {
    for (const key2 of Reflect.ownKeys(events)) {
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  const listeners2 = events[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (let i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  const events = target._events;
  if (events === void 0) {
    return [];
  }
  const evlistener = events[type];
  if (evlistener === void 0) {
    return [];
  }
  if (typeof evlistener === "function") {
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  }
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  }
  return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  const events = this._events;
  if (events !== void 0) {
    const evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
  switch (arr.length) {
    case 2:
      return [arr[0], arr[1]];
    case 3:
      return [arr[0], arr[1], arr[2]];
    case 4:
      return [arr[0], arr[1], arr[2], arr[3]];
    case 5:
      return [arr[0], arr[1], arr[2], arr[3], arr[4]];
    case 6:
      return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
  }
  return arr.slice();
}
function unwrapListeners(arr) {
  const ret = arrayClone(arr);
  for (let i = 0; i < ret.length; ++i) {
    const orig = ret[i].listener;
    if (typeof orig === "function") {
      ret[i] = orig;
    }
  }
  return ret;
}
function getEventListeners(emitterOrTarget, type) {
  if (typeof emitterOrTarget.listeners === "function") {
    return emitterOrTarget.listeners(type);
  }
  if (emitterOrTarget instanceof EventTarget) {
    const root = emitterOrTarget[kEvents].get(type);
    const listeners2 = [];
    let handler = root?.next;
    while (handler?.listener !== void 0) {
      const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
      listeners2.push(listener);
      handler = handler.next;
    }
    return listeners2;
  }
  throw new ERR_INVALID_ARG_TYPE("emitter", ["EventEmitter", "EventTarget"], emitterOrTarget);
}
async function once3(emitter, name, options = {}) {
  const signal = options?.signal;
  validateAbortSignal(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError();
  }
  return new Promise((resolve7, reject) => {
    const errorListener = (err) => {
      emitter.removeListener(name, resolver);
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      }
      reject(err);
    };
    const resolver = (...args) => {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      }
      resolve7(args);
    };
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error" && typeof emitter.once === "function") {
      emitter.once("error", errorListener);
    }
    function abortListener() {
      eventTargetAgnosticRemoveListener(emitter, name, resolver);
      eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
      reject(new AbortError());
    }
    if (signal != null) {
      eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
    }
  });
}
var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}).prototype);
function createIterResult(value, done) {
  return { value, done };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function") {
    emitter.removeListener(name, listener);
  } else if (typeof emitter.removeEventListener === "function") {
    emitter.removeEventListener(name, listener, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags?.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, (arg) => {
      listener(arg);
    }, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
  }
}
function on(emitter, event, options) {
  const signal = options?.signal;
  validateAbortSignal(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError();
  }
  const unconsumedEvents = [];
  const unconsumedPromises = [];
  let error3 = null;
  let finished2 = false;
  const iterator = Object.setPrototypeOf({
    next() {
      const value = unconsumedEvents.shift();
      if (value) {
        return Promise.resolve(createIterResult(value, false));
      }
      if (error3) {
        const p = Promise.reject(error3);
        error3 = null;
        return p;
      }
      if (finished2) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      return new Promise(function(resolve7, reject) {
        unconsumedPromises.push({ resolve: resolve7, reject });
      });
    },
    return() {
      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
      if (signal) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener, { once: true });
      }
      finished2 = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return Promise.resolve(createIterResult(void 0, true));
    },
    throw(err) {
      if (!err || !(err instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
      }
      error3 = err;
      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  }, AsyncIteratorPrototype);
  eventTargetAgnosticAddListener(emitter, event, eventHandler);
  if (event !== "error" && typeof emitter.on === "function") {
    emitter.on("error", errorHandler);
  }
  if (signal) {
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  }
  return iterator;
  function abortListener() {
    errorHandler(new AbortError());
  }
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEvents.push(args);
    }
  }
  function errorHandler(err) {
    finished2 = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error3 = err;
    }
    iterator.return();
  }
}

// deno:https://deno.land/std@0.147.0/flags/mod.ts
var { hasOwn } = Object;
function get(obj2, key2) {
  if (hasOwn(obj2, key2)) {
    return obj2[key2];
  }
}
function getForce(obj2, key2) {
  const v = get(obj2, key2);
  assert2(v != null);
  return v;
}
function isNumber2(x) {
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(String(x)))
    return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj2, keys) {
  let o = obj2;
  keys.slice(0, -1).forEach((key3) => {
    o = get(o, key3) ?? {};
  });
  const key2 = keys[keys.length - 1];
  return hasOwn(o, key2);
}
function parse(args, {
  "--": doubleDash = false,
  alias = {},
  boolean = false,
  default: defaults = {},
  stopEarly = false,
  string = [],
  collect = [],
  negatable = [],
  unknown = (i) => i
} = {}) {
  const flags = {
    bools: {},
    strings: {},
    unknownFn: unknown,
    allBools: false,
    collect: {},
    negatable: {}
  };
  if (boolean !== void 0) {
    if (typeof boolean === "boolean") {
      flags.allBools = !!boolean;
    } else {
      const booleanArgs = typeof boolean === "string" ? [boolean] : boolean;
      for (const key2 of booleanArgs.filter(Boolean)) {
        flags.bools[key2] = true;
      }
    }
  }
  const aliases = {};
  if (alias !== void 0) {
    for (const key2 in alias) {
      const val = getForce(alias, key2);
      if (typeof val === "string") {
        aliases[key2] = [val];
      } else {
        aliases[key2] = val;
      }
      for (const alias2 of getForce(aliases, key2)) {
        aliases[alias2] = [key2].concat(aliases[key2].filter((y) => alias2 !== y));
      }
    }
  }
  if (string !== void 0) {
    const stringArgs = typeof string === "string" ? [string] : string;
    for (const key2 of stringArgs.filter(Boolean)) {
      flags.strings[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.strings[al] = true;
        }
      }
    }
  }
  if (collect !== void 0) {
    const collectArgs = typeof collect === "string" ? [collect] : collect;
    for (const key2 of collectArgs.filter(Boolean)) {
      flags.collect[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.collect[al] = true;
        }
      }
    }
  }
  if (negatable !== void 0) {
    const negatableArgs = typeof negatable === "string" ? [negatable] : negatable;
    for (const key2 of negatableArgs.filter(Boolean)) {
      flags.negatable[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.negatable[al] = true;
        }
      }
    }
  }
  const argv2 = { _: [] };
  function argDefined(key2, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key2) || !!get(flags.strings, key2) || !!get(aliases, key2);
  }
  function setKey(obj2, name, value, collect2 = true) {
    let o = obj2;
    const keys = name.split(".");
    keys.slice(0, -1).forEach(function(key3) {
      if (get(o, key3) === void 0) {
        o[key3] = {};
      }
      o = get(o, key3);
    });
    const key2 = keys[keys.length - 1];
    const collectable = collect2 && !!get(flags.collect, name);
    if (!collectable) {
      o[key2] = value;
    } else if (get(o, key2) === void 0) {
      o[key2] = [value];
    } else if (Array.isArray(get(o, key2))) {
      o[key2].push(value);
    } else {
      o[key2] = [get(o, key2), value];
    }
  }
  function setArg(key2, val, arg = void 0, collect2) {
    if (arg && flags.unknownFn && !argDefined(key2, arg)) {
      if (flags.unknownFn(arg, key2, val) === false)
        return;
    }
    const value = !get(flags.strings, key2) && isNumber2(val) ? Number(val) : val;
    setKey(argv2, key2, value, collect2);
    const alias2 = get(aliases, key2);
    if (alias2) {
      for (const x of alias2) {
        setKey(argv2, x, value, collect2);
      }
    }
  }
  function aliasIsBoolean(key2) {
    return getForce(aliases, key2).some((x) => typeof get(flags.bools, x) === "boolean");
  }
  let notFlags = [];
  if (args.includes("--")) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (/^--.+=/.test(arg)) {
      const m = arg.match(/^--([^=]+)=(.*)$/s);
      assert2(m != null);
      const [, key2, value] = m;
      if (flags.bools[key2]) {
        const booleanValue = value !== "false";
        setArg(key2, booleanValue, arg);
      } else {
        setArg(key2, value, arg);
      }
    } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
      const m = arg.match(/^--no-(.+)/);
      assert2(m != null);
      setArg(m[1], false, arg, false);
    } else if (/^--.+/.test(arg)) {
      const m = arg.match(/^--(.+)/);
      assert2(m != null);
      const [, key2] = m;
      const next = args[i + 1];
      if (next !== void 0 && !/^-/.test(next) && !get(flags.bools, key2) && !flags.allBools && (get(aliases, key2) ? !aliasIsBoolean(key2) : true)) {
        setArg(key2, next, arg);
        i++;
      } else if (/^(true|false)$/.test(next)) {
        setArg(key2, next === "true", arg);
        i++;
      } else {
        setArg(key2, get(flags.strings, key2) ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      const letters = arg.slice(1, -1).split("");
      let broken = false;
      for (let j = 0; j < letters.length; j++) {
        const next = arg.slice(j + 2);
        if (next === "-") {
          setArg(letters[j], next, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
          setArg(letters[j], next.split(/=(.+)/)[1], arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next, arg);
          broken = true;
          break;
        }
        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], arg.slice(j + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
        }
      }
      const [key2] = arg.slice(-1);
      if (!broken && key2 !== "-") {
        if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key2) && (get(aliases, key2) ? !aliasIsBoolean(key2) : true)) {
          setArg(key2, args[i + 1], arg);
          i++;
        } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
          setArg(key2, args[i + 1] === "true", arg);
          i++;
        } else {
          setArg(key2, get(flags.strings, key2) ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv2._.push(flags.strings["_"] ?? !isNumber2(arg) ? arg : Number(arg));
      }
      if (stopEarly) {
        argv2._.push(...args.slice(i + 1));
        break;
      }
    }
  }
  for (const [key2, value] of Object.entries(defaults)) {
    if (!hasKey(argv2, key2.split("."))) {
      setKey(argv2, key2, value);
      if (aliases[key2]) {
        for (const x of aliases[key2]) {
          setKey(argv2, x, value);
        }
      }
    }
  }
  for (const key2 of Object.keys(flags.bools)) {
    if (!hasKey(argv2, key2.split("."))) {
      const value = get(flags.collect, key2) ? [] : false;
      setKey(argv2, key2, value, false);
    }
  }
  for (const key2 of Object.keys(flags.strings)) {
    if (!hasKey(argv2, key2.split(".")) && get(flags.collect, key2)) {
      setKey(argv2, key2, [], false);
    }
  }
  if (doubleDash) {
    argv2["--"] = [];
    for (const key2 of notFlags) {
      argv2["--"].push(key2);
    }
  } else {
    for (const key2 of notFlags) {
      argv2._.push(key2);
    }
  }
  return argv2;
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/node_options.ts
function getOptions() {
  const args = parse(Deno.args);
  const options = new Map(Object.entries(args).map(([key2, value]) => [key2, { value }]));
  return { options };
}

// deno:https://deno.land/std@0.147.0/node/internal/options.ts
var optionsMap;
function getOptionsFromBinding() {
  if (!optionsMap) {
    ({ options: optionsMap } = getOptions());
  }
  return optionsMap;
}
function getOptionValue(optionName) {
  const options = getOptionsFromBinding();
  if (optionName.startsWith("--no-")) {
    const option = options.get("--" + optionName.slice(5));
    return option && !option.value;
  }
  return options.get(optionName)?.value;
}

// deno:https://deno.land/std@0.147.0/path/win32.ts
var win32_exports = {};
__export(win32_exports, {
  basename: () => basename,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  format: () => format3,
  fromFileUrl: () => fromFileUrl,
  isAbsolute: () => isAbsolute,
  join: () => join2,
  normalize: () => normalize,
  parse: () => parse2,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep,
  toFileUrl: () => toFileUrl,
  toNamespacedPath: () => toNamespacedPath
});

// deno:https://deno.land/std@0.147.0/path/_constants.ts
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;

// deno:https://deno.land/std@0.147.0/path/_util.ts
function assertPath(path6) {
  if (typeof path6 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path6)}`);
  }
}
function isPosixPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code2) {
  return isPosixPathSeparator(code2) || code2 === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code2) {
  return code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z || code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z;
}
function normalizeString(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep7, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base3 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base3;
  if (dir === pathObject.root)
    return dir + base3;
  return dir + sep7 + base3;
}
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string) {
  return string.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}

// deno:https://deno.land/std@0.147.0/path/win32.ts
var sep = "\\";
var delimiter = ";";
function resolve(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno4 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute7 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        isAbsolute7 = true;
        if (isPathSeparator(path6.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path6.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path6.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path6.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path6.charCodeAt(1) === CHAR_COLON) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path6.charCodeAt(2))) {
              isAbsolute7 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      rootEnd = 1;
      isAbsolute7 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute7;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute7 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      isAbsolute7 = true;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path6.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path6.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path6.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            isAbsolute7 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(path6.slice(rootEnd), !isAbsolute7, "\\", isPathSeparator);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute7)
    tail = ".";
  if (tail.length > 0 && isPathSeparator(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute7) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute7) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator(code2)) {
    return true;
  } else if (isWindowsDeviceRoot(code2)) {
    if (len > 2 && path6.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join2(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert2(firstPart != null);
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize(joined);
}
function relative(from5, to) {
  assertPath(from5);
  assertPath(to);
  if (from5 === to)
    return "";
  const fromOrig = resolve(from5);
  const toOrig = resolve(to);
  if (fromOrig === toOrig)
    return "";
  from5 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from5 === to)
    return "";
  let fromStart = 0;
  let fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from5.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path6.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path6.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path6;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path6.charCodeAt(1) === CHAR_COLON)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname(path6) {
  assertPath(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format3(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format("\\", pathObject);
}
function parse2(path6) {
  assertPath(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = 1;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path6.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path6.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl(path6) {
  if (!isAbsolute(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// deno:https://deno.land/std@0.147.0/path/posix.ts
var posix_exports = {};
__export(posix_exports, {
  basename: () => basename2,
  delimiter: () => delimiter2,
  dirname: () => dirname2,
  extname: () => extname2,
  format: () => format4,
  fromFileUrl: () => fromFileUrl2,
  isAbsolute: () => isAbsolute2,
  join: () => join3,
  normalize: () => normalize2,
  parse: () => parse3,
  relative: () => relative2,
  resolve: () => resolve2,
  sep: () => sep2,
  toFileUrl: () => toFileUrl2,
  toNamespacedPath: () => toNamespacedPath2
});
var sep2 = "/";
var delimiter2 = ":";
function resolve2(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
    }
    assertPath(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize2(path6) {
  assertPath(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === CHAR_FORWARD_SLASH;
  path6 = normalizeString(path6, !isAbsolute7, "/", isPosixPathSeparator);
  if (path6.length === 0 && !isAbsolute7)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute7)
    return `/${path6}`;
  return path6;
}
function isAbsolute2(path6) {
  assertPath(path6);
  return path6.length > 0 && path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
}
function join3(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize2(joined);
}
function relative2(from5, to) {
  assertPath(from5);
  assertPath(to);
  if (from5 === to)
    return "";
  from5 = resolve2(from5);
  to = resolve2(to);
  if (from5 === to)
    return "";
  let fromStart = 1;
  const fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath2(path6) {
  return path6;
}
function dirname2(path6) {
  assertPath(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename2(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname2(path6) {
  assertPath(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format4(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format("/", pathObject);
}
function parse3(path6) {
  assertPath(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path6.length === 0)
    return ret;
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  let start;
  if (isAbsolute7) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute7) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute7) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute7)
    ret.dir = "/";
  return ret;
}
function fromFileUrl2(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl2(path6) {
  if (!isAbsolute2(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}

// deno:https://deno.land/std@0.147.0/path/glob.ts
var path = isWindows ? win32_exports : posix_exports;
var { join: join4, normalize: normalize3 } = path;

// deno:https://deno.land/std@0.147.0/path/mod.ts
var path2 = isWindows ? win32_exports : posix_exports;
var {
  basename: basename3,
  delimiter: delimiter3,
  dirname: dirname3,
  extname: extname3,
  format: format5,
  fromFileUrl: fromFileUrl3,
  isAbsolute: isAbsolute3,
  join: join5,
  normalize: normalize4,
  parse: parse4,
  relative: relative3,
  resolve: resolve3,
  sep: sep3,
  toFileUrl: toFileUrl3,
  toNamespacedPath: toNamespacedPath3
} = path2;

// deno:https://deno.land/std@0.147.0/node/_process/process.ts
function _arch() {
  if (Deno.build.arch == "x86_64") {
    return "x64";
  } else if (Deno.build.arch == "aarch64") {
    return "arm64";
  } else {
    throw Error("unreachable");
  }
}
var arch = _arch();
var chdir = Deno.chdir;
var cwd = Deno.cwd;
var nextTick3 = nextTick2;
var env = new Proxy({}, {
  get(_target, prop) {
    return Deno.env.get(String(prop));
  },
  ownKeys: () => Reflect.ownKeys(Deno.env.toObject()),
  getOwnPropertyDescriptor: (_target, name) => {
    const e = Deno.env.toObject();
    if (name in Deno.env.toObject()) {
      const o = { enumerable: true, configurable: true };
      if (typeof name === "string") {
        o.value = e[name];
      }
      return o;
    }
  },
  set(_target, prop, value) {
    Deno.env.set(String(prop), String(value));
    return value;
  }
});
var pid = Deno.pid;
var platform = isWindows ? "win32" : Deno.build.os;
var version = "v16.11.1";
var versions = {
  node: "16.11.1",
  uv: "1.42.0",
  zlib: "1.2.11",
  brotli: "1.0.9",
  ares: "1.17.2",
  modules: "93",
  nghttp2: "1.45.1",
  napi: "8",
  llhttp: "6.0.4",
  openssl: "1.1.1l",
  cldr: "39.0",
  icu: "69.1",
  tz: "2021a",
  unicode: "13.0",
  ...Deno.version
};

// deno:https://deno.land/std@0.147.0/node/internal/readline/utils.mjs
var kEscape = "\x1B";
var kSubstringSearch = Symbol("kSubstringSearch");
function CSI(strings, ...args) {
  let ret = `${kEscape}[`;
  for (let n = 0; n < strings.length; n++) {
    ret += strings[n];
    if (n < args.length) {
      ret += args[n];
    }
  }
  return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;

// deno:https://deno.land/std@0.147.0/node/internal/readline/callbacks.mjs
var {
  kClearLine,
  kClearScreenDown,
  kClearToLineBeginning,
  kClearToLineEnd
} = CSI;
function cursorTo(stream, x, y, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (typeof y === "function") {
    callback = y;
    y = void 0;
  }
  if (Number.isNaN(x))
    throw new ERR_INVALID_ARG_VALUE("x", x);
  if (Number.isNaN(y))
    throw new ERR_INVALID_ARG_VALUE("y", y);
  if (stream == null || typeof x !== "number" && typeof y !== "number") {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  if (typeof x !== "number")
    throw new ERR_INVALID_CURSOR_POS();
  const data = typeof y !== "number" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
  return stream.write(data, callback);
}
function moveCursor(stream, dx, dy, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (stream == null || !(dx || dy)) {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  let data = "";
  if (dx < 0) {
    data += CSI`${-dx}D`;
  } else if (dx > 0) {
    data += CSI`${dx}C`;
  }
  if (dy < 0) {
    data += CSI`${-dy}A`;
  } else if (dy > 0) {
    data += CSI`${dy}B`;
  }
  return stream.write(data, callback);
}
function clearLine(stream, dir, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (stream === null || stream === void 0) {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  const type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;
  return stream.write(type, callback);
}
function clearScreenDown(stream, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (stream === null || stream === void 0) {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  return stream.write(kClearScreenDown, callback);
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/_utils.ts
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/end-of-stream.mjs
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
  return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
  return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
  return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
  if (stream.writableFinished)
    return true;
  const wState = stream._writableState;
  if (!wState || wState.errored)
    return false;
  return wState.finished || wState.ended && wState.length === 0;
}
var nop = () => {
};
function isReadableEnded(stream) {
  if (stream.readableEnded)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  } else if (options == null) {
    options = {};
  } else {
    validateObject(options, "options");
  }
  validateFunction(callback, "callback");
  validateAbortSignal(options.signal, "options.signal");
  callback = once(callback);
  const readable = options.readable || options.readable !== false && isReadable(stream);
  const writable = options.writable || options.writable !== false && isWritable(stream);
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  const onlegacyfinish = () => {
    if (!stream.writable)
      onfinish();
  };
  let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
  let writableFinished = stream.writableFinished || wState && wState.finished;
  const onfinish = () => {
    writableFinished = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.readable || readable))
      return;
    if (!readable || readableEnded)
      callback.call(stream);
  };
  let readableEnded = stream.readableEnded || rState && rState.endEmitted;
  const onend = () => {
    readableEnded = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.writable || writable))
      return;
    if (!writable || writableFinished)
      callback.call(stream);
  };
  const onerror = (err) => {
    callback.call(stream, err);
  };
  const onclose = () => {
    if (readable && !readableEnded) {
      if (!isReadableEnded(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    callback.call(stream);
  };
  const onrequest = () => {
    stream.req.on("finish", onfinish);
  };
  if (isRequest(stream)) {
    stream.on("complete", onfinish);
    if (!willEmitClose) {
      stream.on("abort", onclose);
    }
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !wState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  if (!willEmitClose && typeof stream.aborted === "boolean") {
    stream.on("aborted", onclose);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (options.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  const closed = !wState && !rState && stream._closed === true || (wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted));
  if (closed) {
    nextTick3(() => {
      callback();
    });
  }
  const cleanup = () => {
    callback = nop;
    stream.removeListener("aborted", onclose);
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
  if (options.signal && !closed) {
    const abort = () => {
      const endCallback = callback;
      cleanup();
      endCallback.call(stream, new AbortError());
    };
    if (options.signal.aborted) {
      nextTick3(abort);
    } else {
      const originalCallback = callback;
      callback = once((...args) => {
        options.signal.removeEventListener("abort", abort);
        originalCallback.apply(stream, args);
      });
      options.signal.addEventListener("abort", abort);
    }
  }
  return cleanup;
}
var end_of_stream_default = eos;

// deno:https://deno.land/std@0.147.0/node/internal/streams/add-abort-signal.mjs
var validateAbortSignal2 = (signal, name) => {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
};
function isStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function");
}
function addAbortSignal(signal, stream) {
  validateAbortSignal2(signal, "signal");
  if (!isStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
  }
  return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    return stream;
  }
  const onAbort = () => {
    stream.destroy(new AbortError());
  };
  if (signal.aborted) {
    onAbort();
  } else {
    signal.addEventListener("abort", onAbort);
    end_of_stream_default(stream, () => signal.removeEventListener("abort", onAbort));
  }
  return stream;
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/destroy.mjs
var kDestroy = Symbol("kDestroy");
var kConstruct = Symbol("kConstruct");
function checkError(err, w, r) {
  if (err) {
    err.stack;
    if (w && !w.errored) {
      w.errored = err;
    }
    if (r && !r.errored) {
      r.errored = err;
    }
  }
}
function destroy2(err, cb) {
  const r = this._readableState;
  const w = this._writableState;
  const s = w || r;
  if (w && w.destroyed || r && r.destroyed) {
    if (typeof cb === "function") {
      cb();
    }
    return this;
  }
  checkError(err, w, r);
  if (w) {
    w.destroyed = true;
  }
  if (r) {
    r.destroyed = true;
  }
  if (!s.constructed) {
    this.once(kDestroy, function(er) {
      _destroy(this, aggregateTwoErrors(er, err), cb);
    });
  } else {
    _destroy(this, err, cb);
  }
  return this;
}
function _destroy(self2, err, cb) {
  let called = false;
  function onDestroy(err2) {
    if (called) {
      return;
    }
    called = true;
    const r = self2._readableState;
    const w = self2._writableState;
    checkError(err2, w, r);
    if (w) {
      w.closed = true;
    }
    if (r) {
      r.closed = true;
    }
    if (typeof cb === "function") {
      cb(err2);
    }
    if (err2) {
      nextTick3(emitErrorCloseNT, self2, err2);
    } else {
      nextTick3(emitCloseNT, self2);
    }
  }
  try {
    const result = self2._destroy(err || null, onDestroy);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onDestroy, null);
        }, function(err2) {
          nextTick3(onDestroy, err2);
        });
      }
    }
  } catch (err2) {
    onDestroy(err2);
  }
}
function emitErrorCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  const r = self2._readableState;
  const w = self2._writableState;
  if (w) {
    w.closeEmitted = true;
  }
  if (r) {
    r.closeEmitted = true;
  }
  if (w && w.emitClose || r && r.emitClose) {
    self2.emit("close");
  }
}
function emitErrorNT(self2, err) {
  const r = self2._readableState;
  const w = self2._writableState;
  if (w && w.errorEmitted || r && r.errorEmitted) {
    return;
  }
  if (w) {
    w.errorEmitted = true;
  }
  if (r) {
    r.errorEmitted = true;
  }
  self2.emit("error", err);
}
function undestroy() {
  const r = this._readableState;
  const w = this._writableState;
  if (r) {
    r.constructed = true;
    r.closed = false;
    r.closeEmitted = false;
    r.destroyed = false;
    r.errored = null;
    r.errorEmitted = false;
    r.reading = false;
    r.ended = false;
    r.endEmitted = false;
  }
  if (w) {
    w.constructed = true;
    w.destroyed = false;
    w.closed = false;
    w.closeEmitted = false;
    w.errored = null;
    w.errorEmitted = false;
    w.ended = false;
    w.ending = false;
    w.finalCalled = false;
    w.prefinished = false;
    w.finished = false;
  }
}
function errorOrDestroy(stream, err, sync) {
  const r = stream._readableState;
  const w = stream._writableState;
  if (w && w.destroyed || r && r.destroyed) {
    return this;
  }
  if (r && r.autoDestroy || w && w.autoDestroy) {
    stream.destroy(err);
  } else if (err) {
    err.stack;
    if (w && !w.errored) {
      w.errored = err;
    }
    if (r && !r.errored) {
      r.errored = err;
    }
    if (sync) {
      nextTick3(emitErrorNT, stream, err);
    } else {
      emitErrorNT(stream, err);
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== "function") {
    return;
  }
  const r = stream._readableState;
  const w = stream._writableState;
  if (r) {
    r.constructed = false;
  }
  if (w) {
    w.constructed = false;
  }
  stream.once(kConstruct, cb);
  if (stream.listenerCount(kConstruct) > 1) {
    return;
  }
  nextTick3(constructNT, stream);
}
function constructNT(stream) {
  let called = false;
  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    const r = stream._readableState;
    const w = stream._writableState;
    const s = w || r;
    if (r) {
      r.constructed = true;
    }
    if (w) {
      w.constructed = true;
    }
    if (s.destroyed) {
      stream.emit(kDestroy, err);
    } else if (err) {
      errorOrDestroy(stream, err, true);
    } else {
      nextTick3(emitConstructNT, stream);
    }
  }
  try {
    const result = stream._construct(onConstruct);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onConstruct, null);
        }, function(err) {
          nextTick3(onConstruct, err);
        });
      }
    }
  } catch (err) {
    onConstruct(err);
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct);
}
function isRequest2(stream) {
  return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
  if (!stream)
    return;
  if (isRequest2(stream))
    return stream.abort();
  if (isRequest2(stream.req))
    return stream.req.abort();
  if (typeof stream.destroy === "function")
    return stream.destroy(err);
  if (typeof stream.close === "function")
    return stream.close();
}
var destroy_default = {
  construct,
  destroyer,
  destroy: destroy2,
  undestroy,
  errorOrDestroy
};

// deno:https://deno.land/std@0.147.0/node/internal/streams/utils.mjs
var kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function" && typeof obj2.on === "function" && (!obj2._writableState || obj2._readableState?.readable !== false) && (!obj2._writableState || obj2._readableState));
}
function isWritableNodeStream(obj2) {
  return !!(obj2 && typeof obj2.write === "function" && typeof obj2.on === "function" && (!obj2._readableState || obj2._writableState?.writable !== false));
}
function isDuplexNodeStream(obj2) {
  return !!(obj2 && (typeof obj2.pipe === "function" && obj2._readableState) && typeof obj2.on === "function" && typeof obj2.write === "function");
}
function isNodeStream(obj2) {
  return obj2 && (obj2._readableState || obj2._writableState || typeof obj2.write === "function" && typeof obj2.on === "function" || typeof obj2.pipe === "function" && typeof obj2.on === "function");
}
function isIterable(obj2, isAsync) {
  if (obj2 == null)
    return false;
  if (isAsync === true)
    return typeof obj2[Symbol.asyncIterator] === "function";
  if (isAsync === false)
    return typeof obj2[Symbol.iterator] === "function";
  return typeof obj2[Symbol.asyncIterator] === "function" || typeof obj2[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
  if (!isNodeStream(stream))
    return null;
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream))
    return null;
  if (stream.writableEnded === true)
    return true;
  const wState = stream._writableState;
  if (wState?.errored)
    return false;
  if (typeof wState?.ended !== "boolean")
    return null;
  return wState.ended;
}
function isReadableEnded2(stream) {
  if (!isReadableNodeStream(stream))
    return null;
  if (stream.readableEnded === true)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  if (typeof rState?.ended !== "boolean")
    return null;
  return rState.ended;
}
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream))
    return null;
  const rState = stream._readableState;
  if (rState?.errored)
    return false;
  if (typeof rState?.endEmitted !== "boolean")
    return null;
  return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
  return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable2(stream) {
  const r = isReadableNodeStream(stream);
  if (r === null || typeof stream?.readable !== "boolean")
    return null;
  if (isDestroyed(stream))
    return false;
  return r && stream.readable && !isReadableFinished(stream);
}
function isWritable2(stream) {
  const r = isWritableNodeStream(stream);
  if (r === null || typeof stream?.writable !== "boolean")
    return null;
  if (isDestroyed(stream))
    return false;
  return r && stream.writable && !isWritableEnded(stream);
}

// deno:https://deno.land/std@0.147.0/node/_process/stdio.mjs
var stdio = {};

// deno:https://deno.land/std@0.147.0/node/internal/blob.mjs
function isBlob(object) {
  return object instanceof Blob;
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/from.mjs
function _from2(Readable2, iterable, opts) {
  let iterator;
  if (typeof iterable === "string" || iterable instanceof Buffer3) {
    return new Readable2({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable);
        this.push(null);
      }
    });
  }
  let isAsync;
  if (iterable && iterable[Symbol.asyncIterator]) {
    isAsync = true;
    iterator = iterable[Symbol.asyncIterator]();
  } else if (iterable && iterable[Symbol.iterator]) {
    isAsync = false;
    iterator = iterable[Symbol.iterator]();
  } else {
    throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
  }
  const readable = new Readable2({
    objectMode: true,
    highWaterMark: 1,
    ...opts
  });
  let reading = false;
  readable._read = function() {
    if (!reading) {
      reading = true;
      next();
    }
  };
  readable._destroy = function(error3, cb) {
    close(error3).then(() => nextTick3(cb, error3), (e) => nextTick3(cb, e || error3));
  };
  async function close(error3) {
    const hadError = error3 !== void 0 && error3 !== null;
    const hasThrow = typeof iterator.throw === "function";
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error3);
      await value;
      if (done) {
        return;
      }
    }
    if (typeof iterator.return === "function") {
      const { value } = await iterator.return();
      await value;
    }
  }
  async function next() {
    for (; ; ) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next();
        if (done) {
          readable.push(null);
        } else {
          const res = value && typeof value.then === "function" ? await value : value;
          if (res === null) {
            reading = false;
            throw new ERR_STREAM_NULL_VALUES();
          } else if (readable.push(res)) {
            continue;
          } else {
            reading = false;
          }
        }
      } catch (err) {
        readable.destroy(err);
      }
      break;
    }
  }
  return readable;
}
var from_default = _from2;

// deno:https://deno.land/std@0.147.0/node/internal/streams/state.mjs
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!Number.isInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
      throw new ERR_INVALID_ARG_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return getDefaultHighWaterMark(state.objectMode);
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/legacy.mjs
function Stream(opts) {
  events_default.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, events_default.prototype);
Object.setPrototypeOf(Stream, events_default);
Stream.prototype.pipe = function(dest, options) {
  const source = this;
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause();
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  let didOnEnd = false;
  function onend() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (events_default.listenerCount(this, "error") === 0) {
      this.emit("error", er);
    }
  }
  prependListener2(source, "error", onerror);
  prependListener2(dest, "error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  }
  if (!emitter._events || !emitter._events[event]) {
    emitter.on(event, fn);
  } else if (Array.isArray(emitter._events[event])) {
    emitter._events[event].unshift(fn);
  } else {
    emitter._events[event] = [fn, emitter._events[event]];
  }
}

// deno:https://deno.land/std@0.147.0/node/string_decoder.ts
var NotImplemented = /* @__PURE__ */ ((NotImplemented2) => {
  NotImplemented2[NotImplemented2["ascii"] = 0] = "ascii";
  NotImplemented2[NotImplemented2["latin1"] = 1] = "latin1";
  NotImplemented2[NotImplemented2["utf16le"] = 2] = "utf16le";
  return NotImplemented2;
})(NotImplemented || {});
function normalizeEncoding3(enc) {
  const encoding = normalizeEncoding(enc ?? null);
  if (encoding && encoding in NotImplemented)
    notImplemented(encoding);
  if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
    throw new Error(`Unknown encoding: ${enc}`);
  }
  return String(encoding);
}
function utf8CheckByte(byte) {
  if (byte <= 127)
    return 0;
  else if (byte >> 5 === 6)
    return 2;
  else if (byte >> 4 === 14)
    return 3;
  else if (byte >> 3 === 30)
    return 4;
  return byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self2, buf, i) {
  let j = buf.length - 1;
  if (j < i)
    return 0;
  let nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self2, buf) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "\uFFFD";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "\uFFFD";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}
function utf8FillLastComplete(buf) {
  const p = this.lastTotal - this.lastNeed;
  const r = utf8CheckExtraBytes(this, buf);
  if (r !== void 0)
    return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
  const total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  const end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i, end);
}
function utf8End(buf) {
  const r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r + "\uFFFD";
  return r;
}
function utf8Write2(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  if (buf.length === 0)
    return "";
  let r;
  let i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || "";
}
function base64Text(buf, i) {
  const n = (buf.length - i) % 3;
  if (n === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
  const r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  }
  return r;
}
function simpleWrite(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var StringDecoderBase = class {
  constructor(encoding, nb) {
    this.encoding = encoding;
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer3.allocUnsafe(nb);
  }
};
var Base64Decoder = class extends StringDecoderBase {
  constructor(encoding) {
    super(normalizeEncoding3(encoding), 3);
    this.end = base64End;
    this.fillLast = utf8FillLastIncomplete;
    this.text = base64Text;
    this.write = utf8Write2;
  }
};
var GenericDecoder = class extends StringDecoderBase {
  constructor(encoding) {
    super(normalizeEncoding3(encoding), 4);
    this.end = simpleEnd;
    this.fillLast = void 0;
    this.text = utf8Text;
    this.write = simpleWrite;
  }
};
var Utf8Decoder = class extends StringDecoderBase {
  constructor(encoding) {
    super(normalizeEncoding3(encoding), 4);
    this.end = utf8End;
    this.fillLast = utf8FillLastComplete;
    this.text = utf8Text;
    this.write = utf8Write2;
  }
};
var StringDecoder = class {
  constructor(encoding) {
    let decoder2;
    switch (encoding) {
      case "utf8":
        decoder2 = new Utf8Decoder(encoding);
        break;
      case "base64":
        decoder2 = new Base64Decoder(encoding);
        break;
      default:
        decoder2 = new GenericDecoder(encoding);
    }
    this.encoding = decoder2.encoding;
    this.end = decoder2.end;
    this.fillLast = decoder2.fillLast;
    this.lastChar = decoder2.lastChar;
    this.lastNeed = decoder2.lastNeed;
    this.lastTotal = decoder2.lastTotal;
    this.text = decoder2.text;
    this.write = decoder2.write;
  }
};
var PStringDecoder = new Proxy(StringDecoder, {
  apply(_target, thisArg, args) {
    return Object.assign(thisArg, new StringDecoder(...args));
  }
});
var string_decoder_default2 = { StringDecoder: PStringDecoder };

// deno:https://deno.land/std@0.147.0/node/internal/streams/buffer_list.mjs
var BufferList = class {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(v) {
    const entry = { data: v, next: null };
    if (this.length > 0) {
      this.tail.next = entry;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    ++this.length;
  }
  unshift(v) {
    const entry = { data: v, next: this.head };
    if (this.length === 0) {
      this.tail = entry;
    }
    this.head = entry;
    ++this.length;
  }
  shift() {
    if (this.length === 0) {
      return;
    }
    const ret = this.head.data;
    if (this.length === 1) {
      this.head = this.tail = null;
    } else {
      this.head = this.head.next;
    }
    --this.length;
    return ret;
  }
  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }
  join(s) {
    if (this.length === 0) {
      return "";
    }
    let p = this.head;
    let ret = "" + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }
    return ret;
  }
  concat(n) {
    if (this.length === 0) {
      return Buffer3.alloc(0);
    }
    const ret = Buffer3.allocUnsafe(n >>> 0);
    let p = this.head;
    let i = 0;
    while (p) {
      ret.set(p.data, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  }
  consume(n, hasStrings) {
    const data = this.head.data;
    if (n < data.length) {
      const slice5 = data.slice(0, n);
      this.head.data = data.slice(n);
      return slice5;
    }
    if (n === data.length) {
      return this.shift();
    }
    return hasStrings ? this._getString(n) : this._getBuffer(n);
  }
  first() {
    return this.head.data;
  }
  *[Symbol.iterator]() {
    for (let p = this.head; p; p = p.next) {
      yield p.data;
    }
  }
  _getString(n) {
    let ret = "";
    let p = this.head;
    let c = 0;
    do {
      const str = p.data;
      if (n > str.length) {
        ret += str;
        n -= str.length;
      } else {
        if (n === str.length) {
          ret += str;
          ++c;
          if (p.next) {
            this.head = p.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret += str.slice(0, n);
          this.head = p;
          p.data = str.slice(n);
        }
        break;
      }
      ++c;
    } while (p = p.next);
    this.length -= c;
    return ret;
  }
  _getBuffer(n) {
    const ret = Buffer3.allocUnsafe(n);
    const retLen = n;
    let p = this.head;
    let c = 0;
    do {
      const buf = p.data;
      if (n > buf.length) {
        ret.set(buf, retLen - n);
        n -= buf.length;
      } else {
        if (n === buf.length) {
          ret.set(buf, retLen - n);
          ++c;
          if (p.next) {
            this.head = p.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
          this.head = p;
          p.data = buf.slice(n);
        }
        break;
      }
      ++c;
    } while (p = p.next);
    this.length -= c;
    return ret;
  }
  [inspect.custom](_, options) {
    return inspect(this, {
      ...options,
      depth: 0,
      customInspect: false
    });
  }
};
var buffer_list_default = BufferList;

// deno:https://deno.land/std@0.147.0/node/internal/streams/readable.mjs
var debug = debuglog("stream", (fn) => {
  debug = fn;
});
var kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
var nop2 = () => {
};
var { errorOrDestroy: errorOrDestroy2 } = destroy_default;
function ReadableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = stream instanceof Stream.Duplex;
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = [];
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.constructed = true;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this[kPaused] = null;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.destroyed = false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.awaitDrainWriters = null;
  this.multiAwaitDrain = false;
  this.readingMore = false;
  this.dataEmitted = false;
  this.decoder = null;
  this.encoding = null;
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  }
  const isDuplex = this instanceof Stream.Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);
  if (options) {
    if (typeof options.read === "function") {
      this._read = options.read;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal && !isDuplex) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  destroy_default.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState);
    }
  });
}
Readable.prototype.destroy = destroy_default.destroy;
Readable.prototype._undestroy = destroy_default.undestroy;
Readable.prototype._destroy = function(err, cb) {
  cb(err);
};
Readable.prototype[events_default.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
  debug("readableAddChunk", chunk);
  const state = stream._readableState;
  let err;
  if (!state.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
        } else {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
      }
    } else if (chunk instanceof Buffer3) {
      encoding = "";
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk);
      encoding = "";
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
  }
  if (err) {
    errorOrDestroy2(stream, err);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (addToFront) {
      if (state.endEmitted) {
        errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
      } else {
        addChunk(stream, state, chunk, true);
      }
    } else if (state.ended) {
      errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
    } else if (state.destroyed || state.errored) {
      return false;
    } else {
      state.reading = false;
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk);
        if (state.objectMode || chunk.length !== 0) {
          addChunk(stream, state, chunk, false);
        } else {
          maybeReadMore(stream, state);
        }
      } else {
        addChunk(stream, state, chunk, false);
      }
    }
  } else if (!addToFront) {
    state.reading = false;
    maybeReadMore(stream, state);
  }
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
    state.dataEmitted = true;
    stream.emit("data", chunk);
  } else {
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) {
      state.buffer.unshift(chunk);
    } else {
      state.buffer.push(chunk);
    }
    if (state.needReadable) {
      emitReadable(stream);
    }
  }
  maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
  const state = this._readableState;
  return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
  const decoder2 = new StringDecoder(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  const buffer = this._readableState.buffer;
  let content = "";
  for (const data of buffer) {
    content += decoder2.write(data);
  }
  buffer.clear();
  if (content !== "") {
    buffer.push(content);
  }
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) {
    return 0;
  }
  if (state.objectMode) {
    return 1;
  }
  if (Number.isNaN(n)) {
    if (state.flowing && state.length) {
      return state.buffer.first().length;
    }
    return state.length;
  }
  if (n <= state.length) {
    return n;
  }
  return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n) {
  debug("read", n);
  if (n === void 0) {
    n = NaN;
  } else if (!Number.isInteger(n)) {
    n = Number.parseInt(n, 10);
  }
  const state = this._readableState;
  const nOrig = n;
  if (n > state.highWaterMark) {
    state.highWaterMark = computeNewHighWaterMark(n);
  }
  if (n !== 0) {
    state.emittedReadable = false;
  }
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended) {
      endReadable(this);
    } else {
      emitReadable(this);
    }
    return null;
  }
  n = howMuchToRead(n, state);
  if (n === 0 && state.ended) {
    if (state.length === 0) {
      endReadable(this);
    }
    return null;
  }
  let doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false;
    debug("reading, ended or constructing", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0) {
      state.needReadable = true;
    }
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading) {
      n = howMuchToRead(nOrig, state);
    }
  }
  let ret;
  if (n > 0) {
    ret = fromList(n, state);
  } else {
    ret = null;
  }
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
  }
  if (state.length === 0) {
    if (!state.ended) {
      state.needReadable = true;
    }
    if (nOrig !== n && state.ended) {
      endReadable(this);
    }
  }
  if (ret !== null) {
    state.dataEmitted = true;
    this.emit("data", ret);
  }
  return ret;
};
function onEofChunk(stream, state) {
  debug("onEofChunk");
  if (state.ended)
    return;
  if (state.decoder) {
    const chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    emitReadable(stream);
  } else {
    state.needReadable = false;
    state.emittedReadable = true;
    emitReadable_(stream);
  }
}
function emitReadable(stream) {
  const state = stream._readableState;
  debug("emitReadable", state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    nextTick2(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  const state = stream._readableState;
  debug("emitReadable_", state.destroyed, state.length, state.ended);
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit("readable");
    state.emittedReadable = false;
  }
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    const len = state.length;
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length) {
      break;
    }
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  const src = this;
  const state = this._readableState;
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true;
      state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
    }
  }
  state.pipes.push(dest);
  debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
  const endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) {
    nextTick2(endFn);
  } else {
    src.once("end", endFn);
  }
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug("onend");
    dest.end();
  }
  let ondrain;
  let cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    if (ondrain) {
      dest.removeListener("drain", ondrain);
    }
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
      ondrain();
    }
  }
  function pause() {
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug("false write response, pause", 0);
        state.awaitDrainWriters = dest;
        state.multiAwaitDrain = false;
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug("false write response, pause", state.awaitDrainWriters.size);
        state.awaitDrainWriters.add(dest);
      }
      src.pause();
    }
    if (!ondrain) {
      ondrain = pipeOnDrain(src, dest);
      dest.on("drain", ondrain);
    }
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    const ret = dest.write(chunk);
    debug("dest.write", ret);
    if (ret === false) {
      pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (events_default.listenerCount(dest, "error") === 0) {
      const s = dest._writableState || dest._readableState;
      if (s && !s.errorEmitted) {
        errorOrDestroy2(dest, er);
      } else {
        dest.emit("error", er);
      }
    }
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause();
    }
  } else if (!state.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState;
    if (state.awaitDrainWriters === dest) {
      debug("pipeOnDrain", 1);
      state.awaitDrainWriters = null;
    } else if (state.multiAwaitDrain) {
      debug("pipeOnDrain", state.awaitDrainWriters.size);
      state.awaitDrainWriters.delete(dest);
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && events_default.listenerCount(src, "data")) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  const state = this._readableState;
  const unpipeInfo = { hasUnpiped: false };
  if (state.pipes.length === 0) {
    return this;
  }
  if (!dest) {
    const dests = state.pipes;
    state.pipes = [];
    this.pause();
    for (let i = 0; i < dests.length; i++) {
      dests[i].emit("unpipe", this, { hasUnpiped: false });
    }
    return this;
  }
  const index = state.pipes.indexOf(dest);
  if (index === -1) {
    return this;
  }
  state.pipes.splice(index, 1);
  if (state.pipes.length === 0) {
    this.pause();
  }
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);
  const state = this._readableState;
  if (ev === "data") {
    state.readableListening = this.listenerCount("readable") > 0;
    if (state.flowing !== false) {
      this.resume();
    }
  } else if (ev === "readable") {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug("on readable", state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        nextTick2(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    nextTick2(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    nextTick2(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  const state = self2._readableState;
  state.readableListening = self2.listenerCount("readable") > 0;
  if (state.resumeScheduled && state[kPaused] === false) {
    state.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  } else if (!state.readableListening) {
    state.flowing = null;
  }
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  const state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state[kPaused] = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug("resume", state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading) {
    stream.read(0);
  }
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState[kPaused] = true;
  return this;
};
function flow(stream) {
  const state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null)
    ;
}
Readable.prototype.wrap = function(stream) {
  let paused = false;
  stream.on("data", (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true;
      stream.pause();
    }
  });
  stream.on("end", () => {
    this.push(null);
  });
  stream.on("error", (err) => {
    errorOrDestroy2(this, err);
  });
  stream.on("close", () => {
    this.destroy();
  });
  stream.on("destroy", () => {
    this.destroy();
  });
  this._read = () => {
    if (paused && stream.resume) {
      paused = false;
      stream.resume();
    }
  };
  const streamKeys = Object.keys(stream);
  for (let j = 1; j < streamKeys.length; j++) {
    const i = streamKeys[j];
    if (this[i] === void 0 && typeof stream[i] === "function") {
      this[i] = stream[i].bind(stream);
    }
  }
  return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
  return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
  if (options !== void 0) {
    validateObject(options, "options");
  }
  return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== "function") {
    stream = Readable.wrap(stream, { objectMode: true });
  }
  const iter = createAsyncIterator(stream, options);
  iter.stream = stream;
  return iter;
}
async function* createAsyncIterator(stream, options) {
  let callback = nop2;
  const opts = {
    destroyOnReturn: true,
    destroyOnError: true,
    ...options
  };
  function next(resolve7) {
    if (this === stream) {
      callback();
      callback = nop2;
    } else {
      callback = resolve7;
    }
  }
  const state = stream._readableState;
  let error3 = state.errored;
  let errorEmitted = state.errorEmitted;
  let endEmitted = state.endEmitted;
  let closeEmitted = state.closeEmitted;
  stream.on("readable", next).on("error", function(err) {
    error3 = err;
    errorEmitted = true;
    next.call(this);
  }).on("end", function() {
    endEmitted = true;
    next.call(this);
  }).on("close", function() {
    closeEmitted = true;
    next.call(this);
  });
  let errorThrown = false;
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read();
      if (chunk !== null) {
        yield chunk;
      } else if (errorEmitted) {
        throw error3;
      } else if (endEmitted) {
        break;
      } else if (closeEmitted) {
        break;
      } else {
        await new Promise(next);
      }
    }
  } catch (err) {
    if (opts.destroyOnError) {
      destroy_default.destroyer(stream, err);
    }
    errorThrown = true;
    throw err;
  } finally {
    if (!errorThrown && opts.destroyOnReturn) {
      if (state.autoDestroy || !endEmitted) {
        destroy_default.destroyer(stream, null);
      }
    }
  }
}
Object.defineProperties(Readable.prototype, {
  readable: {
    get() {
      const r = this._readableState;
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
    },
    set(val) {
      if (this._readableState) {
        this._readableState.readable = !!val;
      }
    }
  },
  readableDidRead: {
    enumerable: false,
    get: function() {
      return this._readableState.dataEmitted;
    }
  },
  readableAborted: {
    enumerable: false,
    get: function() {
      return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
    }
  },
  readableHighWaterMark: {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  },
  readableBuffer: {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  },
  readableFlowing: {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  },
  readableLength: {
    enumerable: false,
    get() {
      return this._readableState.length;
    }
  },
  readableObjectMode: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false;
    }
  },
  readableEncoding: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null;
    }
  },
  destroyed: {
    enumerable: false,
    get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  },
  readableEnded: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false;
    }
  }
});
Object.defineProperties(ReadableState.prototype, {
  pipesCount: {
    get() {
      return this.pipes.length;
    }
  },
  paused: {
    get() {
      return this[kPaused] !== false;
    },
    set(value) {
      this[kPaused] = !!value;
    }
  }
});
function fromList(n, state) {
  if (state.length === 0) {
    return null;
  }
  let ret;
  if (state.objectMode) {
    ret = state.buffer.shift();
  } else if (!n || n >= state.length) {
    if (state.decoder) {
      ret = state.buffer.join("");
    } else if (state.buffer.length === 1) {
      ret = state.buffer.first();
    } else {
      ret = state.buffer.concat(state.length);
    }
    state.buffer.clear();
  } else {
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  const state = stream._readableState;
  debug("endReadable", state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug("endReadableNT", state.endEmitted, state.length);
  if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.emit("end");
    if (stream.writable && stream.allowHalfOpen === false) {
      nextTick2(endWritableNT, stream);
    } else if (state.autoDestroy) {
      const wState = stream._writableState;
      const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
  if (writable) {
    stream.end();
  }
}
function readableFrom(iterable, opts) {
  return from_default(Readable, iterable, opts);
}
function wrap(src, options) {
  return new Readable({
    objectMode: src.readableObjectMode ?? src.objectMode ?? true,
    ...options,
    destroy(err, callback) {
      destroy_default.destroyer(src, err);
      callback(err);
    }
  }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
var readable_default = Readable;

// deno:https://deno.land/std@0.147.0/node/internal/streams/writable.mjs
var { errorOrDestroy: errorOrDestroy3 } = destroy_default;
function isDuplexStream(maybe_duplex) {
  const isReadable3 = readable_default.prototype.isPrototypeOf(maybe_duplex);
  let prototype = maybe_duplex;
  let isDuplex = false;
  while (prototype?.constructor && prototype.constructor.name !== "Object") {
    if (prototype.constructor.name === "Duplex") {
      isDuplex = true;
      break;
    }
    prototype = Object.getPrototypeOf(prototype);
  }
  return isReadable3 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop3() {
}
var kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = isDuplexStream(stream);
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  const noDecode = !!(options && options.decodeStrings === false);
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = onwrite.bind(void 0, stream);
  this.writecb = null;
  this.writelen = 0;
  this.afterWriteTickInfo = null;
  resetBuffer(this);
  this.pendingcb = 0;
  this.constructed = true;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this[kOnFinished] = [];
}
function resetBuffer(state) {
  state.buffered = [];
  state.bufferedIndex = 0;
  state.allBuffers = true;
  state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
  return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
  get() {
    return this.buffered.length - this.bufferedIndex;
  }
});
function Writable(options) {
  const isDuplex = isDuplexStream(this);
  if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
    return new Writable(options);
  }
  this._writableState = new WritableState(options, this, isDuplex);
  if (options) {
    if (typeof options.write === "function") {
      this._write = options.write;
    }
    if (typeof options.writev === "function") {
      this._writev = options.writev;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.final === "function") {
      this._final = options.final;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  destroy_default.construct(this, () => {
    const state = this._writableState;
    if (!state.writing) {
      clearBuffer(this, state);
    }
    finishMaybe(this, state);
  });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
  value: function(object) {
    if (Function.prototype[Symbol.hasInstance].call(this, object))
      return true;
    if (this !== Writable)
      return false;
    return object && object._writableState instanceof WritableState;
  }
});
Writable.prototype.pipe = function() {
  errorOrDestroy3(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = state.defaultEncoding;
  } else {
    if (!encoding) {
      encoding = state.defaultEncoding;
    } else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) {
      throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    if (typeof cb !== "function") {
      cb = nop3;
    }
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES();
  } else if (!state.objectMode) {
    if (typeof chunk === "string") {
      if (state.decodeStrings !== false) {
        chunk = Buffer3.from(chunk, encoding);
        encoding = "buffer";
      }
    } else if (chunk instanceof Buffer3) {
      encoding = "buffer";
    } else if (isUint8Array(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
      encoding = "buffer";
    } else {
      throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
  }
  let err;
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END();
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED("write");
  }
  if (err) {
    nextTick3(cb, err);
    errorOrDestroy3(stream, err, true);
    return err;
  }
  state.pendingcb++;
  return writeOrBuffer(stream, state, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
  this._writableState.corked++;
};
Writable.prototype.uncork = function() {
  const state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing) {
      clearBuffer(this, state);
    }
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") {
    encoding = encoding.toLowerCase();
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new ERR_UNKNOWN_ENCODING(encoding);
  }
  this._writableState.defaultEncoding = encoding;
  return this;
};
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  const ret = state.length < state.highWaterMark;
  if (!ret) {
    state.needDrain = true;
  }
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({ chunk, encoding, callback });
    if (state.allBuffers && encoding !== "buffer") {
      state.allBuffers = false;
    }
    if (state.allNoop && callback !== nop3) {
      state.allNoop = false;
    }
  } else {
    state.writelen = len;
    state.writecb = callback;
    state.writing = true;
    state.sync = true;
    stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) {
    state.onwrite(new ERR_STREAM_DESTROYED("write"));
  } else if (writev) {
    stream._writev(chunk, state.onwrite);
  } else {
    stream._write(chunk, encoding, state.onwrite);
  }
  state.sync = false;
}
function onwriteError(stream, state, er, cb) {
  --state.pendingcb;
  cb(er);
  errorBuffer(state);
  errorOrDestroy3(stream, er);
}
function onwrite(stream, er) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;
  if (typeof cb !== "function") {
    errorOrDestroy3(stream, new ERR_MULTIPLE_CALLBACK());
    return;
  }
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
  if (er) {
    er.stack;
    if (!state.errored) {
      state.errored = er;
    }
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er;
    }
    if (sync) {
      nextTick3(onwriteError, stream, state, er, cb);
    } else {
      onwriteError(stream, state, er, cb);
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state);
    }
    if (sync) {
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++;
      } else {
        state.afterWriteTickInfo = { count: 1, cb, stream, state };
        nextTick3(afterWriteTick, state.afterWriteTickInfo);
      }
    } else {
      afterWrite(stream, state, 1, cb);
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null;
  return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
  if (needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
  while (count-- > 0) {
    state.pendingcb--;
    cb();
  }
  if (state.destroyed) {
    errorBuffer(state);
  }
  finishMaybe(stream, state);
}
function errorBuffer(state) {
  if (state.writing) {
    return;
  }
  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
    const { chunk, callback } = state.buffered[n];
    const len = state.objectMode ? 1 : chunk.length;
    state.length -= len;
    callback(new ERR_STREAM_DESTROYED("write"));
  }
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i](new ERR_STREAM_DESTROYED("end"));
  }
  resetBuffer(state);
}
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return;
  }
  const { buffered, bufferedIndex, objectMode } = state;
  const bufferedLength = buffered.length - bufferedIndex;
  if (!bufferedLength) {
    return;
  }
  let i = bufferedIndex;
  state.bufferProcessing = true;
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1;
    const callback = state.allNoop ? nop3 : (err) => {
      for (let n = i; n < buffered.length; ++n) {
        buffered[n].callback(err);
      }
    };
    const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
    chunks.allBuffers = state.allBuffers;
    doWrite(stream, state, true, state.length, chunks, "", callback);
    resetBuffer(state);
  } else {
    do {
      const { chunk, encoding, callback } = buffered[i];
      buffered[i++] = null;
      const len = objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, callback);
    } while (i < buffered.length && !state.writing);
    if (i === buffered.length) {
      resetBuffer(state);
    } else if (i > 256) {
      buffered.splice(0, i);
      state.bufferedIndex = 0;
    } else {
      state.bufferedIndex = i;
    }
  }
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  if (this._writev) {
    this._writev([{ chunk, encoding }], cb);
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
  }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  const state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  let err;
  if (chunk !== null && chunk !== void 0) {
    const ret = _write(this, chunk, encoding);
    if (ret instanceof Error) {
      err = ret;
    }
  }
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (err) {
  } else if (!state.errored && !state.ending) {
    state.ending = true;
    finishMaybe(this, state, true);
    state.ended = true;
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED("end");
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED("end");
  }
  if (typeof cb === "function") {
    if (err || state.finished) {
      nextTick3(cb, err);
    } else {
      state[kOnFinished].push(cb);
    }
  }
  return this;
};
function needFinish(state) {
  return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
  let called = false;
  function onFinish(err) {
    if (called) {
      errorOrDestroy3(stream, err ?? ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    state.pendingcb--;
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err);
      }
      errorOrDestroy3(stream, err, state.sync);
    } else if (needFinish(state)) {
      state.prefinished = true;
      stream.emit("prefinish");
      state.pendingcb++;
      nextTick3(finish, stream, state);
    }
  }
  state.sync = true;
  state.pendingcb++;
  try {
    const result = stream._final(onFinish);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onFinish, null);
        }, function(err) {
          nextTick3(onFinish, err);
        });
      }
    }
  } catch (err) {
    onFinish(stream, state, err);
  }
  state.sync = false;
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === "function" && !state.destroyed) {
      state.finalCalled = true;
      callFinal(stream, state);
    } else {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state);
    if (state.pendingcb === 0 && needFinish(state)) {
      state.pendingcb++;
      if (sync) {
        nextTick3(finish, stream, state);
      } else {
        finish(stream, state);
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--;
  state.finished = true;
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]();
  }
  stream.emit("finish");
  if (state.autoDestroy) {
    const rState = stream._readableState;
    const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
    if (autoDestroy) {
      stream.destroy();
    }
  }
}
Object.defineProperties(Writable.prototype, {
  destroyed: {
    get() {
      return this._writableState ? this._writableState.destroyed : false;
    },
    set(value) {
      if (this._writableState) {
        this._writableState.destroyed = value;
      }
    }
  },
  writable: {
    get() {
      const w = this._writableState;
      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
    },
    set(val) {
      if (this._writableState) {
        this._writableState.writable = !!val;
      }
    }
  },
  writableFinished: {
    get() {
      return this._writableState ? this._writableState.finished : false;
    }
  },
  writableObjectMode: {
    get() {
      return this._writableState ? this._writableState.objectMode : false;
    }
  },
  writableBuffer: {
    get() {
      return this._writableState && this._writableState.getBuffer();
    }
  },
  writableEnded: {
    get() {
      return this._writableState ? this._writableState.ending : false;
    }
  },
  writableNeedDrain: {
    get() {
      const wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    }
  },
  writableHighWaterMark: {
    get() {
      return this._writableState && this._writableState.highWaterMark;
    }
  },
  writableCorked: {
    get() {
      return this._writableState ? this._writableState.corked : 0;
    }
  },
  writableLength: {
    get() {
      return this._writableState && this._writableState.length;
    }
  }
});
var destroy3 = destroy_default.destroy;
Writable.prototype.destroy = function(err, cb) {
  const state = this._writableState;
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    nextTick3(errorBuffer, state);
  }
  destroy3.call(this, err, cb);
  return this;
};
Writable.prototype._undestroy = destroy_default.undestroy;
Writable.prototype._destroy = function(err, cb) {
  cb(err);
};
Writable.prototype[events_default.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Writable.WritableState = WritableState;
var writable_default = Writable;

// deno:https://deno.land/std@0.147.0/node/internal/streams/duplex.mjs
Object.setPrototypeOf(Duplex.prototype, readable_default.prototype);
Object.setPrototypeOf(Duplex, readable_default);
{
  for (const method of Object.keys(writable_default.prototype)) {
    if (!Duplex.prototype[method]) {
      Duplex.prototype[method] = writable_default.prototype[method];
    }
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }
  readable_default.call(this, options);
  writable_default.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
    }
  }
}
Object.defineProperties(Duplex.prototype, {
  writable: Object.getOwnPropertyDescriptor(writable_default.prototype, "writable"),
  writableHighWaterMark: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableHighWaterMark"),
  writableObjectMode: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableObjectMode"),
  writableBuffer: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableBuffer"),
  writableLength: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableLength"),
  writableFinished: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableFinished"),
  writableCorked: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableCorked"),
  writableEnded: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableEnded"),
  writableNeedDrain: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableNeedDrain"),
  destroyed: {
    get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set(value) {
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    }
  }
});
function isReadableStream(object) {
  return object instanceof ReadableStream;
}
function isWritableStream(object) {
  return object instanceof WritableStream;
}
Duplex.fromWeb = function(pair, options) {
  validateObject(pair, "pair");
  const {
    readable: readableStream,
    writable: writableStream
  } = pair;
  if (!isReadableStream(readableStream)) {
    throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
  }
  if (!isWritableStream(writableStream)) {
    throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
  }
  validateObject(options, "options");
  const {
    allowHalfOpen = false,
    objectMode = false,
    encoding,
    decodeStrings = true,
    highWaterMark,
    signal
  } = options;
  validateBoolean(objectMode, "options.objectMode");
  if (encoding !== void 0 && !Buffer3.isEncoding(encoding)) {
    throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
  }
  const writer = writableStream.getWriter();
  const reader = readableStream.getReader();
  let writableClosed = false;
  let readableClosed = false;
  const duplex = new Duplex({
    allowHalfOpen,
    highWaterMark,
    objectMode,
    encoding,
    decodeStrings,
    signal,
    writev(chunks, callback) {
      function done(error3) {
        error3 = error3.filter((e) => e);
        try {
          callback(error3.length === 0 ? void 0 : error3);
        } catch (error4) {
          nextTick3(() => destroy(duplex, error4));
        }
      }
      writer.ready.then(() => Promise.All(chunks.map((data) => writer.write(data.chunk))).then(done, done), done);
    },
    write(chunk, encoding2, callback) {
      if (typeof chunk === "string" && decodeStrings && !objectMode) {
        chunk = Buffer3.from(chunk, encoding2);
        chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      }
      function done(error3) {
        try {
          callback(error3);
        } catch (error4) {
          destroy(duplex, error4);
        }
      }
      writer.ready.then(() => writer.write(chunk).then(done, done), done);
    },
    final(callback) {
      function done(error3) {
        try {
          callback(error3);
        } catch (error4) {
          nextTick3(() => destroy(duplex, error4));
        }
      }
      if (!writableClosed) {
        writer.close().then(done, done);
      }
    },
    read() {
      reader.read().then((chunk) => {
        if (chunk.done) {
          duplex.push(null);
        } else {
          duplex.push(chunk.value);
        }
      }, (error3) => destroy(duplex, error3));
    },
    destroy(error3, callback) {
      function done() {
        try {
          callback(error3);
        } catch (error4) {
          nextTick3(() => {
            throw error4;
          });
        }
      }
      async function closeWriter() {
        if (!writableClosed) {
          await writer.abort(error3);
        }
      }
      async function closeReader() {
        if (!readableClosed) {
          await reader.cancel(error3);
        }
      }
      if (!writableClosed || !readableClosed) {
        Promise.All([
          closeWriter(),
          closeReader()
        ]).then(done, done);
        return;
      }
      done();
    }
  });
  writer.closed.then(() => {
    writableClosed = true;
    if (!isWritableEnded(duplex)) {
      destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE());
    }
  }, (error3) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error3);
  });
  reader.closed.then(() => {
    readableClosed = true;
    if (!isReadableEnded2(duplex)) {
      duplex.push(null);
    }
  }, (error3) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error3);
  });
  return duplex;
};
var Duplexify = class extends Duplex {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body;
  }
  if (isReadableNodeStream(body)) {
    return _duplexify({ readable: body });
  }
  if (isWritableNodeStream(body)) {
    return _duplexify({ writable: body });
  }
  if (isNodeStream(body)) {
    return _duplexify({ writable: false, readable: false });
  }
  if (typeof body === "function") {
    const { value, write: write5, final: final2, destroy: destroy4 } = fromAsyncGen(body);
    if (isIterable(value)) {
      return from_default(Duplexify, value, {
        objectMode: true,
        write: write5,
        final: final2,
        destroy: destroy4
      });
    }
    const then2 = value?.then;
    if (typeof then2 === "function") {
      let d;
      const promise = then2.call(value, (val) => {
        if (val != null) {
          throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
        }
      }, (err) => {
        destroyer(d, err);
      });
      return d = new Duplexify({
        objectMode: true,
        readable: false,
        write: write5,
        final(cb) {
          final2(async () => {
            try {
              await promise;
              nextTick3(cb, null);
            } catch (err) {
              nextTick3(cb, err);
            }
          });
        },
        destroy: destroy4
      });
    }
    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
  }
  if (isBlob(body)) {
    return duplexify(body.arrayBuffer());
  }
  if (isIterable(body)) {
    return from_default(Duplexify, body, {
      objectMode: true,
      writable: false
    });
  }
  if (typeof body?.writable === "object" || typeof body?.readable === "object") {
    const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : void 0;
    const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : void 0;
    return _duplexify({ readable, writable });
  }
  const then = body?.then;
  if (typeof then === "function") {
    let d;
    then.call(body, (val) => {
      if (val != null) {
        d.push(val);
      }
      d.push(null);
    }, (err) => {
      destroyer(d, err);
    });
    return d = new Duplexify({
      objectMode: true,
      writable: false,
      read() {
      }
    });
  }
  throw new ERR_INVALID_ARG_TYPE(name, [
    "Blob",
    "ReadableStream",
    "WritableStream",
    "Stream",
    "Iterable",
    "AsyncIterable",
    "Function",
    "{ readable, writable } pair",
    "Promise"
  ], body);
}
function fromAsyncGen(fn) {
  let { promise, resolve: resolve7 } = createDeferredPromise();
  const ac = new AbortController();
  const signal = ac.signal;
  const value = fn(async function* () {
    while (true) {
      const _promise = promise;
      promise = null;
      const { chunk, done, cb } = await _promise;
      nextTick3(cb);
      if (done)
        return;
      if (signal.aborted)
        throw new AbortError();
      ({ promise, resolve: resolve7 } = createDeferredPromise());
      yield chunk;
    }
  }(), { signal });
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve7;
      resolve7 = null;
      _resolve({ chunk, done: false, cb });
    },
    final(cb) {
      const _resolve = resolve7;
      resolve7 = null;
      _resolve({ done: true, cb });
    },
    destroy(err, cb) {
      ac.abort();
      cb(err);
    }
  };
}
function _duplexify(pair) {
  const r = pair.readable && typeof pair.readable.read !== "function" ? readable_default.wrap(pair.readable) : pair.readable;
  const w = pair.writable;
  let readable = !!isReadable2(r);
  let writable = !!isWritable2(w);
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d.destroy(err);
    } else if (!readable && !writable) {
      d.destroy();
    }
  }
  d = new Duplexify({
    readableObjectMode: !!r?.readableObjectMode,
    writableObjectMode: !!w?.writableObjectMode,
    readable,
    writable
  });
  if (writable) {
    end_of_stream_default(w, (err) => {
      writable = false;
      if (err) {
        destroyer(r, err);
      }
      onfinished(err);
    });
    d._write = function(chunk, encoding, callback) {
      if (w.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d._final = function(callback) {
      w.end();
      onfinish = callback;
    };
    w.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    w.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    end_of_stream_default(r, (err) => {
      readable = false;
      if (err) {
        destroyer(r, err);
      }
      onfinished(err);
    });
    r.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    r.on("end", function() {
      d.push(null);
    });
    d._read = function() {
      while (true) {
        const buf = r.read();
        if (buf === null) {
          onreadable = d._read;
          return;
        }
        if (!d.push(buf)) {
          return;
        }
      }
    };
  }
  d._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(w, err);
      destroyer(r, err);
    }
  };
  return d;
}
function duplexFrom(body) {
  return duplexify(body, "body");
}
Duplex.from = duplexFrom;
var duplex_default = Duplex;

// deno:https://deno.land/std@0.147.0/node/internal/streams/transform.mjs
Object.setPrototypeOf(Transform.prototype, duplex_default.prototype);
Object.setPrototypeOf(Transform, duplex_default);
var kCallback = Symbol("kCallback");
function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }
  duplex_default.call(this, options);
  this._readableState.sync = false;
  this[kCallback] = null;
  if (options) {
    if (typeof options.transform === "function") {
      this._transform = options.transform;
    }
    if (typeof options.flush === "function") {
      this._flush = options.flush;
    }
  }
  this.on("prefinish", prefinish2);
}
function final(cb) {
  let called = false;
  if (typeof this._flush === "function" && !this.destroyed) {
    const result = this._flush((er, data) => {
      called = true;
      if (er) {
        if (cb) {
          cb(er);
        } else {
          this.destroy(er);
        }
        return;
      }
      if (data != null) {
        this.push(data);
      }
      this.push(null);
      if (cb) {
        cb();
      }
    });
    if (result !== void 0 && result !== null) {
      try {
        const then = result.then;
        if (typeof then === "function") {
          then.call(result, (data) => {
            if (called) {
              return;
            }
            if (data != null) {
              this.push(data);
            }
            this.push(null);
            if (cb) {
              nextTick3(cb);
            }
          }, (err) => {
            if (cb) {
              nextTick3(cb, err);
            } else {
              nextTick3(() => this.destroy(err));
            }
          });
        }
      } catch (err) {
        nextTick3(() => this.destroy(err));
      }
    }
  } else {
    this.push(null);
    if (cb) {
      cb();
    }
  }
}
function prefinish2() {
  if (this._final !== final) {
    final.call(this);
  }
}
Transform.prototype._final = final;
Transform.prototype._transform = function(chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
  const rState = this._readableState;
  const wState = this._writableState;
  const length = rState.length;
  let called = false;
  const result = this._transform(chunk, encoding, (err, val) => {
    called = true;
    if (err) {
      callback(err);
      return;
    }
    if (val != null) {
      this.push(val);
    }
    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
      callback();
    } else {
      this[kCallback] = callback;
    }
  });
  if (result !== void 0 && result != null) {
    try {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, (val) => {
          if (called) {
            return;
          }
          if (val != null) {
            this.push(val);
          }
          if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            nextTick3(callback);
          } else {
            this[kCallback] = callback;
          }
        }, (err) => {
          nextTick3(callback, err);
        });
      }
    } catch (err) {
      nextTick3(callback, err);
    }
  }
};
Transform.prototype._read = function() {
  if (this[kCallback]) {
    const callback = this[kCallback];
    this[kCallback] = null;
    callback();
  }
};
var transform_default = Transform;

// deno:https://deno.land/std@0.147.0/node/internal/streams/passthrough.mjs
Object.setPrototypeOf(PassThrough.prototype, transform_default.prototype);
Object.setPrototypeOf(PassThrough, transform_default);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) {
    return new PassThrough(options);
  }
  transform_default.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var passthrough_default = PassThrough;

// deno:https://deno.land/std@0.147.0/node/internal/streams/pipeline.mjs
function destroyer2(stream, reading, writing, callback) {
  callback = once(callback);
  let finished2 = false;
  stream.on("close", () => {
    finished2 = true;
  });
  end_of_stream_default(stream, { readable: reading, writable: writing }, (err) => {
    finished2 = !err;
    const rState = stream._readableState;
    if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && (rState && rState.ended && !rState.errored && !rState.errorEmitted)) {
      stream.once("end", callback).once("error", callback);
    } else {
      callback(err);
    }
  });
  return (err) => {
    if (finished2)
      return;
    finished2 = true;
    destroy_default.destroyer(stream, err);
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function popCallback(streams) {
  validateCallback(streams[streams.length - 1]);
  return streams.pop();
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val;
  } else if (isReadableNodeStream(val)) {
    return fromReadable(val);
  }
  throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
}
async function* fromReadable(val) {
  yield* readable_default.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish2) {
  let error3;
  let onresolve = null;
  const resume2 = (err) => {
    if (err) {
      error3 = err;
    }
    if (onresolve) {
      const callback = onresolve;
      onresolve = null;
      callback();
    }
  };
  const wait = () => new Promise((resolve7, reject) => {
    if (error3) {
      reject(error3);
    } else {
      onresolve = () => {
        if (error3) {
          reject(error3);
        } else {
          resolve7();
        }
      };
    }
  });
  writable.on("drain", resume2);
  const cleanup = end_of_stream_default(writable, { readable: false }, resume2);
  try {
    if (writable.writableNeedDrain) {
      await wait();
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait();
      }
    }
    writable.end();
    await wait();
    finish2();
  } catch (err) {
    finish2(error3 !== err ? aggregateTwoErrors(error3, err) : err);
  } finally {
    cleanup();
    writable.off("drain", resume2);
  }
}
function pipeline(...streams) {
  const callback = once(popCallback(streams));
  if (Array.isArray(streams[0]) && streams.length === 1) {
    streams = streams[0];
  }
  return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  const ac = new AbortController();
  const signal = ac.signal;
  const outerSignal = opts?.signal;
  validateAbortSignal(outerSignal, "options.signal");
  function abort() {
    finishImpl(new AbortError());
  }
  outerSignal?.addEventListener("abort", abort);
  let error3;
  let value;
  const destroys = [];
  let finishCount = 0;
  function finish2(err) {
    finishImpl(err, --finishCount === 0);
  }
  function finishImpl(err, final2) {
    if (err && (!error3 || error3.code === "ERR_STREAM_PREMATURE_CLOSE")) {
      error3 = err;
    }
    if (!error3 && !final2) {
      return;
    }
    while (destroys.length) {
      destroys.shift()(error3);
    }
    outerSignal?.removeEventListener("abort", abort);
    ac.abort();
    if (final2) {
      callback(error3, value);
    }
  }
  let ret;
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i];
    const reading = i < streams.length - 1;
    const writing = i > 0;
    if (isNodeStream(stream)) {
      finishCount++;
      destroys.push(destroyer2(stream, reading, writing, finish2));
    }
    if (i === 0) {
      if (typeof stream === "function") {
        ret = stream({ signal });
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream)) {
        ret = stream;
      } else {
        ret = duplex_default.from(stream);
      }
    } else if (typeof stream === "function") {
      ret = makeAsyncIterable(ret);
      ret = stream(ret, { signal });
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
        }
      } else {
        const pt = new passthrough_default({
          objectMode: true
        });
        const then = ret?.then;
        if (typeof then === "function") {
          then.call(ret, (val) => {
            value = val;
            pt.end(val);
          }, (err) => {
            pt.destroy(err);
          });
        } else if (isIterable(ret, true)) {
          finishCount++;
          pump(ret, pt, finish2);
        } else {
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
        }
        ret = pt;
        finishCount++;
        destroys.push(destroyer2(ret, false, true, finish2));
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        ret.pipe(stream);
        if (stream === stdio.stdout || stream === stdio.stderr) {
          ret.on("end", () => stream.end());
        }
      } else {
        ret = makeAsyncIterable(ret);
        finishCount++;
        pump(ret, stream, finish2);
      }
      ret = stream;
    } else {
      ret = duplex_default.from(stream);
    }
  }
  if (signal?.aborted || outerSignal?.aborted) {
    nextTick3(abort);
  }
  return ret;
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/compose.mjs
var ComposeDuplex = class extends duplex_default {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS("streams");
  }
  if (streams.length === 1) {
    return duplex_default.from(streams[0]);
  }
  const orgStreams = [...streams];
  if (typeof streams[0] === "function") {
    streams[0] = duplex_default.from(streams[0]);
  }
  if (typeof streams[streams.length - 1] === "function") {
    const idx = streams.length - 1;
    streams[idx] = duplex_default.from(streams[idx]);
  }
  for (let n = 0; n < streams.length; ++n) {
    if (!isNodeStream(streams[n])) {
      continue;
    }
    if (n < streams.length - 1 && !isReadable2(streams[n])) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
    }
    if (n > 0 && !isWritable2(streams[n])) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
    }
  }
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d.destroy(err);
    } else if (!readable && !writable) {
      d.destroy();
    }
  }
  const head = streams[0];
  const tail = pipeline(streams, onfinished);
  const writable = !!isWritable2(head);
  const readable = !!isReadable2(tail);
  d = new ComposeDuplex({
    writableObjectMode: !!head?.writableObjectMode,
    readableObjectMode: !!tail?.writableObjectMode,
    writable,
    readable
  });
  if (writable) {
    d._write = function(chunk, encoding, callback) {
      if (head.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d._final = function(callback) {
      head.end();
      onfinish = callback;
    };
    head.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    tail.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    tail.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    tail.on("end", function() {
      d.push(null);
    });
    d._read = function() {
      while (true) {
        const buf = tail.read();
        if (buf === null) {
          onreadable = d._read;
          return;
        }
        if (!d.push(buf)) {
          return;
        }
      }
    };
  }
  d._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(tail, err);
    }
  };
  return d;
}
var compose_default = compose;

// deno:https://deno.land/std@0.147.0/node/stream/promises.mjs
function pipeline2(...streams) {
  return new Promise((resolve7, reject) => {
    let signal;
    let end;
    const lastArg = streams[streams.length - 1];
    if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
      const options = streams.pop();
      signal = options.signal;
      end = options.end;
    }
    pipelineImpl(streams, (err, value) => {
      if (err) {
        reject(err);
      } else {
        resolve7(value);
      }
    }, { signal, end });
  });
}
function finished(stream, opts) {
  return new Promise((resolve7, reject) => {
    end_of_stream_default(stream, opts, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve7();
      }
    });
  });
}
var promises_default = {
  finished,
  pipeline: pipeline2
};

// deno:https://deno.land/std@0.147.0/node/_stream.mjs
var { custom: customPromisify } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = readable_default;
Stream.Writable = writable_default;
Stream.Duplex = duplex_default;
Stream.Transform = transform_default;
Stream.PassThrough = passthrough_default;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = end_of_stream_default;
Stream.destroy = destroyer;
Stream.compose = compose_default;
Object.defineProperty(Stream, "promises", {
  configurable: true,
  enumerable: true,
  get() {
    return promises_default;
  }
});
Object.defineProperty(pipeline, customPromisify, {
  enumerable: true,
  get() {
    return promises_default.pipeline;
  }
});
Object.defineProperty(end_of_stream_default, customPromisify, {
  enumerable: true,
  get() {
    return promises_default.finished;
  }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
var stream_default = Stream;

// deno:https://deno.land/std@0.147.0/node/_process/streams.mjs
function createWritableStdioStream(writer, name) {
  const stream = new writable_default({
    write(buf, enc, cb) {
      if (!writer) {
        this.destroy(new Error(`Deno.${name} is not available in this environment`));
        return;
      }
      writer.writeSync(buf instanceof Uint8Array ? buf : Buffer3.from(buf, enc));
      cb();
    },
    destroy(err, cb) {
      cb(err);
      this._undestroy();
      if (!this._writableState.emitClose) {
        nextTick(() => this.emit("close"));
      }
    }
  });
  stream.fd = writer?.rid ?? -1;
  stream.destroySoon = stream.destroy;
  stream._isStdio = true;
  stream.once("close", () => writer?.close());
  Object.defineProperties(stream, {
    columns: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : void 0
    },
    rows: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : void 0
    },
    isTTY: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid)
    },
    getWindowSize: {
      enumerable: true,
      configurable: true,
      value: () => Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : void 0
    }
  });
  if (Deno.isatty?.(writer?.rid)) {
    stream.cursorTo = function(x, y, callback) {
      return cursorTo(this, x, y, callback);
    };
    stream.moveCursor = function(dx, dy, callback) {
      return moveCursor(this, dx, dy, callback);
    };
    stream.clearLine = function(dir, callback) {
      return clearLine(this, dir, callback);
    };
    stream.clearScreenDown = function(callback) {
      return clearScreenDown(this, callback);
    };
  }
  return stream;
}
var stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
var stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
var stdin = stdio.stdin = new readable_default({
  highWaterMark: 0,
  emitClose: false,
  read(size) {
    const p = Buffer3.alloc(size || 16 * 1024);
    if (!Deno.stdin) {
      this.destroy(new Error("Deno.stdin is not available in this environment"));
      return;
    }
    Deno.stdin.read(p).then((length) => {
      this.push(length === null ? null : p.slice(0, length));
    }, (error3) => {
      this.destroy(error3);
    });
  }
});
stdin.on("close", () => Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
  enumerable: true,
  configurable: true,
  get() {
    return Deno.isatty?.(Deno.stdin.rid);
  }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable) => {
  setRaw?.(Deno.stdin?.rid, enable);
  stdin._isRawMode = enable;
  return stdin;
};
Object.defineProperty(stdin, "isRaw", {
  enumerable: true,
  configurable: true,
  get() {
    return stdin._isRawMode;
  }
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/async_wrap.ts
var async_wrap_exports = {};
__export(async_wrap_exports, {
  AsyncWrap: () => AsyncWrap,
  UidFields: () => UidFields,
  asyncIdFields: () => asyncIdFields,
  async_hook_fields: () => asyncHookFields,
  constants: () => constants,
  newAsyncId: () => newAsyncId,
  providerType: () => providerType,
  registerDestroyHook: () => registerDestroyHook
});
function registerDestroyHook(_target, _asyncId, _prop) {
}
var constants = /* @__PURE__ */ ((constants5) => {
  constants5[constants5["kInit"] = 0] = "kInit";
  constants5[constants5["kBefore"] = 1] = "kBefore";
  constants5[constants5["kAfter"] = 2] = "kAfter";
  constants5[constants5["kDestroy"] = 3] = "kDestroy";
  constants5[constants5["kPromiseResolve"] = 4] = "kPromiseResolve";
  constants5[constants5["kTotals"] = 5] = "kTotals";
  constants5[constants5["kCheck"] = 6] = "kCheck";
  constants5[constants5["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
  constants5[constants5["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
  constants5[constants5["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
  constants5[constants5["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
  constants5[constants5["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
  constants5[constants5["kStackLength"] = 12] = "kStackLength";
  return constants5;
})(constants || {});
var asyncHookFields = new Uint32Array(Object.keys(constants).length);
function newAsyncId() {
  return ++asyncIdFields[9 /* kAsyncIdCounter */];
}
var UidFields = /* @__PURE__ */ ((UidFields2) => {
  UidFields2[UidFields2["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
  UidFields2[UidFields2["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
  UidFields2[UidFields2["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
  UidFields2[UidFields2["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
  UidFields2[UidFields2["kUidFieldsCount"] = 4] = "kUidFieldsCount";
  return UidFields2;
})(UidFields || {});
var asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[2 /* kAsyncIdCounter */] = 1;
asyncIdFields[3 /* kDefaultTriggerAsyncId */] = -1;
var providerType = /* @__PURE__ */ ((providerType3) => {
  providerType3[providerType3["NONE"] = 0] = "NONE";
  providerType3[providerType3["DIRHANDLE"] = 1] = "DIRHANDLE";
  providerType3[providerType3["DNSCHANNEL"] = 2] = "DNSCHANNEL";
  providerType3[providerType3["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
  providerType3[providerType3["FILEHANDLE"] = 4] = "FILEHANDLE";
  providerType3[providerType3["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
  providerType3[providerType3["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
  providerType3[providerType3["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
  providerType3[providerType3["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
  providerType3[providerType3["FSREQPROMISE"] = 9] = "FSREQPROMISE";
  providerType3[providerType3["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
  providerType3[providerType3["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
  providerType3[providerType3["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
  providerType3[providerType3["HTTP2SESSION"] = 13] = "HTTP2SESSION";
  providerType3[providerType3["HTTP2STREAM"] = 14] = "HTTP2STREAM";
  providerType3[providerType3["HTTP2PING"] = 15] = "HTTP2PING";
  providerType3[providerType3["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
  providerType3[providerType3["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
  providerType3[providerType3["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
  providerType3[providerType3["JSSTREAM"] = 19] = "JSSTREAM";
  providerType3[providerType3["JSUDPWRAP"] = 20] = "JSUDPWRAP";
  providerType3[providerType3["MESSAGEPORT"] = 21] = "MESSAGEPORT";
  providerType3[providerType3["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
  providerType3[providerType3["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
  providerType3[providerType3["PIPEWRAP"] = 24] = "PIPEWRAP";
  providerType3[providerType3["PROCESSWRAP"] = 25] = "PROCESSWRAP";
  providerType3[providerType3["PROMISE"] = 26] = "PROMISE";
  providerType3[providerType3["QUERYWRAP"] = 27] = "QUERYWRAP";
  providerType3[providerType3["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
  providerType3[providerType3["SIGNALWRAP"] = 29] = "SIGNALWRAP";
  providerType3[providerType3["STATWATCHER"] = 30] = "STATWATCHER";
  providerType3[providerType3["STREAMPIPE"] = 31] = "STREAMPIPE";
  providerType3[providerType3["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
  providerType3[providerType3["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
  providerType3[providerType3["TCPWRAP"] = 34] = "TCPWRAP";
  providerType3[providerType3["TTYWRAP"] = 35] = "TTYWRAP";
  providerType3[providerType3["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
  providerType3[providerType3["UDPWRAP"] = 37] = "UDPWRAP";
  providerType3[providerType3["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
  providerType3[providerType3["WORKER"] = 39] = "WORKER";
  providerType3[providerType3["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
  providerType3[providerType3["WRITEWRAP"] = 41] = "WRITEWRAP";
  providerType3[providerType3["ZLIB"] = 42] = "ZLIB";
  return providerType3;
})(providerType || {});
var kInvalidAsyncId = -1;
var AsyncWrap = class {
  constructor(provider) {
    this.provider = 0 /* NONE */;
    this.asyncId = kInvalidAsyncId;
    this.provider = provider;
    this.getAsyncId();
  }
  getAsyncId() {
    this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
    return this.asyncId;
  }
  getProviderType() {
    return this.provider;
  }
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/config.ts
var config_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/cares_wrap.ts
var cares_wrap_exports = {};
__export(cares_wrap_exports, {
  ChannelWrap: () => ChannelWrap,
  GetAddrInfoReqWrap: () => GetAddrInfoReqWrap,
  QueryReqWrap: () => QueryReqWrap,
  getaddrinfo: () => getaddrinfo,
  strerror: () => strerror
});

// deno:https://deno.land/std@0.147.0/node/internal/net.ts
var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
var IPv4Reg = new RegExp(`^${v4Str}$`);
var v6Seg = "(?:[0-9a-fA-F]{1,4})";
var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
function isIPv4(ip) {
  return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
  return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
  if (isIPv4(ip)) {
    return 4;
  }
  if (isIPv6(ip)) {
    return 6;
  }
  return 0;
}
var normalizedArgsSymbol = Symbol("normalizedArgs");

// deno:https://deno.land/std@0.147.0/node/internal_binding/ares.ts
var ARES_AI_CANONNAME = 1 << 0;
var ARES_AI_NUMERICHOST = 1 << 1;
var ARES_AI_PASSIVE = 1 << 2;
var ARES_AI_NUMERICSERV = 1 << 3;
var AI_V4MAPPED = 1 << 4;
var AI_ALL = 1 << 5;
var AI_ADDRCONFIG = 1 << 6;
var ARES_AI_NOSORT = 1 << 7;
var ARES_AI_ENVHOSTS = 1 << 8;
function ares_strerror(code2) {
  const errorText = [
    "Successful completion",
    "DNS server returned answer with no data",
    "DNS server claims query was misformatted",
    "DNS server returned general failure",
    "Domain name not found",
    "DNS server does not implement requested operation",
    "DNS server refused query",
    "Misformatted DNS query",
    "Misformatted domain name",
    "Unsupported address family",
    "Misformatted DNS reply",
    "Could not contact DNS servers",
    "Timeout while contacting DNS servers",
    "End of file",
    "Error reading file",
    "Out of memory",
    "Channel is being destroyed",
    "Misformatted string",
    "Illegal flags specified",
    "Given hostname is not numeric",
    "Illegal hints flags specified",
    "c-ares library initialization not yet performed",
    "Error loading iphlpapi.dll",
    "Could not find GetNetworkParams function",
    "DNS query cancelled"
  ];
  if (code2 >= 0 && code2 < errorText.length) {
    return errorText[code2];
  } else {
    return "unknown";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/cares_wrap.ts
var GetAddrInfoReqWrap = class extends AsyncWrap {
  constructor() {
    super(10 /* GETADDRINFOREQWRAP */);
  }
};
function getaddrinfo(req, hostname, family, _hints, verbatim) {
  let addresses = [];
  const recordTypes = [];
  if (family === 0 || family === 4) {
    recordTypes.push("A");
  }
  if (family === 0 || family === 6) {
    recordTypes.push("AAAA");
  }
  (async () => {
    await Promise.allSettled(recordTypes.map((recordType) => Deno.resolveDns(hostname, recordType).then((records) => {
      records.forEach((record) => addresses.push(record));
    })));
    const error3 = addresses.length ? 0 : codeMap.get("EAI_NODATA");
    if (!verbatim) {
      addresses.sort((a, b) => {
        if (isIPv4(a)) {
          return -1;
        } else if (isIPv4(b)) {
          return 1;
        }
        return 0;
      });
    }
    if (isWindows && hostname === "localhost") {
      addresses = addresses.filter((address) => isIPv4(address));
    }
    req.oncomplete(error3, addresses);
  })();
  return 0;
}
var QueryReqWrap = class extends AsyncWrap {
  constructor() {
    super(27 /* QUERYWRAP */);
  }
};
function fqdnToHostname(fqdn) {
  return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
  const formatted = address.replace(/\b(?:0+:){2,}/, ":");
  const finalAddress = formatted.split(":").map((octet) => {
    if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
      return Number(octet.replaceAll(".", "")).toString(16);
    }
    return octet.replace(/\b0+/g, "");
  }).join(":");
  return finalAddress;
}
var ChannelWrap = class extends AsyncWrap {
  #servers = [];
  #timeout;
  #tries;
  constructor(timeout, tries) {
    super(2 /* DNSCHANNEL */);
    this.#timeout = timeout;
    this.#tries = tries;
  }
  async #query(query, recordType) {
    let code2;
    let ret;
    if (this.#servers.length) {
      for (const [ipAddr, port] of this.#servers) {
        const resolveOptions = {
          nameServer: {
            ipAddr,
            port
          }
        };
        ({ code: code2, ret } = await this.#resolve(query, recordType, resolveOptions));
        if (code2 === 0 || code2 === codeMap.get("EAI_NODATA")) {
          break;
        }
      }
    } else {
      ({ code: code2, ret } = await this.#resolve(query, recordType));
    }
    return { code: code2, ret };
  }
  async #resolve(query, recordType, resolveOptions) {
    let ret = [];
    let code2 = 0;
    try {
      ret = await Deno.resolveDns(query, recordType, resolveOptions);
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        code2 = codeMap.get("EAI_NODATA");
      } else {
        code2 = codeMap.get("UNKNOWN");
      }
    }
    return { code: code2, ret };
  }
  queryAny(req, name) {
    (async () => {
      const records = [];
      await Promise.allSettled([
        this.#query(name, "A").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "A", address: record }));
        }),
        this.#query(name, "AAAA").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "AAAA", address: compressIPv6(record) }));
        }),
        this.#query(name, "CAA").then(({ ret }) => {
          ret.forEach(({ critical, tag: tag2, value }) => records.push({
            type: "CAA",
            [tag2]: value,
            critical: +critical && 128
          }));
        }),
        this.#query(name, "CNAME").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "CNAME", value: record }));
        }),
        this.#query(name, "MX").then(({ ret }) => {
          ret.forEach(({ preference, exchange }) => records.push({
            type: "MX",
            priority: preference,
            exchange: fqdnToHostname(exchange)
          }));
        }),
        this.#query(name, "NAPTR").then(({ ret }) => {
          ret.forEach(({ order, preference, flags, services, regexp, replacement }) => records.push({
            type: "NAPTR",
            order,
            preference,
            flags,
            service: services,
            regexp,
            replacement
          }));
        }),
        this.#query(name, "NS").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "NS", value: fqdnToHostname(record) }));
        }),
        this.#query(name, "PTR").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "PTR", value: fqdnToHostname(record) }));
        }),
        this.#query(name, "SOA").then(({ ret }) => {
          ret.forEach(({ mname, rname, serial, refresh, retry, expire, minimum }) => records.push({
            type: "SOA",
            nsname: fqdnToHostname(mname),
            hostmaster: fqdnToHostname(rname),
            serial,
            refresh,
            retry,
            expire,
            minttl: minimum
          }));
        }),
        this.#query(name, "SRV").then(({ ret }) => {
          ret.forEach(({ priority, weight, port, target }) => records.push({
            type: "SRV",
            priority,
            weight,
            port,
            name: target
          }));
        }),
        this.#query(name, "TXT").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "TXT", entries: record }));
        })
      ]);
      const err = records.length ? 0 : codeMap.get("EAI_NODATA");
      req.oncomplete(err, records);
    })();
    return 0;
  }
  queryA(req, name) {
    this.#query(name, "A").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryAaaa(req, name) {
    this.#query(name, "AAAA").then(({ code: code2, ret }) => {
      const records = ret.map((record) => compressIPv6(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCaa(req, name) {
    this.#query(name, "CAA").then(({ code: code2, ret }) => {
      const records = ret.map(({ critical, tag: tag2, value }) => ({
        [tag2]: value,
        critical: +critical && 128
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCname(req, name) {
    this.#query(name, "CNAME").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryMx(req, name) {
    this.#query(name, "MX").then(({ code: code2, ret }) => {
      const records = ret.map(({ preference, exchange }) => ({
        priority: preference,
        exchange: fqdnToHostname(exchange)
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNaptr(req, name) {
    this.#query(name, "NAPTR").then(({ code: code2, ret }) => {
      const records = ret.map(({ order, preference, flags, services, regexp, replacement }) => ({
        flags,
        service: services,
        regexp,
        replacement,
        order,
        preference
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNs(req, name) {
    this.#query(name, "NS").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryPtr(req, name) {
    this.#query(name, "PTR").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  querySoa(req, name) {
    this.#query(name, "SOA").then(({ code: code2, ret }) => {
      let record = {};
      if (ret.length) {
        const { mname, rname, serial, refresh, retry, expire, minimum } = ret[0];
        record = {
          nsname: fqdnToHostname(mname),
          hostmaster: fqdnToHostname(rname),
          serial,
          refresh,
          retry,
          expire,
          minttl: minimum
        };
      }
      req.oncomplete(code2, record);
    });
    return 0;
  }
  querySrv(req, name) {
    this.#query(name, "SRV").then(({ code: code2, ret }) => {
      const records = ret.map(({ priority, weight, port, target }) => ({
        priority,
        weight,
        port,
        name: target
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryTxt(req, name) {
    this.#query(name, "TXT").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  getHostByAddr(_req, _name) {
    notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
  }
  getServers() {
    return this.#servers;
  }
  setServers(servers) {
    if (typeof servers === "string") {
      const tuples = [];
      for (let i = 0; i < servers.length; i += 2) {
        tuples.push([servers[i], parseInt(servers[i + 1])]);
      }
      this.#servers = tuples;
    } else {
      this.#servers = servers.map(([_ipVersion, ip, port]) => [ip, port]);
    }
    return 0;
  }
  setLocalAddress(_addr0, _addr1) {
    notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
  }
  cancel() {
    notImplemented("cares.ChannelWrap.prototype.cancel");
  }
};
var DNS_ESETSRVPENDING = -1e3;
var EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code2) {
  return code2 === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code2);
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/contextify.ts
var contextify_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/crypto.ts
var crypto_exports = {};
__export(crypto_exports, {
  getFipsCrypto: () => getFipsCrypto,
  setFipsCrypto: () => setFipsCrypto,
  timingSafeEqual: () => timingSafeEqual
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/_timingSafeEqual.ts
var timingSafeEqual = (a, b) => {
  if (a instanceof DataView)
    a = Buffer3.from(a.buffer);
  if (b instanceof DataView)
    b = Buffer3.from(b.buffer);
  if (a instanceof ArrayBuffer)
    a = Buffer3.from(a);
  if (b instanceof ArrayBuffer)
    b = Buffer3.from(b);
  let result = 0;
  if (a.byteLength !== b.byteLength) {
    b = a;
    result = 1;
  }
  for (let i = 0; i < a.byteLength; i++) {
    result |= a[i] ^ b[i];
  }
  return result === 0;
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/crypto.ts
function getFipsCrypto() {
  notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
  notImplemented("crypto.setFipsCrypto");
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/credentials.ts
var credentials_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/errors.ts
var errors_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/fs.ts
var fs_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/fs_dir.ts
var fs_dir_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/fs_event_wrap.ts
var fs_event_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/heap_utils.ts
var heap_utils_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/http_parser.ts
var http_parser_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/icu.ts
var icu_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/inspector.ts
var inspector_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/js_stream.ts
var js_stream_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/messaging.ts
var messaging_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/module_wrap.ts
var module_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/native_module.ts
var native_module_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/natives.ts
var natives_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/options.ts
var options_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/os.ts
var os_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/pipe_wrap.ts
var pipe_wrap_exports = {};
__export(pipe_wrap_exports, {
  Pipe: () => Pipe,
  PipeConnectWrap: () => PipeConnectWrap,
  constants: () => constants2,
  socketType: () => socketType
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/stream_wrap.ts
var stream_wrap_exports = {};
__export(stream_wrap_exports, {
  LibuvStreamWrap: () => LibuvStreamWrap,
  ShutdownWrap: () => ShutdownWrap,
  WriteWrap: () => WriteWrap,
  kArrayBufferOffset: () => kArrayBufferOffset,
  kBytesWritten: () => kBytesWritten,
  kLastWriteWasAsync: () => kLastWriteWasAsync,
  kNumStreamBaseStateFields: () => kNumStreamBaseStateFields,
  kReadBytesOrError: () => kReadBytesOrError,
  kStreamBaseField: () => kStreamBaseField,
  streamBaseState: () => streamBaseState
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/handle_wrap.ts
var HandleWrap = class extends AsyncWrap {
  constructor(provider) {
    super(provider);
  }
  close(cb = () => {
  }) {
    this._onClose();
    cb();
  }
  ref() {
    unreachable();
  }
  unref() {
    unreachable();
  }
  _onClose() {
  }
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/stream_wrap.ts
var kReadBytesOrError = 0 /* kReadBytesOrError */;
var kArrayBufferOffset = 1 /* kArrayBufferOffset */;
var kBytesWritten = 2 /* kBytesWritten */;
var kLastWriteWasAsync = 3 /* kLastWriteWasAsync */;
var kNumStreamBaseStateFields = 4 /* kNumStreamBaseStateFields */;
var streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
var WriteWrap = class extends AsyncWrap {
  constructor() {
    super(41 /* WRITEWRAP */);
  }
};
var ShutdownWrap = class extends AsyncWrap {
  constructor() {
    super(28 /* SHUTDOWNWRAP */);
  }
};
var kStreamBaseField = Symbol("kStreamBaseField");
var SUGGESTED_SIZE = 64 * 1024;
var LibuvStreamWrap = class extends HandleWrap {
  constructor(provider, stream) {
    super(provider);
    this.#reading = false;
    this.destroyed = false;
    this.writeQueueSize = 0;
    this.bytesRead = 0;
    this.bytesWritten = 0;
    this.#attachToObject(stream);
  }
  #reading;
  readStart() {
    if (!this.#reading) {
      this.#reading = true;
      this.#read();
    }
    return 0;
  }
  readStop() {
    this.#reading = false;
    return 0;
  }
  shutdown(req) {
    const status = this._onClose();
    try {
      req.oncomplete(status);
    } catch {
    }
    return 0;
  }
  useUserBuffer(_userBuf) {
    notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
  }
  writeBuffer(req, data) {
    this.#write(req, data);
    return 0;
  }
  writev(req, chunks, allBuffers) {
    const count = allBuffers ? chunks.length : chunks.length >> 1;
    const buffers = new Array(count);
    if (!allBuffers) {
      for (let i = 0; i < count; i++) {
        const chunk = chunks[i * 2];
        if (Buffer3.isBuffer(chunk)) {
          buffers[i] = chunk;
        }
        const encoding = chunks[i * 2 + 1];
        buffers[i] = Buffer3.from(chunk, encoding);
      }
    } else {
      for (let i = 0; i < count; i++) {
        buffers[i] = chunks[i];
      }
    }
    return this.writeBuffer(req, Buffer3.concat(buffers));
  }
  writeAsciiString(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUtf8String(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUcs2String(_req, _data) {
    notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
  }
  writeLatin1String(req, data) {
    const buffer = Buffer3.from(data, "latin1");
    return this.writeBuffer(req, buffer);
  }
  _onClose() {
    let status = 0;
    this.#reading = false;
    try {
      this[kStreamBaseField]?.close();
    } catch {
      status = codeMap.get("ENOTCONN");
    }
    return status;
  }
  #attachToObject(stream) {
    this[kStreamBaseField] = stream;
  }
  async #read() {
    let buf = new Uint8Array(SUGGESTED_SIZE);
    let nread;
    try {
      nread = await this[kStreamBaseField].read(buf);
    } catch (e) {
      if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
        nread = codeMap.get("EOF");
      } else if (e instanceof Deno.errors.ConnectionReset || e instanceof Deno.errors.ConnectionAborted) {
        nread = codeMap.get("ECONNRESET");
      } else {
        nread = codeMap.get("UNKNOWN");
      }
      buf = new Uint8Array(0);
    }
    nread ??= codeMap.get("EOF");
    streamBaseState[kReadBytesOrError] = nread;
    if (nread > 0) {
      this.bytesRead += nread;
    }
    buf = buf.slice(0, nread);
    streamBaseState[kArrayBufferOffset] = 0;
    try {
      this.onread(buf, nread);
    } catch {
    }
    if (nread >= 0 && this.#reading) {
      this.#read();
    }
  }
  async #write(req, data) {
    const { byteLength: byteLength6 } = data;
    try {
      await writeAll(this[kStreamBaseField], data);
    } catch (e) {
      let status;
      if (e instanceof Deno.errors.BadResource || e instanceof Deno.errors.BrokenPipe) {
        status = codeMap.get("EBADF");
      } else {
        status = codeMap.get("UNKNOWN");
      }
      try {
        req.oncomplete(status);
      } catch {
      }
      return;
    }
    streamBaseState[kBytesWritten] = byteLength6;
    this.bytesWritten += byteLength6;
    try {
      req.oncomplete(0);
    } catch {
    }
    return;
  }
};
kStreamBaseField;

// deno:https://deno.land/std@0.147.0/node/internal_binding/connection_wrap.ts
var ConnectionWrap = class extends LibuvStreamWrap {
  constructor(provider, object) {
    super(provider, object);
    this.onconnection = null;
  }
  afterConnect(req, status) {
    const isSuccessStatus = !status;
    const readable = isSuccessStatus;
    const writable = isSuccessStatus;
    try {
      req.oncomplete(status, this, req, readable, writable);
    } catch {
    }
    return;
  }
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/_listen.ts
function ceilPowOf2(n) {
  const roundPowOf2 = 1 << 31 - Math.clz32(n);
  return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
var INITIAL_ACCEPT_BACKOFF_DELAY = 5;
var MAX_ACCEPT_BACKOFF_DELAY = 1e3;

// deno:https://deno.land/std@0.147.0/node/internal_binding/pipe_wrap.ts
var socketType = /* @__PURE__ */ ((socketType2) => {
  socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
  socketType2[socketType2["SERVER"] = 1] = "SERVER";
  socketType2[socketType2["IPC"] = 2] = "IPC";
  return socketType2;
})(socketType || {});
var Pipe = class extends ConnectionWrap {
  constructor(type, conn) {
    let provider;
    let ipc;
    switch (type) {
      case 0 /* SOCKET */: {
        provider = 24 /* PIPEWRAP */;
        ipc = false;
        break;
      }
      case 1 /* SERVER */: {
        provider = 23 /* PIPESERVERWRAP */;
        ipc = false;
        break;
      }
      case 2 /* IPC */: {
        provider = 24 /* PIPEWRAP */;
        ipc = true;
        break;
      }
      default: {
        unreachable();
      }
    }
    super(provider, conn);
    this.reading = false;
    this.#pendingInstances = 4;
    this.#connections = 0;
    this.#closed = false;
    this.ipc = ipc;
    if (conn && provider === 24 /* PIPEWRAP */) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.path;
    }
  }
  #pendingInstances;
  #address;
  #backlog;
  #listener;
  #connections;
  #closed;
  #acceptBackoffDelay;
  open(_fd) {
    notImplemented("Pipe.prototype.open");
  }
  bind(name) {
    this.#address = name;
    return 0;
  }
  connect(req, address) {
    if (isWindows) {
      notImplemented("Pipe.prototype.connect - Windows");
    }
    const connectOptions = {
      path: address,
      transport: "unix"
    };
    connect(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req.address = localAddr.path;
      this[kStreamBaseField] = conn;
      try {
        this.afterConnect(req, 0);
      } catch {
      }
    }, (e) => {
      let code2;
      if (e instanceof Deno.errors.NotFound) {
        code2 = codeMap.get("ENOENT");
      } else if (e instanceof Deno.errors.PermissionDenied) {
        code2 = codeMap.get("EACCES");
      } else {
        code2 = codeMap.get("ECONNREFUSED");
      }
      try {
        this.afterConnect(req, code2);
      } catch {
      }
    });
    return 0;
  }
  listen(backlog) {
    if (isWindows) {
      notImplemented("Pipe.prototype.listen - Windows");
    }
    this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
    const listenOptions = {
      path: this.#address,
      transport: "unix"
    };
    let listener;
    try {
      listener = listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.path;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref(this.#listener);
    }
  }
  setPendingInstances(instances) {
    this.#pendingInstances = instances;
  }
  fchmod(mode) {
    if (mode != constants2.UV_READABLE && mode != constants2.UV_WRITABLE && mode != (constants2.UV_WRITABLE | constants2.UV_READABLE)) {
      return codeMap.get("EINVAL");
    }
    let desired_mode = 0;
    if (mode & constants2.UV_READABLE) {
      desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
    }
    if (mode & constants2.UV_WRITABLE) {
      desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
    }
    try {
      Deno.chmodSync(this.#address, desired_mode);
    } catch {
      return codeMap.get("UNKNOWN");
    }
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= MAX_ACCEPT_BACKOFF_DELAY) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
    }
    await delay(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection;
    try {
      connection = await this.#listener.accept();
    } catch (e) {
      if (e instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle = new Pipe(0 /* SOCKET */, connection);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === 23 /* PIPESERVERWRAP */) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap.prototype._onClose.call(this);
  }
};
var PipeConnectWrap = class extends AsyncWrap {
  constructor() {
    super(22 /* PIPECONNECTWRAP */);
  }
};
var constants2 = /* @__PURE__ */ ((constants5) => {
  constants5[constants5["SOCKET"] = 0 /* SOCKET */] = "SOCKET";
  constants5[constants5["SERVER"] = 1 /* SERVER */] = "SERVER";
  constants5[constants5["IPC"] = 2 /* IPC */] = "IPC";
  constants5[constants5["UV_READABLE"] = 1] = "UV_READABLE";
  constants5[constants5["UV_WRITABLE"] = 2] = "UV_WRITABLE";
  return constants5;
})(constants2 || {});

// deno:https://deno.land/std@0.147.0/node/internal_binding/performance.ts
var performance_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/process_methods.ts
var process_methods_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/report.ts
var report_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/serdes.ts
var serdes_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/signal_wrap.ts
var signal_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/spawn_sync.ts
var spawn_sync_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/symbols.ts
var symbols_exports = {};
__export(symbols_exports, {
  asyncIdSymbol: () => asyncIdSymbol,
  ownerSymbol: () => ownerSymbol
});
var asyncIdSymbol = Symbol("asyncIdSymbol");
var ownerSymbol = Symbol("ownerSymbol");

// deno:https://deno.land/std@0.147.0/node/internal_binding/task_queue.ts
var task_queue_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/tcp_wrap.ts
var tcp_wrap_exports = {};
__export(tcp_wrap_exports, {
  TCP: () => TCP,
  TCPConnectWrap: () => TCPConnectWrap,
  constants: () => constants3
});
var TCPConnectWrap = class extends AsyncWrap {
  constructor() {
    super(32 /* TCPCONNECTWRAP */);
  }
};
var constants3 = /* @__PURE__ */ ((constants5) => {
  constants5[constants5["SOCKET"] = 0 /* SOCKET */] = "SOCKET";
  constants5[constants5["SERVER"] = 1 /* SERVER */] = "SERVER";
  constants5[constants5["UV_TCP_IPV6ONLY"] = 2] = "UV_TCP_IPV6ONLY";
  return constants5;
})(constants3 || {});
var _a;
var _TCP = class extends ConnectionWrap {
  constructor(type, conn) {
    let provider;
    switch (type) {
      case 0 /* SOCKET */: {
        provider = 34 /* TCPWRAP */;
        break;
      }
      case 1 /* SERVER */: {
        provider = 33 /* TCPSERVERWRAP */;
        break;
      }
      default: {
        unreachable();
      }
    }
    super(provider, conn);
    this[_a] = null;
    this.reading = false;
    this.#connections = 0;
    this.#closed = false;
    if (conn && provider === 34 /* TCPWRAP */) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.hostname;
      this.#port = localAddr.port;
      const remoteAddr = conn.remoteAddr;
      this.#remoteAddress = remoteAddr.hostname;
      this.#remotePort = remoteAddr.port;
      this.#remoteFamily = isIP(remoteAddr.hostname);
    }
  }
  #address;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #backlog;
  #listener;
  #connections;
  #closed;
  #acceptBackoffDelay;
  open(_fd) {
    notImplemented("TCP.prototype.open");
  }
  bind(address, port) {
    return this.#bind(address, port, 0);
  }
  bind6(address, port, flags) {
    return this.#bind(address, port, flags);
  }
  connect(req, address, port) {
    return this.#connect(req, address, port);
  }
  connect6(req, address, port) {
    return this.#connect(req, address, port);
  }
  listen(backlog) {
    this.#backlog = ceilPowOf2(backlog + 1);
    const listenOptions = {
      hostname: this.#address,
      port: this.#port,
      transport: "tcp"
    };
    let listener;
    try {
      listener = Deno.listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.hostname;
    this.#port = address.port;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref(this.#listener);
    }
  }
  getsockname(sockname) {
    if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
      return codeMap.get("EADDRNOTAVAIL");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = isIP(this.#address);
    return 0;
  }
  getpeername(peername) {
    if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
      return codeMap.get("EADDRNOTAVAIL");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  setNoDelay(_noDelay) {
    return 0;
  }
  setKeepAlive(_enable, _initialDelay) {
    return 0;
  }
  setSimultaneousAccepts(_enable) {
    notImplemented("TCP.prototype.setSimultaneousAccepts");
  }
  #bind(address, port, _flags) {
    this.#address = address;
    this.#port = port;
    return 0;
  }
  #connect(req, address, port) {
    this.#remoteAddress = address;
    this.#remotePort = port;
    this.#remoteFamily = isIP(address);
    const connectOptions = {
      hostname: address,
      port,
      transport: "tcp"
    };
    Deno.connect(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req.localAddress = localAddr.hostname;
      this.#port = req.localPort = localAddr.port;
      this[kStreamBaseField] = conn;
      try {
        this.afterConnect(req, 0);
      } catch {
      }
    }, () => {
      try {
        this.afterConnect(req, codeMap.get("ECONNREFUSED"));
      } catch {
      }
    });
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= MAX_ACCEPT_BACKOFF_DELAY) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
    }
    await delay(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection;
    try {
      connection = await this.#listener.accept();
    } catch (e) {
      if (e instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle = new _TCP(0 /* SOCKET */, connection);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#remoteAddress = void 0;
    this.#remoteFamily = void 0;
    this.#remotePort = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === 33 /* TCPSERVERWRAP */) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap.prototype._onClose.call(this);
  }
};
var TCP = _TCP;
_a = ownerSymbol;

// deno:https://deno.land/std@0.147.0/node/internal_binding/timers.ts
var timers_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/tls_wrap.ts
var tls_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/trace_events.ts
var trace_events_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/tty_wrap.ts
var tty_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/udp_wrap.ts
var udp_wrap_exports = {};
__export(udp_wrap_exports, {
  SendWrap: () => SendWrap,
  UDP: () => UDP
});
var AF_INET = 2;
var AF_INET6 = 10;
var UDP_DGRAM_MAXSIZE = 64 * 1024;
var SendWrap = class extends AsyncWrap {
  constructor() {
    super(36 /* UDPSENDWRAP */);
  }
};
var _a2;
var UDP = class extends HandleWrap {
  constructor() {
    super(37 /* UDPWRAP */);
    this[_a2] = null;
    this.#receiving = false;
    this.#recvBufferSize = UDP_DGRAM_MAXSIZE;
    this.#sendBufferSize = UDP_DGRAM_MAXSIZE;
  }
  #address;
  #family;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #listener;
  #receiving;
  #recvBufferSize;
  #sendBufferSize;
  addMembership(_multicastAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.addMembership");
  }
  addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
  }
  bind(ip, port, flags) {
    return this.#doBind(ip, port, flags, AF_INET);
  }
  bind6(ip, port, flags) {
    return this.#doBind(ip, port, flags, AF_INET6);
  }
  bufferSize(size, buffer, ctx) {
    let err;
    if (size > UDP_DGRAM_MAXSIZE) {
      err = "EINVAL";
    } else if (!this.#address) {
      err = isWindows ? "ENOTSOCK" : "EBADF";
    }
    if (err) {
      ctx.errno = codeMap.get(err);
      ctx.code = err;
      ctx.message = errorMap.get(ctx.errno)[1];
      ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
      return;
    }
    if (size !== 0) {
      size = isLinux ? size * 2 : size;
      if (buffer) {
        return this.#recvBufferSize = size;
      }
      return this.#sendBufferSize = size;
    }
    return buffer ? this.#recvBufferSize : this.#sendBufferSize;
  }
  connect(ip, port) {
    return this.#doConnect(ip, port, AF_INET);
  }
  connect6(ip, port) {
    return this.#doConnect(ip, port, AF_INET6);
  }
  disconnect() {
    this.#remoteAddress = void 0;
    this.#remotePort = void 0;
    this.#remoteFamily = void 0;
    return 0;
  }
  dropMembership(_multicastAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.dropMembership");
  }
  dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
  }
  getpeername(peername) {
    if (this.#remoteAddress === void 0) {
      return codeMap.get("EBADF");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  getsockname(sockname) {
    if (this.#address === void 0) {
      return codeMap.get("EBADF");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = this.#family;
    return 0;
  }
  open(_fd) {
    notImplemented("udp.UDP.prototype.open");
  }
  recvStart() {
    if (!this.#receiving) {
      this.#receiving = true;
      this.#receive();
    }
    return 0;
  }
  recvStop() {
    this.#receiving = false;
    return 0;
  }
  ref() {
    notImplemented("udp.UDP.prototype.ref");
  }
  send(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, AF_INET);
  }
  send6(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, AF_INET6);
  }
  setBroadcast(_bool) {
    notImplemented("udp.UDP.prototype.setBroadcast");
  }
  setMulticastInterface(_interfaceAddress) {
    notImplemented("udp.UDP.prototype.setMulticastInterface");
  }
  setMulticastLoopback(_bool) {
    notImplemented("udp.UDP.prototype.setMulticastLoopback");
  }
  setMulticastTTL(_ttl) {
    notImplemented("udp.UDP.prototype.setMulticastTTL");
  }
  setTTL(_ttl) {
    notImplemented("udp.UDP.prototype.setTTL");
  }
  unref() {
    notImplemented("udp.UDP.prototype.unref");
  }
  #doBind(ip, port, _flags, family) {
    const listenOptions = {
      port,
      hostname: ip,
      transport: "udp"
    };
    let listener;
    try {
      listener = listenDatagram(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.hostname;
    this.#port = address.port;
    this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
    this.#listener = listener;
    return 0;
  }
  #doConnect(ip, port, family) {
    this.#remoteAddress = ip;
    this.#remotePort = port;
    this.#remoteFamily = family === AF_INET6 ? "IPv6" : "IPv4";
    return 0;
  }
  #doSend(req, bufs, _count, args, _family) {
    let hasCallback;
    if (args.length === 3) {
      this.#remotePort = args[0];
      this.#remoteAddress = args[1];
      hasCallback = args[2];
    } else {
      hasCallback = args[0];
    }
    const addr = {
      hostname: this.#remoteAddress,
      port: this.#remotePort,
      transport: "udp"
    };
    const payload = new Uint8Array(Buffer3.concat(bufs.map((buf) => {
      if (typeof buf === "string") {
        return Buffer3.from(buf);
      }
      return Buffer3.from(buf.buffer, buf.byteOffset, buf.byteLength);
    })));
    (async () => {
      let sent;
      let err = null;
      try {
        sent = await this.#listener.send(payload, addr);
      } catch (e) {
        if (e instanceof Deno.errors.BadResource) {
          err = codeMap.get("EBADF");
        } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
          err = codeMap.get("EMSGSIZE");
        } else {
          err = codeMap.get("UNKNOWN");
        }
        sent = 0;
      }
      if (hasCallback) {
        try {
          req.oncomplete(err, sent);
        } catch {
        }
      }
    })();
    return 0;
  }
  async #receive() {
    if (!this.#receiving) {
      return;
    }
    const p = new Uint8Array(this.#recvBufferSize);
    let buf;
    let remoteAddr;
    let nread;
    try {
      [buf, remoteAddr] = await this.#listener.receive(p);
      nread = buf.length;
    } catch (e) {
      if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
        nread = 0;
      } else {
        nread = codeMap.get("UNKNOWN");
      }
      buf = new Uint8Array(0);
      remoteAddr = null;
    }
    nread ??= 0;
    const rinfo = remoteAddr ? {
      address: remoteAddr.hostname,
      port: remoteAddr.port,
      family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
    } : void 0;
    try {
      this.onmessage(nread, this, Buffer3.from(buf), rinfo);
    } catch {
    }
    this.#receive();
  }
  _onClose() {
    this.#receiving = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#family = void 0;
    try {
      this.#listener.close();
    } catch {
    }
    this.#listener = void 0;
    return 0;
  }
};
_a2 = ownerSymbol;

// deno:https://deno.land/std@0.147.0/node/internal_binding/url.ts
var url_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/v8.ts
var v8_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/worker.ts
var worker_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/zlib.ts
var zlib_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/mod.ts
var modules = {
  "async_wrap": async_wrap_exports,
  buffer: buffer_exports,
  "cares_wrap": cares_wrap_exports,
  config: config_exports,
  constants: constants_exports,
  contextify: contextify_exports,
  credentials: credentials_exports,
  crypto: crypto_exports,
  errors: errors_exports,
  fs: fs_exports,
  "fs_dir": fs_dir_exports,
  "fs_event_wrap": fs_event_wrap_exports,
  "heap_utils": heap_utils_exports,
  "http_parser": http_parser_exports,
  icu: icu_exports,
  inspector: inspector_exports,
  "js_stream": js_stream_exports,
  messaging: messaging_exports,
  "module_wrap": module_wrap_exports,
  "native_module": native_module_exports,
  natives: natives_exports,
  options: options_exports,
  os: os_exports,
  performance: performance_exports,
  "pipe_wrap": pipe_wrap_exports,
  "process_methods": process_methods_exports,
  report: report_exports,
  serdes: serdes_exports,
  "signal_wrap": signal_wrap_exports,
  "spawn_sync": spawn_sync_exports,
  "stream_wrap": stream_wrap_exports,
  "string_decoder": string_decoder_exports,
  symbols: symbols_exports,
  "task_queue": task_queue_exports,
  "tcp_wrap": tcp_wrap_exports,
  timers: timers_exports,
  "tls_wrap": tls_wrap_exports,
  "trace_events": trace_events_exports,
  "tty_wrap": tty_wrap_exports,
  types: types_exports,
  "udp_wrap": udp_wrap_exports,
  url: url_exports,
  util: util_exports,
  uv: uv_exports,
  v8: v8_exports,
  worker: worker_exports,
  zlib: zlib_exports
};
function getBinding(name) {
  const mod2 = modules[name];
  if (!mod2) {
    throw new Error(`No such module: ${name}`);
  }
  return mod2;
}

// deno:https://deno.land/std@0.147.0/node/internal/process/per_thread.mjs
var kInternal = Symbol("internal properties");
var replaceUnderscoresRegex = /_/g;
var leadingDashesRegex = /^--?/;
var trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
  const allowedNodeEnvironmentFlags = [
    "--track-heap-objects",
    "--no-track-heap-objects",
    "--node-snapshot",
    "--no-node-snapshot",
    "--require",
    "--max-old-space-size",
    "--trace-exit",
    "--no-trace-exit",
    "--disallow-code-generation-from-strings",
    "--experimental-json-modules",
    "--no-experimental-json-modules",
    "--interpreted-frames-native-stack",
    "--inspect-brk",
    "--no-inspect-brk",
    "--trace-tls",
    "--no-trace-tls",
    "--stack-trace-limit",
    "--experimental-repl-await",
    "--no-experimental-repl-await",
    "--preserve-symlinks",
    "--no-preserve-symlinks",
    "--report-uncaught-exception",
    "--no-report-uncaught-exception",
    "--experimental-modules",
    "--no-experimental-modules",
    "--report-signal",
    "--jitless",
    "--inspect-port",
    "--heapsnapshot-near-heap-limit",
    "--tls-keylog",
    "--force-context-aware",
    "--no-force-context-aware",
    "--napi-modules",
    "--abort-on-uncaught-exception",
    "--diagnostic-dir",
    "--verify-base-objects",
    "--no-verify-base-objects",
    "--unhandled-rejections",
    "--perf-basic-prof",
    "--trace-atomics-wait",
    "--no-trace-atomics-wait",
    "--deprecation",
    "--no-deprecation",
    "--perf-basic-prof-only-functions",
    "--perf-prof",
    "--max-http-header-size",
    "--report-on-signal",
    "--no-report-on-signal",
    "--throw-deprecation",
    "--no-throw-deprecation",
    "--warnings",
    "--no-warnings",
    "--force-fips",
    "--no-force-fips",
    "--pending-deprecation",
    "--no-pending-deprecation",
    "--input-type",
    "--tls-max-v1.3",
    "--no-tls-max-v1.3",
    "--tls-min-v1.2",
    "--no-tls-min-v1.2",
    "--inspect",
    "--no-inspect",
    "--heapsnapshot-signal",
    "--trace-warnings",
    "--no-trace-warnings",
    "--trace-event-categories",
    "--experimental-worker",
    "--tls-max-v1.2",
    "--no-tls-max-v1.2",
    "--perf-prof-unwinding-info",
    "--preserve-symlinks-main",
    "--no-preserve-symlinks-main",
    "--policy-integrity",
    "--experimental-wasm-modules",
    "--no-experimental-wasm-modules",
    "--node-memory-debug",
    "--inspect-publish-uid",
    "--tls-min-v1.3",
    "--no-tls-min-v1.3",
    "--experimental-specifier-resolution",
    "--secure-heap",
    "--tls-min-v1.0",
    "--no-tls-min-v1.0",
    "--redirect-warnings",
    "--experimental-report",
    "--trace-event-file-pattern",
    "--trace-uncaught",
    "--no-trace-uncaught",
    "--experimental-loader",
    "--http-parser",
    "--dns-result-order",
    "--trace-sigint",
    "--no-trace-sigint",
    "--secure-heap-min",
    "--enable-fips",
    "--no-enable-fips",
    "--enable-source-maps",
    "--no-enable-source-maps",
    "--insecure-http-parser",
    "--no-insecure-http-parser",
    "--use-openssl-ca",
    "--no-use-openssl-ca",
    "--tls-cipher-list",
    "--experimental-top-level-await",
    "--no-experimental-top-level-await",
    "--openssl-config",
    "--icu-data-dir",
    "--v8-pool-size",
    "--report-on-fatalerror",
    "--no-report-on-fatalerror",
    "--title",
    "--tls-min-v1.1",
    "--no-tls-min-v1.1",
    "--report-filename",
    "--trace-deprecation",
    "--no-trace-deprecation",
    "--report-compact",
    "--no-report-compact",
    "--experimental-policy",
    "--experimental-import-meta-resolve",
    "--no-experimental-import-meta-resolve",
    "--zero-fill-buffers",
    "--no-zero-fill-buffers",
    "--report-dir",
    "--use-bundled-ca",
    "--no-use-bundled-ca",
    "--experimental-vm-modules",
    "--no-experimental-vm-modules",
    "--force-async-hooks-checks",
    "--no-force-async-hooks-checks",
    "--frozen-intrinsics",
    "--no-frozen-intrinsics",
    "--huge-max-old-generation-size",
    "--disable-proto",
    "--debug-arraybuffer-allocations",
    "--no-debug-arraybuffer-allocations",
    "--conditions",
    "--experimental-wasi-unstable-preview1",
    "--no-experimental-wasi-unstable-preview1",
    "--trace-sync-io",
    "--no-trace-sync-io",
    "--use-largepages",
    "--experimental-abortcontroller",
    "--debug-port",
    "--es-module-specifier-resolution",
    "--prof-process",
    "-C",
    "--loader",
    "--report-directory",
    "-r",
    "--trace-events-enabled"
  ];
  const trimLeadingDashes = (flag) => flag.replace(leadingDashesRegex, "");
  const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
  class NodeEnvironmentFlagsSet extends Set {
    constructor(array) {
      super();
      this[kInternal] = { array };
    }
    add() {
      return this;
    }
    delete() {
      return false;
    }
    clear() {
    }
    has(key2) {
      if (typeof key2 === "string") {
        key2 = key2.replace(replaceUnderscoresRegex, "-");
        if (leadingDashesRegex.test(key2)) {
          key2 = key2.replace(trailingValuesRegex, "");
          return this[kInternal].array.includes(key2);
        }
        return nodeFlags.includes(key2);
      }
      return false;
    }
    entries() {
      this[kInternal].set ??= new Set(this[kInternal].array);
      return this[kInternal].set.entries();
    }
    forEach(callback, thisArg = void 0) {
      this[kInternal].array.forEach((v) => Reflect.apply(callback, thisArg, [v, v, this]));
    }
    get size() {
      return this[kInternal].array.length;
    }
    values() {
      this[kInternal].set ??= new Set(this[kInternal].array);
      return this[kInternal].set.values();
    }
  }
  NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
  Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
  Object.freeze(NodeEnvironmentFlagsSet.prototype);
  return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}

// deno:https://deno.land/std@0.147.0/node/process.ts
var stderr2 = stderr;
var stdin2 = stdin;
var stdout2 = stdout;
var notImplementedEvents = [
  "beforeExit",
  "disconnect",
  "message",
  "multipleResolves",
  "rejectionHandled",
  "uncaughtException",
  "uncaughtExceptionMonitor",
  "unhandledRejection",
  "worker"
];
var argv = ["", "", ...Deno.args];
Object.defineProperty(argv, "0", { get: Deno.execPath });
Object.defineProperty(argv, "1", {
  get: () => {
    if (Deno.mainModule.startsWith("file:")) {
      return fromFileUrl3(Deno.mainModule);
    } else {
      return join5(Deno.cwd(), "$deno$node.js");
    }
  }
});
var exit = (code2) => {
  if (code2 || code2 === 0) {
    if (typeof code2 === "string") {
      const parsedCode = parseInt(code2);
      process2.exitCode = isNaN(parsedCode) ? void 0 : parsedCode;
    } else {
      process2.exitCode = code2;
    }
  }
  if (!process2._exiting) {
    process2._exiting = true;
    process2.emit("exit", process2.exitCode || 0);
  }
  Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
  const value = getOptionValue(option);
  if (value) {
    Object.defineProperty(process2, name, {
      writable: false,
      configurable: true,
      enumerable,
      value
    });
  }
}
function createWarningObject(warning, type, code2, ctor, detail) {
  assert2(typeof warning === "string");
  const warningErr = new Error(warning);
  warningErr.name = String(type || "Warning");
  if (code2 !== void 0) {
    warningErr.code = code2;
  }
  if (detail !== void 0) {
    warningErr.detail = detail;
  }
  Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
  return warningErr;
}
function doEmitWarning(warning) {
  process2.emit("warning", warning);
}
function emitWarning(warning, type, code2, ctor) {
  let detail;
  if (type !== null && typeof type === "object" && !Array.isArray(type)) {
    ctor = type.ctor;
    code2 = type.code;
    if (typeof type.detail === "string") {
      detail = type.detail;
    }
    type = type.type || "Warning";
  } else if (typeof type === "function") {
    ctor = type;
    code2 = void 0;
    type = "Warning";
  }
  if (type !== void 0) {
    validateString(type, "type");
  }
  if (typeof code2 === "function") {
    ctor = code2;
    code2 = void 0;
  } else if (code2 !== void 0) {
    validateString(code2, "code");
  }
  if (typeof warning === "string") {
    warning = createWarningObject(warning, type, code2, ctor, detail);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE("warning", ["Error", "string"], warning);
  }
  if (warning.name === "DeprecationWarning") {
    if (process2.noDeprecation) {
      return;
    }
    if (process2.throwDeprecation) {
      return process2.nextTick(() => {
        throw warning;
      });
    }
  }
  process2.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
  const milli = performance.now();
  const sec = Math.floor(milli / 1e3);
  const nano = Math.floor(milli * 1e6 - sec * 1e9);
  if (!time) {
    return [sec, nano];
  }
  const [prevSec, prevNano] = time;
  return [sec - prevSec, nano - prevNano];
}
hrtime.bigint = function() {
  const [sec, nano] = hrtime();
  return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage() {
  return {
    ...Deno.memoryUsage(),
    arrayBuffers: 0
  };
}
memoryUsage.rss = function() {
  return memoryUsage().rss;
};
function kill(pid2, sig = "SIGTERM") {
  if (pid2 != (pid2 | 0)) {
    throw new ERR_INVALID_ARG_TYPE("pid", "number", pid2);
  }
  if (typeof sig === "string") {
    try {
      Deno.kill(pid2, sig);
    } catch (e) {
      if (e instanceof TypeError) {
        throw new ERR_UNKNOWN_SIGNAL(sig);
      }
      throw e;
    }
  } else {
    throw new ERR_UNKNOWN_SIGNAL(sig.toString());
  }
  return true;
}
var Process = class extends EventEmitter {
  constructor() {
    super();
    this.arch = arch;
    this.argv = argv;
    this.chdir = chdir;
    this.config = {
      target_defaults: {},
      variables: {}
    };
    this.cwd = cwd;
    this.env = env;
    this.execArgv = [];
    this.exit = exit;
    this._exiting = _exiting;
    this.exitCode = void 0;
    this.mainModule = void 0;
    this.nextTick = nextTick3;
    this.pid = pid;
    this.platform = platform;
    this.hrtime = hrtime;
    this.kill = kill;
    this.memoryUsage = memoryUsage;
    this.stderr = stderr2;
    this.stdin = stdin2;
    this.stdout = stdout2;
    this.version = version;
    this.versions = versions;
    this.emitWarning = emitWarning;
    this._eval = void 0;
    this.#startTime = Date.now();
    this.#allowedFlags = buildAllowedFlags();
    this.features = { inspector: false };
    globalThis.addEventListener("unload", () => {
      if (!process2._exiting) {
        process2._exiting = true;
        super.emit("exit", process2.exitCode || 0);
      }
    });
  }
  on(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.on("${event}")`);
      super.on(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener(event, listener);
      }
    } else {
      super.on(event, listener);
    }
    return this;
  }
  off(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.off("${event}")`);
      super.off(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        removeSignalListener(event, listener);
      }
    } else {
      super.off(event, listener);
    }
    return this;
  }
  emit(event, ...args) {
    if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        Deno.kill(Deno.pid, event);
      }
    } else {
      return super.emit(event, ...args);
    }
    return true;
  }
  prependListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.prependListener("${event}")`);
      super.prependListener(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener(event, listener);
      }
    } else {
      super.prependListener(event, listener);
    }
    return this;
  }
  addListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.addListener("${event}")`);
    }
    return this.on(event, listener);
  }
  removeListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.removeListener("${event}")`);
    }
    return this.off(event, listener);
  }
  binding(name) {
    return getBinding(name);
  }
  umask() {
    return 18;
  }
  getuid() {
    return NaN;
  }
  getgid() {
    return NaN;
  }
  get execPath() {
    return argv[0];
  }
  #startTime;
  uptime() {
    return (Date.now() - this.#startTime) / 1e3;
  }
  #allowedFlags;
  get allowedNodeEnvironmentFlags() {
    return this.#allowedFlags;
  }
};
var process2 = new Process();
Object.defineProperty(process2, Symbol.toStringTag, {
  enumerable: false,
  writable: true,
  configurable: false,
  value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
var removeListener2 = process2.removeListener;
var removeAllListeners2 = process2.removeAllListeners;
var process_default = process2;

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_randomBytes.ts
var MAX_RANDOM_VALUES = 65536;
var MAX_SIZE2 = 4294967295;
function generateRandomBytes(size) {
  if (size > MAX_SIZE2) {
    throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${MAX_SIZE2}. Received ${size}`);
  }
  const bytes = Buffer3.allocUnsafe(size);
  if (size > MAX_RANDOM_VALUES) {
    for (let generated = 0; generated < size; generated += MAX_RANDOM_VALUES) {
      globalThis.crypto.getRandomValues(bytes.slice(generated, generated + MAX_RANDOM_VALUES));
    }
  } else {
    globalThis.crypto.getRandomValues(bytes);
  }
  return bytes;
}
function randomBytes(size, cb) {
  if (typeof cb === "function") {
    let err = null, bytes;
    try {
      bytes = generateRandomBytes(size);
    } catch (e) {
      if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
        throw e;
      } else if (e instanceof Error) {
        err = e;
      } else {
        err = new Error("[non-error thrown]");
      }
    }
    setTimeout(() => {
      if (err) {
        cb(err);
      } else {
        cb(null, bytes);
      }
    }, 0);
  } else {
    return generateRandomBytes(size);
  }
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_randomFill.ts
var kBufferMaxLength = 2147483647;
function assertOffset(offset, length) {
  if (offset > MAX_SIZE2 || offset < 0) {
    throw new TypeError("offset must be a uint32");
  }
  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError("offset out of range");
  }
}
function assertSize2(size, offset, length) {
  if (size > MAX_SIZE2 || size < 0) {
    throw new TypeError("size must be a uint32");
  }
  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError("buffer too small");
  }
}
function randomFill(buf, offset, size, cb) {
  if (typeof offset === "function") {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === "function") {
    cb = size;
    size = buf.length - Number(offset);
  }
  assertOffset(offset, buf.length);
  assertSize2(size, offset, buf.length);
  randomBytes(size, (err, bytes) => {
    if (err)
      return cb(err, buf);
    bytes?.copy(buf, offset);
    cb(null, buf);
  });
}
function randomFillSync(buf, offset = 0, size) {
  assertOffset(offset, buf.length);
  if (size === void 0)
    size = buf.length - offset;
  assertSize2(size, offset, buf.length);
  const bytes = randomBytes(size);
  bytes.copy(buf, offset);
  return buf;
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_randomInt.ts
function randomInt(max2, min4, cb) {
  if (typeof max2 === "number" && typeof min4 === "number") {
    [max2, min4] = [min4, max2];
  }
  if (min4 === void 0)
    min4 = 0;
  else if (typeof min4 === "function") {
    cb = min4;
    min4 = 0;
  }
  if (!Number.isSafeInteger(min4) || typeof max2 === "number" && !Number.isSafeInteger(max2)) {
    throw new Error("max or min is not a Safe Number");
  }
  if (max2 - min4 > Math.pow(2, 48)) {
    throw new RangeError("max - min should be less than 2^48!");
  }
  if (min4 >= max2) {
    throw new Error("Min is bigger than Max!");
  }
  const randomBuffer = new Uint32Array(1);
  globalThis.crypto.getRandomValues(randomBuffer);
  const randomNumber = randomBuffer[0] / (4294967295 + 1);
  min4 = Math.ceil(min4);
  max2 = Math.floor(max2);
  const result = Math.floor(randomNumber * (max2 - min4)) + min4;
  if (cb) {
    cb(null, result);
    return;
  }
  return result;
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/random.ts
function checkPrime(_candidate, _options, _callback) {
  notImplemented("crypto.checkPrime");
}
function checkPrimeSync(_candidate, _options) {
  notImplemented("crypto.checkPrimeSync");
}
function generatePrime(_size, _options, _callback) {
  notImplemented("crypto.generatePrime");
}
function generatePrimeSync(_size, _options) {
  notImplemented("crypto.generatePrimeSync");
}
var randomUUID = () => globalThis.crypto.randomUUID();

// deno:https://deno.land/std@0.147.0/_wasm_crypto/lib/deno_std_wasm_crypto.generated.mjs
var wasm;
var heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function addHeapObject(obj2) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj2;
  return idx;
}
var cachedTextDecoder = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder.decode();
var cachedUint8Memory0;
function getUint8Memory0() {
  if (cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory0;
function getInt32Memory0() {
  if (cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
    var r02 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    var v12 = getArrayU8FromWasm0(r02, r1).slice();
    wasm.__wbindgen_free(r02, r1 * 1);
    return v12;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
var DigestContextFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_digestcontext_free(ptr));
var DigestContext = class {
  static __wrap(ptr) {
    const obj2 = Object.create(DigestContext.prototype);
    obj2.ptr = ptr;
    DigestContextFinalization.register(obj2, obj2.ptr, obj2);
    return obj2;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    DigestContextFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_digestcontext_free(ptr);
  }
  constructor(algorithm) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.digestcontext_new(retptr, ptr0, len0);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return DigestContext.__wrap(r02);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  update(data) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r02);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digest(length) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v0 = getArrayU8FromWasm0(r02, r1).slice();
      wasm.__wbindgen_free(r02, r1 * 1);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digestAndReset(length) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v0 = getArrayU8FromWasm0(r02, r1).slice();
      wasm.__wbindgen_free(r02, r1 * 1);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digestAndDrop(length) {
    try {
      const ptr = this.__destroy_into_raw();
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v0 = getArrayU8FromWasm0(r02, r1).slice();
      wasm.__wbindgen_free(r02, r1 * 1);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  reset() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_reset(retptr, this.ptr);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r02);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  clone() {
    const ret = wasm.digestcontext_clone(this.ptr);
    return DigestContext.__wrap(ret);
  }
};
var imports = {
  __wbindgen_placeholder__: {
    __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
      const ret = new TypeError(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    },
    __wbindgen_object_drop_ref: function(arg0) {
      takeObject(arg0);
    },
    __wbg_byteLength_3e250b41a8915757: function(arg0) {
      const ret = getObject(arg0).byteLength;
      return ret;
    },
    __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
      const ret = getObject(arg0).byteOffset;
      return ret;
    },
    __wbg_buffer_facf0398a281c85b: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    },
    __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    },
    __wbindgen_memory: function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    },
    __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_new_a7ce447f15ff496f: function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    },
    __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    },
    __wbindgen_throw: function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    }
  }
};
function instantiate() {
  return instantiateWithInstance().exports;
}
var instanceWithExports;
function instantiateWithInstance() {
  if (instanceWithExports == null) {
    const instance = instantiateInstance();
    wasm = instance.exports;
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    instanceWithExports = {
      instance,
      exports: { digest, DigestContext }
    };
  }
  return instanceWithExports;
}
function instantiateInstance() {
  const wasmBytes = base64decode("AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fwF/AqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRjZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNWRmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQPrgICAAGoJBwkHBxEFBwcFAwcHDwMHBRACBQUFBwUCCAYHBxQMCA4HBwcHBwcIFw0FBQkICA0HCQUJCQYGBQUFBQUFBwcHBwcABQIICgcHAgUDDgwLDAsLEhMJBQgIAwYGAgUAAAYDBgAABQUEAAUCBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDAAAsHtoKAgAAOBm1lbW9yeQIABmRpZ2VzdAA1GF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBQEWRpZ2VzdGNvbnRleHRfbmV3ADwUZGlnZXN0Y29udGV4dF91cGRhdGUAVBRkaWdlc3Rjb250ZXh0X2RpZ2VzdAA9HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAPxtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZERyb3AAOBNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQAaH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAbBFfX3diaW5kZ2VuX21hbGxvYwBXEl9fd2JpbmRnZW5fcmVhbGxvYwBiD19fd2JpbmRnZW5fZnJlZQBoCZqAgIAAAQBBAQsUZWZtdGtZO1pbWGNgXF1eX3VBQnIK0smIgABqoH4CEn8CfiMAQbAlayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCAA4YAAECAwQcGxoZGBcWFRQTEhEQDw4NDAsKAAsgASgCBCEBQdABEBYiBUUNBCAEQZASakE4aiABQThqKQMANwMAIARBkBJqQTBqIAFBMGopAwA3AwAgBEGQEmpBKGogAUEoaikDADcDACAEQZASakEgaiABQSBqKQMANwMAIARBkBJqQRhqIAFBGGopAwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEIaiABQQhqKQMANwMAIAQgASkDADcDkBIgASkDQCEWIARBkBJqQcgAaiABQcgAahBDIAQgFjcD0BIgBSAEQZASakHQARA5GkEAIQZBACEBDB8LIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBASEBDBsLIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBAiEBDBoLIAEoAgQhAUHwABAWIgVFDQQgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBCABKQMINwOYEiABKQMAIRYgBEGQEmpBKGogAUEoahA3IAQgFjcDkBIgBSAEQZASakHwABA5GkEDIQEMGQsgASgCBCEBQfgOEBYiBUUNBCAEQZASakGIAWogAUGIAWopAwA3AwAgBEGQEmpBgAFqIAFBgAFqKQMANwMAIARBkBJqQfgAaiABQfgAaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQRhqIAFBGGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQThqIAFBOGopAwA3AwAgBEGQEmpBwABqIAFBwABqKQMANwMAIARBkBJqQcgAaiABQcgAaikDADcDACAEQZASakHQAGogAUHQAGopAwA3AwAgBEGQEmpB2ABqIAFB2ABqKQMANwMAIARBkBJqQeAAaiABQeAAaikDADcDACAEIAEpA3A3A4ATIAQgASkDCDcDmBIgBCABKQMoNwO4EiABKQMAIRYgAS0AaiEHIAEtAGkhCCABLQBoIQkCQCABKAKQAUEFdCIKDQBBACEKDBsLIARBGGoiCyABQZQBaiIGQRhqKQAANwMAIARBEGoiDCAGQRBq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EDkaIAFBuCJqQThqIgogAUGQEmpBPGopAgA3AwAgAUG4ImpBMGoiAyABQZASakE0aikCADcDACABQbgiakEoaiIPIAFBkBJqQSxqKQIANwMAIAFBuCJqQSBqIgsgAUGQEmpBJGopAgA3AwAgAUG4ImpBGGoiDCABQZASakEcaikCADcDACABQbgiakEQaiINIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIhAgAUGQEmpBDGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohAgJAIAZBgAFGDQAgAiAGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAJCfxARIAFB+A5qQQhqIgYgAUGQEmpBCGopAwA3AwAgAUH4DmpBEGoiAiABQZASakEQaikDADcDACABQfgOakEYaiIOIAFBkBJqQRhqKQMANwMAIAFB+A5qQSBqIgcgASkDsBI3AwAgAUH4DmpBKGoiCCABQZASakEoaikDADcDACABQfgOakEwaiIJIAFBkBJqQTBqKQMANwMAIAFB+A5qQThqIhEgAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gECAGKQMANwMAIA0gAikDADcDACAMIA4pAwA3AwAgCyAHKQMANwMAIA8gCCkDADcDACADIAkpAwA3AwAgCiARKQMANwMAIAEgASkD+A43A7giQcAAEBYiBkUNHCAGIAEpA7giNwAAIAZBOGogAUG4ImpBOGopAwA3AAAgBkEwaiABQbgiakEwaikDADcAACAGQShqIAFBuCJqQShqKQMANwAAIAZBIGogAUG4ImpBIGopAwA3AAAgBkEYaiABQbgiakEYaikDADcAACAGQRBqIAFBuCJqQRBqKQMANwAAIAZBCGogAUG4ImpBCGopAwA3AABBwAAhAwwaCyAEIAVB0AEQOSIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCyABQfgOakEYaiICKQMANwMAIAFBkBJqQRBqIgwgAUH4DmpBEGoiCikDADcDACABQZASakEIaiINIAFB+A5qQQhqIgMpAwA3AwAgAUGQEmpBIGogAUH4DmpBIGoiECgCADYCACABIAEpA/gONwOQEiABQbgiakEQaiIOIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIgcgAUGQEmpBDGopAgA3AwAgAUG4ImpBGGoiCCABQZASakEcaikCADcDACABIAEpApQSNwO4IiABQZASaiABQdABEDkaIAEgASkD0BIgAUHYE2otAAAiBq18NwPQEiABQdgSaiEPAkAgBkGAAUYNACAPIAZqQQBBgAEgBmsQOhoLIAFBADoA2BMgAUGQEmogD0J/EBEgAyANKQMANwMAIAogDCkDADcDACACIAspAwA3AwAgECABKQOwEjcDACABQfgOakEoaiABQZASakEoaikDADcDACABQfgOakEwaiABQZASakEwaikDADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAHIAMpAwA3AwAgDiAKKQMANwMAIAggAikDADcDACABIAEpA/gONwO4IkEgEBYiBkUNHCAGIAEpA7giNwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQSAhAwwZCyAEIAVB0AEQOSIBQfgOakEsakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQTA2AvgOIAFBkBJqQShqIg0gAUH4DmpBKGoiAikDADcDACABQZASakEgaiABQfgOakEgaiIKKQMANwMAIAFBkBJqQRhqIhAgAUH4DmpBGGoiAykDADcDACABQZASakEQaiIOIAFB+A5qQRBqIg8pAwA3AwAgAUGQEmpBCGoiByABQfgOakEIaiILKQMANwMAIAFBkBJqQTBqIgggAUH4DmpBMGoiCSgCADYCACABIAEpA/gONwOQEiABQbgiakEgaiIRIAFBkBJqQSRqKQIANwMAIAFBuCJqQRhqIhIgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiEyABQZASakEUaikCADcDACABQbgiakEIaiIUIAFBkBJqQQxqKQIANwMAIAFBuCJqQShqIhUgAUGQEmpBLGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDAJAIAZBgAFGDQAgDCAGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAxCfxARIAsgBykDADcDACAPIA4pAwA3AwAgAyAQKQMANwMAIAogASkDsBI3AwAgAiANKQMANwMAIAkgCCkDADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAUIAspAwA3AwAgEyAPKQMANwMAIBIgAykDADcDACARIAopAwA3AwAgFSACKQMANwMAIAEgASkD+A43A7giQTAQFiIGRQ0cIAYgASkDuCI3AAAgBkEoaiABQbgiakEoaikDADcAACAGQSBqIAFBuCJqQSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQTAhAwwYCyAEIAVB8AAQOSIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCiABQfgOakEYaikDADcDACABQZASakEQaiIDIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqIg8pAwA3AwAgAUGQEmpBIGoiCyABQfgOakEgaigCADYCACABIAEpA/gONwOQEiABQegjakEQaiIMIAFBkBJqQRRqKQIANwMAIAFB6CNqQQhqIg0gAUGQEmpBDGopAgA3AwAgAUHoI2pBGGoiECABQZASakEcaikCADcDACABIAEpApQSNwPoIyABQZASaiABQfAAEDkaIAEgASkDkBIgAUH4EmotAAAiBq18NwOQEiABQbgSaiECAkAgBkHAAEYNACACIAZqQQBBwAAgBmsQOhoLIAFBADoA+BIgAUGQEmogAkF/EBMgDyADKQMAIhY3AwAgDSAWNwMAIAwgCikDADcDACAQIAspAwA3AwAgASABKQOYEiIWNwP4DiABIBY3A+gjQSAQFiIGRQ0cIAYgASkD6CM3AAAgBkEYaiABQegjakEYaikDADcAACAGQRBqIAFB6CNqQRBqKQMANwAAIAZBCGogAUHoI2pBCGopAwA3AABBICEDDBcLIAQgBUH4DhA5IQEgA0EASA0SAkACQCADDQBBASEGDAELIAMQFiIGRQ0dIAZBfGotAABBA3FFDQAgBkEAIAMQOhoLIAFBkBJqIAFB+A4QORogAUH4DmogAUGQEmoQIyABQfgOaiAGIAMQGAwWCyAEIAVB4AIQOSIKQZASaiAKQeACEDkaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6AOgUIAJBAToAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BHCEDQRwQFiIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhqIA8pAwA3AAAMFQsgBCAFQdgCEDkiCkGQEmogCkHYAhA5GiAKQZASaiAKQeAUai0AACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDoaC0EAIQYgCkEAOgDgFCACQQE6AAAgCkHfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADBQLIAQgBUG4AhA5IgpBkBJqIApBuAIQORogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHoACABaxA6GgtBACEGIApBADoAwBQgAkEBOgAAIApBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJCAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFiIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwTCyAEIAVBmAIQOSIKQZASaiAKQZgCEDkaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACACQQBByAAgAWsQOhoLQQAhBiAKQQA6AKAUIAJBAToAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkBJqECQgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBYiBkUNHCAGIAopA/gONwAAIAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwSCyAEIAVB4AAQOSIBQfgOakEMakIANwIAIAFCADcC/A5BECEDIAFBEDYC+A4gAUGQEmpBEGogAUH4DmpBEGooAgA2AgAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABIAEpA/gONwOQEiABIAEpApQSNwPoIyABQZASaiABQeAAEDkaIAFBkBJqIAFBqBJqIAFB6CNqEC9BEBAWIgZFDRwgBiABKQPoIzcAACAGQQhqIAIpAwA3AAAMEQsgBCAFQeAAEDkiAUH4DmpBDGpCADcCACABQgA3AvwOQRAhAyABQRA2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKAIANgIAIAFBkBJqQQhqIAFB+A5qQQhqKQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAUGQEmogAUHgABA5GiABQZASaiABQagSaiABQegjahAuQRAQFiIGRQ0cIAYgASkD6CM3AAAgBkEIaiACKQMANwAADBALQRQhAyAEIAVB6AAQOSIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3AgAgAUEANgL4DiABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKAIANgIAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQORogAUGQEmogAUGwEmogAUHoI2oQLUEUEBYiBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDwtBFCEDIAQgBUHoABA5IgFB+A5qQRRqQQA2AgAgAUH4DmpBDGpCADcCACABQQA2AvgOIAFCADcC/A4gAUEUNgL4DiABQZASakEQaiABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaikDADcDACABQegjakEIaiICIAFBkBJqQQxqKQIANwMAIAFB6CNqQRBqIgogAUGQEmpBFGooAgA2AgAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAUGQEmogAUHoABA5GiABQZASaiABQbASaiABQegjahAoQRQQFiIGRQ0cIAYgASkD6CM3AAAgBkEQaiAKKAIANgAAIAZBCGogAikDADcAAAwOCyAEIAVB4AIQOSIKQZASaiAKQeACEDkaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6AOgUIAJBBjoAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BHCEDQRwQFiIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhqIA8pAwA3AAAMDQsgBCAFQdgCEDkiCkGQEmogCkHYAhA5GiAKQZASaiAKQeAUai0AACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDoaC0EAIQYgCkEAOgDgFCACQQY6AAAgCkHfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADAwLIAQgBUG4AhA5IgpBkBJqIApBuAIQORogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHoACABaxA6GgtBACEGIApBADoAwBQgAkEGOgAAIApBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJCAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFiIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwLCyAEIAVBmAIQOSIKQZASaiAKQZgCEDkaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACACQQBByAAgAWsQOhoLQQAhBiAKQQA6AKAUIAJBBjoAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkBJqECQgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBYiBkUNHCAGIAopA/gONwAAIAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwKCyAEIAVB8AAQOSIBQZASaiABQfAAEDkaQRwhAyABQegjakEcakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBDGpCADcCACABQgA3AuwjIAFBIDYC6CMgAUH4DmpBGGoiAiABQegjakEYaikDADcDACABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB+A5qQQhqIg8gAUHoI2pBCGopAwA3AwAgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgASABKQPoIzcD+A4gAUG4ImpBEGoiBiABQfgOakEUaikCADcDACABQbgiakEIaiILIAFB+A5qQQxqKQIANwMAIAFBuCJqQRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQJyACIAwoAgA2AgAgCiAGKQMANwMAIA8gCykDADcDACABIAEpA7giNwP4DkEcEBYiBkUNHCAGIAEpA/gONwAAIAZBGGogAigCADYAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAkLIAQgBUHwABA5IgFBkBJqIAFB8AAQORogAUHoI2pBHGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsI0EgIQMgAUEgNgLoIyABQfgOakEgaiABQegjakEgaigCADYCACABQfgOakEYaiICIAFB6CNqQRhqKQMANwMAIAFB+A5qQRBqIgogAUHoI2pBEGopAwA3AwAgAUH4DmpBCGoiDyABQegjakEIaikDADcDACABIAEpA+gjNwP4DiABQbgiakEYaiIGIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgsgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDCABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQbgSaiABQbgiahAnIAIgBikDADcDACAKIAspAwA3AwAgDyAMKQMANwMAIAEgASkDuCI3A/gOQSAQFiIGRQ0cIAYgASkD+A43AAAgBkEYaiACKQMANwAAIAZBEGogCikDADcAACAGQQhqIA8pAwA3AAAMCAsgBCAFQdgBEDkiAUGQEmogAUHYARA5GiABQegjakEMakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBHGpCADcCACABQegjakEkakIANwIAIAFB6CNqQSxqQgA3AgAgAUHoI2pBNGpCADcCACABQegjakE8akIANwIAIAFCADcC7CMgAUHAADYC6CMgAUH4DmogAUHoI2pBxAAQORogAUHwImogAUH4DmpBPGopAgA3AwBBMCEDIAFBuCJqQTBqIAFB+A5qQTRqKQIANwMAIAFBuCJqQShqIgYgAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiAiABQfgOakEkaikCADcDACABQbgiakEYaiIKIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIg8gAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiCyABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAiIAFB+A5qQShqIgwgBikDADcDACABQfgOakEgaiINIAIpAwA3AwAgAUH4DmpBGGoiAiAKKQMANwMAIAFB+A5qQRBqIgogDykDADcDACABQfgOakEIaiIPIAspAwA3AwAgASABKQO4IjcD+A5BMBAWIgZFDRwgBiABKQP4DjcAACAGQShqIAwpAwA3AAAgBkEgaiANKQMANwAAIAZBGGogAikDADcAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAcLIAQgBUHYARA5IgFBkBJqIAFB2AEQORogAUHoI2pBDGpCADcCACABQegjakEUakIANwIAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJGpCADcCACABQegjakEsakIANwIAIAFB6CNqQTRqQgA3AgAgAUHoI2pBPGpCADcCACABQgA3AuwjQcAAIQMgAUHAADYC6CMgAUH4DmogAUHoI2pBxAAQORogAUG4ImpBOGoiBiABQfgOakE8aikCADcDACABQbgiakEwaiICIAFB+A5qQTRqKQIANwMAIAFBuCJqQShqIgogAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiDyABQfgOakEkaikCADcDACABQbgiakEYaiILIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgwgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDSABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAiIAFB+A5qQThqIhAgBikDADcDACABQfgOakEwaiIOIAIpAwA3AwAgAUH4DmpBKGoiAiAKKQMANwMAIAFB+A5qQSBqIgogDykDADcDACABQfgOakEYaiIPIAspAwA3AwAgAUH4DmpBEGoiCyAMKQMANwMAIAFB+A5qQQhqIgwgDSkDADcDACABIAEpA7giNwP4DkHAABAWIgZFDRwgBiABKQP4DjcAACAGQThqIBApAwA3AAAgBkEwaiAOKQMANwAAIAZBKGogAikDADcAACAGQSBqIAopAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhqIAwpAwA3AAAMBgsgBEH4DmogBUH4AhA5GiADQQBIDQECQAJAIAMNAEEBIQYMAQsgAxAWIgZFDR0gBkF8ai0AAEEDcUUNACAGQQAgAxA6GgsgBEGQEmogBEH4DmpB+AIQORogBCAEQfgOakHIARA5Ig9ByAFqIA9BkBJqQcgBakGpARA5IQEgD0HoI2ogD0H4DmpByAEQORogD0GIIWogAUGpARA5GiAPQYghaiAPLQCwIiIBaiEKAkAgAUGoAUYNACAKQQBBqAEgAWsQOhoLQQAhAiAPQQA6ALAiIApBHzoAACAPQa8iaiIBIAEtAABBgAFyOgAAA0AgD0HoI2ogAmoiASABLQAAIA9BiCFqIAJqIgotAABzOgAAIAFBAWoiCyALLQAAIApBAWotAABzOgAAIAFBAmoiCyALLQAAIApBAmotAABzOgAAIAFBA2oiASABLQAAIApBA2otAABzOgAAIAJBBGoiAkGoAUcNAAsgD0HoI2oQJCAPQZASaiAPQegjakHIARA5GiAPQQA2ArgiIA9BuCJqQQRyQQBBqAEQOhogD0GoATYCuCIgDyAPQbgiakGsARA5IgFBkBJqQcgBaiABQQRyQagBEDkaIAFBgBVqQQA6AAAgAUGQEmogBiADEDEMBQsgBEH4DmogBUHYAhA5GiADQQBIDQAgAw0BQQEhBgwCCxBpAAsgAxAWIgZFDRogBkF8ai0AAEEDcUUNACAGQQAgAxA6GgsgBEGQEmogBEH4DmpB2AIQORogBCAEQfgOakHIARA5Ig9ByAFqIA9BkBJqQcgBakGJARA5IQEgD0HoI2ogD0H4DmpByAEQORogD0GIIWogAUGJARA5GiAPQYghaiAPLQCQIiIBaiEKAkAgAUGIAUYNACAKQQBBiAEgAWsQOhoLQQAhAiAPQQA6AJAiIApBHzoAACAPQY8iaiIBIAEtAABBgAFyOgAAA0AgD0HoI2ogAmoiASABLQAAIA9BiCFqIAJqIgotAABzOgAAIAFBAWoiCyALLQAAIApBAWotAABzOgAAIAFBAmoiCyALLQAAIApBAmotAABzOgAAIAFBA2oiASABLQAAIApBA2otAABzOgAAIAJBBGoiAkGIAUcNAAsgD0HoI2oQJCAPQZASaiAPQegjakHIARA5GiAPQQA2ArgiIA9BuCJqQQRyQQBBiAEQOhogD0GIATYCuCIgDyAPQbgiakGMARA5IgFBkBJqQcgBaiABQQRyQYgBEDkaIAFB4BRqQQA6AAAgAUGQEmogBiADEDIMAQsgBCAFQegAEDkiAUH4DmpBFGpCADcCACABQfgOakEMakIANwIAIAFCADcC/A5BGCEDIAFBGDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUGQEmpBGGogAUH4DmpBGGooAgA2AgAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKQIANwMAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQORogAUGQEmogAUGwEmogAUHoI2oQMEEYEBYiBkUNGSAGIAEpA+gjNwAAIAZBEGogCikDADcAACAGQQhqIAIpAwA3AAALIAUQHiAAQQhqIAM2AgAgACAGNgIEIABBADYCAAsgBEGwJWokAA8LQcAAQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIAQbEQUAAAtBwABBAUEAKAL41EAiBEEEIAQbEQUAAAtBEEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EQQQFBACgC+NRAIgRBBCAEGxEFAAALQRRBAUEAKAL41EAiBEEEIAQbEQUAAAtBFEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAACyADQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBGEEBQQAoAvjUQCIEQQQgBBsRBQAAC5JaAgF/In4jAEGAAWsiAyQAIANBAEGAARA6IQMgACkDOCEEIAApAzAhBSAAKQMoIQYgACkDICEHIAApAxghCCAAKQMQIQkgACkDCCEKIAApAwAhCwJAIAJBB3QiAkUNACABIAJqIQIDQCADIAEpAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGIZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gODIAxCOIiEhIQ3AwAgAyABQQhqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISENwMIIAMgAUEQaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhDcDECADIAFBGGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGIZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gODIAxCOIiEhIQ3AxggAyABQSBqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISENwMgIAMgAUEoaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhDcDKCADIAFBwABqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIg03A0AgAyABQThqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIg43AzggAyABQTBqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIg83AzAgAykDACEQIAMpAwghESADKQMQIRIgAykDGCETIAMpAyAhFCADKQMoIRUgAyABQcgAaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIWNwNIIAMgAUHQAGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGIZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gODIAxCOIiEhIQiFzcDUCADIAFB2ABqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIhg3A1ggAyABQeAAaikAACIMQjiGIAxCKIZCgICAgICAwP8Ag4QgDEIYhkKAgICAgOA/gyAMQgiGQoCAgIDwH4OEhCAMQgiIQoCAgPgPgyAMQhiIQoCA/AeDhCAMQiiIQoD+A4MgDEI4iISEhCIZNwNgIAMgAUHoAGopAAAiDEI4hiAMQiiGQoCAgICAgMD/AIOEIAxCGIZCgICAgIDgP4MgDEIIhkKAgICA8B+DhIQgDEIIiEKAgID4D4MgDEIYiEKAgPwHg4QgDEIoiEKA/gODIAxCOIiEhIQiGjcDaCADIAFB8ABqKQAAIgxCOIYgDEIohkKAgICAgIDA/wCDhCAMQhiGQoCAgICA4D+DIAxCCIZCgICAgPAfg4SEIAxCCIhCgICA+A+DIAxCGIhCgID8B4OEIAxCKIhCgP4DgyAMQjiIhISEIgw3A3AgAyABQfgAaikAACIbQjiGIBtCKIZCgICAgICAwP8Ag4QgG0IYhkKAgICAgOA/gyAbQgiGQoCAgIDwH4OEhCAbQgiIQoCAgPgPgyAbQhiIQoCA/AeDhCAbQiiIQoD+A4MgG0I4iISEhCIbNwN4IAtCJIkgC0IeiYUgC0IZiYUgCiAJhSALgyAKIAmDhXwgECAEIAYgBYUgB4MgBYV8IAdCMokgB0IuiYUgB0IXiYV8fEKi3KK5jfOLxcIAfCIcfCIdQiSJIB1CHomFIB1CGYmFIB0gCyAKhYMgCyAKg4V8IAUgEXwgHCAIfCIeIAcgBoWDIAaFfCAeQjKJIB5CLomFIB5CF4mFfELNy72fkpLRm/EAfCIffCIcQiSJIBxCHomFIBxCGYmFIBwgHSALhYMgHSALg4V8IAYgEnwgHyAJfCIgIB4gB4WDIAeFfCAgQjKJICBCLomFICBCF4mFfEKv9rTi/vm+4LV/fCIhfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8IAcgE3wgISAKfCIiICAgHoWDIB6FfCAiQjKJICJCLomFICJCF4mFfEK8t6eM2PT22ml8IiN8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgHiAUfCAjIAt8IiMgIiAghYMgIIV8ICNCMokgI0IuiYUgI0IXiYV8Qrjqopq/y7CrOXwiJHwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCAVICB8ICQgHXwiICAjICKFgyAihXwgIEIyiSAgQi6JhSAgQheJhXxCmaCXsJu+xPjZAHwiJHwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAPICJ8ICQgHHwiIiAgICOFgyAjhXwgIkIyiSAiQi6JhSAiQheJhXxCm5/l+MrU4J+Sf3wiJHwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAOICN8ICQgH3wiIyAiICCFgyAghXwgI0IyiSAjQi6JhSAjQheJhXxCmIK2093al46rf3wiJHwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCANICB8ICQgIXwiICAjICKFgyAihXwgIEIyiSAgQi6JhSAgQheJhXxCwoSMmIrT6oNYfCIkfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8IBYgInwgJCAefCIiICAgI4WDICOFfCAiQjKJICJCLomFICJCF4mFfEK+38GrlODWwRJ8IiR8Ih5CJIkgHkIeiYUgHkIZiYUgHiAhIB+FgyAhIB+DhXwgFyAjfCAkIB18IiMgIiAghYMgIIV8ICNCMokgI0IuiYUgI0IXiYV8Qozlkvfkt+GYJHwiJHwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAYICB8ICQgHHwiICAjICKFgyAihXwgIEIyiSAgQi6JhSAgQheJhXxC4un+r724n4bVAHwiJHwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAZICJ8ICQgH3wiIiAgICOFgyAjhXwgIkIyiSAiQi6JhSAiQheJhXxC75Luk8+ul9/yAHwiJHwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCAaICN8ICQgIXwiIyAiICCFgyAghXwgI0IyiSAjQi6JhSAjQheJhXxCsa3a2OO/rO+Af3wiJHwiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCAMICB8ICQgHnwiJCAjICKFgyAihXwgJEIyiSAkQi6JhSAkQheJhXxCtaScrvLUge6bf3wiIHwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCAbICJ8ICAgHXwiJSAkICOFgyAjhXwgJUIyiSAlQi6JhSAlQheJhXxClM2k+8yu/M1BfCIifCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IBAgEUI/iSARQjiJhSARQgeIhXwgFnwgDEItiSAMQgOJhSAMQgaIhXwiICAjfCAiIBx8IhAgJSAkhYMgJIV8IBBCMokgEEIuiYUgEEIXiYV8QtKVxfeZuNrNZHwiI3wiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCARIBJCP4kgEkI4iYUgEkIHiIV8IBd8IBtCLYkgG0IDiYUgG0IGiIV8IiIgJHwgIyAffCIRIBAgJYWDICWFfCARQjKJIBFCLomFIBFCF4mFfELjy7zC4/CR3298IiR8Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgEiATQj+JIBNCOImFIBNCB4iFfCAYfCAgQi2JICBCA4mFICBCBoiFfCIjICV8ICQgIXwiEiARIBCFgyAQhXwgEkIyiSASQi6JhSASQheJhXxCtauz3Oi45+APfCIlfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8IBMgFEI/iSAUQjiJhSAUQgeIhXwgGXwgIkItiSAiQgOJhSAiQgaIhXwiJCAQfCAlIB58IhMgEiARhYMgEYV8IBNCMokgE0IuiYUgE0IXiYV8QuW4sr3HuaiGJHwiEHwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCAUIBVCP4kgFUI4iYUgFUIHiIV8IBp8ICNCLYkgI0IDiYUgI0IGiIV8IiUgEXwgECAdfCIUIBMgEoWDIBKFfCAUQjKJIBRCLomFIBRCF4mFfEL1hKzJ9Y3L9C18IhF8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgFSAPQj+JIA9COImFIA9CB4iFfCAMfCAkQi2JICRCA4mFICRCBoiFfCIQIBJ8IBEgHHwiFSAUIBOFgyAThXwgFUIyiSAVQi6JhSAVQheJhXxCg8mb9aaVobrKAHwiEnwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAOQj+JIA5COImFIA5CB4iFIA98IBt8ICVCLYkgJUIDiYUgJUIGiIV8IhEgE3wgEiAffCIPIBUgFIWDIBSFfCAPQjKJIA9CLomFIA9CF4mFfELU94fqy7uq2NwAfCITfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8IA1CP4kgDUI4iYUgDUIHiIUgDnwgIHwgEEItiSAQQgOJhSAQQgaIhXwiEiAUfCATICF8Ig4gDyAVhYMgFYV8IA5CMokgDkIuiYUgDkIXiYV8QrWnxZiom+L89gB8IhR8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgFkI/iSAWQjiJhSAWQgeIhSANfCAifCARQi2JIBFCA4mFIBFCBoiFfCITIBV8IBQgHnwiDSAOIA+FgyAPhXwgDUIyiSANQi6JhSANQheJhXxCq7+b866qlJ+Yf3wiFXwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCAXQj+JIBdCOImFIBdCB4iFIBZ8ICN8IBJCLYkgEkIDiYUgEkIGiIV8IhQgD3wgFSAdfCIWIA0gDoWDIA6FfCAWQjKJIBZCLomFIBZCF4mFfEKQ5NDt0s3xmKh/fCIPfCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IBhCP4kgGEI4iYUgGEIHiIUgF3wgJHwgE0ItiSATQgOJhSATQgaIhXwiFSAOfCAPIBx8IhcgFiANhYMgDYV8IBdCMokgF0IuiYUgF0IXiYV8Qr/C7MeJ+cmBsH98Ig58IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgGUI/iSAZQjiJhSAZQgeIhSAYfCAlfCAUQi2JIBRCA4mFIBRCBoiFfCIPIA18IA4gH3wiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxC5J289/v436y/f3wiDXwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCAaQj+JIBpCOImFIBpCB4iFIBl8IBB8IBVCLYkgFUIDiYUgFUIGiIV8Ig4gFnwgDSAhfCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfELCn6Lts/6C8EZ8Ihl8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgDEI/iSAMQjiJhSAMQgeIhSAafCARfCAPQi2JIA9CA4mFIA9CBoiFfCINIBd8IBkgHnwiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhSAXQheJhXxCpc6qmPmo5NNVfCIZfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8IBtCP4kgG0I4iYUgG0IHiIUgDHwgEnwgDkItiSAOQgOJhSAOQgaIhXwiDCAYfCAZIB18IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8Qu+EjoCe6pjlBnwiGXwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAgQj+JICBCOImFICBCB4iFIBt8IBN8IA1CLYkgDUIDiYUgDUIGiIV8IhsgFnwgGSAcfCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfELw3LnQ8KzKlBR8Ihl8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgIkI/iSAiQjiJhSAiQgeIhSAgfCAUfCAMQi2JIAxCA4mFIAxCBoiFfCIgIBd8IBkgH3wiFyAWIBiFgyAYhXwgF0IyiSAXQi6JhSAXQheJhXxC/N/IttTQwtsnfCIZfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8ICNCP4kgI0I4iYUgI0IHiIUgInwgFXwgG0ItiSAbQgOJhSAbQgaIhXwiIiAYfCAZICF8IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8QqaSm+GFp8iNLnwiGXwiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCAkQj+JICRCOImFICRCB4iFICN8IA98ICBCLYkgIEIDiYUgIEIGiIV8IiMgFnwgGSAefCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfELt1ZDWxb+bls0AfCIZfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8ICVCP4kgJUI4iYUgJUIHiIUgJHwgDnwgIkItiSAiQgOJhSAiQgaIhXwiJCAXfCAZIB18IhcgFiAYhYMgGIV8IBdCMokgF0IuiYUgF0IXiYV8Qt/n1uy5ooOc0wB8Ihl8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgEEI/iSAQQjiJhSAQQgeIhSAlfCANfCAjQi2JICNCA4mFICNCBoiFfCIlIBh8IBkgHHwiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxC3se93cjqnIXlAHwiGXwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCARQj+JIBFCOImFIBFCB4iFIBB8IAx8ICRCLYkgJEIDiYUgJEIGiIV8IhAgFnwgGSAffCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfEKo5d7js9eCtfYAfCIZfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8IBJCP4kgEkI4iYUgEkIHiIUgEXwgG3wgJUItiSAlQgOJhSAlQgaIhXwiESAXfCAZICF8IhcgFiAYhYMgGIV8IBdCMokgF0IuiYUgF0IXiYV8Qubdtr/kpbLhgX98Ihl8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgE0I/iSATQjiJhSATQgeIhSASfCAgfCAQQi2JIBBCA4mFIBBCBoiFfCISIBh8IBkgHnwiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxCu+qIpNGQi7mSf3wiGXwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCAUQj+JIBRCOImFIBRCB4iFIBN8ICJ8IBFCLYkgEUIDiYUgEUIGiIV8IhMgFnwgGSAdfCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfELkhsTnlJT636J/fCIZfCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IBVCP4kgFUI4iYUgFUIHiIUgFHwgI3wgEkItiSASQgOJhSASQgaIhXwiFCAXfCAZIBx8IhcgFiAYhYMgGIV8IBdCMokgF0IuiYUgF0IXiYV8QoHgiOK7yZmNqH98Ihl8IhxCJIkgHEIeiYUgHEIZiYUgHCAdIB6FgyAdIB6DhXwgD0I/iSAPQjiJhSAPQgeIhSAVfCAkfCATQi2JIBNCA4mFIBNCBoiFfCIVIBh8IBkgH3wiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxCka/ih43u4qVCfCIZfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8IA5CP4kgDkI4iYUgDkIHiIUgD3wgJXwgFEItiSAUQgOJhSAUQgaIhXwiDyAWfCAZICF8IhYgGCAXhYMgF4V8IBZCMokgFkIuiYUgFkIXiYV8QrD80rKwtJS2R3wiGXwiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCANQj+JIA1COImFIA1CB4iFIA58IBB8IBVCLYkgFUIDiYUgFUIGiIV8Ig4gF3wgGSAefCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfEKYpL23nYO6yVF8Ihl8Ih5CJIkgHkIeiYUgHkIZiYUgHiAhIB+FgyAhIB+DhXwgDEI/iSAMQjiJhSAMQgeIhSANfCARfCAPQi2JIA9CA4mFIA9CBoiFfCINIBh8IBkgHXwiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxCkNKWq8XEwcxWfCIZfCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8IBtCP4kgG0I4iYUgG0IHiIUgDHwgEnwgDkItiSAOQgOJhSAOQgaIhXwiDCAWfCAZIBx8IhYgGCAXhYMgF4V8IBZCMokgFkIuiYUgFkIXiYV8QqrAxLvVsI2HdHwiGXwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAgQj+JICBCOImFICBCB4iFIBt8IBN8IA1CLYkgDUIDiYUgDUIGiIV8IhsgF3wgGSAffCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfEK4o++Vg46otRB8Ihl8Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgIkI/iSAiQjiJhSAiQgeIhSAgfCAUfCAMQi2JIAxCA4mFIAxCBoiFfCIgIBh8IBkgIXwiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxCyKHLxuuisNIZfCIZfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8ICNCP4kgI0I4iYUgI0IHiIUgInwgFXwgG0ItiSAbQgOJhSAbQgaIhXwiIiAWfCAZIB58IhYgGCAXhYMgF4V8IBZCMokgFkIuiYUgFkIXiYV8QtPWhoqFgdubHnwiGXwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCAkQj+JICRCOImFICRCB4iFICN8IA98ICBCLYkgIEIDiYUgIEIGiIV8IiMgF3wgGSAdfCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfEKZ17v8zemdpCd8Ihl8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgJUI/iSAlQjiJhSAlQgeIhSAkfCAOfCAiQi2JICJCA4mFICJCBoiFfCIkIBh8IBkgHHwiGCAXIBaFgyAWhXwgGEIyiSAYQi6JhSAYQheJhXxCqJHtjN6Wr9g0fCIZfCIcQiSJIBxCHomFIBxCGYmFIBwgHSAehYMgHSAeg4V8IBBCP4kgEEI4iYUgEEIHiIUgJXwgDXwgI0ItiSAjQgOJhSAjQgaIhXwiJSAWfCAZIB98IhYgGCAXhYMgF4V8IBZCMokgFkIuiYUgFkIXiYV8QuO0pa68loOOOXwiGXwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCARQj+JIBFCOImFIBFCB4iFIBB8IAx8ICRCLYkgJEIDiYUgJEIGiIV8IhAgF3wgGSAhfCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfELLlYaarsmq7M4AfCIZfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8IBJCP4kgEkI4iYUgEkIHiIUgEXwgG3wgJUItiSAlQgOJhSAlQgaIhXwiESAYfCAZIB58IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8QvPGj7v3ybLO2wB8Ihl8Ih5CJIkgHkIeiYUgHkIZiYUgHiAhIB+FgyAhIB+DhXwgE0I/iSATQjiJhSATQgeIhSASfCAgfCAQQi2JIBBCA4mFIBBCBoiFfCISIBZ8IBkgHXwiFiAYIBeFgyAXhXwgFkIyiSAWQi6JhSAWQheJhXxCo/HKtb3+m5foAHwiGXwiHUIkiSAdQh6JhSAdQhmJhSAdIB4gIYWDIB4gIYOFfCAUQj+JIBRCOImFIBRCB4iFIBN8ICJ8IBFCLYkgEUIDiYUgEUIGiIV8IhMgF3wgGSAcfCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfEL85b7v5d3gx/QAfCIZfCIcQiSJIBxCHomFIBxCGYmFIBwgHSAehYMgHSAeg4V8IBVCP4kgFUI4iYUgFUIHiIUgFHwgI3wgEkItiSASQgOJhSASQgaIhXwiFCAYfCAZIB98IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8QuDe3Jj07djS+AB8Ihl8Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgD0I/iSAPQjiJhSAPQgeIhSAVfCAkfCATQi2JIBNCA4mFIBNCBoiFfCIVIBZ8IBkgIXwiFiAYIBeFgyAXhXwgFkIyiSAWQi6JhSAWQheJhXxC8tbCj8qCnuSEf3wiGXwiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCAOQj+JIA5COImFIA5CB4iFIA98ICV8IBRCLYkgFEIDiYUgFEIGiIV8Ig8gF3wgGSAefCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfELs85DTgcHA44x/fCIZfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8IA1CP4kgDUI4iYUgDUIHiIUgDnwgEHwgFUItiSAVQgOJhSAVQgaIhXwiDiAYfCAZIB18IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8Qqi8jJui/7/fkH98Ihl8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgDEI/iSAMQjiJhSAMQgeIhSANfCARfCAPQi2JIA9CA4mFIA9CBoiFfCINIBZ8IBkgHHwiFiAYIBeFgyAXhXwgFkIyiSAWQi6JhSAWQheJhXxC6fuK9L2dm6ikf3wiGXwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAbQj+JIBtCOImFIBtCB4iFIAx8IBJ8IA5CLYkgDkIDiYUgDkIGiIV8IgwgF3wgGSAffCIXIBYgGIWDIBiFfCAXQjKJIBdCLomFIBdCF4mFfEKV8pmW+/7o/L5/fCIZfCIfQiSJIB9CHomFIB9CGYmFIB8gHCAdhYMgHCAdg4V8ICBCP4kgIEI4iYUgIEIHiIUgG3wgE3wgDUItiSANQgOJhSANQgaIhXwiGyAYfCAZICF8IhggFyAWhYMgFoV8IBhCMokgGEIuiYUgGEIXiYV8QqumyZuunt64RnwiGXwiIUIkiSAhQh6JhSAhQhmJhSAhIB8gHIWDIB8gHIOFfCAiQj+JICJCOImFICJCB4iFICB8IBR8IAxCLYkgDEIDiYUgDEIGiIV8IiAgFnwgGSAefCIWIBggF4WDIBeFfCAWQjKJIBZCLomFIBZCF4mFfEKcw5nR7tnPk0p8Ihp8Ih5CJIkgHkIeiYUgHkIZiYUgHiAhIB+FgyAhIB+DhXwgI0I/iSAjQjiJhSAjQgeIhSAifCAVfCAbQi2JIBtCA4mFIBtCBoiFfCIZIBd8IBogHXwiIiAWIBiFgyAYhXwgIkIyiSAiQi6JhSAiQheJhXxCh4SDjvKYrsNRfCIafCIdQiSJIB1CHomFIB1CGYmFIB0gHiAhhYMgHiAhg4V8ICRCP4kgJEI4iYUgJEIHiIUgI3wgD3wgIEItiSAgQgOJhSAgQgaIhXwiFyAYfCAaIBx8IiMgIiAWhYMgFoV8ICNCMokgI0IuiYUgI0IXiYV8Qp7Wg+/sup/tanwiGnwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAlQj+JICVCOImFICVCB4iFICR8IA58IBlCLYkgGUIDiYUgGUIGiIV8IhggFnwgGiAffCIkICMgIoWDICKFfCAkQjKJICRCLomFICRCF4mFfEL4orvz/u/TvnV8IhZ8Ih9CJIkgH0IeiYUgH0IZiYUgHyAcIB2FgyAcIB2DhXwgEEI/iSAQQjiJhSAQQgeIhSAlfCANfCAXQi2JIBdCA4mFIBdCBoiFfCIlICJ8IBYgIXwiIiAkICOFgyAjhXwgIkIyiSAiQi6JhSAiQheJhXxCut/dkKf1mfgGfCIWfCIhQiSJICFCHomFICFCGYmFICEgHyAchYMgHyAcg4V8IBFCP4kgEUI4iYUgEUIHiIUgEHwgDHwgGEItiSAYQgOJhSAYQgaIhXwiECAjfCAWIB58IiMgIiAkhYMgJIV8ICNCMokgI0IuiYUgI0IXiYV8QqaxopbauN+xCnwiFnwiHkIkiSAeQh6JhSAeQhmJhSAeICEgH4WDICEgH4OFfCASQj+JIBJCOImFIBJCB4iFIBF8IBt8ICVCLYkgJUIDiYUgJUIGiIV8IhEgJHwgFiAdfCIkICMgIoWDICKFfCAkQjKJICRCLomFICRCF4mFfEKum+T3y4DmnxF8IhZ8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgE0I/iSATQjiJhSATQgeIhSASfCAgfCAQQi2JIBBCA4mFIBBCBoiFfCISICJ8IBYgHHwiIiAkICOFgyAjhXwgIkIyiSAiQi6JhSAiQheJhXxCm47xmNHmwrgbfCIWfCIcQiSJIBxCHomFIBxCGYmFIBwgHSAehYMgHSAeg4V8IBRCP4kgFEI4iYUgFEIHiIUgE3wgGXwgEUItiSARQgOJhSARQgaIhXwiEyAjfCAWIB98IiMgIiAkhYMgJIV8ICNCMokgI0IuiYUgI0IXiYV8QoT7kZjS/t3tKHwiFnwiH0IkiSAfQh6JhSAfQhmJhSAfIBwgHYWDIBwgHYOFfCAVQj+JIBVCOImFIBVCB4iFIBR8IBd8IBJCLYkgEkIDiYUgEkIGiIV8IhQgJHwgFiAhfCIkICMgIoWDICKFfCAkQjKJICRCLomFICRCF4mFfEKTyZyGtO+q5TJ8IhZ8IiFCJIkgIUIeiYUgIUIZiYUgISAfIByFgyAfIByDhXwgD0I/iSAPQjiJhSAPQgeIhSAVfCAYfCATQi2JIBNCA4mFIBNCBoiFfCIVICJ8IBYgHnwiIiAkICOFgyAjhXwgIkIyiSAiQi6JhSAiQheJhXxCvP2mrqHBr888fCIWfCIeQiSJIB5CHomFIB5CGYmFIB4gISAfhYMgISAfg4V8IA5CP4kgDkI4iYUgDkIHiIUgD3wgJXwgFEItiSAUQgOJhSAUQgaIhXwiJSAjfCAWIB18IiMgIiAkhYMgJIV8ICNCMokgI0IuiYUgI0IXiYV8QsyawODJ+NmOwwB8IhR8Ih1CJIkgHUIeiYUgHUIZiYUgHSAeICGFgyAeICGDhXwgDUI/iSANQjiJhSANQgeIhSAOfCAQfCAVQi2JIBVCA4mFIBVCBoiFfCIQICR8IBQgHHwiJCAjICKFgyAihXwgJEIyiSAkQi6JhSAkQheJhXxCtoX52eyX9eLMAHwiFHwiHEIkiSAcQh6JhSAcQhmJhSAcIB0gHoWDIB0gHoOFfCAMQj+JIAxCOImFIAxCB4iFIA18IBF8ICVCLYkgJUIDiYUgJUIGiIV8IiUgInwgFCAffCIfICQgI4WDICOFfCAfQjKJIB9CLomFIB9CF4mFfEKq/JXjz7PKv9kAfCIRfCIiQiSJICJCHomFICJCGYmFICIgHCAdhYMgHCAdg4V8IAwgG0I/iSAbQjiJhSAbQgeIhXwgEnwgEEItiSAQQgOJhSAQQgaIhXwgI3wgESAhfCIMIB8gJIWDICSFfCAMQjKJIAxCLomFIAxCF4mFfELs9dvWs/Xb5d8AfCIjfCIhICIgHIWDICIgHIOFIAt8ICFCJIkgIUIeiYUgIUIZiYV8IBsgIEI/iSAgQjiJhSAgQgeIhXwgE3wgJUItiSAlQgOJhSAlQgaIhXwgJHwgIyAefCIbIAwgH4WDIB+FfCAbQjKJIBtCLomFIBtCF4mFfEKXsJ3SxLGGouwAfCIefCELICEgCnwhCiAdIAd8IB58IQcgIiAJfCEJIBsgBnwhBiAcIAh8IQggDCAFfCEFIB8gBHwhBCABQYABaiIBIAJHDQALCyAAIAQ3AzggACAFNwMwIAAgBjcDKCAAIAc3AyAgACAINwMYIAAgCTcDECAAIAo3AwggACALNwMAIANBgAFqJAAL+FsCDH8FfiMAQYAGayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOAgABAgsgASgCACICQQJ0QbTTwABqKAIAIQMMEQtBICEFIAEoAgAiAg4YAQ8CDxADDwQFBgYHBwgPCQoLDwwNEBAOAQsgASgCACECDA8LQcAAIQUMDQtBMCEFDAwLQRwhBQwLC0EwIQUMCgtBwAAhBQwJC0EQIQUMCAtBFCEFDAcLQRwhBQwGC0EwIQUMBQtBwAAhBQwEC0EcIQUMAwtBMCEFDAILQcAAIQUMAQtBGCEFCyAFIANGDQBBASEBQTkhA0GtgcAAIQIMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4YAAECAwQFBgcICQoLDA0ODxAREhMUFRYaAAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIgYgBEEoakE8aikCADcDACAEQaADakEwaiIHIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiCCAEQShqQSxqKQIANwMAIARBoANqQSBqIgkgBEEoakEkaikCADcDACAEQaADakEYaiIKIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiCyAEQShqQRRqKQIANwMAIARBoANqQQhqIgwgBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAikDQCACQcgBaiIDLQAAIgGtfDcDQCACQcgAaiEFAkAgAUGAAUYNACAFIAFqQQBBgAEgAWsQOhoLQQAhASADQQA6AAAgAiAFQn8QESAEQShqQQhqIgUgAkEIaikDACIQNwMAIARBKGpBEGogAkEQaikDACIRNwMAIARBKGpBGGogAkEYaikDACISNwMAIARBKGpBIGogAikDICITNwMAIARBKGpBKGogAkEoaikDACIUNwMAIAwgEDcDACALIBE3AwAgCiASNwMAIAkgEzcDACAIIBQ3AwAgByACQTBqKQMANwMAIAYgAkE4aikDADcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIAVBwAAQTyACIAVByAAQORogA0EAOgAAQcAAEBYiAkUNGiACIAQpA6ADNwAAIAJBOGogBEGgA2pBOGopAwA3AAAgAkEwaiAEQaADakEwaikDADcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBwAAhAwwyCyABKAIEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGGoiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARBoANqQRBqIgogBEEoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYCQCABQYABRg0AIAYgAWpBAEGAASABaxA6GgtBACEBIAVBADoAACACIAZCfxARIAMgAkEIaikDACIQNwMAIAggAkEQaikDACIRNwMAIAcgAkEYaikDACISNwMAIAkgAikDIDcDACAEQShqQShqIAJBKGopAwA3AwAgCyAQNwMAIAogETcDACAMIBI3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQSAQTyACIANByAAQORogBUEAOgAAQSAQFiICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBICEDDDELIAEoAgQhAiAEQdAEakEsakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQTA2AtAEIARBKGpBKGoiByAEQdAEakEoaikDADcDACAEQShqQSBqIgggBEHQBGpBIGopAwA3AwAgBEEoakEYaiIJIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCiAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEwaiAEQdAEakEwaigCADYCACAEIAQpA9AENwMoIARBoANqQSBqIgsgBEEoakEkaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiDSAEQShqQRRqKQIANwMAIARBoANqQQhqIg4gBEEoakEMaikCADcDACAEQaADakEoaiIPIARBKGpBLGopAgA3AwAgBCAEKQIsNwOgAyACIAIpA0AgAkHIAWoiBS0AACIBrXw3A0AgAkHIAGohBgJAIAFBgAFGDQAgBiABakEAQYABIAFrEDoaC0EAIQEgBUEAOgAAIAIgBkJ/EBEgAyACQQhqKQMAIhA3AwAgCiACQRBqKQMAIhE3AwAgCSACQRhqKQMAIhI3AwAgCCACKQMgIhM3AwAgByACQShqKQMAIhQ3AwAgDiAQNwMAIA0gETcDACAMIBI3AwAgCyATNwMAIA8gFDcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIANBMBBPIAIgA0HIABA5GiAFQQA6AABBMBAWIgJFDRogAiAEKQOgAzcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBMCEDDDALIAEoAgQhAiAEQdAEakEcakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBDGpCADcCACAEQgA3AtQEIARBIDYC0AQgBEEoakEYaiIHIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCCAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEgaiIJIARB0ARqQSBqKAIANgIAIAQgBCkD0AQ3AyggBEGgA2pBEGoiCiAEQShqQRRqKQIANwMAIARBoANqQQhqIgsgBEEoakEMaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBCAEKQIsNwOgAyACIAIpAwAgAkHoAGoiBS0AACIBrXw3AwAgAkEoaiEGAkAgAUHAAEYNACAGIAFqQQBBwAAgAWsQOhoLQQAhASAFQQA6AAAgAiAGQX8QEyADIAJBEGoiBikCACIQNwMAIAsgEDcDACAKIAJBGGoiCykCADcDACAMIAJBIGoiCikCADcDACAEIAJBCGoiDCkCACIQNwMoIAQgEDcDoAMgAxBVIAogBEEoakEoaikDADcDACALIAkpAwA3AwAgBiAHKQMANwMAIAwgCCkDADcDACACIAQpAzA3AwAgBUEAOgAAQSAQFiICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBICEDDC8LIANBAEgNEiABKAIEIQUCQAJAIAMNAEEBIQIMAQsgAxAWIgJFDRsgAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgBEEoaiAFECMgBUIANwMAIAVBIGogBUGIAWopAwA3AwAgBUEYaiAFQYABaikDADcDACAFQRBqIAVB+ABqKQMANwMAIAUgBSkDcDcDCEEAIQEgBUEoakEAQcIAEDoaAkAgBSgCkAFFDQAgBUEANgKQAQsgBEEoaiACIAMQGAwuCyABKAIEIgUgBUHYAmoiBi0AACIBakHIAWohAwJAIAFBkAFGDQAgA0EAQZABIAFrEDoaC0EAIQIgBkEAOgAAIANBAToAACAFQdcCaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkGQAUcNAAsgBRAkIARBKGpBGGoiBiAFQRhqKAAANgIAIARBKGpBEGoiByAFQRBqKQAANwMAIARBKGpBCGoiCCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDpB2AJqQQA6AABBHCEDQRwQFiICRQ0aIAIgBCkDKDcAACACQRhqIAYoAgA2AAAgAkEQaiAHKQMANwAAIAJBCGogCCkDADcAAAwtCyABKAIEIgUgBUHQAmoiBi0AACIBakHIAWohAwJAIAFBiAFGDQAgA0EAQYgBIAFrEDoaC0EAIQIgBkEAOgAAIANBAToAACAFQc8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkGIAUcNAAsgBRAkIARBKGpBGGoiBiAFQRhqKQAANwMAIARBKGpBEGoiByAFQRBqKQAANwMAIARBKGpBCGoiCCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDpB0AJqQQA6AABBICEDQSAQFiICRQ0aIAIgBCkDKDcAACACQRhqIAYpAwA3AAAgAkEQaiAHKQMANwAAIAJBCGogCCkDADcAAAwsCyABKAIEIgUgBUGwAmoiBi0AACIBakHIAWohAwJAIAFB6ABGDQAgA0EAQegAIAFrEDoaC0EAIQIgBkEAOgAAIANBAToAACAFQa8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkHoAEcNAAsgBRAkIARBKGpBKGoiBiAFQShqKQAANwMAIARBKGpBIGoiByAFQSBqKQAANwMAIARBKGpBGGoiCCAFQRhqKQAANwMAIARBKGpBEGoiCSAFQRBqKQAANwMAIARBKGpBCGoiCiAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDpBsAJqQQA6AABBMCEDQTAQFiICRQ0aIAIgBCkDKDcAACACQShqIAYpAwA3AAAgAkEgaiAHKQMANwAAIAJBGGogCCkDADcAACACQRBqIAkpAwA3AAAgAkEIaiAKKQMANwAADCsLIAEoAgQiBSAFQZACaiIGLQAAIgFqQcgBaiEDAkAgAUHIAEYNACADQQBByAAgAWsQOhoLQQAhAiAGQQA6AAAgA0EBOgAAIAVBjwJqIgEgAS0AAEGAAXI6AAADQCAFIAJqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIDIAMtAAAgAUHJAWotAABzOgAAIAFBAmoiAyADLQAAIAFBygFqLQAAczoAACABQQNqIgMgAy0AACABQcsBai0AAHM6AAAgAkEEaiICQcgARw0ACyAFECQgBEEoakE4aiIGIAVBOGopAAA3AwAgBEEoakEwaiIHIAVBMGopAAA3AwAgBEEoakEoaiIIIAVBKGopAAA3AwAgBEEoakEgaiIJIAVBIGopAAA3AwAgBEEoakEYaiIKIAVBGGopAAA3AwAgBEEoakEQaiILIAVBEGopAAA3AwAgBEEoakEIaiIMIAVBCGopAAA3AwAgBCAFKQAANwMoQQAhASAFQQBByAEQOkGQAmpBADoAAEHAACEDQcAAEBYiAkUNGiACIAQpAyg3AAAgAkE4aiAGKQMANwAAIAJBMGogBykDADcAACACQShqIAgpAwA3AAAgAkEgaiAJKQMANwAAIAJBGGogCikDADcAACACQRBqIAspAwA3AAAgAkEIaiAMKQMANwAADCoLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAEQdAEakEQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC9BACEBIAJB2ABqQQA6AAAgAkEQakL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFiICRQ0aIAIgBCkDoAM3AAAgAkEIaiAFKQMANwAADCkLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAEQdAEakEQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEIAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC5BACEBIAJB2ABqQQA6AAAgAkEQakL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFiICRQ0aIAIgBCkDoAM3AAAgAkEIaiAFKQMANwAADCgLIAEoAgQhAkEUIQNBACEBIARB0ARqQRRqQQA2AgAgBEHQBGpBDGpCADcCACAEQgA3AtQEIARBFDYC0AQgBEEoakEQaiAEQdAEakEQaikDADcDACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEQaADakEQaiIGIARBKGpBFGooAgA2AgAgBCAEKQPQBDcDKCAEIAQpAiw3A6ADIAIgAkEgaiAEQaADahAtIAJCADcDACACQeAAakEAOgAAIAJBACkD2I1ANwMIIAJBEGpBACkD4I1ANwMAIAJBGGpBACgC6I1ANgIAQRQQFiICRQ0aIAIgBCkDoAM3AAAgAkEQaiAGKAIANgAAIAJBCGogBSkDADcAAAwnCyABKAIEIQJBFCEDQQAhASAEQdAEakEUakEANgIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQRQ2AtAEIARBKGpBEGogBEHQBGpBEGopAwA3AwAgBEEoakEIaiAEQdAEakEIaikDADcDACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBEGgA2pBEGoiBiAEQShqQRRqKAIANgIAIAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQKCACQeAAakEAOgAAIAJBGGpB8MPLnnw2AgAgAkEQakL+uevF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRQQFiICRQ0aIAIgBCkDoAM3AAAgAkEQaiAGKAIANgAAIAJBCGogBSkDADcAAAwmCyABKAIEIgUgBUHYAmoiBi0AACIBakHIAWohAwJAIAFBkAFGDQAgA0EAQZABIAFrEDoaC0EAIQIgBkEAOgAAIANBBjoAACAFQdcCaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkGQAUcNAAsgBRAkIARBKGpBGGoiBiAFQRhqKAAANgIAIARBKGpBEGoiByAFQRBqKQAANwMAIARBKGpBCGoiCCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDpB2AJqQQA6AABBHCEDQRwQFiICRQ0aIAIgBCkDKDcAACACQRhqIAYoAgA2AAAgAkEQaiAHKQMANwAAIAJBCGogCCkDADcAAAwlCyABKAIEIgUgBUHQAmoiBi0AACIBakHIAWohAwJAIAFBiAFGDQAgA0EAQYgBIAFrEDoaC0EAIQIgBkEAOgAAIANBBjoAACAFQc8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkGIAUcNAAsgBRAkIARBKGpBGGoiBiAFQRhqKQAANwMAIARBKGpBEGoiByAFQRBqKQAANwMAIARBKGpBCGoiCCAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDpB0AJqQQA6AABBICEDQSAQFiICRQ0aIAIgBCkDKDcAACACQRhqIAYpAwA3AAAgAkEQaiAHKQMANwAAIAJBCGogCCkDADcAAAwkCyABKAIEIgUgBUGwAmoiBi0AACIBakHIAWohAwJAIAFB6ABGDQAgA0EAQegAIAFrEDoaC0EAIQIgBkEAOgAAIANBBjoAACAFQa8CaiIBIAEtAABBgAFyOgAAA0AgBSACaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAyADLQAAIAFByQFqLQAAczoAACABQQJqIgMgAy0AACABQcoBai0AAHM6AAAgAUEDaiIDIAMtAAAgAUHLAWotAABzOgAAIAJBBGoiAkHoAEcNAAsgBRAkIARBKGpBKGoiBiAFQShqKQAANwMAIARBKGpBIGoiByAFQSBqKQAANwMAIARBKGpBGGoiCCAFQRhqKQAANwMAIARBKGpBEGoiCSAFQRBqKQAANwMAIARBKGpBCGoiCiAFQQhqKQAANwMAIAQgBSkAADcDKEEAIQEgBUEAQcgBEDpBsAJqQQA6AABBMCEDQTAQFiICRQ0aIAIgBCkDKDcAACACQShqIAYpAwA3AAAgAkEgaiAHKQMANwAAIAJBGGogCCkDADcAACACQRBqIAkpAwA3AAAgAkEIaiAKKQMANwAADCMLIAEoAgQiBSAFQZACaiIGLQAAIgFqQcgBaiEDAkAgAUHIAEYNACADQQBByAAgAWsQOhoLQQAhAiAGQQA6AAAgA0EGOgAAIAVBjwJqIgEgAS0AAEGAAXI6AAADQCAFIAJqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIDIAMtAAAgAUHJAWotAABzOgAAIAFBAmoiAyADLQAAIAFBygFqLQAAczoAACABQQNqIgMgAy0AACABQcsBai0AAHM6AAAgAkEEaiICQcgARw0ACyAFECQgBEEoakE4aiIGIAVBOGopAAA3AwAgBEEoakEwaiIHIAVBMGopAAA3AwAgBEEoakEoaiIIIAVBKGopAAA3AwAgBEEoakEgaiIJIAVBIGopAAA3AwAgBEEoakEYaiIKIAVBGGopAAA3AwAgBEEoakEQaiILIAVBEGopAAA3AwAgBEEoakEIaiIMIAVBCGopAAA3AwAgBCAFKQAANwMoQQAhASAFQQBByAEQOkGQAmpBADoAAEHAACEDQcAAEBYiAkUNGiACIAQpAyg3AAAgAkE4aiAGKQMANwAAIAJBMGogBykDADcAACACQShqIAgpAwA3AAAgAkEgaiAJKQMANwAAIAJBGGogCikDADcAACACQRBqIAspAwA3AAAgAkEIaiAMKQMANwAADCILIAEoAgQhAkEcIQMgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGGoiBSAEQdAEakEYaikDADcDACAEQShqQRBqIgYgBEHQBGpBEGopAwA3AwAgBEEoakEIaiIHIARB0ARqQQhqKQMANwMAIARBKGpBIGogBEHQBGpBIGooAgA2AgAgBCAEKQPQBDcDKCAEQaADakEQaiIBIARBKGpBFGopAgA3AwAgBEGgA2pBCGoiCCAEQShqQQxqKQIANwMAIARBoANqQRhqIgkgBEEoakEcaikCADcDACAEIAQpAiw3A6ADIAIgAkEoaiAEQaADahAnIAUgCSgCADYCACAGIAEpAwA3AwAgByAIKQMANwMAIAQgBCkDoAM3AyggAkIANwMAQQAhASACQegAakEAOgAAIAJBACkDkI5ANwMIIAJBEGpBACkDmI5ANwMAIAJBGGpBACkDoI5ANwMAIAJBIGpBACkDqI5ANwMAQRwQFiICRQ0aIAIgBCkDKDcAACACQRhqIAUoAgA2AAAgAkEQaiAGKQMANwAAIAJBCGogBykDADcAAAwhCyABKAIEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBEEgIQMgBEEgNgLQBCAEQShqQSBqIARB0ARqQSBqKAIANgIAIARBKGpBGGoiBSAEQdAEakEYaikDADcDACAEQShqQRBqIgYgBEHQBGpBEGopAwA3AwAgBEEoakEIaiIHIARB0ARqQQhqKQMANwMAIAQgBCkD0AQ3AyggBEGgA2pBGGoiASAEQShqQRxqKQIANwMAIARBoANqQRBqIgggBEEoakEUaikCADcDACAEQaADakEIaiIJIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBEGgA2oQJyAFIAEpAwA3AwAgBiAIKQMANwMAIAcgCSkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEgAkHoAGpBADoAACACQQApA/CNQDcDCCACQRBqQQApA/iNQDcDACACQRhqQQApA4COQDcDACACQSBqQQApA4iOQDcDAEEgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAFKQMANwAAIAJBEGogBikDADcAACACQQhqIAcpAwA3AAAMIAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIARBKGpBPGopAgA3AwBBMCEDIARBoANqQTBqIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiASAEQShqQSxqKQIANwMAIARBoANqQSBqIgUgBEEoakEkaikCADcDACAEQaADakEYaiIGIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiByAEQShqQRRqKQIANwMAIARBoANqQQhqIgggBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIiAEQShqQShqIgkgASkDADcDACAEQShqQSBqIgogBSkDADcDACAEQShqQRhqIgUgBikDADcDACAEQShqQRBqIgYgBykDADcDACAEQShqQQhqIgcgCCkDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQThqQQApA6iPQDcDACACQTBqQQApA6CPQDcDACACQShqQQApA5iPQDcDACACQSBqQQApA5CPQDcDACACQRhqQQApA4iPQDcDACACQRBqQQApA4CPQDcDACACQQhqQQApA/iOQDcDACACQQApA/COQDcDACACQdABakEAOgAAQTAQFiICRQ0aIAIgBCkDKDcAACACQShqIAkpAwA3AAAgAkEgaiAKKQMANwAAIAJBGGogBSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADB8LIAEoAgQhAiAEQdAEakEMakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQSxqQgA3AgAgBEHQBGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1ARBwAAhAyAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIgEgBEEoakE8aikCADcDACAEQaADakEwaiIFIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiBiAEQShqQSxqKQIANwMAIARBoANqQSBqIgcgBEEoakEkaikCADcDACAEQaADakEYaiIIIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiCSAEQShqQRRqKQIANwMAIARBoANqQQhqIgogBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIiAEQShqQThqIgsgASkDADcDACAEQShqQTBqIgwgBSkDADcDACAEQShqQShqIgUgBikDADcDACAEQShqQSBqIgYgBykDADcDACAEQShqQRhqIgcgCCkDADcDACAEQShqQRBqIgggCSkDADcDACAEQShqQQhqIgkgCikDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQThqQQApA+iOQDcDACACQTBqQQApA+COQDcDACACQShqQQApA9iOQDcDACACQSBqQQApA9COQDcDACACQRhqQQApA8iOQDcDACACQRBqQQApA8COQDcDACACQQhqQQApA7iOQDcDACACQQApA7COQDcDACACQdABakEAOgAAQcAAEBYiAkUNGiACIAQpAyg3AAAgAkE4aiALKQMANwAAIAJBMGogDCkDADcAACACQShqIAUpAwA3AAAgAkEgaiAGKQMANwAAIAJBGGogBykDADcAACACQRBqIAgpAwA3AAAgAkEIaiAJKQMANwAADB4LIANBAEgNASABKAIEIQcCQAJAIAMNAEEBIQIMAQsgAxAWIgJFDRsgAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQfACaiIILQAAIgFqQcgBaiEGAkAgAUGoAUYNACAGQQBBqAEgAWsQOhoLQQAhBSAIQQA6AAAgBkEfOgAAIAdB7wJqIgEgAS0AAEGAAXI6AAADQCAHIAVqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBiAGLQAAIAFBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQagBRw0ACyAHECQgBEEoaiAHQcgBEDkaQQAhASAHQQBByAEQOkHwAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBqAEQOhogBEGoATYCoAMgBEHQBGogBEGgA2pBrAEQORogBEEoakHIAWogBEHQBGpBBHJBqAEQORogBEEoakHwAmpBADoAACAEQShqIAIgAxAxDB0LIANBAEgNACABKAIEIQcgAw0BQQEhAgwCCxBpAAsgAxAWIgJFDRggAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQdACaiIILQAAIgFqQcgBaiEG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B3QhBiABIQUDQCAAIAApA0BCgAF8NwNAIAAgBUIAEBEgBUGAAWohBSAGQYB/aiIGDQAMQgsLIAQgBWogASACEDkaIAUgAmohAgxBCyAAKAIEIgBByABqIQQCQEGAASAAQcgBai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAgACkDQEKAAXw3A0AgACAEQgAQESABIAZqIQEgAiAGayECCyACIAJBB3YiBiACQQBHIAJB/wBxRXEiB2siBUEHdCIIayECIAVFDT0gCEUNPSAGQQAgB2tqQQd0IQYgASEFA0AgACAAKQNAQoABfDcDQCAAIAVCABARIAVBgAFqIQUgBkGAf2oiBg0ADD4LCyAEIAVqIAEgAhA5GiAFIAJqIQIMPQsgACgCBCIAQShqIQQCQEHAACAAQegAai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAgACkDAELAAHw3AwAgACAEQQAQEyABIAZqIQEgAiAGayECCyACIAJBBnYiBiACQQBHIAJBP3FFcSIHayIFQQZ0IghrIQIgBUUNOSAIRQ05IAZBACAHa2pBBnQhBiABIQUDQCAAIAApAwBCwAB8NwMAIAAgBUEAEBMgBUHAAGohBSAGQUBqIgYNAAw6CwsgBCAFaiABIAIQORogBSACaiECDDkLIAAoAgQiCEHpAGotAABBBnQgCC0AaGoiAEUNNiAIIAEgAkGACCAAayIAIAAgAksbIgUQMxogAiAFayICRQ1CIANB+ABqQRBqIAhBEGoiACkDADcDACADQfgAakEYaiAIQRhqIgYpAwA3AwAgA0H4AGpBIGogCEEgaiIEKQMANwMAIANB+ABqQTBqIAhBMGopAwA3AwAgA0H4AGpBOGogCEE4aikDADcDACADQfgAakHAAGogCEHAAGopAwA3AwAgA0H4AGpByABqIAhByABqKQMANwMAIANB+ABqQdAAaiAIQdAAaikDADcDACADQfgAakHYAGogCEHYAGopAwA3AwAgA0H4AGpB4ABqIAhB4ABqKQMANwMAIAMgCCkDCDcDgAEgAyAIKQMoNwOgASAIQekAai0AACEHIAgtAGohCSADIAgtAGgiCjoA4AEgAyAIKQMAIh03A3ggAyAJIAdFckECciIHOgDhASADQegBakEYaiIJIAQpAgA3AwAgA0HoAWpBEGoiBCAGKQIANwMAIANB6AFqQQhqIgYgACkCADcDACADIAgpAgg3A+gBIANB6AFqIANB+ABqQShqIAogHSAHEBkgCSgCACEHIAQoAgAhBCAGKAIAIQkgAygChAIhCiADKAL8ASELIAMoAvQBIQwgAygC7AEhDSADKALoASEOIAggCCkDABApIAgoApABIgZBN08NEyAIQZABaiAGQQV0aiIAQSBqIAo2AgAgAEEcaiAHNgIAIABBGGogCzYCACAAQRRqIAQ2AgAgAEEQaiAMNgIAIABBDGogCTYCACAAQQhqIA02AgAgAEEEaiAONgIAIAggBkEBajYCkAEgCEEoaiIAQgA3AwAgAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAhBADsBaCAIQQhqIgAgCCkDcDcDACAAQQhqIAhB+ABqKQMANwMAIABBEGogCEGAAWopAwA3AwAgAEEYaiAIQYgBaikDADcDACAIIAgpAwBCAXw3AwAgASAFaiEBDDYLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQORogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCABIAhqIQELIAEgAkGQAW5BkAFsIgBqIQcgAiAAayEJIAJBjwFNDTMgAEUNMwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoAACAAQQNqIgAgAC0AACAGQQNqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCAIIQEgCCAHRg00DAALCyAKIABqIAEgAhA5GiAAIAJqIQkMMwsgACgCBCIEQcgBaiEKAkBBiAEgBEHQAmotAAAiAGsiCCACSw0AAkAgAEUNACAKIABqIAEgCBA5GiACIAhrIQJBACEFA0AgBCAFaiIAIAAtAAAgAEHIAWotAABzOgAAIABBAWoiBiAGLQAAIABByQFqLQAAczoAACAAQQJqIgYgBi0AACAAQcoBai0AAHM6AAAgAEEDaiIGIAYtAAAgAEHLAWotAABzOgAAIAVBBGoiBUGIAUcNAAsgBBAkIAEgCGohAQsgASACQYgBbkGIAWwiAGohByACIABrIQkgAkGHAU0NLyAARQ0vA0AgAUGIAWohCEEAIQUDQCAEIAVqIgAgAC0AACABIAVqIgYtAABzOgAAIABBAWoiAiACLQAAIAZBAWotAABzOgAAIABBAmoiAiACLQAAIAZBAmotAABzOgAAIABBA2oiACAALQAAIAZBA2otAABzOgAAIAVBBGoiBUGIAUcNAAsgBBAkIAghASAIIAdGDTAMAAsLIAogAGogASACEDkaIAAgAmohCQwvCyAAKAIEIgRByAFqIQoCQEHoACAEQbACai0AACIAayIIIAJLDQACQCAARQ0AIAogAGogASAIEDkaIAIgCGshAkEAIQUDQCAEIAVqIgAgAC0AACAAQcgBai0AAHM6AAAgAEEBaiIGIAYtAAAgAEHJAWotAABzOgAAIABBAmoiBiAGLQAAIABBygFqLQAAczoAACAAQQNqIgYgBi0AACAAQcsBai0AAHM6AAAgBUEEaiIFQegARw0ACyAEECQgASAIaiEBCyABIAJB6ABuQegAbCIAaiEHIAIgAGshCSACQecATQ0rIABFDSsDQCABQegAaiEIQQAhBQNAIAQgBWoiACAALQAAIAEgBWoiBi0AAHM6AAAgAEEBaiICIAItAAAgBkEBai0AAHM6AAAgAEECaiICIAItAAAgBkECai0AAHM6AAAgAEEDaiIAIAAtAAAgBkEDai0AAHM6AAAgBUEEaiIFQegARw0ACyAEECQgCCEBIAggB0YNLAwACwsgCiAAaiABIAIQORogACACaiEJDCsLIAAoAgQiBEHIAWohCgJAQcgAIARBkAJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQORogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFq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OgDiASADQfgAaiABIAAQMxogDCALKQMANwMAIAxBCGogBSkDADcDACAMQRBqIAYpAwA3AwAgDEEYaiAHKQMANwMAIAogCSkDADcDACAKQQhqIA4pAwA3AwAgCkEQaiAXKQMANwMAIApBGGogGCkDADcDACAKQSBqIBkpAwA3AwAgCkEoaiAaKQMANwMAIApBMGogGykDADcDACAKQThqIBwpAwA3AwAgAy0A4gEhDiADLQDhASEXIAMgAy0A4AEiGDoAcCADIAMpA3giHjcDCCADIA4gF0VyQQJyIg46AHEgA0HoAWpBGGoiFyAHKQIANwMAIANB6AFqQRBqIgcgBikCADcDACADQegBakEIaiIGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBggHiAOEBkgFygCACEOIAcoAgAhByAGKAIAIRcgAygChAIhGCADKAL8ASEZIAMoAvQBIRogAygC7AEhGyADKALoASEcIAggCCkDABApIAgoApABIgZBN08NCSANIAZBBXRqIgUgGDYCHCAFIA42AhggBSAZNgIUIAUgBzYCECAFIBo2AgwgBSAXNgIIIAUgGzYCBCAFIBw2AgAgCCAGQQFqNgKQAQsgCCAIKQMAIB18Ih43AwAgAiAASQ0JIAEgAGohASACIABrIgJBgAhLDQALCyACRQ0TIAggASACEDMaIAggCCkDABApDBMLIAAgAkGghcAAEEkACyAFQcAAQeCEwAAQSQALIAZBwABB8ITAABBJAAsgBkEgQYCFwAAQSQALIANBkAJqQQhqIgEgGjYCACADQZACakEQaiIAIBg2AgAgA0GQAmpBGGoiBSAONgIAIAMgGTYCnAIgA0GBAWoiBiABKQMANwAAIAMgFzYCpAIgA0GJAWoiASAAKQMANwAAIAMgBzYCrAIgA0GRAWoiACAFKQMANwAAIAMgGzYClAIgAyAcNgKQAiADIAMpA5ACNwB5IANBCGpBGGogACkAADcDACADQQhqQRBqIAEpAAA3AwAgA0EIakEIaiAGKQAANwMAIAMgAykAeTcDCEGQksAAIANBCGpBgIbAAEH4hsAAEEAACyADQZACakEIaiIBIBQ2AgAgA0GQAmpBEGoiACASNgIAIANBkAJqQRhqIgUgEDYCACADIBM2ApwCIANBgQFqIgYgASkDADcAACADIBE2AqQC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BEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGopAgA3AAAgBEHIAGogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABakEUaikCADcAACAEQTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEEAOgBoQQMhBQwiCwJAAkACQAJAIANBuoDAAEEKEFFFDQAgA0HEgMAAQQoQUUUNASADQc6AwABBChBRRQ0CIANB2IDAAEEKEFFFDQMgA0HogMAAQQoQUQ0MQegAEBYiBEUNFiACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARCADcDACAEQQA6AGAgBEEAKQPYjUA3AwggBEEQakEAKQPgjUA3AwAgBEEYakEAKALojUA2AgBBCyEFDCULQeACEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBBkAEQOhogAkGQATYCACACQbABaiACQZQBEDkaIAVByAFqIAJBsAFqQQRyQZABEDkaIAVBADoA2AJBBSEFDCQLQdgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBBiAEQOhogAkGIATYCACACQbABaiACQYwBEDkaIAVByAFqIAJBsAFqQQRyQYgBEDkaIAVBADoA0AJBBiEFDCMLQbgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBB6AAQOhogAkHoADYCACACQbABaiACQewAEDkaIAVByAFqIAJBsAFqQQRyQegAEDkaIAVBADoAsAJBByEFDCILQZgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBByAAQOhogAkHIADYCACACQbABaiACQcwAEDkaIAVByAFqIAJBsAFqQQRyQcgAEDkaIAVBADoAkAJBCCEFDCELAkAgA0HigMAAQQMQUUUNACADQeWAwABBAxBRDQhB4AAQFiIERQ0RIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDkaIARB0ABqIAJBsAFqQTxqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANwAAIARBOGogAkGwAWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIANwAAIARBIGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8ermbzcDCCAEQgA3AwAgBEEAOgBYQQohBQwhC0HgABAWIgRFDQ8gAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQORogBEHQAGogAkGwAWpBPGopAgA3AAAgBEHIAGogAkGwAWpBNGopAgA3AAAgBEHAAGogAkGwAWpBLGopAgA3AAAgBEE4aiACQbABakEkaikCADcAACAEQTBqIAJBsAFqQRxqKQIANwAAIARBKGogAkGwAWpBFGopAgA3AAAgBEEgaiACQbABakEMaikCADcAACAEIAIpArQBNwAYIARC/rnrxemOlZkQNwMQIARCgcaUupbx6uZvNwMIIARCADcDACAEQQA6AFhBCSEFDCALAkACQAJAAkAgAykAAELTkIWa08WMmTRRDQAgAykAAELTkIWa08XMmjZRDQEgAykAAELTkIWa0+WMnDRRDQIgAykAAELTkIWa06XNmDJRDQMgAykAAELTkIXa1KiMmThRDQcgAykAAELTkIXa1MjMmjZSDQpB2AIQFiIERQ0eIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNgIAIAJBsAFqIAJBjAEQORogBUHIAWogAkGwAWpBBHJBiAEQORogBUEAOgDQAkEWIQUMIwtB4AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGQARA6GiACQZABNgIAIAJBsAFqIAJBlAEQORogBUHIAWogAkGwAWpBBHJBkAEQORogBUEAOgDYAkENIQUMIgtB2AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNgIAIAJBsAFqIAJBjAEQORogBUHIAWogAkGwAWpBBHJBiAEQORogBUEAOgDQAkEOIQUMIQtBuAIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEHoABA6GiACQegANgIAIAJBsAFqIAJB7AAQORogBUHIAWogAkGwAWpBBHJB6AAQORogBUEAOgCwAkEPIQUMIAtBmAIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEHIABA6GiACQcgANgIAIAJBsAFqIAJBzAAQORogBUHIAWogAkGwAWpBBHJByAAQORogBUEAOgCQAkEQIQUMHwtB8AAQFiIERQ0UIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDkaIARB4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJBsAFqQSxqKQIANwAAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOGogAkGwAWpBFGopAgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARCADcDACAEQQA6AGggBEEAKQOQjkA3AwggBEEQakEAKQOYjkA3AwAgBEEYakEAKQOgjkA3AwAgBEEgakEAKQOojkA3AwBBESEFDB4LQfAAEBYiBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5GiAEQeAAaiACQbABakE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikCADcAACAEQcgAaiACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQRRqKQIANwAAIARBMGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkD8I1ANwMIIARBEGpBACkD+I1ANwMAIARBGGpBACkDgI5ANwMAIARBIGpBACkDiI5ANwMAQRIhBQwdC0HYARAWIgRFDRQgAkEANgIAIAJBBHJBAEGAARA6GiACQYABNgIAIAJBsAFqIAJBhAEQORogBEHQAGogAkGwAWpBBHJBgAEQORogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA/COQDcDACAEQQhqQQApA/iOQDcDACAEQRBqQQApA4CPQDcDACAEQRhqQQApA4iPQDcDACAEQSBqQQApA5CPQDcDACAEQShqQQApA5iPQDcDACAEQTBqQQApA6CPQDcDACAEQThqQQApA6iPQDcDAEETIQUMHAtB+AIQFiIERQ0VIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGoARA6GiACQagBNgIAIAJBsAFqIAJBrAEQORogBUHIAWogAkGwAWpBBHJBqAEQORogBUEAOgDwAkEVIQUMGwsgA0HygMAAQQUQUUUNFyADQZOBwABBBRBRDQFB6AAQFiIERQ0WIARCADcDACAEQQApA/iRQDcDCCAEQRBqQQApA4CSQDcDACAEQRhqQQApA4iSQDcDACACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARBADoAYEEXIQUMGgsgA0G0gMAAQQYQUUUNFwtBASEEQZiB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IBtqIhdqIhUgBnNBFHciBmoiCXM2AgggACABIAogEGogFyAdc0EZdyIQaiIXaiAXIA1zQRB3IgEgEmoiDSAQc0EUdyIQaiIXIAFzQRh3IgEgDWoiDSALIBggB2ogBCAIc0EZdyIIaiIHaiAHIA5zQRB3IgcgD2oiDyAIc0EUdyIIaiIOczYCBCAAIA4gB3NBGHciByAPaiIPIBdzNgIMIAAgCSAFc0EYdyIFIBVqIg4gE3M2AgAgACACIBFzQRl3IAVzNgIUIAAgDSAQc0EZdyAHczYCECAAIA4gBnNBGXcgDHM2AhwgACAPIAhzQRl3IAFzNgIYC5EiAg5/An4jAEGgD2siASQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAEEEaiECAkACQAJAAkACQCAAKAIEDhgAAQIDBB4dHBsaGRgXFhUUExIREA8ODQwACyACKAIEIQNB0AEQFiICRQ0GIAFBCGpBOGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEMgASAPNwNIIAIgAUEIakHQARA5GkEAIQMMHwsgAigCBCEDQdABEBYiAkUNBiABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIAMpA0AhDyABQQhqQcgAaiADQcgAahBDIAEgDzcDSCACIAFBCGpB0AEQORpBASEDDB4LIAIoAgQhA0HQARAWIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAGogA0HIAGoQQyABIA83A0ggAiABQQhqQdABEDkaQQIhAwwdCyACKAIEIQNB8AAQFiICRQ0GIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEoaiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkEDIQMMHAsgAigCBCEDQfgOEBYiAkUNBiABQQhqQYgBaiADQYgBaikDADcDACABQQhqQYABaiADQYABaikDADcDACABQQhqQfgAaiADQfgAaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBwABqIANBwABqKQMANwMAIAFBCGpByABqIANByABqKQMANwMAIAFBCGpB0ABqIANB0ABqKQMANwMAIAFBCGpB2ABqIANB2ABqKQMANwMAIAFBCGpB4ABqIANB4ABqKQMANwMAIAEgAykDcDcDeCABIAMpAwg3AxAgASADKQMoNwMwIAMpAwAhDyADLQBqIQQgAy0AaSEFIAMtAGghBgJAIAMoApABQQV0IgcNAEEAIQcMGwsgAUGAD2pBGGoiCCADQZQBaiIJQRhqKQAANwMAIAFBgA9qQRBqIgogCUEQaikAADcDACABQYAPakEIaiILIAlBCGopAAA3AwAgASAJKQAANwOADyADQdQBaiEJQQAgB0FgakEFdmshDCABQbwBaiEDQQIhBwNAIANBYGoiDSABKQOADzcAACANQRhqIAgpAwA3AAAgDUEQaiAKKQMANwAAIA1BCGogCykDADcAAAJAAkAgDCAHaiIOQQJGDQAgCCAJQWBqIg1BGGopAAA3AwAgCiANQRBqKQAANwMAIAsgDUEIaikAADcDACABIA0pAAA3A4APIAdBOEcNARBqAAsgB0F/aiEHDBwLIAMgASkDgA83AAAgA0EYaiAIKQMANwAAIANBEGogCikDADcAACADQQhqIAspAwA3AAAgDkEBRg0bIAggCUEYaikAADcDACAKIAlBEGopAAA3AwAgCyAJQQhqKQAANwMAIAEgCSkAADcDgA8gA0HAAGohAyAHQQJqIQcgCUHAAGohCQwACwsQbgALEG8AC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HwAEEIQQAoAvjUQCIBQQQgARsRBQAAC0H4DkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHoABAWIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpBIGogA0EgahA3IAEgDzcDCCACIAFBCGpB6AAQORpBFyEDDBQLQegAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBYiAkUNACABQQhqIANByAEQORogAUEIakHIAWogA0HIAWoQRCACIAFBCGpB2AIQORpBFiEDDBMLQdgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQfgCEBYiAkUNACABQQhqIANByAEQORogAUEIakHIAWogA0HIAWoQRSACIAFBCGpB+AIQORpBFSEDDBILQfgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgBEBYiAkUNACABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIANByABqKQMAIQ8gAykDQCEQIAFBCGpB0ABqIANB0ABqEEMgAUEIakHIAGogDzcDACABIBA3A0ggAiABQQhqQdgBEDkaQRQhAwwRC0HYAUEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHYARAWIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhq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ASAFOgBxIAEgBjoAcCABIA83AwggAiABQQhqQfgOEDkaQQQhAwsgACAAKAIAQX9qNgIAAkBBDBAWIgBFDQAgACACNgIIIAAgAzYCBCAAQQA2AgAgAUGgD2okACAADwtBDEEEQQAoAvjUQCIBQQQgARsRBQAAC6MSARp/IwBBwABrIQMgACgCACgCACIEIAQpAwAgAq18NwMAAkAgAkEGdCICRQ0AIAEgAmohBSAEKAIUIQYgBCgCECEHIAQoAgwhAiAEKAIIIQgDQCADQRhqIgBCADcDACADQSBqIglCADcDACADQThqQgA3AwAgA0EwakIANwMAIANBKGpCADcDACADQQhqIgogAUEIaikAADcDACADQRBqIgsgAUEQaikAADcDACAAIAFBGGooAAAiDDYCACAJIAFBIGooAAAiDTYCACADIAEpAAA3AwAgAyABQRxqKAAAIg42AhwgAyABQSRqKAAAIg82AiQgCigCACIQIAwgAUEoaigAACIRIAFBOGooAAAiEiABQTxqKAAAIhMgAygCDCIUIA4gAUEsaigAACIVIA4gFCATIBUgEiARIAwgByAQaiAGIAMoAgQiFmogCCACIAdxaiAGIAJBf3NxaiADKAIAIhdqQfjIqrt9akEHdyACaiIAIAJxaiAHIABBf3NxakHW7p7GfmpBDHcgAGoiCSAAcWogAiAJQX9zcWpB2+GBoQJqQRF3IAlqIgpqIAMoAhQiGCAJaiAAIAsoAgAiGWogAiAUaiAKIAlxaiAAIApBf3NxakHunfeNfGpBFncgCmoiACAKcWogCSAAQX9zcWpBr5/wq39qQQd3IABqIgkgAHFqIAogCUF/c3FqQaqMn7wEakEMdyAJaiIKIAlxaiAAIApBf3NxakGTjMHBempBEXcgCmoiC2ogDyAKaiANIAlqIA4gAGogCyAKcWogCSALQX9zcWpBgaqaampBFncgC2oiACALcWogCiAAQX9zcWpB2LGCzAZqQQd3IABqIgkgAHFqIAsgCUF/c3FqQa/vk9p4akEMdyAJaiIKIAlxaiAAIApBf3NxakGxt31qQRF3IApqIgtqIAFBNGooAAAiGiAKaiABQTBqKAAAIhsgCWogFSAAaiALIApxaiAJIAtBf3NxakG+r/PKeGpBFncgC2oiACALcWogCiAAQX9zcWpBoqLA3AZqQQd3IABq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A0EBdmtBH3EgA0EfRht0IQIDQCAFIAJBHXZBBHFqQRBqIgYoAgAiA0UNAiACQQF0IQIgAyEFIAMoAgRBeHEgAEcNAAsLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQA2AgAgASADNgIMIAEgADYCCAwCCyAGIAE2AgAgAUEYaiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAoAsTYQEF/aiIBNgLE2EAgAQ0DQQAoArTYQCIADQFB/x8hAQwCCyAAQQN2IgNBA3RBjNXAAGohAAJAAkBBACgChNVAIgJBASADdCIDcUUNACAAKAIIIQMMAQtBACACIANyNgKE1UAgACEDCyAAIAE2AgggAyABNgIMIAEgADYCDCABIAM2AggPC0EAIQEDQCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQAgATYCxNhADwsLlQwBGH8jACECIAAoAgAhAyAAKAIIIQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhqIgdCADcDACACQSBqIghCADcDACACQThqIglCADcDACACQTBqIgpCADcDACACQShqIgtCADcDACACQQhqIgwgASkACDcDACACQRBqIg0gASkAEDcDACAHIAEoABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3AwAgAiABKAAcIhA2AhwgAiABKAAkIhE2AiQgCyABKAAoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIhM2AgAgAiABKAA0Igo2AjQgCSABKAA4IhQ2AgAgAiABKAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4gBiAEIAUgBiADIAYgBHFqIAUgBkF/c3FqIAIoAgAiFmpBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3ciByABcWogBiAHQX9zcWogDCgCACIMakELdyIIIAdxaiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEgAWogByAJQX9zcWogDSgCACINakEDdyIBIAlxIAdqIAggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIaiAJIAJBf3NxampBC3ciByACcSAJaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAIcSACaiAHIAFBf3NxampBB3ciAiABcSAHaiAIIAJBf3NxampBC3ciByACcSAI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BCEDIAJBCGoiBEHAABBPIAMgBEHIABA5QcgBakEAOgAADBcLIAMoAgQhAyACQQhqIgRBIBBPIAMgBEHIABA5QcgBakEAOgAADBYLIAMoAgQhAyACQQhqIgRBMBBPIAMgBEHIABA5QcgBakEAOgAADBULIAMoAgQhAyACQQhqEFUgA0EgaiACQShqKQMANwMAIANBGGogAkEgaikDADcDACADQRBqIAJBGGopAwA3AwAgA0EIaiACQRBqKQMANwMAIAMgAikDCDcDACADQegAakEAOgAADBQLIAMoAgQiA0IANwMAIAMgAykDcDcDCCADQSBqIANBiAFqKQMANwMAIANBGGogA0GAAWopAwA3AwAgA0EQaiADQfgAaikDADcDACADQShqQQBBwgAQOhogAygCkAFFDRMgA0EANgKQAQwTCyADKAIEQQBByAEQOkHYAmpBADoAAAwSCyADKAIEQQBByAEQOkHQAmpBADoAAAwRCyADKAIEQQBByAEQOkGwAmpBADoAAAwQCyADKAIEQQBByAEQOkGQAmpBADoAAAwPCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAAIANBEGpC/rnrxemOlZkQNwMADA4LIAMoAgQiA0KBxpS6lvHq5m83AwggA0IANwMAIANB2ABqQQA6AAAgA0EQakL+uevF6Y6VmRA3AwAMDQsgAygCBCIDQgA3AwAgA0HgAGpBADoAACADQQApA9iNQDcDCCADQRBqQQApA+CNQDcDACADQRhqQQAoAuiNQDYCAAwMCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAAIANBGGpB8MPLnnw2AgAgA0EQakL+uevF6Y6VmRA3AwAMCwsgAygCBEEAQcgBEDpB2AJqQQA6AAAMCgsgAygCBEEAQcgBEDpB0AJqQQA6AAAMCQsgAygCBEEAQcgBEDpBsAJqQQA6AAAMCAsgAygCBEEAQcgBEDpBkAJqQQA6AAAMBwsgAygCBCIDQgA3AwAgA0HoAGpBADoAACADQQApA5COQDcDCCADQRBqQQApA5iOQDcDACADQRhqQQApA6COQDcDACADQSBqQQApA6iOQDcDAAwGCyADKAIEIgNCADcDACADQegAakEAOgAAIANBACkD8I1ANwMIIANBEGpBACkD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QYCA/AdxciAAQQh2QYD+A3EgAEEYdnJyNgAcIANB0AFqJAALogYCA38CfiMAQfABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqQRBqIABBGGooAgA2AgAgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCAGQgmGIAStQgOGhCIGQgiIQoCAgPgPgyAGQhiIQoCA/AeDhCAGQiiIQoD+A4MgBkI4iISEIQcgBkI4hiAGQiiGQoCAgICAgMD/AIOEIAZCGIZCgICAgIDgP4MgBkIIhkKAgICA8B+DhIQhBgJAIARBP3MiAEUNACAFQQFqQQAgABA6GgsgBiAHhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIANBCGogAUEBEBQMAQsgA0EIaiABQQEQFCADQeAAakEMakIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDkaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgakEBEBQLIAFBwABqQQA6AAAgAiADKAIIIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYAACACIAMoAgwiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAEIAIgAygCECIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAggAiADKAIUIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYADCACIAMoAhgiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAQIANB8AFqJAALsgYBFX8jAEGwAWsiAiQAAkACQAJAIAAoApABIgMgAXunIgRNDQAgAEHwAGohBSACQShqIQYgAkEIaiEH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QT9zIgBFDQAgBUEBakEAIAAQOhoLIAYgB4QhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADQQhqIAEQEgwBCyADQQhqIAEQEiADQeAAakEMakIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDkaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahASCyACIAMoAgg2AAAgAiADKQIMNwAEIAIgAykCFDcADCABQcAAakEAOgAAIANB8AFqJAAL8AMCA38CfiMAQfABayIDJAAgAUHAAGotAAAhBCAAKQMAIQYgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCABIARqIgBBgAE6AAAgBkIJhiEGIAStQgOGIQcgAyADQQhqNgIcAkAgBEE/cyIFRQ0AIABBAWpBACAFEDoaCyAHIAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgA0EcaiABEBwMAQsgA0EcaiABEBwgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HAADYCYCADQagBaiADQeAAakHEABA5GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEkaikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBakEMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQRxqIANBIGoQHAsgAUHAAGpBADoAACACIAMpAwg3AAAgAiADKQMQNwAIIANB8AFqJAAL2QMCA38CfiMAQeABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIARQ0AIAVBAWpBACAAEDoaCyAHIAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgAyABEB8MAQsgAyABEB8gA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcCACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAWpCADcCACADQgA3AlQgA0HAADYCUCADQZgBaiADQdAAakHEABA5GiADQcAAaiADQZgBakE0aikCADcDACADQThqIANBmAFqQSxqKQIANwMAIANBMGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcaikCADcDACADQSBqIANBmAFqQRRqKQIANwMAIANBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECADIAY3A0ggAyADQRBqEB8LIAIgAykDADcAACACIAMpAwg3AAggAUHAAGpBADoAACADQeABaiQAC9QDAgR/An4jAEHQAWsiAyQAIAEgAUHAAGotAAAiBGoiBUEBOgAAIAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEDoaCyAHIAiEIQcCQAJAIARBOHFBOEYNACABQThqIAc3AAAgAEEIaiABQQEQFwwBCyAAQQhqIgQgAUEBEBcgA0HAAGpBDGpCADcCACADQcAAakEUakIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIANwIAIANBwABqQTRqQgA3AgAgA0H8AGpCADcCACADQgA3AkQgA0HAADYCQCADQYgBaiADQcAAakHEABA5GiADQTBqIANBiAFqQTRqKQIANwMAIANBKGogA0GIAWpBLGopAgA3AwAgA0EgaiADQYgBakEkaikCADcDACADQRhqIANBiAFqQRxqKQIANwMAIANBEGogA0GIAWpBFGopAgA3AwAgA0EIaiADQYgBakEMaikCADcDACADIAMpAowBNwMAIAMgBzcDOCAEIANBARAXCyABQcAAakEAOgAAIAIgACkDCDcAACACIABBEGopAwA3AAggAiAAQRhqKQMANwAQIANB0AFqJAALlwMBBX8jAEGQBGsiAyQAIABByAFqIQQCQAJAAkACQAJAIABB8AJqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEDkgBmohASACIAZrIQILIAIgAkGoAW4iBUGoAWwiB0kNASACIAdrIQYCQCAFQagBbCICRQ0AIAEhBQNAIANB4AJqIABBqAEQORogABAkIAUgA0HgAmpBqAEQOUGoAWohBSACQdh+aiICDQALCwJAIAYNAEEAIQYMBAsgA0EANgKwASADQbABakEEckEAQagBEDoaIANBqAE2ArABIANB4AJqIANBsAFqQawBEDkaIANBCGogA0HgAmpBBHJBqAEQORogA0HgAmogAEGoARA5GiAAECQgA0EIaiADQeACakGoARA5GiAGQakBTw0CIAEgB2ogA0EIaiAGEDkaIAQgA0EIakGoARA5GgwDCyABIAQgBWogAhA5GiAFIAJqIQYMAgtBoY3AAEEjQcSNwAAQUwALIAZBqAFBxIzAABBJAAsgAEHwAmogBjoAACADQZAEaiQAC5cDAQV/IwBBsANrIgMkACAAQcgBaiEEAkACQAJAAkACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhA5IAZqIQEgAiAGayECCyACIAJBiAFuIgVBiAFsIgdJDQEgAiAHayEGAkAgBUGIAWwiAkUNACABIQUDQCADQaACaiAAQYgBEDkaIAAQJCAFIANBoAJqQYgBEDlBiAFqIQUgAkH4fmoiAg0ACwsCQCAGDQBBACEGDAQLIANBADYCkAEgA0GQAWpBBHJBAEGIARA6GiADQYgBNgKQASADQaACaiADQZABakGMARA5GiADQQhqIANBoAJqQQRyQYgBEDkaIANBoAJqIABBiAEQORogABAkIANBCGogA0GgAmpBiAEQORogBkGJAU8NAiABIAdqIANBCGogBhA5GiAEIANBCGpBiAEQORoMAwsgASAEIAVqIAIQORogBSACaiEGDAILQaGNwABBI0HEjcAAEFMACyAGQYgBQcSMwAAQSQALIABB0AJqIAY6AAAgA0GwA2okAAuCAwEDfwJAAkACQAJAIAAtAGgiA0UNAAJAIANBwQBPDQAg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AAuaAQEDfyMAQRBrIgQkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAIAQgAUEEaiACQQBHIAMQDiAEQQhqKAIAIQMgBCgCBCECAkACQCAEKAIAIgVBAUYNAEEAIQYMAQsgAiADEAAiBiECCyABQQA2AgAgACAFNgIMIAAgBjYCCCAAIAM2AgQgACACNgIAIARBEGokAA8LEG4ACxBvAAt+AQF/IwBBwABrIgQkACAEQSs2AgwgBCAANgIIIAQgAjYCFCAEIAE2AhAgBEEsakECNgIAIARBPGpBATYCACAEQgI3AhwgBEGYiMAANgIYIARBAjYCNCAEIARBMGo2AiggBCAEQRBqNgI4IAQgBEEIajYCMCAEQRhqIAMQVgALfgECfyMAQTBrIgIkACACQRRqQQI2AgAgAkG4h8AANgIQIAJBAjYCDCACQZiHwAA2AgggAUEcaigCACEDIAEoAhghASACQSxqQQI2AgAgAkICNwIcIAJBmIjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC34BAn8jAEEwayICJAAgAkEUakECNgIAIAJBuIfAADYCECACQQI2AgwgAkGYh8AANgIIIAFBHGooAgAhAyABKAIYIQEgAkEsakECNgIAIAJCAjcCHCACQZiIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqECshASACQTBqJAAgAQt0AQJ/IwBBkAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GAAUcNAAsgAkGAATYCACACQYgBaiACQYQBEDkaIAAgAkGIAWpBBHJBgAEQOSABLQCAAToAgAEgAkGQAmokAAt0AQJ/IwBBoAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GIAUcNAAsgAkGIATYCACACQZABaiACQYwBEDkaIAAgAkGQAWpBBHJBiAEQOSABLQCIAToAiAEgAkGgAmokAAt0AQJ/IwBB4AJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GoAUcNAAsgAkGoATYCACACQbABaiACQawBEDkaIAAgAkGwAWpBBHJBqAEQOSABLQCoAToAqAEgAkHgAmokAAtyAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0HIAEcNAAsgAkHIADYCACACQdAAaiACQcwAEDkaIAAgAkHQAGpBBHJByAAQOSABLQBIOgBIIAJBoAFqJAALcgECfyMAQeABayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACADQQRqIgNB6ABHDQALIAJB6AA2AgAgAkHwAGogAkHsABA5GiAAIAJB8ABqQQRyQegAEDkgAS0AaDoAaCACQeABaiQAC3QBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgA0EEaiIDQZABRw0ACyACQZABNgIAIAJBmAFqIAJBlAEQORogACACQZgBakEEckGQARA5IAEtAJABOgCQASACQbACaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQciKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBWAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GoisAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQVgALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANB/IrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFYAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQcyLwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBWAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GEiMAANgIIIANBAzYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQVgALdQECf0EBIQBBAEEAKAKA1UAiAUEBajYCgNVAAkACQEEAKALI2EBBAUcNAEEAKALM2EBBAWohAAwBC0EAQQE2AsjYQAtBACAANgLM2EACQCABQQBIDQAgAEECSw0AQQAoAvzUQEF/TA0AIABBAUsNABBzAAsAC5oBACMAQTBrGiAAQgA3A0AgAEE4akL5wvibkaOz8NsANwMAIABBMGpC6/qG2r+19sEfNwMAIABBKGpCn9j52cKR2oKbfzcDACAAQtGFmu/6z5SH0QA3AyAgAELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7fzcDCCAAIAGtQoiS95X/zPmE6gCFNwMAC1UBAn8CQAJAIABFDQAgACgCAA0BIABBADYCACAAKAIIIQEgACgCBCECIAAQHgJAIAJBBEcNACABKAKQAUUNACABQQA2ApABCyABEB4PCxBuAAsQbwALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLVAEBfwJAAkACQCABQYCAxABGDQBBASEEIAAoAhggASAAQRxqKAIAKAIQEQYADQELIAINAUEAIQQLIAQPCyAAKAIYIAIgAyAAQRxqKAIAKAIMEQgAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIANBoJHAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEFYACzkAAkACQCABRQ0AIAEoAgANASABQX82AgAgAUEEaiACEDYgAUEANgIAIABCADcDAA8LEG4ACxBvAAtSACAAQsfMo9jW0Ouzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhqQv+kuYjFkdqCm383AwAgAEEQakLy5rvjo6f9p6V/NwMACzQBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQcCHwAA2AgQgAkGgkcAANgIAIAIQZwALIwACQCAAQXxLDQACQCAADQBBBA8LIAAQFiIARQ0AIAAPCwALJQACQCAADQBBsI/AAEEwEHAACyAAIAIgAyAEIAUgASgCEBEMAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEKAAsjAAJAIAANAEGwj8AAQTAQcAALIAAg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OjpieXRlX29mZnNldDo6X193YmdfYnl0ZU9mZnNldF80MjA0ZWNiMjRhNmU1ZGY5OjpoOGY0YmM4MWQ5MGE4MjMzZQRManNfc3lzOjpVaW50OEFycmF5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl9mYWNmMDM5OGEyODFjODViOjpoMGZiNjA5YTUxNjQ3NmU5MgV5anNfc3lzOjpVaW50OEFycmF5OjpuZXdfd2l0aF9ieXRlX29mZnNldF9hbmRfbGVuZ3RoOjpfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmOjpoYzI4MjE3ODU0OTVlMmE2MgZManNfc3lzOjpVaW50OEFycmF5OjpsZW5ndGg6Ol9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiOjpoNzNkYzkyYWJjODFkM2ZhNwcyd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX21lbW9yeTo6aDRjOWRjYzlmYzQzMmZlMmMIVWpzX3N5czo6V2ViQXNzZW1ibHk6Ok1lbW9yeTo6YnVmZmVyOjpfX3diZ19idWZmZXJfMzk3ZWFhNGQ3MmVlOTRkZDo6aDM5ZDIzMjAwNzgzMjBiYzAJRmpzX3N5czo6VWludDhBcnJheTo6bmV3OjpfX3diZ19uZXdfYTdjZTQ0N2YxNWZmNDk2Zjo6aDZjZjg5NDdiODY4ZmRlZWYKRmpzX3N5czo6VWludDhBcnJheTo6c2V0OjpfX3diZ19zZXRfOTY5YWQwYTYwZTUxZDMyMDo6aDUxN2Q1OGEyM2QyYjc4MTkLMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDY5MTE5ZDhjZWJhYTQ0M2YMQGRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdDo6aDgyOGE3MDExNDE1ZjA1MjANLHNoYTI6OnNoYTUxMjo6Y29tcHJlc3M1MTI6Omg2YjEwYzMzYWQwNWMzNWY2DkpkZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3RfYW5kX3Jlc2V0OjpoZjlkNDIwYzUyNDhhOTJmNg9AZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6dXBkYXRlOjpoMWFhNzQ2YmE5ZTJlMTdhNRAsc2hhMjo6c2hhMjU2Ojpjb21wcmVzczI1Njo6aGU4NzgwMjljY2ZkZDNkZjQRM2JsYWtlMjo6Qmxha2UyYlZhckNvcmU6OmNvbXByZXNzOjpoOWY4N2E3NmE4ZmJlZTIyYhIpcmlwZW1kOjpjMTYwOjpjb21wcmVzczo6aDE4OWM0NzlmYmQ2N2FmYWQTM2JsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6OmNvbXByZXNzOjpoOWRkYTljMmEyYjYxNzY4ORQrc2hhMTo6Y29tcHJlc3M6OmNvbXByZXNzOjpoNTBlNWQ4M2U5MWQ2NTRhYRU7ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6Om5ldzo6aGY0NjA2NTg2NmYzZDY2NjAWOmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aDJhMjcyMDdlZTlhZjdmZTkXLHRpZ2VyOjpjb21wcmVzczo6Y29tcHJlc3M6Omg2ZDI1OGZiZjc1NDhiZmUxGC1ibGFrZTM6Ok91dHB1dFJlYWRlcjo6ZmlsbDo6aGE5YzI3MGM5YjdmZjQxZWUZNmJsYWtlMzo6cG9ydGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoYzRhZDc0NzdjYmY1MmYwZRoTZGlnZXN0Y29udGV4dF9jbG9uZRtlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aGU3N2FmYjMxMmY4OGY0MzccaDxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6e3tjbG9zdXJlfX06Omg3OThjNzA3YzdjZGEzNTkyHTBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aDk5NWY5MmEwOTlkOTg2MzQeOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6OmhjYjc5NDdhOWE3ZTI4MmNhHyBtZDQ6OmNvbXByZXNzOjpoOTBkNTQwMzZjYTYzM2UzYyBBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZGlzcG9zZV9jaHVuazo6aDJmOTBiZGRmYWI5ZmRhZjkhE2RpZ2VzdGNvbnRleHRfcmVzZXQicjxzaGEyOjpjb3JlX2FwaTo6U2hhNTEyVmFyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoOWVhNGEyMTU4ZTA3MDMzYiMvYmxha2UzOjpIYXNoZXI6OmZpbmFsaXplX3hvZjo6aGI4ODNlNmM1YzRlNWQ0MGIkIGtlY2Nhazo6ZjE2MDA6OmhhODI1NzkwY2YyNWE1ZjVlJSxjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkOjpoNDlkMmNmY2NhZmJiZGU0ZCYOX19ydXN0X3JlYWxsb2MncjxzaGEyOjpjb3JlX2FwaTo6U2hhMjU2VmFyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoMDNhOTMwYjhjNzRjOWVkNShdPHNoYTE6OlNoYTFDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhiNWQ5ZWM3MDI0OGUxODIwKTFibGFrZTM6Okhhc2hlcjo6bWVyZ2VfY3Zfc3RhY2s6Omg0N2I2ZTI0ZTY3ZTIxNjViKjVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoYzY2OTQ3YjFkZWQ1NzhhYSsjY29yZTo6Zm10Ojp3cml0ZTo6aGJiYWYzOWYwOWJmNDllZmIsNGJsYWtlMzo6Y29tcHJlc3NfcGFyZW50c19wYXJhbGxlbDo6aGEwNzMyZmFjYjEyNzY5YmItZDxyaXBlbWQ6OlJpcGVtZDE2MENvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGRlOGZjMmFmNzExZjE4NWYuWzxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDBiMzAwM2U0ODQyOWFjM2QvWzxtZDQ6Ok1kNENvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDNlMmIzMDA3MzBhYThhZjAwXzx0aWdlcjo6VGlnZXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg0NTczYTQwZWJjNTRjYTUzMWU8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoZTUwZWUyZjliMmYyYmQ0YTJlPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aDZkN2E3MzhlNTE0MWViZTAzLWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpoYzU4OGE4Y2Q3YzI2Y2VmNTQvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDY2MjhhM2U3MjI3ZTg1NTM1BmRpZ2VzdDY+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OnVwZGF0ZTo6aDEzYWE5MGI2YzVlZGM0ODY3WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDU2ZDNhMWQ5YzZmOTE3YmU4G2RpZ2VzdGNvbnRleHRfZGlnZXN0QW5kRHJvcDkGbWVtY3B5OgZtZW1zZXQ7P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZDk2N2Y0MzRjNzJmNGU0MjwRZGlnZXN0Y29udGV4dF9uZXc9FGRpZ2VzdGNvbnRleHRfZGlnZXN0Pi1qc19zeXM6OlVpbnQ4QXJyYXk6OnRvX3ZlYzo6aDYzOWJmOTBlOTEwZTgxZDQ/HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXRALmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxlZDo6aGQ1ODRlZmI3Yjg0YmYzMjZBUDxhcnJheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4Y2EzNjljOTgxMGMyMjI5QlA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYWJkMmI2NDNkZDBlY2QyY0NbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMDhkN2U1MzhlNjI5MDQzOERbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoODc3ODZlMzY2MmMyNmQ2NEVbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNWExYTExYjkwNmU5M2QwM0ZbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNDUyMGIyMWMwYzI5ODk4Y0dbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoYzQ4ZjUyNTk0NDZjMmVlY0hbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMWM0ZTBjNjhlY2Q2NmI1NEk/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmhjM2UwZGNmNmQ4NjZlMWJlSkFjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoNmMxMDlhYzg1ODdmMjkxMUs9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoZDI3ZGMzODVhN2VjMTNjMUxOY29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6bGVuX21pc21hdGNoX2ZhaWw6OmhlZGQxMGM1YmNjMDI2MTBjTTZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aGNlMDUwMmY2MzcxMWZhZDhON3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdGhfaG9vazo6aDYwNmQ3YzdmN2E0MjNiOThPOmJsYWtlMjo6Qmxha2UyYlZhckNvcmU6Om5ld193aXRoX3BhcmFtczo6aDU4N2Y5YTcyNzlmMzcxNmRQGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZVEGbWVtY21wUkNjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9wcmVmaXg6OmhhYTBhZGYwMGNiNjdkZWQ3Uyljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoZWMxZmMwNTdiZDBiYWYwYlQUZGlnZXN0Y29udGV4dF91cGRhdGVVOmJsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6Om5ld193aXRoX3BhcmFtczo6aDVmZjQ1OWYyMzFhYjhkNjhWLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm10OjpoNjMxNGI1YzkxYWJlNzM0OVcRX193YmluZGdlbl9tYWxsb2NYP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoMDhiMDAxNWQ0NTZmMjBjN1k/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzYWI0ZThkMTgzNDk0OWU4Wj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDBlZmUyNDJjN2Q3ZmU2MGVbP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoYzRhYTBlM2VmMWQ2ZDdhMVw/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg3OTlhYmFiYmRjZDEyZmEzXT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGE5NDFjMTBjNDA4ODhjNTBeP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoMTE4OWQ1YjVlY2U4MjQxYV8/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmhiZGM0ZjBhM2ViZGQ5MDg2YD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UyX211dDo6aGE2NDc2YjFhNTZlZDFhYjZhQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDliOTg1YTI5M2FhYzRjZTFiEl9fd2JpbmRnZW5fcmVhbGxvY2M/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMV9tdXQ6OmgwNzE4MzRjY2I3MGRmNzI1ZDJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNWE3ZGY5MWI1ZDYwOTBjYmUwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwZDljZDYyNmRhYmFhMWVmZjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDMwM2JjMTZhZWU1NTkxMGcRcnVzdF9iZWdpbl91bndpbmRoD19fd2JpbmRnZW5fZnJlZWk0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93OjpoNGI0OTAxNDgzMGNhZmU2M2ozYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcGFuaWM6OmgzN2Q1OThkNzVkMGQyZTZmazljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aDJhYjg2NzY3ZWMxN2M1MGRsH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXJtTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoMDQ2ZWNjNWVhYWIzNGNkNW4xd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoM2Q3YjQ3NDgzNGRkZjJkOW8yd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aGU1Njk3Y2E4ZTIxZWQ1YTVwKndhc21fYmluZGdlbjo6dGhyb3dfc3RyOjpoNWViNDYxODBmZTVlMWQxYXFJc3RkOjpzeXNfY29tbW9uOjpiYWNrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoYTAzYWJlZjAyYThiNzBmZHIxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYTBjNDQ5MjIxNmQ0ZDJlN3MKcnVzdF9wYW5pY3Q3c3RkOjphbGxvYzo6ZGVmYXVsdF9hbGxvY19lcnJvcl9ob29rOjpoZjljMzkzYmEzY2QyODdlMXVvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVyczo6Y29waWVkOjpDb3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46Omg2M2MyZTE0OTdiNTJmM2Q3AO+AgIAACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS41Ny4wIChmMWVkZDA0MjkgMjAyMS0xMS0yOSkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4GMC4yLjgx");
  const wasmModule = new WebAssembly.Module(wasmBytes);
  return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.147.0/_wasm_crypto/mod.ts
var digestAlgorithms = [
  "BLAKE2B-256",
  "BLAKE2B-384",
  "BLAKE2B",
  "BLAKE2S",
  "BLAKE3",
  "KECCAK-224",
  "KECCAK-256",
  "KECCAK-384",
  "KECCAK-512",
  "SHA-384",
  "SHA3-224",
  "SHA3-256",
  "SHA3-384",
  "SHA3-512",
  "SHAKE128",
  "SHAKE256",
  "TIGER",
  "RIPEMD-160",
  "SHA-224",
  "SHA-256",
  "SHA-512",
  "MD4",
  "MD5",
  "SHA-1"
];

// deno:https://deno.land/std@0.147.0/encoding/hex.ts
var hexTable = new TextEncoder().encode("0123456789abcdef");
function encode3(src) {
  const dst = new Uint8Array(src.length * 2);
  for (let i = 0; i < dst.length; i++) {
    const v = src[i];
    dst[i * 2] = hexTable[v >> 4];
    dst[i * 2 + 1] = hexTable[v & 15];
  }
  return dst;
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/hash.ts
var coerceToBytes = (data) => {
  if (data instanceof Uint8Array) {
    return data;
  } else if (typeof data === "string") {
    return new TextEncoder().encode(data);
  } else if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    throw new TypeError("expected data to be string | BufferSource");
  }
};
var Hash = class extends transform_default {
  #context;
  constructor(algorithm, _opts) {
    super({
      transform(chunk, _encoding, callback) {
        context.update(coerceToBytes(chunk));
        callback();
      },
      flush(callback) {
        this.push(context.digest(void 0));
        callback();
      }
    });
    if (typeof algorithm === "string") {
      algorithm = algorithm.toUpperCase();
      if (opensslToWebCryptoDigestNames[algorithm]) {
        algorithm = opensslToWebCryptoDigestNames[algorithm];
      }
      this.#context = new (instantiate()).DigestContext(algorithm);
    } else {
      this.#context = algorithm;
    }
    const context = this.#context;
  }
  copy() {
    return new Hash(this.#context.clone());
  }
  update(data, _encoding) {
    let bytes;
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
      bytes = coerceToBytes(data);
    } else {
      bytes = coerceToBytes(data);
    }
    this.#context.update(bytes);
    return this;
  }
  digest(encoding) {
    const digest2 = this.#context.digest(void 0);
    if (encoding === void 0) {
      return Buffer3.from(digest2);
    }
    switch (encoding) {
      case "hex":
        return new TextDecoder().decode(encode3(new Uint8Array(digest2)));
      case "binary":
        return String.fromCharCode(...digest2);
      case "base64":
        return encode(digest2);
      default:
        throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
    }
  }
};
var Hmac = class extends transform_default {
  constructor(hmac, _key, _options) {
    validateString(hmac, "hmac");
    super();
    notImplemented("crypto.Hmac");
  }
  digest(_encoding) {
    notImplemented("crypto.Hmac.prototype.digest");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Hmac.prototype.update");
  }
};
var opensslToWebCryptoDigestNames = {
  BLAKE2B512: "BLAKE2B",
  BLAKE2S256: "BLAKE2S",
  RIPEMD160: "RIPEMD-160",
  RMD160: "RIPEMD-160",
  SHA1: "SHA-1",
  SHA224: "SHA-224",
  SHA256: "SHA-256",
  SHA384: "SHA-384",
  SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
  return new Hash(algorithm, opts);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/pbkdf2.ts
var MAX_ALLOC = Math.pow(2, 30) - 1;
var createHasher = (algorithm) => (value) => Buffer3.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros2) {
  return Buffer3.alloc(zeros2);
}
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function toBuffer(bufferable) {
  if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
    return Buffer3.from(bufferable);
  } else {
    return Buffer3.from(bufferable.buffer);
  }
}
var Hmac2 = class {
  constructor(alg, key2, saltLen) {
    this.hash = createHasher(alg);
    const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    if (key2.length > blocksize) {
      key2 = this.hash(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer3.concat([key2, getZeroes(blocksize - key2.length)], blocksize);
    }
    const ipad = Buffer3.allocUnsafe(blocksize + sizes[alg]);
    const opad = Buffer3.allocUnsafe(blocksize + sizes[alg]);
    for (let i = 0; i < blocksize; i++) {
      ipad[i] = key2[i] ^ 54;
      opad[i] = key2[i] ^ 92;
    }
    const ipad1 = Buffer3.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.size = sizes[alg];
  }
  run(data, ipad) {
    data.copy(ipad, this.blocksize);
    const h = this.hash(ipad);
    h.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
  }
};
function pbkdf2Sync(password, salt, iterations, keylen, digest2 = "sha1") {
  if (typeof iterations !== "number" || iterations < 0) {
    throw new TypeError("Bad iterations");
  }
  if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
    throw new TypeError("Bad key length");
  }
  const bufferedPassword = toBuffer(password);
  const bufferedSalt = toBuffer(salt);
  const hmac = new Hmac2(digest2, bufferedPassword, bufferedSalt.length);
  const DK = Buffer3.allocUnsafe(keylen);
  const block1 = Buffer3.allocUnsafe(bufferedSalt.length + 4);
  bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
  let destPos = 0;
  const hLen = sizes[digest2];
  const l = Math.ceil(keylen / hLen);
  for (let i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, bufferedSalt.length);
    const T = hmac.run(block1, hmac.ipad1);
    let U = T;
    for (let j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2);
      for (let k3 = 0; k3 < hLen; k3++)
        T[k3] ^= U[k3];
    }
    T.copy(DK, destPos);
    destPos += hLen;
  }
  return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest2 = "sha1", callback) {
  setTimeout(() => {
    let err = null, res;
    try {
      res = pbkdf2Sync(password, salt, iterations, keylen, digest2);
    } catch (e) {
      err = e;
    }
    if (err) {
      callback(err instanceof Error ? err : new Error("[non-error thrown]"));
    } else {
      callback(null, res);
    }
  }, 0);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/scrypt.ts
var fixOpts = (opts) => {
  const out = { N: 16384, p: 1, r: 8, maxmem: 32 << 20 };
  if (!opts)
    return out;
  if (opts.N)
    out.N = opts.N;
  else if (opts.cost)
    out.N = opts.cost;
  if (opts.p)
    out.p = opts.p;
  else if (opts.parallelization)
    out.p = opts.parallelization;
  if (opts.r)
    out.r = opts.r;
  else if (opts.blockSize)
    out.r = opts.blockSize;
  if (opts.maxmem)
    out.maxmem = opts.maxmem;
  return out;
};
function blockxor(S, Si, D, Di, len) {
  let i = -1;
  while (++i < len)
    D[Di + i] ^= S[Si + i];
}
function arraycopy(src, srcPos, dest, destPos, length) {
  src.copy(dest, destPos, srcPos, srcPos + length);
}
var R = (a, b) => a << b | a >>> 32 - b;
var ScryptRom = class {
  constructor(b, r, N2, p) {
    this.B = b;
    this.r = r;
    this.N = N2;
    this.p = p;
    this.XY = Buffer3.allocUnsafe(256 * r);
    this.V = Buffer3.allocUnsafe(128 * r * N2);
    this.B32 = new Int32Array(16);
    this.x = new Int32Array(16);
    this._X = Buffer3.allocUnsafe(64);
  }
  run() {
    const p = this.p | 0;
    const r = this.r | 0;
    for (let i = 0; i < p; i++)
      this.scryptROMix(i, r);
    return this.B;
  }
  scryptROMix(i, r) {
    const blockStart = i * 128 * r;
    const offset = (2 * r - 1) * 64;
    const blockLen = 128 * r;
    const B = this.B;
    const N2 = this.N | 0;
    const V = this.V;
    const XY = this.XY;
    B.copy(XY, 0, blockStart, blockStart + blockLen);
    for (let i1 = 0; i1 < N2; i1++) {
      XY.copy(V, i1 * blockLen, 0, blockLen);
      this.blockmix_salsa8(blockLen);
    }
    let j;
    for (let i2 = 0; i2 < N2; i2++) {
      j = XY.readUInt32LE(offset) & N2 - 1;
      blockxor(V, j * blockLen, XY, 0, blockLen);
      this.blockmix_salsa8(blockLen);
    }
    XY.copy(B, blockStart, 0, blockLen);
  }
  blockmix_salsa8(blockLen) {
    const BY = this.XY;
    const r = this.r;
    const _X = this._X;
    arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
    let i;
    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64);
      this.salsa20_8();
      arraycopy(_X, 0, BY, blockLen + i * 64, 64);
    }
    for (i = 0; i < r; i++) {
      arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
      arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r) * 64, 64);
    }
  }
  salsa20_8() {
    const B32 = this.B32;
    const B = this._X;
    const x = this.x;
    let i;
    for (i = 0; i < 16; i++) {
      B32[i] = (B[i * 4 + 0] & 255) << 0;
      B32[i] |= (B[i * 4 + 1] & 255) << 8;
      B32[i] |= (B[i * 4 + 2] & 255) << 16;
      B32[i] |= (B[i * 4 + 3] & 255) << 24;
    }
    for (i = 0; i < 16; i++)
      x[i] = B32[i];
    for (i = 0; i < 4; i++) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }
    for (i = 0; i < 16; i++)
      B32[i] += x[i];
    let bi;
    for (i = 0; i < 16; i++) {
      bi = i * 4;
      B[bi + 0] = B32[i] >> 0 & 255;
      B[bi + 1] = B32[i] >> 8 & 255;
      B[bi + 2] = B32[i] >> 16 & 255;
      B[bi + 3] = B32[i] >> 24 & 255;
    }
  }
  clean() {
    this.XY.fill(0);
    this.V.fill(0);
    this._X.fill(0);
    this.B.fill(0);
    for (let i = 0; i < 16; i++) {
      this.B32[i] = 0;
      this.x[i] = 0;
    }
  }
};
function scryptSync(password, salt, keylen, _opts) {
  const { N: N2, r, p, maxmem } = fixOpts(_opts);
  const blen = p * 128 * r;
  if (32 * r * (N2 + 2) * 4 + blen > maxmem) {
    throw new Error("excedes max memory");
  }
  const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
  const scryptRom = new ScryptRom(b, r, N2, p);
  const out = scryptRom.run();
  const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
  scryptRom.clean();
  return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
  if (!cb) {
    cb = _opts;
    _opts = null;
  }
  const { N: N2, r, p, maxmem } = fixOpts(_opts);
  const blen = p * 128 * r;
  if (32 * r * (N2 + 2) * 4 + blen > maxmem) {
    throw new Error("excedes max memory");
  }
  try {
    const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b, r, N2, p);
    const out = scryptRom.run();
    const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    cb(null, result);
  } catch (err) {
    return cb(err);
  }
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ecb.js
var ecb_exports = {};
__export(ecb_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
var encrypt = function(self2, block) {
  return self2._cipher.encryptBlock(block);
};
var decrypt = function(self2, block) {
  return self2._cipher.decryptBlock(block);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cbc.js
var cbc_exports = {};
__export(cbc_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2
});

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/xor.ts
function xor(a, b) {
  const length = Math.min(a.length, b.length);
  const buffer = Buffer3.allocUnsafe(length);
  for (let i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i];
  }
  return buffer;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cbc.js
var encrypt2 = function(self2, block) {
  const data = xor(block, self2._prev);
  self2._prev = self2._cipher.encryptBlock(data);
  return self2._prev;
};
var decrypt2 = function(self2, block) {
  const pad3 = self2._prev;
  self2._prev = block;
  const out = self2._cipher.decryptBlock(block);
  return xor(out, pad3);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cfb.js
var cfb_exports = {};
__export(cfb_exports, {
  encrypt: () => encrypt3
});
function encryptStart(self2, data, decrypt4) {
  const len = data.length;
  const out = xor(data, self2._cache);
  self2._cache = self2._cache.slice(len);
  self2._prev = Buffer3.concat([self2._prev, decrypt4 ? data : out]);
  return out;
}
var encrypt3 = function(self2, data, decrypt4) {
  let out = Buffer3.allocUnsafe(0);
  let len;
  while (data.length) {
    if (self2._cache.length === 0) {
      self2._cache = self2._cipher.encryptBlock(self2._prev);
      self2._prev = Buffer3.allocUnsafe(0);
    }
    if (self2._cache.length <= data.length) {
      len = self2._cache.length;
      out = Buffer3.concat([
        out,
        encryptStart(self2, data.slice(0, len), decrypt4)
      ]);
      data = data.slice(len);
    } else {
      out = Buffer3.concat([out, encryptStart(self2, data, decrypt4)]);
      break;
    }
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cfb8.js
var cfb8_exports = {};
__export(cfb8_exports, {
  encrypt: () => encrypt4
});
function encryptByte(self2, byteParam, decrypt4) {
  const pad3 = self2._cipher.encryptBlock(self2._prev);
  const out = pad3[0] ^ byteParam;
  self2._prev = Buffer3.concat([
    self2._prev.slice(1),
    Buffer3.from([decrypt4 ? byteParam : out])
  ]);
  return out;
}
var encrypt4 = function(self2, chunk, decrypt4) {
  const len = chunk.length;
  const out = Buffer3.allocUnsafe(len);
  let i = -1;
  while (++i < len) {
    out[i] = encryptByte(self2, chunk[i], decrypt4);
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cfb1.js
var cfb1_exports = {};
__export(cfb1_exports, {
  encrypt: () => encrypt5
});
function encryptByte2(self2, byteParam, decrypt4) {
  let pad3;
  let i = -1;
  const len = 8;
  let out = 0;
  let bit, value;
  while (++i < len) {
    pad3 = self2._cipher.encryptBlock(self2._prev);
    bit = byteParam & 1 << 7 - i ? 128 : 0;
    value = pad3[0] ^ bit;
    out += (value & 128) >> i % 8;
    self2._prev = shiftIn(self2._prev, decrypt4 ? bit : value);
  }
  return out;
}
function shiftIn(buffer, value) {
  const len = buffer.length;
  let i = -1;
  const out = Buffer3.allocUnsafe(buffer.length);
  buffer = Buffer3.concat([buffer, Buffer3.from([value])]);
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
  }
  return out;
}
var encrypt5 = function(self2, chunk, decrypt4) {
  const len = chunk.length;
  const out = Buffer3.allocUnsafe(len);
  let i = -1;
  while (++i < len) {
    out[i] = encryptByte2(self2, chunk[i], decrypt4);
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ofb.js
var ofb_exports = {};
__export(ofb_exports, {
  encrypt: () => encrypt6
});
function getBlock(self2) {
  self2._prev = self2._cipher.encryptBlock(self2._prev);
  return self2._prev;
}
var encrypt6 = function(self2, chunk) {
  while (self2._cache.length < chunk.length) {
    self2._cache = Buffer3.concat([self2._cache, getBlock(self2)]);
  }
  const pad3 = self2._cache.slice(0, chunk.length);
  self2._cache = self2._cache.slice(chunk.length);
  return xor(chunk, pad3);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ctr.js
var ctr_exports = {};
__export(ctr_exports, {
  encrypt: () => encrypt7
});

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/incr32.js
function incr32(iv) {
  let len = iv.length;
  let item;
  while (len--) {
    item = iv.readUInt8(len);
    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ctr.js
function getBlock2(self2) {
  const out = self2._cipher.encryptBlockRaw(self2._prev);
  incr32(self2._prev);
  return out;
}
var blockSize = 16;
var encrypt7 = function(self2, chunk) {
  const chunkNum = Math.ceil(chunk.length / blockSize);
  const start = self2._cache.length;
  self2._cache = Buffer3.concat([
    self2._cache,
    Buffer3.allocUnsafe(chunkNum * blockSize)
  ]);
  for (let i = 0; i < chunkNum; i++) {
    const out = getBlock2(self2);
    const offset = start + i * blockSize;
    self2._cache.writeUInt32BE(out[0], offset + 0);
    self2._cache.writeUInt32BE(out[1], offset + 4);
    self2._cache.writeUInt32BE(out[2], offset + 8);
    self2._cache.writeUInt32BE(out[3], offset + 12);
  }
  const pad3 = self2._cache.slice(0, chunk.length);
  self2._cache = self2._cache.slice(chunk.length);
  return xor(chunk, pad3);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/mod.js
var GCM = ctr_exports;
var modeModules = {
  ECB: ecb_exports,
  CBC: cbc_exports,
  CFB: cfb_exports,
  CFB8: cfb8_exports,
  CFB1: cfb1_exports,
  OFB: ofb_exports,
  CTR: ctr_exports,
  GCM
};
var MODES = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
};
for (const mode of Object.values(MODES)) {
  mode.module = modeModules[mode.mode];
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/aes.js
function asUInt32Array(buf) {
  if (!Buffer3.isBuffer(buf))
    buf = Buffer3.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);
  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }
  return out;
}
function scrubVec(v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0;
  }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s02 = M[0] ^ keySchedule[0];
  var s1 = M[1] ^ keySchedule[1];
  var s2 = M[2] ^ keySchedule[2];
  var s3 = M[3] ^ keySchedule[3];
  var t02, t1, t2, t3;
  var ksRow = 4;
  for (var round = 1; round < nRounds; round++) {
    t02 = SUB_MIX0[s02 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s02 & 255] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s02 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s02 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
    s02 = t02;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }
  t02 = (SBOX[s02 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s02 & 255]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s02 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s02 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
  t02 = t02 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [t02, t1, t2, t3];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
var G = function() {
  var d = new Array(256);
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1;
    } else {
      d[j] = j << 1 ^ 283;
    }
  }
  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [[], [], [], []];
  var INV_SUB_MIX = [[], [], [], []];
  var x = 0;
  var xi = 0;
  for (var i = 0; i < 256; ++i) {
    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
    sx = sx >>> 8 ^ sx & 255 ^ 99;
    SBOX[x] = sx;
    INV_SBOX[sx] = x;
    var x2 = d[x];
    var x4 = d[x2];
    var x8 = d[x4];
    var t = d[sx] * 257 ^ sx * 16843008;
    SUB_MIX[0][x] = t << 24 | t >>> 8;
    SUB_MIX[1][x] = t << 16 | t >>> 16;
    SUB_MIX[2][x] = t << 8 | t >>> 24;
    SUB_MIX[3][x] = t;
    t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
    INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
    INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
    INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
    INV_SUB_MIX[3][sx] = t;
    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]];
      xi ^= d[d[xi]];
    }
  }
  return {
    SBOX,
    INV_SBOX,
    SUB_MIX,
    INV_SUB_MIX
  };
}();
function AES(key2) {
  this._key = asUInt32Array(key2);
  this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];
  for (var k3 = 0; k3 < keySize; k3++) {
    keySchedule[k3] = keyWords[k3];
  }
  for (k3 = keySize; k3 < ksRows; k3++) {
    var t = keySchedule[k3 - 1];
    if (k3 % keySize === 0) {
      t = t << 8 | t >>> 24;
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
      t ^= RCON[k3 / keySize | 0] << 24;
    } else if (keySize > 6 && k3 % keySize === 4) {
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
    }
    keySchedule[k3] = keySchedule[k3 - keySize] ^ t;
  }
  var invKeySchedule = [];
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
    }
  }
  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
  M = asUInt32Array(M);
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
  var out = this.encryptBlockRaw(M);
  var buf = Buffer3.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};
AES.prototype.decryptBlock = function(M) {
  M = asUInt32Array(M);
  var m12 = M[1];
  M[1] = M[3];
  M[3] = m12;
  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer3.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/cipher_base.js
function CipherBase(hashMode) {
  transform_default.call(this);
  this.hashMode = typeof hashMode === "string";
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
CipherBase.prototype = Object.create(transform_default.prototype, {
  constructor: {
    value: CipherBase,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
  if (typeof data === "string") {
    data = Buffer3.from(data, inputEnc);
  }
  var outData = this._update(data);
  if (this.hashMode)
    return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function() {
};
CipherBase.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase.prototype._flush = function(done) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
  var outData = this.__final() || Buffer3.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc)
    throw new Error("can't switch encodings");
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var cipher_base_default = CipherBase;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/ghash.js
var ZEROES = Buffer3.alloc(16, 0);
function toArray(buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ];
}
function fromArray(out) {
  var buf = Buffer3.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}
function GHASH(key2) {
  this.h = key2;
  this.state = Buffer3.alloc(16, 0);
  this.cache = Buffer3.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
  var i = -1;
  while (++i < block.length) {
    this.state[i] ^= block[i];
  }
  this._multiply();
};
GHASH.prototype._multiply = function() {
  var Vi = toArray(this.h);
  var Zi2 = [0, 0, 0, 0];
  var j, xi, lsbVi;
  var i = -1;
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
    if (xi) {
      Zi2[0] ^= Vi[0];
      Zi2[1] ^= Vi[1];
      Zi2[2] ^= Vi[2];
      Zi2[3] ^= Vi[3];
    }
    lsbVi = (Vi[3] & 1) !== 0;
    for (j = 3; j > 0; j--) {
      Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
    }
    Vi[0] = Vi[0] >>> 1;
    if (lsbVi) {
      Vi[0] = Vi[0] ^ 225 << 24;
    }
  }
  this.state = fromArray(Zi2);
};
GHASH.prototype.update = function(buf) {
  this.cache = Buffer3.concat([this.cache, buf]);
  var chunk;
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};
GHASH.prototype.final = function(abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer3.concat([this.cache, ZEROES], 16));
  }
  this.ghash(fromArray([0, abl, 0, bl]));
  return this.state;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/auth_cipher.js
function xorTest(a, b) {
  var out = 0;
  if (a.length !== b.length)
    out++;
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; ++i) {
    out += a[i] ^ b[i];
  }
  return out;
}
function calcIv(self2, iv, ck) {
  if (iv.length === 12) {
    self2._finID = Buffer3.concat([iv, Buffer3.from([0, 0, 0, 1])]);
    return Buffer3.concat([iv, Buffer3.from([0, 0, 0, 2])]);
  }
  var ghash = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash.update(iv);
  if (toPad) {
    toPad = 16 - toPad;
    ghash.update(Buffer3.alloc(toPad, 0));
  }
  ghash.update(Buffer3.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer3.alloc(8);
  tail.writeUIntBE(ivBits, 2, 6);
  ghash.update(tail);
  self2._finID = ghash.state;
  var out = Buffer3.from(self2._finID);
  incr32(out);
  return out;
}
function StreamCipher(mode, key2, iv, decrypt4) {
  cipher_base_default.call(this);
  var h = Buffer3.alloc(4, 0);
  this._cipher = new AES(key2);
  var ck = this._cipher.encryptBlock(h);
  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer3.from(iv);
  this._cache = Buffer3.allocUnsafe(0);
  this._secCache = Buffer3.allocUnsafe(0);
  this._decrypt = decrypt4;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}
StreamCipher.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: StreamCipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
StreamCipher.prototype._update = function(chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;
    if (rump < 16) {
      rump = Buffer3.alloc(rump, 0);
      this._ghash.update(rump);
    }
  }
  this._called = true;
  var out = this._mode.encrypt(this, chunk);
  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }
  this._len += chunk.length;
  return out;
};
StreamCipher.prototype._final = function() {
  if (this._decrypt && !this._authTag) {
    throw new Error("Unsupported state or unable to authenticate data");
  }
  var tag2 = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag2, this._authTag)) {
    throw new Error("Unsupported state or unable to authenticate data");
  }
  this._authTag = tag2;
  this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer3.isBuffer(this._authTag)) {
    throw new Error("Attempting to get auth tag in unsupported state");
  }
  return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag2) {
  if (!this._decrypt) {
    throw new Error("Attempting to set auth tag in unsupported state");
  }
  this._authTag = tag2;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
  if (this._called) {
    throw new Error("Attempting to set AAD in unsupported state");
  }
  this._ghash.update(buf);
  this._alen += buf.length;
};
var auth_cipher_default = StreamCipher;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/stream_cipher.js
function StreamCipher2(mode, key2, iv, decrypt4) {
  cipher_base_default.call(this);
  this._cipher = new AES(key2);
  this._prev = Buffer3.from(iv);
  this._cache = Buffer3.allocUnsafe(0);
  this._secCache = Buffer3.allocUnsafe(0);
  this._decrypt = decrypt4;
  this._mode = mode;
}
StreamCipher2.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: StreamCipher2,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
StreamCipher2.prototype._update = function(chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher2.prototype._final = function() {
  this._cipher.scrub();
};
var stream_cipher_default = StreamCipher2;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/evp_bytes_to_key.ts
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer3.isBuffer(password))
    password = Buffer3.from(password, "binary");
  if (salt) {
    if (!Buffer3.isBuffer(salt))
      salt = Buffer3.from(salt, "binary");
    if (salt.length !== 8) {
      throw new RangeError("salt should be Buffer with 8 byte length");
    }
  }
  let keyLen = keyBits / 8;
  const key2 = Buffer3.alloc(keyLen);
  const iv = Buffer3.alloc(ivLen || 0);
  let tmp = Buffer3.alloc(0);
  while (keyLen > 0 || ivLen > 0) {
    const hash = createHash("md5");
    hash.update(tmp);
    hash.update(password);
    if (salt)
      hash.update(salt);
    tmp = hash.digest();
    let used = 0;
    if (keyLen > 0) {
      const keyStart = key2.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key2, keyStart, 0, used);
      keyLen -= used;
    }
    if (used < tmp.length && ivLen > 0) {
      const ivStart = iv.length - ivLen;
      const length = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }
  tmp.fill(0);
  return { key: key2, iv };
}
var evp_bytes_to_key_default = EVP_BytesToKey;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/encrypter.js
function Cipher(mode, key2, iv) {
  cipher_base_default.call(this);
  this._cache = new Splitter();
  this._cipher = new AES(key2);
  this._prev = Buffer3.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
Cipher.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: Cipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Cipher.prototype._update = function(data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }
  return Buffer3.concat(out);
};
var PADDING = Buffer3.alloc(16, 16);
Cipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);
    this._cipher.scrub();
    return chunk;
  }
  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();
    throw new Error("data not multiple of block length");
  }
};
Cipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter() {
  this.cache = Buffer3.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
  this.cache = Buffer3.concat([this.cache, data]);
};
Splitter.prototype.get = function() {
  if (this.cache.length > 15) {
    const out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }
  return null;
};
Splitter.prototype.flush = function() {
  var len = 16 - this.cache.length;
  var padBuff = Buffer3.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }
  return Buffer3.concat([this.cache, padBuff]);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/decrypter.js
function Decipher(mode, key2, iv) {
  cipher_base_default.call(this);
  this._cache = new Splitter2();
  this._last = void 0;
  this._cipher = new AES(key2);
  this._prev = Buffer3.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
Decipher.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: Decipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Decipher.prototype._update = function(data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }
  return Buffer3.concat(out);
};
Decipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error("data not multiple of block length");
  }
};
Decipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter2() {
  this.cache = Buffer3.allocUnsafe(0);
}
Splitter2.prototype.add = function(data) {
  this.cache = Buffer3.concat([this.cache, data]);
};
Splitter2.prototype.get = function(autoPadding) {
  var out;
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }
  return null;
};
Splitter2.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(last) {
  var padded = last[15];
  if (padded < 1 || padded > 16) {
    throw new Error("unable to decrypt data");
  }
  var i = -1;
  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error("unable to decrypt data");
    }
  }
  if (padded === 16)
    return;
  return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config)
    throw new TypeError("invalid suite type");
  if (typeof iv === "string")
    iv = Buffer3.from(iv);
  if (config.mode !== "GCM" && iv.length !== config.iv) {
    throw new TypeError("invalid iv length " + iv.length);
  }
  if (typeof password === "string")
    password = Buffer3.from(password);
  if (password.length !== config.key / 8) {
    throw new TypeError("invalid key length " + password.length);
  }
  if (config.type === "stream") {
    return new stream_cipher_default(config.module, password, iv, true);
  } else if (config.type === "auth") {
    return new auth_cipher_default(config.module, password, iv, true);
  }
  return new Decipher(config.module, password, iv);
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/mod.js
function getCiphers() {
  return Object.keys(MODES);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/util.ts
var defaultEncoding = "buffer";
function getDefaultEncoding() {
  return defaultEncoding;
}
function toBuf(val, encoding) {
  if (typeof val === "string") {
    if (encoding === "buffer") {
      encoding = "utf8";
    }
    return Buffer3.from(val, encoding);
  }
  return val;
}
var validateByteSource = hideStackFrames((val, name) => {
  val = toBuf(val);
  if (isAnyArrayBuffer2(val) || isArrayBufferView(val)) {
    return;
  }
  throw new ERR_INVALID_ARG_TYPE(name, ["string", "ArrayBuffer", "TypedArray", "DataView", "Buffer"], val);
});
function getHashes() {
  return digestAlgorithms;
}
function getCurves() {
  notImplemented("crypto.getCurves");
}
function secureHeapUsed() {
  notImplemented("crypto.secureHeapUsed");
}
function setEngine(_engine, _flags) {
  notImplemented("crypto.setEngine");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/keys.ts
var KeyObject = class {
  constructor(type, handle) {
    if (type !== "secret" && type !== "public" && type !== "private") {
      throw new ERR_INVALID_ARG_VALUE("type", type);
    }
    if (typeof handle !== "object") {
      throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
    }
    this[kKeyType] = type;
    Object.defineProperty(this, kHandle, {
      value: handle,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }
  get type() {
    return this[kKeyType];
  }
  get asymmetricKeyDetails() {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
    return void 0;
  }
  get asymmetricKeyType() {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    return void 0;
  }
  get symmetricKeySize() {
    notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
    return void 0;
  }
  static from(key2) {
    if (!isCryptoKey(key2)) {
      throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key2);
    }
    notImplemented("crypto.KeyObject.prototype.from");
  }
  equals(otherKeyObject) {
    if (!isKeyObject(otherKeyObject)) {
      throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
    }
    notImplemented("crypto.KeyObject.prototype.equals");
  }
  export(_options) {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
  }
};
kKeyType, kHandle;
function createPrivateKey(_key) {
  notImplemented("crypto.createPrivateKey");
}
function createPublicKey(_key) {
  notImplemented("crypto.createPublicKey");
}
function createSecretKey(_key, _encoding) {
  notImplemented("crypto.createSecretKey");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/hkdf.ts
var validateParameters = hideStackFrames((hash, key2, salt, info2, length) => {
  key2 = prepareKey(key2);
  salt = toBuf(salt);
  info2 = toBuf(info2);
  validateString(hash, "digest");
  validateByteSource(salt, "salt");
  validateByteSource(info2, "info");
  validateInteger(length, "length", 0, kMaxLength);
  if (info2.byteLength > 1024) {
    throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info2.byteLength);
  }
  return {
    hash,
    key: key2,
    salt,
    info: info2,
    length
  };
});
function prepareKey(key2) {
  if (isKeyObject(key2)) {
    return key2;
  }
  if (isAnyArrayBuffer2(key2)) {
    return createSecretKey(new Uint8Array(key2));
  }
  key2 = toBuf(key2);
  if (!isArrayBufferView(key2)) {
    throw new ERR_INVALID_ARG_TYPE("ikm", [
      "string",
      "SecretKeyObject",
      "ArrayBuffer",
      "TypedArray",
      "DataView",
      "Buffer"
    ], key2);
  }
  return createSecretKey(key2);
}
function hkdf(hash, key2, salt, info2, length, callback) {
  ({ hash, key: key2, salt, info: info2, length } = validateParameters(hash, key2, salt, info2, length));
  validateCallback(callback);
  notImplemented("crypto.hkdf");
}
function hkdfSync(hash, key2, salt, info2, length) {
  ({ hash, key: key2, salt, info: info2, length } = validateParameters(hash, key2, salt, info2, length));
  notImplemented("crypto.hkdfSync");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/keygen.ts
function generateKey(_type, _options, _callback) {
  notImplemented("crypto.generateKey");
}
function generateKeyPair(_type, _options, _callback) {
  notImplemented("crypto.generateKeyPair");
}
function generateKeyPairSync(_type, _options) {
  notImplemented("crypto.generateKeyPairSync");
}
function generateKeySync(_type, _options) {
  notImplemented("crypto.generateKeySync");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/diffiehellman.ts
var DH_GENERATOR = 2;
var DiffieHellman = class {
  constructor(sizeOrKey, keyEncoding, generator, genEncoding) {
    if (typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer2(sizeOrKey)) {
      throw new ERR_INVALID_ARG_TYPE("sizeOrKey", ["number", "string", "ArrayBuffer", "Buffer", "TypedArray", "DataView"], sizeOrKey);
    }
    if (typeof sizeOrKey === "number") {
      validateInt32(sizeOrKey, "sizeOrKey");
    }
    if (keyEncoding && !Buffer3.isEncoding(keyEncoding) && keyEncoding !== "buffer") {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
    const encoding = getDefaultEncoding();
    keyEncoding = keyEncoding || encoding;
    genEncoding = genEncoding || encoding;
    if (typeof sizeOrKey !== "number") {
      sizeOrKey = toBuf(sizeOrKey, keyEncoding);
    }
    if (!generator) {
      generator = DH_GENERATOR;
    } else if (typeof generator === "number") {
      validateInt32(generator, "generator");
    } else if (typeof generator === "string") {
      generator = toBuf(generator, genEncoding);
    } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer2(generator)) {
      throw new ERR_INVALID_ARG_TYPE("generator", ["number", "string", "ArrayBuffer", "Buffer", "TypedArray", "DataView"], generator);
    }
    notImplemented("crypto.DiffieHellman");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.DiffieHellman.prototype.computeSecret");
  }
  generateKeys(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.generateKeys");
  }
  getGenerator(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getGenerator");
  }
  getPrime(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrime");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
  }
  getPublicKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
  }
  setPrivateKey(_privateKey, _encoding) {
    notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
  }
  setPublicKey(_publicKey, _encoding) {
    notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
  }
};
var DiffieHellmanGroup = class {
  constructor(_name) {
    notImplemented("crypto.DiffieHellmanGroup");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.DiffieHellman.prototype.computeSecret");
  }
  generateKeys(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.generateKeys");
  }
  getGenerator(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getGenerator");
  }
  getPrime(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrime");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
  }
  getPublicKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
  }
};
var ECDH = class {
  constructor(curve) {
    validateString(curve, "curve");
    notImplemented("crypto.ECDH");
  }
  static convertKey(_key, _curve, _inputEncoding, _outputEncoding, _format3) {
    notImplemented("crypto.ECDH.prototype.convertKey");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.ECDH.prototype.computeSecret");
  }
  generateKeys(_encoding, _format3) {
    notImplemented("crypto.ECDH.prototype.generateKeys");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.ECDH.prototype.getPrivateKey");
  }
  getPublicKey(_encoding, _format3) {
    notImplemented("crypto.ECDH.prototype.getPublicKey");
  }
  setPrivateKey(_privateKey, _encoding) {
    notImplemented("crypto.ECDH.prototype.setPrivateKey");
  }
};
function diffieHellman(_options) {
  notImplemented("crypto.diffieHellman");
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/bn.js/bn.js
function assert3(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function inherits2(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {
  };
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}
function BN(number, base3, endian) {
  if (BN.isBN(number)) {
    return number;
  }
  this.negative = 0;
  this.words = null;
  this.length = 0;
  this.red = null;
  if (number !== null) {
    if (base3 === "le" || base3 === "be") {
      endian = base3;
      base3 = 10;
    }
    this._init(number || 0, base3 || 10, endian || "be");
  }
}
var bn_default = BN;
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
  if (num instanceof BN) {
    return true;
  }
  return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
  if (left.cmp(right) > 0)
    return left;
  return right;
};
BN.min = function min2(left, right) {
  if (left.cmp(right) < 0)
    return left;
  return right;
};
BN.prototype._init = function init(number, base3, endian) {
  if (typeof number === "number") {
    return this._initNumber(number, base3, endian);
  }
  if (typeof number === "object") {
    return this._initArray(number, base3, endian);
  }
  if (base3 === "hex") {
    base3 = 16;
  }
  assert3(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
  number = number.toString().replace(/\s+/g, "");
  var start = 0;
  if (number[0] === "-") {
    start++;
    this.negative = 1;
  }
  if (start < number.length) {
    if (base3 === 16) {
      this._parseHex(number, start, endian);
    } else {
      this._parseBase(number, base3, start);
      if (endian === "le") {
        this._initArray(this.toArray(), base3, endian);
      }
    }
  }
};
BN.prototype._initNumber = function _initNumber(number, base3, endian) {
  if (number < 0) {
    this.negative = 1;
    number = -number;
  }
  if (number < 67108864) {
    this.words = [number & 67108863];
    this.length = 1;
  } else if (number < 4503599627370496) {
    this.words = [
      number & 67108863,
      number / 67108864 & 67108863
    ];
    this.length = 2;
  } else {
    assert3(number < 9007199254740992);
    this.words = [
      number & 67108863,
      number / 67108864 & 67108863,
      1
    ];
    this.length = 3;
  }
  if (endian !== "le")
    return;
  this._initArray(this.toArray(), base3, endian);
};
BN.prototype._initArray = function _initArray(number, base3, endian) {
  assert3(typeof number.length === "number");
  if (number.length <= 0) {
    this.words = [0];
    this.length = 1;
    return this;
  }
  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    this.words[i] = 0;
  }
  var j, w;
  var off = 0;
  if (endian === "be") {
    for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
      w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
      this.words[j] |= w << off & 67108863;
      this.words[j + 1] = w >>> 26 - off & 67108863;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === "le") {
    for (i = 0, j = 0; i < number.length; i += 3) {
      w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
      this.words[j] |= w << off & 67108863;
      this.words[j + 1] = w >>> 26 - off & 67108863;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this._strip();
};
function parseHex4Bits(string, index) {
  var c = string.charCodeAt(index);
  if (c >= 48 && c <= 57) {
    return c - 48;
  } else if (c >= 65 && c <= 70) {
    return c - 55;
  } else if (c >= 97 && c <= 102) {
    return c - 87;
  } else {
    assert3(false, "Invalid character in " + string);
  }
}
function parseHexByte(string, lowerBound, index) {
  var r = parseHex4Bits(string, index);
  if (index - 1 >= lowerBound) {
    r |= parseHex4Bits(string, index - 1) << 4;
  }
  return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    this.words[i] = 0;
  }
  var off = 0;
  var j = 0;
  var w;
  if (endian === "be") {
    for (i = number.length - 1; i >= start; i -= 2) {
      w = parseHexByte(number, start, i) << off;
      this.words[j] |= w & 67108863;
      if (off >= 18) {
        off -= 18;
        j += 1;
        this.words[j] |= w >>> 26;
      } else {
        off += 8;
      }
    }
  } else {
    var parseLength = number.length - start;
    for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
      w = parseHexByte(number, start, i) << off;
      this.words[j] |= w & 67108863;
      if (off >= 18) {
        off -= 18;
        j += 1;
        this.words[j] |= w >>> 26;
      } else {
        off += 8;
      }
    }
  }
  this._strip();
};
function parseBase(str, start, end, mul4) {
  var r = 0;
  var b = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;
    r *= mul4;
    if (c >= 49) {
      b = c - 49 + 10;
    } else if (c >= 17) {
      b = c - 17 + 10;
    } else {
      b = c;
    }
    assert3(c >= 0 && b < mul4, "Invalid character");
    r += b;
  }
  return r;
}
BN.prototype._parseBase = function _parseBase(number, base3, start) {
  this.words = [0];
  this.length = 1;
  for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
    limbLen++;
  }
  limbLen--;
  limbPow = limbPow / base3 | 0;
  var total = number.length - start;
  var mod2 = total % limbLen;
  var end = Math.min(total, total - mod2) + start;
  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base3);
    this.imuln(limbPow);
    if (this.words[0] + word < 67108864) {
      this.words[0] += word;
    } else {
      this._iaddn(word);
    }
  }
  if (mod2 !== 0) {
    var pow3 = 1;
    word = parseBase(number, i, number.length, base3);
    for (i = 0; i < mod2; i++) {
      pow3 *= base3;
    }
    this.imuln(pow3);
    if (this.words[0] + word < 67108864) {
      this.words[0] += word;
    } else {
      this._iaddn(word);
    }
  }
  this._strip();
};
BN.prototype.copy = function copy3(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    dest.words[i] = this.words[i];
  }
  dest.length = this.length;
  dest.negative = this.negative;
  dest.red = this.red;
};
function move(dest, src) {
  dest.words = src.words;
  dest.length = src.length;
  dest.negative = src.negative;
  dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
  move(dest, this);
};
BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};
BN.prototype._expand = function _expand(size) {
  while (this.length < size) {
    this.words[this.length++] = 0;
  }
  return this;
};
BN.prototype._strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0) {
    this.length--;
  }
  return this._normSign();
};
BN.prototype._normSign = function _normSign() {
  if (this.length === 1 && this.words[0] === 0) {
    this.negative = 0;
  }
  return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
  try {
    BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
  } catch (e) {
    BN.prototype.inspect = inspect3;
  }
} else {
  BN.prototype.inspect = inspect3;
}
function inspect3() {
  return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
  "",
  "0",
  "00",
  "000",
  "0000",
  "00000",
  "000000",
  "0000000",
  "00000000",
  "000000000",
  "0000000000",
  "00000000000",
  "000000000000",
  "0000000000000",
  "00000000000000",
  "000000000000000",
  "0000000000000000",
  "00000000000000000",
  "000000000000000000",
  "0000000000000000000",
  "00000000000000000000",
  "000000000000000000000",
  "0000000000000000000000",
  "00000000000000000000000",
  "000000000000000000000000",
  "0000000000000000000000000"
];
var groupSizes = [
  0,
  0,
  25,
  16,
  12,
  11,
  10,
  9,
  8,
  8,
  7,
  7,
  7,
  7,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5
];
var groupBases = [
  0,
  0,
  33554432,
  43046721,
  16777216,
  48828125,
  60466176,
  40353607,
  16777216,
  43046721,
  1e7,
  19487171,
  35831808,
  62748517,
  7529536,
  11390625,
  16777216,
  24137569,
  34012224,
  47045881,
  64e6,
  4084101,
  5153632,
  6436343,
  7962624,
  9765625,
  11881376,
  14348907,
  17210368,
  20511149,
  243e5,
  28629151,
  33554432,
  39135393,
  45435424,
  52521875,
  60466176
];
BN.prototype.toString = function toString2(base3, padding) {
  base3 = base3 || 10;
  padding = padding | 0 || 1;
  var out;
  if (base3 === 16 || base3 === "hex") {
    out = "";
    var off = 0;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = ((w << off | carry) & 16777215).toString(16);
      carry = w >>> 24 - off & 16777215;
      if (carry !== 0 || i !== this.length - 1) {
        out = zeros[6 - word.length] + word + out;
      } else {
        out = word + out;
      }
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0) {
      out = carry.toString(16) + out;
    }
    while (out.length % padding !== 0) {
      out = "0" + out;
    }
    if (this.negative !== 0) {
      out = "-" + out;
    }
    return out;
  }
  if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
    var groupSize = groupSizes[base3];
    var groupBase = groupBases[base3];
    out = "";
    var c = this.clone();
    c.negative = 0;
    while (!c.isZero()) {
      var r = c.modrn(groupBase).toString(base3);
      c = c.idivn(groupBase);
      if (!c.isZero()) {
        out = zeros[groupSize - r.length] + r + out;
      } else {
        out = r + out;
      }
    }
    if (this.isZero()) {
      out = "0" + out;
    }
    while (out.length % padding !== 0) {
      out = "0" + out;
    }
    if (this.negative !== 0) {
      out = "-" + out;
    }
    return out;
  }
  assert3(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
  var ret = this.words[0];
  if (this.length === 2) {
    ret += this.words[1] * 67108864;
  } else if (this.length === 3 && this.words[2] === 1) {
    ret += 4503599627370496 + this.words[1] * 67108864;
  } else if (this.length > 2) {
    assert3(false, "Number can only safely store up to 53 bits");
  }
  return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON2() {
  return this.toString(16, 2);
};
if (Buffer3) {
  BN.prototype.toBuffer = function toBuffer2(endian, length) {
    return this.toArrayLike(Buffer3, endian, length);
  };
}
BN.prototype.toArray = function toArray2(endian, length) {
  return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate2(ArrayType, size) {
  if (ArrayType.allocUnsafe) {
    return ArrayType.allocUnsafe(size);
  }
  return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
  this._strip();
  var byteLength6 = this.byteLength();
  var reqLength = length || Math.max(1, byteLength6);
  assert3(byteLength6 <= reqLength, "byte array longer than desired length");
  assert3(reqLength > 0, "Requested array length <= 0");
  var res = allocate(ArrayType, reqLength);
  var postfix = endian === "le" ? "LE" : "BE";
  this["_toArrayLike" + postfix](res, byteLength6);
  return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength6) {
  var position = 0;
  var carry = 0;
  for (var i = 0, shift = 0; i < this.length; i++) {
    var word = this.words[i] << shift | carry;
    res[position++] = word & 255;
    if (position < res.length) {
      res[position++] = word >> 8 & 255;
    }
    if (position < res.length) {
      res[position++] = word >> 16 & 255;
    }
    if (shift === 6) {
      if (position < res.length) {
        res[position++] = word >> 24 & 255;
      }
      carry = 0;
      shift = 0;
    } else {
      carry = word >>> 24;
      shift += 2;
    }
  }
  if (position < res.length) {
    res[position++] = carry;
    while (position < res.length) {
      res[position++] = 0;
    }
  }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength6) {
  var position = res.length - 1;
  var carry = 0;
  for (var i = 0, shift = 0; i < this.length; i++) {
    var word = this.words[i] << shift | carry;
    res[position--] = word & 255;
    if (position >= 0) {
      res[position--] = word >> 8 & 255;
    }
    if (position >= 0) {
      res[position--] = word >> 16 & 255;
    }
    if (shift === 6) {
      if (position >= 0) {
        res[position--] = word >> 24 & 255;
      }
      carry = 0;
      shift = 0;
    } else {
      carry = word >>> 24;
      shift += 2;
    }
  }
  if (position >= 0) {
    res[position--] = carry;
    while (position >= 0) {
      res[position--] = 0;
    }
  }
};
if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 4096) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 64) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 2) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}
BN.prototype._zeroBits = function _zeroBits(w) {
  if (w === 0)
    return 26;
  var t = w;
  var r = 0;
  if ((t & 8191) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 127) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 15) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 1) === 0) {
    r++;
  }
  return r;
};
BN.prototype.bitLength = function bitLength() {
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
  var w = new Array(num.bitLength());
  for (var bit = 0; bit < w.length; bit++) {
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    w[bit] = num.words[off] >>> wbit & 1;
  }
  return w;
}
BN.prototype.zeroBits = function zeroBits() {
  if (this.isZero())
    return 0;
  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};
BN.prototype.byteLength = function byteLength2() {
  return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
  if (this.negative !== 0) {
    return this.abs().inotn(width).iaddn(1);
  }
  return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
  if (this.testn(width - 1)) {
    return this.notn(width).iaddn(1).ineg();
  }
  return this.clone();
};
BN.prototype.isNeg = function isNeg() {
  return this.negative !== 0;
};
BN.prototype.neg = function neg() {
  return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
  if (!this.isZero()) {
    this.negative ^= 1;
  }
  return this;
};
BN.prototype.iuor = function iuor(num) {
  while (this.length < num.length) {
    this.words[this.length++] = 0;
  }
  for (var i = 0; i < num.length; i++) {
    this.words[i] = this.words[i] | num.words[i];
  }
  return this._strip();
};
BN.prototype.ior = function ior(num) {
  assert3((this.negative | num.negative) === 0);
  return this.iuor(num);
};
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
  if (this.length > num.length)
    return this.clone().iuor(num);
  return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
  var b;
  if (this.length > num.length) {
    b = num;
  } else {
    b = this;
  }
  for (var i = 0; i < b.length; i++) {
    this.words[i] = this.words[i] & num.words[i];
  }
  this.length = b.length;
  return this._strip();
};
BN.prototype.iand = function iand(num) {
  assert3((this.negative | num.negative) === 0);
  return this.iuand(num);
};
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
  if (this.length > num.length)
    return this.clone().iuand(num);
  return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }
  for (var i = 0; i < b.length; i++) {
    this.words[i] = a.words[i] ^ b.words[i];
  }
  if (this !== a) {
    for (; i < a.length; i++) {
      this.words[i] = a.words[i];
    }
  }
  this.length = a.length;
  return this._strip();
};
BN.prototype.ixor = function ixor(num) {
  assert3((this.negative | num.negative) === 0);
  return this.iuxor(num);
};
BN.prototype.xor = function xor2(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
  if (this.length > num.length)
    return this.clone().iuxor(num);
  return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
  assert3(typeof width === "number" && width >= 0);
  var bytesNeeded = Math.ceil(width / 26) | 0;
  var bitsLeft = width % 26;
  this._expand(bytesNeeded);
  if (bitsLeft > 0) {
    bytesNeeded--;
  }
  for (var i = 0; i < bytesNeeded; i++) {
    this.words[i] = ~this.words[i] & 67108863;
  }
  if (bitsLeft > 0) {
    this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
  }
  return this._strip();
};
BN.prototype.notn = function notn(width) {
  return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
  assert3(typeof bit === "number" && bit >= 0);
  var off = bit / 26 | 0;
  var wbit = bit % 26;
  this._expand(off + 1);
  if (val) {
    this.words[off] = this.words[off] | 1 << wbit;
  } else {
    this.words[off] = this.words[off] & ~(1 << wbit);
  }
  return this._strip();
};
BN.prototype.iadd = function iadd(num) {
  var r;
  if (this.negative !== 0 && num.negative === 0) {
    this.negative = 0;
    r = this.isub(num);
    this.negative ^= 1;
    return this._normSign();
  } else if (this.negative === 0 && num.negative !== 0) {
    num.negative = 0;
    r = this.isub(num);
    num.negative = 1;
    return r._normSign();
  }
  var a, b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }
  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
    this.words[i] = r & 67108863;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    r = (a.words[i] | 0) + carry;
    this.words[i] = r & 67108863;
    carry = r >>> 26;
  }
  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  } else if (a !== this) {
    for (; i < a.length; i++) {
      this.words[i] = a.words[i];
    }
  }
  return this;
};
BN.prototype.add = function add(num) {
  var res;
  if (num.negative !== 0 && this.negative === 0) {
    num.negative = 0;
    res = this.sub(num);
    num.negative ^= 1;
    return res;
  } else if (num.negative === 0 && this.negative !== 0) {
    this.negative = 0;
    res = num.sub(this);
    this.negative = 1;
    return res;
  }
  if (this.length > num.length)
    return this.clone().iadd(num);
  return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
  if (num.negative !== 0) {
    num.negative = 0;
    var r = this.iadd(num);
    num.negative = 1;
    return r._normSign();
  } else if (this.negative !== 0) {
    this.negative = 0;
    this.iadd(num);
    this.negative = 1;
    return this._normSign();
  }
  var cmp2 = this.cmp(num);
  if (cmp2 === 0) {
    this.negative = 0;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }
  var a, b;
  if (cmp2 > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }
  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 67108863;
  }
  for (; carry !== 0 && i < a.length; i++) {
    r = (a.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 67108863;
  }
  if (carry === 0 && i < a.length && a !== this) {
    for (; i < a.length; i++) {
      this.words[i] = a.words[i];
    }
  }
  this.length = Math.max(this.length, i);
  if (a !== this) {
    this.negative = 1;
  }
  return this._strip();
};
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};
function smallMulTo(self2, num, out) {
  out.negative = num.negative ^ self2.negative;
  var len = self2.length + num.length | 0;
  out.length = len;
  len = len - 1 | 0;
  var a = self2.words[0] | 0;
  var b = num.words[0] | 0;
  var r = a * b;
  var lo2 = r & 67108863;
  var carry = r / 67108864 | 0;
  out.words[0] = lo2;
  for (var k3 = 1; k3 < len; k3++) {
    var ncarry = carry >>> 26;
    var rword = carry & 67108863;
    var maxJ = Math.min(k3, num.length - 1);
    for (var j = Math.max(0, k3 - self2.length + 1); j <= maxJ; j++) {
      var i = k3 - j | 0;
      a = self2.words[i] | 0;
      b = num.words[j] | 0;
      r = a * b + rword;
      ncarry += r / 67108864 | 0;
      rword = r & 67108863;
    }
    out.words[k3] = rword | 0;
    carry = ncarry | 0;
  }
  if (carry !== 0) {
    out.words[k3] = carry | 0;
  } else {
    out.length--;
  }
  return out._strip();
}
var comb10MulTo = function comb10MulTo2(self2, num, out) {
  var a = self2.words;
  var b = num.words;
  var o = out.words;
  var c = 0;
  var lo2;
  var mid;
  var hi;
  var a02 = a[0] | 0;
  var al0 = a02 & 8191;
  var ah0 = a02 >>> 13;
  var a1 = a[1] | 0;
  var al1 = a1 & 8191;
  var ah1 = a1 >>> 13;
  var a2 = a[2] | 0;
  var al2 = a2 & 8191;
  var ah2 = a2 >>> 13;
  var a3 = a[3] | 0;
  var al3 = a3 & 8191;
  var ah3 = a3 >>> 13;
  var a4 = a[4] | 0;
  var al4 = a4 & 8191;
  var ah4 = a4 >>> 13;
  var a5 = a[5] | 0;
  var al5 = a5 & 8191;
  var ah5 = a5 >>> 13;
  var a6 = a[6] | 0;
  var al6 = a6 & 8191;
  var ah6 = a6 >>> 13;
  var a7 = a[7] | 0;
  var al7 = a7 & 8191;
  var ah7 = a7 >>> 13;
  var a8 = a[8] | 0;
  var al8 = a8 & 8191;
  var ah8 = a8 >>> 13;
  var a92 = a[9] | 0;
  var al9 = a92 & 8191;
  var ah9 = a92 >>> 13;
  var b0 = b[0] | 0;
  var bl0 = b0 & 8191;
  var bh0 = b0 >>> 13;
  var b12 = b[1] | 0;
  var bl1 = b12 & 8191;
  var bh1 = b12 >>> 13;
  var b2 = b[2] | 0;
  var bl2 = b2 & 8191;
  var bh2 = b2 >>> 13;
  var b3 = b[3] | 0;
  var bl3 = b3 & 8191;
  var bh3 = b3 >>> 13;
  var b4 = b[4] | 0;
  var bl4 = b4 & 8191;
  var bh4 = b4 >>> 13;
  var b5 = b[5] | 0;
  var bl5 = b5 & 8191;
  var bh5 = b5 >>> 13;
  var b6 = b[6] | 0;
  var bl6 = b6 & 8191;
  var bh6 = b6 >>> 13;
  var b7 = b[7] | 0;
  var bl7 = b7 & 8191;
  var bh7 = b7 >>> 13;
  var b8 = b[8] | 0;
  var bl8 = b8 & 8191;
  var bh8 = b8 >>> 13;
  var b9 = b[9] | 0;
  var bl9 = b9 & 8191;
  var bh9 = b9 >>> 13;
  out.negative = self2.negative ^ num.negative;
  out.length = 19;
  lo2 = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = mid + Math.imul(ah0, bl0) | 0;
  hi = Math.imul(ah0, bh0);
  var w0 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
  w0 &= 67108863;
  lo2 = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = mid + Math.imul(ah1, bl0) | 0;
  hi = Math.imul(ah1, bh0);
  lo2 = lo2 + Math.imul(al0, bl1) | 0;
  mid = mid + Math.imul(al0, bh1) | 0;
  mid = mid + Math.imul(ah0, bl1) | 0;
  hi = hi + Math.imul(ah0, bh1) | 0;
  var w1 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
  w1 &= 67108863;
  lo2 = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = mid + Math.imul(ah2, bl0) | 0;
  hi = Math.imul(ah2, bh0);
  lo2 = lo2 + Math.imul(al1, bl1) | 0;
  mid = mid + Math.imul(al1, bh1) | 0;
  mid = mid + Math.imul(ah1, bl1) | 0;
  hi = hi + Math.imul(ah1, bh1) | 0;
  lo2 = lo2 + Math.imul(al0, bl2) | 0;
  mid = mid + Math.imul(al0, bh2) | 0;
  mid = mid + Math.imul(ah0, bl2) | 0;
  hi = hi + Math.imul(ah0, bh2) | 0;
  var w2 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
  w2 &= 67108863;
  lo2 = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = mid + Math.imul(ah3, bl0) | 0;
  hi = Math.imul(ah3, bh0);
  lo2 = lo2 + Math.imul(al2, bl1) | 0;
  mid = mid + Math.imul(al2, bh1) | 0;
  mid = mid + Math.imul(ah2, bl1) | 0;
  hi = hi + Math.imul(ah2, bh1) | 0;
  lo2 = lo2 + Math.imul(al1, bl2) | 0;
  mid = mid + Math.imul(al1, bh2) | 0;
  mid = mid + Math.imul(ah1, bl2) | 0;
  hi = hi + Math.imul(ah1, bh2) | 0;
  lo2 = lo2 + Math.imul(al0, bl3) | 0;
  mid = mid + Math.imul(al0, bh3) | 0;
  mid = mid + Math.imul(ah0, bl3) | 0;
  hi = hi + Math.imul(ah0, bh3) | 0;
  var w3 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
  w3 &= 67108863;
  lo2 = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = mid + Math.imul(ah4, bl0) | 0;
  hi = Math.imul(ah4, bh0);
  lo2 = lo2 + Math.imul(al3, bl1) | 0;
  mid = mid + Math.imul(al3, bh1) | 0;
  mid = mid + Math.imul(ah3, bl1) | 0;
  hi = hi + Math.imul(ah3, bh1) | 0;
  lo2 = lo2 + Math.imul(al2, bl2) | 0;
  mid = mid + Math.imul(al2, bh2) | 0;
  mid = mid + Math.imul(ah2, bl2) | 0;
  hi = hi + Math.imul(ah2, bh2) | 0;
  lo2 = lo2 + Math.imul(al1, bl3) | 0;
  mid = mid + Math.imul(al1, bh3) | 0;
  mid = mid + Math.imul(ah1, bl3) | 0;
  hi = hi + Math.imul(ah1, bh3) | 0;
  lo2 = lo2 + Math.imul(al0, bl4) | 0;
  mid = mid + Math.imul(al0, bh4) | 0;
  mid = mid + Math.imul(ah0, bl4) | 0;
  hi = hi + Math.imul(ah0, bh4) | 0;
  var w4 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
  w4 &= 67108863;
  lo2 = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = mid + Math.imul(ah5, bl0) | 0;
  hi = Math.imul(ah5, bh0);
  lo2 = lo2 + Math.imul(al4, bl1) | 0;
  mid = mid + Math.imul(al4, bh1) | 0;
  mid = mid + Math.imul(ah4, bl1) | 0;
  hi = hi + Math.imul(ah4, bh1) | 0;
  lo2 = lo2 + Math.imul(al3, bl2) | 0;
  mid = mid + Math.imul(al3, bh2) | 0;
  mid = mid + Math.imul(ah3, bl2) | 0;
  hi = hi + Math.imul(ah3, bh2) | 0;
  lo2 = lo2 + Math.imul(al2, bl3) | 0;
  mid = mid + Math.imul(al2, bh3) | 0;
  mid = mid + Math.imul(ah2, bl3) | 0;
  hi = hi + Math.imul(ah2, bh3) | 0;
  lo2 = lo2 + Math.imul(al1, bl4) | 0;
  mid = mid + Math.imul(al1, bh4) | 0;
  mid = mid + Math.imul(ah1, bl4) | 0;
  hi = hi + Math.imul(ah1, bh4) | 0;
  lo2 = lo2 + Math.imul(al0, bl5) | 0;
  mid = mid + Math.imul(al0, bh5) | 0;
  mid = mid + Math.imul(ah0, bl5) | 0;
  hi = hi + Math.imul(ah0, bh5) | 0;
  var w5 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
  w5 &= 67108863;
  lo2 = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = mid + Math.imul(ah6, bl0) | 0;
  hi = Math.imul(ah6, bh0);
  lo2 = lo2 + Math.imul(al5, bl1) | 0;
  mid = mid + Math.imul(al5, bh1) | 0;
  mid = mid + Math.imul(ah5, bl1) | 0;
  hi = hi + Math.imul(ah5, bh1) | 0;
  lo2 = lo2 + Math.imul(al4, bl2) | 0;
  mid = mid + Math.imul(al4, bh2) | 0;
  mid = mid + Math.imul(ah4, bl2) | 0;
  hi = hi + Math.imul(ah4, bh2) | 0;
  lo2 = lo2 + Math.imul(al3, bl3) | 0;
  mid = mid + Math.imul(al3, bh3) | 0;
  mid = mid + Math.imul(ah3, bl3) | 0;
  hi = hi + Math.imul(ah3, bh3) | 0;
  lo2 = lo2 + Math.imul(al2, bl4) | 0;
  mid = mid + Math.imul(al2, bh4) | 0;
  mid = mid + Math.imul(ah2, bl4) | 0;
  hi = hi + Math.imul(ah2, bh4) | 0;
  lo2 = lo2 + Math.imul(al1, bl5) | 0;
  mid = mid + Math.imul(al1, bh5) | 0;
  mid = mid + Math.imul(ah1, bl5) | 0;
  hi = hi + Math.imul(ah1, bh5) | 0;
  lo2 = lo2 + Math.imul(al0, bl6) | 0;
  mid = mid + Math.imul(al0, bh6) | 0;
  mid = mid + Math.imul(ah0, bl6) | 0;
  hi = hi + Math.imul(ah0, bh6) | 0;
  var w6 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
  w6 &= 67108863;
  lo2 = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = mid + Math.imul(ah7, bl0) | 0;
  hi = Math.imul(ah7, bh0);
  lo2 = lo2 + Math.imul(al6, bl1) | 0;
  mid = mid + Math.imul(al6, bh1) | 0;
  mid = mid + Math.imul(ah6, bl1) | 0;
  hi = hi + Math.imul(ah6, bh1) | 0;
  lo2 = lo2 + Math.imul(al5, bl2) | 0;
  mid = mid + Math.imul(al5, bh2) | 0;
  mid = mid + Math.imul(ah5, bl2) | 0;
  hi = hi + Math.imul(ah5, bh2) | 0;
  lo2 = lo2 + Math.imul(al4, bl3) | 0;
  mid = mid + Math.imul(al4, bh3) | 0;
  mid = mid + Math.imul(ah4, bl3) | 0;
  hi = hi + Math.imul(ah4, bh3) | 0;
  lo2 = lo2 + Math.imul(al3, bl4) | 0;
  mid = mid + Math.imul(al3, bh4) | 0;
  mid = mid + Math.imul(ah3, bl4) | 0;
  hi = hi + Math.imul(ah3, bh4) | 0;
  lo2 = lo2 + Math.imul(al2, bl5) | 0;
  mid = mid + Math.imul(al2, bh5) | 0;
  mid = mid + Math.imul(ah2, bl5) | 0;
  hi = hi + Math.imul(ah2, bh5) | 0;
  lo2 = lo2 + Math.imul(al1, bl6) | 0;
  mid = mid + Math.imul(al1, bh6) | 0;
  mid = mid + Math.imul(ah1, bl6) | 0;
  hi = hi + Math.imul(ah1, bh6) | 0;
  lo2 = lo2 + Math.imul(al0, bl7) | 0;
  mid = mid + Math.imul(al0, bh7) | 0;
  mid = mid + Math.imul(ah0, bl7) | 0;
  hi = hi + Math.imul(ah0, bh7) | 0;
  var w7 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
  w7 &= 67108863;
  lo2 = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = mid + Math.imul(ah8, bl0) | 0;
  hi = Math.imul(ah8, bh0);
  lo2 = lo2 + Math.imul(al7, bl1) | 0;
  mid = mid + Math.imul(al7, bh1) | 0;
  mid = mid + Math.imul(ah7, bl1) | 0;
  hi = hi + Math.imul(ah7, bh1) | 0;
  lo2 = lo2 + Math.imul(al6, bl2) | 0;
  mid = mid + Math.imul(al6, bh2) | 0;
  mid = mid + Math.imul(ah6, bl2) | 0;
  hi = hi + Math.imul(ah6, bh2) | 0;
  lo2 = lo2 + Math.imul(al5, bl3) | 0;
  mid = mid + Math.imul(al5, bh3) | 0;
  mid = mid + Math.imul(ah5, bl3) | 0;
  hi = hi + Math.imul(ah5, bh3) | 0;
  lo2 = lo2 + Math.imul(al4, bl4) | 0;
  mid = mid + Math.imul(al4, bh4) | 0;
  mid = mid + Math.imul(ah4, bl4) | 0;
  hi = hi + Math.imul(ah4, bh4) | 0;
  lo2 = lo2 + Math.imul(al3, bl5) | 0;
  mid = mid + Math.imul(al3, bh5) | 0;
  mid = mid + Math.imul(ah3, bl5) | 0;
  hi = hi + Math.imul(ah3, bh5) | 0;
  lo2 = lo2 + Math.imul(al2, bl6) | 0;
  mid = mid + Math.imul(al2, bh6) | 0;
  mid = mid + Math.imul(ah2, bl6) | 0;
  hi = hi + Math.imul(ah2, bh6) | 0;
  lo2 = lo2 + Math.imul(al1, bl7) | 0;
  mid = mid + Math.imul(al1, bh7) | 0;
  mid = mid + Math.imul(ah1, bl7) | 0;
  hi = hi + Math.imul(ah1, bh7) | 0;
  lo2 = lo2 + Math.imul(al0, bl8) | 0;
  mid = mid + Math.imul(al0, bh8) | 0;
  mid = mid + Math.imul(ah0, bl8) | 0;
  hi = hi + Math.imul(ah0, bh8) | 0;
  var w8 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
  w8 &= 67108863;
  lo2 = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = mid + Math.imul(ah9, bl0) | 0;
  hi = Math.imul(ah9, bh0);
  lo2 = lo2 + Math.imul(al8, bl1) | 0;
  mid = mid + Math.imul(al8, bh1) | 0;
  mid = mid + Math.imul(ah8, bl1) | 0;
  hi = hi + Math.imul(ah8, bh1) | 0;
  lo2 = lo2 + Math.imul(al7, bl2) | 0;
  mid = mid + Math.imul(al7, bh2) | 0;
  mid = mid + Math.imul(ah7, bl2) | 0;
  hi = hi + Math.imul(ah7, bh2) | 0;
  lo2 = lo2 + Math.imul(al6, bl3) | 0;
  mid = mid + Math.imul(al6, bh3) | 0;
  mid = mid + Math.imul(ah6, bl3) | 0;
  hi = hi + Math.imul(ah6, bh3) | 0;
  lo2 = lo2 + Math.imul(al5, bl4) | 0;
  mid = mid + Math.imul(al5, bh4) | 0;
  mid = mid + Math.imul(ah5, bl4) | 0;
  hi = hi + Math.imul(ah5, bh4) | 0;
  lo2 = lo2 + Math.imul(al4, bl5) | 0;
  mid = mid + Math.imul(al4, bh5) | 0;
  mid = mid + Math.imul(ah4, bl5) | 0;
  hi = hi + Math.imul(ah4, bh5) | 0;
  lo2 = lo2 + Math.imul(al3, bl6) | 0;
  mid = mid + Math.imul(al3, bh6) | 0;
  mid = mid + Math.imul(ah3, bl6) | 0;
  hi = hi + Math.imul(ah3, bh6) | 0;
  lo2 = lo2 + Math.imul(al2, bl7) | 0;
  mid = mid + Math.imul(al2, bh7) | 0;
  mid = mid + Math.imul(ah2, bl7) | 0;
  hi = hi + Math.imul(ah2, bh7) | 0;
  lo2 = lo2 + Math.imul(al1, bl8) | 0;
  mid = mid + Math.imul(al1, bh8) | 0;
  mid = mid + Math.imul(ah1, bl8) | 0;
  hi = hi + Math.imul(ah1, bh8) | 0;
  lo2 = lo2 + Math.imul(al0, bl9) | 0;
  mid = mid + Math.imul(al0, bh9) | 0;
  mid = mid + Math.imul(ah0, bl9) | 0;
  hi = hi + Math.imul(ah0, bh9) | 0;
  var w9 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
  w9 &= 67108863;
  lo2 = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = mid + Math.imul(ah9, bl1) | 0;
  hi = Math.imul(ah9, bh1);
  lo2 = lo2 + Math.imul(al8, bl2) | 0;
  mid = mid + Math.imul(al8, bh2) | 0;
  mid = mid + Math.imul(ah8, bl2) | 0;
  hi = hi + Math.imul(ah8, bh2) | 0;
  lo2 = lo2 + Math.imul(al7, bl3) | 0;
  mid = mid + Math.imul(al7, bh3) | 0;
  mid = mid + Math.imul(ah7, bl3) | 0;
  hi = hi + Math.imul(ah7, bh3) | 0;
  lo2 = lo2 + Math.imul(al6, bl4) | 0;
  mid = mid + Math.imul(al6, bh4) | 0;
  mid = mid + Math.imul(ah6, bl4) | 0;
  hi = hi + Math.imul(ah6, bh4) | 0;
  lo2 = lo2 + Math.imul(al5, bl5) | 0;
  mid = mid + Math.imul(al5, bh5) | 0;
  mid = mid + Math.imul(ah5, bl5) | 0;
  hi = hi + Math.imul(ah5, bh5) | 0;
  lo2 = lo2 + Math.imul(al4, bl6) | 0;
  mid = mid + Math.imul(al4, bh6) | 0;
  mid = mid + Math.imul(ah4, bl6) | 0;
  hi = hi + Math.imul(ah4, bh6) | 0;
  lo2 = lo2 + Math.imul(al3, bl7) | 0;
  mid = mid + Math.imul(al3, bh7) | 0;
  mid = mid + Math.imul(ah3, bl7) | 0;
  hi = hi + Math.imul(ah3, bh7) | 0;
  lo2 = lo2 + Math.imul(al2, bl8) | 0;
  mid = mid + Math.imul(al2, bh8) | 0;
  mid = mid + Math.imul(ah2, bl8) | 0;
  hi = hi + Math.imul(ah2, bh8) | 0;
  lo2 = lo2 + Math.imul(al1, bl9) | 0;
  mid = mid + Math.imul(al1, bh9) | 0;
  mid = mid + Math.imul(ah1, bl9) | 0;
  hi = hi + Math.imul(ah1, bh9) | 0;
  var w10 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
  w10 &= 67108863;
  lo2 = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = mid + Math.imul(ah9, bl2) | 0;
  hi = Math.imul(ah9, bh2);
  lo2 = lo2 + Math.imul(al8, bl3) | 0;
  mid = mid + Math.imul(al8, bh3) | 0;
  mid = mid + Math.imul(ah8, bl3) | 0;
  hi = hi + Math.imul(ah8, bh3) | 0;
  lo2 = lo2 + Math.imul(al7, bl4) | 0;
  mid = mid + Math.imul(al7, bh4) | 0;
  mid = mid + Math.imul(ah7, bl4) | 0;
  hi = hi + Math.imul(ah7, bh4) | 0;
  lo2 = lo2 + Math.imul(al6, bl5) | 0;
  mid = mid + Math.imul(al6, bh5) | 0;
  mid = mid + Math.imul(ah6, bl5) | 0;
  hi = hi + Math.imul(ah6, bh5) | 0;
  lo2 = lo2 + Math.imul(al5, bl6) | 0;
  mid = mid + Math.imul(al5, bh6) | 0;
  mid = mid + Math.imul(ah5, bl6) | 0;
  hi = hi + Math.imul(ah5, bh6) | 0;
  lo2 = lo2 + Math.imul(al4, bl7) | 0;
  mid = mid + Math.imul(al4, bh7) | 0;
  mid = mid + Math.imul(ah4, bl7) | 0;
  hi = hi + Math.imul(ah4, bh7) | 0;
  lo2 = lo2 + Math.imul(al3, bl8) | 0;
  mid = mid + Math.imul(al3, bh8) | 0;
  mid = mid + Math.imul(ah3, bl8) | 0;
  hi = hi + Math.imul(ah3, bh8) | 0;
  lo2 = lo2 + Math.imul(al2, bl9) | 0;
  mid = mid + Math.imul(al2, bh9) | 0;
  mid = mid + Math.imul(ah2, bl9) | 0;
  hi = hi + Math.imul(ah2, bh9) | 0;
  var w11 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
  w11 &= 67108863;
  lo2 = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = mid + Math.imul(ah9, bl3) | 0;
  hi = Math.imul(ah9, bh3);
  lo2 = lo2 + Math.imul(al8, bl4) | 0;
  mid = mid + Math.imul(al8, bh4) | 0;
  mid = mid + Math.imul(ah8, bl4) | 0;
  hi = hi + Math.imul(ah8, bh4) | 0;
  lo2 = lo2 + Math.imul(al7, bl5) | 0;
  mid = mid + Math.imul(al7, bh5) | 0;
  mid = mid + Math.imul(ah7, bl5) | 0;
  hi = hi + Math.imul(ah7, bh5) | 0;
  lo2 = lo2 + Math.imul(al6, bl6) | 0;
  mid = mid + Math.imul(al6, bh6) | 0;
  mid = mid + Math.imul(ah6, bl6) | 0;
  hi = hi + Math.imul(ah6, bh6) | 0;
  lo2 = lo2 + Math.imul(al5, bl7) | 0;
  mid = mid + Math.imul(al5, bh7) | 0;
  mid = mid + Math.imul(ah5, bl7) | 0;
  hi = hi + Math.imul(ah5, bh7) | 0;
  lo2 = lo2 + Math.imul(al4, bl8) | 0;
  mid = mid + Math.imul(al4, bh8) | 0;
  mid = mid + Math.imul(ah4, bl8) | 0;
  hi = hi + Math.imul(ah4, bh8) | 0;
  lo2 = lo2 + Math.imul(al3, bl9) | 0;
  mid = mid + Math.imul(al3, bh9) | 0;
  mid = mid + Math.imul(ah3, bl9) | 0;
  hi = hi + Math.imul(ah3, bh9) | 0;
  var w12 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
  w12 &= 67108863;
  lo2 = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = mid + Math.imul(ah9, bl4) | 0;
  hi = Math.imul(ah9, bh4);
  lo2 = lo2 + Math.imul(al8, bl5) | 0;
  mid = mid + Math.imul(al8, bh5) | 0;
  mid = mid + Math.imul(ah8, bl5) | 0;
  hi = hi + Math.imul(ah8, bh5) | 0;
  lo2 = lo2 + Math.imul(al7, bl6) | 0;
  mid = mid + Math.imul(al7, bh6) | 0;
  mid = mid + Math.imul(ah7, bl6) | 0;
  hi = hi + Math.imul(ah7, bh6) | 0;
  lo2 = lo2 + Math.imul(al6, bl7) | 0;
  mid = mid + Math.imul(al6, bh7) | 0;
  mid = mid + Math.imul(ah6, bl7) | 0;
  hi = hi + Math.imul(ah6, bh7) | 0;
  lo2 = lo2 + Math.imul(al5, bl8) | 0;
  mid = mid + Math.imul(al5, bh8) | 0;
  mid = mid + Math.imul(ah5, bl8) | 0;
  hi = hi + Math.imul(ah5, bh8) | 0;
  lo2 = lo2 + Math.imul(al4, bl9) | 0;
  mid = mid + Math.imul(al4, bh9) | 0;
  mid = mid + Math.imul(ah4, bl9) | 0;
  hi = hi + Math.imul(ah4, bh9) | 0;
  var w13 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
  w13 &= 67108863;
  lo2 = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = mid + Math.imul(ah9, bl5) | 0;
  hi = Math.imul(ah9, bh5);
  lo2 = lo2 + Math.imul(al8, bl6) | 0;
  mid = mid + Math.imul(al8, bh6) | 0;
  mid = mid + Math.imul(ah8, bl6) | 0;
  hi = hi + Math.imul(ah8, bh6) | 0;
  lo2 = lo2 + Math.imul(al7, bl7) | 0;
  mid = mid + Math.imul(al7, bh7) | 0;
  mid = mid + Math.imul(ah7, bl7) | 0;
  hi = hi + Math.imul(ah7, bh7) | 0;
  lo2 = lo2 + Math.imul(al6, bl8) | 0;
  mid = mid + Math.imul(al6, bh8) | 0;
  mid = mid + Math.imul(ah6, bl8) | 0;
  hi = hi + Math.imul(ah6, bh8) | 0;
  lo2 = lo2 + Math.imul(al5, bl9) | 0;
  mid = mid + Math.imul(al5, bh9) | 0;
  mid = mid + Math.imul(ah5, bl9) | 0;
  hi = hi + Math.imul(ah5, bh9) | 0;
  var w14 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
  w14 &= 67108863;
  lo2 = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = mid + Math.imul(ah9, bl6) | 0;
  hi = Math.imul(ah9, bh6);
  lo2 = lo2 + Math.imul(al8, bl7) | 0;
  mid = mid + Math.imul(al8, bh7) | 0;
  mid = mid + Math.imul(ah8, bl7) | 0;
  hi = hi + Math.imul(ah8, bh7) | 0;
  lo2 = lo2 + Math.imul(al7, bl8) | 0;
  mid = mid + Math.imul(al7, bh8) | 0;
  mid = mid + Math.imul(ah7, bl8) | 0;
  hi = hi + Math.imul(ah7, bh8) | 0;
  lo2 = lo2 + Math.imul(al6, bl9) | 0;
  mid = mid + Math.imul(al6, bh9) | 0;
  mid = mid + Math.imul(ah6, bl9) | 0;
  hi = hi + Math.imul(ah6, bh9) | 0;
  var w15 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
  w15 &= 67108863;
  lo2 = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = mid + Math.imul(ah9, bl7) | 0;
  hi = Math.imul(ah9, bh7);
  lo2 = lo2 + Math.imul(al8, bl8) | 0;
  mid = mid + Math.imul(al8, bh8) | 0;
  mid = mid + Math.imul(ah8, bl8) | 0;
  hi = hi + Math.imul(ah8, bh8) | 0;
  lo2 = lo2 + Math.imul(al7, bl9) | 0;
  mid = mid + Math.imul(al7, bh9) | 0;
  mid = mid + Math.imul(ah7, bl9) | 0;
  hi = hi + Math.imul(ah7, bh9) | 0;
  var w16 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
  w16 &= 67108863;
  lo2 = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = mid + Math.imul(ah9, bl8) | 0;
  hi = Math.imul(ah9, bh8);
  lo2 = lo2 + Math.imul(al8, bl9) | 0;
  mid = mid + Math.imul(al8, bh9) | 0;
  mid = mid + Math.imul(ah8, bl9) | 0;
  hi = hi + Math.imul(ah8, bh9) | 0;
  var w17 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
  w17 &= 67108863;
  lo2 = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = mid + Math.imul(ah9, bl9) | 0;
  hi = Math.imul(ah9, bh9);
  var w18 = (c + lo2 | 0) + ((mid & 8191) << 13) | 0;
  c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
  w18 &= 67108863;
  o[0] = w0;
  o[1] = w1;
  o[2] = w2;
  o[3] = w3;
  o[4] = w4;
  o[5] = w5;
  o[6] = w6;
  o[7] = w7;
  o[8] = w8;
  o[9] = w9;
  o[10] = w10;
  o[11] = w11;
  o[12] = w12;
  o[13] = w13;
  o[14] = w14;
  o[15] = w15;
  o[16] = w16;
  o[17] = w17;
  o[18] = w18;
  if (c !== 0) {
    o[19] = c;
    out.length++;
  }
  return out;
};
if (!Math.imul) {
  comb10MulTo = smallMulTo;
}
function bigMulTo(self2, num, out) {
  out.negative = num.negative ^ self2.negative;
  out.length = self2.length + num.length;
  var carry = 0;
  var hncarry = 0;
  for (var k3 = 0; k3 < out.length - 1; k3++) {
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 67108863;
    var maxJ = Math.min(k3, num.length - 1);
    for (var j = Math.max(0, k3 - self2.length + 1); j <= maxJ; j++) {
      var i = k3 - j;
      var a = self2.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;
      var lo2 = r & 67108863;
      ncarry = ncarry + (r / 67108864 | 0) | 0;
      lo2 = lo2 + rword | 0;
      rword = lo2 & 67108863;
      ncarry = ncarry + (lo2 >>> 26) | 0;
      hncarry += ncarry >>> 26;
      ncarry &= 67108863;
    }
    out.words[k3] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k3] = carry;
  } else {
    out.length--;
  }
  return out._strip();
}
function jumboMulTo(self2, num, out) {
  return bigMulTo(self2, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  var len = this.length + num.length;
  if (this.length === 10 && num.length === 10) {
    res = comb10MulTo(this, num, out);
  } else if (len < 63) {
    res = smallMulTo(this, num, out);
  } else if (len < 1024) {
    res = bigMulTo(this, num, out);
  } else {
    res = jumboMulTo(this, num, out);
  }
  return res;
};
function FFTM(x, y) {
  this.x = x;
  this.y = y;
}
FFTM.prototype.makeRBT = function makeRBT(N2) {
  var t = new Array(N2);
  var l = BN.prototype._countBits(N2) - 1;
  for (var i = 0; i < N2; i++) {
    t[i] = this.revBin(i, l, N2);
  }
  return t;
};
FFTM.prototype.revBin = function revBin(x, l, N2) {
  if (x === 0 || x === N2 - 1)
    return x;
  var rb = 0;
  for (var i = 0; i < l; i++) {
    rb |= (x & 1) << l - i - 1;
    x >>= 1;
  }
  return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
  for (var i = 0; i < N2; i++) {
    rtws[i] = rws[rbt[i]];
    itws[i] = iws[rbt[i]];
  }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
  this.permute(rbt, rws, iws, rtws, itws, N2);
  for (var s = 1; s < N2; s <<= 1) {
    var l = s << 1;
    var rtwdf = Math.cos(2 * Math.PI / l);
    var itwdf = Math.sin(2 * Math.PI / l);
    for (var p = 0; p < N2; p += l) {
      var rtwdf_ = rtwdf;
      var itwdf_ = itwdf;
      for (var j = 0; j < s; j++) {
        var re = rtws[p + j];
        var ie = itws[p + j];
        var ro = rtws[p + j + s];
        var io = itws[p + j + s];
        var rx = rtwdf_ * ro - itwdf_ * io;
        io = rtwdf_ * io + itwdf_ * ro;
        ro = rx;
        rtws[p + j] = re + ro;
        itws[p + j] = ie + io;
        rtws[p + j + s] = re - ro;
        itws[p + j + s] = ie - io;
        if (j !== l) {
          rx = rtwdf * rtwdf_ - itwdf * itwdf_;
          itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
          rtwdf_ = rx;
        }
      }
    }
  }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
  var N2 = Math.max(m, n) | 1;
  var odd = N2 & 1;
  var i = 0;
  for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
    i++;
  }
  return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
  if (N2 <= 1)
    return;
  for (var i = 0; i < N2 / 2; i++) {
    var t = rws[i];
    rws[i] = rws[N2 - i - 1];
    rws[N2 - i - 1] = t;
    t = iws[i];
    iws[i] = -iws[N2 - i - 1];
    iws[N2 - i - 1] = -t;
  }
};
FFTM.prototype.normalize13b = function normalize13b(ws2, N2) {
  var carry = 0;
  for (var i = 0; i < N2 / 2; i++) {
    var w = Math.round(ws2[2 * i + 1] / N2) * 8192 + Math.round(ws2[2 * i] / N2) + carry;
    ws2[i] = w & 67108863;
    if (w < 67108864) {
      carry = 0;
    } else {
      carry = w / 67108864 | 0;
    }
  }
  return ws2;
};
FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N2) {
  var carry = 0;
  for (var i = 0; i < len; i++) {
    carry = carry + (ws2[i] | 0);
    rws[2 * i] = carry & 8191;
    carry = carry >>> 13;
    rws[2 * i + 1] = carry & 8191;
    carry = carry >>> 13;
  }
  for (i = 2 * len; i < N2; ++i) {
    rws[i] = 0;
  }
  assert3(carry === 0);
  assert3((carry & ~8191) === 0);
};
FFTM.prototype.stub = function stub(N2) {
  var ph = new Array(N2);
  for (var i = 0; i < N2; i++) {
    ph[i] = 0;
  }
  return ph;
};
FFTM.prototype.mulp = function mulp(x, y, out) {
  var N2 = 2 * this.guessLen13b(x.length, y.length);
  var rbt = this.makeRBT(N2);
  var _ = this.stub(N2);
  var rws = new Array(N2);
  var rwst = new Array(N2);
  var iwst = new Array(N2);
  var nrws = new Array(N2);
  var nrwst = new Array(N2);
  var niwst = new Array(N2);
  var rmws = out.words;
  rmws.length = N2;
  this.convert13b(x.words, x.length, rws, N2);
  this.convert13b(y.words, y.length, nrws, N2);
  this.transform(rws, _, rwst, iwst, N2, rbt);
  this.transform(nrws, _, nrwst, niwst, N2, rbt);
  for (var i = 0; i < N2; i++) {
    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
    rwst[i] = rx;
  }
  this.conjugate(rwst, iwst, N2);
  this.transform(rwst, iwst, rmws, _, N2, rbt);
  this.conjugate(rmws, _, N2);
  this.normalize13b(rmws, N2);
  out.negative = x.negative ^ y.negative;
  out.length = x.length + y.length;
  return out._strip();
};
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
  return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert3(typeof num === "number");
  assert3(num < 67108864);
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = (this.words[i] | 0) * num;
    var lo2 = (w & 67108863) + (carry & 67108863);
    carry >>= 26;
    carry += w / 67108864 | 0;
    carry += lo2 >>> 26;
    this.words[i] = lo2 & 67108863;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};
BN.prototype.isqr = function isqr() {
  return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
  var w = toBitArray(num);
  if (w.length === 0)
    return new BN(1);
  var res = this;
  for (var i = 0; i < w.length; i++, res = res.sqr()) {
    if (w[i] !== 0)
      break;
  }
  if (++i < w.length) {
    for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
      if (w[i] === 0)
        continue;
      res = res.mul(q);
    }
  }
  return res;
};
BN.prototype.iushln = function iushln(bits) {
  assert3(typeof bits === "number" && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = 67108863 >>> 26 - r << 26 - r;
  var i;
  if (r !== 0) {
    var carry = 0;
    for (i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] | 0) - newCarry << r;
      this.words[i] = c | carry;
      carry = newCarry >>> 26 - r;
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }
  if (s !== 0) {
    for (i = this.length - 1; i >= 0; i--) {
      this.words[i + s] = this.words[i];
    }
    for (i = 0; i < s; i++) {
      this.words[i] = 0;
    }
    this.length += s;
  }
  return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
  assert3(this.negative === 0);
  return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
  assert3(typeof bits === "number" && bits >= 0);
  var h;
  if (hint) {
    h = (hint - hint % 26) / 26;
  } else {
    h = 0;
  }
  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 67108863 ^ 67108863 >>> r << r;
  var maskedWords = extended;
  h -= s;
  h = Math.max(0, h);
  if (maskedWords) {
    for (var i = 0; i < s; i++) {
      maskedWords.words[i] = this.words[i];
    }
    maskedWords.length = s;
  }
  if (s === 0) {
  } else if (this.length > s) {
    this.length -= s;
    for (i = 0; i < this.length; i++) {
      this.words[i] = this.words[i + s];
    }
  } else {
    this.words[0] = 0;
    this.length = 1;
  }
  var carry = 0;
  for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i] | 0;
    this.words[i] = carry << 26 - r | word >>> r;
    carry = word & mask;
  }
  if (maskedWords && carry !== 0) {
    maskedWords.words[maskedWords.length++] = carry;
  }
  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }
  return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert3(this.negative === 0);
  return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
  return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
  return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
  assert3(typeof bit === "number" && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;
  if (this.length <= s)
    return false;
  var w = this.words[s];
  return !!(w & q);
};
BN.prototype.imaskn = function imaskn(bits) {
  assert3(typeof bits === "number" && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  assert3(this.negative === 0, "imaskn works only with positive numbers");
  if (this.length <= s) {
    return this;
  }
  if (r !== 0) {
    s++;
  }
  this.length = Math.min(s, this.length);
  if (r !== 0) {
    var mask = 67108863 ^ 67108863 >>> r << r;
    this.words[this.length - 1] &= mask;
  }
  return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
  assert3(typeof num === "number");
  assert3(num < 67108864);
  if (num < 0)
    return this.isubn(-num);
  if (this.negative !== 0) {
    if (this.length === 1 && (this.words[0] | 0) <= num) {
      this.words[0] = num - (this.words[0] | 0);
      this.negative = 0;
      return this;
    }
    this.negative = 0;
    this.isubn(num);
    this.negative = 1;
    return this;
  }
  return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;
  for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
    this.words[i] -= 67108864;
    if (i === this.length - 1) {
      this.words[i + 1] = 1;
    } else {
      this.words[i + 1]++;
    }
  }
  this.length = Math.max(this.length, i + 1);
  return this;
};
BN.prototype.isubn = function isubn(num) {
  assert3(typeof num === "number");
  assert3(num < 67108864);
  if (num < 0)
    return this.iaddn(-num);
  if (this.negative !== 0) {
    this.negative = 0;
    this.iaddn(num);
    this.negative = 1;
    return this;
  }
  this.words[0] -= num;
  if (this.length === 1 && this.words[0] < 0) {
    this.words[0] = -this.words[0];
    this.negative = 1;
  } else {
    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 67108864;
      this.words[i + 1] -= 1;
    }
  }
  return this._strip();
};
BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
  this.negative = 0;
  return this;
};
BN.prototype.abs = function abs() {
  return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift) {
  var len = num.length + shift;
  var i;
  this._expand(len);
  var w;
  var carry = 0;
  for (i = 0; i < num.length; i++) {
    w = (this.words[i + shift] | 0) + carry;
    var right = (num.words[i] | 0) * mul4;
    w -= right & 67108863;
    carry = (w >> 26) - (right / 67108864 | 0);
    this.words[i + shift] = w & 67108863;
  }
  for (; i < this.length - shift; i++) {
    w = (this.words[i + shift] | 0) + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 67108863;
  }
  if (carry === 0)
    return this._strip();
  assert3(carry === -1);
  carry = 0;
  for (i = 0; i < this.length; i++) {
    w = -(this.words[i] | 0) + carry;
    carry = w >> 26;
    this.words[i] = w & 67108863;
  }
  this.negative = 1;
  return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;
  var a = this.clone();
  var b = num;
  var bhi = b.words[b.length - 1] | 0;
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.ushln(shift);
    a.iushln(shift);
    bhi = b.words[b.length - 1] | 0;
  }
  var m = a.length - b.length;
  var q;
  if (mode !== "mod") {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++) {
      q.words[i] = 0;
    }
  }
  var diff3 = a.clone()._ishlnsubmul(b, 1, m);
  if (diff3.negative === 0) {
    a = diff3;
    if (q) {
      q.words[m] = 1;
    }
  }
  for (var j = m - 1; j >= 0; j--) {
    var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
    qj = Math.min(qj / bhi | 0, 67108863);
    a._ishlnsubmul(b, qj, j);
    while (a.negative !== 0) {
      qj--;
      a.negative = 0;
      a._ishlnsubmul(b, 1, j);
      if (!a.isZero()) {
        a.negative ^= 1;
      }
    }
    if (q) {
      q.words[j] = qj;
    }
  }
  if (q) {
    q._strip();
  }
  a._strip();
  if (mode !== "div" && shift !== 0) {
    a.iushrn(shift);
  }
  return {
    div: q || null,
    mod: a
  };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
  assert3(!num.isZero());
  if (this.isZero()) {
    return {
      div: new BN(0),
      mod: new BN(0)
    };
  }
  var div2, mod2, res;
  if (this.negative !== 0 && num.negative === 0) {
    res = this.neg().divmod(num, mode);
    if (mode !== "mod") {
      div2 = res.div.neg();
    }
    if (mode !== "div") {
      mod2 = res.mod.neg();
      if (positive && mod2.negative !== 0) {
        mod2.iadd(num);
      }
    }
    return {
      div: div2,
      mod: mod2
    };
  }
  if (this.negative === 0 && num.negative !== 0) {
    res = this.divmod(num.neg(), mode);
    if (mode !== "mod") {
      div2 = res.div.neg();
    }
    return {
      div: div2,
      mod: res.mod
    };
  }
  if ((this.negative & num.negative) !== 0) {
    res = this.neg().divmod(num.neg(), mode);
    if (mode !== "div") {
      mod2 = res.mod.neg();
      if (positive && mod2.negative !== 0) {
        mod2.isub(num);
      }
    }
    return {
      div: res.div,
      mod: mod2
    };
  }
  if (num.length > this.length || this.cmp(num) < 0) {
    return {
      div: new BN(0),
      mod: this
    };
  }
  if (num.length === 1) {
    if (mode === "div") {
      return {
        div: this.divn(num.words[0]),
        mod: null
      };
    }
    if (mode === "mod") {
      return {
        div: null,
        mod: new BN(this.modrn(num.words[0]))
      };
    }
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modrn(num.words[0]))
    };
  }
  return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
  return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
  return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
  return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);
  if (dm.mod.isZero())
    return dm.div;
  var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
  var half = num.ushrn(1);
  var r2 = num.andln(1);
  var cmp2 = mod2.cmp(half);
  if (cmp2 < 0 || r2 === 1 && cmp2 === 0)
    return dm.div;
  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert3(num <= 67108863);
  var p = (1 << 26) % num;
  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    acc = (p * acc + (this.words[i] | 0)) % num;
  }
  return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
  return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert3(num <= 67108863);
  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = (this.words[i] | 0) + carry * 67108864;
    this.words[i] = w / num | 0;
    carry = w % num;
  }
  this._strip();
  return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p) {
  assert3(p.negative === 0);
  assert3(!p.isZero());
  var x = this;
  var y = p.clone();
  if (x.negative !== 0) {
    x = x.umod(p);
  } else {
    x = x.clone();
  }
  var A = new BN(1);
  var B = new BN(0);
  var C = new BN(0);
  var D = new BN(1);
  var g = 0;
  while (x.isEven() && y.isEven()) {
    x.iushrn(1);
    y.iushrn(1);
    ++g;
  }
  var yp = y.clone();
  var xp = x.clone();
  while (!x.isZero()) {
    for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
      ;
    if (i > 0) {
      x.iushrn(i);
      while (i-- > 0) {
        if (A.isOdd() || B.isOdd()) {
          A.iadd(yp);
          B.isub(xp);
        }
        A.iushrn(1);
        B.iushrn(1);
      }
    }
    for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
      ;
    if (j > 0) {
      y.iushrn(j);
      while (j-- > 0) {
        if (C.isOdd() || D.isOdd()) {
          C.iadd(yp);
          D.isub(xp);
        }
        C.iushrn(1);
        D.iushrn(1);
      }
    }
    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }
  return {
    a: C,
    b: D,
    gcd: y.iushln(g)
  };
};
BN.prototype._invmp = function _invmp(p) {
  assert3(p.negative === 0);
  assert3(!p.isZero());
  var a = this;
  var b = p.clone();
  if (a.negative !== 0) {
    a = a.umod(p);
  } else {
    a = a.clone();
  }
  var x1 = new BN(1);
  var x2 = new BN(0);
  var delta = b.clone();
  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
      ;
    if (i > 0) {
      a.iushrn(i);
      while (i-- > 0) {
        if (x1.isOdd()) {
          x1.iadd(delta);
        }
        x1.iushrn(1);
      }
    }
    for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
      ;
    if (j > 0) {
      b.iushrn(j);
      while (j-- > 0) {
        if (x2.isOdd()) {
          x2.iadd(delta);
        }
        x2.iushrn(1);
      }
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  var res;
  if (a.cmpn(1) === 0) {
    res = x1;
  } else {
    res = x2;
  }
  if (res.cmpn(0) < 0) {
    res.iadd(p);
  }
  return res;
};
BN.prototype.gcd = function gcd(num) {
  if (this.isZero())
    return num.abs();
  if (num.isZero())
    return this.abs();
  var a = this.clone();
  var b = num.clone();
  a.negative = 0;
  b.negative = 0;
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.iushrn(1);
    b.iushrn(1);
  }
  do {
    while (a.isEven()) {
      a.iushrn(1);
    }
    while (b.isEven()) {
      b.iushrn(1);
    }
    var r = a.cmp(b);
    if (r < 0) {
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }
    a.isub(b);
  } while (true);
  return b.iushln(shift);
};
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
  assert3(typeof bit === "number");
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;
  if (this.length <= s) {
    this._expand(s + 1);
    this.words[s] |= q;
    return this;
  }
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i] | 0;
    w += carry;
    carry = w >>> 26;
    w &= 67108863;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};
BN.prototype.isZero = function isZero() {
  return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
  var negative = num < 0;
  if (this.negative !== 0 && !negative)
    return -1;
  if (this.negative === 0 && negative)
    return 1;
  this._strip();
  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    if (negative) {
      num = -num;
    }
    assert3(num <= 67108863, "Number is too big");
    var w = this.words[0] | 0;
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.negative !== 0)
    return -res | 0;
  return res;
};
BN.prototype.cmp = function cmp(num) {
  if (this.negative !== 0 && num.negative === 0)
    return -1;
  if (this.negative === 0 && num.negative !== 0)
    return 1;
  var res = this.ucmp(num);
  if (this.negative !== 0)
    return -res | 0;
  return res;
};
BN.prototype.ucmp = function ucmp(num) {
  if (this.length > num.length)
    return 1;
  if (this.length < num.length)
    return -1;
  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i] | 0;
    var b = num.words[i] | 0;
    if (a === b)
      continue;
    if (a < b) {
      res = -1;
    } else if (a > b) {
      res = 1;
    }
    break;
  }
  return res;
};
BN.prototype.gtn = function gtn(num) {
  return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
  return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
  return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
  return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
  return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
  return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
  return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
  return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
  return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
  return this.cmp(num) === 0;
};
BN.red = function red2(num) {
  return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
  assert3(!this.red, "Already a number in reduction context");
  assert3(this.negative === 0, "red works only with positives");
  return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
  assert3(this.red, "fromRed works only with numbers in reduction context");
  return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
  assert3(!this.red, "Already a number in reduction context");
  return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
  assert3(this.red, "redAdd works only with red numbers");
  return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
  assert3(this.red, "redIAdd works only with red numbers");
  return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
  assert3(this.red, "redSub works only with red numbers");
  return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
  assert3(this.red, "redISub works only with red numbers");
  return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
  assert3(this.red, "redShl works only with red numbers");
  return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
  assert3(this.red, "redMul works only with red numbers");
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
  assert3(this.red, "redMul works only with red numbers");
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
  assert3(this.red, "redSqr works only with red numbers");
  this.red._verify1(this);
  return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
  assert3(this.red, "redISqr works only with red numbers");
  this.red._verify1(this);
  return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
  assert3(this.red, "redSqrt works only with red numbers");
  this.red._verify1(this);
  return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
  assert3(this.red, "redInvm works only with red numbers");
  this.red._verify1(this);
  return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
  assert3(this.red, "redNeg works only with red numbers");
  this.red._verify1(this);
  return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
  assert3(this.red && !num.red, "redPow(normalNum)");
  this.red._verify1(this);
  return this.red.pow(this, num);
};
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};
function MPrime(name, p) {
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).iushln(this.n).isub(this.p);
  this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
  var r = num;
  var rlen;
  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);
  var cmp2 = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp2 === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp2 > 0) {
    r.isub(this.p);
  } else {
    if (r.strip !== void 0) {
      r.strip();
    } else {
      r._strip();
    }
  }
  return r;
};
MPrime.prototype.split = function split(input, out) {
  input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};
function K256() {
  MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits2(K256, MPrime);
K256.prototype.split = function split2(input, output) {
  var mask = 4194303;
  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++) {
    output.words[i] = input.words[i];
  }
  output.length = outLen;
  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;
  for (i = 10; i < input.length; i++) {
    var next = input.words[i] | 0;
    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
    prev = next;
  }
  prev >>>= 22;
  input.words[i - 10] = prev;
  if (prev === 0 && input.length > 10) {
    input.length -= 10;
  } else {
    input.length -= 9;
  }
};
K256.prototype.imulK = function imulK2(num) {
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;
  var lo2 = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i] | 0;
    lo2 += w * 977;
    num.words[i] = lo2 & 67108863;
    lo2 = w * 64 + (lo2 / 67108864 | 0);
  }
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0) {
      num.length--;
    }
  }
  return num;
};
function P224() {
  MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits2(P224, MPrime);
function P192() {
  MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits2(P192, MPrime);
function P25519() {
  MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits2(P25519, MPrime);
P25519.prototype.imulK = function imulK3(num) {
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = (num.words[i] | 0) * 19 + carry;
    var lo2 = hi & 67108863;
    hi >>>= 26;
    num.words[i] = lo2;
    carry = hi;
  }
  if (carry !== 0) {
    num.words[num.length++] = carry;
  }
  return num;
};
BN._prime = function prime(name) {
  if (primes[name])
    return primes[name];
  var prime2;
  if (name === "k256") {
    prime2 = new K256();
  } else if (name === "p224") {
    prime2 = new P224();
  } else if (name === "p192") {
    prime2 = new P192();
  } else if (name === "p25519") {
    prime2 = new P25519();
  } else {
    throw new Error("Unknown prime " + name);
  }
  primes[name] = prime2;
  return prime2;
};
function Red(m) {
  if (typeof m === "string") {
    var prime2 = BN._prime(m);
    this.m = prime2.p;
    this.prime = prime2;
  } else {
    assert3(m.gtn(1), "modulus must be greater than 1");
    this.m = m;
    this.prime = null;
  }
}
Red.prototype._verify1 = function _verify1(a) {
  assert3(a.negative === 0, "red works only with positives");
  assert3(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b) {
  assert3((a.negative | b.negative) === 0, "red works only with positives");
  assert3(a.red && a.red === b.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  move(a, a.umod(this.m)._forceRed(this));
  return a;
};
Red.prototype.neg = function neg2(a) {
  if (a.isZero()) {
    return a.clone();
  }
  return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add2(a, b) {
  this._verify2(a, b);
  var res = a.add(b);
  if (res.cmp(this.m) >= 0) {
    res.isub(this.m);
  }
  return res._forceRed(this);
};
Red.prototype.iadd = function iadd2(a, b) {
  this._verify2(a, b);
  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0) {
    res.isub(this.m);
  }
  return res;
};
Red.prototype.sub = function sub2(a, b) {
  this._verify2(a, b);
  var res = a.sub(b);
  if (res.cmpn(0) < 0) {
    res.iadd(this.m);
  }
  return res._forceRed(this);
};
Red.prototype.isub = function isub2(a, b) {
  this._verify2(a, b);
  var res = a.isub(b);
  if (res.cmpn(0) < 0) {
    res.iadd(this.m);
  }
  return res;
};
Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul2(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};
Red.prototype.mul = function mul2(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};
Red.prototype.isqr = function isqr2(a) {
  return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr2(a) {
  return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
  if (a.isZero())
    return a.clone();
  var mod3 = this.m.andln(3);
  assert3(mod3 % 2 === 1);
  if (mod3 === 3) {
    var pow3 = this.m.add(new BN(1)).iushrn(2);
    return this.pow(a, pow3);
  }
  var q = this.m.subn(1);
  var s = 0;
  while (!q.isZero() && q.andln(1) === 0) {
    s++;
    q.iushrn(1);
  }
  assert3(!q.isZero());
  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();
  var lpow = this.m.subn(1).iushrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0) {
    z.redIAdd(nOne);
  }
  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).iushrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++) {
      tmp = tmp.redSqr();
    }
    assert3(i < m);
    var b = this.pow(c, new BN(1).iushln(m - i - 1));
    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }
  return r;
};
Red.prototype.invm = function invm2(a) {
  var inv = a._invmp(this.m);
  if (inv.negative !== 0) {
    inv.negative = 0;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};
Red.prototype.pow = function pow2(a, num) {
  if (num.isZero())
    return new BN(1).toRed(this);
  if (num.cmpn(1) === 0)
    return a.clone();
  var windowSize = 4;
  var wnd = new Array(1 << windowSize);
  wnd[0] = new BN(1).toRed(this);
  wnd[1] = a;
  for (var i = 2; i < wnd.length; i++) {
    wnd[i] = this.mul(wnd[i - 1], a);
  }
  var res = wnd[0];
  var current = 0;
  var currentLen = 0;
  var start = num.bitLength() % 26;
  if (start === 0) {
    start = 26;
  }
  for (i = num.length - 1; i >= 0; i--) {
    var word = num.words[i];
    for (var j = start - 1; j >= 0; j--) {
      var bit = word >> j & 1;
      if (res !== wnd[0]) {
        res = this.sqr(res);
      }
      if (bit === 0 && current === 0) {
        currentLen = 0;
        continue;
      }
      current <<= 1;
      current |= bit;
      currentLen++;
      if (currentLen !== windowSize && (i !== 0 || j !== 0))
        continue;
      res = this.mul(res, wnd[current]);
      currentLen = 0;
      current = 0;
    }
    start = 26;
  }
  return res;
};
Red.prototype.convertTo = function convertTo(num) {
  var r = num.umod(this.m);
  return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};
BN.mont = function mont(num) {
  return new Mont(num);
};
function Mont(m) {
  Red.call(this, m);
  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0) {
    this.shift += 26 - this.shift % 26;
  }
  this.r = new BN(1).iushln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);
  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv = this.minv.umod(this.r);
  this.minv = this.r.sub(this.minv);
}
inherits2(Mont, Red);
Mont.prototype.convertTo = function convertTo2(num) {
  return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom2(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};
Mont.prototype.imul = function imul3(a, b) {
  if (a.isZero() || b.isZero()) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }
  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0) {
    res = u.isub(this.m);
  } else if (u.cmpn(0) < 0) {
    res = u.iadd(this.m);
  }
  return res._forceRed(this);
};
Mont.prototype.mul = function mul3(a, b) {
  if (a.isZero() || b.isZero())
    return new BN(0)._forceRed(this);
  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0) {
    res = u.isub(this.m);
  } else if (u.cmpn(0) < 0) {
    res = u.iadd(this.m);
  }
  return res._forceRed(this);
};
Mont.prototype.invm = function invm3(a) {
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/base/reporter.js
function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
Reporter.prototype.isError = function isError2(obj2) {
  return obj2 instanceof ReporterError;
};
Reporter.prototype.save = function save() {
  const state = this._reporterState;
  return { obj: state.obj, pathLen: state.path.length };
};
Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key2) {
  return this._reporterState.path.push(key2);
};
Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key2, value) {
  const state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null) {
    state.obj[key2] = value;
  }
};
Reporter.prototype.path = function path3() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;
  const prev = state.obj;
  state.obj = {};
  return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;
  const now = state.obj;
  state.obj = prev;
  return now;
};
Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;
  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return "[" + JSON.stringify(elem) + "]";
    }).join(""), msg.message || msg, msg.stack);
  }
  if (!state.options.partial) {
    throw err;
  }
  if (!inherited) {
    state.errors.push(err);
  }
  return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial) {
    return result;
  }
  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};
function ReporterError(path6, msg) {
  this.path = path6;
  this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: ReporterError,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + " at: " + (this.path || "(shallow)");
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ReporterError);
  }
  if (!this.stack) {
    try {
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/base/buffer.js
function DecoderBuffer(base3, options) {
  Reporter.call(this, options);
  if (!Buffer3.isBuffer(base3)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = base3;
  this.offset = 0;
  this.length = base3.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
  constructor: {
    value: DecoderBuffer,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }
  const isCompatible = typeof data === "object" && Buffer3.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
  return isCompatible;
};
DecoderBuffer.prototype.save = function save2() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};
DecoderBuffer.prototype.restore = function restore2(save3) {
  const res = new DecoderBuffer(this.base);
  res.offset = save3.offset;
  res.length = this.offset;
  this.offset = save3.offset;
  Reporter.prototype.restore.call(this, save3.reporter);
  return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt82(fail3) {
  if (this.offset + 1 <= this.length) {
    return this.base.readUInt8(this.offset++, true);
  } else {
    return this.error(fail3 || "DecoderBuffer overrun");
  }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail3) {
  if (!(this.offset + bytes <= this.length)) {
    return this.error(fail3 || "DecoderBuffer overrun");
  }
  const res = new DecoderBuffer(this.base);
  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};
DecoderBuffer.prototype.raw = function raw(save3) {
  return this.base.slice(save3 ? save3.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item)) {
        item = new EncoderBuffer(item, reporter);
      }
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === "number") {
    if (!(0 <= value && value <= 255)) {
      return reporter.error("non-byte EncoderBuffer value");
    }
    this.value = value;
    this.length = 1;
  } else if (typeof value === "string") {
    this.value = value;
    this.length = Buffer3.byteLength(value);
  } else if (Buffer3.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error("Unsupported type: " + typeof value);
  }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }
  const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
  return isCompatible;
};
EncoderBuffer.prototype.join = function join6(out, offset) {
  if (!out) {
    out = Buffer3.alloc(this.length);
  }
  if (!offset) {
    offset = 0;
  }
  if (this.length === 0) {
    return out;
  }
  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === "number") {
      out[offset] = this.value;
    } else if (typeof this.value === "string") {
      out.write(this.value, offset);
    } else if (Buffer3.isBuffer(this.value)) {
      this.value.copy(out, offset);
    }
    offset += this.length;
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/base/node.js
var tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
];
var methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags);
var overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;
  state.name = name;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null;
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state["default"] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
var stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node.prototype.clone = function clone2() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};
Node.prototype._wrap = function wrap2() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone3 = new this.constructor(this);
      state.children.push(clone3);
      return clone3[method].apply(clone3, arguments);
    };
  }, this);
};
Node.prototype._init = function init2(body) {
  const state = this._baseState;
  assert(state.parent === null);
  body.call(this);
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assertEquals(state.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);
  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== "object" || arg.constructor !== Object) {
        return arg;
      }
      const res = {};
      Object.keys(arg).forEach(function(key2) {
        if (key2 == (key2 | 0)) {
          key2 |= 0;
        }
        const value = arg[key2];
        res[value] = key2;
      });
      return res;
    });
  }
};
overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + " not implemented for encoding: " + state.enc);
  };
});
tags.forEach(function(tag2) {
  Node.prototype[tag2] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    assert(state.tag === null);
    state.tag = tag2;
    this._useArgs(args);
    return this;
  };
});
Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;
  assert(state.use === null);
  state.use = item;
  return this;
};
Node.prototype.optional = function optional() {
  const state = this._baseState;
  state.optional = true;
  return this;
};
Node.prototype.def = function def(val) {
  const state = this._baseState;
  assert(state["default"] === null);
  state["default"] = val;
  state.optional = true;
  return this;
};
Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};
Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};
Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0) {
    this._useArgs(args);
  }
  return this;
};
Node.prototype.key = function key(newKey) {
  const state = this._baseState;
  assert(state.key === null);
  state.key = newKey;
  return this;
};
Node.prototype.any = function any() {
  const state = this._baseState;
  state.any = true;
  return this;
};
Node.prototype.choice = function choice(obj2) {
  const state = this._baseState;
  assert(state.choice === null);
  state.choice = obj2;
  this._useArgs(Object.keys(obj2).map(function(key2) {
    return obj2[key2];
  }));
  return this;
};
Node.prototype.contains = function contains(item) {
  const state = this._baseState;
  assert(state.use === null);
  state.contains = item;
  return this;
};
Node.prototype._decode = function decode3(input, options) {
  const state = this._baseState;
  if (state.parent === null) {
    return input.wrapResult(state.children[0]._decode(input, options));
  }
  let result = state["default"];
  let present = true;
  let prevKey = null;
  if (state.key !== null) {
    prevKey = input.enterKey(state.key);
  }
  if (state.optional) {
    let tag2 = null;
    if (state.explicit !== null) {
      tag2 = state.explicit;
    } else if (state.implicit !== null) {
      tag2 = state.implicit;
    } else if (state.tag !== null) {
      tag2 = state.tag;
    }
    if (tag2 === null && !state.any) {
      const save3 = input.save();
      try {
        if (state.choice === null) {
          this._decodeGeneric(state.tag, input, options);
        } else {
          this._decodeChoice(input, options);
        }
        present = true;
      } catch (_e) {
        present = false;
      }
      input.restore(save3);
    } else {
      present = this._peekTag(input, tag2, state.any);
      if (input.isError(present)) {
        return present;
      }
    }
  }
  let prevObj;
  if (state.obj && present) {
    prevObj = input.enterObject();
  }
  if (present) {
    if (state.explicit !== null) {
      const explicit2 = this._decodeTag(input, state.explicit);
      if (input.isError(explicit2)) {
        return explicit2;
      }
      input = explicit2;
    }
    const start = input.offset;
    if (state.use === null && state.choice === null) {
      let save3;
      if (state.any) {
        save3 = input.save();
      }
      const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
      if (input.isError(body)) {
        return body;
      }
      if (state.any) {
        result = input.raw(save3);
      } else {
        input = body;
      }
    }
    if (options && options.track && state.tag !== null) {
      options.track(input.path(), start, input.length, "tagged");
    }
    if (options && options.track && state.tag !== null) {
      options.track(input.path(), input.offset, input.length, "content");
    }
    if (state.any) {
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }
    if (input.isError(result)) {
      return result;
    }
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        child._decode(input, options);
      });
    }
    if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  }
  if (state.obj && present) {
    result = input.leaveObject(prevObj);
  }
  if (state.key !== null && (result !== null || present === true)) {
    input.leaveKey(prevKey, state.key, result);
  } else if (prevKey !== null) {
    input.exitKey(prevKey);
  }
  return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag2, input, options) {
  const state = this._baseState;
  if (tag2 === "seq" || tag2 === "set") {
    return null;
  }
  if (tag2 === "seqof" || tag2 === "setof") {
    return this._decodeList(input, tag2, state.args[0], options);
  } else if (/str$/.test(tag2)) {
    return this._decodeStr(input, tag2, options);
  } else if (tag2 === "objid" && state.args) {
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  } else if (tag2 === "objid") {
    return this._decodeObjid(input, null, null, options);
  } else if (tag2 === "gentime" || tag2 === "utctime") {
    return this._decodeTime(input, tag2, options);
  } else if (tag2 === "null_") {
    return this._decodeNull(input, options);
  } else if (tag2 === "bool") {
    return this._decodeBool(input, options);
  } else if (tag2 === "objDesc") {
    return this._decodeStr(input, tag2, options);
  } else if (tag2 === "int" || tag2 === "enum") {
    return this._decodeInt(input, state.args && state.args[0], options);
  }
  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error("unknown tag: " + tag2);
  }
};
Node.prototype._getUse = function _getUse(entity, obj2) {
  const state = this._baseState;
  state.useDecoder = this._use(entity, obj2);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;
  Object.keys(state.choice).some(function(key2) {
    const save3 = input.save();
    const node = state.choice[key2];
    try {
      const value = node._decode(input, options);
      if (input.isError(value)) {
        return false;
      }
      result = { type: key2, value };
      match = true;
    } catch (_e) {
      input.restore(save3);
      return false;
    }
    return true;
  }, this);
  if (!match) {
    return input.error("Choice not matched");
  }
  return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode4(data, reporter, parent) {
  const state = this._baseState;
  if (state["default"] !== null && state["default"] === data) {
    return;
  }
  const result = this._encodeValue(data, reporter, parent);
  if (result === void 0) {
    return;
  }
  if (this._skipDefault(result, reporter, parent)) {
    return;
  }
  return result;
};
Node.prototype._encodeValue = function encode5(data, reporter, parent) {
  const state = this._baseState;
  if (state.parent === null) {
    return state.children[0]._encode(data, reporter || new Reporter());
  }
  let result = null;
  this.reporter = reporter;
  if (state.optional && data === void 0) {
    if (state["default"] !== null) {
      data = state["default"];
    } else {
      return;
    }
  }
  let content = null;
  let primitive = false;
  if (state.any) {
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === "null_") {
        return child._encode(null, reporter, data);
      }
      if (child._baseState.key === null) {
        return reporter.error("Child should have a key");
      }
      const prevKey = reporter.enterKey(child._baseState.key);
      if (typeof data !== "object") {
        return reporter.error("Child expected, but input is not object");
      }
      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);
      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === "seqof" || state.tag === "setof") {
      if (!(state.args && state.args.length === 1)) {
        return reporter.error("Too many args for : " + state.tag);
      }
      if (!Array.isArray(data)) {
        return reporter.error("seqof/setof, but data is not Array");
      }
      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state2 = this._baseState;
        return this._getUse(state2.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }
  if (!state.any && state.choice === null) {
    const tag2 = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? "universal" : "context";
    if (tag2 === null) {
      if (state.use === null) {
        reporter.error("Tag could be omitted only for .use()");
      }
    } else {
      if (state.use === null) {
        result = this._encodeComposite(tag2, primitive, cls, content);
      }
    }
  }
  if (state.explicit !== null) {
    result = this._encodeComposite(state.explicit, false, "context", result);
  }
  return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;
  const node = state.choice[data.type];
  if (!node) {
    assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag2, data) {
  const state = this._baseState;
  if (/str$/.test(tag2)) {
    return this._encodeStr(data, tag2);
  } else if (tag2 === "objid" && state.args) {
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  } else if (tag2 === "objid") {
    return this._encodeObjid(data, null, null);
  } else if (tag2 === "gentime" || tag2 === "utctime") {
    return this._encodeTime(data, tag2);
  } else if (tag2 === "null_") {
    return this._encodeNull();
  } else if (tag2 === "int" || tag2 === "enum") {
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  } else if (tag2 === "bool") {
    return this._encodeBool(data);
  } else if (tag2 === "objDesc") {
    return this._encodeStr(data, tag2);
  } else {
    throw new Error("Unsupported tag: " + tag2);
  }
};
Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/constants/der.js
var der_exports = {};
__export(der_exports, {
  tag: () => tag,
  tagByName: () => tagByName,
  tagClass: () => tagClass,
  tagClassByName: () => tagClassByName
});
function reverse(map) {
  const res = {};
  Object.keys(map).forEach(function(key2) {
    if ((key2 | 0) == key2) {
      key2 = key2 | 0;
    }
    const value = map[key2];
    res[value] = key2;
  });
  return res;
}
var tagClass = {
  0: "universal",
  1: "application",
  2: "context",
  3: "private"
};
var tagClassByName = reverse(tagClass);
var tag = {
  0: "end",
  1: "bool",
  2: "int",
  3: "bitstr",
  4: "octstr",
  5: "null_",
  6: "objid",
  7: "objDesc",
  8: "external",
  9: "real",
  10: "enum",
  11: "embed",
  12: "utf8str",
  13: "relativeOid",
  16: "seq",
  17: "set",
  18: "numstr",
  19: "printstr",
  20: "t61str",
  21: "videostr",
  22: "ia5str",
  23: "utctime",
  24: "gentime",
  25: "graphstr",
  26: "iso646str",
  27: "genstr",
  28: "unistr",
  29: "charstr",
  30: "bmpstr"
};
var tagByName = reverse(tag);

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/encoders/der.js
function DEREncoder(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode6(data, reporter) {
  return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
  Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
  constructor: {
    value: DERNode,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag2, primitive, cls, content) {
  const encodedTag = encodeTag(tag2, primitive, cls, this.reporter);
  if (content.length < 128) {
    const header2 = Buffer3.alloc(2);
    header2[0] = encodedTag;
    header2[1] = content.length;
    return this._createEncoderBuffer([header2, content]);
  }
  let lenOctets = 1;
  for (let i = content.length; i >= 256; i >>= 8) {
    lenOctets++;
  }
  const header = Buffer3.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 128 | lenOctets;
  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) {
    header[i] = j & 255;
  }
  return this._createEncoderBuffer([header, content]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag2) {
  if (tag2 === "bitstr") {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag2 === "bmpstr") {
    const buf = Buffer3.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag2 === "numstr") {
    if (!this._isNumstr(str)) {
      return this.reporter.error("Encoding of string type: numstr supports only digits and space");
    }
    return this._createEncoderBuffer(str);
  } else if (tag2 === "printstr") {
    if (!this._isPrintstr(str)) {
      return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag2)) {
    return this._createEncoderBuffer(str);
  } else if (tag2 === "objDesc") {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error("Encoding of string type: " + tag2 + " unsupported");
  }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative7) {
  if (typeof id === "string") {
    if (!values) {
      return this.reporter.error("string objid given, but no values map found");
    }
    if (!values.hasOwnProperty(id)) {
      return this.reporter.error("objid not found in values map");
    }
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  }
  if (!Array.isArray(id)) {
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
  }
  if (!relative7) {
    if (id[1] >= 40) {
      return this.reporter.error("Second objid identifier OOB");
    }
    id.splice(0, 2, id[0] * 40 + id[1]);
  }
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 128; ident >>= 7) {
      size++;
    }
  }
  const objid = Buffer3.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 127;
    while ((ident >>= 7) > 0) {
      objid[offset--] = 128 | ident & 127;
    }
  }
  return this._createEncoderBuffer(objid);
};
function two(num) {
  if (num < 10) {
    return "0" + num;
  } else {
    return num;
  }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag2) {
  let str;
  const date = new Date(time);
  if (tag2 === "gentime") {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else if (tag2 === "utctime") {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else {
    this.reporter.error("Encoding " + tag2 + " time is not supported yet");
  }
  return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === "string") {
    if (!values) {
      return this.reporter.error("String int or enum given, but no values map");
    }
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
    }
    num = values[num];
  }
  if (typeof num !== "number" && !Buffer3.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 128) {
      numArray.unshift(0);
    }
    num = Buffer3.from(numArray);
  }
  if (Buffer3.isBuffer(num)) {
    let size2 = num.length;
    if (num.length === 0) {
      size2++;
    }
    const out2 = Buffer3.alloc(size2);
    num.copy(out2);
    if (num.length === 0) {
      out2[0] = 0;
    }
    return this._createEncoderBuffer(out2);
  }
  if (num < 128) {
    return this._createEncoderBuffer(num);
  }
  if (num < 256) {
    return this._createEncoderBuffer([0, num]);
  }
  let size = 1;
  for (let i = num; i >= 256; i >>= 8) {
    size++;
  }
  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 255;
    num >>= 8;
  }
  if (out[0] & 128) {
    out.unshift(0);
  }
  return this._createEncoderBuffer(Buffer3.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 255 : 0);
};
DERNode.prototype._use = function use2(entity, obj2) {
  if (typeof entity === "function") {
    entity = entity(obj2);
  }
  return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state["default"] === null) {
    return false;
  }
  const data = dataBuffer.join();
  if (state.defaultBuffer === void 0) {
    state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
  }
  if (data.length !== state.defaultBuffer.length) {
    return false;
  }
  for (i = 0; i < data.length; i++) {
    if (data[i] !== state.defaultBuffer[i]) {
      return false;
    }
  }
  return true;
};
function encodeTag(tag2, primitive, cls, reporter) {
  let res;
  if (tag2 === "seqof") {
    tag2 = "seq";
  } else if (tag2 === "setof") {
    tag2 = "set";
  }
  if (tagByName.hasOwnProperty(tag2)) {
    res = tagByName[tag2];
  } else if (typeof tag2 === "number" && (tag2 | 0) === tag2) {
    res = tag2;
  } else {
    return reporter.error("Unknown tag: " + tag2);
  }
  if (res >= 31) {
    return reporter.error("Multi-octet tag encoding unsupported");
  }
  if (!primitive) {
    res |= 32;
  }
  res |= tagClassByName[cls || "universal"] << 6;
  return res;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/encoders/pem.js
function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
  constructor: {
    value: PEMEncoder,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
PEMEncoder.prototype.encode = function encode7(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);
  const p = buf.toString("base64");
  const out = ["-----BEGIN " + options.label + "-----"];
  for (let i = 0; i < p.length; i += 64) {
    out.push(p.slice(i, i + 64));
  }
  out.push("-----END " + options.label + "-----");
  return out.join("\n");
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/decoders/der.js
function DERDecoder(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode2();
  this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode4(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }
  return this.tree._decode(data, options);
};
function DERNode2(parent) {
  Node.call(this, "der", parent);
}
DERNode2.prototype = Object.create(Node.prototype, {
  constructor: {
    value: DERNode2,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DERNode2.prototype._peekTag = function peekTag(buffer, tag2, any2) {
  if (buffer.isEmpty()) {
    return false;
  }
  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag2 + '"');
  if (buffer.isError(decodedTag)) {
    return decodedTag;
  }
  buffer.restore(state);
  return decodedTag.tag === tag2 || decodedTag.tagStr === tag2 || decodedTag.tagStr + "of" === tag2 || any2;
};
DERNode2.prototype._decodeTag = function decodeTag(buffer, tag2, any2) {
  const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag2 + '"');
  if (buffer.isError(decodedTag)) {
    return decodedTag;
  }
  let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag2 + '"');
  if (buffer.isError(len)) {
    return len;
  }
  if (!any2 && decodedTag.tag !== tag2 && decodedTag.tagStr !== tag2 && decodedTag.tagStr + "of" !== tag2) {
    return buffer.error('Failed to match tag: "' + tag2 + '"');
  }
  if (decodedTag.primitive || len !== null) {
    return buffer.skip(len, 'Failed to match body of: "' + tag2 + '"');
  }
  const state = buffer.save();
  const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res)) {
    return res;
  }
  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag2 + '"');
};
DERNode2.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail3) {
  for (; ; ) {
    const tag2 = derDecodeTag(buffer, fail3);
    if (buffer.isError(tag2)) {
      return tag2;
    }
    const len = derDecodeLen(buffer, tag2.primitive, fail3);
    if (buffer.isError(len)) {
      return len;
    }
    let res;
    if (tag2.primitive || len !== null) {
      res = buffer.skip(len);
    } else {
      res = this._skipUntilEnd(buffer, fail3);
    }
    if (buffer.isError(res)) {
      return res;
    }
    if (tag2.tagStr === "end") {
      break;
    }
  }
};
DERNode2.prototype._decodeList = function decodeList(buffer, _tag, decoder2, options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, "end");
    if (buffer.isError(possibleEnd)) {
      return possibleEnd;
    }
    const res = decoder2.decode(buffer, "der", options);
    if (buffer.isError(res) && possibleEnd) {
      break;
    }
    result.push(res);
  }
  return result;
};
DERNode2.prototype._decodeStr = function decodeStr(buffer, tag2) {
  if (tag2 === "bitstr") {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused)) {
      return unused;
    }
    return { unused, data: buffer.raw() };
  } else if (tag2 === "bmpstr") {
    const raw2 = buffer.raw();
    if (raw2.length % 2 === 1) {
      return buffer.error("Decoding of string type: bmpstr length mismatch");
    }
    let str = "";
    for (let i = 0; i < raw2.length / 2; i++) {
      str += String.fromCharCode(raw2.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag2 === "numstr") {
    const numstr = buffer.raw().toString("ascii");
    if (!this._isNumstr(numstr)) {
      return buffer.error("Decoding of string type: numstr unsupported characters");
    }
    return numstr;
  } else if (tag2 === "octstr") {
    return buffer.raw();
  } else if (tag2 === "objDesc") {
    return buffer.raw();
  } else if (tag2 === "printstr") {
    const printstr = buffer.raw().toString("ascii");
    if (!this._isPrintstr(printstr)) {
      return buffer.error("Decoding of string type: printstr unsupported characters");
    }
    return printstr;
  } else if (/str$/.test(tag2)) {
    return buffer.raw().toString();
  } else {
    return buffer.error("Decoding of string type: " + tag2 + " unsupported");
  }
};
DERNode2.prototype._decodeObjid = function decodeObjid(buffer, values, relative7) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 127;
    if ((subident & 128) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 128) {
    identifiers.push(ident);
  }
  const first = identifiers[0] / 40 | 0;
  const second = identifiers[0] % 40;
  if (relative7) {
    result = identifiers;
  } else {
    result = [first, second].concat(identifiers.slice(1));
  }
  if (values) {
    let tmp = values[result.join(" ")];
    if (tmp === void 0) {
      tmp = values[result.join(".")];
    }
    if (tmp !== void 0) {
      result = tmp;
    }
  }
  return result;
};
DERNode2.prototype._decodeTime = function decodeTime(buffer, tag2) {
  const str = buffer.raw().toString();
  let year2;
  let mon;
  let day2;
  let hour2;
  let min4;
  let sec;
  if (tag2 === "gentime") {
    year2 = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day2 = str.slice(6, 8) | 0;
    hour2 = str.slice(8, 10) | 0;
    min4 = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag2 === "utctime") {
    year2 = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day2 = str.slice(4, 6) | 0;
    hour2 = str.slice(6, 8) | 0;
    min4 = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year2 < 70) {
      year2 = 2e3 + year2;
    } else {
      year2 = 1900 + year2;
    }
  } else {
    return buffer.error("Decoding " + tag2 + " time is not supported yet");
  }
  return Date.UTC(year2, mon - 1, day2, hour2, min4, sec, 0);
};
DERNode2.prototype._decodeNull = function decodeNull() {
  return null;
};
DERNode2.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res)) {
    return res;
  } else {
    return res !== 0;
  }
};
DERNode2.prototype._decodeInt = function decodeInt(buffer, values) {
  const raw2 = buffer.raw();
  let res = new bn_default(raw2);
  if (values) {
    res = values[res.toString(10)] || res;
  }
  return res;
};
DERNode2.prototype._use = function use3(entity, obj2) {
  if (typeof entity === "function") {
    entity = entity(obj2);
  }
  return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail3) {
  let tag2 = buf.readUInt8(fail3);
  if (buf.isError(tag2)) {
    return tag2;
  }
  const cls = tagClass[tag2 >> 6];
  const primitive = (tag2 & 32) === 0;
  if ((tag2 & 31) === 31) {
    let oct = tag2;
    tag2 = 0;
    while ((oct & 128) === 128) {
      oct = buf.readUInt8(fail3);
      if (buf.isError(oct)) {
        return oct;
      }
      tag2 <<= 7;
      tag2 |= oct & 127;
    }
  } else {
    tag2 &= 31;
  }
  const tagStr = tag[tag2];
  return {
    cls,
    primitive,
    tag: tag2,
    tagStr
  };
}
function derDecodeLen(buf, primitive, fail3) {
  let len = buf.readUInt8(fail3);
  if (buf.isError(len)) {
    return len;
  }
  if (!primitive && len === 128) {
    return null;
  }
  if ((len & 128) === 0) {
    return len;
  }
  const num = len & 127;
  if (num > 4) {
    return buf.error("length octect is too long");
  }
  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail3);
    if (buf.isError(j)) {
      return j;
    }
    len |= j;
  }
  return len;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/decoders/pem.js
function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
  constructor: {
    value: PEMDecoder,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
PEMDecoder.prototype.decode = function decode5(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);
  const label = options.label.toUpperCase();
  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null) {
      continue;
    }
    if (match[2] !== label) {
      continue;
    }
    if (start === -1) {
      if (match[1] !== "BEGIN") {
        break;
      }
      start = i;
    } else {
      if (match[1] !== "END") {
        break;
      }
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1) {
    throw new Error("PEM section not found for: " + label);
  }
  const base64 = lines.slice(start + 1, end).join("");
  base64.replace(/[^a-z0-9+/=]+/gi, "");
  const input = Buffer3.from(base64, "base64");
  return DERDecoder.prototype.decode.call(this, input, options);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/mod.js
var base = {
  DecoderBuffer,
  EncoderBuffer,
  Node,
  Reporter
};
var encoders = { der: DEREncoder, pem: PEMEncoder };
var decoders = { der: DERDecoder, pem: PEMDecoder };
var constants4 = { der: der_exports };
function define(name, body) {
  return new Entity(name, body);
}
function Entity(name, body) {
  this.name = name;
  this.body = body;
  this.decoders = {};
  this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;
  function Generated(entity) {
    this._initNamed(entity, name);
  }
  Generated.prototype = Object.create(Base.prototype, {
    constructor: {
      value: Generated,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Generated.prototype._initNamed = function _initNamed(entity, name2) {
    Base.call(this, entity, name2);
  };
  return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || "der";
  if (!this.decoders.hasOwnProperty(enc)) {
    this.decoders[enc] = this._createNamed(decoders[enc]);
  }
  return this.decoders[enc];
};
Entity.prototype.decode = function decode6(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || "der";
  if (!this.encoders.hasOwnProperty(enc)) {
    this.encoders[enc] = this._createNamed(encoders[enc]);
  }
  return this.encoders[enc];
};
Entity.prototype.encode = function encode8(data, enc, reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};
var mod_default = {
  base,
  bignum: bn_default,
  constants: constants4,
  decoders,
  define,
  encoders
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/certificate.js
var Time = define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = define("AttributeTypeValue", function() {
  this.seq().obj(this.key("type").objid(), this.key("value").any());
});
var AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
var SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
var RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
});
var RDNSequence = define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
});
var Name = define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = define("Validity", function() {
  this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
var Extension = define("Extension", function() {
  this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
var TBSCertificate = define("TBSCertificate", function() {
  this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
var X509Certificate = define("X509Certificate", function() {
  this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
var certificate_default = X509Certificate;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/asn1.js
var RSAPrivateKey = mod_default.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
var RSAPublicKey = mod_default.define("RSAPublicKey", function() {
  this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
var PublicKey = mod_default.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier2), this.key("subjectPublicKey").bitstr());
});
var AlgorithmIdentifier2 = mod_default.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
var PrivateKey = mod_default.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier2), this.key("subjectPrivateKey").octstr());
});
var EncryptedPrivateKey = mod_default.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
var DSAPrivateKey = mod_default.define("DSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
var DSAparam = mod_default.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = mod_default.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
var ECParameters = mod_default.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
var signature = mod_default.define("signature", function() {
  this.seq().obj(this.key("r").int(), this.key("s").int());
});

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/fix_proc.js
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function fix_proc_default(okey, password) {
  const key2 = okey.toString();
  const match = key2.match(findProc);
  let decrypted;
  if (!match) {
    const match2 = key2.match(fullRegex);
    decrypted = Buffer3.from(match2[2].replace(/[\r\n]/g, ""), "base64");
  } else {
    const suite = "aes" + match[1];
    const iv = Buffer3.from(match[2], "hex");
    const cipherText = Buffer3.from(match[3].replace(/[\r\n]/g, ""), "base64");
    const cipherKey = evp_bytes_to_key_default(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    const out = [];
    const cipher = createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer3.concat(out);
  }
  const tag2 = key2.match(startRegex)[1];
  return {
    tag: tag2,
    data: decrypted
  };
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/mod.js
var aesid = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
  let password;
  if (typeof buffer === "object" && !Buffer3.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === "string") {
    buffer = Buffer3.from(buffer);
  }
  const stripped = fix_proc_default(buffer, password);
  const type = stripped.tag;
  let data = stripped.data;
  let subtype, ndata;
  switch (type) {
    case "CERTIFICATE":
      ndata = certificate_default.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      if (!ndata) {
        ndata = PublicKey.decode(data, "der");
      }
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: "ec",
            data: ndata
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
          return {
            type: "dsa",
            data: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "ENCRYPTED PRIVATE KEY":
      data = EncryptedPrivateKey.decode(data, "der");
      data = decrypt3(data, password);
    case "PRIVATE KEY":
      ndata = PrivateKey.decode(data, "der");
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: ndata.algorithm.curve,
            privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
          return {
            type: "dsa",
            params: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "RSA PUBLIC KEY":
      return RSAPublicKey.decode(data, "der");
    case "RSA PRIVATE KEY":
      return RSAPrivateKey.decode(data, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: DSAPrivateKey.decode(data, "der")
      };
    case "EC PRIVATE KEY":
      data = ECPrivateKey.decode(data, "der");
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default:
      throw new Error("unknown key type " + type);
  }
}
var mod_default2 = parseKeys;
parseKeys.signature = signature;
function decrypt3(data, password) {
  const salt = data.algorithm.decrypt.kde.kdeparams.salt;
  const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
  const iv = data.algorithm.decrypt.cipher.iv;
  const cipherText = data.subjectPrivateKey;
  const keylen = parseInt(algo.split("-")[1], 10) / 8;
  const key2 = pbkdf2Sync(password, salt, iters, keylen, "sha1");
  const cipher = createDecipheriv(algo, key2, iv);
  const out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer3.concat(out);
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/randombytes.ts
var MAX_BYTES = 65536;
var MAX_UINT322 = 4294967295;
function randomBytes2(size, cb) {
  if (size > MAX_UINT322) {
    throw new RangeError("requested too many random bytes");
  }
  const bytes = Buffer3.allocUnsafe(size);
  if (size > 0) {
    if (size > MAX_BYTES) {
      for (let generated = 0; generated < size; generated += MAX_BYTES) {
        globalThis.crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
      }
    } else {
      globalThis.crypto.getRandomValues(bytes);
    }
  }
  if (typeof cb === "function") {
    return nextTick2(function() {
      cb(null, bytes);
    });
  }
  return bytes;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/mgf.js
function mgf_default(seed, len) {
  let t = Buffer3.alloc(0);
  let i = 0;
  let c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer3.concat([t, createHash("sha1").update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
}
function i2ops(c) {
  const out = Buffer3.allocUnsafe(4);
  out.writeUInt32BE(c, 0);
  return out;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/xor.js
function xor3(a, b) {
  const len = a.length;
  let i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/with_public.js
function withPublic(paddedMsg, key2) {
  return Buffer3.from(paddedMsg.toRed(BN.mont(key2.modulus)).redPow(new BN(key2.publicExponent)).fromRed().toArray());
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_rsa.js
function blind(priv) {
  const r = getr(priv);
  const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
  return { blinder, unblinder: r.invm(priv.modulus) };
}
function getr(priv) {
  const len = priv.modulus.byteLength();
  let r;
  do {
    r = new BN(randomBytes2(len));
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
  return r;
}
function crt(msg, priv) {
  const blinds = blind(priv);
  const len = priv.modulus.byteLength();
  const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
  const c1 = blinded.toRed(BN.mont(priv.prime1));
  const c2 = blinded.toRed(BN.mont(priv.prime2));
  const qinv = priv.coefficient;
  const p = priv.prime1;
  const q = priv.prime2;
  const m12 = c1.redPow(priv.exponent1).fromRed();
  const m2 = c2.redPow(priv.exponent2).fromRed();
  const h = m12.isub(m2).imul(qinv).umod(p).imul(q);
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer3, "be", len);
}
crt.getr = getr;
var browserify_rsa_default = crt;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/public_encrypt.js
function publicEncrypt(publicKey, msg, reverse2) {
  let padding;
  if (publicKey.padding) {
    padding = publicKey.padding;
  } else if (reverse2) {
    padding = 1;
  } else {
    padding = 4;
  }
  const key2 = mod_default2(publicKey);
  let paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key2, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key2, msg, reverse2);
  } else if (padding === 3) {
    paddedMsg = new BN(msg);
    if (paddedMsg.cmp(key2.modulus) >= 0) {
      throw new Error("data too long for modulus");
    }
  } else {
    throw new Error("unknown padding");
  }
  if (reverse2) {
    return browserify_rsa_default(paddedMsg, key2);
  } else {
    return withPublic(paddedMsg, key2);
  }
}
function oaep(key2, msg) {
  const k3 = key2.modulus.byteLength();
  const mLen = msg.length;
  const iHash = createHash("sha1").update(Buffer3.alloc(0)).digest();
  const hLen = iHash.length;
  const hLen2 = 2 * hLen;
  if (mLen > k3 - hLen2 - 2) {
    throw new Error("message too long");
  }
  const ps = Buffer3.alloc(k3 - mLen - hLen2 - 2);
  const dblen = k3 - hLen - 1;
  const seed = randomBytes2(hLen);
  const maskedDb = xor3(Buffer3.concat([iHash, ps, Buffer3.alloc(1, 1), msg], dblen), mgf_default(seed, dblen));
  const maskedSeed = xor3(seed, mgf_default(maskedDb, hLen));
  return new BN(Buffer3.concat([Buffer3.alloc(1), maskedSeed, maskedDb], k3));
}
function pkcs1(key2, msg, reverse2) {
  const mLen = msg.length;
  const k3 = key2.modulus.byteLength();
  if (mLen > k3 - 11) {
    throw new Error("message too long");
  }
  let ps;
  if (reverse2) {
    ps = Buffer3.alloc(k3 - mLen - 3, 255);
  } else {
    ps = nonZero(k3 - mLen - 3);
  }
  return new BN(Buffer3.concat([
    Buffer3.from([
      0,
      reverse2 ? 1 : 2
    ]),
    ps,
    Buffer3.alloc(1),
    msg
  ], k3));
}
function nonZero(len) {
  const out = Buffer3.allocUnsafe(len);
  let i = 0;
  let cache = randomBytes2(len * 2);
  let cur = 0;
  let num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes2(len * 2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/private_decrypt.js
function privateDecrypt(privateKey, enc, reverse2) {
  let padding;
  if (privateKey.padding) {
    padding = privateKey.padding;
  } else if (reverse2) {
    padding = 1;
  } else {
    padding = 4;
  }
  const key2 = mod_default2(privateKey);
  const k3 = key2.modulus.byteLength();
  if (enc.length > k3 || new BN(enc).cmp(key2.modulus) >= 0) {
    throw new Error("decryption error");
  }
  let msg;
  if (reverse2) {
    msg = withPublic(new BN(enc), key2);
  } else {
    msg = browserify_rsa_default(enc, key2);
  }
  const zBuffer = Buffer3.alloc(k3 - msg.length);
  msg = Buffer3.concat([zBuffer, msg], k3);
  if (padding === 4) {
    return oaep2(key2, msg);
  } else if (padding === 1) {
    return pkcs12(key2, msg, reverse2);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error("unknown padding");
  }
}
function oaep2(key2, msg) {
  const k3 = key2.modulus.byteLength();
  const iHash = createHash("sha1").update(Buffer3.alloc(0)).digest();
  const hLen = iHash.length;
  if (msg[0] !== 0) {
    throw new Error("decryption error");
  }
  const maskedSeed = msg.slice(1, hLen + 1);
  const maskedDb = msg.slice(hLen + 1);
  const seed = xor3(maskedSeed, mgf_default(maskedDb, hLen));
  const db = xor3(maskedDb, mgf_default(seed, k3 - hLen - 1));
  if (compare3(iHash, db.slice(0, hLen))) {
    throw new Error("decryption error");
  }
  let i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error("decryption error");
  }
  return db.slice(i);
}
function pkcs12(_key, msg, reverse2) {
  const p12 = msg.slice(0, 2);
  let i = 2;
  let status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  const ps = msg.slice(2, i - 1);
  if (p12.toString("hex") !== "0002" && !reverse2 || p12.toString("hex") !== "0001" && reverse2) {
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error("decryption error");
  }
  return msg.slice(i);
}
function compare3(a, b) {
  a = Buffer3.from(a);
  b = Buffer3.from(b);
  let dif = 0;
  let len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  let i = -1;
  while (++i < len) {
    dif += a[i] ^ b[i];
  }
  return dif;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/mod.js
function privateEncrypt(key2, buf) {
  return publicEncrypt(key2, buf, true);
}
function publicDecrypt(key2, buf) {
  return privateDecrypt(key2, buf, true);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/cipher.ts
var Cipheriv = class extends transform_default {
  constructor(_cipher, _key, _iv, _options) {
    super();
    notImplemented("crypto.Cipheriv");
  }
  final(_outputEncoding) {
    notImplemented("crypto.Cipheriv.prototype.final");
  }
  getAuthTag() {
    notImplemented("crypto.Cipheriv.prototype.getAuthTag");
  }
  setAAD(_buffer, _options) {
    notImplemented("crypto.Cipheriv.prototype.setAAD");
  }
  setAutoPadding(_autoPadding) {
    notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
  }
  update(_data, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.Cipheriv.prototype.update");
  }
};
var Decipheriv = class extends transform_default {
  constructor(_cipher, _key, _iv, _options) {
    super();
    notImplemented("crypto.Decipheriv");
  }
  final(_outputEncoding) {
    notImplemented("crypto.Decipheriv.prototype.final");
  }
  setAAD(_buffer, _options) {
    notImplemented("crypto.Decipheriv.prototype.setAAD");
  }
  setAuthTag(_buffer, _encoding) {
    notImplemented("crypto.Decipheriv.prototype.setAuthTag");
  }
  setAutoPadding(_autoPadding) {
    notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
  }
  update(_data, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.Decipheriv.prototype.update");
  }
};
function getCipherInfo(nameOrNid, options) {
  if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
    throw new ERR_INVALID_ARG_TYPE("nameOrNid", ["string", "number"], nameOrNid);
  }
  if (typeof nameOrNid === "number") {
    validateInt32(nameOrNid, "nameOrNid");
  }
  let keyLength, ivLength;
  if (options !== void 0) {
    validateObject(options, "options");
    ({ keyLength, ivLength } = options);
    if (keyLength !== void 0) {
      validateInt32(keyLength, "options.keyLength");
    }
    if (ivLength !== void 0) {
      validateInt32(ivLength, "options.ivLength");
    }
  }
  notImplemented("crypto.getCipherInfo");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/sig.ts
var Sign = class extends writable_default {
  constructor(algorithm, _options) {
    validateString(algorithm, "algorithm");
    super();
    notImplemented("crypto.Sign");
  }
  sign(_privateKey, _outputEncoding) {
    notImplemented("crypto.Sign.prototype.sign");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Sign.prototype.update");
  }
};
var Verify = class extends writable_default {
  constructor(algorithm, _options) {
    validateString(algorithm, "algorithm");
    super();
    notImplemented("crypto.Verify");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Sign.prototype.update");
  }
  verify(_object, _signature, _signatureEncoding) {
    notImplemented("crypto.Sign.prototype.sign");
  }
};
function signOneShot(_algorithm, _data, _key, _callback) {
  notImplemented("crypto.sign");
}
function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
  notImplemented("crypto.verify");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/x509.ts
var X509Certificate2 = class {
  constructor(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer3.from(buffer);
    }
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE("buffer", ["string", "Buffer", "TypedArray", "DataView"], buffer);
    }
    notImplemented("crypto.X509Certificate");
  }
  get ca() {
    notImplemented("crypto.X509Certificate.prototype.ca");
    return false;
  }
  checkEmail(_email, _options) {
    notImplemented("crypto.X509Certificate.prototype.checkEmail");
  }
  checkHost(_name, _options) {
    notImplemented("crypto.X509Certificate.prototype.checkHost");
  }
  checkIP(_ip) {
    notImplemented("crypto.X509Certificate.prototype.checkIP");
  }
  checkIssued(_otherCert) {
    notImplemented("crypto.X509Certificate.prototype.checkIssued");
  }
  checkPrivateKey(_privateKey) {
    notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
  }
  get fingerprint() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint");
    return "";
  }
  get fingerprint256() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint256");
    return "";
  }
  get fingerprint512() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint512");
    return "";
  }
  get infoAccess() {
    notImplemented("crypto.X509Certificate.prototype.infoAccess");
    return "";
  }
  get issuer() {
    notImplemented("crypto.X509Certificate.prototype.issuer");
    return "";
  }
  get issuerCertificate() {
    notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
    return {};
  }
  get keyUsage() {
    notImplemented("crypto.X509Certificate.prototype.keyUsage");
    return [];
  }
  get publicKey() {
    notImplemented("crypto.X509Certificate.prototype.publicKey");
    return {};
  }
  get raw() {
    notImplemented("crypto.X509Certificate.prototype.raw");
    return {};
  }
  get serialNumber() {
    notImplemented("crypto.X509Certificate.prototype.serialNumber");
    return "";
  }
  get subject() {
    notImplemented("crypto.X509Certificate.prototype.subject");
    return "";
  }
  get subjectAltName() {
    notImplemented("crypto.X509Certificate.prototype.subjectAltName");
    return "";
  }
  toJSON() {
    return this.toString();
  }
  toLegacyObject() {
    notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
  }
  toString() {
    notImplemented("crypto.X509Certificate.prototype.toString");
  }
  get validFrom() {
    notImplemented("crypto.X509Certificate.prototype.validFrom");
    return "";
  }
  get validTo() {
    notImplemented("crypto.X509Certificate.prototype.validTo");
    return "";
  }
  verify(_publicKey) {
    notImplemented("crypto.X509Certificate.prototype.verify");
  }
};

// deno:https://deno.land/std@0.147.0/node/internal/crypto/certificate.ts
var Certificate = class {
  static exportChallenge(_spkac, _encoding) {
    notImplemented("crypto.Certificate.exportChallenge");
  }
  static exportPublicKey(_spkac, _encoding) {
    notImplemented("crypto.Certificate.exportPublicKey");
  }
  static verifySpkac(_spkac, _encoding) {
    notImplemented("crypto.Certificate.verifySpkac");
  }
};
var certificate_default2 = Certificate;

// deno:https://deno.land/std@0.147.0/node/crypto.ts
var webcrypto = globalThis.crypto;
var fipsForced = getOptionValue("--force-fips");
function createCipheriv(cipher, key2, iv, options) {
  return new Cipheriv(cipher, key2, iv, options);
}
function createDecipheriv2(algorithm, key2, iv, options) {
  return new Decipheriv(algorithm, key2, iv, options);
}
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
  return new DiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding);
}
function createDiffieHellmanGroup(name) {
  return new DiffieHellmanGroup(name);
}
function createECDH(curve) {
  return new ECDH(curve);
}
function createHmac(hmac, key2, options) {
  return new Hmac(hmac, key2, options);
}
function createSign2(algorithm, options) {
  return new Sign(algorithm, options);
}
function createVerify(algorithm, options) {
  return new Verify(algorithm, options);
}
function setFipsForced(val) {
  if (val) {
    return;
  }
  throw new ERR_CRYPTO_FIPS_FORCED();
}
function getFipsForced() {
  return 1;
}
Object.defineProperty(crypto, "defaultCipherList", {
  value: getOptionValue("--tls-cipher-list")
});
var getDiffieHellman = createDiffieHellmanGroup;
var getFips = fipsForced ? getFipsForced : getFipsCrypto;
var setFips = fipsForced ? setFipsForced : setFipsCrypto;
var sign = signOneShot;
var verify = verifyOneShot;
var crypto_default = {
  Certificate: certificate_default2,
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants: crypto,
  createCipheriv,
  createDecipheriv: createDecipheriv2,
  createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  createSign: createSign2,
  createVerify,
  Decipheriv,
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,
  getDiffieHellman,
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,
  KeyObject,
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,
  Sign,
  sign,
  timingSafeEqual,
  Verify,
  verify,
  webcrypto,
  X509Certificate: X509Certificate2
};

// deno:https://esm.sh/v86/node_buffer.js
var yr = Object.create;
var N = Object.defineProperty;
var wr = Object.getOwnPropertyDescriptor;
var xr = Object.getOwnPropertyNames;
var Br = Object.getPrototypeOf;
var Er = Object.prototype.hasOwnProperty;
var dr = (i) => N(i, "__esModule", { value: true });
var k = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports);
var gr = (i, r, t) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n of xr(r))
      !Er.call(i, n) && n !== "default" && N(i, n, { get: () => r[n], enumerable: !(t = wr(r, n)) || t.enumerable });
  return i;
};
var H = (i) => gr(dr(N(i != null ? yr(Br(i)) : {}, "default", i && i.__esModule && "default" in i ? { get: () => i.default, enumerable: true } : { value: i, enumerable: true })), i);
var J = k((_) => {
  "use strict";
  _.byteLength = Ir;
  _.toByteArray = Ar;
  _.fromByteArray = Rr;
  var B = [], w = [], mr = typeof Uint8Array != "undefined" ? Uint8Array : Array, b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (m = 0, V = b.length; m < V; ++m)
    B[m] = b[m], w[b.charCodeAt(m)] = m;
  var m, V;
  w["-".charCodeAt(0)] = 62;
  w["_".charCodeAt(0)] = 63;
  function z(i) {
    var r = i.length;
    if (r % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = i.indexOf("=");
    t === -1 && (t = r);
    var n = t === r ? 0 : 4 - t % 4;
    return [t, n];
  }
  function Ir(i) {
    var r = z(i), t = r[0], n = r[1];
    return (t + n) * 3 / 4 - n;
  }
  function Fr(i, r, t) {
    return (r + t) * 3 / 4 - t;
  }
  function Ar(i) {
    var r, t = z(i), n = t[0], e = t[1], o = new mr(Fr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
    for (c = 0; c < f; c += 4)
      r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
    return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
  }
  function Ur(i) {
    return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
  }
  function Tr(i, r, t) {
    for (var n, e = [], o = r; o < t; o += 3)
      n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Ur(n));
    return e.join("");
  }
  function Rr(i) {
    for (var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n; u < f; u += o)
      e.push(Tr(i, u, u + o > f ? f : u + o));
    return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
  }
});
var K = k((D) => {
  D.read = function(i, r, t, n, e) {
    var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
    for (p += F, o = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o = o * 256 + i[r + p], p += F, s -= 8)
      ;
    for (u = o & (1 << -s) - 1, o >>= -s, s += n; s > 0; u = u * 256 + i[r + p], p += F, s -= 8)
      ;
    if (o === 0)
      o = 1 - l;
    else {
      if (o === c)
        return u ? NaN : (x ? -1 : 1) * (1 / 0);
      u = u + Math.pow(2, n), o = o - l;
    }
    return (x ? -1 : 1) * u * Math.pow(2, o - n);
  };
  D.write = function(i, r, t, n, e, o) {
    var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, M = n ? 1 : -1, ar = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += M, f /= 256, e -= 8)
      ;
    for (u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += M, u /= 256, l -= 8)
      ;
    i[t + x - M] |= ar * 128;
  };
});
var X = k((R2) => {
  "use strict";
  var $ = J(), A = K(), Z = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  R2.Buffer = h;
  R2.SlowBuffer = Nr;
  R2.INSPECT_MAX_BYTES = 50;
  var S = 2147483647;
  R2.kMaxLength = S;
  h.TYPED_ARRAY_SUPPORT = Cr();
  !h.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Cr() {
    try {
      let i = new Uint8Array(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
    } catch (i) {
      return false;
    }
  }
  Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
    if (!!h.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
    if (!!h.isBuffer(this))
      return this.byteOffset;
  } });
  function d(i) {
    if (i > S)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    let r = new Uint8Array(i);
    return Object.setPrototypeOf(r, h.prototype), r;
  }
  function h(i, r, t) {
    if (typeof i == "number") {
      if (typeof r == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return P(i);
    }
    return Q(i, r, t);
  }
  h.poolSize = 8192;
  function Q(i, r, t) {
    if (typeof i == "string")
      return Sr(i, r);
    if (ArrayBuffer.isView(i))
      return Lr(i);
    if (i == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer)))
      return G2(i, r, t);
    if (typeof i == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n = i.valueOf && i.valueOf();
    if (n != null && n !== i)
      return h.from(n, r, t);
    let e = Mr(i);
    if (e)
      return e;
    if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return h.from(i[Symbol.toPrimitive]("string"), r, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
  }
  h.from = function(i, r, t) {
    return Q(i, r, t);
  };
  Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(h, Uint8Array);
  function v(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function _r(i, r, t) {
    return v(i), i <= 0 ? d(i) : r !== void 0 ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
  }
  h.alloc = function(i, r, t) {
    return _r(i, r, t);
  };
  function P(i) {
    return v(i), d(i < 0 ? 0 : Y(i) | 0);
  }
  h.allocUnsafe = function(i) {
    return P(i);
  };
  h.allocUnsafeSlow = function(i) {
    return P(i);
  };
  function Sr(i, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    let t = rr(i, r) | 0, n = d(t), e = n.write(i, r);
    return e !== t && (n = n.slice(0, e)), n;
  }
  function O(i) {
    let r = i.length < 0 ? 0 : Y(i.length) | 0, t = d(r);
    for (let n = 0; n < r; n += 1)
      t[n] = i[n] & 255;
    return t;
  }
  function Lr(i) {
    if (E(i, Uint8Array)) {
      let r = new Uint8Array(i);
      return G2(r.buffer, r.byteOffset, r.byteLength);
    }
    return O(i);
  }
  function G2(i, r, t) {
    if (r < 0 || i.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < r + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
  }
  function Mr(i) {
    if (h.isBuffer(i)) {
      let r = Y(i.length) | 0, t = d(r);
      return t.length === 0 || i.copy(t, 0, 0, r), t;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || j(i.length) ? d(0) : O(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return O(i.data);
  }
  function Y(i) {
    if (i >= S)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S.toString(16) + " bytes");
    return i | 0;
  }
  function Nr(i) {
    return +i != i && (i = 0), h.alloc(+i);
  }
  h.isBuffer = function(r) {
    return r != null && r._isBuffer === true && r !== h.prototype;
  };
  h.compare = function(r, t) {
    if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r === t)
      return 0;
    let n = r.length, e = t.length;
    for (let o = 0, u = Math.min(n, e); o < u; ++o)
      if (r[o] !== t[o]) {
        n = r[o], e = t[o];
        break;
      }
    return n < e ? -1 : e < n ? 1 : 0;
  };
  h.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  h.concat = function(r, t) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return h.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < r.length; ++n)
        t += r[n].length;
    let e = h.allocUnsafe(t), o = 0;
    for (n = 0; n < r.length; ++n) {
      let u = r[n];
      if (E(u, Uint8Array))
        o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
      else if (h.isBuffer(u))
        u.copy(e, o);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      o += u.length;
    }
    return e;
  };
  function rr(i, r) {
    if (h.isBuffer(i))
      return i.length;
    if (ArrayBuffer.isView(i) || E(i, ArrayBuffer))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
    let t = i.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && t === 0)
      return 0;
    let e = false;
    for (; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return W(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return lr(i).length;
        default:
          if (e)
            return n ? -1 : W(i).length;
          r = ("" + r).toLowerCase(), e = true;
      }
  }
  h.byteLength = rr;
  function kr(i, r, t) {
    let n = false;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return jr(this, r, t);
        case "utf8":
        case "utf-8":
          return nr(this, r, t);
        case "ascii":
          return qr(this, r, t);
        case "latin1":
        case "binary":
          return Wr(this, r, t);
        case "base64":
          return Gr(this, r, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Xr(this, r, t);
        default:
          if (n)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), n = true;
      }
  }
  h.prototype._isBuffer = true;
  function I(i, r, t) {
    let n = i[r];
    i[r] = i[t], i[t] = n;
  }
  h.prototype.swap16 = function() {
    let r = this.length;
    if (r % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < r; t += 2)
      I(this, t, t + 1);
    return this;
  };
  h.prototype.swap32 = function() {
    let r = this.length;
    if (r % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < r; t += 4)
      I(this, t, t + 3), I(this, t + 1, t + 2);
    return this;
  };
  h.prototype.swap64 = function() {
    let r = this.length;
    if (r % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < r; t += 8)
      I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
    return this;
  };
  h.prototype.toString = function() {
    let r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? nr(this, 0, r) : kr.apply(this, arguments);
  };
  h.prototype.toLocaleString = h.prototype.toString;
  h.prototype.equals = function(r) {
    if (!h.isBuffer(r))
      throw new TypeError("Argument must be a Buffer");
    return this === r ? true : h.compare(this, r) === 0;
  };
  h.prototype.inspect = function() {
    let r = "", t = R2.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
  };
  Z && (h.prototype[Z] = h.prototype.inspect);
  h.prototype.compare = function(r, t, n, e, o) {
    if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
    if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o === void 0 && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length)
      throw new RangeError("out of range index");
    if (e >= o && t >= n)
      return 0;
    if (e >= o)
      return -1;
    if (t >= n)
      return 1;
    if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r)
      return 0;
    let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
    for (let p = 0; p < c; ++p)
      if (l[p] !== s[p]) {
        u = l[p], f = s[p];
        break;
      }
    return u < f ? -1 : f < u ? 1 : 0;
  };
  function tr(i, r, t, n, e) {
    if (i.length === 0)
      return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, j(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
      if (e)
        return -1;
      t = i.length - 1;
    } else if (t < 0)
      if (e)
        t = 0;
      else
        return -1;
    if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r))
      return r.length === 0 ? -1 : ir(i, r, t, n, e);
    if (typeof r == "number")
      return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir(i, [r], t, n, e);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ir(i, r, t, n, e) {
    let o = 1, u = i.length, f = r.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (i.length < 2 || r.length < 2)
        return -1;
      o = 2, u /= 2, f /= 2, t /= 2;
    }
    function c(s, p) {
      return o === 1 ? s[p] : s.readUInt16BE(p * o);
    }
    let l;
    if (e) {
      let s = -1;
      for (l = t; l < u; l++)
        if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
          if (s === -1 && (s = l), l - s + 1 === f)
            return s * o;
        } else
          s !== -1 && (l -= l - s), s = -1;
    } else
      for (t + f > u && (t = u - f), l = t; l >= 0; l--) {
        let s = true;
        for (let p = 0; p < f; p++)
          if (c(i, l + p) !== c(r, p)) {
            s = false;
            break;
          }
        if (s)
          return l;
      }
    return -1;
  }
  h.prototype.includes = function(r, t, n) {
    return this.indexOf(r, t, n) !== -1;
  };
  h.prototype.indexOf = function(r, t, n) {
    return tr(this, r, t, n, true);
  };
  h.prototype.lastIndexOf = function(r, t, n) {
    return tr(this, r, t, n, false);
  };
  function br(i, r, t, n) {
    t = Number(t) || 0;
    let e = i.length - t;
    n ? (n = Number(n), n > e && (n = e)) : n = e;
    let o = r.length;
    n > o / 2 && (n = o / 2);
    let u;
    for (u = 0; u < n; ++u) {
      let f = parseInt(r.substr(u * 2, 2), 16);
      if (j(f))
        return u;
      i[t + u] = f;
    }
    return u;
  }
  function Dr(i, r, t, n) {
    return L(W(r, i.length - t), i, t, n);
  }
  function $r(i, r, t, n) {
    return L(Jr(r), i, t, n);
  }
  function Pr(i, r, t, n) {
    return L(lr(r), i, t, n);
  }
  function Or(i, r, t, n) {
    return L(Kr(r, i.length - t), i, t, n);
  }
  h.prototype.write = function(r, t, n, e) {
    if (t === void 0)
      e = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string")
      e = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let o = this.length - t;
    if ((n === void 0 || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    e || (e = "utf8");
    let u = false;
    for (; ; )
      switch (e) {
        case "hex":
          return br(this, r, t, n);
        case "utf8":
        case "utf-8":
          return Dr(this, r, t, n);
        case "ascii":
        case "latin1":
        case "binary":
          return $r(this, r, t, n);
        case "base64":
          return Pr(this, r, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Or(this, r, t, n);
        default:
          if (u)
            throw new TypeError("Unknown encoding: " + e);
          e = ("" + e).toLowerCase(), u = true;
      }
  };
  h.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Gr(i, r, t) {
    return r === 0 && t === i.length ? $.fromByteArray(i) : $.fromByteArray(i.slice(r, t));
  }
  function nr(i, r, t) {
    t = Math.min(i.length, t);
    let n = [], e = r;
    for (; e < t; ) {
      let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
      if (e + f <= t) {
        let c, l, s, p;
        switch (f) {
          case 1:
            o < 128 && (u = o);
            break;
          case 2:
            c = i[e + 1], (c & 192) == 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
            break;
          case 3:
            c = i[e + 1], l = i[e + 2], (c & 192) == 128 && (l & 192) == 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
            break;
          case 4:
            c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) == 128 && (l & 192) == 128 && (s & 192) == 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
        }
      }
      u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
    }
    return Yr(n);
  }
  var er = 4096;
  function Yr(i) {
    let r = i.length;
    if (r <= er)
      return String.fromCharCode.apply(String, i);
    let t = "", n = 0;
    for (; n < r; )
      t += String.fromCharCode.apply(String, i.slice(n, n += er));
    return t;
  }
  function qr(i, r, t) {
    let n = "";
    t = Math.min(i.length, t);
    for (let e = r; e < t; ++e)
      n += String.fromCharCode(i[e] & 127);
    return n;
  }
  function Wr(i, r, t) {
    let n = "";
    t = Math.min(i.length, t);
    for (let e = r; e < t; ++e)
      n += String.fromCharCode(i[e]);
    return n;
  }
  function jr(i, r, t) {
    let n = i.length;
    (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
    let e = "";
    for (let o = r; o < t; ++o)
      e += Zr[i[o]];
    return e;
  }
  function Xr(i, r, t) {
    let n = i.slice(r, t), e = "";
    for (let o = 0; o < n.length - 1; o += 2)
      e += String.fromCharCode(n[o] + n[o + 1] * 256);
    return e;
  }
  h.prototype.slice = function(r, t) {
    let n = this.length;
    r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
    let e = this.subarray(r, t);
    return Object.setPrototypeOf(e, h.prototype), e;
  };
  function a(i, r, t) {
    if (i % 1 != 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + r > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = this[r], o = 1, u = 0;
    for (; ++u < t && (o *= 256); )
      e += this[r + u] * o;
    return e;
  };
  h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = this[r + --t], o = 1;
    for (; t > 0 && (o *= 256); )
      e += this[r + --t] * o;
    return e;
  };
  h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
    return r = r >>> 0, t || a(r, 1, this.length), this[r];
  };
  h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
    return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
  };
  h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
    return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
  };
  h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  };
  h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  };
  h.prototype.readBigUInt64LE = g(function(r) {
    r = r >>> 0, T(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
    return BigInt(e) + (BigInt(o) << BigInt(32));
  });
  h.prototype.readBigUInt64BE = g(function(r) {
    r = r >>> 0, T(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
    return (BigInt(e) << BigInt(32)) + BigInt(o);
  });
  h.prototype.readIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = this[r], o = 1, u = 0;
    for (; ++u < t && (o *= 256); )
      e += this[r + u] * o;
    return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
  };
  h.prototype.readIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = t, o = 1, u = this[r + --e];
    for (; e > 0 && (o *= 256); )
      u += this[r + --e] * o;
    return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
  };
  h.prototype.readInt8 = function(r, t) {
    return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  };
  h.prototype.readInt16LE = function(r, t) {
    r = r >>> 0, t || a(r, 2, this.length);
    let n = this[r] | this[r + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  h.prototype.readInt16BE = function(r, t) {
    r = r >>> 0, t || a(r, 2, this.length);
    let n = this[r + 1] | this[r] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  h.prototype.readInt32LE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  };
  h.prototype.readInt32BE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  };
  h.prototype.readBigInt64LE = g(function(r) {
    r = r >>> 0, T(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
    return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  });
  h.prototype.readBigInt64BE = g(function(r) {
    r = r >>> 0, T(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
  });
  h.prototype.readFloatLE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), A.read(this, r, true, 23, 4);
  };
  h.prototype.readFloatBE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), A.read(this, r, false, 23, 4);
  };
  h.prototype.readDoubleLE = function(r, t) {
    return r = r >>> 0, t || a(r, 8, this.length), A.read(this, r, true, 52, 8);
  };
  h.prototype.readDoubleBE = function(r, t) {
    return r = r >>> 0, t || a(r, 8, this.length), A.read(this, r, false, 52, 8);
  };
  function y(i, r, t, n, e, o) {
    if (!h.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > e || r < o)
      throw new RangeError('"value" argument is out of bounds');
    if (t + n > i.length)
      throw new RangeError("Index out of range");
  }
  h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
      let f = Math.pow(2, 8 * n) - 1;
      y(this, r, t, n, f, 0);
    }
    let o = 1, u = 0;
    for (this[t] = r & 255; ++u < n && (o *= 256); )
      this[t + u] = r / o & 255;
    return t + n;
  };
  h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
      let f = Math.pow(2, 8 * n) - 1;
      y(this, r, t, n, f, 0);
    }
    let o = n - 1, u = 1;
    for (this[t + o] = r & 255; --o >= 0 && (u *= 256); )
      this[t + o] = r / u & 255;
    return t + n;
  };
  h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
  };
  h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
  };
  h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  function or2(i, r, t, n, e) {
    sr(r, n, e, i, t, 7);
    let o = Number(r & BigInt(4294967295));
    i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
    let u = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
  }
  function ur(i, r, t, n, e) {
    sr(r, n, e, i, t, 7);
    let o = Number(r & BigInt(4294967295));
    i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
    let u = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
  }
  h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
    return or2(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
    return ur(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  h.prototype.writeIntLE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, !e) {
      let c = Math.pow(2, 8 * n - 1);
      y(this, r, t, n, c - 1, -c);
    }
    let o = 0, u = 1, f = 0;
    for (this[t] = r & 255; ++o < n && (u *= 256); )
      r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
    return t + n;
  };
  h.prototype.writeIntBE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, !e) {
      let c = Math.pow(2, 8 * n - 1);
      y(this, r, t, n, c - 1, -c);
    }
    let o = n - 1, u = 1, f = 0;
    for (this[t + o] = r & 255; --o >= 0 && (u *= 256); )
      r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
    return t + n;
  };
  h.prototype.writeInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
  };
  h.prototype.writeInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  h.prototype.writeInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  h.prototype.writeInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
  };
  h.prototype.writeInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  h.prototype.writeBigInt64LE = g(function(r, t = 0) {
    return or2(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  h.prototype.writeBigInt64BE = g(function(r, t = 0) {
    return ur(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function hr(i, r, t, n, e, o) {
    if (t + n > i.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function fr(i, r, t, n, e) {
    return r = +r, t = t >>> 0, e || hr(i, r, t, 4, 34028234663852886e22, -34028234663852886e22), A.write(i, r, t, n, 23, 4), t + 4;
  }
  h.prototype.writeFloatLE = function(r, t, n) {
    return fr(this, r, t, true, n);
  };
  h.prototype.writeFloatBE = function(r, t, n) {
    return fr(this, r, t, false, n);
  };
  function cr(i, r, t, n, e) {
    return r = +r, t = t >>> 0, e || hr(i, r, t, 8, 17976931348623157e292, -17976931348623157e292), A.write(i, r, t, n, 52, 8), t + 8;
  }
  h.prototype.writeDoubleLE = function(r, t, n) {
    return cr(this, r, t, true, n);
  };
  h.prototype.writeDoubleBE = function(r, t, n) {
    return cr(this, r, t, false, n);
  };
  h.prototype.copy = function(r, t, n, e) {
    if (!h.isBuffer(r))
      throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length)
      throw new RangeError("Index out of range");
    if (e < 0)
      throw new RangeError("sourceEnd out of bounds");
    e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
    let o = e - n;
    return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
  };
  h.prototype.fill = function(r, t, n, e) {
    if (typeof r == "string") {
      if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string")
        throw new TypeError("encoding must be a string");
      if (typeof e == "string" && !h.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      if (r.length === 1) {
        let u = r.charCodeAt(0);
        (e === "utf8" && u < 128 || e === "latin1") && (r = u);
      }
    } else
      typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (t < 0 || this.length < t || this.length < n)
      throw new RangeError("Out of range index");
    if (n <= t)
      return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
    let o;
    if (typeof r == "number")
      for (o = t; o < n; ++o)
        this[o] = r;
    else {
      let u = h.isBuffer(r) ? r : h.from(r, e), f = u.length;
      if (f === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (o = 0; o < n - t; ++o)
        this[o + t] = u[o % f];
    }
    return this;
  };
  var U = {};
  function q(i, r, t) {
    U[i] = class extends t {
      constructor() {
        super();
        Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(e) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e, writable: true });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  q("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
    return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  q("ERR_INVALID_ARG_TYPE", function(i, r) {
    return `The "${i}" argument must be of type number. Received type ${typeof r}`;
  }, TypeError);
  q("ERR_OUT_OF_RANGE", function(i, r, t) {
    let n = `The value of "${i}" is out of range.`, e = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = pr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = pr(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
  }, RangeError);
  function pr(i) {
    let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3)
      r = `_${i.slice(t - 3, t)}${r}`;
    return `${i.slice(0, t)}${r}`;
  }
  function Hr(i, r, t) {
    T(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && C(r, i.length - (t + 1));
  }
  function sr(i, r, t, n, e, o) {
    if (i > t || i < r) {
      let u = typeof r == "bigint" ? "n" : "", f;
      throw o > 3 ? r === 0 || r === BigInt(0) ? f = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f = `>= ${r}${u} and <= ${t}${u}`, new U.ERR_OUT_OF_RANGE("value", f, i);
    }
    Hr(n, e, o);
  }
  function T(i, r) {
    if (typeof i != "number")
      throw new U.ERR_INVALID_ARG_TYPE(r, "number", i);
  }
  function C(i, r, t) {
    throw Math.floor(i) !== i ? (T(i, t), new U.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new U.ERR_BUFFER_OUT_OF_BOUNDS() : new U.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
  }
  var Vr = /[^+/0-9A-Za-z-_]/g;
  function zr(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Vr, ""), i.length < 2)
      return "";
    for (; i.length % 4 != 0; )
      i = i + "=";
    return i;
  }
  function W(i, r) {
    r = r || 1 / 0;
    let t, n = i.length, e = null, o = [];
    for (let u = 0; u < n; ++u) {
      if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
        if (!e) {
          if (t > 56319) {
            (r -= 3) > -1 && o.push(239, 191, 189);
            continue;
          } else if (u + 1 === n) {
            (r -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          e = t;
          continue;
        }
        if (t < 56320) {
          (r -= 3) > -1 && o.push(239, 191, 189), e = t;
          continue;
        }
        t = (e - 55296 << 10 | t - 56320) + 65536;
      } else
        e && (r -= 3) > -1 && o.push(239, 191, 189);
      if (e = null, t < 128) {
        if ((r -= 1) < 0)
          break;
        o.push(t);
      } else if (t < 2048) {
        if ((r -= 2) < 0)
          break;
        o.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((r -= 3) < 0)
          break;
        o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((r -= 4) < 0)
          break;
        o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return o;
  }
  function Jr(i) {
    let r = [];
    for (let t = 0; t < i.length; ++t)
      r.push(i.charCodeAt(t) & 255);
    return r;
  }
  function Kr(i, r) {
    let t, n, e, o = [];
    for (let u = 0; u < i.length && !((r -= 2) < 0); ++u)
      t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
    return o;
  }
  function lr(i) {
    return $.toByteArray(zr(i));
  }
  function L(i, r, t, n) {
    let e;
    for (e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)
      r[e + t] = i[e];
    return e;
  }
  function E(i, r) {
    return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
  }
  function j(i) {
    return i !== i;
  }
  var Zr = function() {
    let i = "0123456789abcdef", r = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let n = t * 16;
      for (let e = 0; e < 16; ++e)
        r[n + e] = i[t] + i[e];
    }
    return r;
  }();
  function g(i) {
    return typeof BigInt == "undefined" ? Qr : i;
  }
  function Qr() {
    throw new Error("BigInt not supported");
  }
});
var vr = H(X());
var rt = H(X());
var { Buffer: ut, SlowBuffer: ht, INSPECT_MAX_BYTES: ft, kMaxLength: ct } = vr;
var export_default = rt.default;

// deno:https://esm.sh/v86/crypto-browserify@3.12.0/deno/crypto-browserify.bundle.js
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
var __setImmediate$ = (cb, ...args) => setTimeout(cb, 0, ...args);
var p1 = Object.create;
var Ls = Object.defineProperty;
var b1 = Object.getOwnPropertyDescriptor;
var m1 = Object.getOwnPropertyNames;
var g1 = Object.getPrototypeOf;
var y1 = Object.prototype.hasOwnProperty;
var Ke = ((t) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, { get: (e, r) => (typeof require != "undefined" ? require : e)[r] }) : t)(function(t) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t + '" is not supported');
});
var k2 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var _1 = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of m1(e))
      !y1.call(t, i) && i !== r && Ls(t, i, { get: () => e[i], enumerable: !(n = b1(e, i)) || n.enumerable });
  return t;
};
var Os = (t, e, r) => (r = t != null ? p1(g1(t)) : {}, _1(e || !t || !t.__esModule ? Ls(r, "default", { value: t, enumerable: true }) : r, t));
var Ae = k2((ya, Us) => {
  var Gf = export_default, er = Gf.Buffer;
  function zs(t, e) {
    for (var r in t)
      e[r] = t[r];
  }
  er.from && er.alloc && er.allocUnsafe && er.allocUnsafeSlow ? Us.exports = Gf : (zs(Gf, ya), ya.Buffer = ii);
  function ii(t, e, r) {
    return er(t, e, r);
  }
  ii.prototype = Object.create(er.prototype);
  zs(er, ii);
  ii.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return er(t, e, r);
  };
  ii.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var n = er(t);
    return e !== void 0 ? typeof r == "string" ? n.fill(e, r) : n.fill(e) : n.fill(0), n;
  };
  ii.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return er(t);
  };
  ii.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return Gf.SlowBuffer(t);
  };
});
var fi = k2((U8, wa) => {
  "use strict";
  var _a3 = 65536, w1 = 4294967295;
  function x1() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var M1 = Ae().Buffer, Xf = __global$.crypto || __global$.msCrypto;
  Xf && Xf.getRandomValues ? wa.exports = S1 : wa.exports = x1;
  function S1(t, e) {
    if (t > w1)
      throw new RangeError("requested too many random bytes");
    var r = M1.allocUnsafe(t);
    if (t > 0)
      if (t > _a3)
        for (var n = 0; n < t; n += _a3)
          Xf.getRandomValues(r.slice(n, n + _a3));
      else
        Xf.getRandomValues(r);
    return typeof e == "function" ? process_default.nextTick(function() {
      e(null, r);
    }) : r;
  }
});
var qe = k2((H8, xa) => {
  typeof Object.create == "function" ? xa.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : xa.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  };
});
var Ma = k2((F8, Hs) => {
  Hs.exports = events_default.EventEmitter;
});
var Ws = k2((K8, js) => {
  "use strict";
  function Fs(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(t);
      e && (n = n.filter(function(i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })), r.push.apply(r, n);
    }
    return r;
  }
  function E1(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? Fs(Object(r), true).forEach(function(n) {
        A1(t, n, r[n]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Fs(Object(r)).forEach(function(n) {
        Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
      });
    }
    return t;
  }
  function A1(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function q1(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function Ks(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function B1(t, e, r) {
    return e && Ks(t.prototype, e), r && Ks(t, r), t;
  }
  var R1 = export_default, Yf = R1.Buffer, I1 = util_default, Sa = I1.inspect, k1 = Sa && Sa.custom || "inspect";
  function D1(t, e, r) {
    Yf.prototype.copy.call(t, e, r);
  }
  js.exports = function() {
    function t() {
      q1(this, t), this.head = null, this.tail = null, this.length = 0;
    }
    return B1(t, [{ key: "push", value: function(r) {
      var n = { data: r, next: null };
      this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var n = { data: r, next: this.head };
      this.length === 0 && (this.tail = n), this.head = n, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var n = this.head, i = "" + n.data; n = n.next; )
        i += r + n.data;
      return i;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return Yf.alloc(0);
      for (var n = Yf.allocUnsafe(r >>> 0), i = this.head, o = 0; i; )
        D1(i.data, n, o), o += i.data.length, i = i.next;
      return n;
    } }, { key: "consume", value: function(r, n) {
      var i;
      return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var n = this.head, i = 1, o = n.data;
      for (r -= o.length; n = n.next; ) {
        var p = n.data, y = r > p.length ? p.length : r;
        if (y === p.length ? o += p : o += p.slice(0, r), r -= y, r === 0) {
          y === p.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = p.slice(y));
          break;
        }
        ++i;
      }
      return this.length -= i, o;
    } }, { key: "_getBuffer", value: function(r) {
      var n = Yf.allocUnsafe(r), i = this.head, o = 1;
      for (i.data.copy(n), r -= i.data.length; i = i.next; ) {
        var p = i.data, y = r > p.length ? p.length : r;
        if (p.copy(n, n.length - r, 0, y), r -= y, r === 0) {
          y === p.length ? (++o, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = p.slice(y));
          break;
        }
        ++o;
      }
      return this.length -= o, n;
    } }, { key: k1, value: function(r, n) {
      return Sa(this, E1({}, n, { depth: 0, customInspect: false }));
    } }]), t;
  }();
});
var Aa = k2((j8, Zs) => {
  "use strict";
  function P1(t, e) {
    var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
    return n || i ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process_default.nextTick(Ea, this, t)) : process_default.nextTick(Ea, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(o) {
      !e && o ? r._writableState ? r._writableState.errorEmitted ? process_default.nextTick(Jf, r) : (r._writableState.errorEmitted = true, process_default.nextTick(Vs, r, o)) : process_default.nextTick(Vs, r, o) : e ? (process_default.nextTick(Jf, r), e(o)) : process_default.nextTick(Jf, r);
    }), this);
  }
  function Vs(t, e) {
    Ea(t, e), Jf(t);
  }
  function Jf(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function T1() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function Ea(t, e) {
    t.emit("error", e);
  }
  function C1(t, e) {
    var r = t._readableState, n = t._writableState;
    r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  Zs.exports = { destroy: P1, undestroy: T1, errorOrDestroy: C1 };
});
var ni = k2((W8, Ys) => {
  "use strict";
  function N1(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var Xs = {};
  function ct2(t, e, r) {
    r || (r = Error);
    function n(o, p, y) {
      return typeof e == "string" ? e : e(o, p, y);
    }
    var i = function(o) {
      N1(p, o);
      function p(y, w, x) {
        return o.call(this, n(y, w, x)) || this;
      }
      return p;
    }(r);
    i.prototype.name = r.name, i.prototype.code = t, Xs[t] = i;
  }
  function Gs(t, e) {
    if (Array.isArray(t)) {
      var r = t.length;
      return t = t.map(function(n) {
        return String(n);
      }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function L1(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
  }
  function O1(t, e, r) {
    return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
  }
  function z1(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
  }
  ct2("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  ct2("ERR_INVALID_ARG_TYPE", function(t, e, r) {
    var n;
    typeof e == "string" && L1(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
    var i;
    if (O1(t, " argument"))
      i = "The ".concat(t, " ").concat(n, " ").concat(Gs(e, "type"));
    else {
      var o = z1(t, ".") ? "property" : "argument";
      i = 'The "'.concat(t, '" ').concat(o, " ").concat(n, " ").concat(Gs(e, "type"));
    }
    return i += ". Received type ".concat(typeof r), i;
  }, TypeError);
  ct2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  ct2("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  ct2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  ct2("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  ct2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  ct2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  ct2("ERR_STREAM_WRITE_AFTER_END", "write after end");
  ct2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  ct2("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  ct2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Ys.exports.codes = Xs;
});
var qa = k2((V8, Js) => {
  "use strict";
  var U1 = ni().codes.ERR_INVALID_OPT_VALUE;
  function H1(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function F1(t, e, r, n) {
    var i = H1(e, n, r);
    if (i != null) {
      if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
        var o = n ? r : "highWaterMark";
        throw new U1(o, i);
      }
      return Math.floor(i);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  Js.exports = { getHighWaterMark: F1 };
});
var Qs = k2((Z8, $s) => {
  $s.exports = K1;
  function K1(t, e) {
    if (Ba("noDeprecation"))
      return t;
    var r = false;
    function n() {
      if (!r) {
        if (Ba("throwDeprecation"))
          throw new Error(e);
        Ba("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return n;
  }
  function Ba(t) {
    try {
      if (!__global$.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = __global$.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var ka = k2((G8, no) => {
  "use strict";
  no.exports = Le;
  function to(t) {
    var e = this;
    this.next = null, this.entry = null, this.finish = function() {
      bv(e, t);
    };
  }
  var Di;
  Le.WritableState = df;
  var j1 = { deprecate: Qs() }, ro = Ma(), Qf = export_default.Buffer, W1 = __global$.Uint8Array || function() {
  };
  function V1(t) {
    return Qf.from(t);
  }
  function Z1(t) {
    return Qf.isBuffer(t) || t instanceof W1;
  }
  var Ia = Aa(), G1 = qa(), X1 = G1.getHighWaterMark, Hr = ni().codes, Y1 = Hr.ERR_INVALID_ARG_TYPE, J1 = Hr.ERR_METHOD_NOT_IMPLEMENTED, $1 = Hr.ERR_MULTIPLE_CALLBACK, Q1 = Hr.ERR_STREAM_CANNOT_PIPE, ev = Hr.ERR_STREAM_DESTROYED, tv = Hr.ERR_STREAM_NULL_VALUES, rv = Hr.ERR_STREAM_WRITE_AFTER_END, iv = Hr.ERR_UNKNOWN_ENCODING, Pi = Ia.errorOrDestroy;
  qe()(Le, ro);
  function fv() {
  }
  function df(t, e, r) {
    Di = Di || ai(), t = t || {}, typeof r != "boolean" && (r = e instanceof Di), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = X1(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var n = t.decodeStrings === false;
    this.decodeStrings = !n, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
      dv(e, i);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new to(this);
  }
  df.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r = []; e; )
      r.push(e), e = e.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(df.prototype, "buffer", { get: j1.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var $f;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? ($f = Function.prototype[Symbol.hasInstance], Object.defineProperty(Le, Symbol.hasInstance, { value: function(e) {
    return $f.call(this, e) ? true : this !== Le ? false : e && e._writableState instanceof df;
  } })) : $f = function(e) {
    return e instanceof this;
  };
  function Le(t) {
    Di = Di || ai();
    var e = this instanceof Di;
    if (!e && !$f.call(Le, this))
      return new Le(t);
    this._writableState = new df(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), ro.call(this);
  }
  Le.prototype.pipe = function() {
    Pi(this, new Q1());
  };
  function nv(t, e) {
    var r = new rv();
    Pi(t, r), process_default.nextTick(e, r);
  }
  function av(t, e, r, n) {
    var i;
    return r === null ? i = new tv() : typeof r != "string" && !e.objectMode && (i = new Y1("chunk", ["string", "Buffer"], r)), i ? (Pi(t, i), process_default.nextTick(n, i), false) : true;
  }
  Le.prototype.write = function(t, e, r) {
    var n = this._writableState, i = false, o = !n.objectMode && Z1(t);
    return o && !Qf.isBuffer(t) && (t = V1(t)), typeof e == "function" && (r = e, e = null), o ? e = "buffer" : e || (e = n.defaultEncoding), typeof r != "function" && (r = fv), n.ending ? nv(this, r) : (o || av(this, n, t, r)) && (n.pendingcb++, i = ov(this, n, o, t, e, r)), i;
  };
  Le.prototype.cork = function() {
    this._writableState.corked++;
  };
  Le.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && io(this, t));
  };
  Le.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new iv(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(Le.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function sv(t, e, r) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = Qf.from(e, r)), e;
  }
  Object.defineProperty(Le.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function ov(t, e, r, n, i, o) {
    if (!r) {
      var p = sv(e, n, i);
      n !== p && (r = true, i = "buffer", n = p);
    }
    var y = e.objectMode ? 1 : n.length;
    e.length += y;
    var w = e.length < e.highWaterMark;
    if (w || (e.needDrain = true), e.writing || e.corked) {
      var x = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      Ra(t, e, false, y, n, i, o);
    return w;
  }
  function Ra(t, e, r, n, i, o, p) {
    e.writelen = n, e.writecb = p, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ev("write")) : r ? t._writev(i, e.onwrite) : t._write(i, o, e.onwrite), e.sync = false;
  }
  function hv(t, e, r, n, i) {
    --e.pendingcb, r ? (process_default.nextTick(i, n), process_default.nextTick(uf, t, e), t._writableState.errorEmitted = true, Pi(t, n)) : (i(n), t._writableState.errorEmitted = true, Pi(t, n), uf(t, e));
  }
  function uv(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function dv(t, e) {
    var r = t._writableState, n = r.sync, i = r.writecb;
    if (typeof i != "function")
      throw new $1();
    if (uv(r), e)
      hv(t, r, n, e, i);
    else {
      var o = fo(r) || t.destroyed;
      !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && io(t, r), n ? process_default.nextTick(eo, t, r, o, i) : eo(t, r, o, i);
    }
  }
  function eo(t, e, r, n) {
    r || cv(t, e), e.pendingcb--, n(), uf(t, e);
  }
  function cv(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function io(t, e) {
    e.bufferProcessing = true;
    var r = e.bufferedRequest;
    if (t._writev && r && r.next) {
      var n = e.bufferedRequestCount, i = new Array(n), o = e.corkedRequestsFree;
      o.entry = r;
      for (var p = 0, y = true; r; )
        i[p] = r, r.isBuf || (y = false), r = r.next, p += 1;
      i.allBuffers = y, Ra(t, e, true, e.length, i, "", o.finish), e.pendingcb++, e.lastBufferedRequest = null, o.next ? (e.corkedRequestsFree = o.next, o.next = null) : e.corkedRequestsFree = new to(e), e.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var w = r.chunk, x = r.encoding, M = r.callback, E = e.objectMode ? 1 : w.length;
        if (Ra(t, e, false, E, w, x, M), r = r.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r, e.bufferProcessing = false;
  }
  Le.prototype._write = function(t, e, r) {
    r(new J1("_write()"));
  };
  Le.prototype._writev = null;
  Le.prototype.end = function(t, e, r) {
    var n = this._writableState;
    return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || pv(this, n, r), this;
  };
  Object.defineProperty(Le.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function fo(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function lv(t, e) {
    t._final(function(r) {
      e.pendingcb--, r && Pi(t, r), e.prefinished = true, t.emit("prefinish"), uf(t, e);
    });
  }
  function vv(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process_default.nextTick(lv, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function uf(t, e) {
    var r = fo(e);
    if (r && (vv(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      var n = t._readableState;
      (!n || n.autoDestroy && n.endEmitted) && t.destroy();
    }
    return r;
  }
  function pv(t, e, r) {
    e.ending = true, uf(t, e), r && (e.finished ? process_default.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
  }
  function bv(t, e, r) {
    var n = t.entry;
    for (t.entry = null; n; ) {
      var i = n.callback;
      e.pendingcb--, i(r), n = n.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(Le.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(e) {
    !this._writableState || (this._writableState.destroyed = e);
  } });
  Le.prototype.destroy = Ia.destroy;
  Le.prototype._undestroy = Ia.undestroy;
  Le.prototype._destroy = function(t, e) {
    e(t);
  };
});
var ai = k2((X8, so) => {
  "use strict";
  var mv = Object.keys || function(t) {
    var e = [];
    for (var r in t)
      e.push(r);
    return e;
  };
  so.exports = tr;
  var ao = Ta(), Pa = ka();
  qe()(tr, ao);
  for (Da = mv(Pa.prototype), en = 0; en < Da.length; en++)
    tn = Da[en], tr.prototype[tn] || (tr.prototype[tn] = Pa.prototype[tn]);
  var Da, tn, en;
  function tr(t) {
    if (!(this instanceof tr))
      return new tr(t);
    ao.call(this, t), Pa.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", gv)));
  }
  Object.defineProperty(tr.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(tr.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(tr.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function gv() {
    this._writableState.ended || process_default.nextTick(yv, this);
  }
  function yv(t) {
    t.end();
  }
  Object.defineProperty(tr.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(e) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
  } });
});
var rn = k2((Y8, uo) => {
  "use strict";
  var oo = ni().codes.ERR_STREAM_PREMATURE_CLOSE;
  function _v(t) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
          n[i] = arguments[i];
        t.apply(this, n);
      }
    };
  }
  function wv() {
  }
  function xv(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function ho(t, e, r) {
    if (typeof e == "function")
      return ho(t, null, e);
    e || (e = {}), r = _v(r || wv);
    var n = e.readable || e.readable !== false && t.readable, i = e.writable || e.writable !== false && t.writable, o = function() {
      t.writable || y();
    }, p = t._writableState && t._writableState.finished, y = function() {
      i = false, p = true, n || r.call(t);
    }, w = t._readableState && t._readableState.endEmitted, x = function() {
      n = false, w = true, i || r.call(t);
    }, M = function(D) {
      r.call(t, D);
    }, E = function() {
      var D;
      if (n && !w)
        return (!t._readableState || !t._readableState.ended) && (D = new oo()), r.call(t, D);
      if (i && !p)
        return (!t._writableState || !t._writableState.ended) && (D = new oo()), r.call(t, D);
    }, A = function() {
      t.req.on("finish", y);
    };
    return xv(t) ? (t.on("complete", y), t.on("abort", E), t.req ? A() : t.on("request", A)) : i && !t._writableState && (t.on("end", o), t.on("close", o)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", M), t.on("close", E), function() {
      t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", A), t.req && t.req.removeListener("finish", y), t.removeListener("end", o), t.removeListener("close", o), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", M), t.removeListener("close", E);
    };
  }
  uo.exports = ho;
});
var lo = k2((J8, co) => {
  "use strict";
  var fn;
  function Fr(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  var Mv = rn(), Kr = Symbol("lastResolve"), si = Symbol("lastReject"), cf = Symbol("error"), nn = Symbol("ended"), oi = Symbol("lastPromise"), Ca = Symbol("handlePromise"), hi = Symbol("stream");
  function jr(t, e) {
    return { value: t, done: e };
  }
  function Sv(t) {
    var e = t[Kr];
    if (e !== null) {
      var r = t[hi].read();
      r !== null && (t[oi] = null, t[Kr] = null, t[si] = null, e(jr(r, false)));
    }
  }
  function Ev(t) {
    process_default.nextTick(Sv, t);
  }
  function Av(t, e) {
    return function(r, n) {
      t.then(function() {
        if (e[nn]) {
          r(jr(void 0, true));
          return;
        }
        e[Ca](r, n);
      }, n);
    };
  }
  var qv = Object.getPrototypeOf(function() {
  }), Bv = Object.setPrototypeOf((fn = { get stream() {
    return this[hi];
  }, next: function() {
    var e = this, r = this[cf];
    if (r !== null)
      return Promise.reject(r);
    if (this[nn])
      return Promise.resolve(jr(void 0, true));
    if (this[hi].destroyed)
      return new Promise(function(p, y) {
        process_default.nextTick(function() {
          e[cf] ? y(e[cf]) : p(jr(void 0, true));
        });
      });
    var n = this[oi], i;
    if (n)
      i = new Promise(Av(n, this));
    else {
      var o = this[hi].read();
      if (o !== null)
        return Promise.resolve(jr(o, false));
      i = new Promise(this[Ca]);
    }
    return this[oi] = i, i;
  } }, Fr(fn, Symbol.asyncIterator, function() {
    return this;
  }), Fr(fn, "return", function() {
    var e = this;
    return new Promise(function(r, n) {
      e[hi].destroy(null, function(i) {
        if (i) {
          n(i);
          return;
        }
        r(jr(void 0, true));
      });
    });
  }), fn), qv), Rv = function(e) {
    var r, n = Object.create(Bv, (r = {}, Fr(r, hi, { value: e, writable: true }), Fr(r, Kr, { value: null, writable: true }), Fr(r, si, { value: null, writable: true }), Fr(r, cf, { value: null, writable: true }), Fr(r, nn, { value: e._readableState.endEmitted, writable: true }), Fr(r, Ca, { value: function(o, p) {
      var y = n[hi].read();
      y ? (n[oi] = null, n[Kr] = null, n[si] = null, o(jr(y, false))) : (n[Kr] = o, n[si] = p);
    }, writable: true }), r));
    return n[oi] = null, Mv(e, function(i) {
      if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var o = n[si];
        o !== null && (n[oi] = null, n[Kr] = null, n[si] = null, o(i)), n[cf] = i;
        return;
      }
      var p = n[Kr];
      p !== null && (n[oi] = null, n[Kr] = null, n[si] = null, p(jr(void 0, true))), n[nn] = true;
    }), e.on("readable", Ev.bind(null, n)), n;
  };
  co.exports = Rv;
});
var po = k2(($8, vo) => {
  vo.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var Ta = k2((e5, Eo) => {
  "use strict";
  Eo.exports = Ie;
  var Ti;
  Ie.ReadableState = yo;
  var Q8 = events_default.EventEmitter, go = function(e, r) {
    return e.listeners(r).length;
  }, vf = Ma(), an = export_default.Buffer, Iv = __global$.Uint8Array || function() {
  };
  function kv(t) {
    return an.from(t);
  }
  function Dv(t) {
    return an.isBuffer(t) || t instanceof Iv;
  }
  var Na = util_default, Be;
  Na && Na.debuglog ? Be = Na.debuglog("stream") : Be = function() {
  };
  var Pv = Ws(), Ka = Aa(), Tv = qa(), Cv = Tv.getHighWaterMark, sn = ni().codes, Nv = sn.ERR_INVALID_ARG_TYPE, Lv = sn.ERR_STREAM_PUSH_AFTER_EOF, Ov = sn.ERR_METHOD_NOT_IMPLEMENTED, zv = sn.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ci, La, Oa;
  qe()(Ie, vf);
  var lf = Ka.errorOrDestroy, za = ["error", "close", "destroy", "pause", "resume"];
  function Uv(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  function yo(t, e, r) {
    Ti = Ti || ai(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ti), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = Cv(this, t, "readableHighWaterMark", r), this.buffer = new Pv(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Ci || (Ci = string_decoder_default2.StringDecoder), this.decoder = new Ci(t.encoding), this.encoding = t.encoding);
  }
  function Ie(t) {
    if (Ti = Ti || ai(), !(this instanceof Ie))
      return new Ie(t);
    var e = this instanceof Ti;
    this._readableState = new yo(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), vf.call(this);
  }
  Object.defineProperty(Ie.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(e) {
    !this._readableState || (this._readableState.destroyed = e);
  } });
  Ie.prototype.destroy = Ka.destroy;
  Ie.prototype._undestroy = Ka.undestroy;
  Ie.prototype._destroy = function(t, e) {
    e(t);
  };
  Ie.prototype.push = function(t, e) {
    var r = this._readableState, n;
    return r.objectMode ? n = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = an.from(t, e), e = ""), n = true), _o(this, t, e, false, n);
  };
  Ie.prototype.unshift = function(t) {
    return _o(this, t, null, true, false);
  };
  function _o(t, e, r, n, i) {
    Be("readableAddChunk", e);
    var o = t._readableState;
    if (e === null)
      o.reading = false, Kv(t, o);
    else {
      var p;
      if (i || (p = Hv(o, e)), p)
        lf(t, p);
      else if (o.objectMode || e && e.length > 0)
        if (typeof e != "string" && !o.objectMode && Object.getPrototypeOf(e) !== an.prototype && (e = kv(e)), n)
          o.endEmitted ? lf(t, new zv()) : Ua(t, o, e, true);
        else if (o.ended)
          lf(t, new Lv());
        else {
          if (o.destroyed)
            return false;
          o.reading = false, o.decoder && !r ? (e = o.decoder.write(e), o.objectMode || e.length !== 0 ? Ua(t, o, e, false) : Fa(t, o)) : Ua(t, o, e, false);
        }
      else
        n || (o.reading = false, Fa(t, o));
    }
    return !o.ended && (o.length < o.highWaterMark || o.length === 0);
  }
  function Ua(t, e, r, n) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && on2(t)), Fa(t, e);
  }
  function Hv(t, e) {
    var r;
    return !Dv(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new Nv("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
  }
  Ie.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Ie.prototype.setEncoding = function(t) {
    Ci || (Ci = string_decoder_default2.StringDecoder);
    var e = new Ci(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, n = ""; r !== null; )
      n += e.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
  };
  var bo = 1073741824;
  function Fv(t) {
    return t >= bo ? t = bo : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function mo(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = Fv(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  Ie.prototype.read = function(t) {
    Be("read", t), t = parseInt(t, 10);
    var e = this._readableState, r = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Be("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Ha(this) : on2(this), null;
    if (t = mo(t, e), t === 0 && e.ended)
      return e.length === 0 && Ha(this), null;
    var n = e.needReadable;
    Be("need readable", n), (e.length === 0 || e.length - t < e.highWaterMark) && (n = true, Be("length less than watermark", n)), e.ended || e.reading ? (n = false, Be("reading or ended", n)) : n && (Be("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = mo(r, e)));
    var i;
    return t > 0 ? i = Mo(t, e) : i = null, i === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Ha(this)), i !== null && this.emit("data", i), i;
  };
  function Kv(t, e) {
    if (Be("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? on2(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, wo(t)));
    }
  }
  function on2(t) {
    var e = t._readableState;
    Be("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Be("emitReadable", e.flowing), e.emittedReadable = true, process_default.nextTick(wo, t));
  }
  function wo(t) {
    var e = t._readableState;
    Be("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ja(t);
  }
  function Fa(t, e) {
    e.readingMore || (e.readingMore = true, process_default.nextTick(jv, t, e));
  }
  function jv(t, e) {
    for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      var r = e.length;
      if (Be("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  Ie.prototype._read = function(t) {
    lf(this, new Ov("_read()"));
  };
  Ie.prototype.pipe = function(t, e) {
    var r = this, n = this._readableState;
    switch (n.pipesCount) {
      case 0:
        n.pipes = t;
        break;
      case 1:
        n.pipes = [n.pipes, t];
        break;
      default:
        n.pipes.push(t);
        break;
    }
    n.pipesCount += 1, Be("pipe count=%d opts=%j", n.pipesCount, e);
    var i = (!e || e.end !== false) && t !== process_default.stdout && t !== process_default.stderr, o = i ? y : C;
    n.endEmitted ? process_default.nextTick(o) : r.once("end", o), t.on("unpipe", p);
    function p(ge, L) {
      Be("onunpipe"), ge === r && L && L.hasUnpiped === false && (L.hasUnpiped = true, M());
    }
    function y() {
      Be("onend"), t.end();
    }
    var w = Wv(r);
    t.on("drain", w);
    var x = false;
    function M() {
      Be("cleanup"), t.removeListener("close", I), t.removeListener("finish", D), t.removeListener("drain", w), t.removeListener("error", A), t.removeListener("unpipe", p), r.removeListener("end", y), r.removeListener("end", C), r.removeListener("data", E), x = true, n.awaitDrain && (!t._writableState || t._writableState.needDrain) && w();
    }
    r.on("data", E);
    function E(ge) {
      Be("ondata");
      var L = t.write(ge);
      Be("dest.write", L), L === false && ((n.pipesCount === 1 && n.pipes === t || n.pipesCount > 1 && So(n.pipes, t) !== -1) && !x && (Be("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
    }
    function A(ge) {
      Be("onerror", ge), C(), t.removeListener("error", A), go(t, "error") === 0 && lf(t, ge);
    }
    Uv(t, "error", A);
    function I() {
      t.removeListener("finish", D), C();
    }
    t.once("close", I);
    function D() {
      Be("onfinish"), t.removeListener("close", I), C();
    }
    t.once("finish", D);
    function C() {
      Be("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), n.flowing || (Be("pipe resume"), r.resume()), t;
  };
  function Wv(t) {
    return function() {
      var r = t._readableState;
      Be("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && go(t, "data") && (r.flowing = true, ja(t));
    };
  }
  Ie.prototype.unpipe = function(t) {
    var e = this._readableState, r = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
    if (!t) {
      var n = e.pipes, i = e.pipesCount;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var o = 0; o < i; o++)
        n[o].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var p = So(e.pipes, t);
    return p === -1 ? this : (e.pipes.splice(p, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
  };
  Ie.prototype.on = function(t, e) {
    var r = vf.prototype.on.call(this, t, e), n = this._readableState;
    return t === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : t === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, Be("on readable", n.length, n.reading), n.length ? on2(this) : n.reading || process_default.nextTick(Vv, this)), r;
  };
  Ie.prototype.addListener = Ie.prototype.on;
  Ie.prototype.removeListener = function(t, e) {
    var r = vf.prototype.removeListener.call(this, t, e);
    return t === "readable" && process_default.nextTick(xo, this), r;
  };
  Ie.prototype.removeAllListeners = function(t) {
    var e = vf.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === void 0) && process_default.nextTick(xo, this), e;
  };
  function xo(t) {
    var e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function Vv(t) {
    Be("readable nexttick read 0"), t.read(0);
  }
  Ie.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (Be("resume"), t.flowing = !t.readableListening, Zv(this, t)), t.paused = false, this;
  };
  function Zv(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, process_default.nextTick(Gv, t, e));
  }
  function Gv(t, e) {
    Be("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ja(t), e.flowing && !e.reading && t.read(0);
  }
  Ie.prototype.pause = function() {
    return Be("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Be("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function ja(t) {
    var e = t._readableState;
    for (Be("flow", e.flowing); e.flowing && t.read() !== null; )
      ;
  }
  Ie.prototype.wrap = function(t) {
    var e = this, r = this._readableState, n = false;
    t.on("end", function() {
      if (Be("wrapped end"), r.decoder && !r.ended) {
        var p = r.decoder.end();
        p && p.length && e.push(p);
      }
      e.push(null);
    }), t.on("data", function(p) {
      if (Be("wrapped data"), r.decoder && (p = r.decoder.write(p)), !(r.objectMode && p == null) && !(!r.objectMode && (!p || !p.length))) {
        var y = e.push(p);
        y || (n = true, t.pause());
      }
    });
    for (var i in t)
      this[i] === void 0 && typeof t[i] == "function" && (this[i] = function(y) {
        return function() {
          return t[y].apply(t, arguments);
        };
      }(i));
    for (var o = 0; o < za.length; o++)
      t.on(za[o], this.emit.bind(this, za[o]));
    return this._read = function(p) {
      Be("wrapped _read", p), n && (n = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (Ie.prototype[Symbol.asyncIterator] = function() {
    return La === void 0 && (La = lo()), La(this);
  });
  Object.defineProperty(Ie.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(Ie.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(Ie.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  Ie._fromList = Mo;
  Object.defineProperty(Ie.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function Mo(t, e) {
    if (e.length === 0)
      return null;
    var r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function Ha(t) {
    var e = t._readableState;
    Be("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process_default.nextTick(Xv, e, t));
  }
  function Xv(t, e) {
    if (Be("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      var r = e._writableState;
      (!r || r.autoDestroy && r.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (Ie.from = function(t, e) {
    return Oa === void 0 && (Oa = po()), Oa(Ie, t, e);
  });
  function So(t, e) {
    for (var r = 0, n = t.length; r < n; r++)
      if (t[r] === e)
        return r;
    return -1;
  }
});
var Wa = k2((t5, qo) => {
  "use strict";
  qo.exports = cr;
  var hn = ni().codes, Yv = hn.ERR_METHOD_NOT_IMPLEMENTED, Jv = hn.ERR_MULTIPLE_CALLBACK, $v = hn.ERR_TRANSFORM_ALREADY_TRANSFORMING, Qv = hn.ERR_TRANSFORM_WITH_LENGTH_0, un = ai();
  qe()(cr, un);
  function ep(t, e) {
    var r = this._transformState;
    r.transforming = false;
    var n = r.writecb;
    if (n === null)
      return this.emit("error", new Jv());
    r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t);
    var i = this._readableState;
    i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
  function cr(t) {
    if (!(this instanceof cr))
      return new cr(t);
    un.call(this, t), this._transformState = { afterTransform: ep.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", tp);
  }
  function tp() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Ao(t, e, r);
    }) : Ao(this, null, null);
  }
  cr.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, un.prototype.push.call(this, t, e);
  };
  cr.prototype._transform = function(t, e, r) {
    r(new Yv("_transform()"));
  };
  cr.prototype._write = function(t, e, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
  };
  cr.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  cr.prototype._destroy = function(t, e) {
    un.prototype._destroy.call(this, t, function(r) {
      e(r);
    });
  };
  function Ao(t, e, r) {
    if (e)
      return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length)
      throw new Qv();
    if (t._transformState.transforming)
      throw new $v();
    return t.push(null);
  }
});
var Io = k2((r5, Ro) => {
  "use strict";
  Ro.exports = pf;
  var Bo = Wa();
  qe()(pf, Bo);
  function pf(t) {
    if (!(this instanceof pf))
      return new pf(t);
    Bo.call(this, t);
  }
  pf.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var Co = k2((i5, To) => {
  "use strict";
  var Va;
  function rp(t) {
    var e = false;
    return function() {
      e || (e = true, t.apply(void 0, arguments));
    };
  }
  var Po = ni().codes, ip = Po.ERR_MISSING_ARGS, fp = Po.ERR_STREAM_DESTROYED;
  function ko(t) {
    if (t)
      throw t;
  }
  function np(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function ap(t, e, r, n) {
    n = rp(n);
    var i = false;
    t.on("close", function() {
      i = true;
    }), Va === void 0 && (Va = rn()), Va(t, { readable: e, writable: r }, function(p) {
      if (p)
        return n(p);
      i = true, n();
    });
    var o = false;
    return function(p) {
      if (!i && !o) {
        if (o = true, np(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        n(p || new fp("pipe"));
      }
    };
  }
  function Do(t) {
    t();
  }
  function sp(t, e) {
    return t.pipe(e);
  }
  function op(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? ko : t.pop();
  }
  function hp() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
      e[r] = arguments[r];
    var n = op(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new ip("streams");
    var i, o = e.map(function(p, y) {
      var w = y < e.length - 1, x = y > 0;
      return ap(p, w, x, function(M) {
        i || (i = M), M && o.forEach(Do), !w && (o.forEach(Do), n(i));
      });
    });
    return e.reduce(sp);
  }
  To.exports = hp;
});
var Za = k2((lt2, No) => {
  lt2 = No.exports = Ta();
  lt2.Stream = lt2;
  lt2.Readable = lt2;
  lt2.Writable = ka();
  lt2.Duplex = ai();
  lt2.Transform = Wa();
  lt2.PassThrough = Io();
  lt2.finished = rn();
  lt2.pipeline = Co();
});
var Ga = k2((f5, Oo) => {
  "use strict";
  var dn = Ae().Buffer, Lo = Za().Transform, up = qe();
  function dp(t, e) {
    if (!dn.isBuffer(t) && typeof t != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function Wr(t) {
    Lo.call(this), this._block = dn.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
  }
  up(Wr, Lo);
  Wr.prototype._transform = function(t, e, r) {
    var n = null;
    try {
      this.update(t, e);
    } catch (i) {
      n = i;
    }
    r(n);
  };
  Wr.prototype._flush = function(t) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Wr.prototype.update = function(t, e) {
    if (dp(t, "Data"), this._finalized)
      throw new Error("Digest already called");
    dn.isBuffer(t) || (t = dn.from(t, e));
    for (var r = this._block, n = 0; this._blockOffset + t.length - n >= this._blockSize; ) {
      for (var i = this._blockOffset; i < this._blockSize; )
        r[i++] = t[n++];
      this._update(), this._blockOffset = 0;
    }
    for (; n < t.length; )
      r[this._blockOffset++] = t[n++];
    for (var o = 0, p = t.length * 8; p > 0; ++o)
      this._length[o] += p, p = this._length[o] / 4294967296 | 0, p > 0 && (this._length[o] -= 4294967296 * p);
    return this;
  };
  Wr.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  Wr.prototype.digest = function(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r = 0; r < 4; ++r)
      this._length[r] = 0;
    return e;
  };
  Wr.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  Oo.exports = Wr;
});
var vn = k2((n5, Uo) => {
  "use strict";
  var cp = qe(), zo = Ga(), lp = Ae().Buffer, vp = new Array(16);
  function cn() {
    zo.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  cp(cn, zo);
  cn.prototype._update = function() {
    for (var t = vp, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    var r = this._a, n = this._b, i = this._c, o = this._d;
    r = Je(r, n, i, o, t[0], 3614090360, 7), o = Je(o, r, n, i, t[1], 3905402710, 12), i = Je(i, o, r, n, t[2], 606105819, 17), n = Je(n, i, o, r, t[3], 3250441966, 22), r = Je(r, n, i, o, t[4], 4118548399, 7), o = Je(o, r, n, i, t[5], 1200080426, 12), i = Je(i, o, r, n, t[6], 2821735955, 17), n = Je(n, i, o, r, t[7], 4249261313, 22), r = Je(r, n, i, o, t[8], 1770035416, 7), o = Je(o, r, n, i, t[9], 2336552879, 12), i = Je(i, o, r, n, t[10], 4294925233, 17), n = Je(n, i, o, r, t[11], 2304563134, 22), r = Je(r, n, i, o, t[12], 1804603682, 7), o = Je(o, r, n, i, t[13], 4254626195, 12), i = Je(i, o, r, n, t[14], 2792965006, 17), n = Je(n, i, o, r, t[15], 1236535329, 22), r = $e(r, n, i, o, t[1], 4129170786, 5), o = $e(o, r, n, i, t[6], 3225465664, 9), i = $e(i, o, r, n, t[11], 643717713, 14), n = $e(n, i, o, r, t[0], 3921069994, 20), r = $e(r, n, i, o, t[5], 3593408605, 5), o = $e(o, r, n, i, t[10], 38016083, 9), i = $e(i, o, r, n, t[15], 3634488961, 14), n = $e(n, i, o, r, t[4], 3889429448, 20), r = $e(r, n, i, o, t[9], 568446438, 5), o = $e(o, r, n, i, t[14], 3275163606, 9), i = $e(i, o, r, n, t[3], 4107603335, 14), n = $e(n, i, o, r, t[8], 1163531501, 20), r = $e(r, n, i, o, t[13], 2850285829, 5), o = $e(o, r, n, i, t[2], 4243563512, 9), i = $e(i, o, r, n, t[7], 1735328473, 14), n = $e(n, i, o, r, t[12], 2368359562, 20), r = Qe(r, n, i, o, t[5], 4294588738, 4), o = Qe(o, r, n, i, t[8], 2272392833, 11), i = Qe(i, o, r, n, t[11], 1839030562, 16), n = Qe(n, i, o, r, t[14], 4259657740, 23), r = Qe(r, n, i, o, t[1], 2763975236, 4), o = Qe(o, r, n, i, t[4], 1272893353, 11), i = Qe(i, o, r, n, t[7], 4139469664, 16), n = Qe(n, i, o, r, t[10], 3200236656, 23), r = Qe(r, n, i, o, t[13], 681279174, 4), o = Qe(o, r, n, i, t[0], 3936430074, 11), i = Qe(i, o, r, n, t[3], 3572445317, 16), n = Qe(n, i, o, r, t[6], 76029189, 23), r = Qe(r, n, i, o, t[9], 3654602809, 4), o = Qe(o, r, n, i, t[12], 3873151461, 11), i = Qe(i, o, r, n, t[15], 530742520, 16), n = Qe(n, i, o, r, t[2], 3299628645, 23), r = et(r, n, i, o, t[0], 4096336452, 6), o = et(o, r, n, i, t[7], 1126891415, 10), i = et(i, o, r, n, t[14], 2878612391, 15), n = et(n, i, o, r, t[5], 4237533241, 21), r = et(r, n, i, o, t[12], 1700485571, 6), o = et(o, r, n, i, t[3], 2399980690, 10), i = et(i, o, r, n, t[10], 4293915773, 15), n = et(n, i, o, r, t[1], 2240044497, 21), r = et(r, n, i, o, t[8], 1873313359, 6), o = et(o, r, n, i, t[15], 4264355552, 10), i = et(i, o, r, n, t[6], 2734768916, 15), n = et(n, i, o, r, t[13], 1309151649, 21), r = et(r, n, i, o, t[4], 4149444226, 6), o = et(o, r, n, i, t[11], 3174756917, 10), i = et(i, o, r, n, t[2], 718787259, 15), n = et(n, i, o, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + n | 0, this._c = this._c + i | 0, this._d = this._d + o | 0;
  };
  cn.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = lp.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
  };
  function ln(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Je(t, e, r, n, i, o, p) {
    return ln(t + (e & r | ~e & n) + i + o | 0, p) + e | 0;
  }
  function $e(t, e, r, n, i, o, p) {
    return ln(t + (e & n | r & ~n) + i + o | 0, p) + e | 0;
  }
  function Qe(t, e, r, n, i, o, p) {
    return ln(t + (e ^ r ^ n) + i + o | 0, p) + e | 0;
  }
  function et(t, e, r, n, i, o, p) {
    return ln(t + (r ^ (e | ~n)) + i + o | 0, p) + e | 0;
  }
  Uo.exports = cn;
});
var bn = k2((a5, Zo) => {
  "use strict";
  var Xa = export_default.Buffer, pp = qe(), Vo = Ga(), bp = new Array(16), bf = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], mf = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], gf = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], yf = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], _f = [0, 1518500249, 1859775393, 2400959708, 2840853838], wf = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function pn() {
    Vo.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  pp(pn, Vo);
  pn.prototype._update = function() {
    for (var t = bp, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    for (var r = this._a | 0, n = this._b | 0, i = this._c | 0, o = this._d | 0, p = this._e | 0, y = this._a | 0, w = this._b | 0, x = this._c | 0, M = this._d | 0, E = this._e | 0, A = 0; A < 80; A += 1) {
      var I, D;
      A < 16 ? (I = Ho(r, n, i, o, p, t[bf[A]], _f[0], gf[A]), D = Wo(y, w, x, M, E, t[mf[A]], wf[0], yf[A])) : A < 32 ? (I = Fo(r, n, i, o, p, t[bf[A]], _f[1], gf[A]), D = jo(y, w, x, M, E, t[mf[A]], wf[1], yf[A])) : A < 48 ? (I = Ko(r, n, i, o, p, t[bf[A]], _f[2], gf[A]), D = Ko(y, w, x, M, E, t[mf[A]], wf[2], yf[A])) : A < 64 ? (I = jo(r, n, i, o, p, t[bf[A]], _f[3], gf[A]), D = Fo(y, w, x, M, E, t[mf[A]], wf[3], yf[A])) : (I = Wo(r, n, i, o, p, t[bf[A]], _f[4], gf[A]), D = Ho(y, w, x, M, E, t[mf[A]], wf[4], yf[A])), r = p, p = o, o = ui(i, 10), i = n, n = I, y = E, E = M, M = ui(x, 10), x = w, w = D;
    }
    var C = this._b + i + M | 0;
    this._b = this._c + o + E | 0, this._c = this._d + p + y | 0, this._d = this._e + r + w | 0, this._e = this._a + n + x | 0, this._a = C;
  };
  pn.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = Xa.alloc ? Xa.alloc(20) : new Xa(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
  };
  function ui(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Ho(t, e, r, n, i, o, p, y) {
    return ui(t + (e ^ r ^ n) + o + p | 0, y) + i | 0;
  }
  function Fo(t, e, r, n, i, o, p, y) {
    return ui(t + (e & r | ~e & n) + o + p | 0, y) + i | 0;
  }
  function Ko(t, e, r, n, i, o, p, y) {
    return ui(t + ((e | ~r) ^ n) + o + p | 0, y) + i | 0;
  }
  function jo(t, e, r, n, i, o, p, y) {
    return ui(t + (e & n | r & ~n) + o + p | 0, y) + i | 0;
  }
  function Wo(t, e, r, n, i, o, p, y) {
    return ui(t + (e ^ (r | ~n)) + o + p | 0, y) + i | 0;
  }
  Zo.exports = pn;
});
var di = k2((s5, Xo) => {
  var Go = Ae().Buffer;
  function mn(t, e) {
    this._block = Go.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
  }
  mn.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = Go.from(t, e));
    for (var r = this._block, n = this._blockSize, i = t.length, o = this._len, p = 0; p < i; ) {
      for (var y = o % n, w = Math.min(i - p, n - y), x = 0; x < w; x++)
        r[y + x] = t[p + x];
      o += w, p += w, o % n === 0 && this._update(r);
    }
    return this._len += i, this;
  };
  mn.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r = this._len * 8;
    if (r <= 4294967295)
      this._block.writeUInt32BE(r, this._blockSize - 4);
    else {
      var n = (r & 4294967295) >>> 0, i = (r - n) / 4294967296;
      this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
    }
    this._update(this._block);
    var o = this._hash();
    return t ? o.toString(t) : o;
  };
  mn.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  Xo.exports = mn;
});
var $o = k2((o5, Jo) => {
  var mp = qe(), Yo = di(), gp = Ae().Buffer, yp = [1518500249, 1859775393, -1894007588, -899497514], _p = new Array(80);
  function xf() {
    this.init(), this._w = _p, Yo.call(this, 64, 56);
  }
  mp(xf, Yo);
  xf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function wp(t) {
    return t << 5 | t >>> 27;
  }
  function xp(t) {
    return t << 30 | t >>> 2;
  }
  function Mp(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n;
  }
  xf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o = this._d | 0, p = this._e | 0, y = 0; y < 16; ++y)
      e[y] = t.readInt32BE(y * 4);
    for (; y < 80; ++y)
      e[y] = e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16];
    for (var w = 0; w < 80; ++w) {
      var x = ~~(w / 20), M = wp(r) + Mp(x, n, i, o) + p + e[w] + yp[x] | 0;
      p = o, o = i, i = xp(n), n = r, r = M;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o + this._d | 0, this._e = p + this._e | 0;
  };
  xf.prototype._hash = function() {
    var t = gp.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Jo.exports = xf;
});
var th = k2((h5, eh) => {
  var Sp = qe(), Qo = di(), Ep = Ae().Buffer, Ap = [1518500249, 1859775393, -1894007588, -899497514], qp = new Array(80);
  function Mf() {
    this.init(), this._w = qp, Qo.call(this, 64, 56);
  }
  Sp(Mf, Qo);
  Mf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Bp(t) {
    return t << 1 | t >>> 31;
  }
  function Rp(t) {
    return t << 5 | t >>> 27;
  }
  function Ip(t) {
    return t << 30 | t >>> 2;
  }
  function kp(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n;
  }
  Mf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o = this._d | 0, p = this._e | 0, y = 0; y < 16; ++y)
      e[y] = t.readInt32BE(y * 4);
    for (; y < 80; ++y)
      e[y] = Bp(e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16]);
    for (var w = 0; w < 80; ++w) {
      var x = ~~(w / 20), M = Rp(r) + kp(x, n, i, o) + p + e[w] + Ap[x] | 0;
      p = o, o = i, i = Ip(n), n = r, r = M;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o + this._d | 0, this._e = p + this._e | 0;
  };
  Mf.prototype._hash = function() {
    var t = Ep.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  eh.exports = Mf;
});
var Ya = k2((u5, ih) => {
  var Dp = qe(), rh = di(), Pp = Ae().Buffer, Tp = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], Cp = new Array(64);
  function Sf() {
    this.init(), this._w = Cp, rh.call(this, 64, 56);
  }
  Dp(Sf, rh);
  Sf.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function Np(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function Lp(t, e, r) {
    return t & e | r & (t | e);
  }
  function Op(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
  }
  function zp(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
  }
  function Up(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
  }
  function Hp(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
  }
  Sf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o = this._d | 0, p = this._e | 0, y = this._f | 0, w = this._g | 0, x = this._h | 0, M = 0; M < 16; ++M)
      e[M] = t.readInt32BE(M * 4);
    for (; M < 64; ++M)
      e[M] = Hp(e[M - 2]) + e[M - 7] + Up(e[M - 15]) + e[M - 16] | 0;
    for (var E = 0; E < 64; ++E) {
      var A = x + zp(p) + Np(p, y, w) + Tp[E] + e[E] | 0, I = Op(r) + Lp(r, n, i) | 0;
      x = w, w = y, y = p, p = o + A | 0, o = i, i = n, n = r, r = A + I | 0;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o + this._d | 0, this._e = p + this._e | 0, this._f = y + this._f | 0, this._g = w + this._g | 0, this._h = x + this._h | 0;
  };
  Sf.prototype._hash = function() {
    var t = Pp.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
  };
  ih.exports = Sf;
});
var nh = k2((d5, fh) => {
  var Fp = qe(), Kp = Ya(), jp = di(), Wp = Ae().Buffer, Vp = new Array(64);
  function gn() {
    this.init(), this._w = Vp, jp.call(this, 64, 56);
  }
  Fp(gn, Kp);
  gn.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  gn.prototype._hash = function() {
    var t = Wp.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  };
  fh.exports = gn;
});
var Ja = k2((c5, ch) => {
  var Zp = qe(), dh = di(), Gp = Ae().Buffer, ah = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], Xp = new Array(160);
  function Ef() {
    this.init(), this._w = Xp, dh.call(this, 128, 112);
  }
  Zp(Ef, dh);
  Ef.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function sh(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function oh(t, e, r) {
    return t & e | r & (t | e);
  }
  function hh(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
  }
  function uh(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
  }
  function Yp(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
  }
  function Jp(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
  }
  function $p(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
  }
  function Qp(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
  }
  function je(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0;
  }
  Ef.prototype._update = function(t) {
    for (var e = this._w, r = this._ah | 0, n = this._bh | 0, i = this._ch | 0, o = this._dh | 0, p = this._eh | 0, y = this._fh | 0, w = this._gh | 0, x = this._hh | 0, M = this._al | 0, E = this._bl | 0, A = this._cl | 0, I = this._dl | 0, D = this._el | 0, C = this._fl | 0, ge = this._gl | 0, L = this._hl | 0, ye = 0; ye < 32; ye += 2)
      e[ye] = t.readInt32BE(ye * 4), e[ye + 1] = t.readInt32BE(ye * 4 + 4);
    for (; ye < 160; ye += 2) {
      var Re = e[ye - 30], xe = e[ye - 15 * 2 + 1], ke = Yp(Re, xe), Me = Jp(xe, Re);
      Re = e[ye - 2 * 2], xe = e[ye - 2 * 2 + 1];
      var Ce = $p(Re, xe), Ee = Qp(xe, Re), Ne = e[ye - 7 * 2], S = e[ye - 7 * 2 + 1], v = e[ye - 16 * 2], _ = e[ye - 16 * 2 + 1], c = Me + S | 0, f = ke + Ne + je(c, Me) | 0;
      c = c + Ee | 0, f = f + Ce + je(c, Ee) | 0, c = c + _ | 0, f = f + v + je(c, _) | 0, e[ye] = f, e[ye + 1] = c;
    }
    for (var a = 0; a < 160; a += 2) {
      f = e[a], c = e[a + 1];
      var u = oh(r, n, i), l = oh(M, E, A), d = hh(r, M), h = hh(M, r), b = uh(p, D), m = uh(D, p), s = ah[a], g = ah[a + 1], q = sh(p, y, w), R2 = sh(D, C, ge), B = L + m | 0, P = x + b + je(B, L) | 0;
      B = B + R2 | 0, P = P + q + je(B, R2) | 0, B = B + g | 0, P = P + s + je(B, g) | 0, B = B + c | 0, P = P + f + je(B, c) | 0;
      var T = h + l | 0, N2 = d + u + je(T, h) | 0;
      x = w, L = ge, w = y, ge = C, y = p, C = D, D = I + B | 0, p = o + P + je(D, I) | 0, o = i, I = A, i = n, A = E, n = r, E = M, M = B + T | 0, r = P + N2 + je(M, B) | 0;
    }
    this._al = this._al + M | 0, this._bl = this._bl + E | 0, this._cl = this._cl + A | 0, this._dl = this._dl + I | 0, this._el = this._el + D | 0, this._fl = this._fl + C | 0, this._gl = this._gl + ge | 0, this._hl = this._hl + L | 0, this._ah = this._ah + r + je(this._al, M) | 0, this._bh = this._bh + n + je(this._bl, E) | 0, this._ch = this._ch + i + je(this._cl, A) | 0, this._dh = this._dh + o + je(this._dl, I) | 0, this._eh = this._eh + p + je(this._el, D) | 0, this._fh = this._fh + y + je(this._fl, C) | 0, this._gh = this._gh + w + je(this._gl, ge) | 0, this._hh = this._hh + x + je(this._hl, L) | 0;
  };
  Ef.prototype._hash = function() {
    var t = Gp.allocUnsafe(64);
    function e(r, n, i) {
      t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
  };
  ch.exports = Ef;
});
var vh = k2((l5, lh) => {
  var e2 = qe(), t2 = Ja(), r2 = di(), i2 = Ae().Buffer, f2 = new Array(160);
  function yn() {
    this.init(), this._w = f2, r2.call(this, 128, 112);
  }
  e2(yn, t2);
  yn.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  yn.prototype._hash = function() {
    var t = i2.allocUnsafe(48);
    function e(r, n, i) {
      t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
  };
  lh.exports = yn;
});
var _n = k2((lr, ph) => {
  var lr = ph.exports = function(e) {
    e = e.toLowerCase();
    var r = lr[e];
    if (!r)
      throw new Error(e + " is not supported (we accept pull requests)");
    return new r();
  };
  lr.sha = $o();
  lr.sha1 = th();
  lr.sha224 = nh();
  lr.sha256 = Ya();
  lr.sha384 = vh();
  lr.sha512 = Ja();
});
var vr2 = k2((v5, gh) => {
  var bh = Ae().Buffer, mh = stream_default.Transform, n2 = string_decoder_default2.StringDecoder, a2 = qe();
  function Ft(t) {
    mh.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  a2(Ft, mh);
  Ft.prototype.update = function(t, e, r) {
    typeof t == "string" && (t = bh.from(t, e));
    var n = this._update(t);
    return this.hashMode ? this : (r && (n = this._toString(n, r)), n);
  };
  Ft.prototype.setAutoPadding = function() {
  };
  Ft.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  Ft.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  Ft.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  Ft.prototype._transform = function(t, e, r) {
    var n;
    try {
      this.hashMode ? this._update(t) : this.push(this._update(t));
    } catch (i) {
      n = i;
    } finally {
      r(n);
    }
  };
  Ft.prototype._flush = function(t) {
    var e;
    try {
      this.push(this.__final());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Ft.prototype._finalOrDigest = function(t) {
    var e = this.__final() || bh.alloc(0);
    return t && (e = this._toString(e, t, true)), e;
  };
  Ft.prototype._toString = function(t, e, r) {
    if (this._decoder || (this._decoder = new n2(e), this._encoding = e), this._encoding !== e)
      throw new Error("can't switch encodings");
    var n = this._decoder.write(t);
    return r && (n += this._decoder.end()), n;
  };
  gh.exports = Ft;
});
var Ni = k2((p5, _h) => {
  "use strict";
  var s2 = qe(), o2 = vn(), h2 = bn(), u2 = _n(), yh = vr2();
  function wn(t) {
    yh.call(this, "digest"), this._hash = t;
  }
  s2(wn, yh);
  wn.prototype._update = function(t) {
    this._hash.update(t);
  };
  wn.prototype._final = function() {
    return this._hash.digest();
  };
  _h.exports = function(e) {
    return e = e.toLowerCase(), e === "md5" ? new o2() : e === "rmd160" || e === "ripemd160" ? new h2() : new wn(u2(e));
  };
});
var Mh = k2((b5, xh) => {
  "use strict";
  var d2 = qe(), ci = Ae().Buffer, wh = vr2(), c2 = ci.alloc(128), Li = 64;
  function xn(t, e) {
    wh.call(this, "digest"), typeof e == "string" && (e = ci.from(e)), this._alg = t, this._key = e, e.length > Li ? e = t(e) : e.length < Li && (e = ci.concat([e, c2], Li));
    for (var r = this._ipad = ci.allocUnsafe(Li), n = this._opad = ci.allocUnsafe(Li), i = 0; i < Li; i++)
      r[i] = e[i] ^ 54, n[i] = e[i] ^ 92;
    this._hash = [r];
  }
  d2(xn, wh);
  xn.prototype._update = function(t) {
    this._hash.push(t);
  };
  xn.prototype._final = function() {
    var t = this._alg(ci.concat(this._hash));
    return this._alg(ci.concat([this._opad, t]));
  };
  xh.exports = xn;
});
var $a = k2((m5, Sh) => {
  var l2 = vn();
  Sh.exports = function(t) {
    return new l2().update(t).digest();
  };
});
var t0 = k2((g5, Ah) => {
  "use strict";
  var v2 = qe(), p2 = Mh(), Eh = vr2(), Af = Ae().Buffer, b2 = $a(), Qa = bn(), e0 = _n(), m2 = Af.alloc(128);
  function qf(t, e) {
    Eh.call(this, "digest"), typeof e == "string" && (e = Af.from(e));
    var r = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r) {
      var n = t === "rmd160" ? new Qa() : e0(t);
      e = n.update(e).digest();
    } else
      e.length < r && (e = Af.concat([e, m2], r));
    for (var i = this._ipad = Af.allocUnsafe(r), o = this._opad = Af.allocUnsafe(r), p = 0; p < r; p++)
      i[p] = e[p] ^ 54, o[p] = e[p] ^ 92;
    this._hash = t === "rmd160" ? new Qa() : e0(t), this._hash.update(i);
  }
  v2(qf, Eh);
  qf.prototype._update = function(t) {
    this._hash.update(t);
  };
  qf.prototype._final = function() {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new Qa() : e0(this._alg);
    return e.update(this._opad).update(t).digest();
  };
  Ah.exports = function(e, r) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new qf("rmd160", r) : e === "md5" ? new p2(b2, r) : new qf(e, r);
  };
});
var r0 = k2((y5, g2) => {
  g2.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
});
var Bh = k2((_5, qh) => {
  qh.exports = r0();
});
var i0 = k2((w5, Rh) => {
  var y2 = Math.pow(2, 30) - 1;
  Rh.exports = function(t, e) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > y2 || e !== e)
      throw new TypeError("Bad key length");
  };
});
var f0 = k2((x5, kh) => {
  var Mn;
  process_default && process_default.browser ? Mn = "utf-8" : process_default && process_default.version ? (Ih = parseInt(process_default.version.split(".")[0].slice(1), 10), Mn = Ih >= 6 ? "utf-8" : "binary") : Mn = "utf-8";
  var Ih;
  kh.exports = Mn;
});
var a0 = k2((M5, Dh) => {
  var n0 = Ae().Buffer;
  Dh.exports = function(t, e, r) {
    if (n0.isBuffer(t))
      return t;
    if (typeof t == "string")
      return n0.from(t, e);
    if (ArrayBuffer.isView(t))
      return n0.from(t.buffer);
    throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var s0 = k2((S5, Nh) => {
  var _2 = $a(), w2 = bn(), x2 = _n(), li = Ae().Buffer, M2 = i0(), Ph = f0(), Th = a0(), S2 = li.alloc(128), Sn = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function Ch(t, e, r) {
    var n = E2(t), i = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > i ? e = n(e) : e.length < i && (e = li.concat([e, S2], i));
    for (var o = li.allocUnsafe(i + Sn[t]), p = li.allocUnsafe(i + Sn[t]), y = 0; y < i; y++)
      o[y] = e[y] ^ 54, p[y] = e[y] ^ 92;
    var w = li.allocUnsafe(i + r + 4);
    o.copy(w, 0, 0, i), this.ipad1 = w, this.ipad2 = o, this.opad = p, this.alg = t, this.blocksize = i, this.hash = n, this.size = Sn[t];
  }
  Ch.prototype.run = function(t, e) {
    t.copy(e, this.blocksize);
    var r = this.hash(e);
    return r.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function E2(t) {
    function e(n) {
      return x2(t).update(n).digest();
    }
    function r(n) {
      return new w2().update(n).digest();
    }
    return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? _2 : e;
  }
  function A2(t, e, r, n, i) {
    M2(r, n), t = Th(t, Ph, "Password"), e = Th(e, Ph, "Salt"), i = i || "sha1";
    var o = new Ch(i, t, e.length), p = li.allocUnsafe(n), y = li.allocUnsafe(e.length + 4);
    e.copy(y, 0, 0, e.length);
    for (var w = 0, x = Sn[i], M = Math.ceil(n / x), E = 1; E <= M; E++) {
      y.writeUInt32BE(E, e.length);
      for (var A = o.run(y, o.ipad1), I = A, D = 1; D < r; D++) {
        I = o.run(I, o.ipad2);
        for (var C = 0; C < x; C++)
          A[C] ^= I[C];
      }
      A.copy(p, w), w += x;
    }
    return p;
  }
  Nh.exports = A2;
});
var Kh = k2((E5, Fh) => {
  var Uh = Ae().Buffer, q2 = i0(), Lh = f0(), Oh = s0(), zh = a0(), En, Bf = __global$.crypto && __global$.crypto.subtle, B2 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, o0 = [];
  function R2(t) {
    if (process_default && !process_default.browser || !Bf || !Bf.importKey || !Bf.deriveBits)
      return Promise.resolve(false);
    if (o0[t] !== void 0)
      return o0[t];
    En = En || Uh.alloc(8);
    var e = Hh(En, En, 10, 128, t).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return o0[t] = e, e;
  }
  var vi;
  function h0() {
    return vi || (process_default && process_default.nextTick ? vi = process_default.nextTick : __global$.queueMicrotask ? vi = __global$.queueMicrotask : __setImmediate$ ? vi = __setImmediate$ : vi = __global$.setTimeout, vi);
  }
  function Hh(t, e, r, n, i) {
    return Bf.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(o) {
      return Bf.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: i } }, o, n << 3);
    }).then(function(o) {
      return Uh.from(o);
    });
  }
  function I2(t, e) {
    t.then(function(r) {
      h0()(function() {
        e(null, r);
      });
    }, function(r) {
      h0()(function() {
        e(r);
      });
    });
  }
  Fh.exports = function(t, e, r, n, i, o) {
    typeof i == "function" && (o = i, i = void 0), i = i || "sha1";
    var p = B2[i.toLowerCase()];
    if (!p || typeof __global$.Promise != "function") {
      h0()(function() {
        var y;
        try {
          y = Oh(t, e, r, n, i);
        } catch (w) {
          return o(w);
        }
        o(null, y);
      });
      return;
    }
    if (q2(r, n), t = zh(t, Lh, "Password"), e = zh(e, Lh, "Salt"), typeof o != "function")
      throw new Error("No callback provided to pbkdf2");
    I2(R2(p).then(function(y) {
      return y ? Hh(t, e, r, n, p) : Oh(t, e, r, n, i);
    }), o);
  };
});
var d0 = k2((u0) => {
  u0.pbkdf2 = Kh();
  u0.pbkdf2Sync = s0();
});
var c0 = k2((vt) => {
  "use strict";
  vt.readUInt32BE = function(e, r) {
    var n = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
    return n >>> 0;
  };
  vt.writeUInt32BE = function(e, r, n) {
    e[0 + n] = r >>> 24, e[1 + n] = r >>> 16 & 255, e[2 + n] = r >>> 8 & 255, e[3 + n] = r & 255;
  };
  vt.ip = function(e, r, n, i) {
    for (var o = 0, p = 0, y = 6; y >= 0; y -= 2) {
      for (var w = 0; w <= 24; w += 8)
        o <<= 1, o |= r >>> w + y & 1;
      for (var w = 0; w <= 24; w += 8)
        o <<= 1, o |= e >>> w + y & 1;
    }
    for (var y = 6; y >= 0; y -= 2) {
      for (var w = 1; w <= 25; w += 8)
        p <<= 1, p |= r >>> w + y & 1;
      for (var w = 1; w <= 25; w += 8)
        p <<= 1, p |= e >>> w + y & 1;
    }
    n[i + 0] = o >>> 0, n[i + 1] = p >>> 0;
  };
  vt.rip = function(e, r, n, i) {
    for (var o = 0, p = 0, y = 0; y < 4; y++)
      for (var w = 24; w >= 0; w -= 8)
        o <<= 1, o |= r >>> w + y & 1, o <<= 1, o |= e >>> w + y & 1;
    for (var y = 4; y < 8; y++)
      for (var w = 24; w >= 0; w -= 8)
        p <<= 1, p |= r >>> w + y & 1, p <<= 1, p |= e >>> w + y & 1;
    n[i + 0] = o >>> 0, n[i + 1] = p >>> 0;
  };
  vt.pc1 = function(e, r, n, i) {
    for (var o = 0, p = 0, y = 7; y >= 5; y--) {
      for (var w = 0; w <= 24; w += 8)
        o <<= 1, o |= r >> w + y & 1;
      for (var w = 0; w <= 24; w += 8)
        o <<= 1, o |= e >> w + y & 1;
    }
    for (var w = 0; w <= 24; w += 8)
      o <<= 1, o |= r >> w + y & 1;
    for (var y = 1; y <= 3; y++) {
      for (var w = 0; w <= 24; w += 8)
        p <<= 1, p |= r >> w + y & 1;
      for (var w = 0; w <= 24; w += 8)
        p <<= 1, p |= e >> w + y & 1;
    }
    for (var w = 0; w <= 24; w += 8)
      p <<= 1, p |= e >> w + y & 1;
    n[i + 0] = o >>> 0, n[i + 1] = p >>> 0;
  };
  vt.r28shl = function(e, r) {
    return e << r & 268435455 | e >>> 28 - r;
  };
  var An = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  vt.pc2 = function(e, r, n, i) {
    for (var o = 0, p = 0, y = An.length >>> 1, w = 0; w < y; w++)
      o <<= 1, o |= e >>> An[w] & 1;
    for (var w = y; w < An.length; w++)
      p <<= 1, p |= r >>> An[w] & 1;
    n[i + 0] = o >>> 0, n[i + 1] = p >>> 0;
  };
  vt.expand = function(e, r, n) {
    var i = 0, o = 0;
    i = (e & 1) << 5 | e >>> 27;
    for (var p = 23; p >= 15; p -= 4)
      i <<= 6, i |= e >>> p & 63;
    for (var p = 11; p >= 3; p -= 4)
      o |= e >>> p & 63, o <<= 6;
    o |= (e & 31) << 1 | e >>> 31, r[n + 0] = i >>> 0, r[n + 1] = o >>> 0;
  };
  var jh = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  vt.substitute = function(e, r) {
    for (var n = 0, i = 0; i < 4; i++) {
      var o = e >>> 18 - i * 6 & 63, p = jh[i * 64 + o];
      n <<= 4, n |= p;
    }
    for (var i = 0; i < 4; i++) {
      var o = r >>> 18 - i * 6 & 63, p = jh[4 * 64 + i * 64 + o];
      n <<= 4, n |= p;
    }
    return n >>> 0;
  };
  var Wh = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  vt.permute = function(e) {
    for (var r = 0, n = 0; n < Wh.length; n++)
      r <<= 1, r |= e >>> Wh[n] & 1;
    return r >>> 0;
  };
  vt.padSplit = function(e, r, n) {
    for (var i = e.toString(2); i.length < r; )
      i = "0" + i;
    for (var o = [], p = 0; p < r; p += n)
      o.push(i.slice(p, p + n));
    return o.join(" ");
  };
});
var ot = k2((B5, Zh) => {
  Zh.exports = Vh;
  function Vh(t, e) {
    if (!t)
      throw new Error(e || "Assertion failed");
  }
  Vh.equal = function(e, r, n) {
    if (e != r)
      throw new Error(n || "Assertion failed: " + e + " != " + r);
  };
});
var qn = k2((R5, Gh) => {
  "use strict";
  var k22 = ot();
  function pt(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  Gh.exports = pt;
  pt.prototype._init = function() {
  };
  pt.prototype.update = function(e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
  };
  pt.prototype._buffer = function(e, r) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, e.length - r), i = 0; i < n; i++)
      this.buffer[this.bufferOff + i] = e[r + i];
    return this.bufferOff += n, n;
  };
  pt.prototype._flushBuffer = function(e, r) {
    return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
  };
  pt.prototype._updateEncrypt = function(e) {
    var r = 0, n = 0, i = (this.bufferOff + e.length) / this.blockSize | 0, o = new Array(i * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (n += this._flushBuffer(o, n)));
    for (var p = e.length - (e.length - r) % this.blockSize; r < p; r += this.blockSize)
      this._update(e, r, o, n), n += this.blockSize;
    for (; r < e.length; r++, this.bufferOff++)
      this.buffer[this.bufferOff] = e[r];
    return o;
  };
  pt.prototype._updateDecrypt = function(e) {
    for (var r = 0, n = 0, i = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, o = new Array(i * this.blockSize); i > 0; i--)
      r += this._buffer(e, r), n += this._flushBuffer(o, n);
    return r += this._buffer(e, r), o;
  };
  pt.prototype.final = function(e) {
    var r;
    e && (r = this.update(e));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), r ? r.concat(n) : n;
  };
  pt.prototype._pad = function(e, r) {
    if (r === 0)
      return false;
    for (; r < e.length; )
      e[r++] = 0;
    return true;
  };
  pt.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e;
  };
  pt.prototype._unpad = function(e) {
    return e;
  };
  pt.prototype._finalDecrypt = function() {
    k22.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e);
  };
});
var l0 = k2((I5, Jh) => {
  "use strict";
  var Xh = ot(), D2 = qe(), He = c0(), Yh = qn();
  function P2() {
    this.tmp = new Array(2), this.keys = null;
  }
  function rr(t) {
    Yh.call(this, t);
    var e = new P2();
    this._desState = e, this.deriveKeys(e, t.key);
  }
  D2(rr, Yh);
  Jh.exports = rr;
  rr.create = function(e) {
    return new rr(e);
  };
  var T2 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  rr.prototype.deriveKeys = function(e, r) {
    e.keys = new Array(16 * 2), Xh.equal(r.length, this.blockSize, "Invalid key length");
    var n = He.readUInt32BE(r, 0), i = He.readUInt32BE(r, 4);
    He.pc1(n, i, e.tmp, 0), n = e.tmp[0], i = e.tmp[1];
    for (var o = 0; o < e.keys.length; o += 2) {
      var p = T2[o >>> 1];
      n = He.r28shl(n, p), i = He.r28shl(i, p), He.pc2(n, i, e.keys, o);
    }
  };
  rr.prototype._update = function(e, r, n, i) {
    var o = this._desState, p = He.readUInt32BE(e, r), y = He.readUInt32BE(e, r + 4);
    He.ip(p, y, o.tmp, 0), p = o.tmp[0], y = o.tmp[1], this.type === "encrypt" ? this._encrypt(o, p, y, o.tmp, 0) : this._decrypt(o, p, y, o.tmp, 0), p = o.tmp[0], y = o.tmp[1], He.writeUInt32BE(n, p, i), He.writeUInt32BE(n, y, i + 4);
  };
  rr.prototype._pad = function(e, r) {
    for (var n = e.length - r, i = r; i < e.length; i++)
      e[i] = n;
    return true;
  };
  rr.prototype._unpad = function(e) {
    for (var r = e[e.length - 1], n = e.length - r; n < e.length; n++)
      Xh.equal(e[n], r);
    return e.slice(0, e.length - r);
  };
  rr.prototype._encrypt = function(e, r, n, i, o) {
    for (var p = r, y = n, w = 0; w < e.keys.length; w += 2) {
      var x = e.keys[w], M = e.keys[w + 1];
      He.expand(y, e.tmp, 0), x ^= e.tmp[0], M ^= e.tmp[1];
      var E = He.substitute(x, M), A = He.permute(E), I = y;
      y = (p ^ A) >>> 0, p = I;
    }
    He.rip(y, p, i, o);
  };
  rr.prototype._decrypt = function(e, r, n, i, o) {
    for (var p = n, y = r, w = e.keys.length - 2; w >= 0; w -= 2) {
      var x = e.keys[w], M = e.keys[w + 1];
      He.expand(p, e.tmp, 0), x ^= e.tmp[0], M ^= e.tmp[1];
      var E = He.substitute(x, M), A = He.permute(E), I = p;
      p = (y ^ A) >>> 0, y = I;
    }
    He.rip(p, y, i, o);
  };
});
var Qh = k2(($h) => {
  "use strict";
  var C2 = ot(), N2 = qe(), Bn = {};
  function L2(t) {
    C2.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0; e < this.iv.length; e++)
      this.iv[e] = t[e];
  }
  function O2(t) {
    function e(o) {
      t.call(this, o), this._cbcInit();
    }
    N2(e, t);
    for (var r = Object.keys(Bn), n = 0; n < r.length; n++) {
      var i = r[n];
      e.prototype[i] = Bn[i];
    }
    return e.create = function(p) {
      return new e(p);
    }, e;
  }
  $h.instantiate = O2;
  Bn._cbcInit = function() {
    var e = new L2(this.options.iv);
    this._cbcState = e;
  };
  Bn._update = function(e, r, n, i) {
    var o = this._cbcState, p = this.constructor.super_.prototype, y = o.iv;
    if (this.type === "encrypt") {
      for (var w = 0; w < this.blockSize; w++)
        y[w] ^= e[r + w];
      p._update.call(this, y, 0, n, i);
      for (var w = 0; w < this.blockSize; w++)
        y[w] = n[i + w];
    } else {
      p._update.call(this, e, r, n, i);
      for (var w = 0; w < this.blockSize; w++)
        n[i + w] ^= y[w];
      for (var w = 0; w < this.blockSize; w++)
        y[w] = e[r + w];
    }
  };
});
var ru = k2((D5, tu) => {
  "use strict";
  var z2 = ot(), U2 = qe(), eu = qn(), Vr = l0();
  function H2(t, e) {
    z2.equal(e.length, 24, "Invalid key length");
    var r = e.slice(0, 8), n = e.slice(8, 16), i = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [Vr.create({ type: "encrypt", key: r }), Vr.create({ type: "decrypt", key: n }), Vr.create({ type: "encrypt", key: i })] : this.ciphers = [Vr.create({ type: "decrypt", key: i }), Vr.create({ type: "encrypt", key: n }), Vr.create({ type: "decrypt", key: r })];
  }
  function pi(t) {
    eu.call(this, t);
    var e = new H2(this.type, this.options.key);
    this._edeState = e;
  }
  U2(pi, eu);
  tu.exports = pi;
  pi.create = function(e) {
    return new pi(e);
  };
  pi.prototype._update = function(e, r, n, i) {
    var o = this._edeState;
    o.ciphers[0]._update(e, r, n, i), o.ciphers[1]._update(n, i, n, i), o.ciphers[2]._update(n, i, n, i);
  };
  pi.prototype._pad = Vr.prototype._pad;
  pi.prototype._unpad = Vr.prototype._unpad;
});
var iu = k2((Oi) => {
  "use strict";
  Oi.utils = c0();
  Oi.Cipher = qn();
  Oi.DES = l0();
  Oi.CBC = Qh();
  Oi.EDE = ru();
});
var au = k2((T5, nu) => {
  var fu = vr2(), pr = iu(), F2 = qe(), bi = Ae().Buffer, Rf = { "des-ede3-cbc": pr.CBC.instantiate(pr.EDE), "des-ede3": pr.EDE, "des-ede-cbc": pr.CBC.instantiate(pr.EDE), "des-ede": pr.EDE, "des-cbc": pr.CBC.instantiate(pr.DES), "des-ecb": pr.DES };
  Rf.des = Rf["des-cbc"];
  Rf.des3 = Rf["des-ede3-cbc"];
  nu.exports = Rn;
  F2(Rn, fu);
  function Rn(t) {
    fu.call(this);
    var e = t.mode.toLowerCase(), r = Rf[e], n;
    t.decrypt ? n = "decrypt" : n = "encrypt";
    var i = t.key;
    bi.isBuffer(i) || (i = bi.from(i)), (e === "des-ede" || e === "des-ede-cbc") && (i = bi.concat([i, i.slice(0, 8)]));
    var o = t.iv;
    bi.isBuffer(o) || (o = bi.from(o)), this._des = r.create({ key: i, iv: o, type: n });
  }
  Rn.prototype._update = function(t) {
    return bi.from(this._des.update(t));
  };
  Rn.prototype._final = function() {
    return bi.from(this._des.final());
  };
});
var su = k2((v0) => {
  v0.encrypt = function(t, e) {
    return t._cipher.encryptBlock(e);
  };
  v0.decrypt = function(t, e) {
    return t._cipher.decryptBlock(e);
  };
});
var zi = k2((N5, ou) => {
  ou.exports = function(e, r) {
    for (var n = Math.min(e.length, r.length), i = new Buffer3(n), o = 0; o < n; ++o)
      i[o] = e[o] ^ r[o];
    return i;
  };
});
var uu = k2((p0) => {
  var hu = zi();
  p0.encrypt = function(t, e) {
    var r = hu(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev;
  };
  p0.decrypt = function(t, e) {
    var r = t._prev;
    t._prev = e;
    var n = t._cipher.decryptBlock(e);
    return hu(n, r);
  };
});
var lu = k2((cu) => {
  var If = Ae().Buffer, K2 = zi();
  function du(t, e, r) {
    var n = e.length, i = K2(e, t._cache);
    return t._cache = t._cache.slice(n), t._prev = If.concat([t._prev, r ? e : i]), i;
  }
  cu.encrypt = function(t, e, r) {
    for (var n = If.allocUnsafe(0), i; e.length; )
      if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = If.allocUnsafe(0)), t._cache.length <= e.length)
        i = t._cache.length, n = If.concat([n, du(t, e.slice(0, i), r)]), e = e.slice(i);
      else {
        n = If.concat([n, du(t, e, r)]);
        break;
      }
    return n;
  };
});
var pu = k2((vu) => {
  var b0 = Ae().Buffer;
  function j2(t, e, r) {
    var n = t._cipher.encryptBlock(t._prev), i = n[0] ^ e;
    return t._prev = b0.concat([t._prev.slice(1), b0.from([r ? e : i])]), i;
  }
  vu.encrypt = function(t, e, r) {
    for (var n = e.length, i = b0.allocUnsafe(n), o = -1; ++o < n; )
      i[o] = j2(t, e[o], r);
    return i;
  };
});
var mu = k2((bu) => {
  var In = Ae().Buffer;
  function W2(t, e, r) {
    for (var n, i = -1, o = 8, p = 0, y, w; ++i < o; )
      n = t._cipher.encryptBlock(t._prev), y = e & 1 << 7 - i ? 128 : 0, w = n[0] ^ y, p += (w & 128) >> i % 8, t._prev = V2(t._prev, r ? y : w);
    return p;
  }
  function V2(t, e) {
    var r = t.length, n = -1, i = In.allocUnsafe(t.length);
    for (t = In.concat([t, In.from([e])]); ++n < r; )
      i[n] = t[n] << 1 | t[n + 1] >> 7;
    return i;
  }
  bu.encrypt = function(t, e, r) {
    for (var n = e.length, i = In.allocUnsafe(n), o = -1; ++o < n; )
      i[o] = W2(t, e[o], r);
    return i;
  };
});
var yu = k2((gu) => {
  var Z2 = zi();
  function G2(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  gu.encrypt = function(t, e) {
    for (; t._cache.length < e.length; )
      t._cache = Buffer3.concat([t._cache, G2(t)]);
    var r = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), Z2(e, r);
  };
});
var m0 = k2((F5, _u) => {
  function X2(t) {
    for (var e = t.length, r; e--; )
      if (r = t.readUInt8(e), r === 255)
        t.writeUInt8(0, e);
      else {
        r++, t.writeUInt8(r, e);
        break;
      }
  }
  _u.exports = X2;
});
var y0 = k2((xu) => {
  var Y2 = zi(), wu = Ae().Buffer, J2 = m0();
  function $2(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return J2(t._prev), e;
  }
  var g0 = 16;
  xu.encrypt = function(t, e) {
    var r = Math.ceil(e.length / g0), n = t._cache.length;
    t._cache = wu.concat([t._cache, wu.allocUnsafe(r * g0)]);
    for (var i = 0; i < r; i++) {
      var o = $2(t), p = n + i * g0;
      t._cache.writeUInt32BE(o[0], p + 0), t._cache.writeUInt32BE(o[1], p + 4), t._cache.writeUInt32BE(o[2], p + 8), t._cache.writeUInt32BE(o[3], p + 12);
    }
    var y = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), Y2(e, y);
  };
});
var _0 = k2((j5, Q2) => {
  Q2.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
});
var Dn = k2((W5, Mu) => {
  var eb = { ECB: su(), CBC: uu(), CFB: lu(), CFB8: pu(), CFB1: mu(), OFB: yu(), CTR: y0(), GCM: y0() }, kn = _0();
  for (w0 in kn)
    kn[w0].module = eb[kn[w0].mode];
  var w0;
  Mu.exports = kn;
});
var kf = k2((V5, Eu) => {
  var Pn = Ae().Buffer;
  function M0(t) {
    Pn.isBuffer(t) || (t = Pn.from(t));
    for (var e = t.length / 4 | 0, r = new Array(e), n = 0; n < e; n++)
      r[n] = t.readUInt32BE(n * 4);
    return r;
  }
  function x0(t) {
    for (var e = 0; e < t.length; t++)
      t[e] = 0;
  }
  function Su(t, e, r, n, i) {
    for (var o = r[0], p = r[1], y = r[2], w = r[3], x = t[0] ^ e[0], M = t[1] ^ e[1], E = t[2] ^ e[2], A = t[3] ^ e[3], I, D, C, ge, L = 4, ye = 1; ye < i; ye++)
      I = o[x >>> 24] ^ p[M >>> 16 & 255] ^ y[E >>> 8 & 255] ^ w[A & 255] ^ e[L++], D = o[M >>> 24] ^ p[E >>> 16 & 255] ^ y[A >>> 8 & 255] ^ w[x & 255] ^ e[L++], C = o[E >>> 24] ^ p[A >>> 16 & 255] ^ y[x >>> 8 & 255] ^ w[M & 255] ^ e[L++], ge = o[A >>> 24] ^ p[x >>> 16 & 255] ^ y[M >>> 8 & 255] ^ w[E & 255] ^ e[L++], x = I, M = D, E = C, A = ge;
    return I = (n[x >>> 24] << 24 | n[M >>> 16 & 255] << 16 | n[E >>> 8 & 255] << 8 | n[A & 255]) ^ e[L++], D = (n[M >>> 24] << 24 | n[E >>> 16 & 255] << 16 | n[A >>> 8 & 255] << 8 | n[x & 255]) ^ e[L++], C = (n[E >>> 24] << 24 | n[A >>> 16 & 255] << 16 | n[x >>> 8 & 255] << 8 | n[M & 255]) ^ e[L++], ge = (n[A >>> 24] << 24 | n[x >>> 16 & 255] << 16 | n[M >>> 8 & 255] << 8 | n[E & 255]) ^ e[L++], I = I >>> 0, D = D >>> 0, C = C >>> 0, ge = ge >>> 0, [I, D, C, ge];
  }
  var tb = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Ue = function() {
    for (var t = new Array(256), e = 0; e < 256; e++)
      e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r = [], n = [], i = [[], [], [], []], o = [[], [], [], []], p = 0, y = 0, w = 0; w < 256; ++w) {
      var x = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
      x = x >>> 8 ^ x & 255 ^ 99, r[p] = x, n[x] = p;
      var M = t[p], E = t[M], A = t[E], I = t[x] * 257 ^ x * 16843008;
      i[0][p] = I << 24 | I >>> 8, i[1][p] = I << 16 | I >>> 16, i[2][p] = I << 8 | I >>> 24, i[3][p] = I, I = A * 16843009 ^ E * 65537 ^ M * 257 ^ p * 16843008, o[0][x] = I << 24 | I >>> 8, o[1][x] = I << 16 | I >>> 16, o[2][x] = I << 8 | I >>> 24, o[3][x] = I, p === 0 ? p = y = 1 : (p = M ^ t[t[t[A ^ M]]], y ^= t[t[y]]);
    }
    return { SBOX: r, INV_SBOX: n, SUB_MIX: i, INV_SUB_MIX: o };
  }();
  function bt(t) {
    this._key = M0(t), this._reset();
  }
  bt.blockSize = 4 * 4;
  bt.keySize = 256 / 8;
  bt.prototype.blockSize = bt.blockSize;
  bt.prototype.keySize = bt.keySize;
  bt.prototype._reset = function() {
    for (var t = this._key, e = t.length, r = e + 6, n = (r + 1) * 4, i = [], o = 0; o < e; o++)
      i[o] = t[o];
    for (o = e; o < n; o++) {
      var p = i[o - 1];
      o % e === 0 ? (p = p << 8 | p >>> 24, p = Ue.SBOX[p >>> 24] << 24 | Ue.SBOX[p >>> 16 & 255] << 16 | Ue.SBOX[p >>> 8 & 255] << 8 | Ue.SBOX[p & 255], p ^= tb[o / e | 0] << 24) : e > 6 && o % e === 4 && (p = Ue.SBOX[p >>> 24] << 24 | Ue.SBOX[p >>> 16 & 255] << 16 | Ue.SBOX[p >>> 8 & 255] << 8 | Ue.SBOX[p & 255]), i[o] = i[o - e] ^ p;
    }
    for (var y = [], w = 0; w < n; w++) {
      var x = n - w, M = i[x - (w % 4 ? 0 : 4)];
      w < 4 || x <= 4 ? y[w] = M : y[w] = Ue.INV_SUB_MIX[0][Ue.SBOX[M >>> 24]] ^ Ue.INV_SUB_MIX[1][Ue.SBOX[M >>> 16 & 255]] ^ Ue.INV_SUB_MIX[2][Ue.SBOX[M >>> 8 & 255]] ^ Ue.INV_SUB_MIX[3][Ue.SBOX[M & 255]];
    }
    this._nRounds = r, this._keySchedule = i, this._invKeySchedule = y;
  };
  bt.prototype.encryptBlockRaw = function(t) {
    return t = M0(t), Su(t, this._keySchedule, Ue.SUB_MIX, Ue.SBOX, this._nRounds);
  };
  bt.prototype.encryptBlock = function(t) {
    var e = this.encryptBlockRaw(t), r = Pn.allocUnsafe(16);
    return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
  };
  bt.prototype.decryptBlock = function(t) {
    t = M0(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r = Su(t, this._invKeySchedule, Ue.INV_SUB_MIX, Ue.INV_SBOX, this._nRounds), n = Pn.allocUnsafe(16);
    return n.writeUInt32BE(r[0], 0), n.writeUInt32BE(r[3], 4), n.writeUInt32BE(r[2], 8), n.writeUInt32BE(r[1], 12), n;
  };
  bt.prototype.scrub = function() {
    x0(this._keySchedule), x0(this._invKeySchedule), x0(this._key);
  };
  Eu.exports.AES = bt;
});
var Bu = k2((Z5, qu) => {
  var Ui = Ae().Buffer, rb = Ui.alloc(16, 0);
  function ib(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
  }
  function Au(t) {
    var e = Ui.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
  }
  function Df(t) {
    this.h = t, this.state = Ui.alloc(16, 0), this.cache = Ui.allocUnsafe(0);
  }
  Df.prototype.ghash = function(t) {
    for (var e = -1; ++e < t.length; )
      this.state[e] ^= t[e];
    this._multiply();
  };
  Df.prototype._multiply = function() {
    for (var t = ib(this.h), e = [0, 0, 0, 0], r, n, i, o = -1; ++o < 128; ) {
      for (n = (this.state[~~(o / 8)] & 1 << 7 - o % 8) !== 0, n && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), i = (t[3] & 1) !== 0, r = 3; r > 0; r--)
        t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
      t[0] = t[0] >>> 1, i && (t[0] = t[0] ^ 225 << 24);
    }
    this.state = Au(e);
  };
  Df.prototype.update = function(t) {
    this.cache = Ui.concat([this.cache, t]);
    for (var e; this.cache.length >= 16; )
      e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
  };
  Df.prototype.final = function(t, e) {
    return this.cache.length && this.ghash(Ui.concat([this.cache, rb], 16)), this.ghash(Au([0, t, 0, e])), this.state;
  };
  qu.exports = Df;
});
var S0 = k2((G5, ku) => {
  var fb = kf(), ft2 = Ae().Buffer, Ru = vr2(), nb = qe(), Iu = Bu(), ab = zi(), sb = m0();
  function ob(t, e) {
    var r = 0;
    t.length !== e.length && r++;
    for (var n = Math.min(t.length, e.length), i = 0; i < n; ++i)
      r += t[i] ^ e[i];
    return r;
  }
  function hb(t, e, r) {
    if (e.length === 12)
      return t._finID = ft2.concat([e, ft2.from([0, 0, 0, 1])]), ft2.concat([e, ft2.from([0, 0, 0, 2])]);
    var n = new Iu(r), i = e.length, o = i % 16;
    n.update(e), o && (o = 16 - o, n.update(ft2.alloc(o, 0))), n.update(ft2.alloc(8, 0));
    var p = i * 8, y = ft2.alloc(8);
    y.writeUIntBE(p, 0, 8), n.update(y), t._finID = n.state;
    var w = ft2.from(t._finID);
    return sb(w), w;
  }
  function mi(t, e, r, n) {
    Ru.call(this);
    var i = ft2.alloc(4, 0);
    this._cipher = new fb.AES(e);
    var o = this._cipher.encryptBlock(i);
    this._ghash = new Iu(o), r = hb(this, r, o), this._prev = ft2.from(r), this._cache = ft2.allocUnsafe(0), this._secCache = ft2.allocUnsafe(0), this._decrypt = n, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
  }
  nb(mi, Ru);
  mi.prototype._update = function(t) {
    if (!this._called && this._alen) {
      var e = 16 - this._alen % 16;
      e < 16 && (e = ft2.alloc(e, 0), this._ghash.update(e));
    }
    this._called = true;
    var r = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
  };
  mi.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var t = ab(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ob(t, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub();
  };
  mi.prototype.getAuthTag = function() {
    if (this._decrypt || !ft2.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  mi.prototype.setAuthTag = function(e) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e;
  };
  mi.prototype.setAAD = function(e) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length;
  };
  ku.exports = mi;
});
var A0 = k2((X5, Pu) => {
  var ub = kf(), E0 = Ae().Buffer, Du = vr2(), db = qe();
  function Tn(t, e, r, n) {
    Du.call(this), this._cipher = new ub.AES(e), this._prev = E0.from(r), this._cache = E0.allocUnsafe(0), this._secCache = E0.allocUnsafe(0), this._decrypt = n, this._mode = t;
  }
  db(Tn, Du);
  Tn.prototype._update = function(t) {
    return this._mode.encrypt(this, t, this._decrypt);
  };
  Tn.prototype._final = function() {
    this._cipher.scrub();
  };
  Pu.exports = Tn;
});
var Pf = k2((Y5, Tu) => {
  var gi = Ae().Buffer, cb = vn();
  function lb(t, e, r, n) {
    if (gi.isBuffer(t) || (t = gi.from(t, "binary")), e && (gi.isBuffer(e) || (e = gi.from(e, "binary")), e.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var i = r / 8, o = gi.alloc(i), p = gi.alloc(n || 0), y = gi.alloc(0); i > 0 || n > 0; ) {
      var w = new cb();
      w.update(y), w.update(t), e && w.update(e), y = w.digest();
      var x = 0;
      if (i > 0) {
        var M = o.length - i;
        x = Math.min(i, y.length), y.copy(o, M, 0, x), i -= x;
      }
      if (x < y.length && n > 0) {
        var E = p.length - n, A = Math.min(n, y.length - x);
        y.copy(p, E, x, x + A), n -= A;
      }
    }
    return y.fill(0), { key: o, iv: p };
  }
  Tu.exports = lb;
});
var Ou = k2((q0) => {
  var Cu = Dn(), vb = S0(), br = Ae().Buffer, pb = A0(), Nu = vr2(), bb = kf(), mb = Pf(), gb = qe();
  function Tf(t, e, r) {
    Nu.call(this), this._cache = new Cn(), this._cipher = new bb.AES(e), this._prev = br.from(r), this._mode = t, this._autopadding = true;
  }
  gb(Tf, Nu);
  Tf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(); )
      r = this._mode.encrypt(this, e), n.push(r);
    return br.concat(n);
  };
  var yb = br.alloc(16, 16);
  Tf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(yb))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  Tf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Cn() {
    this.cache = br.allocUnsafe(0);
  }
  Cn.prototype.add = function(t) {
    this.cache = br.concat([this.cache, t]);
  };
  Cn.prototype.get = function() {
    if (this.cache.length > 15) {
      var t = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), t;
    }
    return null;
  };
  Cn.prototype.flush = function() {
    for (var t = 16 - this.cache.length, e = br.allocUnsafe(t), r = -1; ++r < t; )
      e.writeUInt8(t, r);
    return br.concat([this.cache, e]);
  };
  function Lu(t, e, r) {
    var n = Cu[t.toLowerCase()];
    if (!n)
      throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = br.from(e)), e.length !== n.key / 8)
      throw new TypeError("invalid key length " + e.length);
    if (typeof r == "string" && (r = br.from(r)), n.mode !== "GCM" && r.length !== n.iv)
      throw new TypeError("invalid iv length " + r.length);
    return n.type === "stream" ? new pb(n.module, e, r) : n.type === "auth" ? new vb(n.module, e, r) : new Tf(n.module, e, r);
  }
  function _b(t, e) {
    var r = Cu[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var n = mb(e, false, r.key, r.iv);
    return Lu(t, n.key, n.iv);
  }
  q0.createCipheriv = Lu;
  q0.createCipher = _b;
});
var Fu = k2((B0) => {
  var wb = S0(), Hi = Ae().Buffer, zu = Dn(), xb = A0(), Uu = vr2(), Mb = kf(), Sb = Pf(), Eb = qe();
  function Cf(t, e, r) {
    Uu.call(this), this._cache = new Nn(), this._last = void 0, this._cipher = new Mb.AES(e), this._prev = Hi.from(r), this._mode = t, this._autopadding = true;
  }
  Eb(Cf, Uu);
  Cf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(this._autopadding); )
      r = this._mode.decrypt(this, e), n.push(r);
    return Hi.concat(n);
  };
  Cf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return Ab(this._mode.decrypt(this, t));
    if (t)
      throw new Error("data not multiple of block length");
  };
  Cf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Nn() {
    this.cache = Hi.allocUnsafe(0);
  }
  Nn.prototype.add = function(t) {
    this.cache = Hi.concat([this.cache, t]);
  };
  Nn.prototype.get = function(t) {
    var e;
    if (t) {
      if (this.cache.length > 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    } else if (this.cache.length >= 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null;
  };
  Nn.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function Ab(t) {
    var e = t[15];
    if (e < 1 || e > 16)
      throw new Error("unable to decrypt data");
    for (var r = -1; ++r < e; )
      if (t[r + (16 - e)] !== e)
        throw new Error("unable to decrypt data");
    if (e !== 16)
      return t.slice(0, 16 - e);
  }
  function Hu(t, e, r) {
    var n = zu[t.toLowerCase()];
    if (!n)
      throw new TypeError("invalid suite type");
    if (typeof r == "string" && (r = Hi.from(r)), n.mode !== "GCM" && r.length !== n.iv)
      throw new TypeError("invalid iv length " + r.length);
    if (typeof e == "string" && (e = Hi.from(e)), e.length !== n.key / 8)
      throw new TypeError("invalid key length " + e.length);
    return n.type === "stream" ? new xb(n.module, e, r, true) : n.type === "auth" ? new wb(n.module, e, r, true) : new Cf(n.module, e, r);
  }
  function qb(t, e) {
    var r = zu[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var n = Sb(e, false, r.key, r.iv);
    return Hu(t, n.key, n.iv);
  }
  B0.createDecipher = qb;
  B0.createDecipheriv = Hu;
});
var Ln = k2((Kt) => {
  var Ku = Ou(), ju = Fu(), Bb = _0();
  function Rb() {
    return Object.keys(Bb);
  }
  Kt.createCipher = Kt.Cipher = Ku.createCipher;
  Kt.createCipheriv = Kt.Cipheriv = Ku.createCipheriv;
  Kt.createDecipher = Kt.Decipher = ju.createDecipher;
  Kt.createDecipheriv = Kt.Decipheriv = ju.createDecipheriv;
  Kt.listCiphers = Kt.getCiphers = Rb;
});
var Wu = k2((mr) => {
  mr["des-ecb"] = { key: 8, iv: 0 };
  mr["des-cbc"] = mr.des = { key: 8, iv: 8 };
  mr["des-ede3-cbc"] = mr.des3 = { key: 24, iv: 8 };
  mr["des-ede3"] = { key: 24, iv: 0 };
  mr["des-ede-cbc"] = { key: 16, iv: 8 };
  mr["des-ede"] = { key: 16, iv: 0 };
});
var Yu = k2((jt) => {
  var Vu = au(), R0 = Ln(), Zr = Dn(), gr2 = Wu(), Zu = Pf();
  function Ib(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (Zr[t])
      r = Zr[t].key, n = Zr[t].iv;
    else if (gr2[t])
      r = gr2[t].key * 8, n = gr2[t].iv;
    else
      throw new TypeError("invalid suite type");
    var i = Zu(e, false, r, n);
    return Gu(t, i.key, i.iv);
  }
  function kb(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (Zr[t])
      r = Zr[t].key, n = Zr[t].iv;
    else if (gr2[t])
      r = gr2[t].key * 8, n = gr2[t].iv;
    else
      throw new TypeError("invalid suite type");
    var i = Zu(e, false, r, n);
    return Xu(t, i.key, i.iv);
  }
  function Gu(t, e, r) {
    if (t = t.toLowerCase(), Zr[t])
      return R0.createCipheriv(t, e, r);
    if (gr2[t])
      return new Vu({ key: e, iv: r, mode: t });
    throw new TypeError("invalid suite type");
  }
  function Xu(t, e, r) {
    if (t = t.toLowerCase(), Zr[t])
      return R0.createDecipheriv(t, e, r);
    if (gr2[t])
      return new Vu({ key: e, iv: r, mode: t, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function Db() {
    return Object.keys(gr2).concat(R0.getCiphers());
  }
  jt.createCipher = jt.Cipher = Ib;
  jt.createCipheriv = jt.Cipheriv = Gu;
  jt.createDecipher = jt.Decipher = kb;
  jt.createDecipheriv = jt.Decipheriv = Xu;
  jt.listCiphers = jt.getCiphers = Db;
});
var Fe = k2((Ju, I0) => {
  (function(t, e) {
    "use strict";
    function r(S, v) {
      if (!S)
        throw new Error(v || "Assertion failed");
    }
    function n(S, v) {
      S.super_ = v;
      var _ = function() {
      };
      _.prototype = v.prototype, S.prototype = new _(), S.prototype.constructor = S;
    }
    function i(S, v, _) {
      if (i.isBN(S))
        return S;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, S !== null && ((v === "le" || v === "be") && (_ = v, v = 10), this._init(S || 0, v || 10, _ || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = export_default.Buffer;
    } catch {
    }
    i.isBN = function(v) {
      return v instanceof i ? true : v !== null && typeof v == "object" && v.constructor.wordSize === i.wordSize && Array.isArray(v.words);
    }, i.max = function(v, _) {
      return v.cmp(_) > 0 ? v : _;
    }, i.min = function(v, _) {
      return v.cmp(_) < 0 ? v : _;
    }, i.prototype._init = function(v, _, c) {
      if (typeof v == "number")
        return this._initNumber(v, _, c);
      if (typeof v == "object")
        return this._initArray(v, _, c);
      _ === "hex" && (_ = 16), r(_ === (_ | 0) && _ >= 2 && _ <= 36), v = v.toString().replace(/\s+/g, "");
      var f = 0;
      v[0] === "-" && (f++, this.negative = 1), f < v.length && (_ === 16 ? this._parseHex(v, f, c) : (this._parseBase(v, _, f), c === "le" && this._initArray(this.toArray(), _, c)));
    }, i.prototype._initNumber = function(v, _, c) {
      v < 0 && (this.negative = 1, v = -v), v < 67108864 ? (this.words = [v & 67108863], this.length = 1) : v < 4503599627370496 ? (this.words = [v & 67108863, v / 67108864 & 67108863], this.length = 2) : (r(v < 9007199254740992), this.words = [v & 67108863, v / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), _, c);
    }, i.prototype._initArray = function(v, _, c) {
      if (r(typeof v.length == "number"), v.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(v.length / 3), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var a, u, l = 0;
      if (c === "be")
        for (f = v.length - 1, a = 0; f >= 0; f -= 3)
          u = v[f] | v[f - 1] << 8 | v[f - 2] << 16, this.words[a] |= u << l & 67108863, this.words[a + 1] = u >>> 26 - l & 67108863, l += 24, l >= 26 && (l -= 26, a++);
      else if (c === "le")
        for (f = 0, a = 0; f < v.length; f += 3)
          u = v[f] | v[f + 1] << 8 | v[f + 2] << 16, this.words[a] |= u << l & 67108863, this.words[a + 1] = u >>> 26 - l & 67108863, l += 24, l >= 26 && (l -= 26, a++);
      return this.strip();
    };
    function p(S, v) {
      var _ = S.charCodeAt(v);
      return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
    }
    function y(S, v, _) {
      var c = p(S, _);
      return _ - 1 >= v && (c |= p(S, _ - 1) << 4), c;
    }
    i.prototype._parseHex = function(v, _, c) {
      this.length = Math.ceil((v.length - _) / 6), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var a = 0, u = 0, l;
      if (c === "be")
        for (f = v.length - 1; f >= _; f -= 2)
          l = y(v, _, f) << a, this.words[u] |= l & 67108863, a >= 18 ? (a -= 18, u += 1, this.words[u] |= l >>> 26) : a += 8;
      else {
        var d = v.length - _;
        for (f = d % 2 === 0 ? _ + 1 : _; f < v.length; f += 2)
          l = y(v, _, f) << a, this.words[u] |= l & 67108863, a >= 18 ? (a -= 18, u += 1, this.words[u] |= l >>> 26) : a += 8;
      }
      this.strip();
    };
    function w(S, v, _, c) {
      for (var f = 0, a = Math.min(S.length, _), u = v; u < a; u++) {
        var l = S.charCodeAt(u) - 48;
        f *= c, l >= 49 ? f += l - 49 + 10 : l >= 17 ? f += l - 17 + 10 : f += l;
      }
      return f;
    }
    i.prototype._parseBase = function(v, _, c) {
      this.words = [0], this.length = 1;
      for (var f = 0, a = 1; a <= 67108863; a *= _)
        f++;
      f--, a = a / _ | 0;
      for (var u = v.length - c, l = u % f, d = Math.min(u, u - l) + c, h = 0, b = c; b < d; b += f)
        h = w(v, b, b + f, _), this.imuln(a), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      if (l !== 0) {
        var m = 1;
        for (h = w(v, b, v.length, _), b = 0; b < l; b++)
          m *= _;
        this.imuln(m), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      }
      this.strip();
    }, i.prototype.copy = function(v) {
      v.words = new Array(this.length);
      for (var _ = 0; _ < this.length; _++)
        v.words[_] = this.words[_];
      v.length = this.length, v.negative = this.negative, v.red = this.red;
    }, i.prototype.clone = function() {
      var v = new i(null);
      return this.copy(v), v;
    }, i.prototype._expand = function(v) {
      for (; this.length < v; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], M = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(v, _) {
      v = v || 10, _ = _ | 0 || 1;
      var c;
      if (v === 16 || v === "hex") {
        c = "";
        for (var f = 0, a = 0, u = 0; u < this.length; u++) {
          var l = this.words[u], d = ((l << f | a) & 16777215).toString(16);
          a = l >>> 24 - f & 16777215, a !== 0 || u !== this.length - 1 ? c = x[6 - d.length] + d + c : c = d + c, f += 2, f >= 26 && (f -= 26, u--);
        }
        for (a !== 0 && (c = a.toString(16) + c); c.length % _ !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      if (v === (v | 0) && v >= 2 && v <= 36) {
        var h = M[v], b = E[v];
        c = "";
        var m = this.clone();
        for (m.negative = 0; !m.isZero(); ) {
          var s = m.modn(b).toString(v);
          m = m.idivn(b), m.isZero() ? c = s + c : c = x[h - s.length] + s + c;
        }
        for (this.isZero() && (c = "0" + c); c.length % _ !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var v = this.words[0];
      return this.length === 2 ? v += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? v += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -v : v;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(v, _) {
      return r(typeof o < "u"), this.toArrayLike(o, v, _);
    }, i.prototype.toArray = function(v, _) {
      return this.toArrayLike(Array, v, _);
    }, i.prototype.toArrayLike = function(v, _, c) {
      var f = this.byteLength(), a = c || Math.max(1, f);
      r(f <= a, "byte array longer than desired length"), r(a > 0, "Requested array length <= 0"), this.strip();
      var u = _ === "le", l = new v(a), d, h, b = this.clone();
      if (u) {
        for (h = 0; !b.isZero(); h++)
          d = b.andln(255), b.iushrn(8), l[h] = d;
        for (; h < a; h++)
          l[h] = 0;
      } else {
        for (h = 0; h < a - f; h++)
          l[h] = 0;
        for (h = 0; !b.isZero(); h++)
          d = b.andln(255), b.iushrn(8), l[a - h - 1] = d;
      }
      return l;
    }, Math.clz32 ? i.prototype._countBits = function(v) {
      return 32 - Math.clz32(v);
    } : i.prototype._countBits = function(v) {
      var _ = v, c = 0;
      return _ >= 4096 && (c += 13, _ >>>= 13), _ >= 64 && (c += 7, _ >>>= 7), _ >= 8 && (c += 4, _ >>>= 4), _ >= 2 && (c += 2, _ >>>= 2), c + _;
    }, i.prototype._zeroBits = function(v) {
      if (v === 0)
        return 26;
      var _ = v, c = 0;
      return (_ & 8191) === 0 && (c += 13, _ >>>= 13), (_ & 127) === 0 && (c += 7, _ >>>= 7), (_ & 15) === 0 && (c += 4, _ >>>= 4), (_ & 3) === 0 && (c += 2, _ >>>= 2), (_ & 1) === 0 && c++, c;
    }, i.prototype.bitLength = function() {
      var v = this.words[this.length - 1], _ = this._countBits(v);
      return (this.length - 1) * 26 + _;
    };
    function A(S) {
      for (var v = new Array(S.bitLength()), _ = 0; _ < v.length; _++) {
        var c = _ / 26 | 0, f = _ % 26;
        v[_] = (S.words[c] & 1 << f) >>> f;
      }
      return v;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var v = 0, _ = 0; _ < this.length; _++) {
        var c = this._zeroBits(this.words[_]);
        if (v += c, c !== 26)
          break;
      }
      return v;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(v) {
      return this.negative !== 0 ? this.abs().inotn(v).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(v) {
      return this.testn(v - 1) ? this.notn(v).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(v) {
      for (; this.length < v.length; )
        this.words[this.length++] = 0;
      for (var _ = 0; _ < v.length; _++)
        this.words[_] = this.words[_] | v.words[_];
      return this.strip();
    }, i.prototype.ior = function(v) {
      return r((this.negative | v.negative) === 0), this.iuor(v);
    }, i.prototype.or = function(v) {
      return this.length > v.length ? this.clone().ior(v) : v.clone().ior(this);
    }, i.prototype.uor = function(v) {
      return this.length > v.length ? this.clone().iuor(v) : v.clone().iuor(this);
    }, i.prototype.iuand = function(v) {
      var _;
      this.length > v.length ? _ = v : _ = this;
      for (var c = 0; c < _.length; c++)
        this.words[c] = this.words[c] & v.words[c];
      return this.length = _.length, this.strip();
    }, i.prototype.iand = function(v) {
      return r((this.negative | v.negative) === 0), this.iuand(v);
    }, i.prototype.and = function(v) {
      return this.length > v.length ? this.clone().iand(v) : v.clone().iand(this);
    }, i.prototype.uand = function(v) {
      return this.length > v.length ? this.clone().iuand(v) : v.clone().iuand(this);
    }, i.prototype.iuxor = function(v) {
      var _, c;
      this.length > v.length ? (_ = this, c = v) : (_ = v, c = this);
      for (var f = 0; f < c.length; f++)
        this.words[f] = _.words[f] ^ c.words[f];
      if (this !== _)
        for (; f < _.length; f++)
          this.words[f] = _.words[f];
      return this.length = _.length, this.strip();
    }, i.prototype.ixor = function(v) {
      return r((this.negative | v.negative) === 0), this.iuxor(v);
    }, i.prototype.xor = function(v) {
      return this.length > v.length ? this.clone().ixor(v) : v.clone().ixor(this);
    }, i.prototype.uxor = function(v) {
      return this.length > v.length ? this.clone().iuxor(v) : v.clone().iuxor(this);
    }, i.prototype.inotn = function(v) {
      r(typeof v == "number" && v >= 0);
      var _ = Math.ceil(v / 26) | 0, c = v % 26;
      this._expand(_), c > 0 && _--;
      for (var f = 0; f < _; f++)
        this.words[f] = ~this.words[f] & 67108863;
      return c > 0 && (this.words[f] = ~this.words[f] & 67108863 >> 26 - c), this.strip();
    }, i.prototype.notn = function(v) {
      return this.clone().inotn(v);
    }, i.prototype.setn = function(v, _) {
      r(typeof v == "number" && v >= 0);
      var c = v / 26 | 0, f = v % 26;
      return this._expand(c + 1), _ ? this.words[c] = this.words[c] | 1 << f : this.words[c] = this.words[c] & ~(1 << f), this.strip();
    }, i.prototype.iadd = function(v) {
      var _;
      if (this.negative !== 0 && v.negative === 0)
        return this.negative = 0, _ = this.isub(v), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && v.negative !== 0)
        return v.negative = 0, _ = this.isub(v), v.negative = 1, _._normSign();
      var c, f;
      this.length > v.length ? (c = this, f = v) : (c = v, f = this);
      for (var a = 0, u = 0; u < f.length; u++)
        _ = (c.words[u] | 0) + (f.words[u] | 0) + a, this.words[u] = _ & 67108863, a = _ >>> 26;
      for (; a !== 0 && u < c.length; u++)
        _ = (c.words[u] | 0) + a, this.words[u] = _ & 67108863, a = _ >>> 26;
      if (this.length = c.length, a !== 0)
        this.words[this.length] = a, this.length++;
      else if (c !== this)
        for (; u < c.length; u++)
          this.words[u] = c.words[u];
      return this;
    }, i.prototype.add = function(v) {
      var _;
      return v.negative !== 0 && this.negative === 0 ? (v.negative = 0, _ = this.sub(v), v.negative ^= 1, _) : v.negative === 0 && this.negative !== 0 ? (this.negative = 0, _ = v.sub(this), this.negative = 1, _) : this.length > v.length ? this.clone().iadd(v) : v.clone().iadd(this);
    }, i.prototype.isub = function(v) {
      if (v.negative !== 0) {
        v.negative = 0;
        var _ = this.iadd(v);
        return v.negative = 1, _._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(v), this.negative = 1, this._normSign();
      var c = this.cmp(v);
      if (c === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var f, a;
      c > 0 ? (f = this, a = v) : (f = v, a = this);
      for (var u = 0, l = 0; l < a.length; l++)
        _ = (f.words[l] | 0) - (a.words[l] | 0) + u, u = _ >> 26, this.words[l] = _ & 67108863;
      for (; u !== 0 && l < f.length; l++)
        _ = (f.words[l] | 0) + u, u = _ >> 26, this.words[l] = _ & 67108863;
      if (u === 0 && l < f.length && f !== this)
        for (; l < f.length; l++)
          this.words[l] = f.words[l];
      return this.length = Math.max(this.length, l), f !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(v) {
      return this.clone().isub(v);
    };
    function I(S, v, _) {
      _.negative = v.negative ^ S.negative;
      var c = S.length + v.length | 0;
      _.length = c, c = c - 1 | 0;
      var f = S.words[0] | 0, a = v.words[0] | 0, u = f * a, l = u & 67108863, d = u / 67108864 | 0;
      _.words[0] = l;
      for (var h = 1; h < c; h++) {
        for (var b = d >>> 26, m = d & 67108863, s = Math.min(h, v.length - 1), g = Math.max(0, h - S.length + 1); g <= s; g++) {
          var q = h - g | 0;
          f = S.words[q] | 0, a = v.words[g] | 0, u = f * a + m, b += u / 67108864 | 0, m = u & 67108863;
        }
        _.words[h] = m | 0, d = b | 0;
      }
      return d !== 0 ? _.words[h] = d | 0 : _.length--, _.strip();
    }
    var D = function(v, _, c) {
      var f = v.words, a = _.words, u = c.words, l = 0, d, h, b, m = f[0] | 0, s = m & 8191, g = m >>> 13, q = f[1] | 0, R2 = q & 8191, B = q >>> 13, P = f[2] | 0, T = P & 8191, N2 = P >>> 13, ze = f[3] | 0, O = ze & 8191, z = ze >>> 13, Er2 = f[4] | 0, U = Er2 & 8191, H2 = Er2 >>> 13, Ar = f[5] | 0, F = Ar & 8191, K2 = Ar >>> 13, qr = f[6] | 0, j = qr & 8191, W = qr >>> 13, Br2 = f[7] | 0, V = Br2 & 8191, Z = Br2 >>> 13, Rr = f[8] | 0, G2 = Rr & 8191, X2 = Rr >>> 13, Ir = f[9] | 0, Y = Ir & 8191, J2 = Ir >>> 13, kr = a[0] | 0, $ = kr & 8191, Q = kr >>> 13, Dr = a[1] | 0, ee = Dr & 8191, te = Dr >>> 13, Pr = a[2] | 0, re = Pr & 8191, ie = Pr >>> 13, Tr = a[3] | 0, fe = Tr & 8191, ne = Tr >>> 13, Cr = a[4] | 0, ae = Cr & 8191, se = Cr >>> 13, Nr = a[5] | 0, oe = Nr & 8191, he = Nr >>> 13, Lr = a[6] | 0, ue = Lr & 8191, de = Lr >>> 13, Or = a[7] | 0, ce = Or & 8191, le = Or >>> 13, zr = a[8] | 0, ve = zr & 8191, pe = zr >>> 13, Ur = a[9] | 0, be = Ur & 8191, me = Ur >>> 13;
      c.negative = v.negative ^ _.negative, c.length = 19, d = Math.imul(s, $), h = Math.imul(s, Q), h = h + Math.imul(g, $) | 0, b = Math.imul(g, Q);
      var dr2 = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (dr2 >>> 26) | 0, dr2 &= 67108863, d = Math.imul(R2, $), h = Math.imul(R2, Q), h = h + Math.imul(B, $) | 0, b = Math.imul(B, Q), d = d + Math.imul(s, ee) | 0, h = h + Math.imul(s, te) | 0, h = h + Math.imul(g, ee) | 0, b = b + Math.imul(g, te) | 0;
      var _e = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, d = Math.imul(T, $), h = Math.imul(T, Q), h = h + Math.imul(N2, $) | 0, b = Math.imul(N2, Q), d = d + Math.imul(R2, ee) | 0, h = h + Math.imul(R2, te) | 0, h = h + Math.imul(B, ee) | 0, b = b + Math.imul(B, te) | 0, d = d + Math.imul(s, re) | 0, h = h + Math.imul(s, ie) | 0, h = h + Math.imul(g, re) | 0, b = b + Math.imul(g, ie) | 0;
      var we = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, d = Math.imul(O, $), h = Math.imul(O, Q), h = h + Math.imul(z, $) | 0, b = Math.imul(z, Q), d = d + Math.imul(T, ee) | 0, h = h + Math.imul(T, te) | 0, h = h + Math.imul(N2, ee) | 0, b = b + Math.imul(N2, te) | 0, d = d + Math.imul(R2, re) | 0, h = h + Math.imul(R2, ie) | 0, h = h + Math.imul(B, re) | 0, b = b + Math.imul(B, ie) | 0, d = d + Math.imul(s, fe) | 0, h = h + Math.imul(s, ne) | 0, h = h + Math.imul(g, fe) | 0, b = b + Math.imul(g, ne) | 0;
      var At = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, d = Math.imul(U, $), h = Math.imul(U, Q), h = h + Math.imul(H2, $) | 0, b = Math.imul(H2, Q), d = d + Math.imul(O, ee) | 0, h = h + Math.imul(O, te) | 0, h = h + Math.imul(z, ee) | 0, b = b + Math.imul(z, te) | 0, d = d + Math.imul(T, re) | 0, h = h + Math.imul(T, ie) | 0, h = h + Math.imul(N2, re) | 0, b = b + Math.imul(N2, ie) | 0, d = d + Math.imul(R2, fe) | 0, h = h + Math.imul(R2, ne) | 0, h = h + Math.imul(B, fe) | 0, b = b + Math.imul(B, ne) | 0, d = d + Math.imul(s, ae) | 0, h = h + Math.imul(s, se) | 0, h = h + Math.imul(g, ae) | 0, b = b + Math.imul(g, se) | 0;
      var qt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, d = Math.imul(F, $), h = Math.imul(F, Q), h = h + Math.imul(K2, $) | 0, b = Math.imul(K2, Q), d = d + Math.imul(U, ee) | 0, h = h + Math.imul(U, te) | 0, h = h + Math.imul(H2, ee) | 0, b = b + Math.imul(H2, te) | 0, d = d + Math.imul(O, re) | 0, h = h + Math.imul(O, ie) | 0, h = h + Math.imul(z, re) | 0, b = b + Math.imul(z, ie) | 0, d = d + Math.imul(T, fe) | 0, h = h + Math.imul(T, ne) | 0, h = h + Math.imul(N2, fe) | 0, b = b + Math.imul(N2, ne) | 0, d = d + Math.imul(R2, ae) | 0, h = h + Math.imul(R2, se) | 0, h = h + Math.imul(B, ae) | 0, b = b + Math.imul(B, se) | 0, d = d + Math.imul(s, oe) | 0, h = h + Math.imul(s, he) | 0, h = h + Math.imul(g, oe) | 0, b = b + Math.imul(g, he) | 0;
      var Bt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, d = Math.imul(j, $), h = Math.imul(j, Q), h = h + Math.imul(W, $) | 0, b = Math.imul(W, Q), d = d + Math.imul(F, ee) | 0, h = h + Math.imul(F, te) | 0, h = h + Math.imul(K2, ee) | 0, b = b + Math.imul(K2, te) | 0, d = d + Math.imul(U, re) | 0, h = h + Math.imul(U, ie) | 0, h = h + Math.imul(H2, re) | 0, b = b + Math.imul(H2, ie) | 0, d = d + Math.imul(O, fe) | 0, h = h + Math.imul(O, ne) | 0, h = h + Math.imul(z, fe) | 0, b = b + Math.imul(z, ne) | 0, d = d + Math.imul(T, ae) | 0, h = h + Math.imul(T, se) | 0, h = h + Math.imul(N2, ae) | 0, b = b + Math.imul(N2, se) | 0, d = d + Math.imul(R2, oe) | 0, h = h + Math.imul(R2, he) | 0, h = h + Math.imul(B, oe) | 0, b = b + Math.imul(B, he) | 0, d = d + Math.imul(s, ue) | 0, h = h + Math.imul(s, de) | 0, h = h + Math.imul(g, ue) | 0, b = b + Math.imul(g, de) | 0;
      var Rt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, d = Math.imul(V, $), h = Math.imul(V, Q), h = h + Math.imul(Z, $) | 0, b = Math.imul(Z, Q), d = d + Math.imul(j, ee) | 0, h = h + Math.imul(j, te) | 0, h = h + Math.imul(W, ee) | 0, b = b + Math.imul(W, te) | 0, d = d + Math.imul(F, re) | 0, h = h + Math.imul(F, ie) | 0, h = h + Math.imul(K2, re) | 0, b = b + Math.imul(K2, ie) | 0, d = d + Math.imul(U, fe) | 0, h = h + Math.imul(U, ne) | 0, h = h + Math.imul(H2, fe) | 0, b = b + Math.imul(H2, ne) | 0, d = d + Math.imul(O, ae) | 0, h = h + Math.imul(O, se) | 0, h = h + Math.imul(z, ae) | 0, b = b + Math.imul(z, se) | 0, d = d + Math.imul(T, oe) | 0, h = h + Math.imul(T, he) | 0, h = h + Math.imul(N2, oe) | 0, b = b + Math.imul(N2, he) | 0, d = d + Math.imul(R2, ue) | 0, h = h + Math.imul(R2, de) | 0, h = h + Math.imul(B, ue) | 0, b = b + Math.imul(B, de) | 0, d = d + Math.imul(s, ce) | 0, h = h + Math.imul(s, le) | 0, h = h + Math.imul(g, ce) | 0, b = b + Math.imul(g, le) | 0;
      var It = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, d = Math.imul(G2, $), h = Math.imul(G2, Q), h = h + Math.imul(X2, $) | 0, b = Math.imul(X2, Q), d = d + Math.imul(V, ee) | 0, h = h + Math.imul(V, te) | 0, h = h + Math.imul(Z, ee) | 0, b = b + Math.imul(Z, te) | 0, d = d + Math.imul(j, re) | 0, h = h + Math.imul(j, ie) | 0, h = h + Math.imul(W, re) | 0, b = b + Math.imul(W, ie) | 0, d = d + Math.imul(F, fe) | 0, h = h + Math.imul(F, ne) | 0, h = h + Math.imul(K2, fe) | 0, b = b + Math.imul(K2, ne) | 0, d = d + Math.imul(U, ae) | 0, h = h + Math.imul(U, se) | 0, h = h + Math.imul(H2, ae) | 0, b = b + Math.imul(H2, se) | 0, d = d + Math.imul(O, oe) | 0, h = h + Math.imul(O, he) | 0, h = h + Math.imul(z, oe) | 0, b = b + Math.imul(z, he) | 0, d = d + Math.imul(T, ue) | 0, h = h + Math.imul(T, de) | 0, h = h + Math.imul(N2, ue) | 0, b = b + Math.imul(N2, de) | 0, d = d + Math.imul(R2, ce) | 0, h = h + Math.imul(R2, le) | 0, h = h + Math.imul(B, ce) | 0, b = b + Math.imul(B, le) | 0, d = d + Math.imul(s, ve) | 0, h = h + Math.imul(s, pe) | 0, h = h + Math.imul(g, ve) | 0, b = b + Math.imul(g, pe) | 0;
      var kt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, d = Math.imul(Y, $), h = Math.imul(Y, Q), h = h + Math.imul(J2, $) | 0, b = Math.imul(J2, Q), d = d + Math.imul(G2, ee) | 0, h = h + Math.imul(G2, te) | 0, h = h + Math.imul(X2, ee) | 0, b = b + Math.imul(X2, te) | 0, d = d + Math.imul(V, re) | 0, h = h + Math.imul(V, ie) | 0, h = h + Math.imul(Z, re) | 0, b = b + Math.imul(Z, ie) | 0, d = d + Math.imul(j, fe) | 0, h = h + Math.imul(j, ne) | 0, h = h + Math.imul(W, fe) | 0, b = b + Math.imul(W, ne) | 0, d = d + Math.imul(F, ae) | 0, h = h + Math.imul(F, se) | 0, h = h + Math.imul(K2, ae) | 0, b = b + Math.imul(K2, se) | 0, d = d + Math.imul(U, oe) | 0, h = h + Math.imul(U, he) | 0, h = h + Math.imul(H2, oe) | 0, b = b + Math.imul(H2, he) | 0, d = d + Math.imul(O, ue) | 0, h = h + Math.imul(O, de) | 0, h = h + Math.imul(z, ue) | 0, b = b + Math.imul(z, de) | 0, d = d + Math.imul(T, ce) | 0, h = h + Math.imul(T, le) | 0, h = h + Math.imul(N2, ce) | 0, b = b + Math.imul(N2, le) | 0, d = d + Math.imul(R2, ve) | 0, h = h + Math.imul(R2, pe) | 0, h = h + Math.imul(B, ve) | 0, b = b + Math.imul(B, pe) | 0, d = d + Math.imul(s, be) | 0, h = h + Math.imul(s, me) | 0, h = h + Math.imul(g, be) | 0, b = b + Math.imul(g, me) | 0;
      var Dt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, d = Math.imul(Y, ee), h = Math.imul(Y, te), h = h + Math.imul(J2, ee) | 0, b = Math.imul(J2, te), d = d + Math.imul(G2, re) | 0, h = h + Math.imul(G2, ie) | 0, h = h + Math.imul(X2, re) | 0, b = b + Math.imul(X2, ie) | 0, d = d + Math.imul(V, fe) | 0, h = h + Math.imul(V, ne) | 0, h = h + Math.imul(Z, fe) | 0, b = b + Math.imul(Z, ne) | 0, d = d + Math.imul(j, ae) | 0, h = h + Math.imul(j, se) | 0, h = h + Math.imul(W, ae) | 0, b = b + Math.imul(W, se) | 0, d = d + Math.imul(F, oe) | 0, h = h + Math.imul(F, he) | 0, h = h + Math.imul(K2, oe) | 0, b = b + Math.imul(K2, he) | 0, d = d + Math.imul(U, ue) | 0, h = h + Math.imul(U, de) | 0, h = h + Math.imul(H2, ue) | 0, b = b + Math.imul(H2, de) | 0, d = d + Math.imul(O, ce) | 0, h = h + Math.imul(O, le) | 0, h = h + Math.imul(z, ce) | 0, b = b + Math.imul(z, le) | 0, d = d + Math.imul(T, ve) | 0, h = h + Math.imul(T, pe) | 0, h = h + Math.imul(N2, ve) | 0, b = b + Math.imul(N2, pe) | 0, d = d + Math.imul(R2, be) | 0, h = h + Math.imul(R2, me) | 0, h = h + Math.imul(B, be) | 0, b = b + Math.imul(B, me) | 0;
      var Pt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, d = Math.imul(Y, re), h = Math.imul(Y, ie), h = h + Math.imul(J2, re) | 0, b = Math.imul(J2, ie), d = d + Math.imul(G2, fe) | 0, h = h + Math.imul(G2, ne) | 0, h = h + Math.imul(X2, fe) | 0, b = b + Math.imul(X2, ne) | 0, d = d + Math.imul(V, ae) | 0, h = h + Math.imul(V, se) | 0, h = h + Math.imul(Z, ae) | 0, b = b + Math.imul(Z, se) | 0, d = d + Math.imul(j, oe) | 0, h = h + Math.imul(j, he) | 0, h = h + Math.imul(W, oe) | 0, b = b + Math.imul(W, he) | 0, d = d + Math.imul(F, ue) | 0, h = h + Math.imul(F, de) | 0, h = h + Math.imul(K2, ue) | 0, b = b + Math.imul(K2, de) | 0, d = d + Math.imul(U, ce) | 0, h = h + Math.imul(U, le) | 0, h = h + Math.imul(H2, ce) | 0, b = b + Math.imul(H2, le) | 0, d = d + Math.imul(O, ve) | 0, h = h + Math.imul(O, pe) | 0, h = h + Math.imul(z, ve) | 0, b = b + Math.imul(z, pe) | 0, d = d + Math.imul(T, be) | 0, h = h + Math.imul(T, me) | 0, h = h + Math.imul(N2, be) | 0, b = b + Math.imul(N2, me) | 0;
      var Tt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, d = Math.imul(Y, fe), h = Math.imul(Y, ne), h = h + Math.imul(J2, fe) | 0, b = Math.imul(J2, ne), d = d + Math.imul(G2, ae) | 0, h = h + Math.imul(G2, se) | 0, h = h + Math.imul(X2, ae) | 0, b = b + Math.imul(X2, se) | 0, d = d + Math.imul(V, oe) | 0, h = h + Math.imul(V, he) | 0, h = h + Math.imul(Z, oe) | 0, b = b + Math.imul(Z, he) | 0, d = d + Math.imul(j, ue) | 0, h = h + Math.imul(j, de) | 0, h = h + Math.imul(W, ue) | 0, b = b + Math.imul(W, de) | 0, d = d + Math.imul(F, ce) | 0, h = h + Math.imul(F, le) | 0, h = h + Math.imul(K2, ce) | 0, b = b + Math.imul(K2, le) | 0, d = d + Math.imul(U, ve) | 0, h = h + Math.imul(U, pe) | 0, h = h + Math.imul(H2, ve) | 0, b = b + Math.imul(H2, pe) | 0, d = d + Math.imul(O, be) | 0, h = h + Math.imul(O, me) | 0, h = h + Math.imul(z, be) | 0, b = b + Math.imul(z, me) | 0;
      var Ct = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, d = Math.imul(Y, ae), h = Math.imul(Y, se), h = h + Math.imul(J2, ae) | 0, b = Math.imul(J2, se), d = d + Math.imul(G2, oe) | 0, h = h + Math.imul(G2, he) | 0, h = h + Math.imul(X2, oe) | 0, b = b + Math.imul(X2, he) | 0, d = d + Math.imul(V, ue) | 0, h = h + Math.imul(V, de) | 0, h = h + Math.imul(Z, ue) | 0, b = b + Math.imul(Z, de) | 0, d = d + Math.imul(j, ce) | 0, h = h + Math.imul(j, le) | 0, h = h + Math.imul(W, ce) | 0, b = b + Math.imul(W, le) | 0, d = d + Math.imul(F, ve) | 0, h = h + Math.imul(F, pe) | 0, h = h + Math.imul(K2, ve) | 0, b = b + Math.imul(K2, pe) | 0, d = d + Math.imul(U, be) | 0, h = h + Math.imul(U, me) | 0, h = h + Math.imul(H2, be) | 0, b = b + Math.imul(H2, me) | 0;
      var Nt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, d = Math.imul(Y, oe), h = Math.imul(Y, he), h = h + Math.imul(J2, oe) | 0, b = Math.imul(J2, he), d = d + Math.imul(G2, ue) | 0, h = h + Math.imul(G2, de) | 0, h = h + Math.imul(X2, ue) | 0, b = b + Math.imul(X2, de) | 0, d = d + Math.imul(V, ce) | 0, h = h + Math.imul(V, le) | 0, h = h + Math.imul(Z, ce) | 0, b = b + Math.imul(Z, le) | 0, d = d + Math.imul(j, ve) | 0, h = h + Math.imul(j, pe) | 0, h = h + Math.imul(W, ve) | 0, b = b + Math.imul(W, pe) | 0, d = d + Math.imul(F, be) | 0, h = h + Math.imul(F, me) | 0, h = h + Math.imul(K2, be) | 0, b = b + Math.imul(K2, me) | 0;
      var Lt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, d = Math.imul(Y, ue), h = Math.imul(Y, de), h = h + Math.imul(J2, ue) | 0, b = Math.imul(J2, de), d = d + Math.imul(G2, ce) | 0, h = h + Math.imul(G2, le) | 0, h = h + Math.imul(X2, ce) | 0, b = b + Math.imul(X2, le) | 0, d = d + Math.imul(V, ve) | 0, h = h + Math.imul(V, pe) | 0, h = h + Math.imul(Z, ve) | 0, b = b + Math.imul(Z, pe) | 0, d = d + Math.imul(j, be) | 0, h = h + Math.imul(j, me) | 0, h = h + Math.imul(W, be) | 0, b = b + Math.imul(W, me) | 0;
      var Ot = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, d = Math.imul(Y, ce), h = Math.imul(Y, le), h = h + Math.imul(J2, ce) | 0, b = Math.imul(J2, le), d = d + Math.imul(G2, ve) | 0, h = h + Math.imul(G2, pe) | 0, h = h + Math.imul(X2, ve) | 0, b = b + Math.imul(X2, pe) | 0, d = d + Math.imul(V, be) | 0, h = h + Math.imul(V, me) | 0, h = h + Math.imul(Z, be) | 0, b = b + Math.imul(Z, me) | 0;
      var zt = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, d = Math.imul(Y, ve), h = Math.imul(Y, pe), h = h + Math.imul(J2, ve) | 0, b = Math.imul(J2, pe), d = d + Math.imul(G2, be) | 0, h = h + Math.imul(G2, me) | 0, h = h + Math.imul(X2, be) | 0, b = b + Math.imul(X2, me) | 0;
      var Ut = (l + d | 0) + ((h & 8191) << 13) | 0;
      l = (b + (h >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, d = Math.imul(Y, be), h = Math.imul(Y, me), h = h + Math.imul(J2, be) | 0, b = Math.imul(J2, me);
      var Ht = (l + d | 0) + ((h & 8191) << 13) | 0;
      return l = (b + (h >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, u[0] = dr2, u[1] = _e, u[2] = we, u[3] = At, u[4] = qt, u[5] = Bt, u[6] = Rt, u[7] = It, u[8] = kt, u[9] = Dt, u[10] = Pt, u[11] = Tt, u[12] = Ct, u[13] = Nt, u[14] = Lt, u[15] = Ot, u[16] = zt, u[17] = Ut, u[18] = Ht, l !== 0 && (u[19] = l, c.length++), c;
    };
    Math.imul || (D = I);
    function C(S, v, _) {
      _.negative = v.negative ^ S.negative, _.length = S.length + v.length;
      for (var c = 0, f = 0, a = 0; a < _.length - 1; a++) {
        var u = f;
        f = 0;
        for (var l = c & 67108863, d = Math.min(a, v.length - 1), h = Math.max(0, a - S.length + 1); h <= d; h++) {
          var b = a - h, m = S.words[b] | 0, s = v.words[h] | 0, g = m * s, q = g & 67108863;
          u = u + (g / 67108864 | 0) | 0, q = q + l | 0, l = q & 67108863, u = u + (q >>> 26) | 0, f += u >>> 26, u &= 67108863;
        }
        _.words[a] = l, c = u, u = f;
      }
      return c !== 0 ? _.words[a] = c : _.length--, _.strip();
    }
    function ge(S, v, _) {
      var c = new L();
      return c.mulp(S, v, _);
    }
    i.prototype.mulTo = function(v, _) {
      var c, f = this.length + v.length;
      return this.length === 10 && v.length === 10 ? c = D(this, v, _) : f < 63 ? c = I(this, v, _) : f < 1024 ? c = C(this, v, _) : c = ge(this, v, _), c;
    };
    function L(S, v) {
      this.x = S, this.y = v;
    }
    L.prototype.makeRBT = function(v) {
      for (var _ = new Array(v), c = i.prototype._countBits(v) - 1, f = 0; f < v; f++)
        _[f] = this.revBin(f, c, v);
      return _;
    }, L.prototype.revBin = function(v, _, c) {
      if (v === 0 || v === c - 1)
        return v;
      for (var f = 0, a = 0; a < _; a++)
        f |= (v & 1) << _ - a - 1, v >>= 1;
      return f;
    }, L.prototype.permute = function(v, _, c, f, a, u) {
      for (var l = 0; l < u; l++)
        f[l] = _[v[l]], a[l] = c[v[l]];
    }, L.prototype.transform = function(v, _, c, f, a, u) {
      this.permute(u, v, _, c, f, a);
      for (var l = 1; l < a; l <<= 1)
        for (var d = l << 1, h = Math.cos(2 * Math.PI / d), b = Math.sin(2 * Math.PI / d), m = 0; m < a; m += d)
          for (var s = h, g = b, q = 0; q < l; q++) {
            var R2 = c[m + q], B = f[m + q], P = c[m + q + l], T = f[m + q + l], N2 = s * P - g * T;
            T = s * T + g * P, P = N2, c[m + q] = R2 + P, f[m + q] = B + T, c[m + q + l] = R2 - P, f[m + q + l] = B - T, q !== d && (N2 = h * s - b * g, g = h * g + b * s, s = N2);
          }
    }, L.prototype.guessLen13b = function(v, _) {
      var c = Math.max(_, v) | 1, f = c & 1, a = 0;
      for (c = c / 2 | 0; c; c = c >>> 1)
        a++;
      return 1 << a + 1 + f;
    }, L.prototype.conjugate = function(v, _, c) {
      if (!(c <= 1))
        for (var f = 0; f < c / 2; f++) {
          var a = v[f];
          v[f] = v[c - f - 1], v[c - f - 1] = a, a = _[f], _[f] = -_[c - f - 1], _[c - f - 1] = -a;
        }
    }, L.prototype.normalize13b = function(v, _) {
      for (var c = 0, f = 0; f < _ / 2; f++) {
        var a = Math.round(v[2 * f + 1] / _) * 8192 + Math.round(v[2 * f] / _) + c;
        v[f] = a & 67108863, a < 67108864 ? c = 0 : c = a / 67108864 | 0;
      }
      return v;
    }, L.prototype.convert13b = function(v, _, c, f) {
      for (var a = 0, u = 0; u < _; u++)
        a = a + (v[u] | 0), c[2 * u] = a & 8191, a = a >>> 13, c[2 * u + 1] = a & 8191, a = a >>> 13;
      for (u = 2 * _; u < f; ++u)
        c[u] = 0;
      r(a === 0), r((a & -8192) === 0);
    }, L.prototype.stub = function(v) {
      for (var _ = new Array(v), c = 0; c < v; c++)
        _[c] = 0;
      return _;
    }, L.prototype.mulp = function(v, _, c) {
      var f = 2 * this.guessLen13b(v.length, _.length), a = this.makeRBT(f), u = this.stub(f), l = new Array(f), d = new Array(f), h = new Array(f), b = new Array(f), m = new Array(f), s = new Array(f), g = c.words;
      g.length = f, this.convert13b(v.words, v.length, l, f), this.convert13b(_.words, _.length, b, f), this.transform(l, u, d, h, f, a), this.transform(b, u, m, s, f, a);
      for (var q = 0; q < f; q++) {
        var R2 = d[q] * m[q] - h[q] * s[q];
        h[q] = d[q] * s[q] + h[q] * m[q], d[q] = R2;
      }
      return this.conjugate(d, h, f), this.transform(d, h, g, u, f, a), this.conjugate(g, u, f), this.normalize13b(g, f), c.negative = v.negative ^ _.negative, c.length = v.length + _.length, c.strip();
    }, i.prototype.mul = function(v) {
      var _ = new i(null);
      return _.words = new Array(this.length + v.length), this.mulTo(v, _);
    }, i.prototype.mulf = function(v) {
      var _ = new i(null);
      return _.words = new Array(this.length + v.length), ge(this, v, _);
    }, i.prototype.imul = function(v) {
      return this.clone().mulTo(v, this);
    }, i.prototype.imuln = function(v) {
      r(typeof v == "number"), r(v < 67108864);
      for (var _ = 0, c = 0; c < this.length; c++) {
        var f = (this.words[c] | 0) * v, a = (f & 67108863) + (_ & 67108863);
        _ >>= 26, _ += f / 67108864 | 0, _ += a >>> 26, this.words[c] = a & 67108863;
      }
      return _ !== 0 && (this.words[c] = _, this.length++), this;
    }, i.prototype.muln = function(v) {
      return this.clone().imuln(v);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(v) {
      var _ = A(v);
      if (_.length === 0)
        return new i(1);
      for (var c = this, f = 0; f < _.length && _[f] === 0; f++, c = c.sqr())
        ;
      if (++f < _.length)
        for (var a = c.sqr(); f < _.length; f++, a = a.sqr())
          _[f] !== 0 && (c = c.mul(a));
      return c;
    }, i.prototype.iushln = function(v) {
      r(typeof v == "number" && v >= 0);
      var _ = v % 26, c = (v - _) / 26, f = 67108863 >>> 26 - _ << 26 - _, a;
      if (_ !== 0) {
        var u = 0;
        for (a = 0; a < this.length; a++) {
          var l = this.words[a] & f, d = (this.words[a] | 0) - l << _;
          this.words[a] = d | u, u = l >>> 26 - _;
        }
        u && (this.words[a] = u, this.length++);
      }
      if (c !== 0) {
        for (a = this.length - 1; a >= 0; a--)
          this.words[a + c] = this.words[a];
        for (a = 0; a < c; a++)
          this.words[a] = 0;
        this.length += c;
      }
      return this.strip();
    }, i.prototype.ishln = function(v) {
      return r(this.negative === 0), this.iushln(v);
    }, i.prototype.iushrn = function(v, _, c) {
      r(typeof v == "number" && v >= 0);
      var f;
      _ ? f = (_ - _ % 26) / 26 : f = 0;
      var a = v % 26, u = Math.min((v - a) / 26, this.length), l = 67108863 ^ 67108863 >>> a << a, d = c;
      if (f -= u, f = Math.max(0, f), d) {
        for (var h = 0; h < u; h++)
          d.words[h] = this.words[h];
        d.length = u;
      }
      if (u !== 0)
        if (this.length > u)
          for (this.length -= u, h = 0; h < this.length; h++)
            this.words[h] = this.words[h + u];
        else
          this.words[0] = 0, this.length = 1;
      var b = 0;
      for (h = this.length - 1; h >= 0 && (b !== 0 || h >= f); h--) {
        var m = this.words[h] | 0;
        this.words[h] = b << 26 - a | m >>> a, b = m & l;
      }
      return d && b !== 0 && (d.words[d.length++] = b), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(v, _, c) {
      return r(this.negative === 0), this.iushrn(v, _, c);
    }, i.prototype.shln = function(v) {
      return this.clone().ishln(v);
    }, i.prototype.ushln = function(v) {
      return this.clone().iushln(v);
    }, i.prototype.shrn = function(v) {
      return this.clone().ishrn(v);
    }, i.prototype.ushrn = function(v) {
      return this.clone().iushrn(v);
    }, i.prototype.testn = function(v) {
      r(typeof v == "number" && v >= 0);
      var _ = v % 26, c = (v - _) / 26, f = 1 << _;
      if (this.length <= c)
        return false;
      var a = this.words[c];
      return !!(a & f);
    }, i.prototype.imaskn = function(v) {
      r(typeof v == "number" && v >= 0);
      var _ = v % 26, c = (v - _) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
        return this;
      if (_ !== 0 && c++, this.length = Math.min(c, this.length), _ !== 0) {
        var f = 67108863 ^ 67108863 >>> _ << _;
        this.words[this.length - 1] &= f;
      }
      return this.strip();
    }, i.prototype.maskn = function(v) {
      return this.clone().imaskn(v);
    }, i.prototype.iaddn = function(v) {
      return r(typeof v == "number"), r(v < 67108864), v < 0 ? this.isubn(-v) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < v ? (this.words[0] = v - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(v), this.negative = 1, this) : this._iaddn(v);
    }, i.prototype._iaddn = function(v) {
      this.words[0] += v;
      for (var _ = 0; _ < this.length && this.words[_] >= 67108864; _++)
        this.words[_] -= 67108864, _ === this.length - 1 ? this.words[_ + 1] = 1 : this.words[_ + 1]++;
      return this.length = Math.max(this.length, _ + 1), this;
    }, i.prototype.isubn = function(v) {
      if (r(typeof v == "number"), r(v < 67108864), v < 0)
        return this.iaddn(-v);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(v), this.negative = 1, this;
      if (this.words[0] -= v, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var _ = 0; _ < this.length && this.words[_] < 0; _++)
          this.words[_] += 67108864, this.words[_ + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(v) {
      return this.clone().iaddn(v);
    }, i.prototype.subn = function(v) {
      return this.clone().isubn(v);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(v, _, c) {
      var f = v.length + c, a;
      this._expand(f);
      var u, l = 0;
      for (a = 0; a < v.length; a++) {
        u = (this.words[a + c] | 0) + l;
        var d = (v.words[a] | 0) * _;
        u -= d & 67108863, l = (u >> 26) - (d / 67108864 | 0), this.words[a + c] = u & 67108863;
      }
      for (; a < this.length - c; a++)
        u = (this.words[a + c] | 0) + l, l = u >> 26, this.words[a + c] = u & 67108863;
      if (l === 0)
        return this.strip();
      for (r(l === -1), l = 0, a = 0; a < this.length; a++)
        u = -(this.words[a] | 0) + l, l = u >> 26, this.words[a] = u & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(v, _) {
      var c = this.length - v.length, f = this.clone(), a = v, u = a.words[a.length - 1] | 0, l = this._countBits(u);
      c = 26 - l, c !== 0 && (a = a.ushln(c), f.iushln(c), u = a.words[a.length - 1] | 0);
      var d = f.length - a.length, h;
      if (_ !== "mod") {
        h = new i(null), h.length = d + 1, h.words = new Array(h.length);
        for (var b = 0; b < h.length; b++)
          h.words[b] = 0;
      }
      var m = f.clone()._ishlnsubmul(a, 1, d);
      m.negative === 0 && (f = m, h && (h.words[d] = 1));
      for (var s = d - 1; s >= 0; s--) {
        var g = (f.words[a.length + s] | 0) * 67108864 + (f.words[a.length + s - 1] | 0);
        for (g = Math.min(g / u | 0, 67108863), f._ishlnsubmul(a, g, s); f.negative !== 0; )
          g--, f.negative = 0, f._ishlnsubmul(a, 1, s), f.isZero() || (f.negative ^= 1);
        h && (h.words[s] = g);
      }
      return h && h.strip(), f.strip(), _ !== "div" && c !== 0 && f.iushrn(c), { div: h || null, mod: f };
    }, i.prototype.divmod = function(v, _, c) {
      if (r(!v.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var f, a, u;
      return this.negative !== 0 && v.negative === 0 ? (u = this.neg().divmod(v, _), _ !== "mod" && (f = u.div.neg()), _ !== "div" && (a = u.mod.neg(), c && a.negative !== 0 && a.iadd(v)), { div: f, mod: a }) : this.negative === 0 && v.negative !== 0 ? (u = this.divmod(v.neg(), _), _ !== "mod" && (f = u.div.neg()), { div: f, mod: u.mod }) : (this.negative & v.negative) !== 0 ? (u = this.neg().divmod(v.neg(), _), _ !== "div" && (a = u.mod.neg(), c && a.negative !== 0 && a.isub(v)), { div: u.div, mod: a }) : v.length > this.length || this.cmp(v) < 0 ? { div: new i(0), mod: this } : v.length === 1 ? _ === "div" ? { div: this.divn(v.words[0]), mod: null } : _ === "mod" ? { div: null, mod: new i(this.modn(v.words[0])) } : { div: this.divn(v.words[0]), mod: new i(this.modn(v.words[0])) } : this._wordDiv(v, _);
    }, i.prototype.div = function(v) {
      return this.divmod(v, "div", false).div;
    }, i.prototype.mod = function(v) {
      return this.divmod(v, "mod", false).mod;
    }, i.prototype.umod = function(v) {
      return this.divmod(v, "mod", true).mod;
    }, i.prototype.divRound = function(v) {
      var _ = this.divmod(v);
      if (_.mod.isZero())
        return _.div;
      var c = _.div.negative !== 0 ? _.mod.isub(v) : _.mod, f = v.ushrn(1), a = v.andln(1), u = c.cmp(f);
      return u < 0 || a === 1 && u === 0 ? _.div : _.div.negative !== 0 ? _.div.isubn(1) : _.div.iaddn(1);
    }, i.prototype.modn = function(v) {
      r(v <= 67108863);
      for (var _ = (1 << 26) % v, c = 0, f = this.length - 1; f >= 0; f--)
        c = (_ * c + (this.words[f] | 0)) % v;
      return c;
    }, i.prototype.idivn = function(v) {
      r(v <= 67108863);
      for (var _ = 0, c = this.length - 1; c >= 0; c--) {
        var f = (this.words[c] | 0) + _ * 67108864;
        this.words[c] = f / v | 0, _ = f % v;
      }
      return this.strip();
    }, i.prototype.divn = function(v) {
      return this.clone().idivn(v);
    }, i.prototype.egcd = function(v) {
      r(v.negative === 0), r(!v.isZero());
      var _ = this, c = v.clone();
      _.negative !== 0 ? _ = _.umod(v) : _ = _.clone();
      for (var f = new i(1), a = new i(0), u = new i(0), l = new i(1), d = 0; _.isEven() && c.isEven(); )
        _.iushrn(1), c.iushrn(1), ++d;
      for (var h = c.clone(), b = _.clone(); !_.isZero(); ) {
        for (var m = 0, s = 1; (_.words[0] & s) === 0 && m < 26; ++m, s <<= 1)
          ;
        if (m > 0)
          for (_.iushrn(m); m-- > 0; )
            (f.isOdd() || a.isOdd()) && (f.iadd(h), a.isub(b)), f.iushrn(1), a.iushrn(1);
        for (var g = 0, q = 1; (c.words[0] & q) === 0 && g < 26; ++g, q <<= 1)
          ;
        if (g > 0)
          for (c.iushrn(g); g-- > 0; )
            (u.isOdd() || l.isOdd()) && (u.iadd(h), l.isub(b)), u.iushrn(1), l.iushrn(1);
        _.cmp(c) >= 0 ? (_.isub(c), f.isub(u), a.isub(l)) : (c.isub(_), u.isub(f), l.isub(a));
      }
      return { a: u, b: l, gcd: c.iushln(d) };
    }, i.prototype._invmp = function(v) {
      r(v.negative === 0), r(!v.isZero());
      var _ = this, c = v.clone();
      _.negative !== 0 ? _ = _.umod(v) : _ = _.clone();
      for (var f = new i(1), a = new i(0), u = c.clone(); _.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
        for (var l = 0, d = 1; (_.words[0] & d) === 0 && l < 26; ++l, d <<= 1)
          ;
        if (l > 0)
          for (_.iushrn(l); l-- > 0; )
            f.isOdd() && f.iadd(u), f.iushrn(1);
        for (var h = 0, b = 1; (c.words[0] & b) === 0 && h < 26; ++h, b <<= 1)
          ;
        if (h > 0)
          for (c.iushrn(h); h-- > 0; )
            a.isOdd() && a.iadd(u), a.iushrn(1);
        _.cmp(c) >= 0 ? (_.isub(c), f.isub(a)) : (c.isub(_), a.isub(f));
      }
      var m;
      return _.cmpn(1) === 0 ? m = f : m = a, m.cmpn(0) < 0 && m.iadd(v), m;
    }, i.prototype.gcd = function(v) {
      if (this.isZero())
        return v.abs();
      if (v.isZero())
        return this.abs();
      var _ = this.clone(), c = v.clone();
      _.negative = 0, c.negative = 0;
      for (var f = 0; _.isEven() && c.isEven(); f++)
        _.iushrn(1), c.iushrn(1);
      do {
        for (; _.isEven(); )
          _.iushrn(1);
        for (; c.isEven(); )
          c.iushrn(1);
        var a = _.cmp(c);
        if (a < 0) {
          var u = _;
          _ = c, c = u;
        } else if (a === 0 || c.cmpn(1) === 0)
          break;
        _.isub(c);
      } while (true);
      return c.iushln(f);
    }, i.prototype.invm = function(v) {
      return this.egcd(v).a.umod(v);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(v) {
      return this.words[0] & v;
    }, i.prototype.bincn = function(v) {
      r(typeof v == "number");
      var _ = v % 26, c = (v - _) / 26, f = 1 << _;
      if (this.length <= c)
        return this._expand(c + 1), this.words[c] |= f, this;
      for (var a = f, u = c; a !== 0 && u < this.length; u++) {
        var l = this.words[u] | 0;
        l += a, a = l >>> 26, l &= 67108863, this.words[u] = l;
      }
      return a !== 0 && (this.words[u] = a, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(v) {
      var _ = v < 0;
      if (this.negative !== 0 && !_)
        return -1;
      if (this.negative === 0 && _)
        return 1;
      this.strip();
      var c;
      if (this.length > 1)
        c = 1;
      else {
        _ && (v = -v), r(v <= 67108863, "Number is too big");
        var f = this.words[0] | 0;
        c = f === v ? 0 : f < v ? -1 : 1;
      }
      return this.negative !== 0 ? -c | 0 : c;
    }, i.prototype.cmp = function(v) {
      if (this.negative !== 0 && v.negative === 0)
        return -1;
      if (this.negative === 0 && v.negative !== 0)
        return 1;
      var _ = this.ucmp(v);
      return this.negative !== 0 ? -_ | 0 : _;
    }, i.prototype.ucmp = function(v) {
      if (this.length > v.length)
        return 1;
      if (this.length < v.length)
        return -1;
      for (var _ = 0, c = this.length - 1; c >= 0; c--) {
        var f = this.words[c] | 0, a = v.words[c] | 0;
        if (f !== a) {
          f < a ? _ = -1 : f > a && (_ = 1);
          break;
        }
      }
      return _;
    }, i.prototype.gtn = function(v) {
      return this.cmpn(v) === 1;
    }, i.prototype.gt = function(v) {
      return this.cmp(v) === 1;
    }, i.prototype.gten = function(v) {
      return this.cmpn(v) >= 0;
    }, i.prototype.gte = function(v) {
      return this.cmp(v) >= 0;
    }, i.prototype.ltn = function(v) {
      return this.cmpn(v) === -1;
    }, i.prototype.lt = function(v) {
      return this.cmp(v) === -1;
    }, i.prototype.lten = function(v) {
      return this.cmpn(v) <= 0;
    }, i.prototype.lte = function(v) {
      return this.cmp(v) <= 0;
    }, i.prototype.eqn = function(v) {
      return this.cmpn(v) === 0;
    }, i.prototype.eq = function(v) {
      return this.cmp(v) === 0;
    }, i.red = function(v) {
      return new Ee(v);
    }, i.prototype.toRed = function(v) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), v.convertTo(this)._forceRed(v);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(v) {
      return this.red = v, this;
    }, i.prototype.forceRed = function(v) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(v);
    }, i.prototype.redAdd = function(v) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, v);
    }, i.prototype.redIAdd = function(v) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, v);
    }, i.prototype.redSub = function(v) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, v);
    }, i.prototype.redISub = function(v) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, v);
    }, i.prototype.redShl = function(v) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, v);
    }, i.prototype.redMul = function(v) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, v), this.red.mul(this, v);
    }, i.prototype.redIMul = function(v) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, v), this.red.imul(this, v);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(v) {
      return r(this.red && !v.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, v);
    };
    var ye = { k256: null, p224: null, p192: null, p25519: null };
    function Re(S, v) {
      this.name = S, this.p = new i(v, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Re.prototype._tmp = function() {
      var v = new i(null);
      return v.words = new Array(Math.ceil(this.n / 13)), v;
    }, Re.prototype.ireduce = function(v) {
      var _ = v, c;
      do
        this.split(_, this.tmp), _ = this.imulK(_), _ = _.iadd(this.tmp), c = _.bitLength();
      while (c > this.n);
      var f = c < this.n ? -1 : _.ucmp(this.p);
      return f === 0 ? (_.words[0] = 0, _.length = 1) : f > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
    }, Re.prototype.split = function(v, _) {
      v.iushrn(this.n, 0, _);
    }, Re.prototype.imulK = function(v) {
      return v.imul(this.k);
    };
    function xe() {
      Re.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(xe, Re), xe.prototype.split = function(v, _) {
      for (var c = 4194303, f = Math.min(v.length, 9), a = 0; a < f; a++)
        _.words[a] = v.words[a];
      if (_.length = f, v.length <= 9) {
        v.words[0] = 0, v.length = 1;
        return;
      }
      var u = v.words[9];
      for (_.words[_.length++] = u & c, a = 10; a < v.length; a++) {
        var l = v.words[a] | 0;
        v.words[a - 10] = (l & c) << 4 | u >>> 22, u = l;
      }
      u >>>= 22, v.words[a - 10] = u, u === 0 && v.length > 10 ? v.length -= 10 : v.length -= 9;
    }, xe.prototype.imulK = function(v) {
      v.words[v.length] = 0, v.words[v.length + 1] = 0, v.length += 2;
      for (var _ = 0, c = 0; c < v.length; c++) {
        var f = v.words[c] | 0;
        _ += f * 977, v.words[c] = _ & 67108863, _ = f * 64 + (_ / 67108864 | 0);
      }
      return v.words[v.length - 1] === 0 && (v.length--, v.words[v.length - 1] === 0 && v.length--), v;
    };
    function ke() {
      Re.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(ke, Re);
    function Me() {
      Re.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Me, Re);
    function Ce() {
      Re.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(Ce, Re), Ce.prototype.imulK = function(v) {
      for (var _ = 0, c = 0; c < v.length; c++) {
        var f = (v.words[c] | 0) * 19 + _, a = f & 67108863;
        f >>>= 26, v.words[c] = a, _ = f;
      }
      return _ !== 0 && (v.words[v.length++] = _), v;
    }, i._prime = function(v) {
      if (ye[v])
        return ye[v];
      var _;
      if (v === "k256")
        _ = new xe();
      else if (v === "p224")
        _ = new ke();
      else if (v === "p192")
        _ = new Me();
      else if (v === "p25519")
        _ = new Ce();
      else
        throw new Error("Unknown prime " + v);
      return ye[v] = _, _;
    };
    function Ee(S) {
      if (typeof S == "string") {
        var v = i._prime(S);
        this.m = v.p, this.prime = v;
      } else
        r(S.gtn(1), "modulus must be greater than 1"), this.m = S, this.prime = null;
    }
    Ee.prototype._verify1 = function(v) {
      r(v.negative === 0, "red works only with positives"), r(v.red, "red works only with red numbers");
    }, Ee.prototype._verify2 = function(v, _) {
      r((v.negative | _.negative) === 0, "red works only with positives"), r(v.red && v.red === _.red, "red works only with red numbers");
    }, Ee.prototype.imod = function(v) {
      return this.prime ? this.prime.ireduce(v)._forceRed(this) : v.umod(this.m)._forceRed(this);
    }, Ee.prototype.neg = function(v) {
      return v.isZero() ? v.clone() : this.m.sub(v)._forceRed(this);
    }, Ee.prototype.add = function(v, _) {
      this._verify2(v, _);
      var c = v.add(_);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
    }, Ee.prototype.iadd = function(v, _) {
      this._verify2(v, _);
      var c = v.iadd(_);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c;
    }, Ee.prototype.sub = function(v, _) {
      this._verify2(v, _);
      var c = v.sub(_);
      return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
    }, Ee.prototype.isub = function(v, _) {
      this._verify2(v, _);
      var c = v.isub(_);
      return c.cmpn(0) < 0 && c.iadd(this.m), c;
    }, Ee.prototype.shl = function(v, _) {
      return this._verify1(v), this.imod(v.ushln(_));
    }, Ee.prototype.imul = function(v, _) {
      return this._verify2(v, _), this.imod(v.imul(_));
    }, Ee.prototype.mul = function(v, _) {
      return this._verify2(v, _), this.imod(v.mul(_));
    }, Ee.prototype.isqr = function(v) {
      return this.imul(v, v.clone());
    }, Ee.prototype.sqr = function(v) {
      return this.mul(v, v);
    }, Ee.prototype.sqrt = function(v) {
      if (v.isZero())
        return v.clone();
      var _ = this.m.andln(3);
      if (r(_ % 2 === 1), _ === 3) {
        var c = this.m.add(new i(1)).iushrn(2);
        return this.pow(v, c);
      }
      for (var f = this.m.subn(1), a = 0; !f.isZero() && f.andln(1) === 0; )
        a++, f.iushrn(1);
      r(!f.isZero());
      var u = new i(1).toRed(this), l = u.redNeg(), d = this.m.subn(1).iushrn(1), h = this.m.bitLength();
      for (h = new i(2 * h * h).toRed(this); this.pow(h, d).cmp(l) !== 0; )
        h.redIAdd(l);
      for (var b = this.pow(h, f), m = this.pow(v, f.addn(1).iushrn(1)), s = this.pow(v, f), g = a; s.cmp(u) !== 0; ) {
        for (var q = s, R2 = 0; q.cmp(u) !== 0; R2++)
          q = q.redSqr();
        r(R2 < g);
        var B = this.pow(b, new i(1).iushln(g - R2 - 1));
        m = m.redMul(B), b = B.redSqr(), s = s.redMul(b), g = R2;
      }
      return m;
    }, Ee.prototype.invm = function(v) {
      var _ = v._invmp(this.m);
      return _.negative !== 0 ? (_.negative = 0, this.imod(_).redNeg()) : this.imod(_);
    }, Ee.prototype.pow = function(v, _) {
      if (_.isZero())
        return new i(1).toRed(this);
      if (_.cmpn(1) === 0)
        return v.clone();
      var c = 4, f = new Array(1 << c);
      f[0] = new i(1).toRed(this), f[1] = v;
      for (var a = 2; a < f.length; a++)
        f[a] = this.mul(f[a - 1], v);
      var u = f[0], l = 0, d = 0, h = _.bitLength() % 26;
      for (h === 0 && (h = 26), a = _.length - 1; a >= 0; a--) {
        for (var b = _.words[a], m = h - 1; m >= 0; m--) {
          var s = b >> m & 1;
          if (u !== f[0] && (u = this.sqr(u)), s === 0 && l === 0) {
            d = 0;
            continue;
          }
          l <<= 1, l |= s, d++, !(d !== c && (a !== 0 || m !== 0)) && (u = this.mul(u, f[l]), d = 0, l = 0);
        }
        h = 26;
      }
      return u;
    }, Ee.prototype.convertTo = function(v) {
      var _ = v.umod(this.m);
      return _ === v ? _.clone() : _;
    }, Ee.prototype.convertFrom = function(v) {
      var _ = v.clone();
      return _.red = null, _;
    }, i.mont = function(v) {
      return new Ne(v);
    };
    function Ne(S) {
      Ee.call(this, S), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(Ne, Ee), Ne.prototype.convertTo = function(v) {
      return this.imod(v.ushln(this.shift));
    }, Ne.prototype.convertFrom = function(v) {
      var _ = this.imod(v.mul(this.rinv));
      return _.red = null, _;
    }, Ne.prototype.imul = function(v, _) {
      if (v.isZero() || _.isZero())
        return v.words[0] = 0, v.length = 1, v;
      var c = v.imul(_), f = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a = c.isub(f).iushrn(this.shift), u = a;
      return a.cmp(this.m) >= 0 ? u = a.isub(this.m) : a.cmpn(0) < 0 && (u = a.iadd(this.m)), u._forceRed(this);
    }, Ne.prototype.mul = function(v, _) {
      if (v.isZero() || _.isZero())
        return new i(0)._forceRed(this);
      var c = v.mul(_), f = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a = c.isub(f).iushrn(this.shift), u = a;
      return a.cmp(this.m) >= 0 ? u = a.isub(this.m) : a.cmpn(0) < 0 && (u = a.iadd(this.m)), u._forceRed(this);
    }, Ne.prototype.invm = function(v) {
      var _ = this.imod(v._invmp(this.m).mul(this.r2));
      return _._forceRed(this);
    };
  })(typeof I0 > "u" || I0, Ju);
});
var On = k2((rm, P0) => {
  var k0;
  P0.exports = function(e) {
    return k0 || (k0 = new Gr(null)), k0.generate(e);
  };
  function Gr(t) {
    this.rand = t;
  }
  P0.exports.Rand = Gr;
  Gr.prototype.generate = function(e) {
    return this._rand(e);
  };
  Gr.prototype._rand = function(e) {
    if (this.rand.getBytes)
      return this.rand.getBytes(e);
    for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
      r[n] = this.rand.getByte();
    return r;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Gr.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.crypto.getRandomValues(r), r;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Gr.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.msCrypto.getRandomValues(r), r;
    } : typeof window == "object" && (Gr.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (D0 = crypto_default, typeof D0.randomBytes != "function")
        throw new Error("Not supported");
      Gr.prototype._rand = function(e) {
        return D0.randomBytes(e);
      };
    } catch {
    }
  var D0;
});
var T0 = k2((im, $u) => {
  var yi = Fe(), Pb = On();
  function _i(t) {
    this.rand = t || new Pb.Rand();
  }
  $u.exports = _i;
  _i.create = function(e) {
    return new _i(e);
  };
  _i.prototype._randbelow = function(e) {
    var r = e.bitLength(), n = Math.ceil(r / 8);
    do
      var i = new yi(this.rand.generate(n));
    while (i.cmp(e) >= 0);
    return i;
  };
  _i.prototype._randrange = function(e, r) {
    var n = r.sub(e);
    return e.add(this._randbelow(n));
  };
  _i.prototype.test = function(e, r, n) {
    var i = e.bitLength(), o = yi.mont(e), p = new yi(1).toRed(o);
    r || (r = Math.max(1, i / 48 | 0));
    for (var y = e.subn(1), w = 0; !y.testn(w); w++)
      ;
    for (var x = e.shrn(w), M = y.toRed(o), E = true; r > 0; r--) {
      var A = this._randrange(new yi(2), y);
      n && n(A);
      var I = A.toRed(o).redPow(x);
      if (!(I.cmp(p) === 0 || I.cmp(M) === 0)) {
        for (var D = 1; D < w; D++) {
          if (I = I.redSqr(), I.cmp(p) === 0)
            return false;
          if (I.cmp(M) === 0)
            break;
        }
        if (D === w)
          return false;
      }
    }
    return E;
  };
  _i.prototype.getDivisor = function(e, r) {
    var n = e.bitLength(), i = yi.mont(e), o = new yi(1).toRed(i);
    r || (r = Math.max(1, n / 48 | 0));
    for (var p = e.subn(1), y = 0; !p.testn(y); y++)
      ;
    for (var w = e.shrn(y), x = p.toRed(i); r > 0; r--) {
      var M = this._randrange(new yi(2), p), E = e.gcd(M);
      if (E.cmpn(1) !== 0)
        return E;
      var A = M.toRed(i).redPow(w);
      if (!(A.cmp(o) === 0 || A.cmp(x) === 0)) {
        for (var I = 1; I < y; I++) {
          if (A = A.redSqr(), A.cmp(o) === 0)
            return A.fromRed().subn(1).gcd(e);
          if (A.cmp(x) === 0)
            break;
        }
        if (I === y)
          return A = A.redSqr(), A.fromRed().subn(1).gcd(e);
      }
    }
    return false;
  };
});
var U0 = k2((om, td) => {
  var Tb = fi();
  td.exports = z0;
  z0.simpleSieve = L0;
  z0.fermatTest = O0;
  var Ge = Fe(), Cb = new Ge(24), Nb = T0(), Qu = new Nb(), Lb = new Ge(1), N0 = new Ge(2), Ob = new Ge(5), fm = new Ge(16), nm = new Ge(8), zb = new Ge(10), Ub = new Ge(3), am = new Ge(7), Hb = new Ge(11), ed = new Ge(4), sm = new Ge(12), C0 = null;
  function Fb() {
    if (C0 !== null)
      return C0;
    var t = 1048576, e = [];
    e[0] = 2;
    for (var r = 1, n = 3; n < t; n += 2) {
      for (var i = Math.ceil(Math.sqrt(n)), o = 0; o < r && e[o] <= i && n % e[o] !== 0; o++)
        ;
      r !== o && e[o] <= i || (e[r++] = n);
    }
    return C0 = e, e;
  }
  function L0(t) {
    for (var e = Fb(), r = 0; r < e.length; r++)
      if (t.modn(e[r]) === 0)
        return t.cmpn(e[r]) === 0;
    return true;
  }
  function O0(t) {
    var e = Ge.mont(t);
    return N0.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
  }
  function z0(t, e) {
    if (t < 16)
      return e === 2 || e === 5 ? new Ge([140, 123]) : new Ge([140, 39]);
    e = new Ge(e);
    for (var r, n; ; ) {
      for (r = new Ge(Tb(Math.ceil(t / 8))); r.bitLength() > t; )
        r.ishrn(1);
      if (r.isEven() && r.iadd(Lb), r.testn(1) || r.iadd(N0), e.cmp(N0)) {
        if (!e.cmp(Ob))
          for (; r.mod(zb).cmp(Ub); )
            r.iadd(ed);
      } else
        for (; r.mod(Cb).cmp(Hb); )
          r.iadd(ed);
      if (n = r.shrn(1), L0(n) && L0(r) && O0(n) && O0(r) && Qu.test(n) && Qu.test(r))
        return r;
    }
  }
});
var rd = k2((hm, Kb) => {
  Kb.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
});
var ad = k2((um, nd) => {
  var mt = Fe(), jb = T0(), id = new jb(), Wb = new mt(24), Vb = new mt(11), Zb = new mt(10), Gb = new mt(3), Xb = new mt(7), fd = U0(), Yb = fi();
  nd.exports = yr2;
  function Jb(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this._pub = new mt(t), this;
  }
  function $b(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this._priv = new mt(t), this;
  }
  var zn = {};
  function Qb(t, e) {
    var r = e.toString("hex"), n = [r, t.toString(16)].join("_");
    if (n in zn)
      return zn[n];
    var i = 0;
    if (t.isEven() || !fd.simpleSieve || !fd.fermatTest(t) || !id.test(t))
      return i += 1, r === "02" || r === "05" ? i += 8 : i += 4, zn[n] = i, i;
    id.test(t.shrn(1)) || (i += 2);
    var o;
    switch (r) {
      case "02":
        t.mod(Wb).cmp(Vb) && (i += 8);
        break;
      case "05":
        o = t.mod(Zb), o.cmp(Gb) && o.cmp(Xb) && (i += 8);
        break;
      default:
        i += 4;
    }
    return zn[n] = i, i;
  }
  function yr2(t, e, r) {
    this.setGenerator(e), this.__prime = new mt(t), this._prime = mt.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = Jb, this.setPrivateKey = $b) : this._primeCode = 8;
  }
  Object.defineProperty(yr2.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = Qb(this.__prime, this.__gen)), this._primeCode;
  } });
  yr2.prototype.generateKeys = function() {
    return this._priv || (this._priv = new mt(Yb(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  yr2.prototype.computeSecret = function(t) {
    t = new mt(t), t = t.toRed(this._prime);
    var e = t.redPow(this._priv).fromRed(), r = new Buffer3(e.toArray()), n = this.getPrime();
    if (r.length < n.length) {
      var i = new Buffer3(n.length - r.length);
      i.fill(0), r = Buffer3.concat([i, r]);
    }
    return r;
  };
  yr2.prototype.getPublicKey = function(e) {
    return Un(this._pub, e);
  };
  yr2.prototype.getPrivateKey = function(e) {
    return Un(this._priv, e);
  };
  yr2.prototype.getPrime = function(t) {
    return Un(this.__prime, t);
  };
  yr2.prototype.getGenerator = function(t) {
    return Un(this._gen, t);
  };
  yr2.prototype.setGenerator = function(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this.__gen = t, this._gen = new mt(t), this;
  };
  function Un(t, e) {
    var r = new Buffer3(t.toArray());
    return e ? r.toString(e) : r;
  }
});
var hd = k2((Fi) => {
  var e6 = U0(), sd = rd(), H0 = ad();
  function t6(t) {
    var e = new Buffer3(sd[t].prime, "hex"), r = new Buffer3(sd[t].gen, "hex");
    return new H0(e, r);
  }
  var r6 = { binary: true, hex: true, base64: true };
  function od(t, e, r, n) {
    return Buffer3.isBuffer(e) || r6[e] === void 0 ? od(t, "binary", e, r) : (e = e || "binary", n = n || "binary", r = r || new Buffer3([2]), Buffer3.isBuffer(r) || (r = new Buffer3(r, n)), typeof t == "number" ? new H0(e6(t, r), r, true) : (Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), new H0(t, r, true)));
  }
  Fi.DiffieHellmanGroup = Fi.createDiffieHellmanGroup = Fi.getDiffieHellman = t6;
  Fi.createDiffieHellman = Fi.DiffieHellman = od;
});
var dd = k2((ud, F0) => {
  (function(t, e) {
    "use strict";
    function r(c, f) {
      if (!c)
        throw new Error(f || "Assertion failed");
    }
    function n(c, f) {
      c.super_ = f;
      var a = function() {
      };
      a.prototype = f.prototype, c.prototype = new a(), c.prototype.constructor = c;
    }
    function i(c, f, a) {
      if (i.isBN(c))
        return c;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c !== null && ((f === "le" || f === "be") && (a = f, f = 10), this._init(c || 0, f || 10, a || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = export_default.Buffer;
    } catch {
    }
    i.isBN = function(f) {
      return f instanceof i ? true : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
    }, i.max = function(f, a) {
      return f.cmp(a) > 0 ? f : a;
    }, i.min = function(f, a) {
      return f.cmp(a) < 0 ? f : a;
    }, i.prototype._init = function(f, a, u) {
      if (typeof f == "number")
        return this._initNumber(f, a, u);
      if (typeof f == "object")
        return this._initArray(f, a, u);
      a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), f = f.toString().replace(/\s+/g, "");
      var l = 0;
      f[0] === "-" && (l++, this.negative = 1), l < f.length && (a === 16 ? this._parseHex(f, l, u) : (this._parseBase(f, a, l), u === "le" && this._initArray(this.toArray(), a, u)));
    }, i.prototype._initNumber = function(f, a, u) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), u === "le" && this._initArray(this.toArray(), a, u);
    }, i.prototype._initArray = function(f, a, u) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d, h, b = 0;
      if (u === "be")
        for (l = f.length - 1, d = 0; l >= 0; l -= 3)
          h = f[l] | f[l - 1] << 8 | f[l - 2] << 16, this.words[d] |= h << b & 67108863, this.words[d + 1] = h >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, d++);
      else if (u === "le")
        for (l = 0, d = 0; l < f.length; l += 3)
          h = f[l] | f[l + 1] << 8 | f[l + 2] << 16, this.words[d] |= h << b & 67108863, this.words[d + 1] = h >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, d++);
      return this._strip();
    };
    function p(c, f) {
      var a = c.charCodeAt(f);
      if (a >= 48 && a <= 57)
        return a - 48;
      if (a >= 65 && a <= 70)
        return a - 55;
      if (a >= 97 && a <= 102)
        return a - 87;
      r(false, "Invalid character in " + c);
    }
    function y(c, f, a) {
      var u = p(c, a);
      return a - 1 >= f && (u |= p(c, a - 1) << 4), u;
    }
    i.prototype._parseHex = function(f, a, u) {
      this.length = Math.ceil((f.length - a) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d = 0, h = 0, b;
      if (u === "be")
        for (l = f.length - 1; l >= a; l -= 2)
          b = y(f, a, l) << d, this.words[h] |= b & 67108863, d >= 18 ? (d -= 18, h += 1, this.words[h] |= b >>> 26) : d += 8;
      else {
        var m = f.length - a;
        for (l = m % 2 === 0 ? a + 1 : a; l < f.length; l += 2)
          b = y(f, a, l) << d, this.words[h] |= b & 67108863, d >= 18 ? (d -= 18, h += 1, this.words[h] |= b >>> 26) : d += 8;
      }
      this._strip();
    };
    function w(c, f, a, u) {
      for (var l = 0, d = 0, h = Math.min(c.length, a), b = f; b < h; b++) {
        var m = c.charCodeAt(b) - 48;
        l *= u, m >= 49 ? d = m - 49 + 10 : m >= 17 ? d = m - 17 + 10 : d = m, r(m >= 0 && d < u, "Invalid character"), l += d;
      }
      return l;
    }
    i.prototype._parseBase = function(f, a, u) {
      this.words = [0], this.length = 1;
      for (var l = 0, d = 1; d <= 67108863; d *= a)
        l++;
      l--, d = d / a | 0;
      for (var h = f.length - u, b = h % l, m = Math.min(h, h - b) + u, s = 0, g = u; g < m; g += l)
        s = w(f, g, g + l, a), this.imuln(d), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      if (b !== 0) {
        var q = 1;
        for (s = w(f, g, f.length, a), g = 0; g < b; g++)
          q *= a;
        this.imuln(q), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      }
      this._strip();
    }, i.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        f.words[a] = this.words[a];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function x(c, f) {
      c.words = f.words, c.length = f.length, c.negative = f.negative, c.red = f.red;
    }
    if (i.prototype._move = function(f) {
      x(f, this);
    }, i.prototype.clone = function() {
      var f = new i(null);
      return this.copy(f), f;
    }, i.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        i.prototype[Symbol.for("nodejs.util.inspect.custom")] = M;
      } catch {
        i.prototype.inspect = M;
      }
    else
      i.prototype.inspect = M;
    function M() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(f, a) {
      f = f || 10, a = a | 0 || 1;
      var u;
      if (f === 16 || f === "hex") {
        u = "";
        for (var l = 0, d = 0, h = 0; h < this.length; h++) {
          var b = this.words[h], m = ((b << l | d) & 16777215).toString(16);
          d = b >>> 24 - l & 16777215, l += 2, l >= 26 && (l -= 26, h--), d !== 0 || h !== this.length - 1 ? u = E[6 - m.length] + m + u : u = m + u;
        }
        for (d !== 0 && (u = d.toString(16) + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var s = A[f], g = I[f];
        u = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var R2 = q.modrn(g).toString(f);
          q = q.idivn(g), q.isZero() ? u = R2 + u : u = E[s - R2.length] + R2 + u;
        }
        for (this.isZero() && (u = "0" + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (i.prototype.toBuffer = function(f, a) {
      return this.toArrayLike(o, f, a);
    }), i.prototype.toArray = function(f, a) {
      return this.toArrayLike(Array, f, a);
    };
    var D = function(f, a) {
      return f.allocUnsafe ? f.allocUnsafe(a) : new f(a);
    };
    i.prototype.toArrayLike = function(f, a, u) {
      this._strip();
      var l = this.byteLength(), d = u || Math.max(1, l);
      r(l <= d, "byte array longer than desired length"), r(d > 0, "Requested array length <= 0");
      var h = D(f, d), b = a === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b](h, l), h;
    }, i.prototype._toArrayLikeLE = function(f, a) {
      for (var u = 0, l = 0, d = 0, h = 0; d < this.length; d++) {
        var b = this.words[d] << h | l;
        f[u++] = b & 255, u < f.length && (f[u++] = b >> 8 & 255), u < f.length && (f[u++] = b >> 16 & 255), h === 6 ? (u < f.length && (f[u++] = b >> 24 & 255), l = 0, h = 0) : (l = b >>> 24, h += 2);
      }
      if (u < f.length)
        for (f[u++] = l; u < f.length; )
          f[u++] = 0;
    }, i.prototype._toArrayLikeBE = function(f, a) {
      for (var u = f.length - 1, l = 0, d = 0, h = 0; d < this.length; d++) {
        var b = this.words[d] << h | l;
        f[u--] = b & 255, u >= 0 && (f[u--] = b >> 8 & 255), u >= 0 && (f[u--] = b >> 16 & 255), h === 6 ? (u >= 0 && (f[u--] = b >> 24 & 255), l = 0, h = 0) : (l = b >>> 24, h += 2);
      }
      if (u >= 0)
        for (f[u--] = l; u >= 0; )
          f[u--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : i.prototype._countBits = function(f) {
      var a = f, u = 0;
      return a >= 4096 && (u += 13, a >>>= 13), a >= 64 && (u += 7, a >>>= 7), a >= 8 && (u += 4, a >>>= 4), a >= 2 && (u += 2, a >>>= 2), u + a;
    }, i.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var a = f, u = 0;
      return (a & 8191) === 0 && (u += 13, a >>>= 13), (a & 127) === 0 && (u += 7, a >>>= 7), (a & 15) === 0 && (u += 4, a >>>= 4), (a & 3) === 0 && (u += 2, a >>>= 2), (a & 1) === 0 && u++, u;
    }, i.prototype.bitLength = function() {
      var f = this.words[this.length - 1], a = this._countBits(f);
      return (this.length - 1) * 26 + a;
    };
    function C(c) {
      for (var f = new Array(c.bitLength()), a = 0; a < f.length; a++) {
        var u = a / 26 | 0, l = a % 26;
        f[a] = c.words[u] >>> l & 1;
      }
      return f;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, a = 0; a < this.length; a++) {
        var u = this._zeroBits(this.words[a]);
        if (f += u, u !== 26)
          break;
      }
      return f;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var a = 0; a < f.length; a++)
        this.words[a] = this.words[a] | f.words[a];
      return this._strip();
    }, i.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, i.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, i.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, i.prototype.iuand = function(f) {
      var a;
      this.length > f.length ? a = f : a = this;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] & f.words[u];
      return this.length = a.length, this._strip();
    }, i.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, i.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, i.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, i.prototype.iuxor = function(f) {
      var a, u;
      this.length > f.length ? (a = this, u = f) : (a = f, u = this);
      for (var l = 0; l < u.length; l++)
        this.words[l] = a.words[l] ^ u.words[l];
      if (this !== a)
        for (; l < a.length; l++)
          this.words[l] = a.words[l];
      return this.length = a.length, this._strip();
    }, i.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, i.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, i.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, i.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = Math.ceil(f / 26) | 0, u = f % 26;
      this._expand(a), u > 0 && a--;
      for (var l = 0; l < a; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return u > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - u), this._strip();
    }, i.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, i.prototype.setn = function(f, a) {
      r(typeof f == "number" && f >= 0);
      var u = f / 26 | 0, l = f % 26;
      return this._expand(u + 1), a ? this.words[u] = this.words[u] | 1 << l : this.words[u] = this.words[u] & ~(1 << l), this._strip();
    }, i.prototype.iadd = function(f) {
      var a;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, a = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, a = this.isub(f), f.negative = 1, a._normSign();
      var u, l;
      this.length > f.length ? (u = this, l = f) : (u = f, l = this);
      for (var d = 0, h = 0; h < l.length; h++)
        a = (u.words[h] | 0) + (l.words[h] | 0) + d, this.words[h] = a & 67108863, d = a >>> 26;
      for (; d !== 0 && h < u.length; h++)
        a = (u.words[h] | 0) + d, this.words[h] = a & 67108863, d = a >>> 26;
      if (this.length = u.length, d !== 0)
        this.words[this.length] = d, this.length++;
      else if (u !== this)
        for (; h < u.length; h++)
          this.words[h] = u.words[h];
      return this;
    }, i.prototype.add = function(f) {
      var a;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, a = this.sub(f), f.negative ^= 1, a) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = f.sub(this), this.negative = 1, a) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, i.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var a = this.iadd(f);
        return f.negative = 1, a._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var u = this.cmp(f);
      if (u === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, d;
      u > 0 ? (l = this, d = f) : (l = f, d = this);
      for (var h = 0, b = 0; b < d.length; b++)
        a = (l.words[b] | 0) - (d.words[b] | 0) + h, h = a >> 26, this.words[b] = a & 67108863;
      for (; h !== 0 && b < l.length; b++)
        a = (l.words[b] | 0) + h, h = a >> 26, this.words[b] = a & 67108863;
      if (h === 0 && b < l.length && l !== this)
        for (; b < l.length; b++)
          this.words[b] = l.words[b];
      return this.length = Math.max(this.length, b), l !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function ge(c, f, a) {
      a.negative = f.negative ^ c.negative;
      var u = c.length + f.length | 0;
      a.length = u, u = u - 1 | 0;
      var l = c.words[0] | 0, d = f.words[0] | 0, h = l * d, b = h & 67108863, m = h / 67108864 | 0;
      a.words[0] = b;
      for (var s = 1; s < u; s++) {
        for (var g = m >>> 26, q = m & 67108863, R2 = Math.min(s, f.length - 1), B = Math.max(0, s - c.length + 1); B <= R2; B++) {
          var P = s - B | 0;
          l = c.words[P] | 0, d = f.words[B] | 0, h = l * d + q, g += h / 67108864 | 0, q = h & 67108863;
        }
        a.words[s] = q | 0, m = g | 0;
      }
      return m !== 0 ? a.words[s] = m | 0 : a.length--, a._strip();
    }
    var L = function(f, a, u) {
      var l = f.words, d = a.words, h = u.words, b = 0, m, s, g, q = l[0] | 0, R2 = q & 8191, B = q >>> 13, P = l[1] | 0, T = P & 8191, N2 = P >>> 13, ze = l[2] | 0, O = ze & 8191, z = ze >>> 13, Er2 = l[3] | 0, U = Er2 & 8191, H2 = Er2 >>> 13, Ar = l[4] | 0, F = Ar & 8191, K2 = Ar >>> 13, qr = l[5] | 0, j = qr & 8191, W = qr >>> 13, Br2 = l[6] | 0, V = Br2 & 8191, Z = Br2 >>> 13, Rr = l[7] | 0, G2 = Rr & 8191, X2 = Rr >>> 13, Ir = l[8] | 0, Y = Ir & 8191, J2 = Ir >>> 13, kr = l[9] | 0, $ = kr & 8191, Q = kr >>> 13, Dr = d[0] | 0, ee = Dr & 8191, te = Dr >>> 13, Pr = d[1] | 0, re = Pr & 8191, ie = Pr >>> 13, Tr = d[2] | 0, fe = Tr & 8191, ne = Tr >>> 13, Cr = d[3] | 0, ae = Cr & 8191, se = Cr >>> 13, Nr = d[4] | 0, oe = Nr & 8191, he = Nr >>> 13, Lr = d[5] | 0, ue = Lr & 8191, de = Lr >>> 13, Or = d[6] | 0, ce = Or & 8191, le = Or >>> 13, zr = d[7] | 0, ve = zr & 8191, pe = zr >>> 13, Ur = d[8] | 0, be = Ur & 8191, me = Ur >>> 13, dr2 = d[9] | 0, _e = dr2 & 8191, we = dr2 >>> 13;
      u.negative = f.negative ^ a.negative, u.length = 19, m = Math.imul(R2, ee), s = Math.imul(R2, te), s = s + Math.imul(B, ee) | 0, g = Math.imul(B, te);
      var At = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, m = Math.imul(T, ee), s = Math.imul(T, te), s = s + Math.imul(N2, ee) | 0, g = Math.imul(N2, te), m = m + Math.imul(R2, re) | 0, s = s + Math.imul(R2, ie) | 0, s = s + Math.imul(B, re) | 0, g = g + Math.imul(B, ie) | 0;
      var qt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, m = Math.imul(O, ee), s = Math.imul(O, te), s = s + Math.imul(z, ee) | 0, g = Math.imul(z, te), m = m + Math.imul(T, re) | 0, s = s + Math.imul(T, ie) | 0, s = s + Math.imul(N2, re) | 0, g = g + Math.imul(N2, ie) | 0, m = m + Math.imul(R2, fe) | 0, s = s + Math.imul(R2, ne) | 0, s = s + Math.imul(B, fe) | 0, g = g + Math.imul(B, ne) | 0;
      var Bt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, m = Math.imul(U, ee), s = Math.imul(U, te), s = s + Math.imul(H2, ee) | 0, g = Math.imul(H2, te), m = m + Math.imul(O, re) | 0, s = s + Math.imul(O, ie) | 0, s = s + Math.imul(z, re) | 0, g = g + Math.imul(z, ie) | 0, m = m + Math.imul(T, fe) | 0, s = s + Math.imul(T, ne) | 0, s = s + Math.imul(N2, fe) | 0, g = g + Math.imul(N2, ne) | 0, m = m + Math.imul(R2, ae) | 0, s = s + Math.imul(R2, se) | 0, s = s + Math.imul(B, ae) | 0, g = g + Math.imul(B, se) | 0;
      var Rt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, m = Math.imul(F, ee), s = Math.imul(F, te), s = s + Math.imul(K2, ee) | 0, g = Math.imul(K2, te), m = m + Math.imul(U, re) | 0, s = s + Math.imul(U, ie) | 0, s = s + Math.imul(H2, re) | 0, g = g + Math.imul(H2, ie) | 0, m = m + Math.imul(O, fe) | 0, s = s + Math.imul(O, ne) | 0, s = s + Math.imul(z, fe) | 0, g = g + Math.imul(z, ne) | 0, m = m + Math.imul(T, ae) | 0, s = s + Math.imul(T, se) | 0, s = s + Math.imul(N2, ae) | 0, g = g + Math.imul(N2, se) | 0, m = m + Math.imul(R2, oe) | 0, s = s + Math.imul(R2, he) | 0, s = s + Math.imul(B, oe) | 0, g = g + Math.imul(B, he) | 0;
      var It = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, m = Math.imul(j, ee), s = Math.imul(j, te), s = s + Math.imul(W, ee) | 0, g = Math.imul(W, te), m = m + Math.imul(F, re) | 0, s = s + Math.imul(F, ie) | 0, s = s + Math.imul(K2, re) | 0, g = g + Math.imul(K2, ie) | 0, m = m + Math.imul(U, fe) | 0, s = s + Math.imul(U, ne) | 0, s = s + Math.imul(H2, fe) | 0, g = g + Math.imul(H2, ne) | 0, m = m + Math.imul(O, ae) | 0, s = s + Math.imul(O, se) | 0, s = s + Math.imul(z, ae) | 0, g = g + Math.imul(z, se) | 0, m = m + Math.imul(T, oe) | 0, s = s + Math.imul(T, he) | 0, s = s + Math.imul(N2, oe) | 0, g = g + Math.imul(N2, he) | 0, m = m + Math.imul(R2, ue) | 0, s = s + Math.imul(R2, de) | 0, s = s + Math.imul(B, ue) | 0, g = g + Math.imul(B, de) | 0;
      var kt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, m = Math.imul(V, ee), s = Math.imul(V, te), s = s + Math.imul(Z, ee) | 0, g = Math.imul(Z, te), m = m + Math.imul(j, re) | 0, s = s + Math.imul(j, ie) | 0, s = s + Math.imul(W, re) | 0, g = g + Math.imul(W, ie) | 0, m = m + Math.imul(F, fe) | 0, s = s + Math.imul(F, ne) | 0, s = s + Math.imul(K2, fe) | 0, g = g + Math.imul(K2, ne) | 0, m = m + Math.imul(U, ae) | 0, s = s + Math.imul(U, se) | 0, s = s + Math.imul(H2, ae) | 0, g = g + Math.imul(H2, se) | 0, m = m + Math.imul(O, oe) | 0, s = s + Math.imul(O, he) | 0, s = s + Math.imul(z, oe) | 0, g = g + Math.imul(z, he) | 0, m = m + Math.imul(T, ue) | 0, s = s + Math.imul(T, de) | 0, s = s + Math.imul(N2, ue) | 0, g = g + Math.imul(N2, de) | 0, m = m + Math.imul(R2, ce) | 0, s = s + Math.imul(R2, le) | 0, s = s + Math.imul(B, ce) | 0, g = g + Math.imul(B, le) | 0;
      var Dt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, m = Math.imul(G2, ee), s = Math.imul(G2, te), s = s + Math.imul(X2, ee) | 0, g = Math.imul(X2, te), m = m + Math.imul(V, re) | 0, s = s + Math.imul(V, ie) | 0, s = s + Math.imul(Z, re) | 0, g = g + Math.imul(Z, ie) | 0, m = m + Math.imul(j, fe) | 0, s = s + Math.imul(j, ne) | 0, s = s + Math.imul(W, fe) | 0, g = g + Math.imul(W, ne) | 0, m = m + Math.imul(F, ae) | 0, s = s + Math.imul(F, se) | 0, s = s + Math.imul(K2, ae) | 0, g = g + Math.imul(K2, se) | 0, m = m + Math.imul(U, oe) | 0, s = s + Math.imul(U, he) | 0, s = s + Math.imul(H2, oe) | 0, g = g + Math.imul(H2, he) | 0, m = m + Math.imul(O, ue) | 0, s = s + Math.imul(O, de) | 0, s = s + Math.imul(z, ue) | 0, g = g + Math.imul(z, de) | 0, m = m + Math.imul(T, ce) | 0, s = s + Math.imul(T, le) | 0, s = s + Math.imul(N2, ce) | 0, g = g + Math.imul(N2, le) | 0, m = m + Math.imul(R2, ve) | 0, s = s + Math.imul(R2, pe) | 0, s = s + Math.imul(B, ve) | 0, g = g + Math.imul(B, pe) | 0;
      var Pt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, m = Math.imul(Y, ee), s = Math.imul(Y, te), s = s + Math.imul(J2, ee) | 0, g = Math.imul(J2, te), m = m + Math.imul(G2, re) | 0, s = s + Math.imul(G2, ie) | 0, s = s + Math.imul(X2, re) | 0, g = g + Math.imul(X2, ie) | 0, m = m + Math.imul(V, fe) | 0, s = s + Math.imul(V, ne) | 0, s = s + Math.imul(Z, fe) | 0, g = g + Math.imul(Z, ne) | 0, m = m + Math.imul(j, ae) | 0, s = s + Math.imul(j, se) | 0, s = s + Math.imul(W, ae) | 0, g = g + Math.imul(W, se) | 0, m = m + Math.imul(F, oe) | 0, s = s + Math.imul(F, he) | 0, s = s + Math.imul(K2, oe) | 0, g = g + Math.imul(K2, he) | 0, m = m + Math.imul(U, ue) | 0, s = s + Math.imul(U, de) | 0, s = s + Math.imul(H2, ue) | 0, g = g + Math.imul(H2, de) | 0, m = m + Math.imul(O, ce) | 0, s = s + Math.imul(O, le) | 0, s = s + Math.imul(z, ce) | 0, g = g + Math.imul(z, le) | 0, m = m + Math.imul(T, ve) | 0, s = s + Math.imul(T, pe) | 0, s = s + Math.imul(N2, ve) | 0, g = g + Math.imul(N2, pe) | 0, m = m + Math.imul(R2, be) | 0, s = s + Math.imul(R2, me) | 0, s = s + Math.imul(B, be) | 0, g = g + Math.imul(B, me) | 0;
      var Tt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, m = Math.imul($, ee), s = Math.imul($, te), s = s + Math.imul(Q, ee) | 0, g = Math.imul(Q, te), m = m + Math.imul(Y, re) | 0, s = s + Math.imul(Y, ie) | 0, s = s + Math.imul(J2, re) | 0, g = g + Math.imul(J2, ie) | 0, m = m + Math.imul(G2, fe) | 0, s = s + Math.imul(G2, ne) | 0, s = s + Math.imul(X2, fe) | 0, g = g + Math.imul(X2, ne) | 0, m = m + Math.imul(V, ae) | 0, s = s + Math.imul(V, se) | 0, s = s + Math.imul(Z, ae) | 0, g = g + Math.imul(Z, se) | 0, m = m + Math.imul(j, oe) | 0, s = s + Math.imul(j, he) | 0, s = s + Math.imul(W, oe) | 0, g = g + Math.imul(W, he) | 0, m = m + Math.imul(F, ue) | 0, s = s + Math.imul(F, de) | 0, s = s + Math.imul(K2, ue) | 0, g = g + Math.imul(K2, de) | 0, m = m + Math.imul(U, ce) | 0, s = s + Math.imul(U, le) | 0, s = s + Math.imul(H2, ce) | 0, g = g + Math.imul(H2, le) | 0, m = m + Math.imul(O, ve) | 0, s = s + Math.imul(O, pe) | 0, s = s + Math.imul(z, ve) | 0, g = g + Math.imul(z, pe) | 0, m = m + Math.imul(T, be) | 0, s = s + Math.imul(T, me) | 0, s = s + Math.imul(N2, be) | 0, g = g + Math.imul(N2, me) | 0, m = m + Math.imul(R2, _e) | 0, s = s + Math.imul(R2, we) | 0, s = s + Math.imul(B, _e) | 0, g = g + Math.imul(B, we) | 0;
      var Ct = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, m = Math.imul($, re), s = Math.imul($, ie), s = s + Math.imul(Q, re) | 0, g = Math.imul(Q, ie), m = m + Math.imul(Y, fe) | 0, s = s + Math.imul(Y, ne) | 0, s = s + Math.imul(J2, fe) | 0, g = g + Math.imul(J2, ne) | 0, m = m + Math.imul(G2, ae) | 0, s = s + Math.imul(G2, se) | 0, s = s + Math.imul(X2, ae) | 0, g = g + Math.imul(X2, se) | 0, m = m + Math.imul(V, oe) | 0, s = s + Math.imul(V, he) | 0, s = s + Math.imul(Z, oe) | 0, g = g + Math.imul(Z, he) | 0, m = m + Math.imul(j, ue) | 0, s = s + Math.imul(j, de) | 0, s = s + Math.imul(W, ue) | 0, g = g + Math.imul(W, de) | 0, m = m + Math.imul(F, ce) | 0, s = s + Math.imul(F, le) | 0, s = s + Math.imul(K2, ce) | 0, g = g + Math.imul(K2, le) | 0, m = m + Math.imul(U, ve) | 0, s = s + Math.imul(U, pe) | 0, s = s + Math.imul(H2, ve) | 0, g = g + Math.imul(H2, pe) | 0, m = m + Math.imul(O, be) | 0, s = s + Math.imul(O, me) | 0, s = s + Math.imul(z, be) | 0, g = g + Math.imul(z, me) | 0, m = m + Math.imul(T, _e) | 0, s = s + Math.imul(T, we) | 0, s = s + Math.imul(N2, _e) | 0, g = g + Math.imul(N2, we) | 0;
      var Nt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, m = Math.imul($, fe), s = Math.imul($, ne), s = s + Math.imul(Q, fe) | 0, g = Math.imul(Q, ne), m = m + Math.imul(Y, ae) | 0, s = s + Math.imul(Y, se) | 0, s = s + Math.imul(J2, ae) | 0, g = g + Math.imul(J2, se) | 0, m = m + Math.imul(G2, oe) | 0, s = s + Math.imul(G2, he) | 0, s = s + Math.imul(X2, oe) | 0, g = g + Math.imul(X2, he) | 0, m = m + Math.imul(V, ue) | 0, s = s + Math.imul(V, de) | 0, s = s + Math.imul(Z, ue) | 0, g = g + Math.imul(Z, de) | 0, m = m + Math.imul(j, ce) | 0, s = s + Math.imul(j, le) | 0, s = s + Math.imul(W, ce) | 0, g = g + Math.imul(W, le) | 0, m = m + Math.imul(F, ve) | 0, s = s + Math.imul(F, pe) | 0, s = s + Math.imul(K2, ve) | 0, g = g + Math.imul(K2, pe) | 0, m = m + Math.imul(U, be) | 0, s = s + Math.imul(U, me) | 0, s = s + Math.imul(H2, be) | 0, g = g + Math.imul(H2, me) | 0, m = m + Math.imul(O, _e) | 0, s = s + Math.imul(O, we) | 0, s = s + Math.imul(z, _e) | 0, g = g + Math.imul(z, we) | 0;
      var Lt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, m = Math.imul($, ae), s = Math.imul($, se), s = s + Math.imul(Q, ae) | 0, g = Math.imul(Q, se), m = m + Math.imul(Y, oe) | 0, s = s + Math.imul(Y, he) | 0, s = s + Math.imul(J2, oe) | 0, g = g + Math.imul(J2, he) | 0, m = m + Math.imul(G2, ue) | 0, s = s + Math.imul(G2, de) | 0, s = s + Math.imul(X2, ue) | 0, g = g + Math.imul(X2, de) | 0, m = m + Math.imul(V, ce) | 0, s = s + Math.imul(V, le) | 0, s = s + Math.imul(Z, ce) | 0, g = g + Math.imul(Z, le) | 0, m = m + Math.imul(j, ve) | 0, s = s + Math.imul(j, pe) | 0, s = s + Math.imul(W, ve) | 0, g = g + Math.imul(W, pe) | 0, m = m + Math.imul(F, be) | 0, s = s + Math.imul(F, me) | 0, s = s + Math.imul(K2, be) | 0, g = g + Math.imul(K2, me) | 0, m = m + Math.imul(U, _e) | 0, s = s + Math.imul(U, we) | 0, s = s + Math.imul(H2, _e) | 0, g = g + Math.imul(H2, we) | 0;
      var Ot = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, m = Math.imul($, oe), s = Math.imul($, he), s = s + Math.imul(Q, oe) | 0, g = Math.imul(Q, he), m = m + Math.imul(Y, ue) | 0, s = s + Math.imul(Y, de) | 0, s = s + Math.imul(J2, ue) | 0, g = g + Math.imul(J2, de) | 0, m = m + Math.imul(G2, ce) | 0, s = s + Math.imul(G2, le) | 0, s = s + Math.imul(X2, ce) | 0, g = g + Math.imul(X2, le) | 0, m = m + Math.imul(V, ve) | 0, s = s + Math.imul(V, pe) | 0, s = s + Math.imul(Z, ve) | 0, g = g + Math.imul(Z, pe) | 0, m = m + Math.imul(j, be) | 0, s = s + Math.imul(j, me) | 0, s = s + Math.imul(W, be) | 0, g = g + Math.imul(W, me) | 0, m = m + Math.imul(F, _e) | 0, s = s + Math.imul(F, we) | 0, s = s + Math.imul(K2, _e) | 0, g = g + Math.imul(K2, we) | 0;
      var zt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, m = Math.imul($, ue), s = Math.imul($, de), s = s + Math.imul(Q, ue) | 0, g = Math.imul(Q, de), m = m + Math.imul(Y, ce) | 0, s = s + Math.imul(Y, le) | 0, s = s + Math.imul(J2, ce) | 0, g = g + Math.imul(J2, le) | 0, m = m + Math.imul(G2, ve) | 0, s = s + Math.imul(G2, pe) | 0, s = s + Math.imul(X2, ve) | 0, g = g + Math.imul(X2, pe) | 0, m = m + Math.imul(V, be) | 0, s = s + Math.imul(V, me) | 0, s = s + Math.imul(Z, be) | 0, g = g + Math.imul(Z, me) | 0, m = m + Math.imul(j, _e) | 0, s = s + Math.imul(j, we) | 0, s = s + Math.imul(W, _e) | 0, g = g + Math.imul(W, we) | 0;
      var Ut = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, m = Math.imul($, ce), s = Math.imul($, le), s = s + Math.imul(Q, ce) | 0, g = Math.imul(Q, le), m = m + Math.imul(Y, ve) | 0, s = s + Math.imul(Y, pe) | 0, s = s + Math.imul(J2, ve) | 0, g = g + Math.imul(J2, pe) | 0, m = m + Math.imul(G2, be) | 0, s = s + Math.imul(G2, me) | 0, s = s + Math.imul(X2, be) | 0, g = g + Math.imul(X2, me) | 0, m = m + Math.imul(V, _e) | 0, s = s + Math.imul(V, we) | 0, s = s + Math.imul(Z, _e) | 0, g = g + Math.imul(Z, we) | 0;
      var Ht = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m = Math.imul($, ve), s = Math.imul($, pe), s = s + Math.imul(Q, ve) | 0, g = Math.imul(Q, pe), m = m + Math.imul(Y, be) | 0, s = s + Math.imul(Y, me) | 0, s = s + Math.imul(J2, be) | 0, g = g + Math.imul(J2, me) | 0, m = m + Math.imul(G2, _e) | 0, s = s + Math.imul(G2, we) | 0, s = s + Math.imul(X2, _e) | 0, g = g + Math.imul(X2, we) | 0;
      var ei = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m = Math.imul($, be), s = Math.imul($, me), s = s + Math.imul(Q, be) | 0, g = Math.imul(Q, me), m = m + Math.imul(Y, _e) | 0, s = s + Math.imul(Y, we) | 0, s = s + Math.imul(J2, _e) | 0, g = g + Math.imul(J2, we) | 0;
      var ti = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m = Math.imul($, _e), s = Math.imul($, we), s = s + Math.imul(Q, _e) | 0, g = Math.imul(Q, we);
      var ri = (b + m | 0) + ((s & 8191) << 13) | 0;
      return b = (g + (s >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, h[0] = At, h[1] = qt, h[2] = Bt, h[3] = Rt, h[4] = It, h[5] = kt, h[6] = Dt, h[7] = Pt, h[8] = Tt, h[9] = Ct, h[10] = Nt, h[11] = Lt, h[12] = Ot, h[13] = zt, h[14] = Ut, h[15] = Ht, h[16] = ei, h[17] = ti, h[18] = ri, b !== 0 && (h[19] = b, u.length++), u;
    };
    Math.imul || (L = ge);
    function ye(c, f, a) {
      a.negative = f.negative ^ c.negative, a.length = c.length + f.length;
      for (var u = 0, l = 0, d = 0; d < a.length - 1; d++) {
        var h = l;
        l = 0;
        for (var b = u & 67108863, m = Math.min(d, f.length - 1), s = Math.max(0, d - c.length + 1); s <= m; s++) {
          var g = d - s, q = c.words[g] | 0, R2 = f.words[s] | 0, B = q * R2, P = B & 67108863;
          h = h + (B / 67108864 | 0) | 0, P = P + b | 0, b = P & 67108863, h = h + (P >>> 26) | 0, l += h >>> 26, h &= 67108863;
        }
        a.words[d] = b, u = h, h = l;
      }
      return u !== 0 ? a.words[d] = u : a.length--, a._strip();
    }
    function Re(c, f, a) {
      return ye(c, f, a);
    }
    i.prototype.mulTo = function(f, a) {
      var u, l = this.length + f.length;
      return this.length === 10 && f.length === 10 ? u = L(this, f, a) : l < 63 ? u = ge(this, f, a) : l < 1024 ? u = ye(this, f, a) : u = Re(this, f, a), u;
    };
    function xe(c, f) {
      this.x = c, this.y = f;
    }
    xe.prototype.makeRBT = function(f) {
      for (var a = new Array(f), u = i.prototype._countBits(f) - 1, l = 0; l < f; l++)
        a[l] = this.revBin(l, u, f);
      return a;
    }, xe.prototype.revBin = function(f, a, u) {
      if (f === 0 || f === u - 1)
        return f;
      for (var l = 0, d = 0; d < a; d++)
        l |= (f & 1) << a - d - 1, f >>= 1;
      return l;
    }, xe.prototype.permute = function(f, a, u, l, d, h) {
      for (var b = 0; b < h; b++)
        l[b] = a[f[b]], d[b] = u[f[b]];
    }, xe.prototype.transform = function(f, a, u, l, d, h) {
      this.permute(h, f, a, u, l, d);
      for (var b = 1; b < d; b <<= 1)
        for (var m = b << 1, s = Math.cos(2 * Math.PI / m), g = Math.sin(2 * Math.PI / m), q = 0; q < d; q += m)
          for (var R2 = s, B = g, P = 0; P < b; P++) {
            var T = u[q + P], N2 = l[q + P], ze = u[q + P + b], O = l[q + P + b], z = R2 * ze - B * O;
            O = R2 * O + B * ze, ze = z, u[q + P] = T + ze, l[q + P] = N2 + O, u[q + P + b] = T - ze, l[q + P + b] = N2 - O, P !== m && (z = s * R2 - g * B, B = s * B + g * R2, R2 = z);
          }
    }, xe.prototype.guessLen13b = function(f, a) {
      var u = Math.max(a, f) | 1, l = u & 1, d = 0;
      for (u = u / 2 | 0; u; u = u >>> 1)
        d++;
      return 1 << d + 1 + l;
    }, xe.prototype.conjugate = function(f, a, u) {
      if (!(u <= 1))
        for (var l = 0; l < u / 2; l++) {
          var d = f[l];
          f[l] = f[u - l - 1], f[u - l - 1] = d, d = a[l], a[l] = -a[u - l - 1], a[u - l - 1] = -d;
        }
    }, xe.prototype.normalize13b = function(f, a) {
      for (var u = 0, l = 0; l < a / 2; l++) {
        var d = Math.round(f[2 * l + 1] / a) * 8192 + Math.round(f[2 * l] / a) + u;
        f[l] = d & 67108863, d < 67108864 ? u = 0 : u = d / 67108864 | 0;
      }
      return f;
    }, xe.prototype.convert13b = function(f, a, u, l) {
      for (var d = 0, h = 0; h < a; h++)
        d = d + (f[h] | 0), u[2 * h] = d & 8191, d = d >>> 13, u[2 * h + 1] = d & 8191, d = d >>> 13;
      for (h = 2 * a; h < l; ++h)
        u[h] = 0;
      r(d === 0), r((d & -8192) === 0);
    }, xe.prototype.stub = function(f) {
      for (var a = new Array(f), u = 0; u < f; u++)
        a[u] = 0;
      return a;
    }, xe.prototype.mulp = function(f, a, u) {
      var l = 2 * this.guessLen13b(f.length, a.length), d = this.makeRBT(l), h = this.stub(l), b = new Array(l), m = new Array(l), s = new Array(l), g = new Array(l), q = new Array(l), R2 = new Array(l), B = u.words;
      B.length = l, this.convert13b(f.words, f.length, b, l), this.convert13b(a.words, a.length, g, l), this.transform(b, h, m, s, l, d), this.transform(g, h, q, R2, l, d);
      for (var P = 0; P < l; P++) {
        var T = m[P] * q[P] - s[P] * R2[P];
        s[P] = m[P] * R2[P] + s[P] * q[P], m[P] = T;
      }
      return this.conjugate(m, s, l), this.transform(m, s, B, h, l, d), this.conjugate(B, h, l), this.normalize13b(B, l), u.negative = f.negative ^ a.negative, u.length = f.length + a.length, u._strip();
    }, i.prototype.mul = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), this.mulTo(f, a);
    }, i.prototype.mulf = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), Re(this, f, a);
    }, i.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, i.prototype.imuln = function(f) {
      var a = f < 0;
      a && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var u = 0, l = 0; l < this.length; l++) {
        var d = (this.words[l] | 0) * f, h = (d & 67108863) + (u & 67108863);
        u >>= 26, u += d / 67108864 | 0, u += h >>> 26, this.words[l] = h & 67108863;
      }
      return u !== 0 && (this.words[l] = u, this.length++), a ? this.ineg() : this;
    }, i.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(f) {
      var a = C(f);
      if (a.length === 0)
        return new i(1);
      for (var u = this, l = 0; l < a.length && a[l] === 0; l++, u = u.sqr())
        ;
      if (++l < a.length)
        for (var d = u.sqr(); l < a.length; l++, d = d.sqr())
          a[l] !== 0 && (u = u.mul(d));
      return u;
    }, i.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 67108863 >>> 26 - a << 26 - a, d;
      if (a !== 0) {
        var h = 0;
        for (d = 0; d < this.length; d++) {
          var b = this.words[d] & l, m = (this.words[d] | 0) - b << a;
          this.words[d] = m | h, h = b >>> 26 - a;
        }
        h && (this.words[d] = h, this.length++);
      }
      if (u !== 0) {
        for (d = this.length - 1; d >= 0; d--)
          this.words[d + u] = this.words[d];
        for (d = 0; d < u; d++)
          this.words[d] = 0;
        this.length += u;
      }
      return this._strip();
    }, i.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, i.prototype.iushrn = function(f, a, u) {
      r(typeof f == "number" && f >= 0);
      var l;
      a ? l = (a - a % 26) / 26 : l = 0;
      var d = f % 26, h = Math.min((f - d) / 26, this.length), b = 67108863 ^ 67108863 >>> d << d, m = u;
      if (l -= h, l = Math.max(0, l), m) {
        for (var s = 0; s < h; s++)
          m.words[s] = this.words[s];
        m.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, s = 0; s < this.length; s++)
            this.words[s] = this.words[s + h];
        else
          this.words[0] = 0, this.length = 1;
      var g = 0;
      for (s = this.length - 1; s >= 0 && (g !== 0 || s >= l); s--) {
        var q = this.words[s] | 0;
        this.words[s] = g << 26 - d | q >>> d, g = q & b;
      }
      return m && g !== 0 && (m.words[m.length++] = g), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(f, a, u) {
      return r(this.negative === 0), this.iushrn(f, a, u);
    }, i.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, i.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, i.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, i.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, i.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return false;
      var d = this.words[u];
      return !!(d & l);
    }, i.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u)
        return this;
      if (a !== 0 && u++, this.length = Math.min(u, this.length), a !== 0) {
        var l = 67108863 ^ 67108863 >>> a << a;
        this.words[this.length - 1] &= l;
      }
      return this._strip();
    }, i.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, i.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, i.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var a = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
      return this.length = Math.max(this.length, a + 1), this;
    }, i.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a = 0; a < this.length && this.words[a] < 0; a++)
          this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, i.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(f, a, u) {
      var l = f.length + u, d;
      this._expand(l);
      var h, b = 0;
      for (d = 0; d < f.length; d++) {
        h = (this.words[d + u] | 0) + b;
        var m = (f.words[d] | 0) * a;
        h -= m & 67108863, b = (h >> 26) - (m / 67108864 | 0), this.words[d + u] = h & 67108863;
      }
      for (; d < this.length - u; d++)
        h = (this.words[d + u] | 0) + b, b = h >> 26, this.words[d + u] = h & 67108863;
      if (b === 0)
        return this._strip();
      for (r(b === -1), b = 0, d = 0; d < this.length; d++)
        h = -(this.words[d] | 0) + b, b = h >> 26, this.words[d] = h & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(f, a) {
      var u = this.length - f.length, l = this.clone(), d = f, h = d.words[d.length - 1] | 0, b = this._countBits(h);
      u = 26 - b, u !== 0 && (d = d.ushln(u), l.iushln(u), h = d.words[d.length - 1] | 0);
      var m = l.length - d.length, s;
      if (a !== "mod") {
        s = new i(null), s.length = m + 1, s.words = new Array(s.length);
        for (var g = 0; g < s.length; g++)
          s.words[g] = 0;
      }
      var q = l.clone()._ishlnsubmul(d, 1, m);
      q.negative === 0 && (l = q, s && (s.words[m] = 1));
      for (var R2 = m - 1; R2 >= 0; R2--) {
        var B = (l.words[d.length + R2] | 0) * 67108864 + (l.words[d.length + R2 - 1] | 0);
        for (B = Math.min(B / h | 0, 67108863), l._ishlnsubmul(d, B, R2); l.negative !== 0; )
          B--, l.negative = 0, l._ishlnsubmul(d, 1, R2), l.isZero() || (l.negative ^= 1);
        s && (s.words[R2] = B);
      }
      return s && s._strip(), l._strip(), a !== "div" && u !== 0 && l.iushrn(u), { div: s || null, mod: l };
    }, i.prototype.divmod = function(f, a, u) {
      if (r(!f.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var l, d, h;
      return this.negative !== 0 && f.negative === 0 ? (h = this.neg().divmod(f, a), a !== "mod" && (l = h.div.neg()), a !== "div" && (d = h.mod.neg(), u && d.negative !== 0 && d.iadd(f)), { div: l, mod: d }) : this.negative === 0 && f.negative !== 0 ? (h = this.divmod(f.neg(), a), a !== "mod" && (l = h.div.neg()), { div: l, mod: h.mod }) : (this.negative & f.negative) !== 0 ? (h = this.neg().divmod(f.neg(), a), a !== "div" && (d = h.mod.neg(), u && d.negative !== 0 && d.isub(f)), { div: h.div, mod: d }) : f.length > this.length || this.cmp(f) < 0 ? { div: new i(0), mod: this } : f.length === 1 ? a === "div" ? { div: this.divn(f.words[0]), mod: null } : a === "mod" ? { div: null, mod: new i(this.modrn(f.words[0])) } : { div: this.divn(f.words[0]), mod: new i(this.modrn(f.words[0])) } : this._wordDiv(f, a);
    }, i.prototype.div = function(f) {
      return this.divmod(f, "div", false).div;
    }, i.prototype.mod = function(f) {
      return this.divmod(f, "mod", false).mod;
    }, i.prototype.umod = function(f) {
      return this.divmod(f, "mod", true).mod;
    }, i.prototype.divRound = function(f) {
      var a = this.divmod(f);
      if (a.mod.isZero())
        return a.div;
      var u = a.div.negative !== 0 ? a.mod.isub(f) : a.mod, l = f.ushrn(1), d = f.andln(1), h = u.cmp(l);
      return h < 0 || d === 1 && h === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
    }, i.prototype.modrn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = (1 << 26) % f, l = 0, d = this.length - 1; d >= 0; d--)
        l = (u * l + (this.words[d] | 0)) % f;
      return a ? -l : l;
    }, i.prototype.modn = function(f) {
      return this.modrn(f);
    }, i.prototype.idivn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d = (this.words[l] | 0) + u * 67108864;
        this.words[l] = d / f | 0, u = d % f;
      }
      return this._strip(), a ? this.ineg() : this;
    }, i.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, i.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d = new i(0), h = new i(0), b = new i(1), m = 0; a.isEven() && u.isEven(); )
        a.iushrn(1), u.iushrn(1), ++m;
      for (var s = u.clone(), g = a.clone(); !a.isZero(); ) {
        for (var q = 0, R2 = 1; (a.words[0] & R2) === 0 && q < 26; ++q, R2 <<= 1)
          ;
        if (q > 0)
          for (a.iushrn(q); q-- > 0; )
            (l.isOdd() || d.isOdd()) && (l.iadd(s), d.isub(g)), l.iushrn(1), d.iushrn(1);
        for (var B = 0, P = 1; (u.words[0] & P) === 0 && B < 26; ++B, P <<= 1)
          ;
        if (B > 0)
          for (u.iushrn(B); B-- > 0; )
            (h.isOdd() || b.isOdd()) && (h.iadd(s), b.isub(g)), h.iushrn(1), b.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(h), d.isub(b)) : (u.isub(a), h.isub(l), b.isub(d));
      }
      return { a: h, b, gcd: u.iushln(m) };
    }, i.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d = new i(0), h = u.clone(); a.cmpn(1) > 0 && u.cmpn(1) > 0; ) {
        for (var b = 0, m = 1; (a.words[0] & m) === 0 && b < 26; ++b, m <<= 1)
          ;
        if (b > 0)
          for (a.iushrn(b); b-- > 0; )
            l.isOdd() && l.iadd(h), l.iushrn(1);
        for (var s = 0, g = 1; (u.words[0] & g) === 0 && s < 26; ++s, g <<= 1)
          ;
        if (s > 0)
          for (u.iushrn(s); s-- > 0; )
            d.isOdd() && d.iadd(h), d.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(d)) : (u.isub(a), d.isub(l));
      }
      var q;
      return a.cmpn(1) === 0 ? q = l : q = d, q.cmpn(0) < 0 && q.iadd(f), q;
    }, i.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var a = this.clone(), u = f.clone();
      a.negative = 0, u.negative = 0;
      for (var l = 0; a.isEven() && u.isEven(); l++)
        a.iushrn(1), u.iushrn(1);
      do {
        for (; a.isEven(); )
          a.iushrn(1);
        for (; u.isEven(); )
          u.iushrn(1);
        var d = a.cmp(u);
        if (d < 0) {
          var h = a;
          a = u, u = h;
        } else if (d === 0 || u.cmpn(1) === 0)
          break;
        a.isub(u);
      } while (true);
      return u.iushln(l);
    }, i.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(f) {
      return this.words[0] & f;
    }, i.prototype.bincn = function(f) {
      r(typeof f == "number");
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return this._expand(u + 1), this.words[u] |= l, this;
      for (var d = l, h = u; d !== 0 && h < this.length; h++) {
        var b = this.words[h] | 0;
        b += d, d = b >>> 26, b &= 67108863, this.words[h] = b;
      }
      return d !== 0 && (this.words[h] = d, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(f) {
      var a = f < 0;
      if (this.negative !== 0 && !a)
        return -1;
      if (this.negative === 0 && a)
        return 1;
      this._strip();
      var u;
      if (this.length > 1)
        u = 1;
      else {
        a && (f = -f), r(f <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        u = l === f ? 0 : l < f ? -1 : 1;
      }
      return this.negative !== 0 ? -u | 0 : u;
    }, i.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var a = this.ucmp(f);
      return this.negative !== 0 ? -a | 0 : a;
    }, i.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var a = 0, u = this.length - 1; u >= 0; u--) {
        var l = this.words[u] | 0, d = f.words[u] | 0;
        if (l !== d) {
          l < d ? a = -1 : l > d && (a = 1);
          break;
        }
      }
      return a;
    }, i.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, i.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, i.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, i.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, i.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, i.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, i.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, i.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, i.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, i.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, i.red = function(f) {
      return new v(f);
    }, i.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, i.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, i.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, i.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, i.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, i.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, i.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, i.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, i.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ke = { k256: null, p224: null, p192: null, p25519: null };
    function Me(c, f) {
      this.name = c, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var f = new i(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Me.prototype.ireduce = function(f) {
      var a = f, u;
      do
        this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), u = a.bitLength();
      while (u > this.n);
      var l = u < this.n ? -1 : a.ucmp(this.p);
      return l === 0 ? (a.words[0] = 0, a.length = 1) : l > 0 ? a.isub(this.p) : a.strip !== void 0 ? a.strip() : a._strip(), a;
    }, Me.prototype.split = function(f, a) {
      f.iushrn(this.n, 0, a);
    }, Me.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function Ce() {
      Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(Ce, Me), Ce.prototype.split = function(f, a) {
      for (var u = 4194303, l = Math.min(f.length, 9), d = 0; d < l; d++)
        a.words[d] = f.words[d];
      if (a.length = l, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var h = f.words[9];
      for (a.words[a.length++] = h & u, d = 10; d < f.length; d++) {
        var b = f.words[d] | 0;
        f.words[d - 10] = (b & u) << 4 | h >>> 22, h = b;
      }
      h >>>= 22, f.words[d - 10] = h, h === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, Ce.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = f.words[u] | 0;
        a += l * 977, f.words[u] = a & 67108863, a = l * 64 + (a / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Ee() {
      Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(Ee, Me);
    function Ne() {
      Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Ne, Me);
    function S() {
      Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(S, Me), S.prototype.imulK = function(f) {
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = (f.words[u] | 0) * 19 + a, d = l & 67108863;
        l >>>= 26, f.words[u] = d, a = l;
      }
      return a !== 0 && (f.words[f.length++] = a), f;
    }, i._prime = function(f) {
      if (ke[f])
        return ke[f];
      var a;
      if (f === "k256")
        a = new Ce();
      else if (f === "p224")
        a = new Ee();
      else if (f === "p192")
        a = new Ne();
      else if (f === "p25519")
        a = new S();
      else
        throw new Error("Unknown prime " + f);
      return ke[f] = a, a;
    };
    function v(c) {
      if (typeof c == "string") {
        var f = i._prime(c);
        this.m = f.p, this.prime = f;
      } else
        r(c.gtn(1), "modulus must be greater than 1"), this.m = c, this.prime = null;
    }
    v.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, v.prototype._verify2 = function(f, a) {
      r((f.negative | a.negative) === 0, "red works only with positives"), r(f.red && f.red === a.red, "red works only with red numbers");
    }, v.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (x(f, f.umod(this.m)._forceRed(this)), f);
    }, v.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, v.prototype.add = function(f, a) {
      this._verify2(f, a);
      var u = f.add(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u._forceRed(this);
    }, v.prototype.iadd = function(f, a) {
      this._verify2(f, a);
      var u = f.iadd(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u;
    }, v.prototype.sub = function(f, a) {
      this._verify2(f, a);
      var u = f.sub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u._forceRed(this);
    }, v.prototype.isub = function(f, a) {
      this._verify2(f, a);
      var u = f.isub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u;
    }, v.prototype.shl = function(f, a) {
      return this._verify1(f), this.imod(f.ushln(a));
    }, v.prototype.imul = function(f, a) {
      return this._verify2(f, a), this.imod(f.imul(a));
    }, v.prototype.mul = function(f, a) {
      return this._verify2(f, a), this.imod(f.mul(a));
    }, v.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, v.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, v.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var a = this.m.andln(3);
      if (r(a % 2 === 1), a === 3) {
        var u = this.m.add(new i(1)).iushrn(2);
        return this.pow(f, u);
      }
      for (var l = this.m.subn(1), d = 0; !l.isZero() && l.andln(1) === 0; )
        d++, l.iushrn(1);
      r(!l.isZero());
      var h = new i(1).toRed(this), b = h.redNeg(), m = this.m.subn(1).iushrn(1), s = this.m.bitLength();
      for (s = new i(2 * s * s).toRed(this); this.pow(s, m).cmp(b) !== 0; )
        s.redIAdd(b);
      for (var g = this.pow(s, l), q = this.pow(f, l.addn(1).iushrn(1)), R2 = this.pow(f, l), B = d; R2.cmp(h) !== 0; ) {
        for (var P = R2, T = 0; P.cmp(h) !== 0; T++)
          P = P.redSqr();
        r(T < B);
        var N2 = this.pow(g, new i(1).iushln(B - T - 1));
        q = q.redMul(N2), g = N2.redSqr(), R2 = R2.redMul(g), B = T;
      }
      return q;
    }, v.prototype.invm = function(f) {
      var a = f._invmp(this.m);
      return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
    }, v.prototype.pow = function(f, a) {
      if (a.isZero())
        return new i(1).toRed(this);
      if (a.cmpn(1) === 0)
        return f.clone();
      var u = 4, l = new Array(1 << u);
      l[0] = new i(1).toRed(this), l[1] = f;
      for (var d = 2; d < l.length; d++)
        l[d] = this.mul(l[d - 1], f);
      var h = l[0], b = 0, m = 0, s = a.bitLength() % 26;
      for (s === 0 && (s = 26), d = a.length - 1; d >= 0; d--) {
        for (var g = a.words[d], q = s - 1; q >= 0; q--) {
          var R2 = g >> q & 1;
          if (h !== l[0] && (h = this.sqr(h)), R2 === 0 && b === 0) {
            m = 0;
            continue;
          }
          b <<= 1, b |= R2, m++, !(m !== u && (d !== 0 || q !== 0)) && (h = this.mul(h, l[b]), m = 0, b = 0);
        }
        s = 26;
      }
      return h;
    }, v.prototype.convertTo = function(f) {
      var a = f.umod(this.m);
      return a === f ? a.clone() : a;
    }, v.prototype.convertFrom = function(f) {
      var a = f.clone();
      return a.red = null, a;
    }, i.mont = function(f) {
      return new _(f);
    };
    function _(c) {
      v.call(this, c), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(_, v), _.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, _.prototype.convertFrom = function(f) {
      var a = this.imod(f.mul(this.rinv));
      return a.red = null, a;
    }, _.prototype.imul = function(f, a) {
      if (f.isZero() || a.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var u = f.imul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d = u.isub(l).iushrn(this.shift), h = d;
      return d.cmp(this.m) >= 0 ? h = d.isub(this.m) : d.cmpn(0) < 0 && (h = d.iadd(this.m)), h._forceRed(this);
    }, _.prototype.mul = function(f, a) {
      if (f.isZero() || a.isZero())
        return new i(0)._forceRed(this);
      var u = f.mul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d = u.isub(l).iushrn(this.shift), h = d;
      return d.cmp(this.m) >= 0 ? h = d.isub(this.m) : d.cmpn(0) < 0 && (h = d.iadd(this.m)), h._forceRed(this);
    }, _.prototype.invm = function(f) {
      var a = this.imod(f._invmp(this.m).mul(this.r2));
      return a._forceRed(this);
    };
  })(typeof F0 > "u" || F0, ud);
});
var Hn = k2((cm, vd) => {
  var Ki = dd(), i6 = fi();
  function f6(t) {
    var e = cd(t), r = e.toRed(Ki.mont(t.modulus)).redPow(new Ki(t.publicExponent)).fromRed();
    return { blinder: r, unblinder: e.invm(t.modulus) };
  }
  function cd(t) {
    var e = t.modulus.byteLength(), r;
    do
      r = new Ki(i6(e));
    while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
    return r;
  }
  function ld(t, e) {
    var r = f6(e), n = e.modulus.byteLength(), i = new Ki(t).mul(r.blinder).umod(e.modulus), o = i.toRed(Ki.mont(e.prime1)), p = i.toRed(Ki.mont(e.prime2)), y = e.coefficient, w = e.prime1, x = e.prime2, M = o.redPow(e.exponent1).fromRed(), E = p.redPow(e.exponent2).fromRed(), A = M.isub(E).imul(y).umod(w).imul(x);
    return E.iadd(A).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer3, "be", n);
  }
  ld.getr = cd;
  vd.exports = ld;
});
var pd = k2((lm, n6) => {
  n6.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
});
var K0 = k2((gd) => {
  "use strict";
  var Fn = gd;
  function a6(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t != "string") {
      for (var n = 0; n < t.length; n++)
        r[n] = t[n] | 0;
      return r;
    }
    if (e === "hex") {
      t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
      for (var n = 0; n < t.length; n += 2)
        r.push(parseInt(t[n] + t[n + 1], 16));
    } else
      for (var n = 0; n < t.length; n++) {
        var i = t.charCodeAt(n), o = i >> 8, p = i & 255;
        o ? r.push(o, p) : r.push(p);
      }
    return r;
  }
  Fn.toArray = a6;
  function bd(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Fn.zero2 = bd;
  function md(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += bd(t[r].toString(16));
    return e;
  }
  Fn.toHex = md;
  Fn.encode = function(e, r) {
    return r === "hex" ? md(e) : e;
  };
});
var ht2 = k2((yd) => {
  "use strict";
  var Wt = yd, s6 = Fe(), o6 = ot(), Kn = K0();
  Wt.assert = o6;
  Wt.toArray = Kn.toArray;
  Wt.zero2 = Kn.zero2;
  Wt.toHex = Kn.toHex;
  Wt.encode = Kn.encode;
  function h6(t, e, r) {
    var n = new Array(Math.max(t.bitLength(), r) + 1);
    n.fill(0);
    for (var i = 1 << e + 1, o = t.clone(), p = 0; p < n.length; p++) {
      var y, w = o.andln(i - 1);
      o.isOdd() ? (w > (i >> 1) - 1 ? y = (i >> 1) - w : y = w, o.isubn(y)) : y = 0, n[p] = y, o.iushrn(1);
    }
    return n;
  }
  Wt.getNAF = h6;
  function u6(t, e) {
    var r = [[], []];
    t = t.clone(), e = e.clone();
    for (var n = 0, i = 0, o; t.cmpn(-n) > 0 || e.cmpn(-i) > 0; ) {
      var p = t.andln(3) + n & 3, y = e.andln(3) + i & 3;
      p === 3 && (p = -1), y === 3 && (y = -1);
      var w;
      (p & 1) === 0 ? w = 0 : (o = t.andln(7) + n & 7, (o === 3 || o === 5) && y === 2 ? w = -p : w = p), r[0].push(w);
      var x;
      (y & 1) === 0 ? x = 0 : (o = e.andln(7) + i & 7, (o === 3 || o === 5) && p === 2 ? x = -y : x = y), r[1].push(x), 2 * n === w + 1 && (n = 1 - n), 2 * i === x + 1 && (i = 1 - i), t.iushrn(1), e.iushrn(1);
    }
    return r;
  }
  Wt.getJSF = u6;
  function d6(t, e, r) {
    var n = "_" + e;
    t.prototype[e] = function() {
      return this[n] !== void 0 ? this[n] : this[n] = r.call(this);
    };
  }
  Wt.cachedProperty = d6;
  function c6(t) {
    return typeof t == "string" ? Wt.toArray(t, "hex") : t;
  }
  Wt.parseBytes = c6;
  function l6(t) {
    return new s6(t, "hex", "le");
  }
  Wt.intFromLE = l6;
});
var Lf = k2((bm, _d) => {
  "use strict";
  var wi = Fe(), Nf = ht2(), jn = Nf.getNAF, v6 = Nf.getJSF, Wn = Nf.assert;
  function Xr(t, e) {
    this.type = t, this.p = new wi(e.p, 16), this.red = e.prime ? wi.red(e.prime) : wi.mont(this.p), this.zero = new wi(0).toRed(this.red), this.one = new wi(1).toRed(this.red), this.two = new wi(2).toRed(this.red), this.n = e.n && new wi(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  _d.exports = Xr;
  Xr.prototype.point = function() {
    throw new Error("Not implemented");
  };
  Xr.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  Xr.prototype._fixedNafMul = function(e, r) {
    Wn(e.precomputed);
    var n = e._getDoubles(), i = jn(r, 1, this._bitLength), o = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
    o /= 3;
    var p = [], y, w;
    for (y = 0; y < i.length; y += n.step) {
      w = 0;
      for (var x = y + n.step - 1; x >= y; x--)
        w = (w << 1) + i[x];
      p.push(w);
    }
    for (var M = this.jpoint(null, null, null), E = this.jpoint(null, null, null), A = o; A > 0; A--) {
      for (y = 0; y < p.length; y++)
        w = p[y], w === A ? E = E.mixedAdd(n.points[y]) : w === -A && (E = E.mixedAdd(n.points[y].neg()));
      M = M.add(E);
    }
    return M.toP();
  };
  Xr.prototype._wnafMul = function(e, r) {
    var n = 4, i = e._getNAFPoints(n);
    n = i.wnd;
    for (var o = i.points, p = jn(r, n, this._bitLength), y = this.jpoint(null, null, null), w = p.length - 1; w >= 0; w--) {
      for (var x = 0; w >= 0 && p[w] === 0; w--)
        x++;
      if (w >= 0 && x++, y = y.dblp(x), w < 0)
        break;
      var M = p[w];
      Wn(M !== 0), e.type === "affine" ? M > 0 ? y = y.mixedAdd(o[M - 1 >> 1]) : y = y.mixedAdd(o[-M - 1 >> 1].neg()) : M > 0 ? y = y.add(o[M - 1 >> 1]) : y = y.add(o[-M - 1 >> 1].neg());
    }
    return e.type === "affine" ? y.toP() : y;
  };
  Xr.prototype._wnafMulAdd = function(e, r, n, i, o) {
    var p = this._wnafT1, y = this._wnafT2, w = this._wnafT3, x = 0, M, E, A;
    for (M = 0; M < i; M++) {
      A = r[M];
      var I = A._getNAFPoints(e);
      p[M] = I.wnd, y[M] = I.points;
    }
    for (M = i - 1; M >= 1; M -= 2) {
      var D = M - 1, C = M;
      if (p[D] !== 1 || p[C] !== 1) {
        w[D] = jn(n[D], p[D], this._bitLength), w[C] = jn(n[C], p[C], this._bitLength), x = Math.max(w[D].length, x), x = Math.max(w[C].length, x);
        continue;
      }
      var ge = [r[D], null, null, r[C]];
      r[D].y.cmp(r[C].y) === 0 ? (ge[1] = r[D].add(r[C]), ge[2] = r[D].toJ().mixedAdd(r[C].neg())) : r[D].y.cmp(r[C].y.redNeg()) === 0 ? (ge[1] = r[D].toJ().mixedAdd(r[C]), ge[2] = r[D].add(r[C].neg())) : (ge[1] = r[D].toJ().mixedAdd(r[C]), ge[2] = r[D].toJ().mixedAdd(r[C].neg()));
      var L = [-3, -1, -5, -7, 0, 7, 5, 1, 3], ye = v6(n[D], n[C]);
      for (x = Math.max(ye[0].length, x), w[D] = new Array(x), w[C] = new Array(x), E = 0; E < x; E++) {
        var Re = ye[0][E] | 0, xe = ye[1][E] | 0;
        w[D][E] = L[(Re + 1) * 3 + (xe + 1)], w[C][E] = 0, y[D] = ge;
      }
    }
    var ke = this.jpoint(null, null, null), Me = this._wnafT4;
    for (M = x; M >= 0; M--) {
      for (var Ce = 0; M >= 0; ) {
        var Ee = true;
        for (E = 0; E < i; E++)
          Me[E] = w[E][M] | 0, Me[E] !== 0 && (Ee = false);
        if (!Ee)
          break;
        Ce++, M--;
      }
      if (M >= 0 && Ce++, ke = ke.dblp(Ce), M < 0)
        break;
      for (E = 0; E < i; E++) {
        var Ne = Me[E];
        Ne !== 0 && (Ne > 0 ? A = y[E][Ne - 1 >> 1] : Ne < 0 && (A = y[E][-Ne - 1 >> 1].neg()), A.type === "affine" ? ke = ke.mixedAdd(A) : ke = ke.add(A));
      }
    }
    for (M = 0; M < i; M++)
      y[M] = null;
    return o ? ke : ke.toP();
  };
  function gt2(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  Xr.BasePoint = gt2;
  gt2.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  gt2.prototype.validate = function() {
    return this.curve.validate(this);
  };
  Xr.prototype.decodePoint = function(e, r) {
    e = Nf.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
      e[0] === 6 ? Wn(e[e.length - 1] % 2 === 0) : e[0] === 7 && Wn(e[e.length - 1] % 2 === 1);
      var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
      return i;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
      return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format");
  };
  gt2.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  gt2.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
  };
  gt2.prototype.encode = function(e, r) {
    return Nf.encode(this._encode(r), e);
  };
  gt2.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var r = { doubles: null, naf: null, beta: null };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
  };
  gt2.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
  };
  gt2.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var n = [this], i = this, o = 0; o < r; o += e) {
      for (var p = 0; p < e; p++)
        i = i.dbl();
      n.push(i);
    }
    return { step: e, points: n };
  };
  gt2.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), o = 1; o < n; o++)
      r[o] = r[o - 1].add(i);
    return { wnd: e, points: r };
  };
  gt2.prototype._getBeta = function() {
    return null;
  };
  gt2.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++)
      r = r.dbl();
    return r;
  };
});
var xd = k2((mm, wd) => {
  "use strict";
  var p6 = ht2(), Oe = Fe(), j0 = qe(), ji = Lf(), b6 = p6.assert;
  function yt(t) {
    ji.call(this, "short", t), this.a = new Oe(t.a, 16).toRed(this.red), this.b = new Oe(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  j0(yt, ji);
  wd.exports = yt;
  yt.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var r, n;
      if (e.beta)
        r = new Oe(e.beta, 16).toRed(this.red);
      else {
        var i = this._getEndoRoots(this.p);
        r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
      }
      if (e.lambda)
        n = new Oe(e.lambda, 16);
      else {
        var o = this._getEndoRoots(this.n);
        this.g.mul(o[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = o[0] : (n = o[1], b6(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
      }
      var p;
      return e.basis ? p = e.basis.map(function(y) {
        return { a: new Oe(y.a, 16), b: new Oe(y.b, 16) };
      }) : p = this._getEndoBasis(n), { beta: r, lambda: n, basis: p };
    }
  };
  yt.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : Oe.mont(e), n = new Oe(2).toRed(r).redInvm(), i = n.redNeg(), o = new Oe(3).toRed(r).redNeg().redSqrt().redMul(n), p = i.redAdd(o).fromRed(), y = i.redSub(o).fromRed();
    return [p, y];
  };
  yt.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), o = new Oe(1), p = new Oe(0), y = new Oe(0), w = new Oe(1), x, M, E, A, I, D, C, ge = 0, L, ye; n.cmpn(0) !== 0; ) {
      var Re = i.div(n);
      L = i.sub(Re.mul(n)), ye = y.sub(Re.mul(o));
      var xe = w.sub(Re.mul(p));
      if (!E && L.cmp(r) < 0)
        x = C.neg(), M = o, E = L.neg(), A = ye;
      else if (E && ++ge === 2)
        break;
      C = L, i = n, n = L, y = o, o = ye, w = p, p = xe;
    }
    I = L.neg(), D = ye;
    var ke = E.sqr().add(A.sqr()), Me = I.sqr().add(D.sqr());
    return Me.cmp(ke) >= 0 && (I = x, D = M), E.negative && (E = E.neg(), A = A.neg()), I.negative && (I = I.neg(), D = D.neg()), [{ a: E, b: A }, { a: I, b: D }];
  };
  yt.prototype._endoSplit = function(e) {
    var r = this.endo.basis, n = r[0], i = r[1], o = i.b.mul(e).divRound(this.n), p = n.b.neg().mul(e).divRound(this.n), y = o.mul(n.a), w = p.mul(i.a), x = o.mul(n.b), M = p.mul(i.b), E = e.sub(y).sub(w), A = x.add(M).neg();
    return { k1: E, k2: A };
  };
  yt.prototype.pointFromX = function(e, r) {
    e = new Oe(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var o = i.fromRed().isOdd();
    return (r && !o || !r && o) && (i = i.redNeg()), this.point(e, i);
  };
  yt.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var r = e.x, n = e.y, i = this.a.redMul(r), o = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(o).cmpn(0) === 0;
  };
  yt.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, o = this._endoWnafT2, p = 0; p < e.length; p++) {
      var y = this._endoSplit(r[p]), w = e[p], x = w._getBeta();
      y.k1.negative && (y.k1.ineg(), w = w.neg(true)), y.k2.negative && (y.k2.ineg(), x = x.neg(true)), i[p * 2] = w, i[p * 2 + 1] = x, o[p * 2] = y.k1, o[p * 2 + 1] = y.k2;
    }
    for (var M = this._wnafMulAdd(1, i, o, p * 2, n), E = 0; E < p * 2; E++)
      i[E] = null, o[E] = null;
    return M;
  };
  function We(t, e, r, n) {
    ji.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new Oe(e, 16), this.y = new Oe(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  j0(We, ji.BasePoint);
  yt.prototype.point = function(e, r, n) {
    return new We(this, e, r, n);
  };
  yt.prototype.pointFromJSON = function(e, r) {
    return We.fromJSON(this, e, r);
  };
  We.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var n = this.curve, i = function(o) {
          return n.point(o.x.redMul(n.endo.beta), o.y);
        };
        e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(i) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(i) } };
      }
      return r;
    }
  };
  We.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  };
  We.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2])
      return i;
    function o(y) {
      return e.point(y[0], y[1], n);
    }
    var p = r[2];
    return i.precomputed = { beta: null, doubles: p.doubles && { step: p.doubles.step, points: [i].concat(p.doubles.points.map(o)) }, naf: p.naf && { wnd: p.naf.wnd, points: [i].concat(p.naf.points.map(o)) } }, i;
  };
  We.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  We.prototype.isInfinity = function() {
    return this.inf;
  };
  We.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i);
  };
  We.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), o = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), p = o.redSqr().redISub(this.x.redAdd(this.x)), y = o.redMul(this.x.redSub(p)).redISub(this.y);
    return this.curve.point(p, y);
  };
  We.prototype.getX = function() {
    return this.x.fromRed();
  };
  We.prototype.getY = function() {
    return this.y.fromRed();
  };
  We.prototype.mul = function(e) {
    return e = new Oe(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
  };
  We.prototype.mulAdd = function(e, r, n) {
    var i = [this, r], o = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, o) : this.curve._wnafMulAdd(1, i, o, 2);
  };
  We.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r], o = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, o, true) : this.curve._wnafMulAdd(1, i, o, 2, true);
  };
  We.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  We.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var n = this.precomputed, i = function(o) {
        return o.neg();
      };
      r.precomputed = { naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(i) }, doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(i) } };
    }
    return r;
  };
  We.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function Xe(t, e, r, n) {
    ji.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Oe(0)) : (this.x = new Oe(e, 16), this.y = new Oe(r, 16), this.z = new Oe(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  j0(Xe, ji.BasePoint);
  yt.prototype.jpoint = function(e, r, n) {
    return new Xe(this, e, r, n);
  };
  Xe.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i);
  };
  Xe.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  Xe.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), o = e.x.redMul(n), p = this.y.redMul(r.redMul(e.z)), y = e.y.redMul(n.redMul(this.z)), w = i.redSub(o), x = p.redSub(y);
    if (w.cmpn(0) === 0)
      return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var M = w.redSqr(), E = M.redMul(w), A = i.redMul(M), I = x.redSqr().redIAdd(E).redISub(A).redISub(A), D = x.redMul(A.redISub(I)).redISub(p.redMul(E)), C = this.z.redMul(e.z).redMul(w);
    return this.curve.jpoint(I, D, C);
  };
  Xe.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), o = this.y, p = e.y.redMul(r).redMul(this.z), y = n.redSub(i), w = o.redSub(p);
    if (y.cmpn(0) === 0)
      return w.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var x = y.redSqr(), M = x.redMul(y), E = n.redMul(x), A = w.redSqr().redIAdd(M).redISub(E).redISub(E), I = w.redMul(E.redISub(A)).redISub(o.redMul(M)), D = this.z.redMul(y);
    return this.curve.jpoint(A, I, D);
  };
  Xe.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
      var n = this;
      for (r = 0; r < e; r++)
        n = n.dbl();
      return n;
    }
    var i = this.curve.a, o = this.curve.tinv, p = this.x, y = this.y, w = this.z, x = w.redSqr().redSqr(), M = y.redAdd(y);
    for (r = 0; r < e; r++) {
      var E = p.redSqr(), A = M.redSqr(), I = A.redSqr(), D = E.redAdd(E).redIAdd(E).redIAdd(i.redMul(x)), C = p.redMul(A), ge = D.redSqr().redISub(C.redAdd(C)), L = C.redISub(ge), ye = D.redMul(L);
      ye = ye.redIAdd(ye).redISub(I);
      var Re = M.redMul(w);
      r + 1 < e && (x = x.redMul(I)), p = ge, w = Re, M = ye;
    }
    return this.curve.jpoint(p, M.redMul(o), w);
  };
  Xe.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  Xe.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
      var i = this.x.redSqr(), o = this.y.redSqr(), p = o.redSqr(), y = this.x.redAdd(o).redSqr().redISub(i).redISub(p);
      y = y.redIAdd(y);
      var w = i.redAdd(i).redIAdd(i), x = w.redSqr().redISub(y).redISub(y), M = p.redIAdd(p);
      M = M.redIAdd(M), M = M.redIAdd(M), e = x, r = w.redMul(y.redISub(x)).redISub(M), n = this.y.redAdd(this.y);
    } else {
      var E = this.x.redSqr(), A = this.y.redSqr(), I = A.redSqr(), D = this.x.redAdd(A).redSqr().redISub(E).redISub(I);
      D = D.redIAdd(D);
      var C = E.redAdd(E).redIAdd(E), ge = C.redSqr(), L = I.redIAdd(I);
      L = L.redIAdd(L), L = L.redIAdd(L), e = ge.redISub(D).redISub(D), r = C.redMul(D.redISub(e)).redISub(L), n = this.y.redMul(this.z), n = n.redIAdd(n);
    }
    return this.curve.jpoint(e, r, n);
  };
  Xe.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
      var i = this.x.redSqr(), o = this.y.redSqr(), p = o.redSqr(), y = this.x.redAdd(o).redSqr().redISub(i).redISub(p);
      y = y.redIAdd(y);
      var w = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), x = w.redSqr().redISub(y).redISub(y);
      e = x;
      var M = p.redIAdd(p);
      M = M.redIAdd(M), M = M.redIAdd(M), r = w.redMul(y.redISub(x)).redISub(M), n = this.y.redAdd(this.y);
    } else {
      var E = this.z.redSqr(), A = this.y.redSqr(), I = this.x.redMul(A), D = this.x.redSub(E).redMul(this.x.redAdd(E));
      D = D.redAdd(D).redIAdd(D);
      var C = I.redIAdd(I);
      C = C.redIAdd(C);
      var ge = C.redAdd(C);
      e = D.redSqr().redISub(ge), n = this.y.redAdd(this.z).redSqr().redISub(A).redISub(E);
      var L = A.redSqr();
      L = L.redIAdd(L), L = L.redIAdd(L), L = L.redIAdd(L), r = D.redMul(C.redISub(e)).redISub(L);
    }
    return this.curve.jpoint(e, r, n);
  };
  Xe.prototype._dbl = function() {
    var e = this.curve.a, r = this.x, n = this.y, i = this.z, o = i.redSqr().redSqr(), p = r.redSqr(), y = n.redSqr(), w = p.redAdd(p).redIAdd(p).redIAdd(e.redMul(o)), x = r.redAdd(r);
    x = x.redIAdd(x);
    var M = x.redMul(y), E = w.redSqr().redISub(M.redAdd(M)), A = M.redISub(E), I = y.redSqr();
    I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);
    var D = w.redMul(A).redISub(I), C = n.redAdd(n).redMul(i);
    return this.curve.jpoint(E, D, C);
  };
  Xe.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), o = e.redAdd(e).redIAdd(e), p = o.redSqr(), y = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(p);
    var w = y.redSqr(), x = i.redIAdd(i);
    x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
    var M = o.redIAdd(y).redSqr().redISub(p).redISub(w).redISub(x), E = r.redMul(M);
    E = E.redIAdd(E), E = E.redIAdd(E);
    var A = this.x.redMul(w).redISub(E);
    A = A.redIAdd(A), A = A.redIAdd(A);
    var I = this.y.redMul(M.redMul(x.redISub(M)).redISub(y.redMul(w)));
    I = I.redIAdd(I), I = I.redIAdd(I), I = I.redIAdd(I);
    var D = this.z.redAdd(y).redSqr().redISub(n).redISub(w);
    return this.curve.jpoint(A, I, D);
  };
  Xe.prototype.mul = function(e, r) {
    return e = new Oe(e, r), this.curve._wnafMul(this, e);
  };
  Xe.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var r = this.z.redSqr(), n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
      return false;
    var i = r.redMul(this.z), o = n.redMul(e.z);
    return this.y.redMul(o).redISub(e.y.redMul(i)).cmpn(0) === 0;
  };
  Xe.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0)
      return true;
    for (var i = e.clone(), o = this.curve.redN.redMul(r); ; ) {
      if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
        return false;
      if (n.redIAdd(o), this.x.cmp(n) === 0)
        return true;
    }
  };
  Xe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  Xe.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var Ed = k2((gm, Sd) => {
  "use strict";
  var Wi = Fe(), Md = qe(), Vn = Lf(), m6 = ht2();
  function Vi(t) {
    Vn.call(this, "mont", t), this.a = new Wi(t.a, 16).toRed(this.red), this.b = new Wi(t.b, 16).toRed(this.red), this.i4 = new Wi(4).toRed(this.red).redInvm(), this.two = new Wi(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Md(Vi, Vn);
  Sd.exports = Vi;
  Vi.prototype.validate = function(e) {
    var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), o = i.redSqrt();
    return o.redSqr().cmp(i) === 0;
  };
  function Ve(t, e, r) {
    Vn.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Wi(e, 16), this.z = new Wi(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  Md(Ve, Vn.BasePoint);
  Vi.prototype.decodePoint = function(e, r) {
    return this.point(m6.toArray(e, r), 1);
  };
  Vi.prototype.point = function(e, r) {
    return new Ve(this, e, r);
  };
  Vi.prototype.pointFromJSON = function(e) {
    return Ve.fromJSON(this, e);
  };
  Ve.prototype.precompute = function() {
  };
  Ve.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Ve.fromJSON = function(e, r) {
    return new Ve(e, r[0], r[1] || e.one);
  };
  Ve.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Ve.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  Ve.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), o = r.redSub(i), p = r.redMul(i), y = o.redMul(i.redAdd(this.curve.a24.redMul(o)));
    return this.curve.point(p, y);
  };
  Ve.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve.prototype.diffAdd = function(e, r) {
    var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), o = e.x.redAdd(e.z), p = e.x.redSub(e.z), y = p.redMul(n), w = o.redMul(i), x = r.z.redMul(y.redAdd(w).redSqr()), M = r.x.redMul(y.redISub(w).redSqr());
    return this.curve.point(x, M);
  };
  Ve.prototype.mul = function(e) {
    for (var r = e.clone(), n = this, i = this.curve.point(null, null), o = this, p = []; r.cmpn(0) !== 0; r.iushrn(1))
      p.push(r.andln(1));
    for (var y = p.length - 1; y >= 0; y--)
      p[y] === 0 ? (n = n.diffAdd(i, o), i = i.dbl()) : (i = n.diffAdd(i, o), n = n.dbl());
    return i;
  };
  Ve.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  Ve.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  Ve.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var Bd = k2((ym, qd) => {
  "use strict";
  var g6 = ht2(), _r = Fe(), Ad = qe(), Zn = Lf(), y6 = g6.assert;
  function ir(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Zn.call(this, "edwards", t), this.a = new _r(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new _r(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new _r(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), y6(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
  }
  Ad(ir, Zn);
  qd.exports = ir;
  ir.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  ir.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  ir.prototype.jpoint = function(e, r, n, i) {
    return this.point(e, r, n, i);
  };
  ir.prototype.pointFromX = function(e, r) {
    e = new _r(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), o = this.one.redSub(this.c2.redMul(this.d).redMul(n)), p = i.redMul(o.redInvm()), y = p.redSqrt();
    if (y.redSqr().redSub(p).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var w = y.fromRed().isOdd();
    return (r && !w || !r && w) && (y = y.redNeg()), this.point(e, y);
  };
  ir.prototype.pointFromY = function(e, r) {
    e = new _r(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = n.redSub(this.c2), o = n.redMul(this.d).redMul(this.c2).redSub(this.a), p = i.redMul(o.redInvm());
    if (p.cmp(this.zero) === 0) {
      if (r)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var y = p.redSqrt();
    if (y.redSqr().redSub(p).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return y.fromRed().isOdd() !== r && (y = y.redNeg()), this.point(y, e);
  };
  ir.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), o = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
    return i.cmp(o) === 0;
  };
  function Te(t, e, r, n, i) {
    Zn.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new _r(e, 16), this.y = new _r(r, 16), this.z = n ? new _r(n, 16) : this.curve.one, this.t = i && new _r(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  Ad(Te, Zn.BasePoint);
  ir.prototype.pointFromJSON = function(e) {
    return Te.fromJSON(this, e);
  };
  ir.prototype.point = function(e, r, n, i) {
    return new Te(this, e, r, n, i);
  };
  Te.fromJSON = function(e, r) {
    return new Te(e, r[0], r[1], r[2]);
  };
  Te.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Te.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Te.prototype._extDbl = function() {
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
    n = n.redIAdd(n);
    var i = this.curve._mulA(e), o = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), p = i.redAdd(r), y = p.redSub(n), w = i.redSub(r), x = o.redMul(y), M = p.redMul(w), E = o.redMul(w), A = y.redMul(p);
    return this.curve.point(x, M, A, E);
  };
  Te.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, o, p, y, w, x;
    if (this.curve.twisted) {
      y = this.curve._mulA(r);
      var M = y.redAdd(n);
      this.zOne ? (i = e.redSub(r).redSub(n).redMul(M.redSub(this.curve.two)), o = M.redMul(y.redSub(n)), p = M.redSqr().redSub(M).redSub(M)) : (w = this.z.redSqr(), x = M.redSub(w).redISub(w), i = e.redSub(r).redISub(n).redMul(x), o = M.redMul(y.redSub(n)), p = M.redMul(x));
    } else
      y = r.redAdd(n), w = this.curve._mulC(this.z).redSqr(), x = y.redSub(w).redSub(w), i = this.curve._mulC(e.redISub(y)).redMul(x), o = this.curve._mulC(y).redMul(r.redISub(n)), p = y.redMul(x);
    return this.curve.point(i, o, p);
  };
  Te.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  Te.prototype._extAdd = function(e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), o = this.z.redMul(e.z.redAdd(e.z)), p = n.redSub(r), y = o.redSub(i), w = o.redAdd(i), x = n.redAdd(r), M = p.redMul(y), E = w.redMul(x), A = p.redMul(x), I = y.redMul(w);
    return this.curve.point(M, E, I, A);
  };
  Te.prototype._projAdd = function(e) {
    var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), o = this.y.redMul(e.y), p = this.curve.d.redMul(i).redMul(o), y = n.redSub(p), w = n.redAdd(p), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(o), M = r.redMul(y).redMul(x), E, A;
    return this.curve.twisted ? (E = r.redMul(w).redMul(o.redSub(this.curve._mulA(i))), A = y.redMul(w)) : (E = r.redMul(w).redMul(o.redSub(i)), A = this.curve._mulC(y).redMul(w)), this.curve.point(M, E, A);
  };
  Te.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  Te.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  Te.prototype.mulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, false);
  };
  Te.prototype.jmulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, true);
  };
  Te.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  Te.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Te.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  Te.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  Te.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  Te.prototype.eqXToP = function(e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0)
      return true;
    for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
      if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
        return false;
      if (r.redIAdd(i), this.x.cmp(r) === 0)
        return true;
    }
  };
  Te.prototype.toP = Te.prototype.normalize;
  Te.prototype.mixedAdd = Te.prototype.add;
});
var W0 = k2((Rd) => {
  "use strict";
  var Gn = Rd;
  Gn.base = Lf();
  Gn.short = xd();
  Gn.mont = Ed();
  Gn.edwards = Bd();
});
var Vt = k2((Pe) => {
  "use strict";
  var _6 = ot(), w6 = qe();
  Pe.inherits = w6;
  function x6(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function M6(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t == "string")
      if (e) {
        if (e === "hex")
          for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
            r.push(parseInt(t[i] + t[i + 1], 16));
      } else
        for (var n = 0, i = 0; i < t.length; i++) {
          var o = t.charCodeAt(i);
          o < 128 ? r[n++] = o : o < 2048 ? (r[n++] = o >> 6 | 192, r[n++] = o & 63 | 128) : x6(t, i) ? (o = 65536 + ((o & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = o >> 18 | 240, r[n++] = o >> 12 & 63 | 128, r[n++] = o >> 6 & 63 | 128, r[n++] = o & 63 | 128) : (r[n++] = o >> 12 | 224, r[n++] = o >> 6 & 63 | 128, r[n++] = o & 63 | 128);
        }
    else
      for (i = 0; i < t.length; i++)
        r[i] = t[i] | 0;
    return r;
  }
  Pe.toArray = M6;
  function S6(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += kd(t[r].toString(16));
    return e;
  }
  Pe.toHex = S6;
  function Id(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  Pe.htonl = Id;
  function E6(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
      var i = t[n];
      e === "little" && (i = Id(i)), r += Dd(i.toString(16));
    }
    return r;
  }
  Pe.toHex32 = E6;
  function kd(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Pe.zero2 = kd;
  function Dd(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  Pe.zero8 = Dd;
  function A6(t, e, r, n) {
    var i = r - e;
    _6(i % 4 === 0);
    for (var o = new Array(i / 4), p = 0, y = e; p < o.length; p++, y += 4) {
      var w;
      n === "big" ? w = t[y] << 24 | t[y + 1] << 16 | t[y + 2] << 8 | t[y + 3] : w = t[y + 3] << 24 | t[y + 2] << 16 | t[y + 1] << 8 | t[y], o[p] = w >>> 0;
    }
    return o;
  }
  Pe.join32 = A6;
  function q6(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
      var o = t[n];
      e === "big" ? (r[i] = o >>> 24, r[i + 1] = o >>> 16 & 255, r[i + 2] = o >>> 8 & 255, r[i + 3] = o & 255) : (r[i + 3] = o >>> 24, r[i + 2] = o >>> 16 & 255, r[i + 1] = o >>> 8 & 255, r[i] = o & 255);
    }
    return r;
  }
  Pe.split32 = q6;
  function B6(t, e) {
    return t >>> e | t << 32 - e;
  }
  Pe.rotr32 = B6;
  function R6(t, e) {
    return t << e | t >>> 32 - e;
  }
  Pe.rotl32 = R6;
  function I6(t, e) {
    return t + e >>> 0;
  }
  Pe.sum32 = I6;
  function k6(t, e, r) {
    return t + e + r >>> 0;
  }
  Pe.sum32_3 = k6;
  function D6(t, e, r, n) {
    return t + e + r + n >>> 0;
  }
  Pe.sum32_4 = D6;
  function P6(t, e, r, n, i) {
    return t + e + r + n + i >>> 0;
  }
  Pe.sum32_5 = P6;
  function T6(t, e, r, n) {
    var i = t[e], o = t[e + 1], p = n + o >>> 0, y = (p < n ? 1 : 0) + r + i;
    t[e] = y >>> 0, t[e + 1] = p;
  }
  Pe.sum64 = T6;
  function C6(t, e, r, n) {
    var i = e + n >>> 0, o = (i < e ? 1 : 0) + t + r;
    return o >>> 0;
  }
  Pe.sum64_hi = C6;
  function N6(t, e, r, n) {
    var i = e + n;
    return i >>> 0;
  }
  Pe.sum64_lo = N6;
  function L6(t, e, r, n, i, o, p, y) {
    var w = 0, x = e;
    x = x + n >>> 0, w += x < e ? 1 : 0, x = x + o >>> 0, w += x < o ? 1 : 0, x = x + y >>> 0, w += x < y ? 1 : 0;
    var M = t + r + i + p + w;
    return M >>> 0;
  }
  Pe.sum64_4_hi = L6;
  function O6(t, e, r, n, i, o, p, y) {
    var w = e + n + o + y;
    return w >>> 0;
  }
  Pe.sum64_4_lo = O6;
  function z6(t, e, r, n, i, o, p, y, w, x) {
    var M = 0, E = e;
    E = E + n >>> 0, M += E < e ? 1 : 0, E = E + o >>> 0, M += E < o ? 1 : 0, E = E + y >>> 0, M += E < y ? 1 : 0, E = E + x >>> 0, M += E < x ? 1 : 0;
    var A = t + r + i + p + w + M;
    return A >>> 0;
  }
  Pe.sum64_5_hi = z6;
  function U6(t, e, r, n, i, o, p, y, w, x) {
    var M = e + n + o + y + x;
    return M >>> 0;
  }
  Pe.sum64_5_lo = U6;
  function H6(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0;
  }
  Pe.rotr64_hi = H6;
  function F6(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0;
  }
  Pe.rotr64_lo = F6;
  function K6(t, e, r) {
    return t >>> r;
  }
  Pe.shr64_hi = K6;
  function j6(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0;
  }
  Pe.shr64_lo = j6;
});
var Zi = k2((Td) => {
  "use strict";
  var Pd = Vt(), W6 = ot();
  function Xn() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  Td.BlockHash = Xn;
  Xn.prototype.update = function(e, r) {
    if (e = Pd.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var n = e.length % this._delta8;
      this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Pd.join32(e, 0, e.length - n, this.endian);
      for (var i = 0; i < e.length; i += this._delta32)
        this._update(e, i, i + this._delta32);
    }
    return this;
  };
  Xn.prototype.digest = function(e) {
    return this.update(this._pad()), W6(this.pending === null), this._digest(e);
  };
  Xn.prototype._pad = function() {
    var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
    i[0] = 128;
    for (var o = 1; o < n; o++)
      i[o] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var p = 8; p < this.padLength; p++)
        i[o++] = 0;
      i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = e >>> 24 & 255, i[o++] = e >>> 16 & 255, i[o++] = e >>> 8 & 255, i[o++] = e & 255;
    } else
      for (i[o++] = e & 255, i[o++] = e >>> 8 & 255, i[o++] = e >>> 16 & 255, i[o++] = e >>> 24 & 255, i[o++] = 0, i[o++] = 0, i[o++] = 0, i[o++] = 0, p = 8; p < this.padLength; p++)
        i[o++] = 0;
    return i;
  };
});
var V0 = k2((wr2) => {
  "use strict";
  var V6 = Vt(), fr = V6.rotr32;
  function Z6(t, e, r, n) {
    if (t === 0)
      return Cd(e, r, n);
    if (t === 1 || t === 3)
      return Ld(e, r, n);
    if (t === 2)
      return Nd(e, r, n);
  }
  wr2.ft_1 = Z6;
  function Cd(t, e, r) {
    return t & e ^ ~t & r;
  }
  wr2.ch32 = Cd;
  function Nd(t, e, r) {
    return t & e ^ t & r ^ e & r;
  }
  wr2.maj32 = Nd;
  function Ld(t, e, r) {
    return t ^ e ^ r;
  }
  wr2.p32 = Ld;
  function G6(t) {
    return fr(t, 2) ^ fr(t, 13) ^ fr(t, 22);
  }
  wr2.s0_256 = G6;
  function X6(t) {
    return fr(t, 6) ^ fr(t, 11) ^ fr(t, 25);
  }
  wr2.s1_256 = X6;
  function Y6(t) {
    return fr(t, 7) ^ fr(t, 18) ^ t >>> 3;
  }
  wr2.g0_256 = Y6;
  function J6(t) {
    return fr(t, 17) ^ fr(t, 19) ^ t >>> 10;
  }
  wr2.g1_256 = J6;
});
var Ud = k2((Sm, zd) => {
  "use strict";
  var Gi = Vt(), $6 = Zi(), Q6 = V0(), Z0 = Gi.rotl32, Of = Gi.sum32, e3 = Gi.sum32_5, t3 = Q6.ft_1, Od = $6.BlockHash, r3 = [1518500249, 1859775393, 2400959708, 3395469782];
  function nr() {
    if (!(this instanceof nr))
      return new nr();
    Od.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  Gi.inherits(nr, Od);
  zd.exports = nr;
  nr.blockSize = 512;
  nr.outSize = 160;
  nr.hmacStrength = 80;
  nr.padLength = 64;
  nr.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++)
      n[i] = e[r + i];
    for (; i < n.length; i++)
      n[i] = Z0(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var o = this.h[0], p = this.h[1], y = this.h[2], w = this.h[3], x = this.h[4];
    for (i = 0; i < n.length; i++) {
      var M = ~~(i / 20), E = e3(Z0(o, 5), t3(M, p, y, w), x, n[i], r3[M]);
      x = w, w = y, y = Z0(p, 30), p = o, o = E;
    }
    this.h[0] = Of(this.h[0], o), this.h[1] = Of(this.h[1], p), this.h[2] = Of(this.h[2], y), this.h[3] = Of(this.h[3], w), this.h[4] = Of(this.h[4], x);
  };
  nr.prototype._digest = function(e) {
    return e === "hex" ? Gi.toHex32(this.h, "big") : Gi.split32(this.h, "big");
  };
});
var G0 = k2((Em, Fd) => {
  "use strict";
  var Xi = Vt(), i3 = Zi(), Yi = V0(), f3 = ot(), Zt = Xi.sum32, n3 = Xi.sum32_4, a3 = Xi.sum32_5, s3 = Yi.ch32, o3 = Yi.maj32, h3 = Yi.s0_256, u3 = Yi.s1_256, d3 = Yi.g0_256, c3 = Yi.g1_256, Hd = i3.BlockHash, l3 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function ar() {
    if (!(this instanceof ar))
      return new ar();
    Hd.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = l3, this.W = new Array(64);
  }
  Xi.inherits(ar, Hd);
  Fd.exports = ar;
  ar.blockSize = 512;
  ar.outSize = 256;
  ar.hmacStrength = 192;
  ar.padLength = 64;
  ar.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++)
      n[i] = e[r + i];
    for (; i < n.length; i++)
      n[i] = n3(c3(n[i - 2]), n[i - 7], d3(n[i - 15]), n[i - 16]);
    var o = this.h[0], p = this.h[1], y = this.h[2], w = this.h[3], x = this.h[4], M = this.h[5], E = this.h[6], A = this.h[7];
    for (f3(this.k.length === n.length), i = 0; i < n.length; i++) {
      var I = a3(A, u3(x), s3(x, M, E), this.k[i], n[i]), D = Zt(h3(o), o3(o, p, y));
      A = E, E = M, M = x, x = Zt(w, I), w = y, y = p, p = o, o = Zt(I, D);
    }
    this.h[0] = Zt(this.h[0], o), this.h[1] = Zt(this.h[1], p), this.h[2] = Zt(this.h[2], y), this.h[3] = Zt(this.h[3], w), this.h[4] = Zt(this.h[4], x), this.h[5] = Zt(this.h[5], M), this.h[6] = Zt(this.h[6], E), this.h[7] = Zt(this.h[7], A);
  };
  ar.prototype._digest = function(e) {
    return e === "hex" ? Xi.toHex32(this.h, "big") : Xi.split32(this.h, "big");
  };
});
var Wd = k2((Am, jd) => {
  "use strict";
  var X0 = Vt(), Kd = G0();
  function xr2() {
    if (!(this instanceof xr2))
      return new xr2();
    Kd.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  X0.inherits(xr2, Kd);
  jd.exports = xr2;
  xr2.blockSize = 512;
  xr2.outSize = 224;
  xr2.hmacStrength = 192;
  xr2.padLength = 64;
  xr2.prototype._digest = function(e) {
    return e === "hex" ? X0.toHex32(this.h.slice(0, 7), "big") : X0.split32(this.h.slice(0, 7), "big");
  };
});
var $0 = k2((qm, Xd) => {
  "use strict";
  var nt = Vt(), v3 = Zi(), p3 = ot(), sr = nt.rotr64_hi, or2 = nt.rotr64_lo, Vd = nt.shr64_hi, Zd = nt.shr64_lo, Yr = nt.sum64, Y0 = nt.sum64_hi, J0 = nt.sum64_lo, b3 = nt.sum64_4_hi, m3 = nt.sum64_4_lo, g3 = nt.sum64_5_hi, y3 = nt.sum64_5_lo, Gd = v3.BlockHash, _3 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function Gt() {
    if (!(this instanceof Gt))
      return new Gt();
    Gd.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = _3, this.W = new Array(160);
  }
  nt.inherits(Gt, Gd);
  Xd.exports = Gt;
  Gt.blockSize = 1024;
  Gt.outSize = 512;
  Gt.hmacStrength = 192;
  Gt.padLength = 128;
  Gt.prototype._prepareBlock = function(e, r) {
    for (var n = this.W, i = 0; i < 32; i++)
      n[i] = e[r + i];
    for (; i < n.length; i += 2) {
      var o = k3(n[i - 4], n[i - 3]), p = D3(n[i - 4], n[i - 3]), y = n[i - 14], w = n[i - 13], x = R3(n[i - 30], n[i - 29]), M = I3(n[i - 30], n[i - 29]), E = n[i - 32], A = n[i - 31];
      n[i] = b3(o, p, y, w, x, M, E, A), n[i + 1] = m3(o, p, y, w, x, M, E, A);
    }
  };
  Gt.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var n = this.W, i = this.h[0], o = this.h[1], p = this.h[2], y = this.h[3], w = this.h[4], x = this.h[5], M = this.h[6], E = this.h[7], A = this.h[8], I = this.h[9], D = this.h[10], C = this.h[11], ge = this.h[12], L = this.h[13], ye = this.h[14], Re = this.h[15];
    p3(this.k.length === n.length);
    for (var xe = 0; xe < n.length; xe += 2) {
      var ke = ye, Me = Re, Ce = q3(A, I), Ee = B3(A, I), Ne = w3(A, I, D, C, ge, L), S = x3(A, I, D, C, ge, L), v = this.k[xe], _ = this.k[xe + 1], c = n[xe], f = n[xe + 1], a = g3(ke, Me, Ce, Ee, Ne, S, v, _, c, f), u = y3(ke, Me, Ce, Ee, Ne, S, v, _, c, f);
      ke = E3(i, o), Me = A3(i, o), Ce = M3(i, o, p, y, w, x), Ee = S3(i, o, p, y, w, x);
      var l = Y0(ke, Me, Ce, Ee), d = J0(ke, Me, Ce, Ee);
      ye = ge, Re = L, ge = D, L = C, D = A, C = I, A = Y0(M, E, a, u), I = J0(E, E, a, u), M = w, E = x, w = p, x = y, p = i, y = o, i = Y0(a, u, l, d), o = J0(a, u, l, d);
    }
    Yr(this.h, 0, i, o), Yr(this.h, 2, p, y), Yr(this.h, 4, w, x), Yr(this.h, 6, M, E), Yr(this.h, 8, A, I), Yr(this.h, 10, D, C), Yr(this.h, 12, ge, L), Yr(this.h, 14, ye, Re);
  };
  Gt.prototype._digest = function(e) {
    return e === "hex" ? nt.toHex32(this.h, "big") : nt.split32(this.h, "big");
  };
  function w3(t, e, r, n, i) {
    var o = t & r ^ ~t & i;
    return o < 0 && (o += 4294967296), o;
  }
  function x3(t, e, r, n, i, o) {
    var p = e & n ^ ~e & o;
    return p < 0 && (p += 4294967296), p;
  }
  function M3(t, e, r, n, i) {
    var o = t & r ^ t & i ^ r & i;
    return o < 0 && (o += 4294967296), o;
  }
  function S3(t, e, r, n, i, o) {
    var p = e & n ^ e & o ^ n & o;
    return p < 0 && (p += 4294967296), p;
  }
  function E3(t, e) {
    var r = sr(t, e, 28), n = sr(e, t, 2), i = sr(e, t, 7), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function A3(t, e) {
    var r = or2(t, e, 28), n = or2(e, t, 2), i = or2(e, t, 7), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function q3(t, e) {
    var r = sr(t, e, 14), n = sr(t, e, 18), i = sr(e, t, 9), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function B3(t, e) {
    var r = or2(t, e, 14), n = or2(t, e, 18), i = or2(e, t, 9), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function R3(t, e) {
    var r = sr(t, e, 1), n = sr(t, e, 8), i = Vd(t, e, 7), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function I3(t, e) {
    var r = or2(t, e, 1), n = or2(t, e, 8), i = Zd(t, e, 7), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function k3(t, e) {
    var r = sr(t, e, 19), n = sr(e, t, 29), i = Vd(t, e, 6), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
  function D3(t, e) {
    var r = or2(t, e, 19), n = or2(e, t, 29), i = Zd(t, e, 6), o = r ^ n ^ i;
    return o < 0 && (o += 4294967296), o;
  }
});
var $d = k2((Bm, Jd) => {
  "use strict";
  var Q0 = Vt(), Yd = $0();
  function Mr() {
    if (!(this instanceof Mr))
      return new Mr();
    Yd.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  Q0.inherits(Mr, Yd);
  Jd.exports = Mr;
  Mr.blockSize = 1024;
  Mr.outSize = 384;
  Mr.hmacStrength = 192;
  Mr.padLength = 128;
  Mr.prototype._digest = function(e) {
    return e === "hex" ? Q0.toHex32(this.h.slice(0, 12), "big") : Q0.split32(this.h.slice(0, 12), "big");
  };
});
var Qd = k2((Ji) => {
  "use strict";
  Ji.sha1 = Ud();
  Ji.sha224 = Wd();
  Ji.sha256 = G0();
  Ji.sha384 = $d();
  Ji.sha512 = $0();
});
var nc = k2((fc) => {
  "use strict";
  var xi = Vt(), P3 = Zi(), Yn = xi.rotl32, ec = xi.sum32, zf = xi.sum32_3, tc = xi.sum32_4, ic = P3.BlockHash;
  function hr() {
    if (!(this instanceof hr))
      return new hr();
    ic.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  xi.inherits(hr, ic);
  fc.ripemd160 = hr;
  hr.blockSize = 512;
  hr.outSize = 160;
  hr.hmacStrength = 192;
  hr.padLength = 64;
  hr.prototype._update = function(e, r) {
    for (var n = this.h[0], i = this.h[1], o = this.h[2], p = this.h[3], y = this.h[4], w = n, x = i, M = o, E = p, A = y, I = 0; I < 80; I++) {
      var D = ec(Yn(tc(n, rc(I, i, o, p), e[N3[I] + r], T3(I)), O3[I]), y);
      n = y, y = p, p = Yn(o, 10), o = i, i = D, D = ec(Yn(tc(w, rc(79 - I, x, M, E), e[L3[I] + r], C3(I)), z3[I]), A), w = A, A = E, E = Yn(M, 10), M = x, x = D;
    }
    D = zf(this.h[1], o, E), this.h[1] = zf(this.h[2], p, A), this.h[2] = zf(this.h[3], y, w), this.h[3] = zf(this.h[4], n, x), this.h[4] = zf(this.h[0], i, M), this.h[0] = D;
  };
  hr.prototype._digest = function(e) {
    return e === "hex" ? xi.toHex32(this.h, "little") : xi.split32(this.h, "little");
  };
  function rc(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
  }
  function T3(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function C3(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var N3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], L3 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], O3 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], z3 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
});
var sc = k2((km, ac) => {
  "use strict";
  var U3 = Vt(), H3 = ot();
  function $i(t, e, r) {
    if (!(this instanceof $i))
      return new $i(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(U3.toArray(e, r));
  }
  ac.exports = $i;
  $i.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), H3(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++)
      e.push(0);
    for (r = 0; r < e.length; r++)
      e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
      e[r] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  $i.prototype.update = function(e, r) {
    return this.inner.update(e, r), this;
  };
  $i.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var Jn = k2((oc) => {
  var Ye = oc;
  Ye.utils = Vt();
  Ye.common = Zi();
  Ye.sha = Qd();
  Ye.ripemd = nc();
  Ye.hmac = sc();
  Ye.sha1 = Ye.sha.sha1;
  Ye.sha256 = Ye.sha.sha256;
  Ye.sha224 = Ye.sha.sha224;
  Ye.sha384 = Ye.sha.sha384;
  Ye.sha512 = Ye.sha.sha512;
  Ye.ripemd160 = Ye.ripemd.ripemd160;
});
var uc = k2((Pm, hc) => {
  hc.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
});
var $n = k2((lc) => {
  "use strict";
  var ts = lc, Jr = Jn(), es = W0(), F3 = ht2(), dc = F3.assert;
  function cc(t) {
    t.type === "short" ? this.curve = new es.short(t) : t.type === "edwards" ? this.curve = new es.edwards(t) : this.curve = new es.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, dc(this.g.validate(), "Invalid curve"), dc(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  ts.PresetCurve = cc;
  function $r(t, e) {
    Object.defineProperty(ts, t, { configurable: true, enumerable: true, get: function() {
      var r = new cc(e);
      return Object.defineProperty(ts, t, { configurable: true, enumerable: true, value: r }), r;
    } });
  }
  $r("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Jr.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
  $r("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Jr.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
  $r("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Jr.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
  $r("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Jr.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
  $r("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Jr.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
  $r("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Jr.sha256, gRed: false, g: ["9"] });
  $r("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Jr.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var rs;
  try {
    rs = uc();
  } catch {
    rs = void 0;
  }
  $r("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Jr.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", rs] });
});
var bc = k2((Cm, pc) => {
  "use strict";
  var K3 = Jn(), Mi = K0(), vc = ot();
  function Qr(t) {
    if (!(this instanceof Qr))
      return new Qr(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Mi.toArray(t.entropy, t.entropyEnc || "hex"), r = Mi.toArray(t.nonce, t.nonceEnc || "hex"), n = Mi.toArray(t.pers, t.persEnc || "hex");
    vc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n);
  }
  pc.exports = Qr;
  Qr.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var o = 0; o < this.V.length; o++)
      this.K[o] = 0, this.V[o] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  Qr.prototype._hmac = function() {
    return new K3.hmac(this.hash, this.K);
  };
  Qr.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  Qr.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = Mi.toArray(e, r), n = Mi.toArray(n, i), vc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1;
  };
  Qr.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = Mi.toArray(n, i || "hex"), this._update(n));
    for (var o = []; o.length < e; )
      this.V = this._hmac().update(this.V).digest(), o = o.concat(this.V);
    var p = o.slice(0, e);
    return this._update(n), this._reseed++, Mi.encode(p, r);
  };
});
var gc = k2((Nm, mc) => {
  "use strict";
  var j3 = Fe(), W3 = ht2(), is = W3.assert;
  function tt(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  mc.exports = tt;
  tt.fromPublic = function(e, r, n) {
    return r instanceof tt ? r : new tt(e, { pub: r, pubEnc: n });
  };
  tt.fromPrivate = function(e, r, n) {
    return r instanceof tt ? r : new tt(e, { priv: r, privEnc: n });
  };
  tt.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
  };
  tt.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
  };
  tt.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  tt.prototype._importPrivate = function(e, r) {
    this.priv = new j3(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  tt.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? is(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && is(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, r);
  };
  tt.prototype.derive = function(e) {
    return e.validate() || is(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  tt.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n);
  };
  tt.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this);
  };
  tt.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var wc = k2((Lm, _c) => {
  "use strict";
  var Qn = Fe(), as = ht2(), V3 = as.assert;
  function ea(t, e) {
    if (t instanceof ea)
      return t;
    this._importDER(t, e) || (V3(t.r && t.s, "Signature without r or s"), this.r = new Qn(t.r, 16), this.s = new Qn(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  _c.exports = ea;
  function Z3() {
    this.place = 0;
  }
  function fs2(t, e) {
    var r = t[e.place++];
    if (!(r & 128))
      return r;
    var n = r & 15;
    if (n === 0 || n > 4)
      return false;
    for (var i = 0, o = 0, p = e.place; o < n; o++, p++)
      i <<= 8, i |= t[p], i >>>= 0;
    return i <= 127 ? false : (e.place = p, i);
  }
  function yc(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
      e++;
    return e === 0 ? t : t.slice(e);
  }
  ea.prototype._importDER = function(e, r) {
    e = as.toArray(e, r);
    var n = new Z3();
    if (e[n.place++] !== 48)
      return false;
    var i = fs2(e, n);
    if (i === false || i + n.place !== e.length || e[n.place++] !== 2)
      return false;
    var o = fs2(e, n);
    if (o === false)
      return false;
    var p = e.slice(n.place, o + n.place);
    if (n.place += o, e[n.place++] !== 2)
      return false;
    var y = fs2(e, n);
    if (y === false || e.length !== y + n.place)
      return false;
    var w = e.slice(n.place, y + n.place);
    if (p[0] === 0)
      if (p[1] & 128)
        p = p.slice(1);
      else
        return false;
    if (w[0] === 0)
      if (w[1] & 128)
        w = w.slice(1);
      else
        return false;
    return this.r = new Qn(p), this.s = new Qn(w), this.recoveryParam = null, true;
  };
  function ns(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r; )
      t.push(e >>> (r << 3) & 255);
    t.push(e);
  }
  ea.prototype.toDER = function(e) {
    var r = this.r.toArray(), n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = yc(r), n = yc(n); !n[0] && !(n[1] & 128); )
      n = n.slice(1);
    var i = [2];
    ns(i, r.length), i = i.concat(r), i.push(2), ns(i, n.length);
    var o = i.concat(n), p = [48];
    return ns(p, o.length), p = p.concat(o), as.encode(p, e);
  };
});
var Ec = k2((Om, Sc) => {
  "use strict";
  var Si = Fe(), xc = bc(), G3 = ht2(), ss = $n(), X3 = On(), Mc = G3.assert, os3 = gc(), ta = wc();
  function _t(t) {
    if (!(this instanceof _t))
      return new _t(t);
    typeof t == "string" && (Mc(Object.prototype.hasOwnProperty.call(ss, t), "Unknown curve " + t), t = ss[t]), t instanceof ss.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  Sc.exports = _t;
  _t.prototype.keyPair = function(e) {
    return new os3(this, e);
  };
  _t.prototype.keyFromPrivate = function(e, r) {
    return os3.fromPrivate(this, e, r);
  };
  _t.prototype.keyFromPublic = function(e, r) {
    return os3.fromPublic(this, e, r);
  };
  _t.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new xc({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || X3(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), n = this.n.byteLength(), i = this.n.sub(new Si(2)); ; ) {
      var o = new Si(r.generate(n));
      if (!(o.cmp(i) > 0))
        return o.iaddn(1), this.keyFromPrivate(o);
    }
  };
  _t.prototype._truncateToN = function(e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength();
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  _t.prototype.sign = function(e, r, n, i) {
    typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new Si(e, 16));
    for (var o = this.n.byteLength(), p = r.getPrivate().toArray("be", o), y = e.toArray("be", o), w = new xc({ hash: this.hash, entropy: p, nonce: y, pers: i.pers, persEnc: i.persEnc || "utf8" }), x = this.n.sub(new Si(1)), M = 0; ; M++) {
      var E = i.k ? i.k(M) : new Si(w.generate(this.n.byteLength()));
      if (E = this._truncateToN(E, true), !(E.cmpn(1) <= 0 || E.cmp(x) >= 0)) {
        var A = this.g.mul(E);
        if (!A.isInfinity()) {
          var I = A.getX(), D = I.umod(this.n);
          if (D.cmpn(0) !== 0) {
            var C = E.invm(this.n).mul(D.mul(r.getPrivate()).iadd(e));
            if (C = C.umod(this.n), C.cmpn(0) !== 0) {
              var ge = (A.getY().isOdd() ? 1 : 0) | (I.cmp(D) !== 0 ? 2 : 0);
              return i.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), ge ^= 1), new ta({ r: D, s: C, recoveryParam: ge });
            }
          }
        }
      }
    }
  };
  _t.prototype.verify = function(e, r, n, i) {
    e = this._truncateToN(new Si(e, 16)), n = this.keyFromPublic(n, i), r = new ta(r, "hex");
    var o = r.r, p = r.s;
    if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || p.cmpn(1) < 0 || p.cmp(this.n) >= 0)
      return false;
    var y = p.invm(this.n), w = y.mul(e).umod(this.n), x = y.mul(o).umod(this.n), M;
    return this.curve._maxwellTrick ? (M = this.g.jmulAdd(w, n.getPublic(), x), M.isInfinity() ? false : M.eqXToP(o)) : (M = this.g.mulAdd(w, n.getPublic(), x), M.isInfinity() ? false : M.getX().umod(this.n).cmp(o) === 0);
  };
  _t.prototype.recoverPubKey = function(t, e, r, n) {
    Mc((3 & r) === r, "The recovery param is more than two bits"), e = new ta(e, n);
    var i = this.n, o = new Si(t), p = e.r, y = e.s, w = r & 1, x = r >> 1;
    if (p.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
      throw new Error("Unable to find sencond key candinate");
    x ? p = this.curve.pointFromX(p.add(this.curve.n), w) : p = this.curve.pointFromX(p, w);
    var M = e.r.invm(i), E = i.sub(o).mul(M).umod(i), A = y.mul(M).umod(i);
    return this.g.mulAdd(E, p, A);
  };
  _t.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new ta(e, n), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var o;
      try {
        o = this.recoverPubKey(t, e, i);
      } catch {
        continue;
      }
      if (o.eq(r))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var Rc = k2((zm, Bc) => {
  "use strict";
  var Uf = ht2(), qc = Uf.assert, Ac = Uf.parseBytes, Qi = Uf.cachedProperty;
  function Ze(t, e) {
    this.eddsa = t, this._secret = Ac(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Ac(e.pub);
  }
  Ze.fromPublic = function(e, r) {
    return r instanceof Ze ? r : new Ze(e, { pub: r });
  };
  Ze.fromSecret = function(e, r) {
    return r instanceof Ze ? r : new Ze(e, { secret: r });
  };
  Ze.prototype.secret = function() {
    return this._secret;
  };
  Qi(Ze, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  Qi(Ze, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  Qi(Ze, "privBytes", function() {
    var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
    return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
  });
  Qi(Ze, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  Qi(Ze, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  Qi(Ze, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  Ze.prototype.sign = function(e) {
    return qc(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  Ze.prototype.verify = function(e, r) {
    return this.eddsa.verify(e, r, this);
  };
  Ze.prototype.getSecret = function(e) {
    return qc(this._secret, "KeyPair is public only"), Uf.encode(this.secret(), e);
  };
  Ze.prototype.getPublic = function(e) {
    return Uf.encode(this.pubBytes(), e);
  };
  Bc.exports = Ze;
});
var kc = k2((Um, Ic) => {
  "use strict";
  var Y3 = Fe(), ra = ht2(), J3 = ra.assert, ia = ra.cachedProperty, $3 = ra.parseBytes;
  function Ei(t, e) {
    this.eddsa = t, typeof e != "object" && (e = $3(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), J3(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof Y3 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  ia(Ei, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  ia(Ei, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  ia(Ei, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  ia(Ei, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  Ei.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Ei.prototype.toHex = function() {
    return ra.encode(this.toBytes(), "hex").toUpperCase();
  };
  Ic.exports = Ei;
});
var Nc = k2((Hm, Cc) => {
  "use strict";
  var Q3 = Jn(), e4 = $n(), ef = ht2(), t4 = ef.assert, Pc = ef.parseBytes, Tc = Rc(), Dc = kc();
  function at(t) {
    if (t4(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof at))
      return new at(t);
    t = e4[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = Q3.sha512;
  }
  Cc.exports = at;
  at.prototype.sign = function(e, r) {
    e = Pc(e);
    var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), o = this.g.mul(i), p = this.encodePoint(o), y = this.hashInt(p, n.pubBytes(), e).mul(n.priv()), w = i.add(y).umod(this.curve.n);
    return this.makeSignature({ R: o, S: w, Rencoded: p });
  };
  at.prototype.verify = function(e, r, n) {
    e = Pc(e), r = this.makeSignature(r);
    var i = this.keyFromPublic(n), o = this.hashInt(r.Rencoded(), i.pubBytes(), e), p = this.g.mul(r.S()), y = r.R().add(i.pub().mul(o));
    return y.eq(p);
  };
  at.prototype.hashInt = function() {
    for (var e = this.hash(), r = 0; r < arguments.length; r++)
      e.update(arguments[r]);
    return ef.intFromLE(e.digest()).umod(this.curve.n);
  };
  at.prototype.keyFromPublic = function(e) {
    return Tc.fromPublic(this, e);
  };
  at.prototype.keyFromSecret = function(e) {
    return Tc.fromSecret(this, e);
  };
  at.prototype.makeSignature = function(e) {
    return e instanceof Dc ? e : new Dc(this, e);
  };
  at.prototype.encodePoint = function(e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
  };
  at.prototype.decodePoint = function(e) {
    e = ef.parseBytes(e);
    var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, o = ef.intFromLE(n);
    return this.curve.pointFromY(o, i);
  };
  at.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  at.prototype.decodeInt = function(e) {
    return ef.intFromLE(e);
  };
  at.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var fa = k2((Lc) => {
  "use strict";
  var Ai = Lc;
  Ai.version = pd().version;
  Ai.utils = ht2();
  Ai.rand = On();
  Ai.curve = W0();
  Ai.curves = $n();
  Ai.ec = Ec();
  Ai.eddsa = Nc();
});
var us = k2((Oc, hs) => {
  (function(t, e) {
    "use strict";
    function r(c, f) {
      if (!c)
        throw new Error(f || "Assertion failed");
    }
    function n(c, f) {
      c.super_ = f;
      var a = function() {
      };
      a.prototype = f.prototype, c.prototype = new a(), c.prototype.constructor = c;
    }
    function i(c, f, a) {
      if (i.isBN(c))
        return c;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c !== null && ((f === "le" || f === "be") && (a = f, f = 10), this._init(c || 0, f || 10, a || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = export_default.Buffer;
    } catch {
    }
    i.isBN = function(f) {
      return f instanceof i ? true : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
    }, i.max = function(f, a) {
      return f.cmp(a) > 0 ? f : a;
    }, i.min = function(f, a) {
      return f.cmp(a) < 0 ? f : a;
    }, i.prototype._init = function(f, a, u) {
      if (typeof f == "number")
        return this._initNumber(f, a, u);
      if (typeof f == "object")
        return this._initArray(f, a, u);
      a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), f = f.toString().replace(/\s+/g, "");
      var l = 0;
      f[0] === "-" && (l++, this.negative = 1), l < f.length && (a === 16 ? this._parseHex(f, l, u) : (this._parseBase(f, a, l), u === "le" && this._initArray(this.toArray(), a, u)));
    }, i.prototype._initNumber = function(f, a, u) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), u === "le" && this._initArray(this.toArray(), a, u);
    }, i.prototype._initArray = function(f, a, u) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d, h, b = 0;
      if (u === "be")
        for (l = f.length - 1, d = 0; l >= 0; l -= 3)
          h = f[l] | f[l - 1] << 8 | f[l - 2] << 16, this.words[d] |= h << b & 67108863, this.words[d + 1] = h >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, d++);
      else if (u === "le")
        for (l = 0, d = 0; l < f.length; l += 3)
          h = f[l] | f[l + 1] << 8 | f[l + 2] << 16, this.words[d] |= h << b & 67108863, this.words[d + 1] = h >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, d++);
      return this._strip();
    };
    function p(c, f) {
      var a = c.charCodeAt(f);
      if (a >= 48 && a <= 57)
        return a - 48;
      if (a >= 65 && a <= 70)
        return a - 55;
      if (a >= 97 && a <= 102)
        return a - 87;
      r(false, "Invalid character in " + c);
    }
    function y(c, f, a) {
      var u = p(c, a);
      return a - 1 >= f && (u |= p(c, a - 1) << 4), u;
    }
    i.prototype._parseHex = function(f, a, u) {
      this.length = Math.ceil((f.length - a) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d = 0, h = 0, b;
      if (u === "be")
        for (l = f.length - 1; l >= a; l -= 2)
          b = y(f, a, l) << d, this.words[h] |= b & 67108863, d >= 18 ? (d -= 18, h += 1, this.words[h] |= b >>> 26) : d += 8;
      else {
        var m = f.length - a;
        for (l = m % 2 === 0 ? a + 1 : a; l < f.length; l += 2)
          b = y(f, a, l) << d, this.words[h] |= b & 67108863, d >= 18 ? (d -= 18, h += 1, this.words[h] |= b >>> 26) : d += 8;
      }
      this._strip();
    };
    function w(c, f, a, u) {
      for (var l = 0, d = 0, h = Math.min(c.length, a), b = f; b < h; b++) {
        var m = c.charCodeAt(b) - 48;
        l *= u, m >= 49 ? d = m - 49 + 10 : m >= 17 ? d = m - 17 + 10 : d = m, r(m >= 0 && d < u, "Invalid character"), l += d;
      }
      return l;
    }
    i.prototype._parseBase = function(f, a, u) {
      this.words = [0], this.length = 1;
      for (var l = 0, d = 1; d <= 67108863; d *= a)
        l++;
      l--, d = d / a | 0;
      for (var h = f.length - u, b = h % l, m = Math.min(h, h - b) + u, s = 0, g = u; g < m; g += l)
        s = w(f, g, g + l, a), this.imuln(d), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      if (b !== 0) {
        var q = 1;
        for (s = w(f, g, f.length, a), g = 0; g < b; g++)
          q *= a;
        this.imuln(q), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      }
      this._strip();
    }, i.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        f.words[a] = this.words[a];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function x(c, f) {
      c.words = f.words, c.length = f.length, c.negative = f.negative, c.red = f.red;
    }
    if (i.prototype._move = function(f) {
      x(f, this);
    }, i.prototype.clone = function() {
      var f = new i(null);
      return this.copy(f), f;
    }, i.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        i.prototype[Symbol.for("nodejs.util.inspect.custom")] = M;
      } catch {
        i.prototype.inspect = M;
      }
    else
      i.prototype.inspect = M;
    function M() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(f, a) {
      f = f || 10, a = a | 0 || 1;
      var u;
      if (f === 16 || f === "hex") {
        u = "";
        for (var l = 0, d = 0, h = 0; h < this.length; h++) {
          var b = this.words[h], m = ((b << l | d) & 16777215).toString(16);
          d = b >>> 24 - l & 16777215, l += 2, l >= 26 && (l -= 26, h--), d !== 0 || h !== this.length - 1 ? u = E[6 - m.length] + m + u : u = m + u;
        }
        for (d !== 0 && (u = d.toString(16) + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var s = A[f], g = I[f];
        u = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var R2 = q.modrn(g).toString(f);
          q = q.idivn(g), q.isZero() ? u = R2 + u : u = E[s - R2.length] + R2 + u;
        }
        for (this.isZero() && (u = "0" + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (i.prototype.toBuffer = function(f, a) {
      return this.toArrayLike(o, f, a);
    }), i.prototype.toArray = function(f, a) {
      return this.toArrayLike(Array, f, a);
    };
    var D = function(f, a) {
      return f.allocUnsafe ? f.allocUnsafe(a) : new f(a);
    };
    i.prototype.toArrayLike = function(f, a, u) {
      this._strip();
      var l = this.byteLength(), d = u || Math.max(1, l);
      r(l <= d, "byte array longer than desired length"), r(d > 0, "Requested array length <= 0");
      var h = D(f, d), b = a === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b](h, l), h;
    }, i.prototype._toArrayLikeLE = function(f, a) {
      for (var u = 0, l = 0, d = 0, h = 0; d < this.length; d++) {
        var b = this.words[d] << h | l;
        f[u++] = b & 255, u < f.length && (f[u++] = b >> 8 & 255), u < f.length && (f[u++] = b >> 16 & 255), h === 6 ? (u < f.length && (f[u++] = b >> 24 & 255), l = 0, h = 0) : (l = b >>> 24, h += 2);
      }
      if (u < f.length)
        for (f[u++] = l; u < f.length; )
          f[u++] = 0;
    }, i.prototype._toArrayLikeBE = function(f, a) {
      for (var u = f.length - 1, l = 0, d = 0, h = 0; d < this.length; d++) {
        var b = this.words[d] << h | l;
        f[u--] = b & 255, u >= 0 && (f[u--] = b >> 8 & 255), u >= 0 && (f[u--] = b >> 16 & 255), h === 6 ? (u >= 0 && (f[u--] = b >> 24 & 255), l = 0, h = 0) : (l = b >>> 24, h += 2);
      }
      if (u >= 0)
        for (f[u--] = l; u >= 0; )
          f[u--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : i.prototype._countBits = function(f) {
      var a = f, u = 0;
      return a >= 4096 && (u += 13, a >>>= 13), a >= 64 && (u += 7, a >>>= 7), a >= 8 && (u += 4, a >>>= 4), a >= 2 && (u += 2, a >>>= 2), u + a;
    }, i.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var a = f, u = 0;
      return (a & 8191) === 0 && (u += 13, a >>>= 13), (a & 127) === 0 && (u += 7, a >>>= 7), (a & 15) === 0 && (u += 4, a >>>= 4), (a & 3) === 0 && (u += 2, a >>>= 2), (a & 1) === 0 && u++, u;
    }, i.prototype.bitLength = function() {
      var f = this.words[this.length - 1], a = this._countBits(f);
      return (this.length - 1) * 26 + a;
    };
    function C(c) {
      for (var f = new Array(c.bitLength()), a = 0; a < f.length; a++) {
        var u = a / 26 | 0, l = a % 26;
        f[a] = c.words[u] >>> l & 1;
      }
      return f;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, a = 0; a < this.length; a++) {
        var u = this._zeroBits(this.words[a]);
        if (f += u, u !== 26)
          break;
      }
      return f;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var a = 0; a < f.length; a++)
        this.words[a] = this.words[a] | f.words[a];
      return this._strip();
    }, i.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, i.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, i.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, i.prototype.iuand = function(f) {
      var a;
      this.length > f.length ? a = f : a = this;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] & f.words[u];
      return this.length = a.length, this._strip();
    }, i.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, i.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, i.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, i.prototype.iuxor = function(f) {
      var a, u;
      this.length > f.length ? (a = this, u = f) : (a = f, u = this);
      for (var l = 0; l < u.length; l++)
        this.words[l] = a.words[l] ^ u.words[l];
      if (this !== a)
        for (; l < a.length; l++)
          this.words[l] = a.words[l];
      return this.length = a.length, this._strip();
    }, i.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, i.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, i.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, i.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = Math.ceil(f / 26) | 0, u = f % 26;
      this._expand(a), u > 0 && a--;
      for (var l = 0; l < a; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return u > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - u), this._strip();
    }, i.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, i.prototype.setn = function(f, a) {
      r(typeof f == "number" && f >= 0);
      var u = f / 26 | 0, l = f % 26;
      return this._expand(u + 1), a ? this.words[u] = this.words[u] | 1 << l : this.words[u] = this.words[u] & ~(1 << l), this._strip();
    }, i.prototype.iadd = function(f) {
      var a;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, a = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, a = this.isub(f), f.negative = 1, a._normSign();
      var u, l;
      this.length > f.length ? (u = this, l = f) : (u = f, l = this);
      for (var d = 0, h = 0; h < l.length; h++)
        a = (u.words[h] | 0) + (l.words[h] | 0) + d, this.words[h] = a & 67108863, d = a >>> 26;
      for (; d !== 0 && h < u.length; h++)
        a = (u.words[h] | 0) + d, this.words[h] = a & 67108863, d = a >>> 26;
      if (this.length = u.length, d !== 0)
        this.words[this.length] = d, this.length++;
      else if (u !== this)
        for (; h < u.length; h++)
          this.words[h] = u.words[h];
      return this;
    }, i.prototype.add = function(f) {
      var a;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, a = this.sub(f), f.negative ^= 1, a) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = f.sub(this), this.negative = 1, a) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, i.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var a = this.iadd(f);
        return f.negative = 1, a._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var u = this.cmp(f);
      if (u === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, d;
      u > 0 ? (l = this, d = f) : (l = f, d = this);
      for (var h = 0, b = 0; b < d.length; b++)
        a = (l.words[b] | 0) - (d.words[b] | 0) + h, h = a >> 26, this.words[b] = a & 67108863;
      for (; h !== 0 && b < l.length; b++)
        a = (l.words[b] | 0) + h, h = a >> 26, this.words[b] = a & 67108863;
      if (h === 0 && b < l.length && l !== this)
        for (; b < l.length; b++)
          this.words[b] = l.words[b];
      return this.length = Math.max(this.length, b), l !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function ge(c, f, a) {
      a.negative = f.negative ^ c.negative;
      var u = c.length + f.length | 0;
      a.length = u, u = u - 1 | 0;
      var l = c.words[0] | 0, d = f.words[0] | 0, h = l * d, b = h & 67108863, m = h / 67108864 | 0;
      a.words[0] = b;
      for (var s = 1; s < u; s++) {
        for (var g = m >>> 26, q = m & 67108863, R2 = Math.min(s, f.length - 1), B = Math.max(0, s - c.length + 1); B <= R2; B++) {
          var P = s - B | 0;
          l = c.words[P] | 0, d = f.words[B] | 0, h = l * d + q, g += h / 67108864 | 0, q = h & 67108863;
        }
        a.words[s] = q | 0, m = g | 0;
      }
      return m !== 0 ? a.words[s] = m | 0 : a.length--, a._strip();
    }
    var L = function(f, a, u) {
      var l = f.words, d = a.words, h = u.words, b = 0, m, s, g, q = l[0] | 0, R2 = q & 8191, B = q >>> 13, P = l[1] | 0, T = P & 8191, N2 = P >>> 13, ze = l[2] | 0, O = ze & 8191, z = ze >>> 13, Er2 = l[3] | 0, U = Er2 & 8191, H2 = Er2 >>> 13, Ar = l[4] | 0, F = Ar & 8191, K2 = Ar >>> 13, qr = l[5] | 0, j = qr & 8191, W = qr >>> 13, Br2 = l[6] | 0, V = Br2 & 8191, Z = Br2 >>> 13, Rr = l[7] | 0, G2 = Rr & 8191, X2 = Rr >>> 13, Ir = l[8] | 0, Y = Ir & 8191, J2 = Ir >>> 13, kr = l[9] | 0, $ = kr & 8191, Q = kr >>> 13, Dr = d[0] | 0, ee = Dr & 8191, te = Dr >>> 13, Pr = d[1] | 0, re = Pr & 8191, ie = Pr >>> 13, Tr = d[2] | 0, fe = Tr & 8191, ne = Tr >>> 13, Cr = d[3] | 0, ae = Cr & 8191, se = Cr >>> 13, Nr = d[4] | 0, oe = Nr & 8191, he = Nr >>> 13, Lr = d[5] | 0, ue = Lr & 8191, de = Lr >>> 13, Or = d[6] | 0, ce = Or & 8191, le = Or >>> 13, zr = d[7] | 0, ve = zr & 8191, pe = zr >>> 13, Ur = d[8] | 0, be = Ur & 8191, me = Ur >>> 13, dr2 = d[9] | 0, _e = dr2 & 8191, we = dr2 >>> 13;
      u.negative = f.negative ^ a.negative, u.length = 19, m = Math.imul(R2, ee), s = Math.imul(R2, te), s = s + Math.imul(B, ee) | 0, g = Math.imul(B, te);
      var At = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, m = Math.imul(T, ee), s = Math.imul(T, te), s = s + Math.imul(N2, ee) | 0, g = Math.imul(N2, te), m = m + Math.imul(R2, re) | 0, s = s + Math.imul(R2, ie) | 0, s = s + Math.imul(B, re) | 0, g = g + Math.imul(B, ie) | 0;
      var qt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, m = Math.imul(O, ee), s = Math.imul(O, te), s = s + Math.imul(z, ee) | 0, g = Math.imul(z, te), m = m + Math.imul(T, re) | 0, s = s + Math.imul(T, ie) | 0, s = s + Math.imul(N2, re) | 0, g = g + Math.imul(N2, ie) | 0, m = m + Math.imul(R2, fe) | 0, s = s + Math.imul(R2, ne) | 0, s = s + Math.imul(B, fe) | 0, g = g + Math.imul(B, ne) | 0;
      var Bt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, m = Math.imul(U, ee), s = Math.imul(U, te), s = s + Math.imul(H2, ee) | 0, g = Math.imul(H2, te), m = m + Math.imul(O, re) | 0, s = s + Math.imul(O, ie) | 0, s = s + Math.imul(z, re) | 0, g = g + Math.imul(z, ie) | 0, m = m + Math.imul(T, fe) | 0, s = s + Math.imul(T, ne) | 0, s = s + Math.imul(N2, fe) | 0, g = g + Math.imul(N2, ne) | 0, m = m + Math.imul(R2, ae) | 0, s = s + Math.imul(R2, se) | 0, s = s + Math.imul(B, ae) | 0, g = g + Math.imul(B, se) | 0;
      var Rt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, m = Math.imul(F, ee), s = Math.imul(F, te), s = s + Math.imul(K2, ee) | 0, g = Math.imul(K2, te), m = m + Math.imul(U, re) | 0, s = s + Math.imul(U, ie) | 0, s = s + Math.imul(H2, re) | 0, g = g + Math.imul(H2, ie) | 0, m = m + Math.imul(O, fe) | 0, s = s + Math.imul(O, ne) | 0, s = s + Math.imul(z, fe) | 0, g = g + Math.imul(z, ne) | 0, m = m + Math.imul(T, ae) | 0, s = s + Math.imul(T, se) | 0, s = s + Math.imul(N2, ae) | 0, g = g + Math.imul(N2, se) | 0, m = m + Math.imul(R2, oe) | 0, s = s + Math.imul(R2, he) | 0, s = s + Math.imul(B, oe) | 0, g = g + Math.imul(B, he) | 0;
      var It = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, m = Math.imul(j, ee), s = Math.imul(j, te), s = s + Math.imul(W, ee) | 0, g = Math.imul(W, te), m = m + Math.imul(F, re) | 0, s = s + Math.imul(F, ie) | 0, s = s + Math.imul(K2, re) | 0, g = g + Math.imul(K2, ie) | 0, m = m + Math.imul(U, fe) | 0, s = s + Math.imul(U, ne) | 0, s = s + Math.imul(H2, fe) | 0, g = g + Math.imul(H2, ne) | 0, m = m + Math.imul(O, ae) | 0, s = s + Math.imul(O, se) | 0, s = s + Math.imul(z, ae) | 0, g = g + Math.imul(z, se) | 0, m = m + Math.imul(T, oe) | 0, s = s + Math.imul(T, he) | 0, s = s + Math.imul(N2, oe) | 0, g = g + Math.imul(N2, he) | 0, m = m + Math.imul(R2, ue) | 0, s = s + Math.imul(R2, de) | 0, s = s + Math.imul(B, ue) | 0, g = g + Math.imul(B, de) | 0;
      var kt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, m = Math.imul(V, ee), s = Math.imul(V, te), s = s + Math.imul(Z, ee) | 0, g = Math.imul(Z, te), m = m + Math.imul(j, re) | 0, s = s + Math.imul(j, ie) | 0, s = s + Math.imul(W, re) | 0, g = g + Math.imul(W, ie) | 0, m = m + Math.imul(F, fe) | 0, s = s + Math.imul(F, ne) | 0, s = s + Math.imul(K2, fe) | 0, g = g + Math.imul(K2, ne) | 0, m = m + Math.imul(U, ae) | 0, s = s + Math.imul(U, se) | 0, s = s + Math.imul(H2, ae) | 0, g = g + Math.imul(H2, se) | 0, m = m + Math.imul(O, oe) | 0, s = s + Math.imul(O, he) | 0, s = s + Math.imul(z, oe) | 0, g = g + Math.imul(z, he) | 0, m = m + Math.imul(T, ue) | 0, s = s + Math.imul(T, de) | 0, s = s + Math.imul(N2, ue) | 0, g = g + Math.imul(N2, de) | 0, m = m + Math.imul(R2, ce) | 0, s = s + Math.imul(R2, le) | 0, s = s + Math.imul(B, ce) | 0, g = g + Math.imul(B, le) | 0;
      var Dt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, m = Math.imul(G2, ee), s = Math.imul(G2, te), s = s + Math.imul(X2, ee) | 0, g = Math.imul(X2, te), m = m + Math.imul(V, re) | 0, s = s + Math.imul(V, ie) | 0, s = s + Math.imul(Z, re) | 0, g = g + Math.imul(Z, ie) | 0, m = m + Math.imul(j, fe) | 0, s = s + Math.imul(j, ne) | 0, s = s + Math.imul(W, fe) | 0, g = g + Math.imul(W, ne) | 0, m = m + Math.imul(F, ae) | 0, s = s + Math.imul(F, se) | 0, s = s + Math.imul(K2, ae) | 0, g = g + Math.imul(K2, se) | 0, m = m + Math.imul(U, oe) | 0, s = s + Math.imul(U, he) | 0, s = s + Math.imul(H2, oe) | 0, g = g + Math.imul(H2, he) | 0, m = m + Math.imul(O, ue) | 0, s = s + Math.imul(O, de) | 0, s = s + Math.imul(z, ue) | 0, g = g + Math.imul(z, de) | 0, m = m + Math.imul(T, ce) | 0, s = s + Math.imul(T, le) | 0, s = s + Math.imul(N2, ce) | 0, g = g + Math.imul(N2, le) | 0, m = m + Math.imul(R2, ve) | 0, s = s + Math.imul(R2, pe) | 0, s = s + Math.imul(B, ve) | 0, g = g + Math.imul(B, pe) | 0;
      var Pt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, m = Math.imul(Y, ee), s = Math.imul(Y, te), s = s + Math.imul(J2, ee) | 0, g = Math.imul(J2, te), m = m + Math.imul(G2, re) | 0, s = s + Math.imul(G2, ie) | 0, s = s + Math.imul(X2, re) | 0, g = g + Math.imul(X2, ie) | 0, m = m + Math.imul(V, fe) | 0, s = s + Math.imul(V, ne) | 0, s = s + Math.imul(Z, fe) | 0, g = g + Math.imul(Z, ne) | 0, m = m + Math.imul(j, ae) | 0, s = s + Math.imul(j, se) | 0, s = s + Math.imul(W, ae) | 0, g = g + Math.imul(W, se) | 0, m = m + Math.imul(F, oe) | 0, s = s + Math.imul(F, he) | 0, s = s + Math.imul(K2, oe) | 0, g = g + Math.imul(K2, he) | 0, m = m + Math.imul(U, ue) | 0, s = s + Math.imul(U, de) | 0, s = s + Math.imul(H2, ue) | 0, g = g + Math.imul(H2, de) | 0, m = m + Math.imul(O, ce) | 0, s = s + Math.imul(O, le) | 0, s = s + Math.imul(z, ce) | 0, g = g + Math.imul(z, le) | 0, m = m + Math.imul(T, ve) | 0, s = s + Math.imul(T, pe) | 0, s = s + Math.imul(N2, ve) | 0, g = g + Math.imul(N2, pe) | 0, m = m + Math.imul(R2, be) | 0, s = s + Math.imul(R2, me) | 0, s = s + Math.imul(B, be) | 0, g = g + Math.imul(B, me) | 0;
      var Tt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, m = Math.imul($, ee), s = Math.imul($, te), s = s + Math.imul(Q, ee) | 0, g = Math.imul(Q, te), m = m + Math.imul(Y, re) | 0, s = s + Math.imul(Y, ie) | 0, s = s + Math.imul(J2, re) | 0, g = g + Math.imul(J2, ie) | 0, m = m + Math.imul(G2, fe) | 0, s = s + Math.imul(G2, ne) | 0, s = s + Math.imul(X2, fe) | 0, g = g + Math.imul(X2, ne) | 0, m = m + Math.imul(V, ae) | 0, s = s + Math.imul(V, se) | 0, s = s + Math.imul(Z, ae) | 0, g = g + Math.imul(Z, se) | 0, m = m + Math.imul(j, oe) | 0, s = s + Math.imul(j, he) | 0, s = s + Math.imul(W, oe) | 0, g = g + Math.imul(W, he) | 0, m = m + Math.imul(F, ue) | 0, s = s + Math.imul(F, de) | 0, s = s + Math.imul(K2, ue) | 0, g = g + Math.imul(K2, de) | 0, m = m + Math.imul(U, ce) | 0, s = s + Math.imul(U, le) | 0, s = s + Math.imul(H2, ce) | 0, g = g + Math.imul(H2, le) | 0, m = m + Math.imul(O, ve) | 0, s = s + Math.imul(O, pe) | 0, s = s + Math.imul(z, ve) | 0, g = g + Math.imul(z, pe) | 0, m = m + Math.imul(T, be) | 0, s = s + Math.imul(T, me) | 0, s = s + Math.imul(N2, be) | 0, g = g + Math.imul(N2, me) | 0, m = m + Math.imul(R2, _e) | 0, s = s + Math.imul(R2, we) | 0, s = s + Math.imul(B, _e) | 0, g = g + Math.imul(B, we) | 0;
      var Ct = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, m = Math.imul($, re), s = Math.imul($, ie), s = s + Math.imul(Q, re) | 0, g = Math.imul(Q, ie), m = m + Math.imul(Y, fe) | 0, s = s + Math.imul(Y, ne) | 0, s = s + Math.imul(J2, fe) | 0, g = g + Math.imul(J2, ne) | 0, m = m + Math.imul(G2, ae) | 0, s = s + Math.imul(G2, se) | 0, s = s + Math.imul(X2, ae) | 0, g = g + Math.imul(X2, se) | 0, m = m + Math.imul(V, oe) | 0, s = s + Math.imul(V, he) | 0, s = s + Math.imul(Z, oe) | 0, g = g + Math.imul(Z, he) | 0, m = m + Math.imul(j, ue) | 0, s = s + Math.imul(j, de) | 0, s = s + Math.imul(W, ue) | 0, g = g + Math.imul(W, de) | 0, m = m + Math.imul(F, ce) | 0, s = s + Math.imul(F, le) | 0, s = s + Math.imul(K2, ce) | 0, g = g + Math.imul(K2, le) | 0, m = m + Math.imul(U, ve) | 0, s = s + Math.imul(U, pe) | 0, s = s + Math.imul(H2, ve) | 0, g = g + Math.imul(H2, pe) | 0, m = m + Math.imul(O, be) | 0, s = s + Math.imul(O, me) | 0, s = s + Math.imul(z, be) | 0, g = g + Math.imul(z, me) | 0, m = m + Math.imul(T, _e) | 0, s = s + Math.imul(T, we) | 0, s = s + Math.imul(N2, _e) | 0, g = g + Math.imul(N2, we) | 0;
      var Nt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, m = Math.imul($, fe), s = Math.imul($, ne), s = s + Math.imul(Q, fe) | 0, g = Math.imul(Q, ne), m = m + Math.imul(Y, ae) | 0, s = s + Math.imul(Y, se) | 0, s = s + Math.imul(J2, ae) | 0, g = g + Math.imul(J2, se) | 0, m = m + Math.imul(G2, oe) | 0, s = s + Math.imul(G2, he) | 0, s = s + Math.imul(X2, oe) | 0, g = g + Math.imul(X2, he) | 0, m = m + Math.imul(V, ue) | 0, s = s + Math.imul(V, de) | 0, s = s + Math.imul(Z, ue) | 0, g = g + Math.imul(Z, de) | 0, m = m + Math.imul(j, ce) | 0, s = s + Math.imul(j, le) | 0, s = s + Math.imul(W, ce) | 0, g = g + Math.imul(W, le) | 0, m = m + Math.imul(F, ve) | 0, s = s + Math.imul(F, pe) | 0, s = s + Math.imul(K2, ve) | 0, g = g + Math.imul(K2, pe) | 0, m = m + Math.imul(U, be) | 0, s = s + Math.imul(U, me) | 0, s = s + Math.imul(H2, be) | 0, g = g + Math.imul(H2, me) | 0, m = m + Math.imul(O, _e) | 0, s = s + Math.imul(O, we) | 0, s = s + Math.imul(z, _e) | 0, g = g + Math.imul(z, we) | 0;
      var Lt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, m = Math.imul($, ae), s = Math.imul($, se), s = s + Math.imul(Q, ae) | 0, g = Math.imul(Q, se), m = m + Math.imul(Y, oe) | 0, s = s + Math.imul(Y, he) | 0, s = s + Math.imul(J2, oe) | 0, g = g + Math.imul(J2, he) | 0, m = m + Math.imul(G2, ue) | 0, s = s + Math.imul(G2, de) | 0, s = s + Math.imul(X2, ue) | 0, g = g + Math.imul(X2, de) | 0, m = m + Math.imul(V, ce) | 0, s = s + Math.imul(V, le) | 0, s = s + Math.imul(Z, ce) | 0, g = g + Math.imul(Z, le) | 0, m = m + Math.imul(j, ve) | 0, s = s + Math.imul(j, pe) | 0, s = s + Math.imul(W, ve) | 0, g = g + Math.imul(W, pe) | 0, m = m + Math.imul(F, be) | 0, s = s + Math.imul(F, me) | 0, s = s + Math.imul(K2, be) | 0, g = g + Math.imul(K2, me) | 0, m = m + Math.imul(U, _e) | 0, s = s + Math.imul(U, we) | 0, s = s + Math.imul(H2, _e) | 0, g = g + Math.imul(H2, we) | 0;
      var Ot = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, m = Math.imul($, oe), s = Math.imul($, he), s = s + Math.imul(Q, oe) | 0, g = Math.imul(Q, he), m = m + Math.imul(Y, ue) | 0, s = s + Math.imul(Y, de) | 0, s = s + Math.imul(J2, ue) | 0, g = g + Math.imul(J2, de) | 0, m = m + Math.imul(G2, ce) | 0, s = s + Math.imul(G2, le) | 0, s = s + Math.imul(X2, ce) | 0, g = g + Math.imul(X2, le) | 0, m = m + Math.imul(V, ve) | 0, s = s + Math.imul(V, pe) | 0, s = s + Math.imul(Z, ve) | 0, g = g + Math.imul(Z, pe) | 0, m = m + Math.imul(j, be) | 0, s = s + Math.imul(j, me) | 0, s = s + Math.imul(W, be) | 0, g = g + Math.imul(W, me) | 0, m = m + Math.imul(F, _e) | 0, s = s + Math.imul(F, we) | 0, s = s + Math.imul(K2, _e) | 0, g = g + Math.imul(K2, we) | 0;
      var zt = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, m = Math.imul($, ue), s = Math.imul($, de), s = s + Math.imul(Q, ue) | 0, g = Math.imul(Q, de), m = m + Math.imul(Y, ce) | 0, s = s + Math.imul(Y, le) | 0, s = s + Math.imul(J2, ce) | 0, g = g + Math.imul(J2, le) | 0, m = m + Math.imul(G2, ve) | 0, s = s + Math.imul(G2, pe) | 0, s = s + Math.imul(X2, ve) | 0, g = g + Math.imul(X2, pe) | 0, m = m + Math.imul(V, be) | 0, s = s + Math.imul(V, me) | 0, s = s + Math.imul(Z, be) | 0, g = g + Math.imul(Z, me) | 0, m = m + Math.imul(j, _e) | 0, s = s + Math.imul(j, we) | 0, s = s + Math.imul(W, _e) | 0, g = g + Math.imul(W, we) | 0;
      var Ut = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, m = Math.imul($, ce), s = Math.imul($, le), s = s + Math.imul(Q, ce) | 0, g = Math.imul(Q, le), m = m + Math.imul(Y, ve) | 0, s = s + Math.imul(Y, pe) | 0, s = s + Math.imul(J2, ve) | 0, g = g + Math.imul(J2, pe) | 0, m = m + Math.imul(G2, be) | 0, s = s + Math.imul(G2, me) | 0, s = s + Math.imul(X2, be) | 0, g = g + Math.imul(X2, me) | 0, m = m + Math.imul(V, _e) | 0, s = s + Math.imul(V, we) | 0, s = s + Math.imul(Z, _e) | 0, g = g + Math.imul(Z, we) | 0;
      var Ht = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m = Math.imul($, ve), s = Math.imul($, pe), s = s + Math.imul(Q, ve) | 0, g = Math.imul(Q, pe), m = m + Math.imul(Y, be) | 0, s = s + Math.imul(Y, me) | 0, s = s + Math.imul(J2, be) | 0, g = g + Math.imul(J2, me) | 0, m = m + Math.imul(G2, _e) | 0, s = s + Math.imul(G2, we) | 0, s = s + Math.imul(X2, _e) | 0, g = g + Math.imul(X2, we) | 0;
      var ei = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m = Math.imul($, be), s = Math.imul($, me), s = s + Math.imul(Q, be) | 0, g = Math.imul(Q, me), m = m + Math.imul(Y, _e) | 0, s = s + Math.imul(Y, we) | 0, s = s + Math.imul(J2, _e) | 0, g = g + Math.imul(J2, we) | 0;
      var ti = (b + m | 0) + ((s & 8191) << 13) | 0;
      b = (g + (s >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m = Math.imul($, _e), s = Math.imul($, we), s = s + Math.imul(Q, _e) | 0, g = Math.imul(Q, we);
      var ri = (b + m | 0) + ((s & 8191) << 13) | 0;
      return b = (g + (s >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, h[0] = At, h[1] = qt, h[2] = Bt, h[3] = Rt, h[4] = It, h[5] = kt, h[6] = Dt, h[7] = Pt, h[8] = Tt, h[9] = Ct, h[10] = Nt, h[11] = Lt, h[12] = Ot, h[13] = zt, h[14] = Ut, h[15] = Ht, h[16] = ei, h[17] = ti, h[18] = ri, b !== 0 && (h[19] = b, u.length++), u;
    };
    Math.imul || (L = ge);
    function ye(c, f, a) {
      a.negative = f.negative ^ c.negative, a.length = c.length + f.length;
      for (var u = 0, l = 0, d = 0; d < a.length - 1; d++) {
        var h = l;
        l = 0;
        for (var b = u & 67108863, m = Math.min(d, f.length - 1), s = Math.max(0, d - c.length + 1); s <= m; s++) {
          var g = d - s, q = c.words[g] | 0, R2 = f.words[s] | 0, B = q * R2, P = B & 67108863;
          h = h + (B / 67108864 | 0) | 0, P = P + b | 0, b = P & 67108863, h = h + (P >>> 26) | 0, l += h >>> 26, h &= 67108863;
        }
        a.words[d] = b, u = h, h = l;
      }
      return u !== 0 ? a.words[d] = u : a.length--, a._strip();
    }
    function Re(c, f, a) {
      return ye(c, f, a);
    }
    i.prototype.mulTo = function(f, a) {
      var u, l = this.length + f.length;
      return this.length === 10 && f.length === 10 ? u = L(this, f, a) : l < 63 ? u = ge(this, f, a) : l < 1024 ? u = ye(this, f, a) : u = Re(this, f, a), u;
    };
    function xe(c, f) {
      this.x = c, this.y = f;
    }
    xe.prototype.makeRBT = function(f) {
      for (var a = new Array(f), u = i.prototype._countBits(f) - 1, l = 0; l < f; l++)
        a[l] = this.revBin(l, u, f);
      return a;
    }, xe.prototype.revBin = function(f, a, u) {
      if (f === 0 || f === u - 1)
        return f;
      for (var l = 0, d = 0; d < a; d++)
        l |= (f & 1) << a - d - 1, f >>= 1;
      return l;
    }, xe.prototype.permute = function(f, a, u, l, d, h) {
      for (var b = 0; b < h; b++)
        l[b] = a[f[b]], d[b] = u[f[b]];
    }, xe.prototype.transform = function(f, a, u, l, d, h) {
      this.permute(h, f, a, u, l, d);
      for (var b = 1; b < d; b <<= 1)
        for (var m = b << 1, s = Math.cos(2 * Math.PI / m), g = Math.sin(2 * Math.PI / m), q = 0; q < d; q += m)
          for (var R2 = s, B = g, P = 0; P < b; P++) {
            var T = u[q + P], N2 = l[q + P], ze = u[q + P + b], O = l[q + P + b], z = R2 * ze - B * O;
            O = R2 * O + B * ze, ze = z, u[q + P] = T + ze, l[q + P] = N2 + O, u[q + P + b] = T - ze, l[q + P + b] = N2 - O, P !== m && (z = s * R2 - g * B, B = s * B + g * R2, R2 = z);
          }
    }, xe.prototype.guessLen13b = function(f, a) {
      var u = Math.max(a, f) | 1, l = u & 1, d = 0;
      for (u = u / 2 | 0; u; u = u >>> 1)
        d++;
      return 1 << d + 1 + l;
    }, xe.prototype.conjugate = function(f, a, u) {
      if (!(u <= 1))
        for (var l = 0; l < u / 2; l++) {
          var d = f[l];
          f[l] = f[u - l - 1], f[u - l - 1] = d, d = a[l], a[l] = -a[u - l - 1], a[u - l - 1] = -d;
        }
    }, xe.prototype.normalize13b = function(f, a) {
      for (var u = 0, l = 0; l < a / 2; l++) {
        var d = Math.round(f[2 * l + 1] / a) * 8192 + Math.round(f[2 * l] / a) + u;
        f[l] = d & 67108863, d < 67108864 ? u = 0 : u = d / 67108864 | 0;
      }
      return f;
    }, xe.prototype.convert13b = function(f, a, u, l) {
      for (var d = 0, h = 0; h < a; h++)
        d = d + (f[h] | 0), u[2 * h] = d & 8191, d = d >>> 13, u[2 * h + 1] = d & 8191, d = d >>> 13;
      for (h = 2 * a; h < l; ++h)
        u[h] = 0;
      r(d === 0), r((d & -8192) === 0);
    }, xe.prototype.stub = function(f) {
      for (var a = new Array(f), u = 0; u < f; u++)
        a[u] = 0;
      return a;
    }, xe.prototype.mulp = function(f, a, u) {
      var l = 2 * this.guessLen13b(f.length, a.length), d = this.makeRBT(l), h = this.stub(l), b = new Array(l), m = new Array(l), s = new Array(l), g = new Array(l), q = new Array(l), R2 = new Array(l), B = u.words;
      B.length = l, this.convert13b(f.words, f.length, b, l), this.convert13b(a.words, a.length, g, l), this.transform(b, h, m, s, l, d), this.transform(g, h, q, R2, l, d);
      for (var P = 0; P < l; P++) {
        var T = m[P] * q[P] - s[P] * R2[P];
        s[P] = m[P] * R2[P] + s[P] * q[P], m[P] = T;
      }
      return this.conjugate(m, s, l), this.transform(m, s, B, h, l, d), this.conjugate(B, h, l), this.normalize13b(B, l), u.negative = f.negative ^ a.negative, u.length = f.length + a.length, u._strip();
    }, i.prototype.mul = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), this.mulTo(f, a);
    }, i.prototype.mulf = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), Re(this, f, a);
    }, i.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, i.prototype.imuln = function(f) {
      var a = f < 0;
      a && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var u = 0, l = 0; l < this.length; l++) {
        var d = (this.words[l] | 0) * f, h = (d & 67108863) + (u & 67108863);
        u >>= 26, u += d / 67108864 | 0, u += h >>> 26, this.words[l] = h & 67108863;
      }
      return u !== 0 && (this.words[l] = u, this.length++), a ? this.ineg() : this;
    }, i.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(f) {
      var a = C(f);
      if (a.length === 0)
        return new i(1);
      for (var u = this, l = 0; l < a.length && a[l] === 0; l++, u = u.sqr())
        ;
      if (++l < a.length)
        for (var d = u.sqr(); l < a.length; l++, d = d.sqr())
          a[l] !== 0 && (u = u.mul(d));
      return u;
    }, i.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 67108863 >>> 26 - a << 26 - a, d;
      if (a !== 0) {
        var h = 0;
        for (d = 0; d < this.length; d++) {
          var b = this.words[d] & l, m = (this.words[d] | 0) - b << a;
          this.words[d] = m | h, h = b >>> 26 - a;
        }
        h && (this.words[d] = h, this.length++);
      }
      if (u !== 0) {
        for (d = this.length - 1; d >= 0; d--)
          this.words[d + u] = this.words[d];
        for (d = 0; d < u; d++)
          this.words[d] = 0;
        this.length += u;
      }
      return this._strip();
    }, i.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, i.prototype.iushrn = function(f, a, u) {
      r(typeof f == "number" && f >= 0);
      var l;
      a ? l = (a - a % 26) / 26 : l = 0;
      var d = f % 26, h = Math.min((f - d) / 26, this.length), b = 67108863 ^ 67108863 >>> d << d, m = u;
      if (l -= h, l = Math.max(0, l), m) {
        for (var s = 0; s < h; s++)
          m.words[s] = this.words[s];
        m.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, s = 0; s < this.length; s++)
            this.words[s] = this.words[s + h];
        else
          this.words[0] = 0, this.length = 1;
      var g = 0;
      for (s = this.length - 1; s >= 0 && (g !== 0 || s >= l); s--) {
        var q = this.words[s] | 0;
        this.words[s] = g << 26 - d | q >>> d, g = q & b;
      }
      return m && g !== 0 && (m.words[m.length++] = g), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(f, a, u) {
      return r(this.negative === 0), this.iushrn(f, a, u);
    }, i.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, i.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, i.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, i.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, i.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return false;
      var d = this.words[u];
      return !!(d & l);
    }, i.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u)
        return this;
      if (a !== 0 && u++, this.length = Math.min(u, this.length), a !== 0) {
        var l = 67108863 ^ 67108863 >>> a << a;
        this.words[this.length - 1] &= l;
      }
      return this._strip();
    }, i.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, i.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, i.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var a = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
      return this.length = Math.max(this.length, a + 1), this;
    }, i.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a = 0; a < this.length && this.words[a] < 0; a++)
          this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, i.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(f, a, u) {
      var l = f.length + u, d;
      this._expand(l);
      var h, b = 0;
      for (d = 0; d < f.length; d++) {
        h = (this.words[d + u] | 0) + b;
        var m = (f.words[d] | 0) * a;
        h -= m & 67108863, b = (h >> 26) - (m / 67108864 | 0), this.words[d + u] = h & 67108863;
      }
      for (; d < this.length - u; d++)
        h = (this.words[d + u] | 0) + b, b = h >> 26, this.words[d + u] = h & 67108863;
      if (b === 0)
        return this._strip();
      for (r(b === -1), b = 0, d = 0; d < this.length; d++)
        h = -(this.words[d] | 0) + b, b = h >> 26, this.words[d] = h & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(f, a) {
      var u = this.length - f.length, l = this.clone(), d = f, h = d.words[d.length - 1] | 0, b = this._countBits(h);
      u = 26 - b, u !== 0 && (d = d.ushln(u), l.iushln(u), h = d.words[d.length - 1] | 0);
      var m = l.length - d.length, s;
      if (a !== "mod") {
        s = new i(null), s.length = m + 1, s.words = new Array(s.length);
        for (var g = 0; g < s.length; g++)
          s.words[g] = 0;
      }
      var q = l.clone()._ishlnsubmul(d, 1, m);
      q.negative === 0 && (l = q, s && (s.words[m] = 1));
      for (var R2 = m - 1; R2 >= 0; R2--) {
        var B = (l.words[d.length + R2] | 0) * 67108864 + (l.words[d.length + R2 - 1] | 0);
        for (B = Math.min(B / h | 0, 67108863), l._ishlnsubmul(d, B, R2); l.negative !== 0; )
          B--, l.negative = 0, l._ishlnsubmul(d, 1, R2), l.isZero() || (l.negative ^= 1);
        s && (s.words[R2] = B);
      }
      return s && s._strip(), l._strip(), a !== "div" && u !== 0 && l.iushrn(u), { div: s || null, mod: l };
    }, i.prototype.divmod = function(f, a, u) {
      if (r(!f.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var l, d, h;
      return this.negative !== 0 && f.negative === 0 ? (h = this.neg().divmod(f, a), a !== "mod" && (l = h.div.neg()), a !== "div" && (d = h.mod.neg(), u && d.negative !== 0 && d.iadd(f)), { div: l, mod: d }) : this.negative === 0 && f.negative !== 0 ? (h = this.divmod(f.neg(), a), a !== "mod" && (l = h.div.neg()), { div: l, mod: h.mod }) : (this.negative & f.negative) !== 0 ? (h = this.neg().divmod(f.neg(), a), a !== "div" && (d = h.mod.neg(), u && d.negative !== 0 && d.isub(f)), { div: h.div, mod: d }) : f.length > this.length || this.cmp(f) < 0 ? { div: new i(0), mod: this } : f.length === 1 ? a === "div" ? { div: this.divn(f.words[0]), mod: null } : a === "mod" ? { div: null, mod: new i(this.modrn(f.words[0])) } : { div: this.divn(f.words[0]), mod: new i(this.modrn(f.words[0])) } : this._wordDiv(f, a);
    }, i.prototype.div = function(f) {
      return this.divmod(f, "div", false).div;
    }, i.prototype.mod = function(f) {
      return this.divmod(f, "mod", false).mod;
    }, i.prototype.umod = function(f) {
      return this.divmod(f, "mod", true).mod;
    }, i.prototype.divRound = function(f) {
      var a = this.divmod(f);
      if (a.mod.isZero())
        return a.div;
      var u = a.div.negative !== 0 ? a.mod.isub(f) : a.mod, l = f.ushrn(1), d = f.andln(1), h = u.cmp(l);
      return h < 0 || d === 1 && h === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
    }, i.prototype.modrn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = (1 << 26) % f, l = 0, d = this.length - 1; d >= 0; d--)
        l = (u * l + (this.words[d] | 0)) % f;
      return a ? -l : l;
    }, i.prototype.modn = function(f) {
      return this.modrn(f);
    }, i.prototype.idivn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d = (this.words[l] | 0) + u * 67108864;
        this.words[l] = d / f | 0, u = d % f;
      }
      return this._strip(), a ? this.ineg() : this;
    }, i.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, i.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d = new i(0), h = new i(0), b = new i(1), m = 0; a.isEven() && u.isEven(); )
        a.iushrn(1), u.iushrn(1), ++m;
      for (var s = u.clone(), g = a.clone(); !a.isZero(); ) {
        for (var q = 0, R2 = 1; (a.words[0] & R2) === 0 && q < 26; ++q, R2 <<= 1)
          ;
        if (q > 0)
          for (a.iushrn(q); q-- > 0; )
            (l.isOdd() || d.isOdd()) && (l.iadd(s), d.isub(g)), l.iushrn(1), d.iushrn(1);
        for (var B = 0, P = 1; (u.words[0] & P) === 0 && B < 26; ++B, P <<= 1)
          ;
        if (B > 0)
          for (u.iushrn(B); B-- > 0; )
            (h.isOdd() || b.isOdd()) && (h.iadd(s), b.isub(g)), h.iushrn(1), b.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(h), d.isub(b)) : (u.isub(a), h.isub(l), b.isub(d));
      }
      return { a: h, b, gcd: u.iushln(m) };
    }, i.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d = new i(0), h = u.clone(); a.cmpn(1) > 0 && u.cmpn(1) > 0; ) {
        for (var b = 0, m = 1; (a.words[0] & m) === 0 && b < 26; ++b, m <<= 1)
          ;
        if (b > 0)
          for (a.iushrn(b); b-- > 0; )
            l.isOdd() && l.iadd(h), l.iushrn(1);
        for (var s = 0, g = 1; (u.words[0] & g) === 0 && s < 26; ++s, g <<= 1)
          ;
        if (s > 0)
          for (u.iushrn(s); s-- > 0; )
            d.isOdd() && d.iadd(h), d.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(d)) : (u.isub(a), d.isub(l));
      }
      var q;
      return a.cmpn(1) === 0 ? q = l : q = d, q.cmpn(0) < 0 && q.iadd(f), q;
    }, i.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var a = this.clone(), u = f.clone();
      a.negative = 0, u.negative = 0;
      for (var l = 0; a.isEven() && u.isEven(); l++)
        a.iushrn(1), u.iushrn(1);
      do {
        for (; a.isEven(); )
          a.iushrn(1);
        for (; u.isEven(); )
          u.iushrn(1);
        var d = a.cmp(u);
        if (d < 0) {
          var h = a;
          a = u, u = h;
        } else if (d === 0 || u.cmpn(1) === 0)
          break;
        a.isub(u);
      } while (true);
      return u.iushln(l);
    }, i.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(f) {
      return this.words[0] & f;
    }, i.prototype.bincn = function(f) {
      r(typeof f == "number");
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return this._expand(u + 1), this.words[u] |= l, this;
      for (var d = l, h = u; d !== 0 && h < this.length; h++) {
        var b = this.words[h] | 0;
        b += d, d = b >>> 26, b &= 67108863, this.words[h] = b;
      }
      return d !== 0 && (this.words[h] = d, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(f) {
      var a = f < 0;
      if (this.negative !== 0 && !a)
        return -1;
      if (this.negative === 0 && a)
        return 1;
      this._strip();
      var u;
      if (this.length > 1)
        u = 1;
      else {
        a && (f = -f), r(f <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        u = l === f ? 0 : l < f ? -1 : 1;
      }
      return this.negative !== 0 ? -u | 0 : u;
    }, i.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var a = this.ucmp(f);
      return this.negative !== 0 ? -a | 0 : a;
    }, i.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var a = 0, u = this.length - 1; u >= 0; u--) {
        var l = this.words[u] | 0, d = f.words[u] | 0;
        if (l !== d) {
          l < d ? a = -1 : l > d && (a = 1);
          break;
        }
      }
      return a;
    }, i.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, i.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, i.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, i.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, i.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, i.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, i.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, i.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, i.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, i.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, i.red = function(f) {
      return new v(f);
    }, i.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, i.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, i.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, i.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, i.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, i.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, i.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, i.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, i.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ke = { k256: null, p224: null, p192: null, p25519: null };
    function Me(c, f) {
      this.name = c, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var f = new i(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Me.prototype.ireduce = function(f) {
      var a = f, u;
      do
        this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), u = a.bitLength();
      while (u > this.n);
      var l = u < this.n ? -1 : a.ucmp(this.p);
      return l === 0 ? (a.words[0] = 0, a.length = 1) : l > 0 ? a.isub(this.p) : a.strip !== void 0 ? a.strip() : a._strip(), a;
    }, Me.prototype.split = function(f, a) {
      f.iushrn(this.n, 0, a);
    }, Me.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function Ce() {
      Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(Ce, Me), Ce.prototype.split = function(f, a) {
      for (var u = 4194303, l = Math.min(f.length, 9), d = 0; d < l; d++)
        a.words[d] = f.words[d];
      if (a.length = l, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var h = f.words[9];
      for (a.words[a.length++] = h & u, d = 10; d < f.length; d++) {
        var b = f.words[d] | 0;
        f.words[d - 10] = (b & u) << 4 | h >>> 22, h = b;
      }
      h >>>= 22, f.words[d - 10] = h, h === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, Ce.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = f.words[u] | 0;
        a += l * 977, f.words[u] = a & 67108863, a = l * 64 + (a / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Ee() {
      Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(Ee, Me);
    function Ne() {
      Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Ne, Me);
    function S() {
      Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(S, Me), S.prototype.imulK = function(f) {
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = (f.words[u] | 0) * 19 + a, d = l & 67108863;
        l >>>= 26, f.words[u] = d, a = l;
      }
      return a !== 0 && (f.words[f.length++] = a), f;
    }, i._prime = function(f) {
      if (ke[f])
        return ke[f];
      var a;
      if (f === "k256")
        a = new Ce();
      else if (f === "p224")
        a = new Ee();
      else if (f === "p192")
        a = new Ne();
      else if (f === "p25519")
        a = new S();
      else
        throw new Error("Unknown prime " + f);
      return ke[f] = a, a;
    };
    function v(c) {
      if (typeof c == "string") {
        var f = i._prime(c);
        this.m = f.p, this.prime = f;
      } else
        r(c.gtn(1), "modulus must be greater than 1"), this.m = c, this.prime = null;
    }
    v.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, v.prototype._verify2 = function(f, a) {
      r((f.negative | a.negative) === 0, "red works only with positives"), r(f.red && f.red === a.red, "red works only with red numbers");
    }, v.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (x(f, f.umod(this.m)._forceRed(this)), f);
    }, v.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, v.prototype.add = function(f, a) {
      this._verify2(f, a);
      var u = f.add(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u._forceRed(this);
    }, v.prototype.iadd = function(f, a) {
      this._verify2(f, a);
      var u = f.iadd(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u;
    }, v.prototype.sub = function(f, a) {
      this._verify2(f, a);
      var u = f.sub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u._forceRed(this);
    }, v.prototype.isub = function(f, a) {
      this._verify2(f, a);
      var u = f.isub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u;
    }, v.prototype.shl = function(f, a) {
      return this._verify1(f), this.imod(f.ushln(a));
    }, v.prototype.imul = function(f, a) {
      return this._verify2(f, a), this.imod(f.imul(a));
    }, v.prototype.mul = function(f, a) {
      return this._verify2(f, a), this.imod(f.mul(a));
    }, v.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, v.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, v.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var a = this.m.andln(3);
      if (r(a % 2 === 1), a === 3) {
        var u = this.m.add(new i(1)).iushrn(2);
        return this.pow(f, u);
      }
      for (var l = this.m.subn(1), d = 0; !l.isZero() && l.andln(1) === 0; )
        d++, l.iushrn(1);
      r(!l.isZero());
      var h = new i(1).toRed(this), b = h.redNeg(), m = this.m.subn(1).iushrn(1), s = this.m.bitLength();
      for (s = new i(2 * s * s).toRed(this); this.pow(s, m).cmp(b) !== 0; )
        s.redIAdd(b);
      for (var g = this.pow(s, l), q = this.pow(f, l.addn(1).iushrn(1)), R2 = this.pow(f, l), B = d; R2.cmp(h) !== 0; ) {
        for (var P = R2, T = 0; P.cmp(h) !== 0; T++)
          P = P.redSqr();
        r(T < B);
        var N2 = this.pow(g, new i(1).iushln(B - T - 1));
        q = q.redMul(N2), g = N2.redSqr(), R2 = R2.redMul(g), B = T;
      }
      return q;
    }, v.prototype.invm = function(f) {
      var a = f._invmp(this.m);
      return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
    }, v.prototype.pow = function(f, a) {
      if (a.isZero())
        return new i(1).toRed(this);
      if (a.cmpn(1) === 0)
        return f.clone();
      var u = 4, l = new Array(1 << u);
      l[0] = new i(1).toRed(this), l[1] = f;
      for (var d = 2; d < l.length; d++)
        l[d] = this.mul(l[d - 1], f);
      var h = l[0], b = 0, m = 0, s = a.bitLength() % 26;
      for (s === 0 && (s = 26), d = a.length - 1; d >= 0; d--) {
        for (var g = a.words[d], q = s - 1; q >= 0; q--) {
          var R2 = g >> q & 1;
          if (h !== l[0] && (h = this.sqr(h)), R2 === 0 && b === 0) {
            m = 0;
            continue;
          }
          b <<= 1, b |= R2, m++, !(m !== u && (d !== 0 || q !== 0)) && (h = this.mul(h, l[b]), m = 0, b = 0);
        }
        s = 26;
      }
      return h;
    }, v.prototype.convertTo = function(f) {
      var a = f.umod(this.m);
      return a === f ? a.clone() : a;
    }, v.prototype.convertFrom = function(f) {
      var a = f.clone();
      return a.red = null, a;
    }, i.mont = function(f) {
      return new _(f);
    };
    function _(c) {
      v.call(this, c), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(_, v), _.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, _.prototype.convertFrom = function(f) {
      var a = this.imod(f.mul(this.rinv));
      return a.red = null, a;
    }, _.prototype.imul = function(f, a) {
      if (f.isZero() || a.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var u = f.imul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d = u.isub(l).iushrn(this.shift), h = d;
      return d.cmp(this.m) >= 0 ? h = d.isub(this.m) : d.cmpn(0) < 0 && (h = d.iadd(this.m)), h._forceRed(this);
    }, _.prototype.mul = function(f, a) {
      if (f.isZero() || a.isZero())
        return new i(0)._forceRed(this);
      var u = f.mul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d = u.isub(l).iushrn(this.shift), h = d;
      return d.cmp(this.m) >= 0 ? h = d.isub(this.m) : d.cmpn(0) < 0 && (h = d.iadd(this.m)), h._forceRed(this);
    }, _.prototype.invm = function(f) {
      var a = this.imod(f._invmp(this.m).mul(this.r2));
      return a._forceRed(this);
    };
  })(typeof hs > "u" || hs, Oc);
});
var aa = k2((Km, zc) => {
  "use strict";
  var na = export_default, tf = na.Buffer, wt = {}, xt;
  for (xt in na)
    !na.hasOwnProperty(xt) || xt === "SlowBuffer" || xt === "Buffer" || (wt[xt] = na[xt]);
  var rf = wt.Buffer = {};
  for (xt in tf)
    !tf.hasOwnProperty(xt) || xt === "allocUnsafe" || xt === "allocUnsafeSlow" || (rf[xt] = tf[xt]);
  wt.Buffer.prototype = tf.prototype;
  (!rf.from || rf.from === Uint8Array.from) && (rf.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return tf(t, e, r);
  });
  rf.alloc || (rf.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30))
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var n = tf(t);
    return !e || e.length === 0 ? n.fill(0) : typeof r == "string" ? n.fill(e, r) : n.fill(e), n;
  });
  if (!wt.kStringMaxLength)
    try {
      wt.kStringMaxLength = process_default.binding("buffer").kStringMaxLength;
    } catch {
    }
  wt.constants || (wt.constants = { MAX_LENGTH: wt.kMaxLength }, wt.kStringMaxLength && (wt.constants.MAX_STRING_LENGTH = wt.kStringMaxLength));
  zc.exports = wt;
});
var sa = k2((Uc) => {
  "use strict";
  var r4 = qe();
  function Mt(t) {
    this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
  }
  Uc.Reporter = Mt;
  Mt.prototype.isError = function(e) {
    return e instanceof ff;
  };
  Mt.prototype.save = function() {
    let e = this._reporterState;
    return { obj: e.obj, pathLen: e.path.length };
  };
  Mt.prototype.restore = function(e) {
    let r = this._reporterState;
    r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
  };
  Mt.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  Mt.prototype.exitKey = function(e) {
    let r = this._reporterState;
    r.path = r.path.slice(0, e - 1);
  };
  Mt.prototype.leaveKey = function(e, r, n) {
    let i = this._reporterState;
    this.exitKey(e), i.obj !== null && (i.obj[r] = n);
  };
  Mt.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  Mt.prototype.enterObject = function() {
    let e = this._reporterState, r = e.obj;
    return e.obj = {}, r;
  };
  Mt.prototype.leaveObject = function(e) {
    let r = this._reporterState, n = r.obj;
    return r.obj = e, n;
  };
  Mt.prototype.error = function(e) {
    let r, n = this._reporterState, i = e instanceof ff;
    if (i ? r = e : r = new ff(n.path.map(function(o) {
      return "[" + JSON.stringify(o) + "]";
    }).join(""), e.message || e, e.stack), !n.options.partial)
      throw r;
    return i || n.errors.push(r), r;
  };
  Mt.prototype.wrapResult = function(e) {
    let r = this._reporterState;
    return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
  };
  function ff(t, e) {
    this.path = t, this.rethrow(e);
  }
  r4(ff, Error);
  ff.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ff), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r) {
        this.stack = r.stack;
      }
    return this;
  };
});
var sf = k2((ds) => {
  "use strict";
  var i4 = qe(), oa = sa().Reporter, nf = aa().Buffer;
  function St(t, e) {
    if (oa.call(this, e), !nf.isBuffer(t)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = t, this.offset = 0, this.length = t.length;
  }
  i4(St, oa);
  ds.DecoderBuffer = St;
  St.isDecoderBuffer = function(e) {
    return e instanceof St ? true : typeof e == "object" && nf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  St.prototype.save = function() {
    return { offset: this.offset, reporter: oa.prototype.save.call(this) };
  };
  St.prototype.restore = function(e) {
    let r = new St(this.base);
    return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, oa.prototype.restore.call(this, e.reporter), r;
  };
  St.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  St.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  St.prototype.skip = function(e, r) {
    if (!(this.offset + e <= this.length))
      return this.error(r || "DecoderBuffer overrun");
    let n = new St(this.base);
    return n._reporterState = this._reporterState, n.offset = this.offset, n.length = this.offset + e, this.offset += e, n;
  };
  St.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function af(t, e) {
    if (Array.isArray(t))
      this.length = 0, this.value = t.map(function(r) {
        return af.isEncoderBuffer(r) || (r = new af(r, e)), this.length += r.length, r;
      }, this);
    else if (typeof t == "number") {
      if (!(0 <= t && t <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = t, this.length = 1;
    } else if (typeof t == "string")
      this.value = t, this.length = nf.byteLength(t);
    else if (nf.isBuffer(t))
      this.value = t, this.length = t.length;
    else
      return e.error("Unsupported type: " + typeof t);
  }
  ds.EncoderBuffer = af;
  af.isEncoderBuffer = function(e) {
    return e instanceof af ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  af.prototype.join = function(e, r) {
    return e || (e = nf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(n) {
      n.join(e, r), r += n.length;
    }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : nf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
  };
});
var ha = k2((Vm, Fc) => {
  "use strict";
  var f4 = sa().Reporter, n4 = sf().EncoderBuffer, a4 = sf().DecoderBuffer, it = ot(), Hc = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], s4 = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Hc), o4 = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function De(t, e, r) {
    let n = {};
    this._baseState = n, n.name = r, n.enc = t, n.parent = e || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = false, n.any = false, n.obj = false, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap());
  }
  Fc.exports = De;
  var h4 = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  De.prototype.clone = function() {
    let e = this._baseState, r = {};
    h4.forEach(function(i) {
      r[i] = e[i];
    });
    let n = new this.constructor(r.parent);
    return n._baseState = r, n;
  };
  De.prototype._wrap = function() {
    let e = this._baseState;
    s4.forEach(function(r) {
      this[r] = function() {
        let i = new this.constructor(this);
        return e.children.push(i), i[r].apply(i, arguments);
      };
    }, this);
  };
  De.prototype._init = function(e) {
    let r = this._baseState;
    it(r.parent === null), e.call(this), r.children = r.children.filter(function(n) {
      return n._baseState.parent === this;
    }, this), it.equal(r.children.length, 1, "Root node can have only one child");
  };
  De.prototype._useArgs = function(e) {
    let r = this._baseState, n = e.filter(function(i) {
      return i instanceof this.constructor;
    }, this);
    e = e.filter(function(i) {
      return !(i instanceof this.constructor);
    }, this), n.length !== 0 && (it(r.children === null), r.children = n, n.forEach(function(i) {
      i._baseState.parent = this;
    }, this)), e.length !== 0 && (it(r.args === null), r.args = e, r.reverseArgs = e.map(function(i) {
      if (typeof i != "object" || i.constructor !== Object)
        return i;
      let o = {};
      return Object.keys(i).forEach(function(p) {
        p == (p | 0) && (p |= 0);
        let y = i[p];
        o[y] = p;
      }), o;
    }));
  };
  o4.forEach(function(t) {
    De.prototype[t] = function() {
      let r = this._baseState;
      throw new Error(t + " not implemented for encoding: " + r.enc);
    };
  });
  Hc.forEach(function(t) {
    De.prototype[t] = function() {
      let r = this._baseState, n = Array.prototype.slice.call(arguments);
      return it(r.tag === null), r.tag = t, this._useArgs(n), this;
    };
  });
  De.prototype.use = function(e) {
    it(e);
    let r = this._baseState;
    return it(r.use === null), r.use = e, this;
  };
  De.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  De.prototype.def = function(e) {
    let r = this._baseState;
    return it(r.default === null), r.default = e, r.optional = true, this;
  };
  De.prototype.explicit = function(e) {
    let r = this._baseState;
    return it(r.explicit === null && r.implicit === null), r.explicit = e, this;
  };
  De.prototype.implicit = function(e) {
    let r = this._baseState;
    return it(r.explicit === null && r.implicit === null), r.implicit = e, this;
  };
  De.prototype.obj = function() {
    let e = this._baseState, r = Array.prototype.slice.call(arguments);
    return e.obj = true, r.length !== 0 && this._useArgs(r), this;
  };
  De.prototype.key = function(e) {
    let r = this._baseState;
    return it(r.key === null), r.key = e, this;
  };
  De.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  De.prototype.choice = function(e) {
    let r = this._baseState;
    return it(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(n) {
      return e[n];
    })), this;
  };
  De.prototype.contains = function(e) {
    let r = this._baseState;
    return it(r.use === null), r.contains = e, this;
  };
  De.prototype._decode = function(e, r) {
    let n = this._baseState;
    if (n.parent === null)
      return e.wrapResult(n.children[0]._decode(e, r));
    let i = n.default, o = true, p = null;
    if (n.key !== null && (p = e.enterKey(n.key)), n.optional) {
      let w = null;
      if (n.explicit !== null ? w = n.explicit : n.implicit !== null ? w = n.implicit : n.tag !== null && (w = n.tag), w === null && !n.any) {
        let x = e.save();
        try {
          n.choice === null ? this._decodeGeneric(n.tag, e, r) : this._decodeChoice(e, r), o = true;
        } catch {
          o = false;
        }
        e.restore(x);
      } else if (o = this._peekTag(e, w, n.any), e.isError(o))
        return o;
    }
    let y;
    if (n.obj && o && (y = e.enterObject()), o) {
      if (n.explicit !== null) {
        let x = this._decodeTag(e, n.explicit);
        if (e.isError(x))
          return x;
        e = x;
      }
      let w = e.offset;
      if (n.use === null && n.choice === null) {
        let x;
        n.any && (x = e.save());
        let M = this._decodeTag(e, n.implicit !== null ? n.implicit : n.tag, n.any);
        if (e.isError(M))
          return M;
        n.any ? i = e.raw(x) : e = M;
      }
      if (r && r.track && n.tag !== null && r.track(e.path(), w, e.length, "tagged"), r && r.track && n.tag !== null && r.track(e.path(), e.offset, e.length, "content"), n.any || (n.choice === null ? i = this._decodeGeneric(n.tag, e, r) : i = this._decodeChoice(e, r)), e.isError(i))
        return i;
      if (!n.any && n.choice === null && n.children !== null && n.children.forEach(function(M) {
        M._decode(e, r);
      }), n.contains && (n.tag === "octstr" || n.tag === "bitstr")) {
        let x = new a4(i);
        i = this._getUse(n.contains, e._reporterState.obj)._decode(x, r);
      }
    }
    return n.obj && o && (i = e.leaveObject(y)), n.key !== null && (i !== null || o === true) ? e.leaveKey(p, n.key, i) : p !== null && e.exitKey(p), i;
  };
  De.prototype._decodeGeneric = function(e, r, n) {
    let i = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(r, e, n) : e === "objid" && i.args ? this._decodeObjid(r, i.args[0], i.args[1], n) : e === "objid" ? this._decodeObjid(r, null, null, n) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, n) : e === "null_" ? this._decodeNull(r, n) : e === "bool" ? this._decodeBool(r, n) : e === "objDesc" ? this._decodeStr(r, e, n) : e === "int" || e === "enum" ? this._decodeInt(r, i.args && i.args[0], n) : i.use !== null ? this._getUse(i.use, r._reporterState.obj)._decode(r, n) : r.error("unknown tag: " + e);
  };
  De.prototype._getUse = function(e, r) {
    let n = this._baseState;
    return n.useDecoder = this._use(e, r), it(n.useDecoder._baseState.parent === null), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder;
  };
  De.prototype._decodeChoice = function(e, r) {
    let n = this._baseState, i = null, o = false;
    return Object.keys(n.choice).some(function(p) {
      let y = e.save(), w = n.choice[p];
      try {
        let x = w._decode(e, r);
        if (e.isError(x))
          return false;
        i = { type: p, value: x }, o = true;
      } catch {
        return e.restore(y), false;
      }
      return true;
    }, this), o ? i : e.error("Choice not matched");
  };
  De.prototype._createEncoderBuffer = function(e) {
    return new n4(e, this.reporter);
  };
  De.prototype._encode = function(e, r, n) {
    let i = this._baseState;
    if (i.default !== null && i.default === e)
      return;
    let o = this._encodeValue(e, r, n);
    if (o !== void 0 && !this._skipDefault(o, r, n))
      return o;
  };
  De.prototype._encodeValue = function(e, r, n) {
    let i = this._baseState;
    if (i.parent === null)
      return i.children[0]._encode(e, r || new f4());
    let o = null;
    if (this.reporter = r, i.optional && e === void 0)
      if (i.default !== null)
        e = i.default;
      else
        return;
    let p = null, y = false;
    if (i.any)
      o = this._createEncoderBuffer(e);
    else if (i.choice)
      o = this._encodeChoice(e, r);
    else if (i.contains)
      p = this._getUse(i.contains, n)._encode(e, r), y = true;
    else if (i.children)
      p = i.children.map(function(w) {
        if (w._baseState.tag === "null_")
          return w._encode(null, r, e);
        if (w._baseState.key === null)
          return r.error("Child should have a key");
        let x = r.enterKey(w._baseState.key);
        if (typeof e != "object")
          return r.error("Child expected, but input is not object");
        let M = w._encode(e[w._baseState.key], r, e);
        return r.leaveKey(x), M;
      }, this).filter(function(w) {
        return w;
      }), p = this._createEncoderBuffer(p);
    else if (i.tag === "seqof" || i.tag === "setof") {
      if (!(i.args && i.args.length === 1))
        return r.error("Too many args for : " + i.tag);
      if (!Array.isArray(e))
        return r.error("seqof/setof, but data is not Array");
      let w = this.clone();
      w._baseState.implicit = null, p = this._createEncoderBuffer(e.map(function(x) {
        let M = this._baseState;
        return this._getUse(M.args[0], e)._encode(x, r);
      }, w));
    } else
      i.use !== null ? o = this._getUse(i.use, n)._encode(e, r) : (p = this._encodePrimitive(i.tag, e), y = true);
    if (!i.any && i.choice === null) {
      let w = i.implicit !== null ? i.implicit : i.tag, x = i.implicit === null ? "universal" : "context";
      w === null ? i.use === null && r.error("Tag could be omitted only for .use()") : i.use === null && (o = this._encodeComposite(w, y, x, p));
    }
    return i.explicit !== null && (o = this._encodeComposite(i.explicit, false, "context", o)), o;
  };
  De.prototype._encodeChoice = function(e, r) {
    let n = this._baseState, i = n.choice[e.type];
    return i || it(false, e.type + " not found in " + JSON.stringify(Object.keys(n.choice))), i._encode(e.value, r);
  };
  De.prototype._encodePrimitive = function(e, r) {
    let n = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(r, e);
    if (e === "objid" && n.args)
      return this._encodeObjid(r, n.reverseArgs[0], n.args[1]);
    if (e === "objid")
      return this._encodeObjid(r, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(r, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(r, n.args && n.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(r);
    if (e === "objDesc")
      return this._encodeStr(r, e);
    throw new Error("Unsupported tag: " + e);
  };
  De.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  De.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var ua = k2((qi) => {
  "use strict";
  function Kc(t) {
    let e = {};
    return Object.keys(t).forEach(function(r) {
      (r | 0) == r && (r = r | 0);
      let n = t[r];
      e[n] = r;
    }), e;
  }
  qi.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  qi.tagClassByName = Kc(qi.tagClass);
  qi.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  qi.tagByName = Kc(qi.tag);
});
var ls = k2((Gm, Vc) => {
  "use strict";
  var u4 = qe(), Sr = aa().Buffer, jc = ha(), cs = ua();
  function Wc(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Xt(), this.tree._init(t.body);
  }
  Vc.exports = Wc;
  Wc.prototype.encode = function(e, r) {
    return this.tree._encode(e, r).join();
  };
  function Xt(t) {
    jc.call(this, "der", t);
  }
  u4(Xt, jc);
  Xt.prototype._encodeComposite = function(e, r, n, i) {
    let o = d4(e, r, n, this.reporter);
    if (i.length < 128) {
      let w = Sr.alloc(2);
      return w[0] = o, w[1] = i.length, this._createEncoderBuffer([w, i]);
    }
    let p = 1;
    for (let w = i.length; w >= 256; w >>= 8)
      p++;
    let y = Sr.alloc(1 + 1 + p);
    y[0] = o, y[1] = 128 | p;
    for (let w = 1 + p, x = i.length; x > 0; w--, x >>= 8)
      y[w] = x & 255;
    return this._createEncoderBuffer([y, i]);
  };
  Xt.prototype._encodeStr = function(e, r) {
    if (r === "bitstr")
      return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r === "bmpstr") {
      let n = Sr.alloc(e.length * 2);
      for (let i = 0; i < e.length; i++)
        n.writeUInt16BE(e.charCodeAt(i), i * 2);
      return this._createEncoderBuffer(n);
    } else
      return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
  };
  Xt.prototype._encodeObjid = function(e, r, n) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("string objid given, but no values map found");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = r[e].split(/[\s.]+/g);
      for (let y = 0; y < e.length; y++)
        e[y] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let y = 0; y < e.length; y++)
        e[y] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!n) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let i = 0;
    for (let y = 0; y < e.length; y++) {
      let w = e[y];
      for (i++; w >= 128; w >>= 7)
        i++;
    }
    let o = Sr.alloc(i), p = o.length - 1;
    for (let y = e.length - 1; y >= 0; y--) {
      let w = e[y];
      for (o[p--] = w & 127; (w >>= 7) > 0; )
        o[p--] = 128 | w & 127;
    }
    return this._createEncoderBuffer(o);
  };
  function Et(t) {
    return t < 10 ? "0" + t : t;
  }
  Xt.prototype._encodeTime = function(e, r) {
    let n, i = new Date(e);
    return r === "gentime" ? n = [Et(i.getUTCFullYear()), Et(i.getUTCMonth() + 1), Et(i.getUTCDate()), Et(i.getUTCHours()), Et(i.getUTCMinutes()), Et(i.getUTCSeconds()), "Z"].join("") : r === "utctime" ? n = [Et(i.getUTCFullYear() % 100), Et(i.getUTCMonth() + 1), Et(i.getUTCDate()), Et(i.getUTCHours()), Et(i.getUTCMinutes()), Et(i.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(n, "octstr");
  };
  Xt.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  Xt.prototype._encodeInt = function(e, r) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("String int or enum given, but no values map");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = r[e];
    }
    if (typeof e != "number" && !Sr.isBuffer(e)) {
      let o = e.toArray();
      !e.sign && o[0] & 128 && o.unshift(0), e = Sr.from(o);
    }
    if (Sr.isBuffer(e)) {
      let o = e.length;
      e.length === 0 && o++;
      let p = Sr.alloc(o);
      return e.copy(p), e.length === 0 && (p[0] = 0), this._createEncoderBuffer(p);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([0, e]);
    let n = 1;
    for (let o = e; o >= 256; o >>= 8)
      n++;
    let i = new Array(n);
    for (let o = i.length - 1; o >= 0; o--)
      i[o] = e & 255, e >>= 8;
    return i[0] & 128 && i.unshift(0), this._createEncoderBuffer(Sr.from(i));
  };
  Xt.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  Xt.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
  };
  Xt.prototype._skipDefault = function(e, r, n) {
    let i = this._baseState, o;
    if (i.default === null)
      return false;
    let p = e.join();
    if (i.defaultBuffer === void 0 && (i.defaultBuffer = this._encodeValue(i.default, r, n).join()), p.length !== i.defaultBuffer.length)
      return false;
    for (o = 0; o < p.length; o++)
      if (p[o] !== i.defaultBuffer[o])
        return false;
    return true;
  };
  function d4(t, e, r, n) {
    let i;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), cs.tagByName.hasOwnProperty(t))
      i = cs.tagByName[t];
    else if (typeof t == "number" && (t | 0) === t)
      i = t;
    else
      return n.error("Unknown tag: " + t);
    return i >= 31 ? n.error("Multi-octet tag encoding unsupported") : (e || (i |= 32), i |= cs.tagClassByName[r || "universal"] << 6, i);
  }
});
var Gc = k2((Xm, Zc) => {
  "use strict";
  var c4 = qe(), vs = ls();
  function ps(t) {
    vs.call(this, t), this.enc = "pem";
  }
  c4(ps, vs);
  Zc.exports = ps;
  ps.prototype.encode = function(e, r) {
    let i = vs.prototype.encode.call(this, e).toString("base64"), o = ["-----BEGIN " + r.label + "-----"];
    for (let p = 0; p < i.length; p += 64)
      o.push(i.slice(p, p + 64));
    return o.push("-----END " + r.label + "-----"), o.join(`
`);
  };
});
var bs = k2((Yc) => {
  "use strict";
  var Xc = Yc;
  Xc.der = ls();
  Xc.pem = Gc();
});
var gs = k2((Jm, rl) => {
  "use strict";
  var l4 = qe(), v4 = Fe(), Jc = sf().DecoderBuffer, Qc = ha(), $c = ua();
  function el(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new ut2(), this.tree._init(t.body);
  }
  rl.exports = el;
  el.prototype.decode = function(e, r) {
    return Jc.isDecoderBuffer(e) || (e = new Jc(e, r)), this.tree._decode(e, r);
  };
  function ut2(t) {
    Qc.call(this, "der", t);
  }
  l4(ut2, Qc);
  ut2.prototype._peekTag = function(e, r, n) {
    if (e.isEmpty())
      return false;
    let i = e.save(), o = ms(e, 'Failed to peek tag: "' + r + '"');
    return e.isError(o) ? o : (e.restore(i), o.tag === r || o.tagStr === r || o.tagStr + "of" === r || n);
  };
  ut2.prototype._decodeTag = function(e, r, n) {
    let i = ms(e, 'Failed to decode tag of "' + r + '"');
    if (e.isError(i))
      return i;
    let o = tl(e, i.primitive, 'Failed to get length of "' + r + '"');
    if (e.isError(o))
      return o;
    if (!n && i.tag !== r && i.tagStr !== r && i.tagStr + "of" !== r)
      return e.error('Failed to match tag: "' + r + '"');
    if (i.primitive || o !== null)
      return e.skip(o, 'Failed to match body of: "' + r + '"');
    let p = e.save(), y = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(y) ? y : (o = e.offset - p.offset, e.restore(p), e.skip(o, 'Failed to match body of: "' + r + '"'));
  };
  ut2.prototype._skipUntilEnd = function(e, r) {
    for (; ; ) {
      let n = ms(e, r);
      if (e.isError(n))
        return n;
      let i = tl(e, n.primitive, r);
      if (e.isError(i))
        return i;
      let o;
      if (n.primitive || i !== null ? o = e.skip(i) : o = this._skipUntilEnd(e, r), e.isError(o))
        return o;
      if (n.tagStr === "end")
        break;
    }
  };
  ut2.prototype._decodeList = function(e, r, n, i) {
    let o = [];
    for (; !e.isEmpty(); ) {
      let p = this._peekTag(e, "end");
      if (e.isError(p))
        return p;
      let y = n.decode(e, "der", i);
      if (e.isError(y) && p)
        break;
      o.push(y);
    }
    return o;
  };
  ut2.prototype._decodeStr = function(e, r) {
    if (r === "bitstr") {
      let n = e.readUInt8();
      return e.isError(n) ? n : { unused: n, data: e.raw() };
    } else if (r === "bmpstr") {
      let n = e.raw();
      if (n.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let i = "";
      for (let o = 0; o < n.length / 2; o++)
        i += String.fromCharCode(n.readUInt16BE(o * 2));
      return i;
    } else if (r === "numstr") {
      let n = e.raw().toString("ascii");
      return this._isNumstr(n) ? n : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (r === "octstr")
        return e.raw();
      if (r === "objDesc")
        return e.raw();
      if (r === "printstr") {
        let n = e.raw().toString("ascii");
        return this._isPrintstr(n) ? n : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
    }
  };
  ut2.prototype._decodeObjid = function(e, r, n) {
    let i, o = [], p = 0, y = 0;
    for (; !e.isEmpty(); )
      y = e.readUInt8(), p <<= 7, p |= y & 127, (y & 128) === 0 && (o.push(p), p = 0);
    y & 128 && o.push(p);
    let w = o[0] / 40 | 0, x = o[0] % 40;
    if (n ? i = o : i = [w, x].concat(o.slice(1)), r) {
      let M = r[i.join(" ")];
      M === void 0 && (M = r[i.join(".")]), M !== void 0 && (i = M);
    }
    return i;
  };
  ut2.prototype._decodeTime = function(e, r) {
    let n = e.raw().toString(), i, o, p, y, w, x;
    if (r === "gentime")
      i = n.slice(0, 4) | 0, o = n.slice(4, 6) | 0, p = n.slice(6, 8) | 0, y = n.slice(8, 10) | 0, w = n.slice(10, 12) | 0, x = n.slice(12, 14) | 0;
    else if (r === "utctime")
      i = n.slice(0, 2) | 0, o = n.slice(2, 4) | 0, p = n.slice(4, 6) | 0, y = n.slice(6, 8) | 0, w = n.slice(8, 10) | 0, x = n.slice(10, 12) | 0, i < 70 ? i = 2e3 + i : i = 1900 + i;
    else
      return e.error("Decoding " + r + " time is not supported yet");
    return Date.UTC(i, o - 1, p, y, w, x, 0);
  };
  ut2.prototype._decodeNull = function() {
    return null;
  };
  ut2.prototype._decodeBool = function(e) {
    let r = e.readUInt8();
    return e.isError(r) ? r : r !== 0;
  };
  ut2.prototype._decodeInt = function(e, r) {
    let n = e.raw(), i = new v4(n);
    return r && (i = r[i.toString(10)] || i), i;
  };
  ut2.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
  };
  function ms(t, e) {
    let r = t.readUInt8(e);
    if (t.isError(r))
      return r;
    let n = $c.tagClass[r >> 6], i = (r & 32) === 0;
    if ((r & 31) === 31) {
      let p = r;
      for (r = 0; (p & 128) === 128; ) {
        if (p = t.readUInt8(e), t.isError(p))
          return p;
        r <<= 7, r |= p & 127;
      }
    } else
      r &= 31;
    let o = $c.tag[r];
    return { cls: n, primitive: i, tag: r, tagStr: o };
  }
  function tl(t, e, r) {
    let n = t.readUInt8(r);
    if (t.isError(n))
      return n;
    if (!e && n === 128)
      return null;
    if ((n & 128) === 0)
      return n;
    let i = n & 127;
    if (i > 4)
      return t.error("length octect is too long");
    n = 0;
    for (let o = 0; o < i; o++) {
      n <<= 8;
      let p = t.readUInt8(r);
      if (t.isError(p))
        return p;
      n |= p;
    }
    return n;
  }
});
var fl = k2(($m, il) => {
  "use strict";
  var p4 = qe(), b4 = aa().Buffer, ys = gs();
  function _s(t) {
    ys.call(this, t), this.enc = "pem";
  }
  p4(_s, ys);
  il.exports = _s;
  _s.prototype.decode = function(e, r) {
    let n = e.toString().split(/[\r\n]+/g), i = r.label.toUpperCase(), o = /^-----(BEGIN|END) ([^-]+)-----$/, p = -1, y = -1;
    for (let M = 0; M < n.length; M++) {
      let E = n[M].match(o);
      if (E !== null && E[2] === i)
        if (p === -1) {
          if (E[1] !== "BEGIN")
            break;
          p = M;
        } else {
          if (E[1] !== "END")
            break;
          y = M;
          break;
        }
    }
    if (p === -1 || y === -1)
      throw new Error("PEM section not found for: " + i);
    let w = n.slice(p + 1, y).join("");
    w.replace(/[^a-z0-9+/=]+/gi, "");
    let x = b4.from(w, "base64");
    return ys.prototype.decode.call(this, x, r);
  };
});
var ws = k2((al) => {
  "use strict";
  var nl = al;
  nl.der = gs();
  nl.pem = fl();
});
var ol = k2((sl) => {
  "use strict";
  var m4 = bs(), g4 = ws(), y4 = qe(), _4 = sl;
  _4.define = function(e, r) {
    return new of(e, r);
  };
  function of(t, e) {
    this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
  }
  of.prototype._createNamed = function(e) {
    let r = this.name;
    function n(i) {
      this._initNamed(i, r);
    }
    return y4(n, e), n.prototype._initNamed = function(o, p) {
      e.call(this, o, p);
    }, new n(this);
  };
  of.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(g4[e])), this.decoders[e];
  };
  of.prototype.decode = function(e, r, n) {
    return this._getDecoder(r).decode(e, n);
  };
  of.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(m4[e])), this.encoders[e];
  };
  of.prototype.encode = function(e, r, n) {
    return this._getEncoder(r).encode(e, n);
  };
});
var ul = k2((hl) => {
  "use strict";
  var da = hl;
  da.Reporter = sa().Reporter;
  da.DecoderBuffer = sf().DecoderBuffer;
  da.EncoderBuffer = sf().EncoderBuffer;
  da.Node = ha();
});
var ll = k2((cl) => {
  "use strict";
  var dl = cl;
  dl._reverse = function(e) {
    let r = {};
    return Object.keys(e).forEach(function(n) {
      (n | 0) == n && (n = n | 0);
      let i = e[n];
      r[i] = n;
    }), r;
  };
  dl.der = ua();
});
var xs = k2((vl) => {
  "use strict";
  var hf = vl;
  hf.bignum = Fe();
  hf.define = ol().define;
  hf.base = ul();
  hf.constants = ll();
  hf.decoders = ws();
  hf.encoders = bs();
});
var gl = k2((f7, ml) => {
  "use strict";
  var Yt = xs(), pl = Yt.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), w4 = Yt.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), Ms = Yt.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), x4 = Yt.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ms), this.key("subjectPublicKey").bitstr());
  }), M4 = Yt.define("RelativeDistinguishedName", function() {
    this.setof(w4);
  }), S4 = Yt.define("RDNSequence", function() {
    this.seqof(M4);
  }), bl = Yt.define("Name", function() {
    this.choice({ rdnSequence: this.use(S4) });
  }), E4 = Yt.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(pl), this.key("notAfter").use(pl));
  }), A4 = Yt.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), q4 = Yt.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Ms), this.key("issuer").use(bl), this.key("validity").use(E4), this.key("subject").use(bl), this.key("subjectPublicKeyInfo").use(x4), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(A4).optional());
  }), B4 = Yt.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(q4), this.key("signatureAlgorithm").use(Ms), this.key("signatureValue").bitstr());
  });
  ml.exports = B4;
});
var _l = k2(($t) => {
  "use strict";
  var Jt = xs();
  $t.certificate = gl();
  var R4 = Jt.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  $t.RSAPrivateKey = R4;
  var I4 = Jt.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  $t.RSAPublicKey = I4;
  var k4 = Jt.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(yl), this.key("subjectPublicKey").bitstr());
  });
  $t.PublicKey = k4;
  var yl = Jt.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), D4 = Jt.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(yl), this.key("subjectPrivateKey").octstr());
  });
  $t.PrivateKey = D4;
  var P4 = Jt.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  $t.EncryptedPrivateKey = P4;
  var T4 = Jt.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  $t.DSAPrivateKey = T4;
  $t.DSAparam = Jt.define("DSAparam", function() {
    this.int();
  });
  var C4 = Jt.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(N4), this.key("publicKey").optional().explicit(1).bitstr());
  });
  $t.ECPrivateKey = C4;
  var N4 = Jt.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  });
  $t.signature = Jt.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var wl = k2((a7, L4) => {
  L4.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
});
var Ml = k2((s7, xl) => {
  var O4 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, z4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, U4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, H4 = Pf(), F4 = Ln(), ca = Ae().Buffer;
  xl.exports = function(t, e) {
    var r = t.toString(), n = r.match(O4), i;
    if (n) {
      var p = "aes" + n[1], y = ca.from(n[2], "hex"), w = ca.from(n[3].replace(/[\r\n]/g, ""), "base64"), x = H4(e, y.slice(0, 8), parseInt(n[1], 10)).key, M = [], E = F4.createDecipheriv(p, x, y);
      M.push(E.update(w)), M.push(E.final()), i = ca.concat(M);
    } else {
      var o = r.match(U4);
      i = ca.from(o[2].replace(/[\r\n]/g, ""), "base64");
    }
    var A = r.match(z4)[1];
    return { tag: A, data: i };
  };
});
var Hf = k2((o7, El) => {
  var st = _l(), K4 = wl(), j4 = Ml(), W4 = Ln(), V4 = d0(), Ss = Ae().Buffer;
  El.exports = Sl;
  function Sl(t) {
    var e;
    typeof t == "object" && !Ss.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = Ss.from(t));
    var r = j4(t, e), n = r.tag, i = r.data, o, p;
    switch (n) {
      case "CERTIFICATE":
        p = st.certificate.decode(i, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (p || (p = st.PublicKey.decode(i, "der")), o = p.algorithm.algorithm.join("."), o) {
          case "1.2.840.113549.1.1.1":
            return st.RSAPublicKey.decode(p.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return p.subjectPrivateKey = p.subjectPublicKey, { type: "ec", data: p };
          case "1.2.840.10040.4.1":
            return p.algorithm.params.pub_key = st.DSAparam.decode(p.subjectPublicKey.data, "der"), { type: "dsa", data: p.algorithm.params };
          default:
            throw new Error("unknown key id " + o);
        }
      case "ENCRYPTED PRIVATE KEY":
        i = st.EncryptedPrivateKey.decode(i, "der"), i = Z4(i, e);
      case "PRIVATE KEY":
        switch (p = st.PrivateKey.decode(i, "der"), o = p.algorithm.algorithm.join("."), o) {
          case "1.2.840.113549.1.1.1":
            return st.RSAPrivateKey.decode(p.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: p.algorithm.curve, privateKey: st.ECPrivateKey.decode(p.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return p.algorithm.params.priv_key = st.DSAparam.decode(p.subjectPrivateKey, "der"), { type: "dsa", params: p.algorithm.params };
          default:
            throw new Error("unknown key id " + o);
        }
      case "RSA PUBLIC KEY":
        return st.RSAPublicKey.decode(i, "der");
      case "RSA PRIVATE KEY":
        return st.RSAPrivateKey.decode(i, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: st.DSAPrivateKey.decode(i, "der") };
      case "EC PRIVATE KEY":
        return i = st.ECPrivateKey.decode(i, "der"), { curve: i.parameters.value, privateKey: i.privateKey };
      default:
        throw new Error("unknown key type " + n);
    }
  }
  Sl.signature = st.signature;
  function Z4(t, e) {
    var r = t.algorithm.decrypt.kde.kdeparams.salt, n = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), i = K4[t.algorithm.decrypt.cipher.algo.join(".")], o = t.algorithm.decrypt.cipher.iv, p = t.subjectPrivateKey, y = parseInt(i.split("-")[1], 10) / 8, w = V4.pbkdf2Sync(e, r, n, y, "sha1"), x = W4.createDecipheriv(i, w, o), M = [];
    return M.push(x.update(p)), M.push(x.final()), Ss.concat(M);
  }
});
var Es = k2((h7, G4) => {
  G4.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
});
var Bl = k2((u7, va) => {
  var rt2 = Ae().Buffer, Bi = t0(), X4 = Hn(), Y4 = fa().ec, la = us(), J4 = Hf(), $4 = Es();
  function Q4(t, e, r, n, i) {
    var o = J4(e);
    if (o.curve) {
      if (n !== "ecdsa" && n !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return e8(t, o);
    } else if (o.type === "dsa") {
      if (n !== "dsa")
        throw new Error("wrong private key type");
      return t8(t, o, r);
    } else if (n !== "rsa" && n !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    t = rt2.concat([i, t]);
    for (var p = o.modulus.byteLength(), y = [0, 1]; t.length + y.length + 1 < p; )
      y.push(255);
    y.push(0);
    for (var w = -1; ++w < t.length; )
      y.push(t[w]);
    var x = X4(y, o);
    return x;
  }
  function e8(t, e) {
    var r = $4[e.curve.join(".")];
    if (!r)
      throw new Error("unknown curve " + e.curve.join("."));
    var n = new Y4(r), i = n.keyFromPrivate(e.privateKey), o = i.sign(t);
    return rt2.from(o.toDER());
  }
  function t8(t, e, r) {
    for (var n = e.params.priv_key, i = e.params.p, o = e.params.q, p = e.params.g, y = new la(0), w, x = As(t, o).mod(o), M = false, E = Al(n, o, t, r); M === false; )
      w = ql(o, E, r), y = f8(p, w, i, o), M = w.invm(o).imul(x.add(n.mul(y))).mod(o), M.cmpn(0) === 0 && (M = false, y = new la(0));
    return r8(y, M);
  }
  function r8(t, e) {
    t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
    var r = t.length + e.length + 4, n = [48, r, 2, t.length];
    return n = n.concat(t, [2, e.length], e), rt2.from(n);
  }
  function Al(t, e, r, n) {
    if (t = rt2.from(t.toArray()), t.length < e.byteLength()) {
      var i = rt2.alloc(e.byteLength() - t.length);
      t = rt2.concat([i, t]);
    }
    var o = r.length, p = i8(r, e), y = rt2.alloc(o);
    y.fill(1);
    var w = rt2.alloc(o);
    return w = Bi(n, w).update(y).update(rt2.from([0])).update(t).update(p).digest(), y = Bi(n, w).update(y).digest(), w = Bi(n, w).update(y).update(rt2.from([1])).update(t).update(p).digest(), y = Bi(n, w).update(y).digest(), { k: w, v: y };
  }
  function As(t, e) {
    var r = new la(t), n = (t.length << 3) - e.bitLength();
    return n > 0 && r.ishrn(n), r;
  }
  function i8(t, e) {
    t = As(t, e), t = t.mod(e);
    var r = rt2.from(t.toArray());
    if (r.length < e.byteLength()) {
      var n = rt2.alloc(e.byteLength() - r.length);
      r = rt2.concat([n, r]);
    }
    return r;
  }
  function ql(t, e, r) {
    var n, i;
    do {
      for (n = rt2.alloc(0); n.length * 8 < t.bitLength(); )
        e.v = Bi(r, e.k).update(e.v).digest(), n = rt2.concat([n, e.v]);
      i = As(n, t), e.k = Bi(r, e.k).update(e.v).update(rt2.from([0])).digest(), e.v = Bi(r, e.k).update(e.v).digest();
    } while (i.cmp(t) !== -1);
    return i;
  }
  function f8(t, e, r, n) {
    return t.toRed(la.mont(r)).redPow(e).fromRed().mod(n);
  }
  va.exports = Q4;
  va.exports.getKey = Al;
  va.exports.makeKey = ql;
});
var Dl = k2((d7, kl) => {
  var qs = Ae().Buffer, Ff = us(), n8 = fa().ec, Il = Hf(), a8 = Es();
  function s8(t, e, r, n, i) {
    var o = Il(r);
    if (o.type === "ec") {
      if (n !== "ecdsa" && n !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return o8(t, e, o);
    } else if (o.type === "dsa") {
      if (n !== "dsa")
        throw new Error("wrong public key type");
      return h8(t, e, o);
    } else if (n !== "rsa" && n !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    e = qs.concat([i, e]);
    for (var p = o.modulus.byteLength(), y = [1], w = 0; e.length + y.length + 2 < p; )
      y.push(255), w++;
    y.push(0);
    for (var x = -1; ++x < e.length; )
      y.push(e[x]);
    y = qs.from(y);
    var M = Ff.mont(o.modulus);
    t = new Ff(t).toRed(M), t = t.redPow(new Ff(o.publicExponent)), t = qs.from(t.fromRed().toArray());
    var E = w < 8 ? 1 : 0;
    for (p = Math.min(t.length, y.length), t.length !== y.length && (E = 1), x = -1; ++x < p; )
      E |= t[x] ^ y[x];
    return E === 0;
  }
  function o8(t, e, r) {
    var n = a8[r.data.algorithm.curve.join(".")];
    if (!n)
      throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
    var i = new n8(n), o = r.data.subjectPrivateKey.data;
    return i.verify(e, t, o);
  }
  function h8(t, e, r) {
    var n = r.data.p, i = r.data.q, o = r.data.g, p = r.data.pub_key, y = Il.signature.decode(t, "der"), w = y.s, x = y.r;
    Rl(w, i), Rl(x, i);
    var M = Ff.mont(n), E = w.invm(i), A = o.toRed(M).redPow(new Ff(e).mul(E).mod(i)).fromRed().mul(p.toRed(M).redPow(x.mul(E).mod(i)).fromRed()).mod(n).mod(i);
    return A.cmp(x) === 0;
  }
  function Rl(t, e) {
    if (t.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (t.cmp(e) >= e)
      throw new Error("invalid sig");
  }
  kl.exports = s8;
});
var Ol = k2((c7, Ll) => {
  var pa = Ae().Buffer, Cl = Ni(), ba = Za(), Nl = qe(), u8 = Bl(), d8 = Dl(), Ri = r0();
  Object.keys(Ri).forEach(function(t) {
    Ri[t].id = pa.from(Ri[t].id, "hex"), Ri[t.toLowerCase()] = Ri[t];
  });
  function Kf(t) {
    ba.Writable.call(this);
    var e = Ri[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hashType = e.hash, this._hash = Cl(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  Nl(Kf, ba.Writable);
  Kf.prototype._write = function(e, r, n) {
    this._hash.update(e), n();
  };
  Kf.prototype.update = function(e, r) {
    return typeof e == "string" && (e = pa.from(e, r)), this._hash.update(e), this;
  };
  Kf.prototype.sign = function(e, r) {
    this.end();
    var n = this._hash.digest(), i = u8(n, e, this._hashType, this._signType, this._tag);
    return r ? i.toString(r) : i;
  };
  function jf(t) {
    ba.Writable.call(this);
    var e = Ri[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hash = Cl(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  Nl(jf, ba.Writable);
  jf.prototype._write = function(e, r, n) {
    this._hash.update(e), n();
  };
  jf.prototype.update = function(e, r) {
    return typeof e == "string" && (e = pa.from(e, r)), this._hash.update(e), this;
  };
  jf.prototype.verify = function(e, r, n) {
    typeof r == "string" && (r = pa.from(r, n)), this.end();
    var i = this._hash.digest();
    return d8(r, i, e, this._signType, this._tag);
  };
  function Pl(t) {
    return new Kf(t);
  }
  function Tl(t) {
    return new jf(t);
  }
  Ll.exports = { Sign: Pl, Verify: Tl, createSign: Pl, createVerify: Tl };
});
var Ul = k2((l7, zl) => {
  var c8 = fa(), l8 = Fe();
  zl.exports = function(e) {
    return new Ii(e);
  };
  var dt = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  dt.p224 = dt.secp224r1;
  dt.p256 = dt.secp256r1 = dt.prime256v1;
  dt.p192 = dt.secp192r1 = dt.prime192v1;
  dt.p384 = dt.secp384r1;
  dt.p521 = dt.secp521r1;
  function Ii(t) {
    this.curveType = dt[t], this.curveType || (this.curveType = { name: t }), this.curve = new c8.ec(this.curveType.name), this.keys = void 0;
  }
  Ii.prototype.generateKeys = function(t, e) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
  };
  Ii.prototype.computeSecret = function(t, e, r) {
    e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e));
    var n = this.curve.keyFromPublic(t).getPublic(), i = n.mul(this.keys.getPrivate()).getX();
    return Bs(i, r, this.curveType.byteLength);
  };
  Ii.prototype.getPublicKey = function(t, e) {
    var r = this.keys.getPublic(e === "compressed", true);
    return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), Bs(r, t);
  };
  Ii.prototype.getPrivateKey = function(t) {
    return Bs(this.keys.getPrivate(), t);
  };
  Ii.prototype.setPublicKey = function(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this.keys._importPublic(t), this;
  };
  Ii.prototype.setPrivateKey = function(t, e) {
    e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e));
    var r = new l8(t);
    return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
  };
  function Bs(t, e, r) {
    Array.isArray(t) || (t = t.toArray());
    var n = new Buffer3(t);
    if (r && n.length < r) {
      var i = new Buffer3(r - n.length);
      i.fill(0), n = Buffer3.concat([i, n]);
    }
    return e ? n.toString(e) : n;
  }
});
var Is = k2((v7, Hl) => {
  var v8 = Ni(), Rs = Ae().Buffer;
  Hl.exports = function(t, e) {
    for (var r = Rs.alloc(0), n = 0, i; r.length < e; )
      i = p8(n++), r = Rs.concat([r, v8("sha1").update(t).update(i).digest()]);
    return r.slice(0, e);
  };
  function p8(t) {
    var e = Rs.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e;
  }
});
var ks = k2((p7, Fl) => {
  Fl.exports = function(e, r) {
    for (var n = e.length, i = -1; ++i < n; )
      e[i] ^= r[i];
    return e;
  };
});
var Ds = k2((b7, jl) => {
  var Kl = Fe(), b8 = Ae().Buffer;
  function m8(t, e) {
    return b8.from(t.toRed(Kl.mont(e.modulus)).redPow(new Kl(e.publicExponent)).fromRed().toArray());
  }
  jl.exports = m8;
});
var Gl = k2((m7, Zl) => {
  var g8 = Hf(), Ps = fi(), y8 = Ni(), Wl = Is(), Vl = ks(), Ts = Fe(), _8 = Ds(), w8 = Hn(), Qt = Ae().Buffer;
  Zl.exports = function(e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var o = g8(e), p;
    if (i === 4)
      p = x8(o, r);
    else if (i === 1)
      p = M8(o, r, n);
    else if (i === 3) {
      if (p = new Ts(r), p.cmp(o.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return n ? w8(p, o) : _8(p, o);
  };
  function x8(t, e) {
    var r = t.modulus.byteLength(), n = e.length, i = y8("sha1").update(Qt.alloc(0)).digest(), o = i.length, p = 2 * o;
    if (n > r - p - 2)
      throw new Error("message too long");
    var y = Qt.alloc(r - n - p - 2), w = r - o - 1, x = Ps(o), M = Vl(Qt.concat([i, y, Qt.alloc(1, 1), e], w), Wl(x, w)), E = Vl(x, Wl(M, o));
    return new Ts(Qt.concat([Qt.alloc(1), E, M], r));
  }
  function M8(t, e, r) {
    var n = e.length, i = t.modulus.byteLength();
    if (n > i - 11)
      throw new Error("message too long");
    var o;
    return r ? o = Qt.alloc(i - n - 3, 255) : o = S8(i - n - 3), new Ts(Qt.concat([Qt.from([0, r ? 1 : 2]), o, Qt.alloc(1), e], i));
  }
  function S8(t) {
    for (var e = Qt.allocUnsafe(t), r = 0, n = Ps(t * 2), i = 0, o; r < t; )
      i === n.length && (n = Ps(t * 2), i = 0), o = n[i++], o && (e[r++] = o);
    return e;
  }
});
var Ql = k2((g7, $l) => {
  var E8 = Hf(), Xl = Is(), Yl = ks(), Jl = Fe(), A8 = Hn(), q8 = Ni(), B8 = Ds(), Wf = Ae().Buffer;
  $l.exports = function(e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var o = E8(e), p = o.modulus.byteLength();
    if (r.length > p || new Jl(r).cmp(o.modulus) >= 0)
      throw new Error("decryption error");
    var y;
    n ? y = B8(new Jl(r), o) : y = A8(r, o);
    var w = Wf.alloc(p - y.length);
    if (y = Wf.concat([w, y], p), i === 4)
      return R8(o, y);
    if (i === 1)
      return I8(o, y, n);
    if (i === 3)
      return y;
    throw new Error("unknown padding");
  };
  function R8(t, e) {
    var r = t.modulus.byteLength(), n = q8("sha1").update(Wf.alloc(0)).digest(), i = n.length;
    if (e[0] !== 0)
      throw new Error("decryption error");
    var o = e.slice(1, i + 1), p = e.slice(i + 1), y = Yl(o, Xl(p, i)), w = Yl(p, Xl(y, r - i - 1));
    if (k8(n, w.slice(0, i)))
      throw new Error("decryption error");
    for (var x = i; w[x] === 0; )
      x++;
    if (w[x++] !== 1)
      throw new Error("decryption error");
    return w.slice(x);
  }
  function I8(t, e, r) {
    for (var n = e.slice(0, 2), i = 2, o = 0; e[i++] !== 0; )
      if (i >= e.length) {
        o++;
        break;
      }
    var p = e.slice(2, i - 1);
    if ((n.toString("hex") !== "0002" && !r || n.toString("hex") !== "0001" && r) && o++, p.length < 8 && o++, o)
      throw new Error("decryption error");
    return e.slice(i);
  }
  function k8(t, e) {
    t = Wf.from(t), e = Wf.from(e);
    var r = 0, n = t.length;
    t.length !== e.length && (r++, n = Math.min(t.length, e.length));
    for (var i = -1; ++i < n; )
      r += t[i] ^ e[i];
    return r;
  }
});
var e1 = k2((ki) => {
  ki.publicEncrypt = Gl();
  ki.privateDecrypt = Ql();
  ki.privateEncrypt = function(e, r) {
    return ki.publicEncrypt(e, r, true);
  };
  ki.publicDecrypt = function(e, r) {
    return ki.privateDecrypt(e, r, true);
  };
});
var u1 = k2((Vf) => {
  "use strict";
  function t1() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var i1 = Ae(), r1 = fi(), f1 = i1.Buffer, n1 = i1.kMaxLength, Cs = __global$.crypto || __global$.msCrypto, a1 = Math.pow(2, 32) - 1;
  function s1(t, e) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("offset must be a number");
    if (t > a1 || t < 0)
      throw new TypeError("offset must be a uint32");
    if (t > n1 || t > e)
      throw new RangeError("offset out of range");
  }
  function o1(t, e, r) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("size must be a number");
    if (t > a1 || t < 0)
      throw new TypeError("size must be a uint32");
    if (t + e > r || t > n1)
      throw new RangeError("buffer too small");
  }
  Cs && Cs.getRandomValues || !process_default.browser ? (Vf.randomFill = D8, Vf.randomFillSync = P8) : (Vf.randomFill = t1, Vf.randomFillSync = t1);
  function D8(t, e, r, n) {
    if (!f1.isBuffer(t) && !(t instanceof __global$.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function")
      n = e, e = 0, r = t.length;
    else if (typeof r == "function")
      n = r, r = t.length - e;
    else if (typeof n != "function")
      throw new TypeError('"cb" argument must be a function');
    return s1(e, t.length), o1(r, e, t.length), h1(t, e, r, n);
  }
  function h1(t, e, r, n) {
    if (process_default.browser) {
      var i = t.buffer, o = new Uint8Array(i, e, r);
      if (Cs.getRandomValues(o), n) {
        process_default.nextTick(function() {
          n(null, t);
        });
        return;
      }
      return t;
    }
    if (n) {
      r1(r, function(y, w) {
        if (y)
          return n(y);
        w.copy(t, e), n(null, t);
      });
      return;
    }
    var p = r1(r);
    return p.copy(t, e), t;
  }
  function P8(t, e, r) {
    if (typeof e > "u" && (e = 0), !f1.isBuffer(t) && !(t instanceof __global$.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return s1(e, t.length), r === void 0 && (r = t.length - e), o1(r, e, t.length), h1(t, e, r);
  }
});
var Ns = k2((Se) => {
  "use strict";
  Se.randomBytes = Se.rng = Se.pseudoRandomBytes = Se.prng = fi();
  Se.createHash = Se.Hash = Ni();
  Se.createHmac = Se.Hmac = t0();
  var T8 = Bh(), C8 = Object.keys(T8), N8 = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(C8);
  Se.getHashes = function() {
    return N8;
  };
  var d1 = d0();
  Se.pbkdf2 = d1.pbkdf2;
  Se.pbkdf2Sync = d1.pbkdf2Sync;
  var ur = Yu();
  Se.Cipher = ur.Cipher;
  Se.createCipher = ur.createCipher;
  Se.Cipheriv = ur.Cipheriv;
  Se.createCipheriv = ur.createCipheriv;
  Se.Decipher = ur.Decipher;
  Se.createDecipher = ur.createDecipher;
  Se.Decipheriv = ur.Decipheriv;
  Se.createDecipheriv = ur.createDecipheriv;
  Se.getCiphers = ur.getCiphers;
  Se.listCiphers = ur.listCiphers;
  var Zf = hd();
  Se.DiffieHellmanGroup = Zf.DiffieHellmanGroup;
  Se.createDiffieHellmanGroup = Zf.createDiffieHellmanGroup;
  Se.getDiffieHellman = Zf.getDiffieHellman;
  Se.createDiffieHellman = Zf.createDiffieHellman;
  Se.DiffieHellman = Zf.DiffieHellman;
  var ma = Ol();
  Se.createSign = ma.createSign;
  Se.Sign = ma.Sign;
  Se.createVerify = ma.createVerify;
  Se.Verify = ma.Verify;
  Se.createECDH = Ul();
  var ga = e1();
  Se.publicEncrypt = ga.publicEncrypt;
  Se.privateEncrypt = ga.privateEncrypt;
  Se.publicDecrypt = ga.publicDecrypt;
  Se.privateDecrypt = ga.privateDecrypt;
  var c1 = u1();
  Se.randomFill = c1.randomFill;
  Se.randomFillSync = c1.randomFillSync;
  Se.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  };
  Se.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
});
var l1 = Os(Ns());
var v1 = Os(Ns());
var { randomBytes: x7, rng: M7, pseudoRandomBytes: S7, prng: E7, createHash: A7, Hash: q7, createHmac: B7, Hmac: R7, getHashes: I7, pbkdf2: k7, pbkdf2Sync: D7, Cipher: P7, createCipher: T7, Cipheriv: C7, createCipheriv: N7, Decipher: L7, createDecipher: O7, Decipheriv: z7, createDecipheriv: U7, getCiphers: H7, listCiphers: F7, DiffieHellmanGroup: K7, createDiffieHellmanGroup: j7, getDiffieHellman: W7, createDiffieHellman: V7, DiffieHellman: Z7, createSign: G7, Sign: X7, createVerify: Y7, Verify: J7, createECDH: $7, publicEncrypt: Q7, privateEncrypt: e9, publicDecrypt: t9, privateDecrypt: r9, randomFill: i9, randomFillSync: f9, createCredentials: n9, constants: a9 } = v1;
var { default: L8, ...O8 } = v1;
var s9 = l1.default ?? L8 ?? O8;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/crypto.ts
var crypto_default2 = crypto_browserify_bundle_exports;

// deno:https://deno.land/std@0.141.0/node/internal/error_codes.ts
var codes2 = {};

// deno:https://deno.land/std@0.141.0/node/internal_binding/types.ts
var types_exports3 = {};
__export(types_exports3, {
  default: () => types_default3,
  isAnyArrayBuffer: () => isAnyArrayBuffer3,
  isArgumentsObject: () => isArgumentsObject3,
  isArrayBuffer: () => isArrayBuffer3,
  isAsyncFunction: () => isAsyncFunction3,
  isBigIntObject: () => isBigIntObject3,
  isBooleanObject: () => isBooleanObject3,
  isBoxedPrimitive: () => isBoxedPrimitive3,
  isDataView: () => isDataView3,
  isDate: () => isDate4,
  isGeneratorFunction: () => isGeneratorFunction3,
  isGeneratorObject: () => isGeneratorObject3,
  isMap: () => isMap3,
  isMapIterator: () => isMapIterator3,
  isModuleNamespaceObject: () => isModuleNamespaceObject3,
  isNativeError: () => isNativeError3,
  isNumberObject: () => isNumberObject3,
  isPromise: () => isPromise3,
  isRegExp: () => isRegExp4,
  isSet: () => isSet3,
  isSetIterator: () => isSetIterator3,
  isSharedArrayBuffer: () => isSharedArrayBuffer3,
  isStringObject: () => isStringObject3,
  isSymbolObject: () => isSymbolObject3,
  isWeakMap: () => isWeakMap3,
  isWeakSet: () => isWeakSet3
});
var _toString3 = Object.prototype.toString;
var _isObjectLike3 = (value) => value !== null && typeof value === "object";
var _isFunctionLike2 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer3(value) {
  return _isObjectLike3(value) && (_toString3.call(value) === "[object ArrayBuffer]" || _toString3.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Arguments]";
}
function isArrayBuffer3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction3(value) {
  return _isFunctionLike2(value) && _toString3.call(value) === "[object AsyncFunction]";
}
function isBooleanObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Boolean]";
}
function isBoxedPrimitive3(value) {
  return isBooleanObject3(value) || isStringObject3(value) || isNumberObject3(value) || isSymbolObject3(value) || isBigIntObject3(value);
}
function isDataView3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object DataView]";
}
function isDate4(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Date]";
}
function isGeneratorFunction3(value) {
  return _isFunctionLike2(value) && _toString3.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Generator]";
}
function isMap3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Map]";
}
function isMapIterator3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Module]";
}
function isNativeError3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Error]";
}
function isNumberObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Number]";
}
function isBigIntObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object BigInt]";
}
function isPromise3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Promise]";
}
function isRegExp4(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object RegExp]";
}
function isSet3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Set]";
}
function isSetIterator3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object String]";
}
function isSymbolObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Symbol]";
}
function isWeakMap3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object WeakMap]";
}
function isWeakSet3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object WeakSet]";
}
var types_default3 = {
  isAsyncFunction: isAsyncFunction3,
  isGeneratorFunction: isGeneratorFunction3,
  isAnyArrayBuffer: isAnyArrayBuffer3,
  isArrayBuffer: isArrayBuffer3,
  isArgumentsObject: isArgumentsObject3,
  isBoxedPrimitive: isBoxedPrimitive3,
  isDataView: isDataView3,
  isMap: isMap3,
  isMapIterator: isMapIterator3,
  isModuleNamespaceObject: isModuleNamespaceObject3,
  isNativeError: isNativeError3,
  isPromise: isPromise3,
  isSet: isSet3,
  isSetIterator: isSetIterator3,
  isWeakMap: isWeakMap3,
  isWeakSet: isWeakSet3,
  isRegExp: isRegExp4,
  isDate: isDate4,
  isStringObject: isStringObject3,
  isNumberObject: isNumberObject3,
  isBooleanObject: isBooleanObject3,
  isBigIntObject: isBigIntObject3
};

// deno:https://deno.land/std@0.141.0/node/internal/crypto/constants.ts
var kHandle2 = Symbol("kHandle");
var kKeyObject2 = Symbol("kKeyObject");

// deno:https://deno.land/std@0.141.0/node/internal/crypto/_keys.ts
var kKeyType2 = Symbol("kKeyType");

// deno:https://deno.land/std@0.141.0/node/internal/util/types.ts
var _toString4 = Object.prototype.toString;
var _isObjectLike4 = (value) => value !== null && typeof value === "object";
function isArrayBufferView2(value) {
  return ArrayBuffer.isView(value);
}
function isUint8Array2(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Uint8Array]";
}
var {
  isDate: isDate5,
  isArgumentsObject: isArgumentsObject4,
  isBigIntObject: isBigIntObject4,
  isBooleanObject: isBooleanObject4,
  isNumberObject: isNumberObject4,
  isStringObject: isStringObject4,
  isSymbolObject: isSymbolObject4,
  isNativeError: isNativeError4,
  isRegExp: isRegExp5,
  isAsyncFunction: isAsyncFunction4,
  isGeneratorFunction: isGeneratorFunction4,
  isGeneratorObject: isGeneratorObject4,
  isPromise: isPromise4,
  isMap: isMap4,
  isSet: isSet4,
  isMapIterator: isMapIterator4,
  isSetIterator: isSetIterator4,
  isWeakMap: isWeakMap4,
  isWeakSet: isWeakSet4,
  isArrayBuffer: isArrayBuffer4,
  isDataView: isDataView4,
  isSharedArrayBuffer: isSharedArrayBuffer4,
  isModuleNamespaceObject: isModuleNamespaceObject4,
  isAnyArrayBuffer: isAnyArrayBuffer4,
  isBoxedPrimitive: isBoxedPrimitive4
} = types_exports3;

// deno:https://deno.land/std@0.141.0/node/internal/hide_stack_frames.ts
function hideStackFrames2(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}

// deno:https://deno.land/std@0.141.0/node/internal/normalize_encoding.mjs
function normalizeEncoding4(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases3(enc);
}
function slowCases3(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.141.0/node/internal/validators.mjs
function isInt322(value) {
  return value === (value | 0);
}
function isUint322(value) {
  return value === value >>> 0;
}
var validateBuffer2 = hideStackFrames2((buffer, name = "buffer") => {
  if (!isArrayBufferView2(buffer)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
  }
});
var validateInteger2 = hideStackFrames2((value, name, min4 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateObject2 = hideStackFrames2((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt322 = hideStackFrames2((value, name, min4 = -2147483648, max2 = 2147483647) => {
  if (!isInt322(value)) {
    if (typeof value !== "number") {
      throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
  if (value < min4 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateUint322 = hideStackFrames2((value, name, positive) => {
  if (!isUint322(value)) {
    if (typeof value !== "number") {
      throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min4 = positive ? 1 : 0;
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes2.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
var validateOneOf2 = hideStackFrames2((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v) => typeof v === "string" ? `'${v}'` : String(v)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback2 = hideStackFrames2((callback) => {
  if (typeof callback !== "function") {
    throw new codes2.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal3 = hideStackFrames2((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction2 = hideStackFrames2((value, name) => {
  if (typeof value !== "function") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
var validateArray2 = hideStackFrames2((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// deno:https://deno.land/std@0.141.0/node/internal/util.mjs
var customInspectSymbol4 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty2 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty2.enumerable = true;
var kCustomPromisifiedSymbol2 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol2 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify2(original) {
  validateFunction2(original, "original");
  if (original[kCustomPromisifiedSymbol2]) {
    const fn2 = original[kCustomPromisifiedSymbol2];
    validateFunction2(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol2, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol2];
  function fn(...args) {
    return new Promise((resolve7, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve7(obj2);
        } else {
          resolve7(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify2.custom = kCustomPromisifiedSymbol2;

// deno:https://deno.land/std@0.141.0/node/internal_binding/_node.ts
var Encodings2 = /* @__PURE__ */ ((Encodings4) => {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
  return Encodings4;
})(Encodings2 || {});

// deno:https://deno.land/std@0.141.0/node/internal_binding/string_decoder.ts
var encodings2 = [];
encodings2[0 /* ASCII */] = "ascii";
encodings2[2 /* BASE64 */] = "base64";
encodings2[7 /* BASE64URL */] = "base64url";
encodings2[6 /* BUFFER */] = "buffer";
encodings2[5 /* HEX */] = "hex";
encodings2[4 /* LATIN1 */] = "latin1";
encodings2[3 /* UCS2 */] = "utf16le";
encodings2[1 /* UTF8 */] = "utf8";

// deno:https://deno.land/std@0.141.0/bytes/mod.ts
function indexOfNeedle2(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s)
      continue;
    const pin = i;
    let matched = 1;
    let j = i;
    while (matched < needle.length) {
      j++;
      if (source[j] !== needle[j - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}

// deno:https://deno.land/std@0.141.0/node/internal_binding/buffer.ts
function numberToBytes2(n) {
  if (n === 0)
    return new Uint8Array([0]);
  const bytes = [];
  bytes.unshift(n & 255);
  while (n >= 256) {
    n = n >>> 8;
    bytes.unshift(n & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex2(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x = 0; x <= searchableBufferLastIndex; x++) {
    if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer2(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings2[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex2(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle2(targetBuffer, buffer, byteOffset);
}
function indexOfNumber2(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes2(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer2(targetBuffer, numberToBytes2(number), byteOffset, 1 /* UTF8 */, forwardDirection);
}

// deno:https://deno.land/std@0.141.0/encoding/base64.ts
var base64abc2 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode9(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc2[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc2[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc2[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode7(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.141.0/encoding/base64url.ts
function addPaddingToBase64url2(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase642(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url2(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url2(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode10(data) {
  return convertBase64ToBase64url2(encode9(data));
}
function decode8(b64url) {
  return decode7(convertBase64urlToBase642(b64url));
}

// deno:https://deno.land/std@0.141.0/node/internal_binding/_utils.ts
function asciiToBytes2(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes2(str) {
  str = base64clean2(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode7(str);
}
var INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes2(str) {
  str = base64clean2(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode8(str);
}
function hexToBytes2(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a = Number.parseInt(str[i * 2], 16);
    const b = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a) && Number.isNaN(b)) {
      break;
    }
    byteArray[i] = a << 4 | b;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes2(str, units) {
  let c, hi, lo2;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo2 = c % 256;
    byteArray.push(lo2);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii2(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le2(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

// deno:https://deno.land/std@0.141.0/node/internal/buffer.mjs
var utf8Encoder2 = new TextEncoder();
var float32Array2 = new Float32Array(1);
var uInt8Float32Array2 = new Uint8Array(float32Array2.buffer);
var float64Array2 = new Float64Array(1);
var uInt8Float64Array2 = new Uint8Array(float64Array2.buffer);
float32Array2[0] = -1;
var bigEndian2 = uInt8Float32Array2[3] === 0;
function readUInt48LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 8);
  }
  uInt8Float64Array2[7] = first;
  uInt8Float64Array2[6] = buffer[++offset];
  uInt8Float64Array2[5] = buffer[++offset];
  uInt8Float64Array2[4] = buffer[++offset];
  uInt8Float64Array2[3] = buffer[++offset];
  uInt8Float64Array2[2] = buffer[++offset];
  uInt8Float64Array2[1] = buffer[++offset];
  uInt8Float64Array2[0] = last;
  return float64Array2[0];
}
function readDoubleForwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 8);
  }
  uInt8Float64Array2[0] = first;
  uInt8Float64Array2[1] = buffer[++offset];
  uInt8Float64Array2[2] = buffer[++offset];
  uInt8Float64Array2[3] = buffer[++offset];
  uInt8Float64Array2[4] = buffer[++offset];
  uInt8Float64Array2[5] = buffer[++offset];
  uInt8Float64Array2[6] = buffer[++offset];
  uInt8Float64Array2[7] = last;
  return float64Array2[0];
}
function writeDoubleForwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 7);
  float64Array2[0] = val;
  buffer[offset++] = uInt8Float64Array2[0];
  buffer[offset++] = uInt8Float64Array2[1];
  buffer[offset++] = uInt8Float64Array2[2];
  buffer[offset++] = uInt8Float64Array2[3];
  buffer[offset++] = uInt8Float64Array2[4];
  buffer[offset++] = uInt8Float64Array2[5];
  buffer[offset++] = uInt8Float64Array2[6];
  buffer[offset++] = uInt8Float64Array2[7];
  return offset;
}
function writeDoubleBackwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 7);
  float64Array2[0] = val;
  buffer[offset++] = uInt8Float64Array2[7];
  buffer[offset++] = uInt8Float64Array2[6];
  buffer[offset++] = uInt8Float64Array2[5];
  buffer[offset++] = uInt8Float64Array2[4];
  buffer[offset++] = uInt8Float64Array2[3];
  buffer[offset++] = uInt8Float64Array2[2];
  buffer[offset++] = uInt8Float64Array2[1];
  buffer[offset++] = uInt8Float64Array2[0];
  return offset;
}
function readFloatBackwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 4);
  }
  uInt8Float32Array2[3] = first;
  uInt8Float32Array2[2] = buffer[++offset];
  uInt8Float32Array2[1] = buffer[++offset];
  uInt8Float32Array2[0] = last;
  return float32Array2[0];
}
function readFloatForwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 4);
  }
  uInt8Float32Array2[0] = first;
  uInt8Float32Array2[1] = buffer[++offset];
  uInt8Float32Array2[2] = buffer[++offset];
  uInt8Float32Array2[3] = last;
  return float32Array2[0];
}
function writeFloatForwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 3);
  float32Array2[0] = val;
  buffer[offset++] = uInt8Float32Array2[0];
  buffer[offset++] = uInt8Float32Array2[1];
  buffer[offset++] = uInt8Float32Array2[2];
  buffer[offset++] = uInt8Float32Array2[3];
  return offset;
}
function writeFloatBackwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 3);
  float32Array2[0] = val;
  buffer[offset++] = uInt8Float32Array2[3];
  buffer[offset++] = uInt8Float32Array2[2];
  buffer[offset++] = uInt8Float32Array2[1];
  buffer[offset++] = uInt8Float32Array2[0];
  return offset;
}
function readInt24LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf82(str) {
  return utf8Encoder2.encode(str).length;
}
function base64ByteLength2(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap2 = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings2.length; ++i) {
  encodingsMap2[encodings2[i]] = i;
}
var encodingOps2 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap2.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength2(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap2.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, base64ToBytes2(val), byteOffset, encodingsMap2.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength2(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap2.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, base64UrlToBytes2(val), byteOffset, encodingsMap2.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap2.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, hexToBytes2(val), byteOffset, encodingsMap2.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap2.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap2.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf82,
    encoding: "utf8",
    encodingVal: encodingsMap2.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf8Encoder2.encode(val), byteOffset, encodingsMap2.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap2.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps2(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps2.utf8;
      if (encoding === "ucs2")
        return encodingOps2.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps2.utf8;
      if (encoding === "ascii")
        return encodingOps2.ascii;
      if (encoding === "ucs-2")
        return encodingOps2.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps2.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps2.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps2.latin1;
      }
      if (encoding === "base64")
        return encodingOps2.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps2.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps2.base64url;
      }
      break;
  }
}
function _copyActual2(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError2(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber2(value, type);
    throw new codes2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber2(value, name) {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds3(buf, offset, byteLength6) {
  validateNumber2(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength6] === void 0) {
    boundsError2(offset, buf.length - (byteLength6 + 1));
  }
}
function checkInt2(value, min4, max2, buf, offset, byteLength6) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength6 > 3) {
      if (min4 === 0 || min4 === 0n) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength6 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds3(buf, offset, byteLength6);
}
function toInteger2(n, defaultVal) {
  n = +n;
  if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
    return n % 1 === 0 ? n : Math.floor(n);
  }
  return defaultVal;
}
function writeU_Int82(buf, value, offset, min4, max2) {
  value = +value;
  validateNumber2(offset, "offset");
  if (value > max2 || value < min4) {
    throw new codes2.ERR_OUT_OF_RANGE("value", `>= ${min4} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError2(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset2(value, name, min4 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
}
function writeU_Int48LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}

// deno:https://deno.land/std@0.141.0/node/_buffer.mjs
var kMaxLength2 = 2147483647;
var MAX_UINT323 = 2 ** 32;
var customInspectSymbol5 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES2 = 50;
Object.defineProperty(Buffer4.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer4.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer4.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer4.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer2(length) {
  if (length > kMaxLength2) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer4.prototype);
  return buf;
}
function Buffer4(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes2.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe2(arg);
  }
  return _from3(arg, encodingOrOffset, length);
}
Buffer4.poolSize = 8192;
function _from3(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString2(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer4(value)) {
      return fromArrayBuffer2(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from3(valueOf, encodingOrOffset, length);
    }
    const b = fromObject2(value);
    if (b) {
      return b;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString2(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes2.ERR_INVALID_ARG_TYPE("first argument", ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"], value);
}
Buffer4.from = function from2(value, encodingOrOffset, length) {
  return _from3(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer4, Uint8Array);
function assertSize3(size) {
  validateNumber2(size, "size");
  if (!(size >= 0 && size <= kMaxLength2)) {
    throw new codes2.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc2(size, fill5, encoding) {
  assertSize3(size);
  const buffer = createBuffer2(size);
  if (fill5 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes2.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill5, encoding);
  }
  return buffer;
}
Buffer4.alloc = function alloc2(size, fill5, encoding) {
  return _alloc2(size, fill5, encoding);
};
function _allocUnsafe2(size) {
  assertSize3(size);
  return createBuffer2(size < 0 ? 0 : checked2(size) | 0);
}
Buffer4.allocUnsafe = function allocUnsafe2(size) {
  return _allocUnsafe2(size);
};
Buffer4.allocUnsafeSlow = function allocUnsafeSlow2(size) {
  return _allocUnsafe2(size);
};
function fromString2(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength3(string, encoding) | 0;
  let buf = createBuffer2(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike2(array) {
  const length = array.length < 0 ? 0 : checked2(array.length) | 0;
  const buf = createBuffer2(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject2(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer4(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer2(0);
    }
    return fromArrayLike2(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike2(obj2.data);
  }
}
function checked2(length) {
  if (length >= kMaxLength2) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2.toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer2(length) {
  assertSize3(length);
  return Buffer4.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer2, Uint8Array);
Buffer4.isBuffer = function isBuffer3(b) {
  return b != null && b._isBuffer === true && b !== Buffer4.prototype;
};
Buffer4.compare = function compare4(a, b) {
  if (isInstance2(a, Uint8Array)) {
    a = Buffer4.from(a, a.offset, a.byteLength);
  }
  if (isInstance2(b, Uint8Array)) {
    b = Buffer4.from(b, b.offset, b.byteLength);
  }
  if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) {
    return 0;
  }
  let x = a.length;
  let y = b.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
};
Buffer4.isEncoding = function isEncoding2(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding4(encoding) !== void 0;
};
Buffer4.concat = function concat3(list, length) {
  if (!Array.isArray(list)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset2(length, "length");
  }
  const buffer = Buffer4.allocUnsafe(length);
  let pos = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    if (!isUint8Array2(buf)) {
      throw new codes2.ERR_INVALID_ARG_TYPE(`list[${i}]`, ["Buffer", "Uint8Array"], list[i]);
    }
    pos += _copyActual2(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength3(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView2(string) || isAnyArrayBuffer4(string)) {
      return string.byteLength;
    }
    throw new codes2.ERR_INVALID_ARG_TYPE("string", ["string", "Buffer", "ArrayBuffer"], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf82(string);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf82(string);
  }
  return ops.byteLength(string);
}
Buffer4.byteLength = byteLength3;
Buffer4.prototype._isBuffer = true;
function swap2(b, n, m) {
  const i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer4.prototype.swap16 = function swap162() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap2(this, i, i + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap322() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap2(this, i, i + 3);
    swap2(this, i + 1, i + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap642() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap2(this, i, i + 7);
    swap2(this, i + 1, i + 6);
    swap2(this, i + 2, i + 5);
    swap2(this, i + 3, i + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString3(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
Buffer4.prototype.equals = function equals4(b) {
  if (!isUint8Array2(b)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("otherBuffer", ["Buffer", "Uint8Array"], b);
  }
  if (this === b) {
    return true;
  }
  return Buffer4.compare(this, b) === 0;
};
Buffer4.prototype.inspect = function inspect4() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES2;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol5) {
  Buffer4.prototype[customInspectSymbol5] = Buffer4.prototype.inspect;
}
Buffer4.prototype.compare = function compare5(target, start, end, thisStart, thisEnd) {
  if (isInstance2(target, Uint8Array)) {
    target = Buffer4.from(target, target.offset, target.byteLength);
  }
  if (!Buffer4.isBuffer(target)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset2(start, "targetStart", 0, kMaxLength2);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset2(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset2(start, "sourceStart", 0, kMaxLength2);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset2(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes2.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x = thisEnd - thisStart;
  let y = end - start;
  const len = Math.min(x, y);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  validateBuffer2(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber2(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps2.utf8;
  } else {
    ops = getEncodingOps2(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array2(val)) {
    const encodingVal = ops === void 0 ? encodingsMap2.utf8 : ops.encodingVal;
    return indexOfBuffer2(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes2.ERR_INVALID_ARG_TYPE("value", ["number", "string", "Buffer", "Uint8Array"], val);
}
Buffer4.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
Buffer4.prototype.asciiSlice = function asciiSlice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii2(this);
  } else {
    return bytesToAscii2(this.slice(offset, length));
  }
};
Buffer4.prototype.asciiWrite = function asciiWrite2(string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer4.prototype.base64Slice = function base64Slice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode9(this);
  } else {
    return encode9(this.slice(offset, length));
  }
};
Buffer4.prototype.base64Write = function base64Write2(string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), this, offset, length);
};
Buffer4.prototype.base64urlSlice = function base64urlSlice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode10(this);
  } else {
    return encode10(this.slice(offset, length));
  }
};
Buffer4.prototype.base64urlWrite = function base64urlWrite2(string, offset, length) {
  return blitBuffer2(base64UrlToBytes2(string), this, offset, length);
};
Buffer4.prototype.hexWrite = function hexWrite2(string, offset, length) {
  return blitBuffer2(hexToBytes2(string, this.length - offset), this, offset, length);
};
Buffer4.prototype.hexSlice = function hexSlice3(string, offset, length) {
  return _hexSlice2(this, string, offset, length);
};
Buffer4.prototype.latin1Slice = function latin1Slice2(string, offset, length) {
  return _latin1Slice2(this, string, offset, length);
};
Buffer4.prototype.latin1Write = function latin1Write2(string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer4.prototype.ucs2Slice = function ucs2Slice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le2(this);
  } else {
    return bytesToUtf16le2(this.slice(offset, length));
  }
};
Buffer4.prototype.ucs2Write = function ucs2Write2(string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, this.length - offset), this, offset, length);
};
Buffer4.prototype.utf8Slice = function utf8Slice2(string, offset, length) {
  return _utf8Slice2(this, string, offset, length);
};
Buffer4.prototype.utf8Write = function utf8Write3(string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, this.length - offset), this, offset, length);
};
Buffer4.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset2(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset2(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer4.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer2(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer4.prototype);
  return buffer;
}
function _utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
  }
  return res;
}
function _latin1Slice2(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice2(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable2[buf[i]];
  }
  return out;
}
Buffer4.prototype.slice = function slice2(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer4.prototype);
  return newBuf;
};
Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48LE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40LE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24LE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48BE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40BE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24BE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt83(offset = 0) {
  validateNumber2(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError2(offset, this.length - 1);
  }
  return val;
};
Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = readUInt16BE2;
Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = readUInt32BE2;
Buffer4.prototype.readBigUint64LE = Buffer4.prototype.readBigUInt64LE = defineBigIntMethod2(function readBigUInt64LE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo2) + (BigInt(hi) << BigInt(32));
});
Buffer4.prototype.readBigUint64BE = Buffer4.prototype.readBigUInt64BE = defineBigIntMethod2(function readBigUInt64BE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo2);
});
Buffer4.prototype.readIntLE = function readIntLE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48LE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40LE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24LE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readIntBE = function readIntBE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48BE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40BE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24BE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readInt8 = function readInt82(offset = 0) {
  validateNumber2(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError2(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer4.prototype.readInt16LE = function readInt16LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer4.prototype.readInt16BE = function readInt16BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer4.prototype.readInt32LE = function readInt32LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer4.prototype.readInt32BE = function readInt32BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer4.prototype.readBigInt64LE = defineBigIntMethod2(function readBigInt64LE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer4.prototype.readBigInt64BE = defineBigIntMethod2(function readBigInt64BE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer4.prototype.readFloatLE = function readFloatLE2(offset) {
  return bigEndian2 ? readFloatBackwards2(this, offset) : readFloatForwards2(this, offset);
};
Buffer4.prototype.readFloatBE = function readFloatBE2(offset) {
  return bigEndian2 ? readFloatForwards2(this, offset) : readFloatBackwards2(this, offset);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE2(offset) {
  return bigEndian2 ? readDoubleBackwards2(this, offset) : readDoubleForwards2(this, offset);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE2(offset) {
  return bigEndian2 ? readDoubleForwards2(this, offset) : readDoubleBackwards2(this, offset);
};
Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE2(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE2(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE2(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE2(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE2(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, 0, 255);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE2(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE2(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE2(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE2(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE2(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, 0, 255);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt82(value, offset = 0) {
  return writeU_Int82(this, value, offset, 0, 255);
};
Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE2(value, offset = 0) {
  return writeU_Int16LE2(this, value, offset, 0, 65535);
};
Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE2(value, offset = 0) {
  return writeU_Int16BE2(this, value, offset, 0, 65535);
};
Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE2(value, offset = 0) {
  return _writeUInt32LE2(this, value, offset, 0, 4294967295);
};
Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE2(value, offset = 0) {
  return _writeUInt32BE2(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE2(buf, value, offset, min4, max2) {
  checkIntBI2(value, min4, max2, buf, offset, 7);
  let lo2 = Number(value & BigInt(4294967295));
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE2(buf, value, offset, min4, max2) {
  checkIntBI2(value, min4, max2, buf, offset, 7);
  let lo2 = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 6] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 5] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 4] = lo2;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer4.prototype.writeBigUint64LE = Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod2(function writeBigUInt64LE2(value, offset = 0) {
  return wrtBigUInt64LE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer4.prototype.writeBigUint64BE = Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod2(function writeBigUInt64BE2(value, offset = 0) {
  return wrtBigUInt64BE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer4.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE2(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE2(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE2(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE2(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE2(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, -128, 127);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE2(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE2(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE2(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE2(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE2(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, -128, 127);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeInt8 = function writeInt82(value, offset = 0) {
  return writeU_Int82(this, value, offset, -128, 127);
};
Buffer4.prototype.writeInt16LE = function writeInt16LE2(value, offset = 0) {
  return writeU_Int16LE2(this, value, offset, -32768, 32767);
};
Buffer4.prototype.writeInt16BE = function writeInt16BE2(value, offset = 0) {
  return writeU_Int16BE2(this, value, offset, -32768, 32767);
};
Buffer4.prototype.writeInt32LE = function writeInt32LE2(value, offset = 0) {
  return writeU_Int32LE2(this, value, offset, -2147483648, 2147483647);
};
Buffer4.prototype.writeInt32BE = function writeInt32BE2(value, offset = 0) {
  return writeU_Int32BE2(this, value, offset, -2147483648, 2147483647);
};
Buffer4.prototype.writeBigInt64LE = defineBigIntMethod2(function writeBigInt64LE2(value, offset = 0) {
  return wrtBigUInt64LE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer4.prototype.writeBigInt64BE = defineBigIntMethod2(function writeBigInt64BE2(value, offset = 0) {
  return wrtBigUInt64BE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer4.prototype.writeFloatLE = function writeFloatLE2(value, offset) {
  return bigEndian2 ? writeFloatBackwards2(this, value, offset) : writeFloatForwards2(this, value, offset);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE2(value, offset) {
  return bigEndian2 ? writeFloatForwards2(this, value, offset) : writeFloatBackwards2(this, value, offset);
};
Buffer4.prototype.writeDoubleLE = function writeDoubleLE2(value, offset) {
  return bigEndian2 ? writeDoubleBackwards2(this, value, offset) : writeDoubleForwards2(this, value, offset);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE2(value, offset) {
  return bigEndian2 ? writeDoubleForwards2(this, value, offset) : writeDoubleBackwards2(this, value, offset);
};
Buffer4.prototype.copy = function copy4(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array2(this)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("source", ["Buffer", "Uint8Array"], this);
  }
  if (!isUint8Array2(target)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger2(targetStart, 0);
    if (targetStart < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger2(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT323) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT323}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger2(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT323) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT323}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer4.prototype.fill = function fill2(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes2.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds4(buf, offset, byteLength22) {
  validateNumber2(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
    boundsError2(offset, buf.length - (byteLength22 + 1));
  }
}
function checkIntBI2(value, min4, max2, buf, offset, byteLength22) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength22 > 3) {
      if (min4 === 0 || min4 === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds4(buf, offset, byteLength22);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer2(src, dst, offset, byteLength6) {
  let i;
  const length = byteLength6 === void 0 ? src.length : byteLength6;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance2(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable2 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();
function defineBigIntMethod2(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined2 : fn;
}
function BufferBigIntNotDefined2() {
  throw new Error("BigInt not supported");
}
var atob3 = globalThis.atob;
var Blob3 = globalThis.Blob;
var btoa2 = globalThis.btoa;

// deno:https://deno.land/std@0.146.0/node/internal/error_codes.ts
var codes3 = {};

// deno:https://deno.land/std@0.146.0/node/internal/hide_stack_frames.ts
function hideStackFrames3(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}

// deno:https://deno.land/std@0.146.0/node/internal/util/types.ts
var types_exports5 = {};
__export(types_exports5, {
  isAnyArrayBuffer: () => isAnyArrayBuffer6,
  isArgumentsObject: () => isArgumentsObject6,
  isArrayBuffer: () => isArrayBuffer6,
  isArrayBufferView: () => isArrayBufferView3,
  isAsyncFunction: () => isAsyncFunction6,
  isBigInt64Array: () => isBigInt64Array2,
  isBigIntObject: () => isBigIntObject6,
  isBigUint64Array: () => isBigUint64Array2,
  isBooleanObject: () => isBooleanObject6,
  isBoxedPrimitive: () => isBoxedPrimitive6,
  isCryptoKey: () => isCryptoKey3,
  isDataView: () => isDataView6,
  isDate: () => isDate7,
  isFloat32Array: () => isFloat32Array2,
  isFloat64Array: () => isFloat64Array2,
  isGeneratorFunction: () => isGeneratorFunction6,
  isGeneratorObject: () => isGeneratorObject6,
  isInt16Array: () => isInt16Array2,
  isInt32Array: () => isInt32Array2,
  isInt8Array: () => isInt8Array2,
  isKeyObject: () => isKeyObject3,
  isMap: () => isMap6,
  isMapIterator: () => isMapIterator6,
  isModuleNamespaceObject: () => isModuleNamespaceObject6,
  isNativeError: () => isNativeError6,
  isNumberObject: () => isNumberObject6,
  isPromise: () => isPromise6,
  isRegExp: () => isRegExp7,
  isSet: () => isSet6,
  isSetIterator: () => isSetIterator6,
  isSharedArrayBuffer: () => isSharedArrayBuffer6,
  isStringObject: () => isStringObject6,
  isSymbolObject: () => isSymbolObject6,
  isTypedArray: () => isTypedArray2,
  isUint16Array: () => isUint16Array2,
  isUint32Array: () => isUint32Array2,
  isUint8Array: () => isUint8Array3,
  isUint8ClampedArray: () => isUint8ClampedArray2,
  isWeakMap: () => isWeakMap6,
  isWeakSet: () => isWeakSet6
});

// deno:https://deno.land/std@0.146.0/node/internal_binding/types.ts
var types_exports4 = {};
__export(types_exports4, {
  default: () => types_default4,
  isAnyArrayBuffer: () => isAnyArrayBuffer5,
  isArgumentsObject: () => isArgumentsObject5,
  isArrayBuffer: () => isArrayBuffer5,
  isAsyncFunction: () => isAsyncFunction5,
  isBigIntObject: () => isBigIntObject5,
  isBooleanObject: () => isBooleanObject5,
  isBoxedPrimitive: () => isBoxedPrimitive5,
  isDataView: () => isDataView5,
  isDate: () => isDate6,
  isGeneratorFunction: () => isGeneratorFunction5,
  isGeneratorObject: () => isGeneratorObject5,
  isMap: () => isMap5,
  isMapIterator: () => isMapIterator5,
  isModuleNamespaceObject: () => isModuleNamespaceObject5,
  isNativeError: () => isNativeError5,
  isNumberObject: () => isNumberObject5,
  isPromise: () => isPromise5,
  isRegExp: () => isRegExp6,
  isSet: () => isSet5,
  isSetIterator: () => isSetIterator5,
  isSharedArrayBuffer: () => isSharedArrayBuffer5,
  isStringObject: () => isStringObject5,
  isSymbolObject: () => isSymbolObject5,
  isWeakMap: () => isWeakMap5,
  isWeakSet: () => isWeakSet5
});
var _toString5 = Object.prototype.toString;
var _isObjectLike5 = (value) => value !== null && typeof value === "object";
var _isFunctionLike3 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer5(value) {
  return _isObjectLike5(value) && (_toString5.call(value) === "[object ArrayBuffer]" || _toString5.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Arguments]";
}
function isArrayBuffer5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction5(value) {
  return _isFunctionLike3(value) && _toString5.call(value) === "[object AsyncFunction]";
}
function isBooleanObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Boolean]";
}
function isBoxedPrimitive5(value) {
  return isBooleanObject5(value) || isStringObject5(value) || isNumberObject5(value) || isSymbolObject5(value) || isBigIntObject5(value);
}
function isDataView5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object DataView]";
}
function isDate6(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Date]";
}
function isGeneratorFunction5(value) {
  return _isFunctionLike3(value) && _toString5.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Generator]";
}
function isMap5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Map]";
}
function isMapIterator5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Module]";
}
function isNativeError5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Error]";
}
function isNumberObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Number]";
}
function isBigIntObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object BigInt]";
}
function isPromise5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Promise]";
}
function isRegExp6(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object RegExp]";
}
function isSet5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Set]";
}
function isSetIterator5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object String]";
}
function isSymbolObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Symbol]";
}
function isWeakMap5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object WeakMap]";
}
function isWeakSet5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object WeakSet]";
}
var types_default4 = {
  isAsyncFunction: isAsyncFunction5,
  isGeneratorFunction: isGeneratorFunction5,
  isAnyArrayBuffer: isAnyArrayBuffer5,
  isArrayBuffer: isArrayBuffer5,
  isArgumentsObject: isArgumentsObject5,
  isBoxedPrimitive: isBoxedPrimitive5,
  isDataView: isDataView5,
  isMap: isMap5,
  isMapIterator: isMapIterator5,
  isModuleNamespaceObject: isModuleNamespaceObject5,
  isNativeError: isNativeError5,
  isPromise: isPromise5,
  isSet: isSet5,
  isSetIterator: isSetIterator5,
  isWeakMap: isWeakMap5,
  isWeakSet: isWeakSet5,
  isRegExp: isRegExp6,
  isDate: isDate6,
  isStringObject: isStringObject5,
  isNumberObject: isNumberObject5,
  isBooleanObject: isBooleanObject5,
  isBigIntObject: isBigIntObject5
};

// deno:https://deno.land/std@0.146.0/node/internal/crypto/constants.ts
var kHandle3 = Symbol("kHandle");
var kKeyObject3 = Symbol("kKeyObject");

// deno:https://deno.land/std@0.146.0/node/internal/crypto/_keys.ts
var kKeyType3 = Symbol("kKeyType");
function isKeyObject3(obj2) {
  return obj2 != null && obj2[kKeyType3] !== void 0;
}
function isCryptoKey3(obj2) {
  return obj2 != null && obj2[kKeyObject3] !== void 0;
}

// deno:https://deno.land/std@0.146.0/node/internal/util/types.ts
var _toString6 = Object.prototype.toString;
var _isObjectLike6 = (value) => value !== null && typeof value === "object";
function isArrayBufferView3(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object BigUint64Array]";
}
function isFloat32Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Float32Array]";
}
function isFloat64Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Float64Array]";
}
function isInt8Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Int8Array]";
}
function isInt16Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Int16Array]";
}
function isInt32Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Int32Array]";
}
function isTypedArray2(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike6(value) && reTypedTag.test(_toString6.call(value));
}
function isUint8Array3(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint16Array]";
}
function isUint32Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint32Array]";
}
var {
  isDate: isDate7,
  isArgumentsObject: isArgumentsObject6,
  isBigIntObject: isBigIntObject6,
  isBooleanObject: isBooleanObject6,
  isNumberObject: isNumberObject6,
  isStringObject: isStringObject6,
  isSymbolObject: isSymbolObject6,
  isNativeError: isNativeError6,
  isRegExp: isRegExp7,
  isAsyncFunction: isAsyncFunction6,
  isGeneratorFunction: isGeneratorFunction6,
  isGeneratorObject: isGeneratorObject6,
  isPromise: isPromise6,
  isMap: isMap6,
  isSet: isSet6,
  isMapIterator: isMapIterator6,
  isSetIterator: isSetIterator6,
  isWeakMap: isWeakMap6,
  isWeakSet: isWeakSet6,
  isArrayBuffer: isArrayBuffer6,
  isDataView: isDataView6,
  isSharedArrayBuffer: isSharedArrayBuffer6,
  isModuleNamespaceObject: isModuleNamespaceObject6,
  isAnyArrayBuffer: isAnyArrayBuffer6,
  isBoxedPrimitive: isBoxedPrimitive6
} = types_exports4;

// deno:https://deno.land/std@0.146.0/node/internal/normalize_encoding.mjs
function normalizeEncoding5(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases4(enc);
}
function slowCases4(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.146.0/node/internal/validators.mjs
function isInt323(value) {
  return value === (value | 0);
}
function isUint323(value) {
  return value === value >>> 0;
}
var validateBuffer3 = hideStackFrames3((buffer, name = "buffer") => {
  if (!isArrayBufferView3(buffer)) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
  }
});
var validateInteger3 = hideStackFrames3((value, name, min4 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateObject3 = hideStackFrames3((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt323 = hideStackFrames3((value, name, min4 = -2147483648, max2 = 2147483647) => {
  if (!isInt323(value)) {
    if (typeof value !== "number") {
      throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
  if (value < min4 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateUint323 = hideStackFrames3((value, name, positive) => {
  if (!isUint323(value)) {
    if (typeof value !== "number") {
      throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min4 = positive ? 1 : 0;
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes3.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString3(value, name) {
  if (typeof value !== "string") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
var validateOneOf3 = hideStackFrames3((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v) => typeof v === "string" ? `'${v}'` : String(v)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback3 = hideStackFrames3((callback) => {
  if (typeof callback !== "function") {
    throw new codes3.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal4 = hideStackFrames3((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction3 = hideStackFrames3((value, name) => {
  if (typeof value !== "function") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
var validateArray3 = hideStackFrames3((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// deno:https://deno.land/std@0.146.0/node/internal/util.mjs
var customInspectSymbol6 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty3 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty3.enumerable = true;
var codesWarned2 = /* @__PURE__ */ new Set();
function deprecate2(fn, msg, code2) {
  if (code2 !== void 0) {
    validateString3(code2, "code");
  }
  let warned = false;
  function deprecated(...args) {
    if (!warned) {
      warned = true;
      if (code2 !== void 0) {
        if (!codesWarned2.has(code2)) {
          process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
          codesWarned2.add(code2);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args, new.target);
    }
    return Reflect.apply(fn, this, args);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol3 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol3 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify3(original) {
  validateFunction3(original, "original");
  if (original[kCustomPromisifiedSymbol3]) {
    const fn2 = original[kCustomPromisifiedSymbol3];
    validateFunction3(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol3, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol3];
  function fn(...args) {
    return new Promise((resolve7, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve7(obj2);
        } else {
          resolve7(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol3, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify3.custom = kCustomPromisifiedSymbol3;

// deno:https://deno.land/std@0.146.0/node/_core.ts
var core2;
if (Deno?.core) {
  core2 = Deno.core;
} else {
  core2 = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}

// deno:https://deno.land/std@0.146.0/node/_process/exiting.ts
var _exiting2 = false;

// deno:https://deno.land/std@0.146.0/node/internal/fixed_queue.ts
var kSize2 = 2048;
var kMask2 = kSize2 - 1;
var FixedCircularBuffer2 = class {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize2);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask2) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask2;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask2;
    return nextItem;
  }
};
var FixedQueue2 = class {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer2();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer2();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};

// deno:https://deno.land/std@0.146.0/node/_next_tick.ts
var queue2 = new FixedQueue2();
var _nextTick2;
if (typeof core2.setNextTickCallback !== "undefined") {
  let runNextTicks = function() {
    if (!core2.hasTickScheduled()) {
      core2.runMicrotasks();
    }
    if (!core2.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections();
    return true;
  }, processTicksAndRejections = function() {
    let tock;
    do {
      while (tock = queue2.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core2.runMicrotasks();
    } while (!queue2.isEmpty());
    core2.setHasTickScheduled(false);
  }, __nextTickNative = function(callback, ...args) {
    validateCallback3(callback);
    if (_exiting2) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [args[0]];
        break;
      case 2:
        args_ = [args[0], args[1]];
        break;
      case 3:
        args_ = [args[0], args[1], args[2]];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue2.isEmpty()) {
      core2.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue2.push(tickObject);
  };
  core2.setNextTickCallback(processTicksAndRejections);
  core2.setMacrotaskCallback(runNextTicks);
  _nextTick2 = __nextTickNative;
} else {
  let __nextTickQueueMicrotask = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  _nextTick2 = __nextTickQueueMicrotask;
}
function nextTick4(callback, ...args) {
  _nextTick2(callback, ...args);
}

// deno:https://deno.land/std@0.146.0/node/_util/_util_callbackify.ts
var NodeFalsyValueRejectionError2 = class extends Error {
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.code = "ERR_FALSY_VALUE_REJECTION";
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError2 = class extends TypeError {
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function callbackify2(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError2('"original"');
  }
  const callbackified = function(...args) {
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError2("last");
    }
    const cb = (...args2) => {
      maybeCb.apply(this, args2);
    };
    original.apply(this, args).then((ret) => {
      nextTick4(cb.bind(this, null, ret));
    }, (rej) => {
      rej = rej || new NodeFalsyValueRejectionError2(rej);
      nextTick4(cb.bind(this, rej));
    });
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}

// deno:https://deno.land/std@0.146.0/fmt/printf.ts
var Flags2 = class {
  constructor() {
    this.width = -1;
    this.precision = -1;
  }
};
var min3 = Math.min;
var UNICODE_REPLACEMENT_CHARACTER2 = "\uFFFD";
var DEFAULT_PRECISION2 = 6;
var FLOAT_REGEXP2 = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var Printf2 = class {
  constructor(format11, ...args) {
    this.state = 0 /* PASSTHROUGH */;
    this.verb = "";
    this.buf = "";
    this.argNum = 0;
    this.flags = new Flags2();
    this.format = format11;
    this.args = args;
    this.haveSeen = Array.from({ length: args.length });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c = this.format[this.i];
      switch (this.state) {
        case 0 /* PASSTHROUGH */:
          if (c === "%") {
            this.state = 1 /* PERCENT */;
          } else {
            this.buf += c;
          }
          break;
        case 1 /* PERCENT */:
          if (c === "%") {
            this.buf += c;
            this.state = 0 /* PASSTHROUGH */;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags2();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c = this.format[this.i];
      switch (this.state) {
        case 1 /* PERCENT */:
          switch (c) {
            case "[":
              this.handlePositional();
              this.state = 2 /* POSITIONAL */;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c && c <= "9" || c === "." || c === "*") {
                if (c === ".") {
                  this.flags.precision = 0;
                  this.state = 3 /* PRECISION */;
                  this.i++;
                } else {
                  this.state = 4 /* WIDTH */;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case 2 /* POSITIONAL */:
          if (c === "*") {
            const worp = this.flags.precision === -1 ? 0 /* WIDTH */ : 1 /* PRECISION */;
            this.handleWidthOrPrecisionRef(worp);
            this.state = 1 /* PERCENT */;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case 0 /* WIDTH */:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === 0 /* WIDTH */ ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c = fmt[this.i];
      switch (this.state) {
        case 4 /* WIDTH */:
          switch (c) {
            case ".":
              this.flags.precision = 0;
              this.state = 3 /* PRECISION */;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(0 /* WIDTH */);
              break;
            default: {
              const val = parseInt(c);
              if (isNaN(val)) {
                this.i--;
                this.state = 1 /* PERCENT */;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case 3 /* PRECISION */: {
          if (c === "*") {
            this.handleWidthOrPrecisionRef(1 /* PRECISION */);
            break;
          }
          const val = parseInt(c);
          if (isNaN(val)) {
            this.i--;
            this.state = 1 /* PERCENT */;
            return;
          }
          flags.precision *= 10;
          flags.precision += val;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format11 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format11[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format11[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = 0 /* PASSTHROUGH */;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s.padEnd(this.flags.width, padding);
    }
    return s.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign3;
    if (neg3) {
      sign3 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign3 = this.flags.plus ? "+" : " ";
    } else {
      sign3 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign3 + nStr;
    }
    const pad3 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign3.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad3);
    } else {
      nStr = nStr.padStart(len, pad3);
    }
    if (zero) {
      nStr = sign3 + nStr;
    }
    return nStr;
  }
  fmtNumber(n, radix, upcase = false) {
    let num = Math.abs(n).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n < 0);
  }
  fmtNumberCodePoint(n) {
    let s = "";
    try {
      s = String.fromCodePoint(n);
    } catch {
      s = UNICODE_REPLACEMENT_CHARACTER2;
    }
    return this.pad(s);
  }
  fmtFloatSpecial(n) {
    if (isNaN(n)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [fractional, round];
  }
  fmtFloatE(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    const m = n.toExponential().match(FLOAT_REGEXP2);
    if (!m) {
      throw Error("can't happen, bug");
    }
    let fractional = m[3 /* fractional */];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION2;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m[5 /* exponent */];
    let esign = m[4 /* esign */];
    let mantissa = parseInt(m[2 /* mantissa */]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r = parseInt(esign + e) + 1;
        e = r.toString();
        esign = r < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n < 0);
  }
  fmtFloatF(n) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    function expandNumber(n2) {
      if (Number.isSafeInteger(n2)) {
        return n2.toString() + ".";
      }
      const t = n2.toExponential().split("e");
      let m = t[0].replace(".", "");
      const e = parseInt(t[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m;
      } else {
        const splIdx = e + 1;
        while (m.length < splIdx) {
          m += "0";
        }
        return m.substr(0, splIdx) + "." + m.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION2;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n < 0);
  }
  fmtFloatG(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    let P = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION2;
    P = P === 0 ? 1 : P;
    const m = n.toExponential().match(FLOAT_REGEXP2);
    if (!m) {
      throw Error("can't happen");
    }
    const X2 = parseInt(m[5 /* exponent */]) * (m[4 /* esign */] === "-" ? -1 : 1);
    let nStr = "";
    if (P > X2 && X2 >= -4) {
      this.flags.precision = P - (X2 + 1);
      nStr = this.fmtFloatF(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P - 1;
      nStr = this.fmtFloatE(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s) {
    if (this.flags.precision !== -1) {
      s = s.substr(0, this.flags.precision);
    }
    return this.pad(s);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min3(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c = (val.charCodeAt(i) & 255).toString(16);
          hex += c.length === 1 ? `0${c}` : c;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? { depth: this.flags.precision } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p = this.flags.precision;
      return p === -1 ? val.toString() : val.toString().substr(0, p);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf2(format11, ...args) {
  const printf = new Printf2(format11, ...args);
  return printf.doPrintf();
}

// deno:https://deno.land/std@0.146.0/async/deferred.ts
function deferred2() {
  let methods2;
  let state = "pending";
  const promise = new Promise((resolve7, reject) => {
    methods2 = {
      async resolve(value) {
        await value;
        state = "fulfilled";
        resolve7(value);
      },
      reject(reason) {
        state = "rejected";
        reject(reason);
      }
    };
  });
  Object.defineProperty(promise, "state", { get: () => state });
  return Object.assign(promise, methods2);
}

// deno:https://deno.land/std@0.146.0/async/mux_async_iterator.ts
var MuxAsyncIterator2 = class {
  #iteratorCount = 0;
  #yields = [];
  #throws = [];
  #signal = deferred2();
  add(iterable) {
    ++this.#iteratorCount;
    this.#callIteratorNext(iterable[Symbol.asyncIterator]());
  }
  async #callIteratorNext(iterator) {
    try {
      const { value, done } = await iterator.next();
      if (done) {
        --this.#iteratorCount;
      } else {
        this.#yields.push({ iterator, value });
      }
    } catch (e) {
      this.#throws.push(e);
    }
    this.#signal.resolve();
  }
  async *iterate() {
    while (this.#iteratorCount > 0) {
      await this.#signal;
      for (let i = 0; i < this.#yields.length; i++) {
        const { iterator, value } = this.#yields[i];
        yield value;
        this.#callIteratorNext(iterator);
      }
      if (this.#throws.length) {
        for (const e of this.#throws) {
          throw e;
        }
        this.#throws.length = 0;
      }
      this.#yields.length = 0;
      this.#signal = deferred2();
    }
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// deno:https://deno.land/std@0.146.0/fmt/colors.ts
var { Deno: Deno3 } = globalThis;
var noColor2 = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
var ANSI_PATTERN2 = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://deno.land/std@0.146.0/testing/asserts.ts
var AssertionError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};
function unreachable2() {
  throw new AssertionError2("unreachable");
}

// deno:https://deno.land/std@0.146.0/_util/assert.ts
var DenoStdInternalError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert4(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError2(msg);
  }
}

// deno:https://deno.land/std@0.146.0/bytes/mod.ts
function indexOfNeedle3(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s)
      continue;
    const pin = i;
    let matched = 1;
    let j = i;
    while (matched < needle.length) {
      j++;
      if (source[j] !== needle[j - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}

// deno:https://deno.land/std@0.146.0/io/buffer.ts
var MIN_READ2 = 32 * 1024;
var MAX_SIZE3 = 2 ** 32 - 2;
var CR2 = "\r".charCodeAt(0);
var LF2 = "\n".charCodeAt(0);

// deno:https://deno.land/std@0.146.0/streams/conversion.ts
var DEFAULT_BUFFER_SIZE2 = 32 * 1024;

// deno:https://deno.land/std@0.146.0/node/_utils.ts
var _TextDecoder2 = TextDecoder;
var _TextEncoder2 = TextEncoder;

// deno:https://deno.land/std@0.146.0/node/internal_binding/util.ts
var ALL_PROPERTIES2 = 0;
var ONLY_WRITABLE2 = 1;
var ONLY_ENUMERABLE2 = 2;
var ONLY_CONFIGURABLE2 = 4;
var SKIP_STRINGS2 = 8;
var SKIP_SYMBOLS2 = 16;
var isNumericLookup2 = {};
function isArrayIndex2(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup2[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup2[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup2[value] = false;
        }
      }
      return isNumericLookup2[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties2(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k3) => !isArrayIndex2(k3));
  }
  if (filter === ALL_PROPERTIES2) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & ONLY_WRITABLE2 && !desc.writable) {
      continue;
    }
    if (filter & ONLY_ENUMERABLE2 && !desc.enumerable) {
      continue;
    }
    if (filter & ONLY_CONFIGURABLE2 && !desc.configurable) {
      continue;
    }
    if (filter & SKIP_STRINGS2 && typeof key2 === "string") {
      continue;
    }
    if (filter & SKIP_SYMBOLS2 && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}

// deno:https://deno.land/std@0.146.0/node/internal/util/inspect.mjs
var kObjectType2 = 0;
var kArrayType2 = 1;
var kArrayExtrasType2 = 2;
var kMinLineLength2 = 16;
var kWeak2 = 0;
var kIterator2 = 1;
var kMapEntries2 = 2;
var kPending2 = 0;
var kRejected2 = 2;
var meta2 = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject2 = (v) => typeof v === "undefined" && v !== void 0;
var strEscapeSequencesRegExp2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp2 = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp2 = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp2 = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp3 = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp2 = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions2 = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions2(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect5(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor2,
    showHidden: inspectDefaultOptions2.showHidden,
    depth: inspectDefaultOptions2.depth,
    colors: inspectDefaultOptions2.colors,
    customInspect: inspectDefaultOptions2.customInspect,
    showProxy: inspectDefaultOptions2.showProxy,
    maxArrayLength: inspectDefaultOptions2.maxArrayLength,
    maxStringLength: inspectDefaultOptions2.maxStringLength,
    breakLength: inspectDefaultOptions2.breakLength,
    compact: inspectDefaultOptions2.compact,
    sorted: inspectDefaultOptions2.sorted,
    getters: inspectDefaultOptions2.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions2.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor2;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue2(ctx, value, 0);
}
var customInspectSymbol7 = Symbol.for("nodejs.util.inspect.custom");
inspect5.custom = customInspectSymbol7;
Object.defineProperty(inspect5, "defaultOptions", {
  get() {
    return inspectDefaultOptions2;
  },
  set(options) {
    validateObject3(options, "options");
    return Object.assign(inspectDefaultOptions2, options);
  }
});
var defaultFG2 = 39;
var defaultBG2 = 49;
inspect5.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  blink: [5, 25],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  doubleunderline: [21, 24],
  black: [30, defaultFG2],
  red: [31, defaultFG2],
  green: [32, defaultFG2],
  yellow: [33, defaultFG2],
  blue: [34, defaultFG2],
  magenta: [35, defaultFG2],
  cyan: [36, defaultFG2],
  white: [37, defaultFG2],
  bgBlack: [40, defaultBG2],
  bgRed: [41, defaultBG2],
  bgGreen: [42, defaultBG2],
  bgYellow: [43, defaultBG2],
  bgBlue: [44, defaultBG2],
  bgMagenta: [45, defaultBG2],
  bgCyan: [46, defaultBG2],
  bgWhite: [47, defaultBG2],
  framed: [51, 54],
  overlined: [53, 55],
  gray: [90, defaultFG2],
  redBright: [91, defaultFG2],
  greenBright: [92, defaultFG2],
  yellowBright: [93, defaultFG2],
  blueBright: [94, defaultFG2],
  magentaBright: [95, defaultFG2],
  cyanBright: [96, defaultFG2],
  whiteBright: [97, defaultFG2],
  bgGray: [100, defaultBG2],
  bgRedBright: [101, defaultBG2],
  bgGreenBright: [102, defaultBG2],
  bgYellowBright: [103, defaultBG2],
  bgBlueBright: [104, defaultBG2],
  bgMagentaBright: [105, defaultBG2],
  bgCyanBright: [106, defaultBG2],
  bgWhiteBright: [107, defaultBG2]
});
function defineColorAlias2(target, alias) {
  Object.defineProperty(inspect5.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias2("gray", "grey");
defineColorAlias2("gray", "blackBright");
defineColorAlias2("bgGray", "bgGrey");
defineColorAlias2("bgGray", "bgBlackBright");
defineColorAlias2("dim", "faint");
defineColorAlias2("strikethrough", "crossedout");
defineColorAlias2("strikethrough", "strikeThrough");
defineColorAlias2("strikethrough", "crossedOut");
defineColorAlias2("hidden", "conceal");
defineColorAlias2("inverse", "swapColors");
defineColorAlias2("inverse", "swapcolors");
defineColorAlias2("doubleunderline", "doubleUnderline");
inspect5.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes2(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn2 = (str) => meta2[str.charCodeAt(0)];
function strEscape2(str) {
  let escapeTest = strEscapeSequencesRegExp2;
  let escapeReplace = strEscapeSequencesReplacer2;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle2;
      escapeReplace = strEscapeSequencesReplacerSingle2;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes2(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn2);
    return addQuotes2(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta2[point];
      } else {
        result += `${str.slice(last, i)}${meta2[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes2(result, singleQuote);
}
function stylizeWithColor2(str, styleType) {
  const style = inspect5.styles[styleType];
  if (style !== void 0) {
    const color = inspect5.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor2(str) {
  return str;
}
function formatValue2(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject2(value)) {
    return formatPrimitive2(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol7];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect5 && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions2(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue2(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw2(ctx, value, recurseTimes, typedArray);
}
function formatRaw2(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName2(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base3 = "";
  let formatter = getEmptyFormatArray2;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES2 : ONLY_ENUMERABLE2;
  let extrasType = kObjectType2;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix2(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties2(value, filter);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType2;
      formatter = formatArray2;
    } else if (isSet6(value)) {
      const size = value.size;
      const prefix = getPrefix2(constructor, tag2, "Set", `(${size})`);
      keys = getKeys2(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet2.bind(null, value) : formatSet2.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isMap6(value)) {
      const size = value.size;
      const prefix = getPrefix2(constructor, tag2, "Map", `(${size})`);
      keys = getKeys2(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap2.bind(null, value) : formatMap2.bind(null, value.entries());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isTypedArray2(value)) {
      keys = getOwnNonIndexProperties2(value, filter);
      const bound = value;
      const fallback = "";
      if (constructor === null) {
      }
      const size = value.length;
      const prefix = getPrefix2(constructor, tag2, fallback, `(${size})`);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray2.bind(null, bound, size);
      extrasType = kArrayExtrasType2;
    } else if (isMapIterator6(value)) {
      keys = getKeys2(value, ctx.showHidden);
      braces = getIteratorBraces2("Map", tag2);
      formatter = formatIterator2.bind(null, braces);
    } else if (isSetIterator6(value)) {
      keys = getKeys2(value, ctx.showHidden);
      braces = getIteratorBraces2("Set", tag2);
      formatter = formatIterator2.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys2(value, ctx.showHidden);
    braces = ["{", "}"];
    if (constructor === "Object") {
      if (isArgumentsObject6(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix2(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base3 = getFunctionBase2(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "special");
      }
    } else if (isRegExp7(value)) {
      base3 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix = getPrefix2(constructor, tag2, "RegExp");
      if (prefix !== "RegExp ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base3, "regexp");
      }
    } else if (isDate7(value)) {
      base3 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix = getPrefix2(constructor, tag2, "Date");
      if (prefix !== "Date ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "date");
      }
    } else if (value instanceof Error) {
      base3 = formatError2(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else if (isAnyArrayBuffer6(value)) {
      const arrayType = isArrayBuffer6(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix = getPrefix2(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer2;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix + `{ byteLength: ${formatNumber2(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      Array.prototype.unshift.call(keys, "byteLength");
    } else if (isDataView6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "Promise")}{`;
      formatter = formatPromise2;
    } else if (isWeakSet6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet2 : formatWeakCollection2;
    } else if (isWeakMap6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap2 : formatWeakCollection2;
    } else if (isModuleNamespaceObject6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject2.bind(null, keys);
    } else if (isBoxedPrimitive6(value)) {
      base3 = getBoxedBase2(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle2(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle2(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle2(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty2(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName = getCtxStyle2(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize2(ctx, err, constructorName, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base3 = base3 === "" ? reference : `${reference} ${base3}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === kObjectType2) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString2(ctx, output, base3, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects2 = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties2(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach.call(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push.call(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty2(ctx, obj2, recurseTimes, key2, kObjectType2, desc, main);
      if (ctx.colors) {
        Array.prototype.push.call(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push.call(output, value);
      }
    }
    Array.prototype.pop.call(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName2(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject2(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof2(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects2.has(descriptor.value.name))) {
        addPrototypeProperties2(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName2(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect5(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive2(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > kMinLineLength2 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape2(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape2(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber2(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt2(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray2() {
  return [];
}
function isInstanceof2(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix2(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray2(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray2(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty2(ctx, value, recurseTimes, i, kArrayType2));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle2(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix2(constructor, tag2, fallback);
}
function getKeys2(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet2(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v of value) {
    Array.prototype.push.call(output, formatValue2(ctx, v, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap2(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k3, 1: v } of value) {
    output.push(`${formatValue2(ctx, k3, recurseTimes)} => ${formatValue2(ctx, v, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray2(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber2 : formatBigInt2;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue2(ctx, value[key2], recurseTimes, true);
      Array.prototype.push.call(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces2(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [`[${tag2}] {`, "}"];
}
function formatIterator2(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner2(ctx, recurseTimes, entries, kMapEntries2);
  }
  return formatSetIterInner2(ctx, recurseTimes, entries, kIterator2);
}
function getFunctionBase2(value, constructor, tag2) {
  const stringified = Function.prototype.toString.call(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice5 = stringified.slice(5, -1);
    const bracketIndex = slice5.indexOf("{");
    if (bracketIndex !== -1 && (!slice5.slice(0, bracketIndex).includes("(") || classRegExp3.test(slice5.replace(stripCommentsRegExp2)))) {
      return getClassBase2(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction6(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction6(value)) {
    type = `Async${type}`;
  }
  let base3 = `[${type}`;
  if (constructor === null) {
    base3 += " (null prototype)";
  }
  if (value.name === "") {
    base3 += " (anonymous)";
  } else {
    base3 += `: ${value.name}`;
  }
  base3 += "]";
  if (constructor !== type && constructor !== null) {
    base3 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  return base3;
}
function formatError2(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name2 of ["name", "message", "stack"]) {
      const index = keys.indexOf(name2);
      if (index !== -1 && stack.includes(err[name2])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix2(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos2 = 0;
      while (nodeModule = nodeModulesRegExp2.exec(line)) {
        newStack += line.slice(pos2, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos2 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos2 === 0 ? line : line.slice(pos2);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice4;
function formatArrayBuffer2(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [ctx.stylize("(detached)", "special")];
  }
  let str = hexSlice4(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [`${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`];
}
function formatNumber2(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise2(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === kPending2) {
    output = [ctx.stylize("<pending>", "special")];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue2(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected2 ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection2(ctx) {
  return [ctx.stylize("<items unknown>", "special")];
}
function formatWeakSet2(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner2(ctx, recurseTimes, entries, kWeak2);
}
function formatWeakMap2(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner2(ctx, recurseTimes, entries, kWeak2);
}
function formatProperty2(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2], enumerable: true };
  if (desc.value !== void 0) {
    const diff3 = ctx.compact !== true || type !== kObjectType2 ? 2 : 3;
    ctx.indentationLvl += diff3;
    str = formatValue2(ctx, desc.value, recurseTimes);
    if (diff3 === 3 && ctx.breakLength < getStringWidth2(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff3;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s(`[${label}]`, sp)} ${formatValue2(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive2(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === kArrayType2) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp = key2.toString().replace(strEscapeSequencesReplacer2, escapeFn2);
    name = `[${ctx.stylize(tmp, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp = key2.replace(strEscapeSequencesReplacer2, escapeFn2);
    name = `[${tmp}]`;
  } else if (keyStrRegExp2.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape2(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize2(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp2 = /\u001b\[\d\d?m/g;
function removeColors2(str) {
  return str.replace(colorRegExp2, "");
}
function isBelowBreakLength2(ctx, output, start, base3) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors2(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base3 === "" || !base3.includes("\n");
}
function formatBigInt2(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject2(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty2(ctx, value, recurseTimes, keys[i], kObjectType2);
    } catch (_err) {
      const tmp = { [keys[i]]: "" };
      output[i] = formatProperty2(ctx, tmp, recurseTimes, keys[i], kObjectType2);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray2(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp2.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty2(ctx, value, recurseTimes, key2, kArrayType2));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? "s" : "";
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase2(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject6(value)) {
    type = "Number";
  } else if (isStringObject6(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject6(value)) {
    type = "Boolean";
  } else if (isBigIntObject6(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base3 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base3 += " (null prototype)";
    } else {
      base3 += ` (${constructor})`;
    }
  }
  base3 += `: ${formatPrimitive2(stylizeNoColor2, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base3 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor2) {
    return base3;
  }
  return ctx.stylize(base3, type.toLowerCase());
}
function getClassBase2(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base3 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base3 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base3 += ` extends ${superName}`;
    }
  } else {
    base3 += " extends [null prototype]";
  }
  return `[${base3}]`;
}
function reduceToSingleString2(ctx, output, base3, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === kArrayExtrasType2 && entries > 6) {
        output = groupArrayElements2(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base3.length + 10;
        if (isBelowBreakLength2(ctx, output, start, base3)) {
          return `${base3 ? `${base3} ` : ""}${braces[0]} ${join7(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation2 = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base3 ? `${base3} ` : ""}${braces[0]}${indentation2}  ${join7(output, `,${indentation2}  `)}${indentation2}${braces[1]}`;
  }
  if (isBelowBreakLength2(ctx, output, 0, base3)) {
    return `${braces[0]}${base3 ? ` ${base3}` : ""} ${join7(output, ", ")} ` + braces[1];
  }
  const indentation = " ".repeat(ctx.indentationLvl);
  const ln = base3 === "" && braces[0].length === 1 ? " " : `${base3 ? ` ${base3}` : ""}
${indentation}  `;
  return `${braces[0]}${ln}${join7(output, `,
${indentation}  `)} ${braces[1]}`;
}
function join7(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements2(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth2(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + separatorSpace;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i2 = 0; i2 < columns; i2++) {
      let lineMaxLength = 0;
      for (let j = i2; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i2] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i2 = 0; i2 < output.length; i2++) {
        if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i2 = 0; i2 < outputLength; i2 += columns) {
      const max2 = Math.min(i2 + columns, outputLength);
      let str = "";
      let j = i2;
      for (; j < max2 - 1; j++) {
        const padding = maxLineLength[j - i2] + output[j].length - dataLen[j];
        str += `${output[j]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding = maxLineLength[j - i2] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, " ");
      } else {
        str += output[j];
      }
      Array.prototype.push.call(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push.call(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner2(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak2) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue2(ctx, entries[pos], recurseTimes)} => ${formatValue2(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [
        formatValue2(ctx, entries[pos], recurseTimes),
        formatValue2(ctx, entries[pos + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString2(ctx, res, "", ["[", "]"], kArrayExtrasType2, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner2(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue2(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak2 && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern2 = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi2 = new RegExp(ansiPattern2, "g");
function getStringWidth2(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters2(str);
  }
  str = str.normalize("NFC");
  for (const char of str[Symbol.iterator]()) {
    const code2 = char.codePointAt(0);
    if (isFullWidthCodePoint2(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint2(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint2 = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint2 = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function hasBuiltInToString2(value) {
  const proxyTarget = void 0;
  if (proxyTarget !== void 0) {
    value = proxyTarget;
  }
  if (typeof value.toString !== "function") {
    return true;
  }
  if (Object.prototype.hasOwnProperty.call(value, "toString")) {
    return false;
  }
  let pointer = value;
  do {
    pointer = Object.getPrototypeOf(pointer);
  } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
  const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
  return descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name);
}
var firstErrorLine2 = (error3) => error3.message.split("\n", 1)[0];
var CIRCULAR_ERROR_MESSAGE2;
function tryStringify2(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    if (!CIRCULAR_ERROR_MESSAGE2) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (circularError) {
        CIRCULAR_ERROR_MESSAGE2 = firstErrorLine2(circularError);
      }
    }
    if (err.name === "TypeError" && firstErrorLine2(err) === CIRCULAR_ERROR_MESSAGE2) {
      return "[Circular]";
    }
    throw err;
  }
}
function format7(...args) {
  return formatWithOptionsInternal2(void 0, args);
}
function formatWithOptions2(inspectOptions, ...args) {
  if (typeof inspectOptions !== "object" || inspectOptions === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
  }
  return formatWithOptionsInternal2(inspectOptions, args);
}
function formatNumberNoColor2(number, options) {
  return formatNumber2(stylizeNoColor2, number, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatBigIntNoColor2(bigint, options) {
  return formatBigInt2(stylizeNoColor2, bigint, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatWithOptionsInternal2(inspectOptions, args) {
  const first = args[0];
  let a = 0;
  let str = "";
  let join12 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              const tempArg = args[++a];
              if (typeof tempArg === "number") {
                tempStr = formatNumberNoColor2(tempArg, inspectOptions);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatBigIntNoColor2(tempArg, inspectOptions);
              } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString2(tempArg)) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect5(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            case 106:
              tempStr = tryStringify2(args[++a]);
              break;
            case 100:
              const tempNum = args[++a];
              if (typeof tempNum === "bigint") {
                tempStr = formatBigIntNoColor2(tempNum, inspectOptions);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor2(Number(tempNum), inspectOptions);
              }
              break;
            case 79:
              tempStr = inspect5(args[++a], inspectOptions);
              break;
            case 111:
              tempStr = inspect5(args[++a], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105:
              const tempInteger = args[++a];
              if (typeof tempInteger === "bigint") {
                tempStr = formatBigIntNoColor2(tempInteger, inspectOptions);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor2(Number.parseInt(tempInteger), inspectOptions);
              }
              break;
            case 102:
              const tempFloat = args[++a];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor2(Number.parseFloat(tempFloat), inspectOptions);
              }
              break;
            case 99:
              a += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join12 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join12;
    str += typeof value !== "string" ? inspect5(value, inspectOptions) : value;
    join12 = " ";
    a++;
  }
  return str;
}
function stripVTControlCharacters2(str) {
  validateString3(str, "str");
  return str.replace(ansi2, "");
}

// deno:https://deno.land/std@0.146.0/node/internal/util/debuglog.ts
var debugImpls2;
var testEnabled2;
function initializeDebugEnv2(debugEnv3) {
  debugImpls2 = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled2 = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled2 = () => false;
  }
}
function emitWarningIfNeeded2(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop2 = () => {
};
function debuglogImpl2(enabled2, set) {
  if (debugImpls2[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded2(set);
      debugImpls2[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect5(arg)).join(" ");
        console.error(sprintf2("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls2[set] = noop2;
    }
  }
  return debugImpls2[set];
}
function debuglog2(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled2(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl2(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv2;
try {
  debugEnv2 = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error3) {
  if (error3 instanceof Deno.errors.PermissionDenied) {
    debugEnv2 = "";
  } else {
    throw error3;
  }
}
initializeDebugEnv2(debugEnv2);

// deno:https://deno.land/std@0.146.0/_util/os.ts
var osType2 = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows2 = osType2 === "windows";

// deno:https://deno.land/std@0.146.0/node/internal_binding/constants.ts
var os2 = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};

// deno:https://deno.land/std@0.146.0/node/internal_binding/uv.ts
var UV_EEXIST2 = os2.errno.EEXIST;
var UV_ENOENT2 = os2.errno.ENOENT;
var codeToErrorWindows2 = [
  [-4093, ["E2BIG", "argument list too long"]],
  [-4092, ["EACCES", "permission denied"]],
  [-4091, ["EADDRINUSE", "address already in use"]],
  [-4090, ["EADDRNOTAVAIL", "address not available"]],
  [-4089, ["EAFNOSUPPORT", "address family not supported"]],
  [-4088, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-4084, ["EALREADY", "connection already in progress"]],
  [-4083, ["EBADF", "bad file descriptor"]],
  [-4082, ["EBUSY", "resource busy or locked"]],
  [-4081, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-4079, ["ECONNABORTED", "software caused connection abort"]],
  [-4078, ["ECONNREFUSED", "connection refused"]],
  [-4077, ["ECONNRESET", "connection reset by peer"]],
  [-4076, ["EDESTADDRREQ", "destination address required"]],
  [-4075, ["EEXIST", "file already exists"]],
  [-4074, ["EFAULT", "bad address in system call argument"]],
  [-4036, ["EFBIG", "file too large"]],
  [-4073, ["EHOSTUNREACH", "host is unreachable"]],
  [-4072, ["EINTR", "interrupted system call"]],
  [-4071, ["EINVAL", "invalid argument"]],
  [-4070, ["EIO", "i/o error"]],
  [-4069, ["EISCONN", "socket is already connected"]],
  [-4068, ["EISDIR", "illegal operation on a directory"]],
  [-4067, ["ELOOP", "too many symbolic links encountered"]],
  [-4066, ["EMFILE", "too many open files"]],
  [-4065, ["EMSGSIZE", "message too long"]],
  [-4064, ["ENAMETOOLONG", "name too long"]],
  [-4063, ["ENETDOWN", "network is down"]],
  [-4062, ["ENETUNREACH", "network is unreachable"]],
  [-4061, ["ENFILE", "file table overflow"]],
  [-4060, ["ENOBUFS", "no buffer space available"]],
  [-4059, ["ENODEV", "no such device"]],
  [-4058, ["ENOENT", "no such file or directory"]],
  [-4057, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-4035, ["ENOPROTOOPT", "protocol not available"]],
  [-4055, ["ENOSPC", "no space left on device"]],
  [-4054, ["ENOSYS", "function not implemented"]],
  [-4053, ["ENOTCONN", "socket is not connected"]],
  [-4052, ["ENOTDIR", "not a directory"]],
  [-4051, ["ENOTEMPTY", "directory not empty"]],
  [-4050, ["ENOTSOCK", "socket operation on non-socket"]],
  [-4049, ["ENOTSUP", "operation not supported on socket"]],
  [-4048, ["EPERM", "operation not permitted"]],
  [-4047, ["EPIPE", "broken pipe"]],
  [-4046, ["EPROTO", "protocol error"]],
  [-4045, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-4044, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-4034, ["ERANGE", "result too large"]],
  [-4043, ["EROFS", "read-only file system"]],
  [-4042, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-4041, ["ESPIPE", "invalid seek"]],
  [-4040, ["ESRCH", "no such process"]],
  [-4039, ["ETIMEDOUT", "connection timed out"]],
  [-4038, ["ETXTBSY", "text file is busy"]],
  [-4037, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-4033, ["ENXIO", "no such device or address"]],
  [-4032, ["EMLINK", "too many links"]],
  [-4031, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-4029, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-4027, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeWindows2 = codeToErrorWindows2.map(([status, [error3]]) => [error3, status]);
var codeToErrorDarwin2 = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-48, ["EADDRINUSE", "address already in use"]],
  [-49, ["EADDRNOTAVAIL", "address not available"]],
  [-47, ["EAFNOSUPPORT", "address family not supported"]],
  [-35, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-37, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-89, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-53, ["ECONNABORTED", "software caused connection abort"]],
  [-61, ["ECONNREFUSED", "connection refused"]],
  [-54, ["ECONNRESET", "connection reset by peer"]],
  [-39, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-65, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-56, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-62, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-40, ["EMSGSIZE", "message too long"]],
  [-63, ["ENAMETOOLONG", "name too long"]],
  [-50, ["ENETDOWN", "network is down"]],
  [-51, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-55, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-42, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-78, ["ENOSYS", "function not implemented"]],
  [-57, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-66, ["ENOTEMPTY", "directory not empty"]],
  [-38, ["ENOTSOCK", "socket operation on non-socket"]],
  [-45, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-100, ["EPROTO", "protocol error"]],
  [-43, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-41, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-58, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-60, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-64, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-79, ["EFTYPE", "inappropriate file type or format"]],
  [-92, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeDarwin2 = codeToErrorDarwin2.map(([status, [code2]]) => [code2, status]);
var codeToErrorLinux2 = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-98, ["EADDRINUSE", "address already in use"]],
  [-99, ["EADDRNOTAVAIL", "address not available"]],
  [-97, ["EAFNOSUPPORT", "address family not supported"]],
  [-11, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-114, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-125, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-103, ["ECONNABORTED", "software caused connection abort"]],
  [-111, ["ECONNREFUSED", "connection refused"]],
  [-104, ["ECONNRESET", "connection reset by peer"]],
  [-89, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-113, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-106, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-40, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-90, ["EMSGSIZE", "message too long"]],
  [-36, ["ENAMETOOLONG", "name too long"]],
  [-100, ["ENETDOWN", "network is down"]],
  [-101, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-105, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-64, ["ENONET", "machine is not on the network"]],
  [-92, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-38, ["ENOSYS", "function not implemented"]],
  [-107, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-39, ["ENOTEMPTY", "directory not empty"]],
  [-88, ["ENOTSOCK", "socket operation on non-socket"]],
  [-95, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-71, ["EPROTO", "protocol error"]],
  [-93, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-91, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-108, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-110, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-112, ["EHOSTDOWN", "host is down"]],
  [-121, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-84, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeLinux2 = codeToErrorLinux2.map(([status, [code2]]) => [code2, status]);
var errorMap2 = new Map(osType2 === "windows" ? codeToErrorWindows2 : osType2 === "darwin" ? codeToErrorDarwin2 : osType2 === "linux" ? codeToErrorLinux2 : unreachable2());
var codeMap2 = new Map(osType2 === "windows" ? errorToCodeWindows2 : osType2 === "darwin" ? errorToCodeDarwin2 : osType2 === "linux" ? errorToCodeLinux2 : unreachable2());
var UV_EAI_MEMORY2 = codeMap2.get("EAI_MEMORY");
var UV_UNKNOWN2 = codeMap2.get("UNKNOWN");
var UV_EBADF2 = codeMap2.get("EBADF");
var UV_EINVAL2 = codeMap2.get("EINVAL");
var UV_ENOTSOCK2 = codeMap2.get("ENOTSOCK");

// deno:https://deno.land/std@0.146.0/node/util/types.ts
var types_default5 = { ...types_exports5 };

// deno:https://deno.land/std@0.146.0/node/internal_binding/_node.ts
var Encodings3 = /* @__PURE__ */ ((Encodings4) => {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
  return Encodings4;
})(Encodings3 || {});

// deno:https://deno.land/std@0.146.0/node/internal_binding/string_decoder.ts
var encodings3 = [];
encodings3[0 /* ASCII */] = "ascii";
encodings3[2 /* BASE64 */] = "base64";
encodings3[7 /* BASE64URL */] = "base64url";
encodings3[6 /* BUFFER */] = "buffer";
encodings3[5 /* HEX */] = "hex";
encodings3[4 /* LATIN1 */] = "latin1";
encodings3[3 /* UCS2 */] = "utf16le";
encodings3[1 /* UTF8 */] = "utf8";

// deno:https://deno.land/std@0.146.0/node/internal_binding/buffer.ts
function numberToBytes3(n) {
  if (n === 0)
    return new Uint8Array([0]);
  const bytes = [];
  bytes.unshift(n & 255);
  while (n >= 256) {
    n = n >>> 8;
    bytes.unshift(n & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex3(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x = 0; x <= searchableBufferLastIndex; x++) {
    if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer3(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings3[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex3(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle3(targetBuffer, buffer, byteOffset);
}
function indexOfNumber3(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes3(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer3(targetBuffer, numberToBytes3(number), byteOffset, 1 /* UTF8 */, forwardDirection);
}

// deno:https://deno.land/std@0.146.0/encoding/base64.ts
var base64abc3 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode11(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc3[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc3[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc3[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode9(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.146.0/encoding/base64url.ts
function addPaddingToBase64url3(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase643(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url3(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url3(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode12(data) {
  return convertBase64ToBase64url3(encode11(data));
}
function decode10(b64url) {
  return decode9(convertBase64urlToBase643(b64url));
}

// deno:https://deno.land/std@0.146.0/node/internal_binding/_utils.ts
function asciiToBytes3(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes3(str) {
  str = base64clean3(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode9(str);
}
var INVALID_BASE64_RE3 = /[^+/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE3, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes3(str) {
  str = base64clean3(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode10(str);
}
function hexToBytes3(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a = Number.parseInt(str[i * 2], 16);
    const b = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a) && Number.isNaN(b)) {
      break;
    }
    byteArray[i] = a << 4 | b;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes3(str, units) {
  let c, hi, lo2;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo2 = c % 256;
    byteArray.push(lo2);
    byteArray.push(hi);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii3(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le3(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

// deno:https://deno.land/std@0.146.0/node/internal/buffer.mjs
var utf8Encoder3 = new TextEncoder();
var float32Array3 = new Float32Array(1);
var uInt8Float32Array3 = new Uint8Array(float32Array3.buffer);
var float64Array3 = new Float64Array(1);
var uInt8Float64Array3 = new Uint8Array(float64Array3.buffer);
float32Array3[0] = -1;
var bigEndian3 = uInt8Float32Array3[3] === 0;
function readUInt48LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 8);
  }
  uInt8Float64Array3[7] = first;
  uInt8Float64Array3[6] = buffer[++offset];
  uInt8Float64Array3[5] = buffer[++offset];
  uInt8Float64Array3[4] = buffer[++offset];
  uInt8Float64Array3[3] = buffer[++offset];
  uInt8Float64Array3[2] = buffer[++offset];
  uInt8Float64Array3[1] = buffer[++offset];
  uInt8Float64Array3[0] = last;
  return float64Array3[0];
}
function readDoubleForwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 8);
  }
  uInt8Float64Array3[0] = first;
  uInt8Float64Array3[1] = buffer[++offset];
  uInt8Float64Array3[2] = buffer[++offset];
  uInt8Float64Array3[3] = buffer[++offset];
  uInt8Float64Array3[4] = buffer[++offset];
  uInt8Float64Array3[5] = buffer[++offset];
  uInt8Float64Array3[6] = buffer[++offset];
  uInt8Float64Array3[7] = last;
  return float64Array3[0];
}
function writeDoubleForwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 7);
  float64Array3[0] = val;
  buffer[offset++] = uInt8Float64Array3[0];
  buffer[offset++] = uInt8Float64Array3[1];
  buffer[offset++] = uInt8Float64Array3[2];
  buffer[offset++] = uInt8Float64Array3[3];
  buffer[offset++] = uInt8Float64Array3[4];
  buffer[offset++] = uInt8Float64Array3[5];
  buffer[offset++] = uInt8Float64Array3[6];
  buffer[offset++] = uInt8Float64Array3[7];
  return offset;
}
function writeDoubleBackwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 7);
  float64Array3[0] = val;
  buffer[offset++] = uInt8Float64Array3[7];
  buffer[offset++] = uInt8Float64Array3[6];
  buffer[offset++] = uInt8Float64Array3[5];
  buffer[offset++] = uInt8Float64Array3[4];
  buffer[offset++] = uInt8Float64Array3[3];
  buffer[offset++] = uInt8Float64Array3[2];
  buffer[offset++] = uInt8Float64Array3[1];
  buffer[offset++] = uInt8Float64Array3[0];
  return offset;
}
function readFloatBackwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 4);
  }
  uInt8Float32Array3[3] = first;
  uInt8Float32Array3[2] = buffer[++offset];
  uInt8Float32Array3[1] = buffer[++offset];
  uInt8Float32Array3[0] = last;
  return float32Array3[0];
}
function readFloatForwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 4);
  }
  uInt8Float32Array3[0] = first;
  uInt8Float32Array3[1] = buffer[++offset];
  uInt8Float32Array3[2] = buffer[++offset];
  uInt8Float32Array3[3] = last;
  return float32Array3[0];
}
function writeFloatForwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 3);
  float32Array3[0] = val;
  buffer[offset++] = uInt8Float32Array3[0];
  buffer[offset++] = uInt8Float32Array3[1];
  buffer[offset++] = uInt8Float32Array3[2];
  buffer[offset++] = uInt8Float32Array3[3];
  return offset;
}
function writeFloatBackwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 3);
  float32Array3[0] = val;
  buffer[offset++] = uInt8Float32Array3[3];
  buffer[offset++] = uInt8Float32Array3[2];
  buffer[offset++] = uInt8Float32Array3[1];
  buffer[offset++] = uInt8Float32Array3[0];
  return offset;
}
function readInt24LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf83(str) {
  return utf8Encoder3.encode(str).length;
}
function base64ByteLength3(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap3 = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings3.length; ++i) {
  encodingsMap3[encodings3[i]] = i;
}
var encodingOps3 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap3.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength3(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap3.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, base64ToBytes3(val), byteOffset, encodingsMap3.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength3(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap3.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, base64UrlToBytes3(val), byteOffset, encodingsMap3.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap3.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, hexToBytes3(val), byteOffset, encodingsMap3.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap3.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap3.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf83,
    encoding: "utf8",
    encodingVal: encodingsMap3.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf8Encoder3.encode(val), byteOffset, encodingsMap3.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap3.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps3(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps3.utf8;
      if (encoding === "ucs2")
        return encodingOps3.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps3.utf8;
      if (encoding === "ascii")
        return encodingOps3.ascii;
      if (encoding === "ucs-2")
        return encodingOps3.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps3.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps3.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps3.latin1;
      }
      if (encoding === "base64")
        return encodingOps3.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps3.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps3.base64url;
      }
      break;
  }
}
function _copyActual3(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError3(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber3(value, type);
    throw new codes3.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes3.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber3(value, name) {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds5(buf, offset, byteLength6) {
  validateNumber3(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength6] === void 0) {
    boundsError3(offset, buf.length - (byteLength6 + 1));
  }
}
function checkInt3(value, min4, max2, buf, offset, byteLength6) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength6 > 3) {
      if (min4 === 0 || min4 === 0n) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength6 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds5(buf, offset, byteLength6);
}
function toInteger3(n, defaultVal) {
  n = +n;
  if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
    return n % 1 === 0 ? n : Math.floor(n);
  }
  return defaultVal;
}
function writeU_Int83(buf, value, offset, min4, max2) {
  value = +value;
  validateNumber3(offset, "offset");
  if (value > max2 || value < min4) {
    throw new codes3.ERR_OUT_OF_RANGE("value", `>= ${min4} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError3(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset3(value, name, min4 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
}
function writeU_Int48LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}

// deno:https://deno.land/std@0.146.0/node/_buffer.mjs
var kMaxLength3 = 2147483647;
var MAX_UINT324 = 2 ** 32;
var customInspectSymbol8 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES3 = 50;
Object.defineProperty(Buffer6.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer6.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer6.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer6.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer3(length) {
  if (length > kMaxLength3) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer6.prototype);
  return buf;
}
function Buffer6(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes3.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe3(arg);
  }
  return _from4(arg, encodingOrOffset, length);
}
Buffer6.poolSize = 8192;
function _from4(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString3(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer6(value)) {
      return fromArrayBuffer3(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from4(valueOf, encodingOrOffset, length);
    }
    const b = fromObject3(value);
    if (b) {
      return b;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString3(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes3.ERR_INVALID_ARG_TYPE("first argument", ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"], value);
}
Buffer6.from = function from3(value, encodingOrOffset, length) {
  return _from4(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer6.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer6, Uint8Array);
function assertSize4(size) {
  validateNumber3(size, "size");
  if (!(size >= 0 && size <= kMaxLength3)) {
    throw new codes3.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc3(size, fill5, encoding) {
  assertSize4(size);
  const buffer = createBuffer3(size);
  if (fill5 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes3.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill5, encoding);
  }
  return buffer;
}
Buffer6.alloc = function alloc3(size, fill5, encoding) {
  return _alloc3(size, fill5, encoding);
};
function _allocUnsafe3(size) {
  assertSize4(size);
  return createBuffer3(size < 0 ? 0 : checked3(size) | 0);
}
Buffer6.allocUnsafe = function allocUnsafe3(size) {
  return _allocUnsafe3(size);
};
Buffer6.allocUnsafeSlow = function allocUnsafeSlow3(size) {
  return _allocUnsafe3(size);
};
function fromString3(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer6.isEncoding(encoding)) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength4(string, encoding) | 0;
  let buf = createBuffer3(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike3(array) {
  const length = array.length < 0 ? 0 : checked3(array.length) | 0;
  const buf = createBuffer3(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject3(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer6(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer3(0);
    }
    return fromArrayLike3(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike3(obj2.data);
  }
}
function checked3(length) {
  if (length >= kMaxLength3) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3.toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer3(length) {
  assertSize4(length);
  return Buffer6.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer3, Uint8Array);
Buffer6.isBuffer = function isBuffer4(b) {
  return b != null && b._isBuffer === true && b !== Buffer6.prototype;
};
Buffer6.compare = function compare6(a, b) {
  if (isInstance3(a, Uint8Array)) {
    a = Buffer6.from(a, a.offset, a.byteLength);
  }
  if (isInstance3(b, Uint8Array)) {
    b = Buffer6.from(b, b.offset, b.byteLength);
  }
  if (!Buffer6.isBuffer(a) || !Buffer6.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) {
    return 0;
  }
  let x = a.length;
  let y = b.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
};
Buffer6.isEncoding = function isEncoding3(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding5(encoding) !== void 0;
};
Buffer6.concat = function concat5(list, length) {
  if (!Array.isArray(list)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer6.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset3(length, "length");
  }
  const buffer = Buffer6.allocUnsafe(length);
  let pos = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    if (!isUint8Array3(buf)) {
      throw new codes3.ERR_INVALID_ARG_TYPE(`list[${i}]`, ["Buffer", "Uint8Array"], list[i]);
    }
    pos += _copyActual3(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength4(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView3(string) || isAnyArrayBuffer6(string)) {
      return string.byteLength;
    }
    throw new codes3.ERR_INVALID_ARG_TYPE("string", ["string", "Buffer", "ArrayBuffer"], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf83(string);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf83(string);
  }
  return ops.byteLength(string);
}
Buffer6.byteLength = byteLength4;
Buffer6.prototype._isBuffer = true;
function swap3(b, n, m) {
  const i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer6.prototype.swap16 = function swap163() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap3(this, i, i + 1);
  }
  return this;
};
Buffer6.prototype.swap32 = function swap323() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap3(this, i, i + 3);
    swap3(this, i + 1, i + 2);
  }
  return this;
};
Buffer6.prototype.swap64 = function swap643() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap3(this, i, i + 7);
    swap3(this, i + 1, i + 6);
    swap3(this, i + 2, i + 5);
    swap3(this, i + 3, i + 4);
  }
  return this;
};
Buffer6.prototype.toString = function toString4(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer6.prototype.toLocaleString = Buffer6.prototype.toString;
Buffer6.prototype.equals = function equals6(b) {
  if (!isUint8Array3(b)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("otherBuffer", ["Buffer", "Uint8Array"], b);
  }
  if (this === b) {
    return true;
  }
  return Buffer6.compare(this, b) === 0;
};
Buffer6.prototype.inspect = function inspect6() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES3;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol8) {
  Buffer6.prototype[customInspectSymbol8] = Buffer6.prototype.inspect;
}
Buffer6.prototype.compare = function compare7(target, start, end, thisStart, thisEnd) {
  if (isInstance3(target, Uint8Array)) {
    target = Buffer6.from(target, target.offset, target.byteLength);
  }
  if (!Buffer6.isBuffer(target)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset3(start, "targetStart", 0, kMaxLength3);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset3(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset3(start, "sourceStart", 0, kMaxLength3);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset3(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes3.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x = thisEnd - thisStart;
  let y = end - start;
  const len = Math.min(x, y);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
  validateBuffer3(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber3(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps3.utf8;
  } else {
    ops = getEncodingOps3(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array3(val)) {
    const encodingVal = ops === void 0 ? encodingsMap3.utf8 : ops.encodingVal;
    return indexOfBuffer3(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes3.ERR_INVALID_ARG_TYPE("value", ["number", "string", "Buffer", "Uint8Array"], val);
}
Buffer6.prototype.includes = function includes3(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer6.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer6.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
Buffer6.prototype.asciiSlice = function asciiSlice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii3(this);
  } else {
    return bytesToAscii3(this.slice(offset, length));
  }
};
Buffer6.prototype.asciiWrite = function asciiWrite3(string, offset, length) {
  return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer6.prototype.base64Slice = function base64Slice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode11(this);
  } else {
    return encode11(this.slice(offset, length));
  }
};
Buffer6.prototype.base64Write = function base64Write3(string, offset, length) {
  return blitBuffer3(base64ToBytes3(string), this, offset, length);
};
Buffer6.prototype.base64urlSlice = function base64urlSlice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode12(this);
  } else {
    return encode12(this.slice(offset, length));
  }
};
Buffer6.prototype.base64urlWrite = function base64urlWrite3(string, offset, length) {
  return blitBuffer3(base64UrlToBytes3(string), this, offset, length);
};
Buffer6.prototype.hexWrite = function hexWrite3(string, offset, length) {
  return blitBuffer3(hexToBytes3(string, this.length - offset), this, offset, length);
};
Buffer6.prototype.hexSlice = function hexSlice5(string, offset, length) {
  return _hexSlice3(this, string, offset, length);
};
Buffer6.prototype.latin1Slice = function latin1Slice3(string, offset, length) {
  return _latin1Slice3(this, string, offset, length);
};
Buffer6.prototype.latin1Write = function latin1Write3(string, offset, length) {
  return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer6.prototype.ucs2Slice = function ucs2Slice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le3(this);
  } else {
    return bytesToUtf16le3(this.slice(offset, length));
  }
};
Buffer6.prototype.ucs2Write = function ucs2Write3(string, offset, length) {
  return blitBuffer3(utf16leToBytes3(string, this.length - offset), this, offset, length);
};
Buffer6.prototype.utf8Slice = function utf8Slice3(string, offset, length) {
  return _utf8Slice3(this, string, offset, length);
};
Buffer6.prototype.utf8Write = function utf8Write4(string, offset, length) {
  return blitBuffer3(utf8ToBytes3(string, this.length - offset), this, offset, length);
};
Buffer6.prototype.write = function write3(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset3(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset3(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer6.prototype.toJSON = function toJSON4() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer3(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer6.prototype);
  return buffer;
}
function _utf8Slice3(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
  }
  return res;
}
function _latin1Slice3(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice3(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable3[buf[i]];
  }
  return out;
}
Buffer6.prototype.slice = function slice3(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer6.prototype);
  return newBuf;
};
Buffer6.prototype.readUintLE = Buffer6.prototype.readUIntLE = function readUIntLE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48LE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40LE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24LE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readUintBE = Buffer6.prototype.readUIntBE = function readUIntBE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48BE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40BE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24BE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readUint8 = Buffer6.prototype.readUInt8 = function readUInt84(offset = 0) {
  validateNumber3(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError3(offset, this.length - 1);
  }
  return val;
};
Buffer6.prototype.readUint16BE = Buffer6.prototype.readUInt16BE = readUInt16BE3;
Buffer6.prototype.readUint16LE = Buffer6.prototype.readUInt16LE = function readUInt16LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer6.prototype.readUint32LE = Buffer6.prototype.readUInt32LE = function readUInt32LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer6.prototype.readUint32BE = Buffer6.prototype.readUInt32BE = readUInt32BE3;
Buffer6.prototype.readBigUint64LE = Buffer6.prototype.readBigUInt64LE = defineBigIntMethod3(function readBigUInt64LE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const lo2 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo2) + (BigInt(hi) << BigInt(32));
});
Buffer6.prototype.readBigUint64BE = Buffer6.prototype.readBigUInt64BE = defineBigIntMethod3(function readBigUInt64BE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo2);
});
Buffer6.prototype.readIntLE = function readIntLE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48LE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40LE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24LE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readIntBE = function readIntBE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48BE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40BE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24BE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readInt8 = function readInt83(offset = 0) {
  validateNumber3(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError3(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer6.prototype.readInt16LE = function readInt16LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer6.prototype.readInt16BE = function readInt16BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer6.prototype.readInt32LE = function readInt32LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer6.prototype.readInt32BE = function readInt32BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer6.prototype.readBigInt64LE = defineBigIntMethod3(function readBigInt64LE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer6.prototype.readBigInt64BE = defineBigIntMethod3(function readBigInt64BE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer6.prototype.readFloatLE = function readFloatLE3(offset) {
  return bigEndian3 ? readFloatBackwards3(this, offset) : readFloatForwards3(this, offset);
};
Buffer6.prototype.readFloatBE = function readFloatBE3(offset) {
  return bigEndian3 ? readFloatForwards3(this, offset) : readFloatBackwards3(this, offset);
};
Buffer6.prototype.readDoubleLE = function readDoubleLE3(offset) {
  return bigEndian3 ? readDoubleBackwards3(this, offset) : readDoubleForwards3(this, offset);
};
Buffer6.prototype.readDoubleBE = function readDoubleBE3(offset) {
  return bigEndian3 ? readDoubleForwards3(this, offset) : readDoubleBackwards3(this, offset);
};
Buffer6.prototype.writeUintLE = Buffer6.prototype.writeUIntLE = function writeUIntLE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE3(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE3(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE3(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE3(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE3(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, 0, 255);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeUintBE = Buffer6.prototype.writeUIntBE = function writeUIntBE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE3(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE3(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE3(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE3(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE3(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, 0, 255);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeUint8 = Buffer6.prototype.writeUInt8 = function writeUInt83(value, offset = 0) {
  return writeU_Int83(this, value, offset, 0, 255);
};
Buffer6.prototype.writeUint16LE = Buffer6.prototype.writeUInt16LE = function writeUInt16LE3(value, offset = 0) {
  return writeU_Int16LE3(this, value, offset, 0, 65535);
};
Buffer6.prototype.writeUint16BE = Buffer6.prototype.writeUInt16BE = function writeUInt16BE3(value, offset = 0) {
  return writeU_Int16BE3(this, value, offset, 0, 65535);
};
Buffer6.prototype.writeUint32LE = Buffer6.prototype.writeUInt32LE = function writeUInt32LE3(value, offset = 0) {
  return _writeUInt32LE3(this, value, offset, 0, 4294967295);
};
Buffer6.prototype.writeUint32BE = Buffer6.prototype.writeUInt32BE = function writeUInt32BE3(value, offset = 0) {
  return _writeUInt32BE3(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE3(buf, value, offset, min4, max2) {
  checkIntBI3(value, min4, max2, buf, offset, 7);
  let lo2 = Number(value & BigInt(4294967295));
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  lo2 = lo2 >> 8;
  buf[offset++] = lo2;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE3(buf, value, offset, min4, max2) {
  checkIntBI3(value, min4, max2, buf, offset, 7);
  let lo2 = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 6] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 5] = lo2;
  lo2 = lo2 >> 8;
  buf[offset + 4] = lo2;
  let hi = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer6.prototype.writeBigUint64LE = Buffer6.prototype.writeBigUInt64LE = defineBigIntMethod3(function writeBigUInt64LE3(value, offset = 0) {
  return wrtBigUInt64LE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer6.prototype.writeBigUint64BE = Buffer6.prototype.writeBigUInt64BE = defineBigIntMethod3(function writeBigUInt64BE3(value, offset = 0) {
  return wrtBigUInt64BE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer6.prototype.writeIntLE = function writeIntLE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE3(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE3(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE3(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE3(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE3(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, -128, 127);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeIntBE = function writeIntBE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE3(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE3(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE3(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE3(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE3(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, -128, 127);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeInt8 = function writeInt83(value, offset = 0) {
  return writeU_Int83(this, value, offset, -128, 127);
};
Buffer6.prototype.writeInt16LE = function writeInt16LE3(value, offset = 0) {
  return writeU_Int16LE3(this, value, offset, -32768, 32767);
};
Buffer6.prototype.writeInt16BE = function writeInt16BE3(value, offset = 0) {
  return writeU_Int16BE3(this, value, offset, -32768, 32767);
};
Buffer6.prototype.writeInt32LE = function writeInt32LE3(value, offset = 0) {
  return writeU_Int32LE3(this, value, offset, -2147483648, 2147483647);
};
Buffer6.prototype.writeInt32BE = function writeInt32BE3(value, offset = 0) {
  return writeU_Int32BE3(this, value, offset, -2147483648, 2147483647);
};
Buffer6.prototype.writeBigInt64LE = defineBigIntMethod3(function writeBigInt64LE3(value, offset = 0) {
  return wrtBigUInt64LE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer6.prototype.writeBigInt64BE = defineBigIntMethod3(function writeBigInt64BE3(value, offset = 0) {
  return wrtBigUInt64BE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer6.prototype.writeFloatLE = function writeFloatLE3(value, offset) {
  return bigEndian3 ? writeFloatBackwards3(this, value, offset) : writeFloatForwards3(this, value, offset);
};
Buffer6.prototype.writeFloatBE = function writeFloatBE3(value, offset) {
  return bigEndian3 ? writeFloatForwards3(this, value, offset) : writeFloatBackwards3(this, value, offset);
};
Buffer6.prototype.writeDoubleLE = function writeDoubleLE3(value, offset) {
  return bigEndian3 ? writeDoubleBackwards3(this, value, offset) : writeDoubleForwards3(this, value, offset);
};
Buffer6.prototype.writeDoubleBE = function writeDoubleBE3(value, offset) {
  return bigEndian3 ? writeDoubleForwards3(this, value, offset) : writeDoubleBackwards3(this, value, offset);
};
Buffer6.prototype.copy = function copy6(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array3(this)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("source", ["Buffer", "Uint8Array"], this);
  }
  if (!isUint8Array3(target)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger3(targetStart, 0);
    if (targetStart < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger3(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT324) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT324}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger3(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT324) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT324}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer6.prototype.fill = function fill3(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer6.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer6.isBuffer(val) ? val : Buffer6.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes3.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds6(buf, offset, byteLength22) {
  validateNumber3(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
    boundsError3(offset, buf.length - (byteLength22 + 1));
  }
}
function checkIntBI3(value, min4, max2, buf, offset, byteLength22) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength22 > 3) {
      if (min4 === 0 || min4 === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds6(buf, offset, byteLength22);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer3(src, dst, offset, byteLength6) {
  let i;
  const length = byteLength6 === void 0 ? src.length : byteLength6;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance3(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable3 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();
function defineBigIntMethod3(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined3 : fn;
}
function BufferBigIntNotDefined3() {
  throw new Error("BigInt not supported");
}
var atob4 = globalThis.atob;
var Blob4 = globalThis.Blob;
var btoa3 = globalThis.btoa;

// deno:https://deno.land/std@0.146.0/node/internal/util/comparisons.ts
var memo2;
function isDeepStrictEqual2(val1, val2) {
  return innerDeepEqual2(val1, val2, true);
}
function innerDeepEqual2(val1, val2, strict, memos = memo2) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE2 : ONLY_ENUMERABLE2 | SKIP_SYMBOLS2;
    const keys1 = getOwnNonIndexProperties2(val1, filter);
    const keys2 = getOwnNonIndexProperties2(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 1 /* isArray */, keys1);
  } else if (val1Tag === "[object Object]") {
    return keyCheck2(val1, val2, strict, memos, 0 /* noIterator */);
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps2(val1, val2)) {
      return false;
    }
  } else if (isNativeError6(val1) || val1 instanceof Error) {
    if (!isNativeError6(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView3(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) => Object.getOwnPropertySymbols(val).map((item) => item.toString()).toString();
    if (isTypedArray2(val1) && isTypedArray2(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
      return false;
    }
    if (!strict && (isFloat32Array2(val1) || isFloat64Array2(val1))) {
      if (!areSimilarFloatArrays2(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays2(val1, val2)) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE2 : ONLY_ENUMERABLE2 | SKIP_SYMBOLS2;
    const keysVal1 = getOwnNonIndexProperties2(val1, filter);
    const keysVal2 = getOwnNonIndexProperties2(val2, filter);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 0 /* noIterator */, keysVal1);
  } else if (isSet6(val1)) {
    if (!isSet6(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 2 /* isSet */);
  } else if (isMap6(val1)) {
    if (!isMap6(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 3 /* isMap */);
  } else if (isAnyArrayBuffer6(val1)) {
    if (!isAnyArrayBuffer6(val2) || !areEqualArrayBuffers2(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive6(val1)) {
    if (!isEqualBoxedPrimitive2(val1, val2)) {
      return false;
    }
  } else if (Array.isArray(val2) || isArrayBufferView3(val2) || isSet6(val2) || isMap6(val2) || isDate7(val2) || isRegExp7(val2) || isAnyArrayBuffer6(val2) || isBoxedPrimitive6(val2) || isNativeError6(val2) || val2 instanceof Error) {
    return false;
  }
  return keyCheck2(val1, val2, strict, memos, 0 /* noIterator */);
}
function keyCheck2(val1, val2, strict, memos, iterationType, aKeys = []) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key2 = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key2)) {
          if (!val2.propertyIsEnumerable(key2)) {
            return false;
          }
          aKeys.push(key2.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key2)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables2(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB.length !== 0 && getEnumerables2(val2, symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === 0 /* noIterator */ || iterationType === 1 /* isArray */ && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv2(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function areSimilarRegExps2(a, b) {
  return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays2(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays2(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return Buffer6.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers2(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && Buffer6.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive2(a, b) {
  if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
    return false;
  }
  if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
    return false;
  }
  if (isNumberObject6(a)) {
    return isNumberObject6(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
  }
  if (isStringObject6(a)) {
    return isStringObject6(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
  }
  if (isBooleanObject6(a)) {
    return isBooleanObject6(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
  }
  if (isBigIntObject6(a)) {
    return isBigIntObject6(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
  }
  if (isSymbolObject6(a)) {
    return isSymbolObject6(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
  }
  throw Error(`Unknown boxed type`);
}
function getEnumerables2(val, keys) {
  return keys.filter((key2) => val.propertyIsEnumerable(key2));
}
function objEquiv2(obj1, obj2, strict, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === 2 /* isSet */) {
    if (!setEquiv2(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 3 /* isMap */) {
    if (!mapEquiv2(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 1 /* isArray */) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (!obj2.hasOwnProperty(i) || !innerDeepEqual2(obj1[i], obj2[i], strict, memos)) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key2 = keys1[i];
          if (!obj2.hasOwnProperty(key2) || !innerDeepEqual2(obj1[key2], obj2[key2], strict, memos)) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (!innerDeepEqual2(obj1[key2], obj2[key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function findLooseMatchingPrimitives2(primitive) {
  switch (typeof primitive) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      primitive = +primitive;
    case "number":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim2(set1, set2, primitive) {
  const altValue = findLooseMatchingPrimitives2(primitive);
  if (altValue != null)
    return altValue;
  return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement2(set, val1, strict, memos) {
  for (const val2 of set) {
    if (innerDeepEqual2(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function setEquiv2(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === "object" && item !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict)
        return false;
      if (!setMightHaveLoosePrim2(set1, set2, item)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    }
  }
  if (set !== null) {
    for (const item of set2) {
      if (typeof item === "object" && item !== null) {
        if (!setHasEqualElement2(set, item, strict, memos))
          return false;
      } else if (!strict && !set1.has(item) && !setHasEqualElement2(set, item, strict, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapMightHaveLoosePrimitive2(map1, map2, primitive, item, memos) {
  const altValue = findLooseMatchingPrimitives2(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (curB === void 0 && !map2.has(altValue) || !innerDeepEqual2(item, curB, false, memo2)) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual2(item, curB, false, memos);
}
function mapEquiv2(map1, map2, strict, memos) {
  let set = null;
  for (const { 0: key2, 1: item1 } of map1) {
    if (typeof key2 === "object" && key2 !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key2);
    } else {
      const item2 = map2.get(key2);
      if (item2 === void 0 && !map2.has(key2) || !innerDeepEqual2(item1, item2, strict, memos)) {
        if (strict)
          return false;
        if (!mapMightHaveLoosePrimitive2(map1, map2, key2, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      }
    }
  }
  if (set !== null) {
    for (const { 0: key2, 1: item } of map2) {
      if (typeof key2 === "object" && key2 !== null) {
        if (!mapHasEqualEntry2(set, map1, key2, item, strict, memos)) {
          return false;
        }
      } else if (!strict && (!map1.has(key2) || !innerDeepEqual2(map1.get(key2), item, false, memos)) && !mapHasEqualEntry2(set, map1, key2, item, false, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry2(set, map, key1, item1, strict, memos) {
  for (const key2 of set) {
    if (innerDeepEqual2(key1, key2, strict, memos) && innerDeepEqual2(item1, map.get(key2), strict, memos)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}

// deno:https://deno.land/std@0.146.0/node/util.ts
var NumberIsSafeInteger2 = Number.isSafeInteger;
function isArray2(value) {
  return Array.isArray(value);
}
function isBoolean2(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull2(value) {
  return value === null;
}
function isNullOrUndefined2(value) {
  return value === null || value === void 0;
}
function isNumber3(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString2(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol2(value) {
  return typeof value === "symbol";
}
function isUndefined2(value) {
  return value === void 0;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}
function isError3(e) {
  return e instanceof Error;
}
function isFunction2(value) {
  return typeof value === "function";
}
function isRegExp8(value) {
  return types_default5.isRegExp(value);
}
function isDate8(value) {
  return types_default5.isDate(value);
}
function isPrimitive2(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer5(value) {
  return Buffer6.isBuffer(value);
}
function _extend2(target, source) {
  if (source === null || typeof source !== "object")
    return target;
  const keys = Object.keys(source);
  let i = keys.length;
  while (i--) {
    target[keys[i]] = source[keys[i]];
  }
  return target;
}
function getSystemErrorName2(code2) {
  if (typeof code2 !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger2(code2)) {
    throw new codes3.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap2.get(code2)?.[0];
}
function inherits3(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
var TextDecoder3 = _TextDecoder2;
var TextEncoder3 = _TextEncoder2;
function pad2(n) {
  return n.toString().padStart(2, "0");
}
var months2 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp2() {
  const d = new Date();
  const t = [
    pad2(d.getHours()),
    pad2(d.getMinutes()),
    pad2(d.getSeconds())
  ].join(":");
  return `${d.getDate()} ${months2[d.getMonth()]} ${t}`;
}
function log2(...args) {
  console.log("%s - %s", timestamp2(), format7(...args));
}
var util_default2 = {
  format: format7,
  formatWithOptions: formatWithOptions2,
  inspect: inspect5,
  isArray: isArray2,
  isBoolean: isBoolean2,
  isNull: isNull2,
  isNullOrUndefined: isNullOrUndefined2,
  isNumber: isNumber3,
  isString: isString2,
  isSymbol: isSymbol2,
  isUndefined: isUndefined2,
  isObject: isObject2,
  isError: isError3,
  isFunction: isFunction2,
  isRegExp: isRegExp8,
  isDate: isDate8,
  isPrimitive: isPrimitive2,
  isBuffer: isBuffer5,
  _extend: _extend2,
  getSystemErrorName: getSystemErrorName2,
  deprecate: deprecate2,
  callbackify: callbackify2,
  promisify: promisify3,
  inherits: inherits3,
  types: types_default5,
  stripVTControlCharacters: stripVTControlCharacters2,
  TextDecoder: TextDecoder3,
  TextEncoder: TextEncoder3,
  log: log2,
  debuglog: debuglog2,
  isDeepStrictEqual: isDeepStrictEqual2
};

// deno:https://deno.land/std@0.146.0/node/internal/errors.ts
var {
  errno: { ENOTDIR: ENOTDIR2, ENOENT: ENOENT2 }
} = os2;
var kIsNodeError2 = Symbol("kIsNodeError");
var classRegExp4 = /^([A-Z][a-z0-9]*)+$/;
var kTypes2 = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
function addNumericalSeparator2(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace3 = hideStackFrames3(function captureLargerStackTrace4(err) {
  Error.captureStackTrace(err);
  return err;
});
var uvExceptionWithHostPort3 = hideStackFrames3(function uvExceptionWithHostPort4(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet2(err) || uvUnmappedError2;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace3(ex);
});
var errnoException3 = hideStackFrames3(function errnoException4(err, syscall, original) {
  const code2 = getSystemErrorName2(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace3(ex);
});
function uvErrmapGet2(name) {
  return errorMap2.get(name);
}
var uvUnmappedError2 = ["UNKNOWN", "unknown error"];
var uvException3 = hideStackFrames3(function uvException4(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet2(ctx.errno) || uvUnmappedError2;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace3(err);
});
var exceptionWithHostPort3 = hideStackFrames3(function exceptionWithHostPort4(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName2(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace3(ex);
});
var dnsException2 = hideStackFrames3(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap2.get("EAI_NODATA") || code2 === codeMap2.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName2(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace3(ex);
});
var NodeErrorAbstraction2 = class extends Error {
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeURIError = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(URIError.prototype.name, code2, message);
    Object.setPrototypeOf(this, URIError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError2 = class extends NodeErrorAbstraction2 {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace3(this);
    Object.defineProperties(this, {
      [kIsNodeError2]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode2(key2, msgPrfix) {
  return class NodeError extends NodeSystemError2 {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
var ERR_FS_EISDIR2 = makeSystemErrorWithCode2("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType2(name, expected) {
  expected = Array.isArray(expected) ? expected : [expected];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes2.includes(value)) {
      types.push(value.toLocaleLowerCase());
    } else if (classRegExp4.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types.indexOf("object");
    if (pos !== -1) {
      types.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types.length > 0) {
    if (types.length > 2) {
      const last = types.pop();
      msg += `one of type ${types.join(", ")}, or ${last}`;
    } else if (types.length === 2) {
      msg += `one of type ${types[0]} or ${types[1]}`;
    } else {
      msg += `of type ${types[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last = other.pop();
      msg += `one of ${other.join(", ")}, or ${last}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE2 = class extends NodeRangeError2 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType2(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE2 = class extends NodeTypeError2 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType2(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
  }
};
ERR_INVALID_ARG_TYPE2.RangeError = ERR_INVALID_ARG_TYPE_RANGE2;
var ERR_INVALID_ARG_VALUE_RANGE2 = class extends NodeRangeError2 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect5(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE2 = class extends NodeTypeError2 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect5(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
ERR_INVALID_ARG_VALUE2.RangeError = ERR_INVALID_ARG_VALUE_RANGE2;
function invalidArgTypeHelper2(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect5(input, { depth: -1 })}`;
  }
  let inspected = inspect5(input, { colors: false });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE2 = class extends RangeError {
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert4(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator2(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator2(received);
      }
      received += "n";
    } else {
      received = inspect5(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    this.code = "ERR_OUT_OF_RANGE";
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS2 = class extends NodeRangeError2 {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_INVALID_CALLBACK2 = class extends NodeTypeError2 {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect5(object)}`);
  }
};
var ERR_INVALID_URI = class extends NodeURIError {
  constructor() {
    super("ERR_INVALID_URI", `URI malformed`);
  }
};
var ERR_IPC_CHANNEL_CLOSED2 = class extends NodeError2 {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_SOCKET_BAD_PORT2 = class extends NodeRangeError2 {
  constructor(name, port, allowZero = true) {
    assert4(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_UNKNOWN_ENCODING2 = class extends NodeTypeError2 {
  constructor(x) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
  }
};
codes3.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED2;
codes3.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE2;
codes3.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE2;
codes3.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK2;
codes3.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE2;
codes3.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT2;
codes3.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS2;
codes3.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING2;
var genericNodeError3 = hideStackFrames3(function genericNodeError4(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});

// deno:https://deno.land/std@0.146.0/path/_constants.ts
var CHAR_UPPERCASE_A2 = 65;
var CHAR_LOWERCASE_A2 = 97;
var CHAR_UPPERCASE_Z2 = 90;
var CHAR_LOWERCASE_Z2 = 122;
var CHAR_DOT2 = 46;
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_BACKWARD_SLASH2 = 92;
var CHAR_VERTICAL_LINE = 124;
var CHAR_QUESTION_MARK2 = 63;
var CHAR_UNDERSCORE = 95;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_TAB = 9;
var CHAR_FORM_FEED = 12;
var CHAR_HASH = 35;
var CHAR_SPACE = 32;
var CHAR_NO_BREAK_SPACE = 160;
var CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_LEFT_ANGLE_BRACKET = 60;
var CHAR_RIGHT_ANGLE_BRACKET = 62;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var CHAR_HYPHEN_MINUS = 45;
var CHAR_PLUS = 43;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_PERCENT = 37;
var CHAR_SEMICOLON = 59;
var CHAR_CIRCUMFLEX_ACCENT = 94;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_AT = 64;
var CHAR_0 = 48;
var CHAR_9 = 57;

// deno:https://deno.land/std@0.146.0/node/path/mod.ts
var mod_exports3 = {};
__export(mod_exports3, {
  SEP: () => SEP2,
  SEP_PATTERN: () => SEP_PATTERN2,
  basename: () => basename6,
  common: () => common,
  delimiter: () => delimiter6,
  dirname: () => dirname6,
  extname: () => extname6,
  format: () => format10,
  fromFileUrl: () => fromFileUrl6,
  globToRegExp: () => globToRegExp,
  isAbsolute: () => isAbsolute6,
  isGlob: () => isGlob,
  join: () => join11,
  joinGlobs: () => joinGlobs,
  normalize: () => normalize8,
  normalizeGlob: () => normalizeGlob,
  parse: () => parse7,
  posix: () => posix,
  relative: () => relative6,
  resolve: () => resolve6,
  sep: () => sep6,
  toFileUrl: () => toFileUrl6,
  toNamespacedPath: () => toNamespacedPath6,
  win32: () => win32
});

// deno:https://deno.land/std@0.146.0/node/path/win32.ts
var win32_exports2 = {};
__export(win32_exports2, {
  basename: () => basename4,
  default: () => win32_default,
  delimiter: () => delimiter4,
  dirname: () => dirname4,
  extname: () => extname4,
  format: () => format8,
  fromFileUrl: () => fromFileUrl4,
  isAbsolute: () => isAbsolute4,
  join: () => join8,
  normalize: () => normalize5,
  parse: () => parse5,
  relative: () => relative4,
  resolve: () => resolve4,
  sep: () => sep4,
  toFileUrl: () => toFileUrl4,
  toNamespacedPath: () => toNamespacedPath4
});

// deno:https://deno.land/std@0.146.0/node/path/_constants.ts
var CHAR_UPPERCASE_A3 = 65;
var CHAR_LOWERCASE_A3 = 97;
var CHAR_UPPERCASE_Z3 = 90;
var CHAR_LOWERCASE_Z3 = 122;
var CHAR_DOT3 = 46;
var CHAR_FORWARD_SLASH3 = 47;
var CHAR_BACKWARD_SLASH3 = 92;
var CHAR_COLON2 = 58;
var CHAR_QUESTION_MARK3 = 63;

// deno:https://deno.land/std@0.146.0/node/path/_util.ts
function assertPath2(path6) {
  if (typeof path6 !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("path", ["string"], path6);
  }
}
function isPosixPathSeparator2(code2) {
  return code2 === CHAR_FORWARD_SLASH3;
}
function isPathSeparator2(code2) {
  return isPosixPathSeparator2(code2) || code2 === CHAR_BACKWARD_SLASH3;
}
function isWindowsDeviceRoot2(code2) {
  return code2 >= CHAR_LOWERCASE_A3 && code2 <= CHAR_LOWERCASE_Z3 || code2 >= CHAR_UPPERCASE_A3 && code2 <= CHAR_UPPERCASE_Z3;
}
function normalizeString2(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH3;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT3 || res.charCodeAt(res.length - 2) !== CHAR_DOT3) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === CHAR_DOT3 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep7, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base3 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base3;
  if (dir === pathObject.root)
    return dir + base3;
  return dir + sep7 + base3;
}
var WHITESPACE_ENCODINGS2 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace2(string) {
  return string.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS2[c] ?? c;
  });
}

// deno:https://deno.land/std@0.146.0/node/path/win32.ts
var sep4 = "\\";
var delimiter4 = ";";
function resolve4(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno4 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath2(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute7 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator2(code2)) {
        isAbsolute7 = true;
        if (isPathSeparator2(path6.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator2(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path6.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator2(path6.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator2(path6.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot2(code2)) {
        if (path6.charCodeAt(1) === CHAR_COLON2) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator2(path6.charCodeAt(2))) {
              isAbsolute7 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator2(code2)) {
      rootEnd = 1;
      isAbsolute7 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute7;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize5(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute7 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      isAbsolute7 = true;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path6.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path6.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path6.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON2) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            isAbsolute7 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString2(path6.slice(rootEnd), !isAbsolute7, "\\", isPathSeparator2);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute7)
    tail = ".";
  if (tail.length > 0 && isPathSeparator2(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute7) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute7) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute4(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator2(code2)) {
    return true;
  } else if (isWindowsDeviceRoot2(code2)) {
    if (len > 2 && path6.charCodeAt(1) === CHAR_COLON2) {
      if (isPathSeparator2(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join8(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath2(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert4(firstPart != null);
  if (isPathSeparator2(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator2(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator2(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator2(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize5(joined);
}
function relative4(from5, to) {
  assertPath2(from5);
  assertPath2(to);
  if (from5 === to)
    return "";
  const fromOrig = resolve4(from5);
  const toOrig = resolve4(to);
  if (fromOrig === toOrig)
    return "";
  from5 = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from5 === to)
    return "";
  let fromStart = 0;
  let fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from5.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH3) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH3) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH3)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_BACKWARD_SLASH3) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH3)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath4(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve4(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH3) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH3) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK3 && code2 !== CHAR_DOT3) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON2 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH3) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname4(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path6.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path6.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path6;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator2(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename4(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("ext", ["string"], ext);
  }
  assertPath2(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot2(drive)) {
      if (path6.charCodeAt(1) === CHAR_COLON2)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator2(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator2(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname4(path6) {
  assertPath2(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === CHAR_COLON2 && isWindowsDeviceRoot2(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format8(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ERR_INVALID_ARG_TYPE2("pathObject", ["Object"], pathObject);
  }
  return _format2("\\", pathObject);
}
function parse5(path6) {
  assertPath2(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = 1;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path6.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path6.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path6.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl4(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl4(path6) {
  if (!isAbsolute4(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}
var win32_default = {
  basename: basename4,
  delimiter: delimiter4,
  dirname: dirname4,
  extname: extname4,
  format: format8,
  fromFileUrl: fromFileUrl4,
  isAbsolute: isAbsolute4,
  join: join8,
  normalize: normalize5,
  parse: parse5,
  relative: relative4,
  resolve: resolve4,
  sep: sep4,
  toFileUrl: toFileUrl4,
  toNamespacedPath: toNamespacedPath4
};

// deno:https://deno.land/std@0.146.0/node/path/posix.ts
var posix_exports2 = {};
__export(posix_exports2, {
  basename: () => basename5,
  default: () => posix_default,
  delimiter: () => delimiter5,
  dirname: () => dirname5,
  extname: () => extname5,
  format: () => format9,
  fromFileUrl: () => fromFileUrl5,
  isAbsolute: () => isAbsolute5,
  join: () => join9,
  normalize: () => normalize6,
  parse: () => parse6,
  relative: () => relative5,
  resolve: () => resolve5,
  sep: () => sep5,
  toFileUrl: () => toFileUrl5,
  toNamespacedPath: () => toNamespacedPath5
});
var sep5 = "/";
var delimiter5 = ":";
function resolve5(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
    }
    assertPath2(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  }
  resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize6(path6) {
  assertPath2(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === CHAR_FORWARD_SLASH3;
  path6 = normalizeString2(path6, !isAbsolute7, "/", isPosixPathSeparator2);
  if (path6.length === 0 && !isAbsolute7)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute7)
    return `/${path6}`;
  return path6;
}
function isAbsolute5(path6) {
  assertPath2(path6);
  return path6.length > 0 && path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
}
function join9(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath2(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize6(joined);
}
function relative5(from5, to) {
  assertPath2(from5);
  assertPath2(to);
  if (from5 === to)
    return "";
  from5 = resolve5(from5);
  to = resolve5(to);
  if (from5 === to)
    return "";
  let fromStart = 1;
  const fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH3)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH3)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH3) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH3) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH3)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_FORWARD_SLASH3) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH3)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath5(path6) {
  return path6;
}
function dirname5(path6) {
  assertPath2(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH3) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename5(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("ext", ["string"], ext);
  }
  assertPath2(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === CHAR_FORWARD_SLASH3) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH3) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname5(path6) {
  assertPath2(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH3) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format9(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ERR_INVALID_ARG_TYPE2("pathObject", ["Object"], pathObject);
  }
  return _format2("/", pathObject);
}
function parse6(path6) {
  assertPath2(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path6.length === 0)
    return ret;
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  let start;
  if (isAbsolute7) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH3) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute7) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute7) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute7)
    ret.dir = "/";
  return ret;
}
function fromFileUrl5(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl5(path6) {
  if (!isAbsolute5(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}
var posix_default = {
  basename: basename5,
  delimiter: delimiter5,
  dirname: dirname5,
  extname: extname5,
  format: format9,
  fromFileUrl: fromFileUrl5,
  isAbsolute: isAbsolute5,
  join: join9,
  normalize: normalize6,
  parse: parse6,
  relative: relative5,
  resolve: resolve5,
  sep: sep5,
  toFileUrl: toFileUrl5,
  toNamespacedPath: toNamespacedPath5
};

// deno:https://deno.land/std@0.146.0/node/path/separator.ts
var SEP2 = isWindows2 ? "\\" : "/";
var SEP_PATTERN2 = isWindows2 ? /[\\/]+/ : /\/+/;

// deno:https://deno.land/std@0.146.0/node/path/common.ts
function common(paths, sep7 = SEP2) {
  const [first = "", ...remaining] = paths;
  if (first === "" || remaining.length === 0) {
    return first.substring(0, first.lastIndexOf(sep7) + 1);
  }
  const parts = first.split(sep7);
  let endOfPrefix = parts.length;
  for (const path6 of remaining) {
    const compare9 = path6.split(sep7);
    for (let i = 0; i < endOfPrefix; i++) {
      if (compare9[i] !== parts[i]) {
        endOfPrefix = i;
      }
    }
    if (endOfPrefix === 0) {
      return "";
    }
  }
  const prefix = parts.slice(0, endOfPrefix).join(sep7);
  return prefix.endsWith(sep7) ? prefix : `${prefix}${sep7}`;
}

// deno:https://deno.land/std@0.146.0/node/path/glob.ts
var path4 = isWindows2 ? win32_exports2 : posix_exports2;
var { join: join10, normalize: normalize7 } = path4;
var regExpEscapeChars = [
  "!",
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "=",
  "?",
  "[",
  "\\",
  "^",
  "{",
  "|"
];
var rangeEscapeChars = ["-", "\\", "]"];
function globToRegExp(glob, {
  extended = true,
  globstar: globstarOption = true,
  os: os3 = osType2,
  caseInsensitive = false
} = {}) {
  if (glob == "") {
    return /(?!)/;
  }
  const sep7 = os3 == "windows" ? "(?:\\\\|/)+" : "/+";
  const sepMaybe = os3 == "windows" ? "(?:\\\\|/)*" : "/*";
  const seps = os3 == "windows" ? ["\\", "/"] : ["/"];
  const globstar = os3 == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
  const wildcard = os3 == "windows" ? "[^\\\\/]*" : "[^/]*";
  const escapePrefix = os3 == "windows" ? "`" : "\\";
  let newLength = glob.length;
  for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--)
    ;
  glob = glob.slice(0, newLength);
  let regExpString = "";
  for (let j = 0; j < glob.length; ) {
    let segment = "";
    const groupStack = [];
    let inRange = false;
    let inEscape = false;
    let endsWithSep = false;
    let i = j;
    for (; i < glob.length && !seps.includes(glob[i]); i++) {
      if (inEscape) {
        inEscape = false;
        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
        segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        continue;
      }
      if (glob[i] == escapePrefix) {
        inEscape = true;
        continue;
      }
      if (glob[i] == "[") {
        if (!inRange) {
          inRange = true;
          segment += "[";
          if (glob[i + 1] == "!") {
            i++;
            segment += "^";
          } else if (glob[i + 1] == "^") {
            i++;
            segment += "\\^";
          }
          continue;
        } else if (glob[i + 1] == ":") {
          let k3 = i + 1;
          let value = "";
          while (glob[k3 + 1] != null && glob[k3 + 1] != ":") {
            value += glob[k3 + 1];
            k3++;
          }
          if (glob[k3 + 1] == ":" && glob[k3 + 2] == "]") {
            i = k3 + 2;
            if (value == "alnum")
              segment += "\\dA-Za-z";
            else if (value == "alpha")
              segment += "A-Za-z";
            else if (value == "ascii")
              segment += "\0-\x7F";
            else if (value == "blank")
              segment += "	 ";
            else if (value == "cntrl")
              segment += "\0-\x7F";
            else if (value == "digit")
              segment += "\\d";
            else if (value == "graph")
              segment += "!-~";
            else if (value == "lower")
              segment += "a-z";
            else if (value == "print")
              segment += " -~";
            else if (value == "punct") {
              segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_\u2018{|}~`;
            } else if (value == "space")
              segment += "\\s\v";
            else if (value == "upper")
              segment += "A-Z";
            else if (value == "word")
              segment += "\\w";
            else if (value == "xdigit")
              segment += "\\dA-Fa-f";
            continue;
          }
        }
      }
      if (glob[i] == "]" && inRange) {
        inRange = false;
        segment += "]";
        continue;
      }
      if (inRange) {
        if (glob[i] == "\\") {
          segment += `\\\\`;
        } else {
          segment += glob[i];
        }
        continue;
      }
      if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
        segment += ")";
        const type = groupStack.pop();
        if (type == "!") {
          segment += wildcard;
        } else if (type != "@") {
          segment += type;
        }
        continue;
      }
      if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] == "+" && extended && glob[i + 1] == "(") {
        i++;
        groupStack.push("+");
        segment += "(?:";
        continue;
      }
      if (glob[i] == "@" && extended && glob[i + 1] == "(") {
        i++;
        groupStack.push("@");
        segment += "(?:";
        continue;
      }
      if (glob[i] == "?") {
        if (extended && glob[i + 1] == "(") {
          i++;
          groupStack.push("?");
          segment += "(?:";
        } else {
          segment += ".";
        }
        continue;
      }
      if (glob[i] == "!" && extended && glob[i + 1] == "(") {
        i++;
        groupStack.push("!");
        segment += "(?!";
        continue;
      }
      if (glob[i] == "{") {
        groupStack.push("BRACE");
        segment += "(?:";
        continue;
      }
      if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
        groupStack.pop();
        segment += ")";
        continue;
      }
      if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] == "*") {
        if (extended && glob[i + 1] == "(") {
          i++;
          groupStack.push("*");
          segment += "(?:";
        } else {
          const prevChar = glob[i - 1];
          let numStars = 1;
          while (glob[i + 1] == "*") {
            i++;
            numStars++;
          }
          const nextChar = glob[i + 1];
          if (globstarOption && numStars == 2 && [...seps, void 0].includes(prevChar) && [...seps, void 0].includes(nextChar)) {
            segment += globstar;
            endsWithSep = true;
          } else {
            segment += wildcard;
          }
        }
        continue;
      }
      segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
    }
    if (groupStack.length > 0 || inRange || inEscape) {
      segment = "";
      for (const c of glob.slice(j, i)) {
        segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
        endsWithSep = false;
      }
    }
    regExpString += segment;
    if (!endsWithSep) {
      regExpString += i < glob.length ? sep7 : sepMaybe;
      endsWithSep = true;
    }
    while (seps.includes(glob[i]))
      i++;
    if (!(i > j)) {
      throw new Error("Assertion failure: i > j (potential infinite loop)");
    }
    j = i;
  }
  regExpString = `^${regExpString}$`;
  return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
  const chars = { "{": "}", "(": ")", "[": "]" };
  const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if (str === "") {
    return false;
  }
  let match;
  while (match = regex.exec(str)) {
    if (match[2])
      return true;
    let idx = match.index + match[0].length;
    const open = match[1];
    const close = open ? chars[open] : null;
    if (open && close) {
      const n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }
    str = str.slice(idx);
  }
  return false;
}
function normalizeGlob(glob, { globstar = false } = {}) {
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize7(glob);
  }
  const s = SEP_PATTERN2.source;
  const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
  return normalize7(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended = true, globstar = false } = {}) {
  if (!globstar || globs.length == 0) {
    return join10(...globs);
  }
  if (globs.length === 0)
    return ".";
  let joined;
  for (const glob of globs) {
    const path6 = glob;
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `${SEP2}${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalizeGlob(joined, { extended, globstar });
}

// deno:https://deno.land/std@0.146.0/node/path/mod.ts
var path5 = isWindows2 ? win32_default : posix_default;
var win32 = win32_default;
var posix = posix_default;
var {
  basename: basename6,
  delimiter: delimiter6,
  dirname: dirname6,
  extname: extname6,
  format: format10,
  fromFileUrl: fromFileUrl6,
  isAbsolute: isAbsolute6,
  join: join11,
  normalize: normalize8,
  parse: parse7,
  relative: relative6,
  resolve: resolve6,
  sep: sep6,
  toFileUrl: toFileUrl6,
  toNamespacedPath: toNamespacedPath6
} = path5;

// deno:https://deno.land/std@0.146.0/node/path.ts
var path_default = { ...mod_exports3 };

// deno:https://deno.land/std@0.146.0/node/internal/idna.ts
var maxInt = 2147483647;
var base2 = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter7 = "-";
var regexNonASCII = /[^\0-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base2 - tMin;
function error2(type) {
  throw new RangeError(errors[type]);
}
function mapDomain(str, fn) {
  const parts = str.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    str = parts[1];
  }
  str = str.replace(regexSeparators, ".");
  const labels = str.split(".");
  const encoded = labels.map(fn).join(".");
  return result + encoded;
}
function ucs2decode(str) {
  const output = [];
  let counter = 0;
  const length = str.length;
  while (counter < length) {
    const value = str.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = str.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  let k3 = 0;
  delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
  delta += Math.floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k3 += base2) {
    delta = Math.floor(delta / baseMinusTMin);
  }
  return Math.floor(k3 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode13(str) {
  const output = [];
  const input = ucs2decode(str);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(String.fromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter7);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > Math.floor((maxInt - delta) / handledCPCountPlusOne)) {
      error2("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error2("overflow");
      }
      if (currentValue == n) {
        let q = delta;
        for (let k3 = base2; ; k3 += base2) {
          const t = k3 <= bias ? tMin : k3 >= bias + tMax ? tMax : k3 - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base2 - t;
          output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
          q = Math.floor(qMinusT / baseMinusT);
        }
        output.push(String.fromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(str) {
    return regexNonASCII.test(str) ? "xn--" + encode13(str) : str;
  });
}

// deno:https://deno.land/std@0.146.0/node/internal/querystring.ts
var hexTable2 = new Array(256);
for (let i = 0; i < 256; ++i) {
  hexTable2[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
}
var isHexTable = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function encodeStr2(str, noEscapeTable, hexTable3) {
  const len = str.length;
  if (len === 0)
    return "";
  let out = "";
  let lastPos = 0;
  for (let i = 0; i < len; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      if (noEscapeTable[c] === 1)
        continue;
      if (lastPos < i)
        out += str.slice(lastPos, i);
      lastPos = i + 1;
      out += hexTable3[c];
      continue;
    }
    if (lastPos < i)
      out += str.slice(lastPos, i);
    if (c < 2048) {
      lastPos = i + 1;
      out += hexTable3[192 | c >> 6] + hexTable3[128 | c & 63];
      continue;
    }
    if (c < 55296 || c >= 57344) {
      lastPos = i + 1;
      out += hexTable3[224 | c >> 12] + hexTable3[128 | c >> 6 & 63] + hexTable3[128 | c & 63];
      continue;
    }
    ++i;
    if (i >= len)
      throw new ERR_INVALID_URI();
    const c2 = str.charCodeAt(i) & 1023;
    lastPos = i + 1;
    c = 65536 + ((c & 1023) << 10 | c2);
    out += hexTable3[240 | c >> 18] + hexTable3[128 | c >> 12 & 63] + hexTable3[128 | c >> 6 & 63] + hexTable3[128 | c & 63];
  }
  if (lastPos === 0)
    return str;
  if (lastPos < len)
    return out + str.slice(lastPos);
  return out;
}

// deno:https://deno.land/std@0.146.0/node/querystring.ts
var decode11 = parse8;
var encode14 = stringify;
function qsEscape(str) {
  if (typeof str !== "string") {
    if (typeof str === "object") {
      str = String(str);
    } else {
      str += "";
    }
  }
  return encodeStr2(str, noEscape, hexTable2);
}
var escape = qsEscape;
var isHexTable2 = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function charCodes(str) {
  const ret = new Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode14) {
  if (key2.length > 0 && keyEncoded) {
    key2 = decode14(key2);
  }
  if (value.length > 0 && valEncoded) {
    value = decode14(value);
  }
  if (obj2[key2] === void 0) {
    obj2[key2] = value;
  } else {
    const curValue = obj2[key2];
    if (curValue.pop) {
      curValue[curValue.length] = value;
    } else {
      obj2[key2] = [curValue, value];
    }
  }
}
function parse8(str, sep7 = "&", eq2 = "=", { decodeURIComponent: decodeURIComponent2 = unescape, maxKeys = 1e3 } = {}) {
  const obj2 = /* @__PURE__ */ Object.create(null);
  if (typeof str !== "string" || str.length === 0) {
    return obj2;
  }
  const sepCodes = !sep7 ? [38] : charCodes(String(sep7));
  const eqCodes = !eq2 ? [61] : charCodes(String(eq2));
  const sepLen = sepCodes.length;
  const eqLen = eqCodes.length;
  let pairs = 1e3;
  if (typeof maxKeys === "number") {
    pairs = maxKeys > 0 ? maxKeys : -1;
  }
  let decode14 = unescape;
  if (decodeURIComponent2) {
    decode14 = decodeURIComponent2;
  }
  const customDecode = decode14 !== unescape;
  let lastPos = 0;
  let sepIdx = 0;
  let eqIdx = 0;
  let key2 = "";
  let value = "";
  let keyEncoded = customDecode;
  let valEncoded = customDecode;
  const plusChar = customDecode ? "%20" : " ";
  let encodeCheck = 0;
  for (let i = 0; i < str.length; ++i) {
    const code2 = str.charCodeAt(i);
    if (code2 === sepCodes[sepIdx]) {
      if (++sepIdx === sepLen) {
        const end = i - sepIdx + 1;
        if (eqIdx < eqLen) {
          if (lastPos < end) {
            key2 += str.slice(lastPos, end);
          } else if (key2.length === 0) {
            if (--pairs === 0) {
              return obj2;
            }
            lastPos = i + 1;
            sepIdx = eqIdx = 0;
            continue;
          }
        } else if (lastPos < end) {
          value += str.slice(lastPos, end);
        }
        addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode14);
        if (--pairs === 0) {
          return obj2;
        }
        key2 = value = "";
        encodeCheck = 0;
        lastPos = i + 1;
        sepIdx = eqIdx = 0;
      }
    } else {
      sepIdx = 0;
      if (eqIdx < eqLen) {
        if (code2 === eqCodes[eqIdx]) {
          if (++eqIdx === eqLen) {
            const end = i - eqIdx + 1;
            if (lastPos < end) {
              key2 += str.slice(lastPos, end);
            }
            encodeCheck = 0;
            lastPos = i + 1;
          }
          continue;
        } else {
          eqIdx = 0;
          if (!keyEncoded) {
            if (code2 === 37) {
              encodeCheck = 1;
              continue;
            } else if (encodeCheck > 0) {
              if (isHexTable2[code2] === 1) {
                if (++encodeCheck === 3) {
                  keyEncoded = true;
                }
                continue;
              } else {
                encodeCheck = 0;
              }
            }
          }
        }
        if (code2 === 43) {
          if (lastPos < i) {
            key2 += str.slice(lastPos, i);
          }
          key2 += plusChar;
          lastPos = i + 1;
          continue;
        }
      }
      if (code2 === 43) {
        if (lastPos < i) {
          value += str.slice(lastPos, i);
        }
        value += plusChar;
        lastPos = i + 1;
      } else if (!valEncoded) {
        if (code2 === 37) {
          encodeCheck = 1;
        } else if (encodeCheck > 0) {
          if (isHexTable2[code2] === 1) {
            if (++encodeCheck === 3) {
              valEncoded = true;
            }
          } else {
            encodeCheck = 0;
          }
        }
      }
    }
  }
  if (lastPos < str.length) {
    if (eqIdx < eqLen) {
      key2 += str.slice(lastPos);
    } else if (sepIdx < sepLen) {
      value += str.slice(lastPos);
    }
  } else if (eqIdx === 0 && key2.length === 0) {
    return obj2;
  }
  addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode14);
  return obj2;
}
var noEscape = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
]);
function stringifyPrimitive(v) {
  if (typeof v === "string") {
    return v;
  }
  if (typeof v === "number" && isFinite(v)) {
    return "" + v;
  }
  if (typeof v === "bigint") {
    return "" + v;
  }
  if (typeof v === "boolean") {
    return v ? "true" : "false";
  }
  return "";
}
function encodeStringifiedCustom(v, encode17) {
  return encode17(stringifyPrimitive(v));
}
function encodeStringified(v, encode17) {
  if (typeof v === "string") {
    return v.length ? encode17(v) : "";
  }
  if (typeof v === "number" && isFinite(v)) {
    return Math.abs(v) < 1e21 ? "" + v : encode17("" + v);
  }
  if (typeof v === "bigint") {
    return "" + v;
  }
  if (typeof v === "boolean") {
    return v ? "true" : "false";
  }
  return "";
}
function stringify(obj2, sep7, eq2, options) {
  sep7 ||= "&";
  eq2 ||= "=";
  const encode17 = options ? options.encodeURIComponent : qsEscape;
  const convert = options ? encodeStringifiedCustom : encodeStringified;
  if (obj2 !== null && typeof obj2 === "object") {
    const keys = Object.keys(obj2);
    const len = keys.length;
    let fields = "";
    for (let i = 0; i < len; ++i) {
      const k3 = keys[i];
      const v = obj2[k3];
      let ks2 = convert(k3, encode17);
      ks2 += eq2;
      if (Array.isArray(v)) {
        const vlen = v.length;
        if (vlen === 0)
          continue;
        if (fields) {
          fields += sep7;
        }
        for (let j = 0; j < vlen; ++j) {
          if (j) {
            fields += sep7;
          }
          fields += ks2;
          fields += convert(v[j], encode17);
        }
      } else {
        if (fields) {
          fields += sep7;
        }
        fields += ks2;
        fields += convert(v, encode17);
      }
    }
    return fields;
  }
  return "";
}
var unhexTable = new Int8Array([
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
  const out = new Buffer6(s.length);
  let index = 0;
  let outIndex = 0;
  let currentChar;
  let nextChar;
  let hexHigh;
  let hexLow;
  const maxLength = s.length - 2;
  let hasHex = false;
  while (index < s.length) {
    currentChar = s.charCodeAt(index);
    if (currentChar === 43 && decodeSpaces) {
      out[outIndex++] = 32;
      index++;
      continue;
    }
    if (currentChar === 37 && index < maxLength) {
      currentChar = s.charCodeAt(++index);
      hexHigh = unhexTable[currentChar];
      if (!(hexHigh >= 0)) {
        out[outIndex++] = 37;
        continue;
      } else {
        nextChar = s.charCodeAt(++index);
        hexLow = unhexTable[nextChar];
        if (!(hexLow >= 0)) {
          out[outIndex++] = 37;
          index--;
        } else {
          hasHex = true;
          currentChar = hexHigh * 16 + hexLow;
        }
      }
    }
    out[outIndex++] = currentChar;
    index++;
  }
  return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
  try {
    return decodeURIComponent(s);
  } catch {
    return unescapeBuffer(s).toString();
  }
}
var unescape = qsUnescape;
var querystring_default = {
  parse: parse8,
  stringify,
  decode: decode11,
  encode: encode14,
  unescape,
  escape,
  unescapeBuffer
};

// deno:https://deno.land/std@0.146.0/node/url.ts
var protocolPattern = /^[a-z0-9.+-]+:/i;
var portPattern = /:[0-9]*$/;
var hostPattern = /^\/\/[^@/]+@[^@/]+/;
var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
var unsafeProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
var hostlessProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
var slashedProtocol = /* @__PURE__ */ new Set([
  "http",
  "http:",
  "https",
  "https:",
  "ftp",
  "ftp:",
  "gopher",
  "gopher:",
  "file",
  "file:",
  "ws",
  "ws:",
  "wss",
  "wss:"
]);
var hostnameMaxLen = 255;
var noEscapeAuth = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
]);
var Url = class {
  constructor() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  #parseHost() {
    let host = this.host || "";
    let port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.slice(1);
      }
      host = host.slice(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  }
  resolve(relative7) {
    return this.resolveObject(parse9(relative7, false, true)).format();
  }
  resolveObject(relative7) {
    if (typeof relative7 === "string") {
      const rel = new Url();
      rel.urlParse(relative7, false, true);
      relative7 = rel;
    }
    const result = new Url();
    const tkeys = Object.keys(this);
    for (let tk = 0; tk < tkeys.length; tk++) {
      const tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative7.hash;
    if (relative7.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative7.slashes && !relative7.protocol) {
      const rkeys = Object.keys(relative7);
      for (let rk = 0; rk < rkeys.length; rk++) {
        const rkey = rkeys[rk];
        if (rkey !== "protocol")
          result[rkey] = relative7[rkey];
      }
      if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
        result.path = result.pathname = "/";
      }
      result.href = result.format();
      return result;
    }
    if (relative7.protocol && relative7.protocol !== result.protocol) {
      if (!slashedProtocol.has(relative7.protocol)) {
        const keys = Object.keys(relative7);
        for (let v = 0; v < keys.length; v++) {
          const k3 = keys[v];
          result[k3] = relative7[k3];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative7.protocol;
      if (!relative7.host && !/^file:?$/.test(relative7.protocol) && !hostlessProtocol.has(relative7.protocol)) {
        const relPath2 = (relative7.pathname || "").split("/");
        while (relPath2.length && !(relative7.host = relPath2.shift() || null))
          ;
        if (!relative7.host)
          relative7.host = "";
        if (!relative7.hostname)
          relative7.hostname = "";
        if (relPath2[0] !== "")
          relPath2.unshift("");
        if (relPath2.length < 2)
          relPath2.unshift("");
        result.pathname = relPath2.join("/");
      } else {
        result.pathname = relative7.pathname;
      }
      result.search = relative7.search;
      result.query = relative7.query;
      result.host = relative7.host || "";
      result.auth = relative7.auth;
      result.hostname = relative7.hostname || relative7.host;
      result.port = relative7.port;
      if (result.pathname || result.search) {
        const p = result.pathname || "";
        const s = result.search || "";
        result.path = p + s;
      }
      result.slashes = result.slashes || relative7.slashes;
      result.href = result.format();
      return result;
    }
    const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
    const isRelAbs = relative7.host || relative7.pathname && relative7.pathname.charAt(0) === "/";
    let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative7.pathname;
    const removeAllDots = mustEndAbs;
    let srcPath = result.pathname && result.pathname.split("/") || [];
    const relPath = relative7.pathname && relative7.pathname.split("/") || [];
    const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
    if (noLeadingSlashes) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative7.protocol) {
        relative7.hostname = null;
        relative7.port = null;
        result.auth = null;
        if (relative7.host) {
          if (relPath[0] === "")
            relPath[0] = relative7.host;
          else
            relPath.unshift(relative7.host);
        }
        relative7.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      if (relative7.host || relative7.host === "") {
        if (result.host !== relative7.host)
          result.auth = null;
        result.host = relative7.host;
        result.port = relative7.port;
      }
      if (relative7.hostname || relative7.hostname === "") {
        if (result.hostname !== relative7.hostname)
          result.auth = null;
        result.hostname = relative7.hostname;
      }
      result.search = relative7.search;
      result.query = relative7.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative7.search;
      result.query = relative7.query;
    } else if (relative7.search !== null && relative7.search !== void 0) {
      if (noLeadingSlashes) {
        result.hostname = result.host = srcPath.shift() || null;
        const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
        if (authInHost) {
          result.auth = authInHost.shift() || null;
          result.host = result.hostname = authInHost.shift() || null;
        }
      }
      result.search = relative7.search;
      result.query = relative7.query;
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    let last = srcPath.slice(-1)[0];
    const hasTrailingSlash = (result.host || relative7.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    let up = 0;
    for (let i = srcPath.length - 1; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      while (up--) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    const isAbsolute7 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (noLeadingSlashes) {
      result.hostname = result.host = isAbsolute7 ? "" : srcPath.length ? srcPath.shift() || null : "";
      const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift() || null;
        result.host = result.hostname = authInHost.shift() || null;
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute7) {
      srcPath.unshift("");
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join("/");
    }
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative7.auth || result.auth;
    result.slashes = result.slashes || relative7.slashes;
    result.href = result.format();
    return result;
  }
  format() {
    let auth = this.auth || "";
    if (auth) {
      auth = encodeStr2(auth, noEscapeAuth, hexTable2);
      auth += "@";
    }
    let protocol = this.protocol || "";
    let pathname = this.pathname || "";
    let hash = this.hash || "";
    let host = "";
    let query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query !== null && typeof this.query === "object") {
      query = querystring_default.stringify(this.query);
    }
    let search = this.search || query && "?" + query || "";
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
      protocol += ":";
    }
    let newPathname = "";
    let lastPos = 0;
    for (let i = 0; i < pathname.length; ++i) {
      switch (pathname.charCodeAt(i)) {
        case CHAR_HASH:
          if (i - lastPos > 0) {
            newPathname += pathname.slice(lastPos, i);
          }
          newPathname += "%23";
          lastPos = i + 1;
          break;
        case CHAR_QUESTION_MARK2:
          if (i - lastPos > 0) {
            newPathname += pathname.slice(lastPos, i);
          }
          newPathname += "%3F";
          lastPos = i + 1;
          break;
      }
    }
    if (lastPos > 0) {
      if (lastPos !== pathname.length) {
        pathname = newPathname + pathname.slice(lastPos);
      } else
        pathname = newPathname;
    }
    if (this.slashes || slashedProtocol.has(protocol)) {
      if (this.slashes || host) {
        if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH2) {
          pathname = "/" + pathname;
        }
        host = "//" + host;
      } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
        host = "//";
      }
    }
    search = search.replace(/#/g, "%23");
    if (hash && hash.charCodeAt(0) !== CHAR_HASH) {
      hash = "#" + hash;
    }
    if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK2) {
      search = "?" + search;
    }
    return protocol + host + pathname + search + hash;
  }
  urlParse(url, parseQueryString, slashesDenoteHost) {
    let hasHash = false;
    let start = -1;
    let end = -1;
    let rest = "";
    let lastPos = 0;
    for (let i = 0, inWs = false, split3 = false; i < url.length; ++i) {
      const code2 = url.charCodeAt(i);
      const isWs = code2 === CHAR_SPACE || code2 === CHAR_TAB || code2 === CHAR_CARRIAGE_RETURN || code2 === CHAR_LINE_FEED || code2 === CHAR_FORM_FEED || code2 === CHAR_NO_BREAK_SPACE || code2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE;
      if (start === -1) {
        if (isWs)
          continue;
        lastPos = start = i;
      } else if (inWs) {
        if (!isWs) {
          end = -1;
          inWs = false;
        }
      } else if (isWs) {
        end = i;
        inWs = true;
      }
      if (!split3) {
        switch (code2) {
          case CHAR_HASH:
            hasHash = true;
          case CHAR_QUESTION_MARK2:
            split3 = true;
            break;
          case CHAR_BACKWARD_SLASH2:
            if (i - lastPos > 0)
              rest += url.slice(lastPos, i);
            rest += "/";
            lastPos = i + 1;
            break;
        }
      } else if (!hasHash && code2 === CHAR_HASH) {
        hasHash = true;
      }
    }
    if (start !== -1) {
      if (lastPos === start) {
        if (end === -1) {
          if (start === 0)
            rest = url;
          else
            rest = url.slice(start);
        } else {
          rest = url.slice(start, end);
        }
      } else if (end === -1 && lastPos < url.length) {
        rest += url.slice(lastPos);
      } else if (end !== -1 && lastPos < end) {
        rest += url.slice(lastPos, end);
      }
    }
    if (!slashesDenoteHost && !hasHash) {
      const simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring_default.parse(this.search.slice(1));
          } else {
            this.query = this.search.slice(1);
          }
        } else if (parseQueryString) {
          this.search = null;
          this.query = /* @__PURE__ */ Object.create(null);
        }
        return this;
      }
    }
    let proto = protocolPattern.exec(rest);
    let lowerProto = "";
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.slice(proto.length);
    }
    let slashes;
    if (slashesDenoteHost || proto || hostPattern.test(rest)) {
      slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH2 && rest.charCodeAt(1) === CHAR_FORWARD_SLASH2;
      if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
        rest = rest.slice(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
      let hostEnd = -1;
      let atSign = -1;
      let nonHost = -1;
      for (let i = 0; i < rest.length; ++i) {
        switch (rest.charCodeAt(i)) {
          case CHAR_TAB:
          case CHAR_LINE_FEED:
          case CHAR_CARRIAGE_RETURN:
          case CHAR_SPACE:
          case CHAR_DOUBLE_QUOTE:
          case CHAR_PERCENT:
          case CHAR_SINGLE_QUOTE:
          case CHAR_SEMICOLON:
          case CHAR_LEFT_ANGLE_BRACKET:
          case CHAR_RIGHT_ANGLE_BRACKET:
          case CHAR_BACKWARD_SLASH2:
          case CHAR_CIRCUMFLEX_ACCENT:
          case CHAR_GRAVE_ACCENT:
          case CHAR_LEFT_CURLY_BRACKET:
          case CHAR_VERTICAL_LINE:
          case CHAR_RIGHT_CURLY_BRACKET:
            if (nonHost === -1)
              nonHost = i;
            break;
          case CHAR_HASH:
          case CHAR_FORWARD_SLASH2:
          case CHAR_QUESTION_MARK2:
            if (nonHost === -1)
              nonHost = i;
            hostEnd = i;
            break;
          case CHAR_AT:
            atSign = i;
            nonHost = -1;
            break;
        }
        if (hostEnd !== -1)
          break;
      }
      start = 0;
      if (atSign !== -1) {
        this.auth = decodeURIComponent(rest.slice(0, atSign));
        start = atSign + 1;
      }
      if (nonHost === -1) {
        this.host = rest.slice(start);
        rest = "";
      } else {
        this.host = rest.slice(start, nonHost);
        rest = rest.slice(nonHost);
      }
      this.#parseHost();
      if (typeof this.hostname !== "string")
        this.hostname = "";
      const hostname = this.hostname;
      const ipv6Hostname = isIpv6Hostname(hostname);
      if (!ipv6Hostname) {
        rest = getHostname(this, rest, hostname);
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = toASCII(this.hostname);
      }
      const p = this.port ? ":" + this.port : "";
      const h = this.hostname || "";
      this.host = h + p;
      if (ipv6Hostname) {
        this.hostname = this.hostname.slice(1, -1);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol.has(lowerProto)) {
      rest = autoEscapeStr(rest);
    }
    let questionIdx = -1;
    let hashIdx = -1;
    for (let i = 0; i < rest.length; ++i) {
      const code2 = rest.charCodeAt(i);
      if (code2 === CHAR_HASH) {
        this.hash = rest.slice(i);
        hashIdx = i;
        break;
      } else if (code2 === CHAR_QUESTION_MARK2 && questionIdx === -1) {
        questionIdx = i;
      }
    }
    if (questionIdx !== -1) {
      if (hashIdx === -1) {
        this.search = rest.slice(questionIdx);
        this.query = rest.slice(questionIdx + 1);
      } else {
        this.search = rest.slice(questionIdx, hashIdx);
        this.query = rest.slice(questionIdx + 1, hashIdx);
      }
      if (parseQueryString) {
        this.query = querystring_default.parse(this.query);
      }
    } else if (parseQueryString) {
      this.search = null;
      this.query = /* @__PURE__ */ Object.create(null);
    }
    const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
    const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
    if (firstIdx === -1) {
      if (rest.length > 0)
        this.pathname = rest;
    } else if (firstIdx > 0) {
      this.pathname = rest.slice(0, firstIdx);
    }
    if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      const p = this.pathname || "";
      const s = this.search || "";
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  }
};
function isIpv6Hostname(hostname) {
  return hostname.charCodeAt(0) === CHAR_LEFT_SQUARE_BRACKET && hostname.charCodeAt(hostname.length - 1) === CHAR_RIGHT_SQUARE_BRACKET;
}
function getHostname(self2, rest, hostname) {
  for (let i = 0; i < hostname.length; ++i) {
    const code2 = hostname.charCodeAt(i);
    const isValid = code2 >= CHAR_LOWERCASE_A2 && code2 <= CHAR_LOWERCASE_Z2 || code2 === CHAR_DOT2 || code2 >= CHAR_UPPERCASE_A2 && code2 <= CHAR_UPPERCASE_Z2 || code2 >= CHAR_0 && code2 <= CHAR_9 || code2 === CHAR_HYPHEN_MINUS || code2 === CHAR_PLUS || code2 === CHAR_UNDERSCORE || code2 > 127;
    if (!isValid) {
      self2.hostname = hostname.slice(0, i);
      return `/${hostname.slice(i)}${rest}`;
    }
  }
  return rest;
}
var escapedCodes = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%09",
  "%0A",
  "",
  "",
  "%0D",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%20",
  "",
  "%22",
  "",
  "",
  "",
  "",
  "%27",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%3C",
  "",
  "%3E",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%5C",
  "",
  "%5E",
  "",
  "%60",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%7B",
  "%7C",
  "%7D"
];
function autoEscapeStr(rest) {
  let escaped = "";
  let lastEscapedPos = 0;
  for (let i = 0; i < rest.length; ++i) {
    const escapedChar = escapedCodes[rest.charCodeAt(i)];
    if (escapedChar) {
      if (i > lastEscapedPos) {
        escaped += rest.slice(lastEscapedPos, i);
      }
      escaped += escapedChar;
      lastEscapedPos = i + 1;
    }
  }
  if (lastEscapedPos === 0) {
    return rest;
  }
  if (lastEscapedPos < rest.length) {
    escaped += rest.slice(lastEscapedPos);
  }
  return escaped;
}
function parse9(url, parseQueryString, slashesDenoteHost) {
  if (url instanceof Url)
    return url;
  const urlObject = new Url();
  urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
  return urlObject;
}

// deno:https://deno.land/x/jose@v3.19.0/lib/buffer_utils.ts
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;
function concat6(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}

// deno:https://deno.land/x/jose@v3.19.0/runtime/global.ts
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  throw new Error("unable to locate global object");
}
var global_default = getGlobal();
function isCloudflareWorkers() {
  try {
    return getGlobal().WebSocketPair !== void 0;
  } catch {
    return false;
  }
}
function isNodeJs() {
  try {
    return getGlobal().process?.versions?.node !== void 0;
  } catch {
    return false;
  }
}

// deno:https://deno.land/x/jose@v3.19.0/runtime/base64url.ts
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return global_default.btoa(arr.join(""));
};
var encode15 = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};

// deno:https://deno.land/x/jose@v3.19.0/util/errors.ts
var _JOSEError = class extends Error {
  constructor(message) {
    super(message);
    this.code = _JOSEError.code;
    this.name = this.constructor.name;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var JOSEError = _JOSEError;
JOSEError.code = "ERR_JOSE_GENERIC";
var _JWTClaimValidationFailed = class extends JOSEError {
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = _JWTClaimValidationFailed.code;
    this.claim = claim;
    this.reason = reason;
  }
};
var JWTClaimValidationFailed = _JWTClaimValidationFailed;
JWTClaimValidationFailed.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
var _JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JOSEAlgNotAllowed.code;
  }
};
var JOSEAlgNotAllowed = _JOSEAlgNotAllowed;
JOSEAlgNotAllowed.code = "ERR_JOSE_ALG_NOT_ALLOWED";
var _JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JOSENotSupported.code;
  }
};
var JOSENotSupported = _JOSENotSupported;
JOSENotSupported.code = "ERR_JOSE_NOT_SUPPORTED";
var _JWEDecryptionFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWEDecryptionFailed.code;
    this.message = "decryption operation failed";
  }
};
var JWEDecryptionFailed = _JWEDecryptionFailed;
JWEDecryptionFailed.code = "ERR_JWE_DECRYPTION_FAILED";
var _JWEInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWEInvalid.code;
  }
};
var JWEInvalid = _JWEInvalid;
JWEInvalid.code = "ERR_JWE_INVALID";
var _JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWSInvalid.code;
  }
};
var JWSInvalid = _JWSInvalid;
JWSInvalid.code = "ERR_JWS_INVALID";
var _JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWTInvalid.code;
  }
};
var JWTInvalid = _JWTInvalid;
JWTInvalid.code = "ERR_JWT_INVALID";
var _JWKInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWKInvalid.code;
  }
};
var JWKInvalid = _JWKInvalid;
JWKInvalid.code = "ERR_JWK_INVALID";
var _JWKSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWKSInvalid.code;
  }
};
var JWKSInvalid = _JWKSInvalid;
JWKSInvalid.code = "ERR_JWKS_INVALID";
var _JWKSNoMatchingKey = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWKSNoMatchingKey.code;
    this.message = "no applicable key found in the JSON Web Key Set";
  }
};
var JWKSNoMatchingKey = _JWKSNoMatchingKey;
JWKSNoMatchingKey.code = "ERR_JWKS_NO_MATCHING_KEY";
var _JWKSMultipleMatchingKeys = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWKSMultipleMatchingKeys.code;
    this.message = "multiple matching keys found in the JSON Web Key Set";
  }
};
var JWKSMultipleMatchingKeys = _JWKSMultipleMatchingKeys;
JWKSMultipleMatchingKeys.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
var _JWSSignatureVerificationFailed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = _JWSSignatureVerificationFailed.code;
    this.message = "signature verification failed";
  }
};
var JWSSignatureVerificationFailed = _JWSSignatureVerificationFailed;
JWSSignatureVerificationFailed.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
var _JWTExpired = class extends JWTClaimValidationFailed {
  constructor() {
    super(...arguments);
    this.code = _JWTExpired.code;
  }
};
var JWTExpired = _JWTExpired;
JWTExpired.code = "ERR_JWT_EXPIRED";

// deno:https://deno.land/x/jose@v3.19.0/runtime/subtle_dsa.ts
function subtleDsa(alg, crv) {
  switch (alg) {
    case "HS256":
      return { hash: { name: "SHA-256" }, name: "HMAC" };
    case "HS384":
      return { hash: { name: "SHA-384" }, name: "HMAC" };
    case "HS512":
      return { hash: { name: "SHA-512" }, name: "HMAC" };
    case "PS256":
      return {
        hash: { name: "SHA-256" },
        name: "RSA-PSS",
        saltLength: 256 >> 3
      };
    case "PS384":
      return {
        hash: { name: "SHA-384" },
        name: "RSA-PSS",
        saltLength: 384 >> 3
      };
    case "PS512":
      return {
        hash: { name: "SHA-512" },
        name: "RSA-PSS",
        saltLength: 512 >> 3
      };
    case "RS256":
      return { hash: { name: "SHA-256" }, name: "RSASSA-PKCS1-v1_5" };
    case "RS384":
      return { hash: { name: "SHA-384" }, name: "RSASSA-PKCS1-v1_5" };
    case "RS512":
      return { hash: { name: "SHA-512" }, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
      return { hash: { name: "SHA-256" }, name: "ECDSA", namedCurve: "P-256" };
    case "ES384":
      return { hash: { name: "SHA-384" }, name: "ECDSA", namedCurve: "P-384" };
    case "ES512":
      return { hash: { name: "SHA-512" }, name: "ECDSA", namedCurve: "P-521" };
    case ((isCloudflareWorkers() || isNodeJs()) && "EdDSA"):
      return { name: crv, namedCurve: crv };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// deno:https://deno.land/x/jose@v3.19.0/runtime/webcrypto.ts
var webcrypto_default = global_default.crypto;
function isCryptoKey4(key2) {
  if (typeof global_default.CryptoKey === "undefined") {
    return false;
  }
  return key2 != null && key2 instanceof global_default.CryptoKey;
}

// deno:https://deno.land/x/jose@v3.19.0/runtime/check_key_length.ts
var check_key_length_default = (alg, key2) => {
  if (alg.startsWith("HS")) {
    const bitlen = parseInt(alg.substr(-3), 10);
    const { length } = key2.algorithm;
    if (typeof length !== "number" || length < bitlen) {
      throw new TypeError(`${alg} requires symmetric keys to be ${bitlen} bits or larger`);
    }
  }
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key2.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// deno:https://deno.land/x/jose@v3.19.0/runtime/invalid_key_input.ts
var invalid_key_input_default = (actual, ...types) => {
  let msg = "Key must be ";
  if (types.length > 2) {
    const last = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
};

// deno:https://deno.land/x/jose@v3.19.0/runtime/get_sign_verify_key.ts
function getCryptoKey(alg, key2, usage) {
  if (isCryptoKey4(key2)) {
    return key2;
  }
  if (key2 instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key2, "CryptoKey"));
    }
    return webcrypto_default.subtle.importKey("raw", key2, { hash: { name: `SHA-${alg.substr(-3)}` }, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key2, "CryptoKey", "Uint8Array"));
}

// deno:https://deno.land/x/jose@v3.19.0/runtime/sign.ts
var sign2 = async (alg, key2, data) => {
  const cryptoKey = await getCryptoKey(alg, key2, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature2 = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm.namedCurve), cryptoKey, data);
  return new Uint8Array(signature2);
};
var sign_default = sign2;

// deno:https://deno.land/x/jose@v3.19.0/lib/is_disjoint.ts
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// deno:https://deno.land/x/jose@v3.19.0/lib/check_key_type.ts
var checkKeyType = (alg, key2, usage) => {
  if (!(key2 instanceof Uint8Array) && !key2?.type) {
    throw new TypeError(invalid_key_input_default(key2, "KeyObject", "CryptoKey", "Uint8Array"));
  }
  if (alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || alg.match(/^A\d{3}(?:GCM)?KW$/)) {
    if (key2 instanceof Uint8Array || key2.type === "secret") {
      return;
    }
    throw new TypeError('CryptoKey or KeyObject instances for symmetric algorithms must be of type "secret"');
  }
  if (key2 instanceof Uint8Array) {
    throw new TypeError(invalid_key_input_default(key2, "KeyObject", "CryptoKey"));
  }
  if (key2.type === "secret") {
    throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithms must not be of type "secret"');
  }
  if (usage === "sign" && key2.type === "public") {
    throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithm signing must be of type "private"');
  }
  if (usage === "decrypt" && key2.type === "public") {
    throw new TypeError('CryptoKey or KeyObject instances for asymmetric algorithm decryption must be of type "private"');
  }
};
var check_key_type_default = checkKeyType;

// deno:https://deno.land/x/jose@v3.19.0/lib/validate_crit.ts
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// deno:https://deno.land/x/jose@v3.19.0/jws/flattened/sign.ts
var checkExtensions = validate_crit_default.bind(void 0, JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]));
var FlattenedSign = class {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key2, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = checkExtensions(options?.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key2, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode15(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode15(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat6(protectedHeader, encoder.encode("."), payload);
    const signature2 = await sign_default(alg, key2, data);
    const jws = {
      signature: encode15(signature2),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
};
var sign_default2 = FlattenedSign;

// deno:https://deno.land/x/jose@v3.19.0/jws/compact/sign.ts
var CompactSign = class {
  constructor(payload) {
    this._flattened = new sign_default2(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key2, options) {
    const jws = await this._flattened.sign(key2, options);
    if (jws.payload === void 0) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
};
var sign_default3 = CompactSign;

// deno:https://deno.land/x/jose@v3.19.0/lib/epoch.ts
var epoch_default = (date) => Math.floor(date.getTime() / 1e3);

// deno:https://deno.land/x/jose@v3.19.0/lib/is_object.ts
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject3(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// deno:https://deno.land/x/jose@v3.19.0/lib/secs.ts
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};

// deno:https://deno.land/x/jose@v3.19.0/lib/jwt_producer.ts
var ProduceJWT = class {
  constructor(payload) {
    if (!isObject3(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date()) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date()) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date()) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
};

// deno:https://deno.land/x/jose@v3.19.0/jwt/sign.ts
var SignJWT = class extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key2, options) {
    const sig = new sign_default3(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key2, options);
  }
};

// deno:https://cdn.skypack.dev/-/urlsafe-base64@v1.0.0-BTpQCswrPNOGPq5vM1FQ/dist=es2019,mode=imports/optimized/urlsafe-base64.js
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init3() {
  inited = true;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code2.length; i < len; ++i) {
    lookup[i] = code2[i];
    revLookup[code2.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init3();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init3();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write4(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt2 / c;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES4 = 50;
Buffer7.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
function kMaxLength4() {
  return Buffer7.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer4(that, length) {
  if (kMaxLength4() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer7.prototype;
  } else {
    if (that === null) {
      that = new Buffer7(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer7(arg, encodingOrOffset, length) {
  if (!Buffer7.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer7)) {
    return new Buffer7(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe4(this, arg);
  }
  return from4(this, arg, encodingOrOffset, length);
}
Buffer7.poolSize = 8192;
Buffer7._augment = function(arr) {
  arr.__proto__ = Buffer7.prototype;
  return arr;
};
function from4(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer4(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString4(that, value, encodingOrOffset);
  }
  return fromObject4(that, value);
}
Buffer7.from = function(value, encodingOrOffset, length) {
  return from4(null, value, encodingOrOffset, length);
};
if (Buffer7.TYPED_ARRAY_SUPPORT) {
  Buffer7.prototype.__proto__ = Uint8Array.prototype;
  Buffer7.__proto__ = Uint8Array;
}
function assertSize5(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc4(that, size, fill22, encoding) {
  assertSize5(size);
  if (size <= 0) {
    return createBuffer4(that, size);
  }
  if (fill22 !== void 0) {
    return typeof encoding === "string" ? createBuffer4(that, size).fill(fill22, encoding) : createBuffer4(that, size).fill(fill22);
  }
  return createBuffer4(that, size);
}
Buffer7.alloc = function(size, fill22, encoding) {
  return alloc4(null, size, fill22, encoding);
};
function allocUnsafe4(that, size) {
  assertSize5(size);
  that = createBuffer4(that, size < 0 ? 0 : checked4(size) | 0);
  if (!Buffer7.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer7.allocUnsafe = function(size) {
  return allocUnsafe4(null, size);
};
Buffer7.allocUnsafeSlow = function(size) {
  return allocUnsafe4(null, size);
};
function fromString4(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer7.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength5(string, encoding) | 0;
  that = createBuffer4(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike4(that, array) {
  var length = array.length < 0 ? 0 : checked4(array.length) | 0;
  that = createBuffer4(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer4(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer7.prototype;
  } else {
    that = fromArrayLike4(that, array);
  }
  return that;
}
function fromObject4(that, obj2) {
  if (internalIsBuffer(obj2)) {
    var len = checked4(obj2.length) | 0;
    that = createBuffer4(that, len);
    if (that.length === 0) {
      return that;
    }
    obj2.copy(that, 0, 0, len);
    return that;
  }
  if (obj2) {
    if (typeof ArrayBuffer !== "undefined" && obj2.buffer instanceof ArrayBuffer || "length" in obj2) {
      if (typeof obj2.length !== "number" || isnan(obj2.length)) {
        return createBuffer4(that, 0);
      }
      return fromArrayLike4(that, obj2);
    }
    if (obj2.type === "Buffer" && isArray3(obj2.data)) {
      return fromArrayLike4(that, obj2.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked4(length) {
  if (length >= kMaxLength4()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength4().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer7.isBuffer = isBuffer6;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer7.compare = function compare8(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a === b)
    return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
Buffer7.isEncoding = function isEncoding4(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer7.concat = function concat7(list, length) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer7.alloc(0);
  }
  var i;
  if (length === void 0) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer7.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength5(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes4(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes4(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes4(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer7.byteLength = byteLength5;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice6(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice4(this, start, end);
      case "ascii":
        return asciiSlice4(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice4(this, start, end);
      case "base64":
        return base64Slice4(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer7.prototype._isBuffer = true;
function swap4(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer7.prototype.swap16 = function swap164() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap4(this, i, i + 1);
  }
  return this;
};
Buffer7.prototype.swap32 = function swap324() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap4(this, i, i + 3);
    swap4(this, i + 1, i + 2);
  }
  return this;
};
Buffer7.prototype.swap64 = function swap644() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap4(this, i, i + 7);
    swap4(this, i + 1, i + 6);
    swap4(this, i + 2, i + 5);
    swap4(this, i + 3, i + 4);
  }
  return this;
};
Buffer7.prototype.toString = function toString22() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice4(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer7.prototype.equals = function equals7(b) {
  if (!internalIsBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer7.compare(this, b) === 0;
};
Buffer7.prototype.inspect = function inspect7() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES4;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer7.prototype.compare = function compare22(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf4(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer7.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer7.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer7.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer7.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf4(this, val, byteOffset, encoding, true);
};
Buffer7.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf4(this, val, byteOffset, encoding, false);
};
function hexWrite4(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write5(buf, string, offset, length) {
  return blitBuffer4(utf8ToBytes4(string, buf.length - offset), buf, offset, length);
}
function asciiWrite4(buf, string, offset, length) {
  return blitBuffer4(asciiToBytes4(string), buf, offset, length);
}
function latin1Write4(buf, string, offset, length) {
  return asciiWrite4(buf, string, offset, length);
}
function base64Write4(buf, string, offset, length) {
  return blitBuffer4(base64ToBytes4(string), buf, offset, length);
}
function ucs2Write4(buf, string, offset, length) {
  return blitBuffer4(utf16leToBytes4(string, buf.length - offset), buf, offset, length);
}
Buffer7.prototype.write = function write22(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite4(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write5(this, string, offset, length);
      case "ascii":
        return asciiWrite4(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write4(this, string, offset, length);
      case "base64":
        return base64Write4(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write4(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer7.prototype.toJSON = function toJSON5() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice4(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice4(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray4(res);
}
var MAX_ARGUMENTS_LENGTH4 = 4096;
function decodeCodePointsArray4(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH4) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH4));
  }
  return res;
}
function asciiSlice4(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice4(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice6(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer7.prototype.slice = function slice4(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer7.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer7(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer7.prototype.readUIntLE = function readUIntLE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength22, this.length);
  var val = this[offset];
  var mul4 = 1;
  var i = 0;
  while (++i < byteLength22 && (mul4 *= 256)) {
    val += this[offset + i] * mul4;
  }
  return val;
};
Buffer7.prototype.readUIntBE = function readUIntBE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength22, this.length);
  }
  var val = this[offset + --byteLength22];
  var mul4 = 1;
  while (byteLength22 > 0 && (mul4 *= 256)) {
    val += this[offset + --byteLength22] * mul4;
  }
  return val;
};
Buffer7.prototype.readUInt8 = function readUInt85(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer7.prototype.readUInt16LE = function readUInt16LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer7.prototype.readUInt16BE = function readUInt16BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer7.prototype.readUInt32LE = function readUInt32LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer7.prototype.readUInt32BE = function readUInt32BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer7.prototype.readIntLE = function readIntLE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength22, this.length);
  var val = this[offset];
  var mul4 = 1;
  var i = 0;
  while (++i < byteLength22 && (mul4 *= 256)) {
    val += this[offset + i] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength22);
  return val;
};
Buffer7.prototype.readIntBE = function readIntBE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength22, this.length);
  var i = byteLength22;
  var mul4 = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul4 *= 256)) {
    val += this[offset + --i] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength22);
  return val;
};
Buffer7.prototype.readInt8 = function readInt84(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer7.prototype.readInt16LE = function readInt16LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer7.prototype.readInt16BE = function readInt16BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer7.prototype.readInt32LE = function readInt32LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer7.prototype.readInt32BE = function readInt32BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer7.prototype.readFloatLE = function readFloatLE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer7.prototype.readFloatBE = function readFloatBE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer7.prototype.readDoubleLE = function readDoubleLE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer7.prototype.readDoubleBE = function readDoubleBE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt4(buf, value, offset, ext, max2, min4) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min4)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer7.prototype.writeUIntLE = function writeUIntLE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength22) - 1;
    checkInt4(this, value, offset, byteLength22, maxBytes, 0);
  }
  var mul4 = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength22 && (mul4 *= 256)) {
    this[offset + i] = value / mul4 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeUIntBE = function writeUIntBE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength22) - 1;
    checkInt4(this, value, offset, byteLength22, maxBytes, 0);
  }
  var i = byteLength22 - 1;
  var mul4 = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul4 *= 256)) {
    this[offset + i] = value / mul4 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeUInt8 = function writeUInt84(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 1, 255, 0);
  if (!Buffer7.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer7.prototype.writeUInt16LE = function writeUInt16LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 65535, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer7.prototype.writeUInt16BE = function writeUInt16BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 65535, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer7.prototype.writeUInt32LE = function writeUInt32LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 4294967295, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer7.prototype.writeUInt32BE = function writeUInt32BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 4294967295, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer7.prototype.writeIntLE = function writeIntLE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength22 - 1);
    checkInt4(this, value, offset, byteLength22, limit - 1, -limit);
  }
  var i = 0;
  var mul4 = 1;
  var sub3 = 0;
  this[offset] = value & 255;
  while (++i < byteLength22 && (mul4 *= 256)) {
    if (value < 0 && sub3 === 0 && this[offset + i - 1] !== 0) {
      sub3 = 1;
    }
    this[offset + i] = (value / mul4 >> 0) - sub3 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeIntBE = function writeIntBE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength22 - 1);
    checkInt4(this, value, offset, byteLength22, limit - 1, -limit);
  }
  var i = byteLength22 - 1;
  var mul4 = 1;
  var sub3 = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul4 *= 256)) {
    if (value < 0 && sub3 === 0 && this[offset + i + 1] !== 0) {
      sub3 = 1;
    }
    this[offset + i] = (value / mul4 >> 0) - sub3 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeInt8 = function writeInt84(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 1, 127, -128);
  if (!Buffer7.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer7.prototype.writeInt16LE = function writeInt16LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 32767, -32768);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer7.prototype.writeInt16BE = function writeInt16BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 32767, -32768);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer7.prototype.writeInt32LE = function writeInt32LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer7.prototype.writeInt32BE = function writeInt32BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max2, min4) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write4(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer7.prototype.writeFloatLE = function writeFloatLE4(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer7.prototype.writeFloatBE = function writeFloatBE4(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write4(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer7.prototype.writeDoubleLE = function writeDoubleLE4(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer7.prototype.writeDoubleBE = function writeDoubleBE4(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer7.prototype.copy = function copy7(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1e3 || !Buffer7.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};
Buffer7.prototype.fill = function fill4(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer7.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes4(new Buffer7(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE4 = /[^+\/0-9A-Za-z-_]/g;
function base64clean4(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE4, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes4(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes4(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes4(str, units) {
  var c, hi, lo2;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo2 = c % 256;
    byteArray.push(lo2);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes4(str) {
  return toByteArray(base64clean4(str));
}
function blitBuffer4(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer6(obj2) {
  return obj2 != null && (!!obj2._isBuffer || isFastBuffer(obj2) || isSlowBuffer(obj2));
}
function isFastBuffer(obj2) {
  return !!obj2.constructor && typeof obj2.constructor.isBuffer === "function" && obj2.constructor.isBuffer(obj2);
}
function isSlowBuffer(obj2) {
  return typeof obj2.readFloatLE === "function" && typeof obj2.slice === "function" && isFastBuffer(obj2.slice(0, 0));
}
var version2 = "1.0.0";
var encode16 = function encode22(buffer) {
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
var decode12 = function decode22(base64) {
  base64 += Array(5 - base64.length % 4).join("=");
  base64 = base64.replace(/\-/g, "+").replace(/\_/g, "/");
  return new Buffer7(base64, "base64");
};
var validate = function validate2(base64) {
  return /^[A-Za-z0-9\-_]+$/.test(base64);
};
var urlsafeBase64 = {
  version: version2,
  encode: encode16,
  decode: decode12,
  validate
};
var urlsafeBase64$1 = urlsafeBase64;
var decode$1 = urlsafeBase64$1.decode;
var encode$1 = urlsafeBase64$1.encode;
var validate$1 = urlsafeBase64$1.validate;
var version$1 = urlsafeBase64$1.version;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/web-push-constants.ts
var WebPushConstants = {};
var supportedContentEncodings = {
  AES_GCM: "aesgcm",
  AES_128_GCM: "aes128gcm"
};
WebPushConstants.supportedContentEncodings = supportedContentEncodings;
var web_push_constants_default = WebPushConstants;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/vapid-helper.ts
var DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;
var MAX_EXPIRATION_SECONDS = 24 * 60 * 60;
function generateVAPIDKeys() {
  const curve = crypto_default2.createECDH("prime256v1");
  curve.generateKeys();
  let publicKeyBuffer = curve.getPublicKey();
  let privateKeyBuffer = curve.getPrivateKey();
  if (privateKeyBuffer.length < 32) {
    const padding = Buffer4.alloc(32 - privateKeyBuffer.length);
    padding.fill(0);
    privateKeyBuffer = Buffer4.concat([padding, privateKeyBuffer]);
  }
  if (publicKeyBuffer.length < 65) {
    const padding = Buffer4.alloc(65 - publicKeyBuffer.length);
    padding.fill(0);
    publicKeyBuffer = Buffer4.concat([padding, publicKeyBuffer]);
  }
  return {
    publicKey: encode$1(publicKeyBuffer),
    privateKey: encode$1(privateKeyBuffer)
  };
}
function validateSubject(subject) {
  if (!subject) {
    throw new Error("No subject set in vapidDetails.subject.");
  }
  if (typeof subject !== "string" || subject.length === 0) {
    throw new Error("The subject value must be a string containing a URL or mailto: address. " + subject);
  }
  if (subject.indexOf("mailto:") !== 0) {
    const subjectParseResult = parse9(subject, false, false);
    if (!subjectParseResult.hostname) {
      throw new Error("Vapid subject is not a url or mailto url. " + subject);
    }
  }
}
function validatePublicKey(publicKey) {
  if (!publicKey) {
    throw new Error("No key set vapidDetails.publicKey");
  }
  if (typeof publicKey !== "string") {
    throw new Error("Vapid public key is must be a URL safe Base 64 encoded string.");
  }
  if (!validate$1(publicKey)) {
    throw new Error('Vapid public key must be a URL safe Base 64 (without "=")');
  }
  publicKey = decode$1(publicKey);
  if (publicKey.length !== 65) {
    throw new Error("Vapid public key should be 65 bytes long when decoded.");
  }
}
function validatePrivateKey(privateKey) {
  if (!privateKey) {
    throw new Error("No key set in vapidDetails.privateKey");
  }
  if (typeof privateKey !== "string") {
    throw new Error("Vapid private key must be a URL safe Base 64 encoded string.");
  }
  if (!validate$1(privateKey)) {
    throw new Error('Vapid private key must be a URL safe Base 64 (without "=")');
  }
  privateKey = decode$1(privateKey);
  if (privateKey.length !== 32) {
    throw new Error("Vapid private key should be 32 bytes long when decoded.");
  }
}
function getFutureExpirationTimestamp(numSeconds) {
  const futureExp = new Date();
  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);
  return Math.floor(futureExp.getTime() / 1e3);
}
function validateExpiration(expiration) {
  if (!Number.isInteger(expiration)) {
    throw new Error("`expiration` value must be a number");
  }
  if (expiration < 0) {
    throw new Error("`expiration` must be a positive integer");
  }
  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);
  if (expiration >= maxExpirationTimestamp) {
    throw new Error("`expiration` value is greater than maximum of 24 hours");
  }
}
async function getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {
  if (!audience) {
    throw new Error("No audience could be generated for VAPID.");
  }
  if (typeof audience !== "string" || audience.length === 0) {
    throw new Error("The audience value must be a string containing the origin of a push service. " + audience);
  }
  const audienceParseResult = parse9(audience, false, false);
  if (!audienceParseResult.hostname) {
    throw new Error("VAPID audience is not a url. " + audience);
  }
  validateSubject(subject);
  validatePublicKey(publicKey);
  validatePrivateKey(privateKey);
  const privateKeyBuffer = decode$1(privateKey);
  if (expiration) {
    validateExpiration(expiration);
  } else {
    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);
  }
  const header = {
    typ: "JWT",
    alg: "ES256"
  };
  const jwtPayload = {
    aud: audience,
    exp: expiration,
    sub: subject
  };
  console.log("privateKeyBuffer", privateKeyBuffer.toString("base64"));
  const privateKeyToSign = await globalThis.crypto.subtle.importKey("pkcs8", privateKeyBuffer, {
    name: "ECDSA",
    namedCurve: "P-256"
  }, true, ["sign"]);
  const jwt = new SignJWT(jwtPayload).setProtectedHeader(header).sign(privateKeyToSign);
  console.log("jwt", jwt);
  if (contentEncoding === supportedContentEncodings.AES_128_GCM) {
    return {
      Authorization: "vapid t=" + jwt + ", k=" + publicKey
    };
  }
  if (contentEncoding === supportedContentEncodings.AES_GCM) {
    return {
      Authorization: "WebPush " + jwt,
      "Crypto-Key": "p256ecdsa=" + publicKey
    };
  }
  throw new Error("Unsupported encoding type specified.");
}

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/ece.ts
var AES_GCM = "aes-128-gcm";
var PAD_SIZE = { aes128gcm: 1, aesgcm: 2 };
var TAG_LENGTH = 16;
var KEY_LENGTH = 16;
var NONCE_LENGTH = 12;
var SHA_256_LENGTH = 32;
var MODE_ENCRYPT = "encrypt";
var MODE_DECRYPT = "decrypt";
var keylog;
keylog = function(m, k3) {
  return k3;
};
function decode13(b) {
  if (typeof b === "string") {
    return decode$1(b);
  }
  return b;
}
function HMAC_hash(key2, input) {
  const hmac = crypto_default2.createHmac("sha256", key2);
  hmac.update(input);
  return hmac.digest();
}
function HKDF_extract(salt, ikm) {
  keylog("salt", salt);
  keylog("ikm", ikm);
  return keylog("extract", HMAC_hash(salt, ikm));
}
function HKDF_expand(prk, info2, l) {
  keylog("prk", prk);
  keylog("info", info2);
  let output = Buffer4.alloc(0);
  let T = Buffer4.alloc(0);
  info2 = Buffer4.from(info2, "ascii");
  let counter = 0;
  const cbuf = Buffer4.alloc(1);
  while (output.length < l) {
    cbuf.writeUIntBE(++counter, 0, 1);
    T = HMAC_hash(prk, Buffer4.concat([T, info2, cbuf]));
    output = Buffer4.concat([output, T]);
  }
  return keylog("expand", output.slice(0, l));
}
function HKDF(salt, ikm, info2, len) {
  return HKDF_expand(HKDF_extract(salt, ikm), info2, len);
}
function info(base3, context) {
  const result = Buffer4.concat([
    Buffer4.from("Content-Encoding: " + base3 + "\0", "ascii"),
    context
  ]);
  keylog("info " + base3, result);
  return result;
}
function lengthPrefix(buffer) {
  const b = Buffer4.concat([Buffer4.alloc(2), buffer]);
  b.writeUIntBE(buffer.length, 0, 2);
  return b;
}
function extractDH(header, mode) {
  const key2 = header.privateKey;
  let senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = key2.getPublicKey();
    receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    senderPubKey = header.dh;
    receiverPubKey = key2.getPublicKey();
  } else {
    throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
  }
  return {
    secret: key2.computeSecret(header.dh),
    context: Buffer4.concat([
      Buffer4.from(header.keylabel, "ascii"),
      Buffer4.from([0]),
      lengthPrefix(receiverPubKey),
      lengthPrefix(senderPubKey)
    ])
  };
}
function extractSecretAndContext(header, mode) {
  let result = { secret: null, context: Buffer4.alloc(0) };
  if (header.key) {
    result.secret = header.key;
    if (result.secret !== null && result.secret.length !== KEY_LENGTH) {
      throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
    }
  } else if (header.dh) {
    result = extractDH(header, mode);
  } else if (header.keyid !== void 0) {
    result.secret = header.keymap[header.keyid];
  }
  if (!result.secret) {
    throw new Error("Unable to determine key");
  }
  keylog("secret", result.secret);
  keylog("context", result.context);
  if (header.authSecret) {
    result.secret = HKDF(header.authSecret, result.secret, info("auth", Buffer4.alloc(0)), SHA_256_LENGTH);
    keylog("authsecret", result.secret);
  }
  return result;
}
function webpushSecret(header, mode) {
  if (!header.authSecret) {
    throw new Error("No authentication secret for webpush");
  }
  keylog("authsecret", header.authSecret);
  let remotePubKey, senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = header.privateKey.getPublicKey();
    remotePubKey = receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    remotePubKey = senderPubKey = header.keyid;
    receiverPubKey = header.privateKey.getPublicKey();
  } else {
    throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
  }
  keylog("remote pubkey", remotePubKey);
  keylog("sender pubkey", senderPubKey);
  keylog("receiver pubkey", receiverPubKey);
  return keylog("secret dh", HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer4.concat([
    Buffer4.from("WebPush: info\0"),
    receiverPubKey,
    senderPubKey
  ]), SHA_256_LENGTH));
}
function extractSecret(header, mode, keyLookupCallback) {
  if (keyLookupCallback) {
    if (!isFunction3(keyLookupCallback)) {
      throw new Error("Callback is not a function");
    }
  }
  if (header.key) {
    if (header.key.length !== KEY_LENGTH) {
      throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
    }
    return keylog("secret key", header.key);
  }
  if (!header.privateKey) {
    let key2;
    if (!keyLookupCallback) {
      key2 = header.keymap && header.keymap[header.keyid];
    } else {
      key2 = keyLookupCallback(header.keyid);
    }
    if (!key2) {
      throw new Error('No saved key (keyid: "' + header.keyid + '")');
    }
    return key2;
  }
  return webpushSecret(header, mode);
}
function deriveKeyAndNonce(header, mode, lookupKeyCallback) {
  if (!header.salt) {
    throw new Error("must include a salt parameter for " + header.version);
  }
  let keyInfo;
  let nonceInfo;
  let secret;
  if (header.version === "aesgcm") {
    const s = extractSecretAndContext(header, mode, lookupKeyCallback);
    keyInfo = info("aesgcm", s.context);
    nonceInfo = info("nonce", s.context);
    secret = s.secret;
  } else if (header.version === "aes128gcm") {
    keyInfo = Buffer4.from("Content-Encoding: aes128gcm\0");
    nonceInfo = Buffer4.from("Content-Encoding: nonce\0");
    secret = extractSecret(header, mode, lookupKeyCallback);
  } else {
    throw new Error("Unable to set context for mode " + header.version);
  }
  const prk = HKDF_extract(header.salt, secret);
  const result = {
    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),
    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)
  };
  keylog("key", result.key);
  keylog("nonce base", result.nonce);
  return result;
}
function parseParams(params) {
  const header = {};
  header.version = params.version || "aes128gcm";
  header.rs = parseInt(params.rs, 10);
  if (isNaN(header.rs)) {
    header.rs = 4096;
  }
  let overhead = PAD_SIZE[header.version];
  if (header.version === "aes128gcm") {
    overhead += TAG_LENGTH;
  }
  if (header.rs <= overhead) {
    throw new Error("The rs parameter has to be greater than " + overhead);
  }
  if (params.salt) {
    header.salt = decode13(params.salt);
    if (header.salt.length !== KEY_LENGTH) {
      throw new Error("The salt parameter must be " + KEY_LENGTH + " bytes");
    }
  }
  header.keyid = params.keyid;
  if (params.key) {
    header.key = decode13(params.key);
  } else {
    header.privateKey = params.privateKey;
    if (!header.privateKey) {
      header.keymap = params.keymap;
    }
    if (header.version !== "aes128gcm") {
      header.keylabel = params.keylabel || "P-256";
    }
    if (params.dh) {
      header.dh = decode13(params.dh);
    }
  }
  if (params.authSecret) {
    header.authSecret = decode13(params.authSecret);
  }
  return header;
}
function generateNonce(base3, counter) {
  const nonce = Buffer4.from(base3);
  const m = nonce.readUIntBE(nonce.length - 6, 6);
  const x = ((m ^ counter) & 16777215) + ((m / 16777216 ^ counter / 16777216) & 16777215) * 16777216;
  nonce.writeUIntBE(x, nonce.length - 6, 6);
  keylog("nonce" + counter, nonce);
  return nonce;
}
function encryptRecord(key2, counter, buffer, pad3, header, last) {
  keylog("encrypt", buffer);
  pad3 = pad3 || 0;
  const nonce = generateNonce(key2.nonce, counter);
  const gcm = crypto_default2.createCipheriv(AES_GCM, key2.key, nonce);
  const ciphertext = [];
  const padSize = PAD_SIZE[header.version];
  const padding = Buffer4.alloc(pad3 + padSize);
  padding.fill(0);
  if (header.version !== "aes128gcm") {
    padding.writeUIntBE(pad3, 0, padSize);
    keylog("padding", padding);
    ciphertext.push(gcm.update(padding));
    ciphertext.push(gcm.update(buffer));
    if (!last && padding.length + buffer.length < header.rs) {
      throw new Error("Unable to pad to record size");
    }
  } else {
    ciphertext.push(gcm.update(buffer));
    padding.writeUIntBE(last ? 2 : 1, 0, 1);
    keylog("padding", padding);
    ciphertext.push(gcm.update(padding));
  }
  gcm.final();
  const tag2 = gcm.getAuthTag();
  if (tag2.length !== TAG_LENGTH) {
    throw new Error("invalid tag generated");
  }
  ciphertext.push(tag2);
  return keylog("encrypted", Buffer4.concat(ciphertext));
}
function writeHeader(header) {
  const ints = Buffer4.alloc(5);
  const keyid = Buffer4.from(header.keyid || []);
  if (keyid.length > 255) {
    throw new Error("keyid is too large");
  }
  ints.writeUIntBE(header.rs, 0, 4);
  ints.writeUIntBE(keyid.length, 4, 1);
  return Buffer4.concat([header.salt, ints, keyid]);
}
function encrypt8(buffer, params, keyLookupCallback) {
  if (!Buffer4.isBuffer(buffer)) {
    throw new Error("buffer argument must be a Buffer");
  }
  const header = parseParams(params);
  if (!header.salt) {
    header.salt = crypto_default2.randomBytes(KEY_LENGTH);
  }
  let result;
  if (header.version === "aes128gcm") {
    if (header.privateKey && !header.keyid) {
      header.keyid = header.privateKey.getPublicKey();
    }
    result = writeHeader(header);
  } else {
    result = Buffer4.alloc(0);
  }
  const key2 = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);
  let start = 0;
  const padSize = PAD_SIZE[header.version];
  let overhead = padSize;
  if (header.version === "aes128gcm") {
    overhead += TAG_LENGTH;
  }
  let pad3 = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);
  let counter = 0;
  let last = false;
  while (!last) {
    let recordPad = Math.min(header.rs - overhead - 1, pad3);
    if (header.version !== "aes128gcm") {
      recordPad = Math.min((1 << padSize * 8) - 1, recordPad);
    }
    if (pad3 > 0 && recordPad === 0) {
      ++recordPad;
    }
    pad3 -= recordPad;
    const end = start + header.rs - overhead - recordPad;
    if (header.version !== "aes128gcm") {
      last = end > buffer.length;
    } else {
      last = end >= buffer.length;
    }
    last = last && pad3 <= 0;
    const block = encryptRecord(key2, counter, buffer.slice(start, end), recordPad, header, last);
    result = Buffer4.concat([result, block]);
    start = end;
    ++counter;
  }
  return result;
}
function isFunction3(object) {
  return typeof object === "function";
}

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/encryption-helper.ts
var encrypt9 = function(userPublicKey, userAuth, payload, contentEncoding) {
  if (!userPublicKey) {
    throw new Error("No user public key provided for encryption.");
  }
  if (typeof userPublicKey !== "string") {
    throw new Error("The subscription p256dh value must be a string.");
  }
  if (decode$1(userPublicKey).length !== 65) {
    throw new Error("The subscription p256dh value should be 65 bytes long.");
  }
  if (!userAuth) {
    throw new Error("No user auth provided for encryption.");
  }
  if (typeof userAuth !== "string") {
    throw new Error("The subscription auth key must be a string.");
  }
  if (decode$1(userAuth).length < 16) {
    throw new Error("The subscription auth key should be at least 16 bytes long");
  }
  if (payload instanceof Uint8Array) {
    payload = new Buffer4(payload);
  }
  if (typeof payload !== "string" && !Buffer4.isBuffer(payload)) {
    throw new Error("Payload must be either a string or a Node Buffer.");
  }
  if (typeof payload === "string" || payload instanceof String) {
    payload = Buffer4.from(payload);
  }
  const localCurve = crypto_default2.createECDH("prime256v1");
  const localPublicKey = localCurve.generateKeys();
  const salt = encode$1(crypto_default2.randomBytes(16));
  const cipherText = encrypt8(payload, {
    version: contentEncoding,
    dh: userPublicKey,
    privateKey: localCurve,
    salt,
    authSecret: userAuth
  });
  return {
    localPublicKey,
    salt,
    cipherText
  };
};

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/web-push-error.ts
function WebPushError(message, statusCode, headers, body, endpoint) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
  this.statusCode = statusCode;
  this.headers = headers;
  this.body = body;
  this.endpoint = endpoint;
}
util_default2.inherits(WebPushError, Error);
var web_push_error_default = WebPushError;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/web-push-lib.ts
var DEFAULT_TTL = 2419200;
var gcmAPIKey = "";
var vapidDetails;
function WebPushLib() {
}
WebPushLib.prototype.setGCMAPIKey = function(apiKey) {
  if (apiKey === null) {
    gcmAPIKey = null;
    return;
  }
  if (typeof apiKey === "undefined" || typeof apiKey !== "string" || apiKey.length === 0) {
    throw new Error("The GCM API Key should be a non-empty string or null.");
  }
  gcmAPIKey = apiKey;
};
WebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {
  if (arguments.length === 1 && arguments[0] === null) {
    vapidDetails = null;
    return;
  }
  validateSubject(subject);
  validatePublicKey(publicKey);
  validatePrivateKey(privateKey);
  vapidDetails = {
    subject,
    publicKey,
    privateKey
  };
};
WebPushLib.prototype.generateRequestDetails = function(subscription, payload, options) {
  if (!subscription || !subscription.endpoint) {
    throw new Error("You must pass in a subscription with at least an endpoint.");
  }
  if (typeof subscription.endpoint !== "string" || subscription.endpoint.length === 0) {
    throw new Error("The subscription endpoint must be a string with a valid URL.");
  }
  if (payload) {
    if (typeof subscription !== "object" || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {
      throw new Error("To send a message with a payload, the subscription must have 'auth' and 'p256dh' keys.");
    }
  }
  let currentGCMAPIKey = gcmAPIKey;
  let currentVapidDetails = vapidDetails;
  let timeToLive = DEFAULT_TTL;
  let extraHeaders = {};
  let contentEncoding = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
  let proxy;
  let agent;
  let timeout;
  if (options) {
    const validOptionKeys = [
      "headers",
      "gcmAPIKey",
      "vapidDetails",
      "TTL",
      "contentEncoding",
      "proxy",
      "agent",
      "timeout"
    ];
    const optionKeys = Object.keys(options);
    for (let i = 0; i < optionKeys.length; i += 1) {
      const optionKey = optionKeys[i];
      if (validOptionKeys.indexOf(optionKey) === -1) {
        throw new Error("'" + optionKey + "' is an invalid option. The valid options are ['" + validOptionKeys.join("', '") + "'].");
      }
    }
    if (options.headers) {
      extraHeaders = options.headers;
      let duplicates = Object.keys(extraHeaders).filter(function(header) {
        return typeof options[header] !== "undefined";
      });
      if (duplicates.length > 0) {
        throw new Error("Duplicated headers defined [" + duplicates.join(",") + "]. Please either define the header in thetop level options OR in the 'headers' key.");
      }
    }
    if (options.gcmAPIKey) {
      currentGCMAPIKey = options.gcmAPIKey;
    }
    if (options.vapidDetails !== void 0) {
      currentVapidDetails = options.vapidDetails;
    }
    if (options.TTL !== void 0) {
      timeToLive = Number(options.TTL);
      if (timeToLive < 0) {
        throw new Error("TTL should be a number and should be at least 0");
      }
    }
    if (options.contentEncoding) {
      if (options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM || options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
        contentEncoding = options.contentEncoding;
      } else {
        throw new Error("Unsupported content encoding specified.");
      }
    }
    if (options.proxy) {
      if (typeof options.proxy === "string" || typeof options.proxy.host === "string") {
        proxy = options.proxy;
      } else {
        console.warn("Attempt to use proxy option, but invalid type it should be a string or proxy options object.");
      }
    }
    if (typeof options.timeout === "number") {
      timeout = options.timeout;
    }
  }
  if (typeof timeToLive === "undefined") {
    timeToLive = DEFAULT_TTL;
  }
  const requestDetails = {
    method: "POST",
    headers: {
      TTL: timeToLive
    }
  };
  Object.keys(extraHeaders).forEach(function(header) {
    requestDetails.headers[header] = extraHeaders[header];
  });
  let requestPayload = null;
  if (payload) {
    const encrypted = encrypt9(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);
    requestDetails.headers["Content-Length"] = encrypted.cipherText.length;
    requestDetails.headers["Content-Type"] = "application/octet-stream";
    if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM) {
      requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
    } else if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
      requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_GCM;
      requestDetails.headers.Encryption = "salt=" + encrypted.salt;
      requestDetails.headers["Crypto-Key"] = "dh=" + encode$1(encrypted.localPublicKey);
    }
    requestPayload = encrypted.cipherText;
  } else {
    requestDetails.headers["Content-Length"] = 0;
  }
  const isGCM = subscription.endpoint.indexOf("https://android.googleapis.com/gcm/send") === 0;
  const isFCM = subscription.endpoint.indexOf("https://fcm.googleapis.com/fcm/send") === 0;
  if (isGCM) {
    if (!currentGCMAPIKey) {
      console.warn("Attempt to send push notification to GCM endpoint, but no GCM key is defined. Please use setGCMApiKey() or add 'gcmAPIKey' as an option.");
    } else {
      requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
    }
  } else if (currentVapidDetails) {
    const parsedUrl = parse9(subscription.endpoint, false, false);
    const audience = parsedUrl.protocol + "//" + parsedUrl.host;
    const vapidHeaders = getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);
    requestDetails.headers.Authorization = vapidHeaders.Authorization;
    if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
      if (requestDetails.headers["Crypto-Key"]) {
        requestDetails.headers["Crypto-Key"] += ";" + vapidHeaders["Crypto-Key"];
      } else {
        requestDetails.headers["Crypto-Key"] = vapidHeaders["Crypto-Key"];
      }
    }
  } else if (isFCM && currentGCMAPIKey) {
    requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
  }
  requestDetails.body = requestPayload;
  requestDetails.endpoint = subscription.endpoint;
  if (proxy) {
    requestDetails.proxy = proxy;
  }
  if (agent) {
    requestDetails.agent = agent;
  }
  if (timeout) {
    requestDetails.timeout = timeout;
  }
  return requestDetails;
};
WebPushLib.prototype.sendNotification = function(subscription, payload, options) {
  let requestDetails;
  try {
    requestDetails = this.generateRequestDetails(subscription, payload, options);
  } catch (err) {
    return Promise.reject(err);
  }
  return new Promise(async function(resolve7, reject) {
    const httpsOptions = {};
    const urlParts = parse9(requestDetails.endpoint, false, false);
    httpsOptions.hostname = urlParts.hostname;
    httpsOptions.port = urlParts.port;
    httpsOptions.path = urlParts.path;
    httpsOptions.headers = requestDetails.headers;
    httpsOptions.method = requestDetails.method;
    if (requestDetails.timeout) {
      httpsOptions.timeout = requestDetails.timeout;
    }
    if (requestDetails.agent) {
      httpsOptions.agent = requestDetails.agent;
    }
    if (requestDetails.body) {
      httpsOptions.body = requestDetails.body;
    }
    const pushResponse = await fetch(requestDetails.endpoint, httpsOptions).catch((e) => {
      reject(e);
    });
    if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {
      reject(new web_push_error_default("Received unexpected response code", pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));
    } else {
      const responseText2 = await pushResponse.text();
      resolve7({
        statusCode: pushResponse.statusCode,
        body: responseText2,
        headers: pushResponse.headers
      });
    }
  });
};
var web_push_lib_default = WebPushLib;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/index.ts
var webPush = new web_push_lib_default();
var setGCMAPIKey = webPush.setGCMAPIKey;
var setVapidDetails = webPush.setVapidDetails;
var generateRequestDetails = webPush.generateRequestDetails;
var sendNotification = webPush.sendNotification;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * urlsafe-base64
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
