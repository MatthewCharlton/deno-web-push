// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
const _isFunctionLike = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
Symbol("kHandle");
const kKeyObject = Symbol("kKeyObject");
const kKeyType = Symbol("kKeyType");
function isKeyObject(obj) {
    return obj != null && obj[kKeyType] !== undefined;
}
function isCryptoKey(obj) {
    return obj != null && obj[kKeyObject] !== undefined;
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Int32Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike(value) && reTypedTag.test(_toString.call(value));
}
function isUint8Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Uint32Array]";
}
const { isDate , isArgumentsObject , isBigIntObject , isBooleanObject , isNumberObject , isStringObject , isSymbolObject , isNativeError , isRegExp , isAsyncFunction , isGeneratorFunction , isGeneratorObject , isPromise , isMap , isSet , isMapIterator , isSetIterator , isWeakMap , isWeakSet , isArrayBuffer , isDataView , isSharedArrayBuffer , isModuleNamespaceObject , isAnyArrayBuffer , isBoxedPrimitive ,  } = mod;
const mod = {
    isCryptoKey: isCryptoKey,
    isKeyObject: isKeyObject,
    isArrayBufferView: isArrayBufferView,
    isBigInt64Array: isBigInt64Array,
    isBigUint64Array: isBigUint64Array,
    isFloat32Array: isFloat32Array,
    isFloat64Array: isFloat64Array,
    isInt8Array: isInt8Array,
    isInt16Array: isInt16Array,
    isInt32Array: isInt32Array,
    isTypedArray: isTypedArray,
    isUint8Array: isUint8Array,
    isUint8ClampedArray: isUint8ClampedArray,
    isUint16Array: isUint16Array,
    isUint32Array: isUint32Array,
    isDate: isDate,
    isArgumentsObject: isArgumentsObject,
    isBigIntObject: isBigIntObject,
    isBooleanObject: isBooleanObject,
    isNumberObject: isNumberObject,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isNativeError: isNativeError,
    isRegExp: isRegExp,
    isAsyncFunction: isAsyncFunction,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isPromise: isPromise,
    isMap: isMap,
    isSet: isSet,
    isMapIterator: isMapIterator,
    isSetIterator: isSetIterator,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    isArrayBuffer: isArrayBuffer,
    isDataView: isDataView,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isAnyArrayBuffer: isAnyArrayBuffer,
    isBoxedPrimitive: isBoxedPrimitive
};
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
const codesWarned = new Set();
function deprecate(fn, msg, code) {
    if (code !== undefined) {
        validateString(code, "code");
    }
    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned.has(code)) {
                    process.emitWarning(msg, "DeprecationWarning", code, deprecated);
                    codesWarned.add(code);
                }
            } else {
                process.emitWarning(msg, "DeprecationWarning", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick(callback, ...args) {
    _nextTick(callback, ...args);
}
class NodeFalsyValueRejectionError extends Error {
    reason;
    code = "ERR_FALSY_VALUE_REJECTION";
    constructor(reason){
        super("Promise was rejected with falsy value");
        this.reason = reason;
    }
}
class NodeInvalidArgTypeError extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName){
        super(`The ${argumentName} argument must be of type function.`);
    }
}
function callbackify(original) {
    if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError('"original"');
    }
    const callbackified = function(...args) {
        const maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
            throw new NodeInvalidArgTypeError("last");
        }
        const cb = (...args)=>{
            maybeCb.apply(this, args);
        };
        original.apply(this, args).then((ret)=>{
            nextTick(cb.bind(this, null, ret));
        }, (rej)=>{
            rej = rej || new NodeFalsyValueRejectionError(rej);
            nextTick(cb.bind(this, rej));
        });
    };
    const descriptors = Object.getOwnPropertyDescriptors(original);
    if (typeof descriptors.length.value === "number") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === "string") {
        descriptors.name.value += "Callbackified";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val1 = parseInt(c);
                        if (isNaN(val1)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val1;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F.exponent];
        let esign = m[F.esign];
        let mantissa = parseInt(m[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.substr(0, splIdx) + "." + m.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F.exponent]) * (m[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.substr(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().substr(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format, ...args) {
    const printf = new Printf(format, ...args);
    return printf.doPrintf();
}
const { Deno  } = globalThis;
typeof Deno?.noColor === "boolean" ? Deno.noColor : true;
new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
var DiffType;
(function(DiffType) {
    DiffType["removed"] = "removed";
    DiffType["common"] = "common";
    DiffType["added"] = "added";
})(DiffType || (DiffType = {}));
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    name;
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
        this.name = "BufferFullError";
    }
    partial;
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r, size = 4096) {
        return r instanceof BufReader ? r : new BufReader(r, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i = 100; i > 0; i--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r) {
        this.#reset(this.#buf, r);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p) {
        let rr = p.byteLength;
        if (p.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p.byteLength >= this.#buf.byteLength) {
                const rr1 = await this.#rd.read(p);
                const nread = rr1 ?? 0;
                assert(nread >= 0, "negative read");
                return rr1;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p) {
        let bytesRead = 0;
        while(bytesRead < p.length){
            try {
                const rr = await this.read(p.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = p.subarray(0, bytesRead);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = p.subarray(0, bytesRead);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return p;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c = this.#buf[this.#r];
        this.#r++;
        return c;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer = await this.readSlice(delim.charCodeAt(0));
        if (buffer === null) return null;
        return new TextDecoder().decode(buffer);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err) {
            if (err instanceof Deno.errors.BadResource) {
                throw err;
            }
            let partial;
            if (err instanceof PartialReadError) {
                partial = err.partial;
                assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            partial = err.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s = 0;
        let slice;
        while(true){
            let i = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = this.#buf.subarray(this.#r, this.#r + i + 1);
                this.#r += i + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = slice;
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = slice;
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
        }
        return slice;
    }
    async peek(n) {
        if (n < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err) {
                if (err instanceof PartialReadError) {
                    err.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err instanceof Error) {
                    const e = new PartialReadError();
                    e.partial = this.#buf.subarray(this.#r, this.#w);
                    e.stack = err.stack;
                    e.message = err.message;
                    e.cause = err.cause;
                    throw err;
                }
                throw err;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += await this.#writer.write(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p.length){
                nwritten += this.#writer.writeSync(p.subarray(nwritten));
            }
        } catch (e) {
            if (e instanceof Error) {
                this.err = e;
            }
            throw e;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data) {
        if (this.err !== null) throw this.err;
        if (data.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data);
                } catch (e) {
                    if (e instanceof Error) {
                        this.err = e;
                    }
                    throw e;
                }
            } else {
                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data = data.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const _TextDecoder = TextDecoder;
const _TextEncoder = TextEncoder;
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i)}${meta[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet(value)) {
            const size = value.size;
            const prefix1 = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix1}{}`;
            }
            braces = [
                `${prefix1}{`,
                "}"
            ];
        } else if (isMap(value)) {
            const size1 = value.size;
            const prefix2 = getPrefix(constructor, tag, "Map", `(${size1})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size1 === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix2}{}`;
            }
            braces = [
                `${prefix2}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size2 = value.length;
            const prefix3 = getPrefix(constructor, tag, fallback, `(${size2})`);
            braces = [
                `${prefix3}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size2);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix4 = getPrefix(constructor, tag, "RegExp");
            if (prefix4 !== "RegExp ") {
                base = `${prefix4}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix5 = getPrefix(constructor, tag, "Date");
            if (prefix5 !== "Date ") {
                base = `${prefix5}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer(value)) {
            const arrayType = isArrayBuffer(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix6 = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix6 + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix6}{`;
            Array.prototype.unshift.call(keys, "byteLength");
        } else if (isDataView(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive(value)) {
            base = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName1 = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName1, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach.call(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push.call(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push.call(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push.call(output, value);
            }
        }
        Array.prototype.pop.call(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push.call(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push.call(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString.call(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name1 of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name1);
            if (index !== -1 && stack.includes(err[name1])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos1 = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos1, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos1 = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos1 === 0 ? line : line.slice(pos1);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp1 = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp1, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp2 = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp2}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending1 = remaining > 1 ? "s" : "";
            const message1 = `<${remaining} empty item${ending1}>`;
            output.push(ctx.stylize(message1, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject(value)) {
        type = "Number";
    } else if (isStringObject(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject(value)) {
        type = "Boolean";
    } else if (isBigIntObject(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation1 = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation1}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation1}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i1 = 0; i1 < columns; i1++){
            let lineMaxLength = 0;
            for(let j = i1; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i1] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i2 = 0; i2 < output.length; i2++){
                if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i3 = 0; i3 < outputLength; i3 += columns){
            const max = Math.min(i3 + columns, outputLength);
            let str = "";
            let j1 = i3;
            for(; j1 < max - 1; j1++){
                const padding = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1];
                str += `${output[j1]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding1 = maxLineLength[j1 - i3] + output[j1].length - dataLen[j1] - 2;
                str += output[j1].padStart(padding1, " ");
            } else {
                str += output[j1];
            }
            Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos1 = i * 2;
            const res = [
                formatValue(ctx, entries[pos1], recurseTimes),
                formatValue(ctx, entries[pos1 + 1], recurseTimes), 
            ];
            output[i] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function hasBuiltInToString(value) {
    const proxyTarget = undefined;
    if (proxyTarget !== undefined) {
        value = proxyTarget;
    }
    if (typeof value.toString !== "function") {
        return true;
    }
    if (Object.prototype.hasOwnProperty.call(value, "toString")) {
        return false;
    }
    let pointer = value;
    do {
        pointer = Object.getPrototypeOf(pointer);
    }while (!Object.prototype.hasOwnProperty.call(pointer, "toString"))
    const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
    return descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name);
}
const firstErrorLine = (error)=>error.message.split("\n", 1)[0];
let CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
    try {
        return JSON.stringify(arg);
    } catch (err) {
        if (!CIRCULAR_ERROR_MESSAGE) {
            try {
                const a = {};
                a.a = a;
                JSON.stringify(a);
            } catch (circularError) {
                CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
            }
        }
        if (err.name === "TypeError" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
            return "[Circular]";
        }
        throw err;
    }
}
function format(...args) {
    return formatWithOptionsInternal(undefined, args);
}
function formatWithOptions(inspectOptions, ...args) {
    if (typeof inspectOptions !== "object" || inspectOptions === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
    }
    return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
    return formatNumber(stylizeNoColor, number, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
    return formatBigInt(stylizeNoColor, bigint, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
    const first = args[0];
    let a = 0;
    let str = "";
    let join = "";
    if (typeof first === "string") {
        if (args.length === 1) {
            return first;
        }
        let tempStr;
        let lastPos = 0;
        for(let i = 0; i < first.length - 1; i++){
            if (first.charCodeAt(i) === 37) {
                const nextChar = first.charCodeAt(++i);
                if (a + 1 !== args.length) {
                    switch(nextChar){
                        case 115:
                            const tempArg = args[++a];
                            if (typeof tempArg === "number") {
                                tempStr = formatNumberNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg === "bigint") {
                                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                                tempStr = String(tempArg);
                            } else {
                                tempStr = inspect(tempArg, {
                                    ...inspectOptions,
                                    compact: 3,
                                    colors: false,
                                    depth: 0
                                });
                            }
                            break;
                        case 106:
                            tempStr = tryStringify(args[++a]);
                            break;
                        case 100:
                            const tempNum = args[++a];
                            if (typeof tempNum === "bigint") {
                                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
                            } else if (typeof tempNum === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
                            }
                            break;
                        case 79:
                            tempStr = inspect(args[++a], inspectOptions);
                            break;
                        case 111:
                            tempStr = inspect(args[++a], {
                                ...inspectOptions,
                                showHidden: true,
                                showProxy: true,
                                depth: 4
                            });
                            break;
                        case 105:
                            const tempInteger = args[++a];
                            if (typeof tempInteger === "bigint") {
                                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
                            } else if (typeof tempInteger === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
                            }
                            break;
                        case 102:
                            const tempFloat = args[++a];
                            if (typeof tempFloat === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
                            }
                            break;
                        case 99:
                            a += 1;
                            tempStr = "";
                            break;
                        case 37:
                            str += first.slice(lastPos, i);
                            lastPos = i + 1;
                            continue;
                        default:
                            continue;
                    }
                    if (lastPos !== i - 1) {
                        str += first.slice(lastPos, i - 1);
                    }
                    str += tempStr;
                    lastPos = i + 1;
                } else if (nextChar === 37) {
                    str += first.slice(lastPos, i);
                    lastPos = i + 1;
                }
            }
        }
        if (lastPos !== 0) {
            a++;
            join = " ";
            if (lastPos < first.length) {
                str += first.slice(lastPos);
            }
        }
    }
    while(a < args.length){
        const value = args[a];
        str += join;
        str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
        join = " ";
        a++;
    }
    return str;
}
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        testEnabled = ()=>false;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled, set) {
    if (debugImpls[set] === undefined) {
        if (enabled) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled = testEnabled(set);
    }
    let debug = (...args)=>{
        init();
        debug = debuglogImpl(enabled, set);
        if (typeof cb === "function") {
            cb(debug);
        }
        return debug(...args);
    };
    let enabled;
    let test = ()=>{
        init();
        test = ()=>enabled;
        return enabled;
    };
    const logger = (...args)=>debug(...args);
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let debugEnv;
try {
    debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error) {
    if (error instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
    } else {
        throw error;
    }
}
initializeDebugEnv(debugEnv);
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const os = {
    UV_UDP_IPV6ONLY: 1,
    UV_UDP_PARTIAL: 2,
    UV_UDP_REUSEADDR: 4,
    UV_UDP_MMSG_CHUNK: 8,
    UV_UDP_MMSG_FREE: 16,
    UV_UDP_LINUX_RECVERR: 32,
    UV_UDP_RECVMMSG: 256,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGBREAK: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12,
        SIGEMT: 7,
        SIGPWR: 30,
        SIGSTKFLT: 16
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
os.errno.EEXIST;
os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
codeMap.get("EAI_MEMORY");
codeMap.get("UNKNOWN");
codeMap.get("EBADF");
codeMap.get("EINVAL");
codeMap.get("ENOTSOCK");
const __default = {
    ...mod
};
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer.from(b, b.offset, b.byteLength);
    }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer.byteLength = byteLength;
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = readUInt16BE;
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = readUInt32BE;
Buffer.prototype.readBigUint64LE = Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUint64BE = Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUint64LE = Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUint64BE = Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
var valueType;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, true);
}
function innerDeepEqual(val1, val2, strict, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? Object.is(val1, val2) : true;
    }
    if (strict) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError(val1) || val1 instanceof Error) {
        if (!isNativeError(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()).toString();
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter1 = strict ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter1);
        const keysVal2 = getOwnNonIndexProperties(val2, filter1);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.noIterator, keysVal1);
    } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isSet);
    } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict, memos, valueType.isMap);
    } else if (isAnyArrayBuffer(val1)) {
        if (!isAnyArrayBuffer(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet(val2) || isMap(val2) || isDate(val2) || isRegExp(val2) || isAnyArrayBuffer(val2) || isBoxedPrimitive(val2) || isNativeError(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i = 0;
    for(; i < aKeys.length; i++){
        if (!val2.propertyIsEnumerable(aKeys[i])) {
            return false;
        }
    }
    if (strict && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                const key = symbolKeysA[i];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                return false;
            }
        } else {
            const symbolKeysB1 = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB1.length !== 0 && getEnumerables(val2, symbolKeysB1).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a, b) {
    return a.source === b.source && a.flags === b.flags && a.lastIndex === b.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i = 0; i < arr1.byteLength; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b) {
    if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b).length) {
        return false;
    }
    if (isNumberObject(a)) {
        return isNumberObject(b) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b));
    }
    if (isStringObject(a)) {
        return isStringObject(b) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b);
    }
    if (isBooleanObject(a)) {
        return isBooleanObject(b) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b);
    }
    if (isBigIntObject(a)) {
        return isBigIntObject(b) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b);
    }
    if (isSymbolObject(a)) {
        return isSymbolObject(b) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
    let i = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i < obj1.length; i++){
            if (obj1.hasOwnProperty(i)) {
                if (!obj2.hasOwnProperty(i) || !innerDeepEqual(obj1[i], obj2[i], strict, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i < keys1.length; i++){
                    const key = keys1[i];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i = 0; i < keys.length; i++){
        const key1 = keys[i];
        if (!innerDeepEqual(obj1[key1], obj2[key1], strict, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item1 of set2){
            if (typeof item1 === "object" && item1 !== null) {
                if (!setHasEqualElement(set, item1, strict, memos)) return false;
            } else if (!strict && !set1.has(item1) && !setHasEqualElement(set, item1, strict, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict, memos)) {
                if (strict) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key1 , 1: item  } of map2){
            if (typeof key1 === "object" && key1 !== null) {
                if (!mapHasEqualEntry(set, map1, key1, item, strict, memos)) {
                    return false;
                }
            } else if (!strict && (!map1.has(key1) || !innerDeepEqual(map1.get(key1), item, false, memos)) && !mapHasEqualEntry(set, map1, key1, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function isArray(value) {
    return Array.isArray(value);
}
function isBoolean(value) {
    return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
    return value === null;
}
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
function isNumber(value) {
    return typeof value === "number" || value instanceof Number;
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
    return typeof value === "symbol";
}
function isUndefined(value) {
    return value === undefined;
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isError(e) {
    return e instanceof Error;
}
function isFunction(value) {
    return typeof value === "function";
}
function isRegExp(value) {
    return __default.isRegExp(value);
}
function isDate(value) {
    return __default.isDate(value);
}
function isPrimitive(value) {
    return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer(value) {
    return Buffer.isBuffer(value);
}
function _extend(target, source) {
    if (source === null || typeof source !== "object") return target;
    const keys = Object.keys(source);
    let i = keys.length;
    while(i--){
        target[keys[i]] = source[keys[i]];
    }
    return target;
}
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
function inherits(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
    }
    if (superCtor === undefined || superCtor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
    }
    if (superCtor.prototype === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
    }
    Object.defineProperty(ctor, "super_", {
        value: superCtor,
        writable: true,
        configurable: true
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad(n) {
    return n.toString().padStart(2, "0");
}
const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec", 
];
function timestamp() {
    const d = new Date();
    const t = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds()), 
    ].join(":");
    return `${d.getDate()} ${months[d.getMonth()]} ${t}`;
}
function log(...args) {
    console.log("%s - %s", timestamp(), format(...args));
}
const __default = {
    format,
    formatWithOptions,
    inspect,
    isArray,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isSymbol,
    isUndefined,
    isObject,
    isError,
    isFunction,
    isRegExp,
    isDate,
    isPrimitive,
    isBuffer,
    _extend,
    getSystemErrorName,
    deprecate,
    callbackify,
    promisify,
    inherits,
    types: __default,
    stripVTControlCharacters,
    TextDecoder: _TextDecoder,
    TextEncoder: _TextEncoder,
    log,
    debuglog,
    isDeepStrictEqual
};
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code, message){
        super(URIError.prototype.name, code, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last1 = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last1}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last2 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last2}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
const CHAR_FORWARD_SLASH = 47;
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format("\\", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default = {
    basename,
    delimiter,
    dirname,
    extname,
    format,
    fromFileUrl,
    isAbsolute,
    join,
    normalize,
    parse,
    relative,
    resolve,
    sep,
    toFileUrl,
    toNamespacedPath
};
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl,
    default: __default
};
const sep = "/";
const delimiter = ":";
function resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve(from);
    to = resolve(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath(path) {
    return path;
}
function dirname(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format("/", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default = {
    basename,
    delimiter,
    dirname,
    extname,
    format,
    fromFileUrl,
    isAbsolute,
    join,
    normalize,
    parse,
    relative,
    resolve,
    sep,
    toFileUrl,
    toNamespacedPath
};
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl,
    default: __default
};
const path = isWindows ? mod : mod;
const { join , normalize  } = path;
const path = isWindows ? __default : __default;
const { basename , delimiter , dirname , extname , format , fromFileUrl , isAbsolute , join , normalize , parse , relative , resolve , sep , toFileUrl , toNamespacedPath ,  } = path;
"use strict";
const base = 36;
const damp = 700;
const delimiter = "-";
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin = 36 - 1;
function error(type) {
    throw new RangeError(errors[type]);
}
function mapDomain(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k += base){
        delta = Math.floor(delta / baseMinusTMin);
    }
    return Math.floor(k + (baseMinusTMin + 1) * delta / (delta + 38));
}
function encode(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 0x80) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter);
    }
    while(handledCPCount < inputLength){
        let m = 2147483647;
        for (const currentValue1 of input){
            if (currentValue1 >= n && currentValue1 < m) {
                m = currentValue1;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue2 of input){
            if (currentValue2 < n && ++delta > 2147483647) {
                error("overflow");
            }
            if (currentValue2 == n) {
                let q = delta;
                for(let k = 36;; k += base){
                    const t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = 36 - t;
                    output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                    q = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join("");
}
function toASCII(input) {
    return mapDomain(input, function(str) {
        return regexNonASCII.test(str) ? "xn--" + encode(str) : str;
    });
}
const hexTable = new Array(256);
for(let i = 0; i < 256; ++i){
    hexTable[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i = 0; i < len; i++){
        let c = str.charCodeAt(i);
        if (c < 0x80) {
            if (noEscapeTable[c] === 1) continue;
            if (lastPos < i) out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
            continue;
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        if (c < 0x800) {
            lastPos = i + 1;
            out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        if (c < 0xd800 || c >= 0xe000) {
            lastPos = i + 1;
            out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
            continue;
        }
        ++i;
        if (i >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i) & 0x3ff;
        lastPos = i + 1;
        c = 0x10000 + ((c & 0x3ff) << 10 | c2);
        out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode = parse;
const encode = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable);
}
const escape = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret = new Array(str.length);
    for(let i = 0; i < str.length; ++i){
        ret[i] = str.charCodeAt(i);
    }
    return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode) {
    if (key.length > 0 && keyEncoded) {
        key = decode(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse(str, sep = "&", eq = "=", { decodeURIComponent: decodeURIComponent1 = unescape , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep ? [
        38
    ] : charCodes(String(sep));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode = unescape;
    if (decodeURIComponent1) {
        decode = decodeURIComponent1;
    }
    const customDecode = decode !== unescape;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i = 0; i < str.length; ++i){
        const code = str.charCodeAt(i);
        if (code === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end1 = i - eqIdx + 1;
                        if (lastPos < end1) {
                            key += str.slice(lastPos, end1);
                        }
                        encodeCheck = 0;
                        lastPos = i + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code === 43) {
                    if (lastPos < i) {
                        key += str.slice(lastPos, i);
                    }
                    key += plusChar;
                    lastPos = i + 1;
                    continue;
                }
            }
            if (code === 43) {
                if (lastPos < i) {
                    value += str.slice(lastPos, i);
                }
                value += plusChar;
                lastPos = i + 1;
            } else if (!valEncoded) {
                if (code === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v) {
    if (typeof v === "string") {
        return v;
    }
    if (typeof v === "number" && isFinite(v)) {
        return "" + v;
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v, encode) {
    return encode(stringifyPrimitive(v));
}
function encodeStringified(v, encode) {
    if (typeof v === "string") {
        return v.length ? encode(v) : "";
    }
    if (typeof v === "number" && isFinite(v)) {
        return Math.abs(v) < 1e21 ? "" + v : encode("" + v);
    }
    if (typeof v === "bigint") {
        return "" + v;
    }
    if (typeof v === "boolean") {
        return v ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep, eq, options) {
    sep ||= "&";
    eq ||= "=";
    const encode = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i = 0; i < len; ++i){
            const k = keys[i];
            const v = obj[k];
            let ks = convert(k, encode);
            ks += eq;
            if (Array.isArray(v)) {
                const vlen = v.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep;
                    }
                    fields += ks;
                    fields += convert(v[j], encode);
                }
            } else {
                if (fields) {
                    fields += sep;
                }
                fields += ks;
                fields += convert(v, encode);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
    const out = new Buffer(s.length);
    let index = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s.length - 2;
    let hasHex = false;
    while(index < s.length){
        currentChar = s.charCodeAt(index);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index++;
            continue;
        }
        if (currentChar === 37 && index < maxLength) {
            currentChar = s.charCodeAt(++index);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s.charCodeAt(++index);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
    try {
        return decodeURIComponent(s);
    } catch  {
        return unescapeBuffer(s).toString();
    }
}
const unescape = qsUnescape;
const __default = {
    parse,
    stringify,
    decode,
    encode,
    unescape,
    escape,
    unescapeBuffer
};
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:", 
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
URL;
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
     #parseHost() {
        let host = this.host || "";
        let port = portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ":") {
                this.port = port.slice(1);
            }
            host = host.slice(0, host.length - port.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative) {
        return this.resolveObject(parse(relative, false, true)).format();
    }
    resolveObject(relative) {
        if (typeof relative === "string") {
            const rel = new Url();
            rel.urlParse(relative, false, true);
            relative = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative.hash;
        if (relative.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative.slashes && !relative.protocol) {
            const rkeys = Object.keys(relative);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative.protocol)) {
                const keys = Object.keys(relative);
                for(let v = 0; v < keys.length; v++){
                    const k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !/^file:?$/.test(relative.protocol) && !hostlessProtocol.has(relative.protocol)) {
                const relPath = (relative.pathname || "").split("/");
                while(relPath.length && !(relative.host = relPath.shift() || null));
                if (!relative.host) relative.host = "";
                if (!relative.hostname) relative.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
                const p = result.pathname || "";
                const s = result.search || "";
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath1 = relative.pathname && relative.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                result.auth = null;
                if (relative.host) {
                    if (relPath1[0] === "") relPath1[0] = relative.host;
                    else relPath1.unshift(relative.host);
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath1[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative.host || relative.host === "") {
                if (result.host !== relative.host) result.auth = null;
                result.host = relative.host;
                result.port = relative.port;
            }
            if (relative.hostname || relative.hostname === "") {
                if (result.hostname !== relative.hostname) result.auth = null;
                result.hostname = relative.hostname;
            }
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath1;
        } else if (relPath1.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath1);
            result.search = relative.search;
            result.query = relative.query;
        } else if (relative.search !== null && relative.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for(let i = srcPath.length - 1; i >= 0; i--){
            last = srcPath[i];
            if (last === ".") {
                srcPath.splice(i, 1);
            } else if (last === "..") {
                srcPath.splice(i, 1);
                up++;
            } else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost1 = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost1) {
                result.auth = authInHost1.shift() || null;
                result.host = result.hostname = authInHost1.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i = 0; i < pathname.length; ++i){
            switch(pathname.charCodeAt(i)){
                case 35:
                    if (i - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i);
                    }
                    newPathname += "%23";
                    lastPos = i + 1;
                    break;
                case 63:
                    if (i - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i);
                    }
                    newPathname += "%3F";
                    lastPos = i + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url, parseQueryString, slashesDenoteHost) {
        let hasHash = false;
        let start = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i = 0, inWs = false, split = false; i < url.length; ++i){
            const code = url.charCodeAt(i);
            const isWs = code === 32 || code === 9 || code === 13 || code === 10 || code === 12 || code === 160 || code === 65279;
            if (start === -1) {
                if (isWs) continue;
                lastPos = start = i;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i;
                inWs = true;
            }
            if (!split) {
                switch(code){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i - lastPos > 0) rest += url.slice(lastPos, i);
                        rest += "/";
                        lastPos = i + 1;
                        break;
                }
            } else if (!hasHash && code === 35) {
                hasHash = true;
            }
        }
        if (start !== -1) {
            if (lastPos === start) {
                if (end === -1) {
                    if (start === 0) rest = url;
                    else rest = url.slice(start);
                } else {
                    rest = url.slice(start, end);
                }
            } else if (end === -1 && lastPos < url.length) {
                rest += url.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
            proto = proto[0];
            lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
            if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i1 = 0; i1 < rest.length; ++i1){
                switch(rest.charCodeAt(i1)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i1;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i1;
                        hostEnd = i1;
                        break;
                    case 64:
                        atSign = i1;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start);
                rest = "";
            } else {
                this.host = rest.slice(start, nonHost);
                rest = rest.slice(nonHost);
            }
            this.#parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                this.hostname = toASCII(this.hostname);
            }
            const p = this.port ? ":" + this.port : "";
            const h = this.hostname || "";
            this.host = h + p;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i2 = 0; i2 < rest.length; ++i2){
            const code1 = rest.charCodeAt(i2);
            if (code1 === 35) {
                this.hash = rest.slice(i2);
                hashIdx = i2;
                break;
            } else if (code1 === 63 && questionIdx === -1) {
                questionIdx = i2;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p1 = this.pathname || "";
            const s = this.search || "";
            this.path = p1 + s;
        }
        this.href = this.format();
        return this;
    }
}
function isIpv6Hostname(hostname) {
    return hostname.charCodeAt(0) === 91 && hostname.charCodeAt(hostname.length - 1) === 93;
}
function getHostname(self1, rest, hostname) {
    for(let i = 0; i < hostname.length; ++i){
        const code = hostname.charCodeAt(i);
        const isValid = code >= 97 && code <= 122 || code === 46 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 43 || code === 95 || code > 127;
        if (!isValid) {
            self1.hostname = hostname.slice(0, i);
            return `/${hostname.slice(i)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i = 0; i < rest.length; ++i){
        const escapedChar = escapedCodes[rest.charCodeAt(i)];
        if (escapedChar) {
            if (i > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i);
            }
            escaped += escapedChar;
            lastEscapedPos = i + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse(url, parseQueryString, slashesDenoteHost) {
    if (url instanceof Url) return url;
    const urlObject = new Url();
    urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
    return urlObject;
}
const ENC = {
    '+': '-',
    '/': '_',
    '=': '.'
};
const DEC = {
    '-': '+',
    _: '/',
    '.': '='
};
const encode = (base64)=>{
    return base64.replace(/[+/=]/g, (m)=>ENC[m]);
};
const decode = (safe)=>{
    return safe.replace(/[-_.]/g, (m)=>DEC[m]);
};
const isUrlSafeBase64 = (string)=>/^[A-Za-z0-9_-]*[.]{0,2}$/.test(string);
'use strict';
function WebPushError(message, statusCode, headers, body, endpoint) {
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.message = message;
    this.statusCode = statusCode;
    this.headers = headers;
    this.body = body;
    this.endpoint = endpoint;
}
__default.inherits(WebPushError, Error);
var yr = Object.create;
var N = Object.defineProperty;
var wr = Object.getOwnPropertyDescriptor;
var xr = Object.getOwnPropertyNames;
var Br = Object.getPrototypeOf, Er = Object.prototype.hasOwnProperty;
var dr = (i)=>N(i, "__esModule", {
        value: !0
    });
var k = (i, r)=>()=>(r || i((r = {
            exports: {}
        }).exports, r), r.exports);
var gr = (i, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of xr(r))!Er.call(i, n) && n !== "default" && N(i, n, {
        get: ()=>r[n],
        enumerable: !(t = wr(r, n)) || t.enumerable
    });
    return i;
}, H = (i)=>gr(dr(N(i != null ? yr(Br(i)) : {}, "default", i && i.__esModule && "default" in i ? {
        get: ()=>i.default,
        enumerable: !0
    } : {
        value: i,
        enumerable: !0
    })), i);
var J = k((_)=>{
    "use strict";
    _.byteLength = Ir;
    _.toByteArray = Ar;
    _.fromByteArray = Rr;
    var B = [], w = [], mr = typeof Uint8Array != "undefined" ? Uint8Array : Array, b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for(m = 0, V = b.length; m < V; ++m)B[m] = b[m], w[b.charCodeAt(m)] = m;
    var m, V;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function z(i) {
        var r = i.length;
        if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var t = i.indexOf("=");
        t === -1 && (t = r);
        var n = t === r ? 0 : 4 - t % 4;
        return [
            t,
            n
        ];
    }
    function Ir(i) {
        var r = z(i), t = r[0], n = r[1];
        return (t + n) * 3 / 4 - n;
    }
    function Fr(i, r, t) {
        return (r + t) * 3 / 4 - t;
    }
    function Ar(i) {
        var r, t = z(i), n = t[0], e = t[1], o = new mr(Fr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
        for(c = 0; c < f; c += 4)r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
        return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Ur(i) {
        return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function Tr(i, r, t) {
        for(var n, e = [], o = r; o < t; o += 3)n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Ur(n));
        return e.join("");
    }
    function Rr(i) {
        for(var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n; u < f; u += o)e.push(Tr(i, u, u + o > f ? f : u + o));
        return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
});
var K = k((D)=>{
    D.read = function(i, r, t, n, e) {
        var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
        for(p += F, o = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o = o * 256 + i[r + p], p += F, s -= 8);
        for(u = o & (1 << -s) - 1, o >>= -s, s += n; s > 0; u = u * 256 + i[r + p], p += F, s -= 8);
        if (o === 0) o = 1 - l;
        else {
            if (o === c) return u ? NaN : (x ? -1 : 1) * (1 / 0);
            u = u + Math.pow(2, n), o = o - l;
        }
        return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    D.write = function(i, r, t, n, e, o) {
        var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, M = n ? 1 : -1, ar = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for(r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += M, f /= 256, e -= 8);
        for(u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += M, u /= 256, l -= 8);
        i[t + x - M] |= ar * 128;
    };
});
var X = k((R)=>{
    "use strict";
    var $ = J(), A = K(), Z = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    R.Buffer = h;
    R.SlowBuffer = Nr;
    R.INSPECT_MAX_BYTES = 50;
    var S = 2147483647;
    R.kMaxLength = S;
    h.TYPED_ARRAY_SUPPORT = Cr();
    !h.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Cr() {
        try {
            let i = new Uint8Array(1), r = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
        } catch (i1) {
            return !1;
        }
    }
    Object.defineProperty(h.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (!!h.isBuffer(this)) return this.buffer;
        }
    });
    Object.defineProperty(h.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (!!h.isBuffer(this)) return this.byteOffset;
        }
    });
    function d(i) {
        if (i > S) throw new RangeError('The value "' + i + '" is invalid for option "size"');
        let r = new Uint8Array(i);
        return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
        if (typeof i == "number") {
            if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return P(i);
        }
        return Q(i, r, t);
    }
    h.poolSize = 8192;
    function Q(i, r, t) {
        if (typeof i == "string") return Sr(i, r);
        if (ArrayBuffer.isView(i)) return Lr(i);
        if (i == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
        if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer))) return G(i, r, t);
        if (typeof i == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        let n = i.valueOf && i.valueOf();
        if (n != null && n !== i) return h.from(n, r, t);
        let e = Mr(i);
        if (e) return e;
        if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function") return h.from(i[Symbol.toPrimitive]("string"), r, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
        return Q(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function v(i) {
        if (typeof i != "number") throw new TypeError('"size" argument must be of type number');
        if (i < 0) throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function _r(i, r, t) {
        return v(i), i <= 0 ? d(i) : r !== void 0 ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
        return _r(i, r, t);
    };
    function P(i) {
        return v(i), d(i < 0 ? 0 : Y(i) | 0);
    }
    h.allocUnsafe = function(i) {
        return P(i);
    };
    h.allocUnsafeSlow = function(i) {
        return P(i);
    };
    function Sr(i, r) {
        if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        let t = rr(i, r) | 0, n = d(t), e = n.write(i, r);
        return e !== t && (n = n.slice(0, e)), n;
    }
    function O(i) {
        let r = i.length < 0 ? 0 : Y(i.length) | 0, t = d(r);
        for(let n = 0; n < r; n += 1)t[n] = i[n] & 255;
        return t;
    }
    function Lr(i) {
        if (E(i, Uint8Array)) {
            let r = new Uint8Array(i);
            return G(r.buffer, r.byteOffset, r.byteLength);
        }
        return O(i);
    }
    function G(i, r, t) {
        if (r < 0 || i.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
        if (i.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let n;
        return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function Mr(i) {
        if (h.isBuffer(i)) {
            let r = Y(i.length) | 0, t = d(r);
            return t.length === 0 || i.copy(t, 0, 0, r), t;
        }
        if (i.length !== void 0) return typeof i.length != "number" || j(i.length) ? d(0) : O(i);
        if (i.type === "Buffer" && Array.isArray(i.data)) return O(i.data);
    }
    function Y(i) {
        if (i >= S) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S.toString(16) + " bytes");
        return i | 0;
    }
    function Nr(i) {
        return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
        return r != null && r._isBuffer === !0 && r !== h.prototype;
    };
    h.compare = function(r, t) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (r === t) return 0;
        let n = r.length, e = t.length;
        for(let o = 0, u = Math.min(n, e); o < u; ++o)if (r[o] !== t[o]) {
            n = r[o], e = t[o];
            break;
        }
        return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
        switch(String(r).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    };
    h.concat = function(r, t) {
        if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return h.alloc(0);
        let n;
        if (t === void 0) for(t = 0, n = 0; n < r.length; ++n)t += r[n].length;
        let e = h.allocUnsafe(t), o = 0;
        for(n = 0; n < r.length; ++n){
            let u = r[n];
            if (E(u, Uint8Array)) o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
            else if (h.isBuffer(u)) u.copy(e, o);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            o += u.length;
        }
        return e;
    };
    function rr(i, r) {
        if (h.isBuffer(i)) return i.length;
        if (ArrayBuffer.isView(i) || E(i, ArrayBuffer)) return i.byteLength;
        if (typeof i != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
        let t = i.length, n = arguments.length > 2 && arguments[2] === !0;
        if (!n && t === 0) return 0;
        let e = !1;
        for(;;)switch(r){
            case "ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return W(i).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return lr(i).length;
            default:
                if (e) return n ? -1 : W(i).length;
                r = ("" + r).toLowerCase(), e = !0;
        }
    }
    h.byteLength = rr;
    function kr(i, r, t) {
        let n = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
        for(i || (i = "utf8");;)switch(i){
            case "hex":
                return jr(this, r, t);
            case "utf8":
            case "utf-8":
                return nr(this, r, t);
            case "ascii":
                return qr(this, r, t);
            case "latin1":
            case "binary":
                return Wr(this, r, t);
            case "base64":
                return Gr(this, r, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Xr(this, r, t);
            default:
                if (n) throw new TypeError("Unknown encoding: " + i);
                i = (i + "").toLowerCase(), n = !0;
        }
    }
    h.prototype._isBuffer = !0;
    function I(i, r, t) {
        let n = i[r];
        i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
        let r = this.length;
        if (r % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let t = 0; t < r; t += 2)I(this, t, t + 1);
        return this;
    };
    h.prototype.swap32 = function() {
        let r = this.length;
        if (r % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let t = 0; t < r; t += 4)I(this, t, t + 3), I(this, t + 1, t + 2);
        return this;
    };
    h.prototype.swap64 = function() {
        let r = this.length;
        if (r % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let t = 0; t < r; t += 8)I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
        return this;
    };
    h.prototype.toString = function() {
        let r = this.length;
        return r === 0 ? "" : arguments.length === 0 ? nr(this, 0, r) : kr.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
        if (!h.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
        let r = "", t = R.INSPECT_MAX_BYTES;
        return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    Z && (h.prototype[Z] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
        if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
        if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o === void 0 && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length) throw new RangeError("out of range index");
        if (e >= o && t >= n) return 0;
        if (e >= o) return -1;
        if (t >= n) return 1;
        if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r) return 0;
        let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
        for(let p = 0; p < c; ++p)if (l[p] !== s[p]) {
            u = l[p], f = s[p];
            break;
        }
        return u < f ? -1 : f < u ? 1 : 0;
    };
    function tr(i, r, t, n, e) {
        if (i.length === 0) return -1;
        if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, j(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
            if (e) return -1;
            t = i.length - 1;
        } else if (t < 0) if (e) t = 0;
        else return -1;
        if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r)) return r.length === 0 ? -1 : ir(i, r, t, n, e);
        if (typeof r == "number") return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir(i, [
            r
        ], t, n, e);
        throw new TypeError("val must be string, number or Buffer");
    }
    function ir(i, r, t, n, e) {
        let o = 1, u = i.length, f = r.length;
        if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
            if (i.length < 2 || r.length < 2) return -1;
            o = 2, u /= 2, f /= 2, t /= 2;
        }
        function c(s, p) {
            return o === 1 ? s[p] : s.readUInt16BE(p * o);
        }
        let l;
        if (e) {
            let s = -1;
            for(l = t; l < u; l++)if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
                if (s === -1 && (s = l), l - s + 1 === f) return s * o;
            } else s !== -1 && (l -= l - s), s = -1;
        } else for(t + f > u && (t = u - f), l = t; l >= 0; l--){
            let s1 = !0;
            for(let p = 0; p < f; p++)if (c(i, l + p) !== c(r, p)) {
                s1 = !1;
                break;
            }
            if (s1) return l;
        }
        return -1;
    }
    h.prototype.includes = function(r, t, n) {
        return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
        return tr(this, r, t, n, !0);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
        return tr(this, r, t, n, !1);
    };
    function br(i, r, t, n) {
        t = Number(t) || 0;
        let e = i.length - t;
        n ? (n = Number(n), n > e && (n = e)) : n = e;
        let o = r.length;
        n > o / 2 && (n = o / 2);
        let u;
        for(u = 0; u < n; ++u){
            let f = parseInt(r.substr(u * 2, 2), 16);
            if (j(f)) return u;
            i[t + u] = f;
        }
        return u;
    }
    function Dr(i, r, t, n) {
        return L(W(r, i.length - t), i, t, n);
    }
    function $r(i, r, t, n) {
        return L(Jr(r), i, t, n);
    }
    function Pr(i, r, t, n) {
        return L(lr(r), i, t, n);
    }
    function Or(i, r, t, n) {
        return L(Kr(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
        if (t === void 0) e = "utf8", n = this.length, t = 0;
        else if (n === void 0 && typeof t == "string") e = t, n = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let o = this.length - t;
        if ((n === void 0 || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        e || (e = "utf8");
        let u = !1;
        for(;;)switch(e){
            case "hex":
                return br(this, r, t, n);
            case "utf8":
            case "utf-8":
                return Dr(this, r, t, n);
            case "ascii":
            case "latin1":
            case "binary":
                return $r(this, r, t, n);
            case "base64":
                return Pr(this, r, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Or(this, r, t, n);
            default:
                if (u) throw new TypeError("Unknown encoding: " + e);
                e = ("" + e).toLowerCase(), u = !0;
        }
    };
    h.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function Gr(i, r, t) {
        return r === 0 && t === i.length ? $.fromByteArray(i) : $.fromByteArray(i.slice(r, t));
    }
    function nr(i, r, t) {
        t = Math.min(i.length, t);
        let n = [], e = r;
        for(; e < t;){
            let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
            if (e + f <= t) {
                let c, l, s, p;
                switch(f){
                    case 1:
                        o < 128 && (u = o);
                        break;
                    case 2:
                        c = i[e + 1], (c & 192) == 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
                        break;
                    case 3:
                        c = i[e + 1], l = i[e + 2], (c & 192) == 128 && (l & 192) == 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
                        break;
                    case 4:
                        c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) == 128 && (l & 192) == 128 && (s & 192) == 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
                }
            }
            u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
        }
        return Yr(n);
    }
    var er = 4096;
    function Yr(i) {
        let r = i.length;
        if (r <= er) return String.fromCharCode.apply(String, i);
        let t = "", n = 0;
        for(; n < r;)t += String.fromCharCode.apply(String, i.slice(n, n += er));
        return t;
    }
    function qr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e] & 127);
        return n;
    }
    function Wr(i, r, t) {
        let n = "";
        t = Math.min(i.length, t);
        for(let e = r; e < t; ++e)n += String.fromCharCode(i[e]);
        return n;
    }
    function jr(i, r, t) {
        let n = i.length;
        (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
        let e = "";
        for(let o = r; o < t; ++o)e += Zr[i[o]];
        return e;
    }
    function Xr(i, r, t) {
        let n = i.slice(r, t), e = "";
        for(let o = 0; o < n.length - 1; o += 2)e += String.fromCharCode(n[o] + n[o + 1] * 256);
        return e;
    }
    h.prototype.slice = function(r, t) {
        let n = this.length;
        r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
        let e = this.subarray(r, t);
        return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
        if (i % 1 != 0 || i < 0) throw new RangeError("offset is not uint");
        if (i + r > t) throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r + --t], o = 1;
        for(; t > 0 && (o *= 256);)e += this[r + --t] * o;
        return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
        return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
        return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
        return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = this[r], o = 1, u = 0;
        for(; ++u < t && (o *= 256);)e += this[r + u] * o;
        return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
        r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
        let e = t, o = 1, u = this[r + --e];
        for(; e > 0 && (o *= 256);)u += this[r + --e] * o;
        return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
        return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r] | this[r + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
        r = r >>> 0, t || a(r, 2, this.length);
        let n = this[r + 1] | this[r] << 8;
        return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
        return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
        r = r >>> 0, T(r, "offset");
        let t = this[r], n = this[r + 7];
        (t === void 0 || n === void 0) && C(r, this.length - 8);
        let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
        return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), A.read(this, r, !0, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
        return r = r >>> 0, t || a(r, 4, this.length), A.read(this, r, !1, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), A.read(this, r, !0, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
        return r = r >>> 0, t || a(r, 8, this.length), A.read(this, r, !1, 52, 8);
    };
    function y(i, r, t, n, e, o) {
        if (!h.isBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > e || r < o) throw new RangeError('"value" argument is out of bounds');
        if (t + n > i.length) throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = 1, u = 0;
        for(this[t] = r & 255; ++u < n && (o *= 256);)this[t + u] = r / o & 255;
        return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
            let f = Math.pow(2, 8 * n) - 1;
            y(this, r, t, n, f, 0);
        }
        let o = n - 1, u = 1;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)this[t + o] = r / u & 255;
        return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function or(i, r, t, n, e) {
        sr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function ur(i, r, t, n, e) {
        sr(r, n, e, i, t, 7);
        let o = Number(r & BigInt(4294967295));
        i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
        let u = Number(r >> BigInt(32) & BigInt(4294967295));
        return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
        return or(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
        return ur(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = 0, u = 1, f = 0;
        for(this[t] = r & 255; ++o < n && (u *= 256);)r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
        if (r = +r, t = t >>> 0, !e) {
            let c = Math.pow(2, 8 * n - 1);
            y(this, r, t, n, c - 1, -c);
        }
        let o = n - 1, u = 1, f = 0;
        for(this[t + o] = r & 255; --o >= 0 && (u *= 256);)r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
        return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
        return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
        return or(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
        return ur(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function hr(i, r, t, n, e, o) {
        if (t + n > i.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    function fr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || hr(i, r, t, 4, 34028234663852886e22, -34028234663852886e22), A.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
        return fr(this, r, t, !0, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
        return fr(this, r, t, !1, n);
    };
    function cr(i, r, t, n, e) {
        return r = +r, t = t >>> 0, e || hr(i, r, t, 8, 17976931348623157e292, -17976931348623157e292), A.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
        return cr(this, r, t, !0, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
        return cr(this, r, t, !1, n);
    };
    h.prototype.copy = function(r, t, n, e) {
        if (!h.isBuffer(r)) throw new TypeError("argument should be a Buffer");
        if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
        if (e < 0) throw new RangeError("sourceEnd out of bounds");
        e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
        let o = e - n;
        return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
        if (typeof r == "string") {
            if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string") throw new TypeError("encoding must be a string");
            if (typeof e == "string" && !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            if (r.length === 1) {
                let u = r.charCodeAt(0);
                (e === "utf8" && u < 128 || e === "latin1") && (r = u);
            }
        } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
        if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
        if (n <= t) return this;
        t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
        let o;
        if (typeof r == "number") for(o = t; o < n; ++o)this[o] = r;
        else {
            let u1 = h.isBuffer(r) ? r : h.from(r, e), f = u1.length;
            if (f === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
            for(o = 0; o < n - t; ++o)this[o + t] = u1[o % f];
        }
        return this;
    };
    var U = {};
    function q(i, r, t) {
        U[i] = class extends t {
            constructor(){
                super();
                Object.defineProperty(this, "message", {
                    value: r.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
            }
            get code() {
                return i;
            }
            set code(e) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: e,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${i}]: ${this.message}`;
            }
        };
    }
    q("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
        return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    q("ERR_INVALID_ARG_TYPE", function(i, r) {
        return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    q("ERR_OUT_OF_RANGE", function(i, r, t) {
        let n = `The value of "${i}" is out of range.`, e = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = pr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = pr(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
    }, RangeError);
    function pr(i) {
        let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
        for(; t >= n + 4; t -= 3)r = `_${i.slice(t - 3, t)}${r}`;
        return `${i.slice(0, t)}${r}`;
    }
    function Hr(i, r, t) {
        T(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && C(r, i.length - (t + 1));
    }
    function sr(i, r, t, n, e, o) {
        if (i > t || i < r) {
            let u = typeof r == "bigint" ? "n" : "", f;
            throw o > 3 ? r === 0 || r === BigInt(0) ? f = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f = `>= ${r}${u} and <= ${t}${u}`, new U.ERR_OUT_OF_RANGE("value", f, i);
        }
        Hr(n, e, o);
    }
    function T(i, r) {
        if (typeof i != "number") throw new U.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function C(i, r, t) {
        throw Math.floor(i) !== i ? (T(i, t), new U.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new U.ERR_BUFFER_OUT_OF_BOUNDS : new U.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Vr = /[^+/0-9A-Za-z-_]/g;
    function zr(i) {
        if (i = i.split("=")[0], i = i.trim().replace(Vr, ""), i.length < 2) return "";
        for(; i.length % 4 != 0;)i = i + "=";
        return i;
    }
    function W(i, r) {
        r = r || 1 / 0;
        let t, n = i.length, e = null, o = [];
        for(let u = 0; u < n; ++u){
            if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
                if (!e) {
                    if (t > 56319) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    } else if (u + 1 === n) {
                        (r -= 3) > -1 && o.push(239, 191, 189);
                        continue;
                    }
                    e = t;
                    continue;
                }
                if (t < 56320) {
                    (r -= 3) > -1 && o.push(239, 191, 189), e = t;
                    continue;
                }
                t = (e - 55296 << 10 | t - 56320) + 65536;
            } else e && (r -= 3) > -1 && o.push(239, 191, 189);
            if (e = null, t < 128) {
                if ((r -= 1) < 0) break;
                o.push(t);
            } else if (t < 2048) {
                if ((r -= 2) < 0) break;
                o.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((r -= 3) < 0) break;
                o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((r -= 4) < 0) break;
                o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return o;
    }
    function Jr(i) {
        let r = [];
        for(let t = 0; t < i.length; ++t)r.push(i.charCodeAt(t) & 255);
        return r;
    }
    function Kr(i, r) {
        let t, n, e, o = [];
        for(let u = 0; u < i.length && !((r -= 2) < 0); ++u)t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
        return o;
    }
    function lr(i) {
        return $.toByteArray(zr(i));
    }
    function L(i, r, t, n) {
        let e;
        for(e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)r[e + t] = i[e];
        return e;
    }
    function E(i, r) {
        return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function j(i) {
        return i !== i;
    }
    var Zr = function() {
        let i = "0123456789abcdef", r = new Array(256);
        for(let t = 0; t < 16; ++t){
            let n = t * 16;
            for(let e = 0; e < 16; ++e)r[n + e] = i[t] + i[e];
        }
        return r;
    }();
    function g(i) {
        return typeof BigInt == "undefined" ? Qr : i;
    }
    function Qr() {
        throw new Error("BigInt not supported");
    }
});
var vr = H(X()), rt = H(X()), { Buffer: ut , SlowBuffer: ht , INSPECT_MAX_BYTES: ft , kMaxLength: ct  } = vr;
var export_default = rt.default;
var di = Object.create;
var Lt = Object.defineProperty;
var mi = Object.getOwnPropertyDescriptor;
var pi = Object.getOwnPropertyNames;
var Mi = Object.getPrototypeOf, gi = Object.prototype.hasOwnProperty;
var ci = (x)=>Lt(x, "__esModule", {
        value: !0
    });
var yi = (x, et)=>()=>(et || x((et = {
            exports: {}
        }).exports, et), et.exports);
var xi = (x, et, v)=>{
    if (et && typeof et == "object" || typeof et == "function") for (let ft of pi(et))!gi.call(x, ft) && ft !== "default" && Lt(x, ft, {
        get: ()=>et[ft],
        enumerable: !(v = mi(et, ft)) || v.enumerable
    });
    return x;
}, si = (x)=>xi(ci(Lt(x != null ? di(Mi(x)) : {}, "default", x && x.__esModule && "default" in x ? {
        get: ()=>x.default,
        enumerable: !0
    } : {
        value: x,
        enumerable: !0
    })), x);
var It = yi((oi, zt)=>{
    (function(x, et) {
        "use strict";
        function v(o, t) {
            if (!o) throw new Error(t || "Assertion failed");
        }
        function ft(o, t) {
            o.super_ = t;
            var r = function() {};
            r.prototype = t.prototype, o.prototype = new r, o.prototype.constructor = o;
        }
        function l(o, t, r) {
            if (l.isBN(o)) return o;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, o !== null && ((t === "le" || t === "be") && (r = t, t = 10), this._init(o || 0, t || 10, r || "be"));
        }
        typeof x == "object" ? x.exports = l : et.BN = l, l.BN = l, l.wordSize = 26;
        var at;
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? at = window.Buffer : at = export_default.Buffer;
        } catch (o) {}
        l.isBN = function(t) {
            return t instanceof l ? !0 : t !== null && typeof t == "object" && t.constructor.wordSize === l.wordSize && Array.isArray(t.words);
        }, l.max = function(t, r) {
            return t.cmp(r) > 0 ? t : r;
        }, l.min = function(t, r) {
            return t.cmp(r) < 0 ? t : r;
        }, l.prototype._init = function(t, r, e) {
            if (typeof t == "number") return this._initNumber(t, r, e);
            if (typeof t == "object") return this._initArray(t, r, e);
            r === "hex" && (r = 16), v(r === (r | 0) && r >= 2 && r <= 36), t = t.toString().replace(/\s+/g, "");
            var h = 0;
            t[0] === "-" && (h++, this.negative = 1), h < t.length && (r === 16 ? this._parseHex(t, h, e) : (this._parseBase(t, r, h), e === "le" && this._initArray(this.toArray(), r, e)));
        }, l.prototype._initNumber = function(t, r, e) {
            t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [
                t & 67108863
            ], this.length = 1) : t < 4503599627370496 ? (this.words = [
                t & 67108863,
                t / 67108864 & 67108863
            ], this.length = 2) : (v(t < 9007199254740992), this.words = [
                t & 67108863,
                t / 67108864 & 67108863,
                1
            ], this.length = 3), e === "le" && this._initArray(this.toArray(), r, e);
        }, l.prototype._initArray = function(t, r, e) {
            if (v(typeof t.length == "number"), t.length <= 0) return this.words = [
                0
            ], this.length = 1, this;
            this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
            for(var h = 0; h < this.length; h++)this.words[h] = 0;
            var s, a, u = 0;
            if (e === "be") for(h = t.length - 1, s = 0; h >= 0; h -= 3)a = t[h] | t[h - 1] << 8 | t[h - 2] << 16, this.words[s] |= a << u & 67108863, this.words[s + 1] = a >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, s++);
            else if (e === "le") for(h = 0, s = 0; h < t.length; h += 3)a = t[h] | t[h + 1] << 8 | t[h + 2] << 16, this.words[s] |= a << u & 67108863, this.words[s + 1] = a >>> 26 - u & 67108863, u += 24, u >= 26 && (u -= 26, s++);
            return this.strip();
        };
        function Nt(o, t) {
            var r = o.charCodeAt(t);
            return r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : r - 48 & 15;
        }
        function Et(o, t, r) {
            var e = Nt(o, r);
            return r - 1 >= t && (e |= Nt(o, r - 1) << 4), e;
        }
        l.prototype._parseHex = function(t, r, e) {
            this.length = Math.ceil((t.length - r) / 6), this.words = new Array(this.length);
            for(var h = 0; h < this.length; h++)this.words[h] = 0;
            var s = 0, a = 0, u;
            if (e === "be") for(h = t.length - 1; h >= r; h -= 2)u = Et(t, r, h) << s, this.words[a] |= u & 67108863, s >= 18 ? (s -= 18, a += 1, this.words[a] |= u >>> 26) : s += 8;
            else {
                var f = t.length - r;
                for(h = f % 2 == 0 ? r + 1 : r; h < t.length; h += 2)u = Et(t, r, h) << s, this.words[a] |= u & 67108863, s >= 18 ? (s -= 18, a += 1, this.words[a] |= u >>> 26) : s += 8;
            }
            this.strip();
        };
        function Ot(o, t, r, e) {
            for(var h = 0, s = Math.min(o.length, r), a = t; a < s; a++){
                var u = o.charCodeAt(a) - 48;
                h *= e, u >= 49 ? h += u - 49 + 10 : u >= 17 ? h += u - 17 + 10 : h += u;
            }
            return h;
        }
        l.prototype._parseBase = function(t, r, e) {
            this.words = [
                0
            ], this.length = 1;
            for(var h = 0, s = 1; s <= 67108863; s *= r)h++;
            h--, s = s / r | 0;
            for(var a = t.length - e, u = a % h, f = Math.min(a, a - u) + e, i = 0, n = e; n < f; n += h)i = Ot(t, n, n + h, r), this.imuln(s), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
            if (u !== 0) {
                var d = 1;
                for(i = Ot(t, n, t.length, r), n = 0; n < u; n++)d *= r;
                this.imuln(d), this.words[0] + i < 67108864 ? this.words[0] += i : this._iaddn(i);
            }
            this.strip();
        }, l.prototype.copy = function(t) {
            t.words = new Array(this.length);
            for(var r = 0; r < this.length; r++)t.words[r] = this.words[r];
            t.length = this.length, t.negative = this.negative, t.red = this.red;
        }, l.prototype.clone = function() {
            var t = new l(null);
            return this.copy(t), t;
        }, l.prototype._expand = function(t) {
            for(; this.length < t;)this.words[this.length++] = 0;
            return this;
        }, l.prototype.strip = function() {
            for(; this.length > 1 && this.words[this.length - 1] === 0;)this.length--;
            return this._normSign();
        }, l.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, l.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var Kt = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000"
        ], ai = [
            0,
            0,
            25,
            16,
            12,
            11,
            10,
            9,
            8,
            8,
            7,
            7,
            7,
            7,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5
        ], li = [
            0,
            0,
            33554432,
            43046721,
            16777216,
            48828125,
            60466176,
            40353607,
            16777216,
            43046721,
            1e7,
            19487171,
            35831808,
            62748517,
            7529536,
            11390625,
            16777216,
            24137569,
            34012224,
            47045881,
            64e6,
            4084101,
            5153632,
            6436343,
            7962624,
            9765625,
            11881376,
            14348907,
            17210368,
            20511149,
            243e5,
            28629151,
            33554432,
            39135393,
            45435424,
            52521875,
            60466176
        ];
        l.prototype.toString = function(t, r) {
            t = t || 10, r = r | 0 || 1;
            var e;
            if (t === 16 || t === "hex") {
                e = "";
                for(var h = 0, s = 0, a = 0; a < this.length; a++){
                    var u = this.words[a], f = ((u << h | s) & 16777215).toString(16);
                    s = u >>> 24 - h & 16777215, s !== 0 || a !== this.length - 1 ? e = Kt[6 - f.length] + f + e : e = f + e, h += 2, h >= 26 && (h -= 26, a--);
                }
                for(s !== 0 && (e = s.toString(16) + e); e.length % r != 0;)e = "0" + e;
                return this.negative !== 0 && (e = "-" + e), e;
            }
            if (t === (t | 0) && t >= 2 && t <= 36) {
                var i = ai[t], n = li[t];
                e = "";
                var d = this.clone();
                for(d.negative = 0; !d.isZero();){
                    var m = d.modn(n).toString(t);
                    d = d.idivn(n), d.isZero() ? e = m + e : e = Kt[i - m.length] + m + e;
                }
                for(this.isZero() && (e = "0" + e); e.length % r != 0;)e = "0" + e;
                return this.negative !== 0 && (e = "-" + e), e;
            }
            v(!1, "Base should be between 2 and 36");
        }, l.prototype.toNumber = function() {
            var t = this.words[0];
            return this.length === 2 ? t += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && v(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t : t;
        }, l.prototype.toJSON = function() {
            return this.toString(16);
        }, l.prototype.toBuffer = function(t, r) {
            return v(typeof at != "undefined"), this.toArrayLike(at, t, r);
        }, l.prototype.toArray = function(t, r) {
            return this.toArrayLike(Array, t, r);
        }, l.prototype.toArrayLike = function(t, r, e) {
            var h = this.byteLength(), s = e || Math.max(1, h);
            v(h <= s, "byte array longer than desired length"), v(s > 0, "Requested array length <= 0"), this.strip();
            var a = r === "le", u = new t(s), f, i, n = this.clone();
            if (a) {
                for(i = 0; !n.isZero(); i++)f = n.andln(255), n.iushrn(8), u[i] = f;
                for(; i < s; i++)u[i] = 0;
            } else {
                for(i = 0; i < s - h; i++)u[i] = 0;
                for(i = 0; !n.isZero(); i++)f = n.andln(255), n.iushrn(8), u[s - i - 1] = f;
            }
            return u;
        }, Math.clz32 ? l.prototype._countBits = function(t) {
            return 32 - Math.clz32(t);
        } : l.prototype._countBits = function(t) {
            var r = t, e = 0;
            return r >= 4096 && (e += 13, r >>>= 13), r >= 64 && (e += 7, r >>>= 7), r >= 8 && (e += 4, r >>>= 4), r >= 2 && (e += 2, r >>>= 2), e + r;
        }, l.prototype._zeroBits = function(t) {
            if (t === 0) return 26;
            var r = t, e = 0;
            return (r & 8191) == 0 && (e += 13, r >>>= 13), (r & 127) == 0 && (e += 7, r >>>= 7), (r & 15) == 0 && (e += 4, r >>>= 4), (r & 3) == 0 && (e += 2, r >>>= 2), (r & 1) == 0 && e++, e;
        }, l.prototype.bitLength = function() {
            var t = this.words[this.length - 1], r = this._countBits(t);
            return (this.length - 1) * 26 + r;
        };
        function ui(o) {
            for(var t = new Array(o.bitLength()), r = 0; r < t.length; r++){
                var e = r / 26 | 0, h = r % 26;
                t[r] = (o.words[e] & 1 << h) >>> h;
            }
            return t;
        }
        l.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for(var t = 0, r = 0; r < this.length; r++){
                var e = this._zeroBits(this.words[r]);
                if (t += e, e !== 26) break;
            }
            return t;
        }, l.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8);
        }, l.prototype.toTwos = function(t) {
            return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
        }, l.prototype.fromTwos = function(t) {
            return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
        }, l.prototype.isNeg = function() {
            return this.negative !== 0;
        }, l.prototype.neg = function() {
            return this.clone().ineg();
        }, l.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this;
        }, l.prototype.iuor = function(t) {
            for(; this.length < t.length;)this.words[this.length++] = 0;
            for(var r = 0; r < t.length; r++)this.words[r] = this.words[r] | t.words[r];
            return this.strip();
        }, l.prototype.ior = function(t) {
            return v((this.negative | t.negative) == 0), this.iuor(t);
        }, l.prototype.or = function(t) {
            return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this);
        }, l.prototype.uor = function(t) {
            return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this);
        }, l.prototype.iuand = function(t) {
            var r;
            this.length > t.length ? r = t : r = this;
            for(var e = 0; e < r.length; e++)this.words[e] = this.words[e] & t.words[e];
            return this.length = r.length, this.strip();
        }, l.prototype.iand = function(t) {
            return v((this.negative | t.negative) == 0), this.iuand(t);
        }, l.prototype.and = function(t) {
            return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this);
        }, l.prototype.uand = function(t) {
            return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this);
        }, l.prototype.iuxor = function(t) {
            var r, e;
            this.length > t.length ? (r = this, e = t) : (r = t, e = this);
            for(var h = 0; h < e.length; h++)this.words[h] = r.words[h] ^ e.words[h];
            if (this !== r) for(; h < r.length; h++)this.words[h] = r.words[h];
            return this.length = r.length, this.strip();
        }, l.prototype.ixor = function(t) {
            return v((this.negative | t.negative) == 0), this.iuxor(t);
        }, l.prototype.xor = function(t) {
            return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this);
        }, l.prototype.uxor = function(t) {
            return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this);
        }, l.prototype.inotn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = Math.ceil(t / 26) | 0, e = t % 26;
            this._expand(r), e > 0 && r--;
            for(var h = 0; h < r; h++)this.words[h] = ~this.words[h] & 67108863;
            return e > 0 && (this.words[h] = ~this.words[h] & 67108863 >> 26 - e), this.strip();
        }, l.prototype.notn = function(t) {
            return this.clone().inotn(t);
        }, l.prototype.setn = function(t, r) {
            v(typeof t == "number" && t >= 0);
            var e = t / 26 | 0, h = t % 26;
            return this._expand(e + 1), r ? this.words[e] = this.words[e] | 1 << h : this.words[e] = this.words[e] & ~(1 << h), this.strip();
        }, l.prototype.iadd = function(t) {
            var r;
            if (this.negative !== 0 && t.negative === 0) return this.negative = 0, r = this.isub(t), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && t.negative !== 0) return t.negative = 0, r = this.isub(t), t.negative = 1, r._normSign();
            var e, h;
            this.length > t.length ? (e = this, h = t) : (e = t, h = this);
            for(var s = 0, a = 0; a < h.length; a++)r = (e.words[a] | 0) + (h.words[a] | 0) + s, this.words[a] = r & 67108863, s = r >>> 26;
            for(; s !== 0 && a < e.length; a++)r = (e.words[a] | 0) + s, this.words[a] = r & 67108863, s = r >>> 26;
            if (this.length = e.length, s !== 0) this.words[this.length] = s, this.length++;
            else if (e !== this) for(; a < e.length; a++)this.words[a] = e.words[a];
            return this;
        }, l.prototype.add = function(t) {
            var r;
            return t.negative !== 0 && this.negative === 0 ? (t.negative = 0, r = this.sub(t), t.negative ^= 1, r) : t.negative === 0 && this.negative !== 0 ? (this.negative = 0, r = t.sub(this), this.negative = 1, r) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this);
        }, l.prototype.isub = function(t) {
            if (t.negative !== 0) {
                t.negative = 0;
                var r = this.iadd(t);
                return t.negative = 1, r._normSign();
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
            var e = this.cmp(t);
            if (e === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var h, s;
            e > 0 ? (h = this, s = t) : (h = t, s = this);
            for(var a = 0, u = 0; u < s.length; u++)r = (h.words[u] | 0) - (s.words[u] | 0) + a, a = r >> 26, this.words[u] = r & 67108863;
            for(; a !== 0 && u < h.length; u++)r = (h.words[u] | 0) + a, a = r >> 26, this.words[u] = r & 67108863;
            if (a === 0 && u < h.length && h !== this) for(; u < h.length; u++)this.words[u] = h.words[u];
            return this.length = Math.max(this.length, u), h !== this && (this.negative = 1), this.strip();
        }, l.prototype.sub = function(t) {
            return this.clone().isub(t);
        };
        function Ft(o, t, r) {
            r.negative = t.negative ^ o.negative;
            var e = o.length + t.length | 0;
            r.length = e, e = e - 1 | 0;
            var h = o.words[0] | 0, s = t.words[0] | 0, a = h * s, u = a & 67108863, f = a / 67108864 | 0;
            r.words[0] = u;
            for(var i = 1; i < e; i++){
                for(var n = f >>> 26, d = f & 67108863, m = Math.min(i, t.length - 1), p = Math.max(0, i - o.length + 1); p <= m; p++){
                    var M = i - p | 0;
                    h = o.words[M] | 0, s = t.words[p] | 0, a = h * s + d, n += a / 67108864 | 0, d = a & 67108863;
                }
                r.words[i] = d | 0, f = n | 0;
            }
            return f !== 0 ? r.words[i] = f | 0 : r.length--, r.strip();
        }
        var Ht = function(t, r, e) {
            var h = t.words, s = r.words, a = e.words, u = 0, f, i, n, d = h[0] | 0, m = d & 8191, p = d >>> 13, M = h[1] | 0, g = M & 8191, c = M >>> 13, st = h[2] | 0, w = st & 8191, y = st >>> 13, Jt = h[3] | 0, _ = Jt & 8191, A = Jt >>> 13, Ut = h[4] | 0, B = Ut & 8191, S = Ut >>> 13, Wt = h[5] | 0, k = Wt & 8191, q = Wt >>> 13, Gt = h[6] | 0, R = Gt & 8191, Z = Gt >>> 13, Qt = h[7] | 0, T = Qt & 8191, L = Qt >>> 13, Vt = h[8] | 0, z = Vt & 8191, I = Vt >>> 13, Xt = h[9] | 0, N = Xt & 8191, E = Xt >>> 13, Yt = s[0] | 0, O = Yt & 8191, K = Yt >>> 13, $t = s[1] | 0, F = $t & 8191, H = $t >>> 13, jt = s[2] | 0, P = jt & 8191, D = jt >>> 13, ti = s[3] | 0, C = ti & 8191, J = ti >>> 13, ii = s[4] | 0, U = ii & 8191, W = ii >>> 13, ri = s[5] | 0, G = ri & 8191, Q = ri >>> 13, ei = s[6] | 0, V = ei & 8191, X = ei >>> 13, hi = s[7] | 0, Y = hi & 8191, $ = hi >>> 13, fi = s[8] | 0, j = fi & 8191, tt = fi >>> 13, ni = s[9] | 0, it = ni & 8191, rt = ni >>> 13;
            e.negative = t.negative ^ r.negative, e.length = 19, f = Math.imul(m, O), i = Math.imul(m, K), i = i + Math.imul(p, O) | 0, n = Math.imul(p, K);
            var dt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, f = Math.imul(g, O), i = Math.imul(g, K), i = i + Math.imul(c, O) | 0, n = Math.imul(c, K), f = f + Math.imul(m, F) | 0, i = i + Math.imul(m, H) | 0, i = i + Math.imul(p, F) | 0, n = n + Math.imul(p, H) | 0;
            var mt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, f = Math.imul(w, O), i = Math.imul(w, K), i = i + Math.imul(y, O) | 0, n = Math.imul(y, K), f = f + Math.imul(g, F) | 0, i = i + Math.imul(g, H) | 0, i = i + Math.imul(c, F) | 0, n = n + Math.imul(c, H) | 0, f = f + Math.imul(m, P) | 0, i = i + Math.imul(m, D) | 0, i = i + Math.imul(p, P) | 0, n = n + Math.imul(p, D) | 0;
            var pt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, f = Math.imul(_, O), i = Math.imul(_, K), i = i + Math.imul(A, O) | 0, n = Math.imul(A, K), f = f + Math.imul(w, F) | 0, i = i + Math.imul(w, H) | 0, i = i + Math.imul(y, F) | 0, n = n + Math.imul(y, H) | 0, f = f + Math.imul(g, P) | 0, i = i + Math.imul(g, D) | 0, i = i + Math.imul(c, P) | 0, n = n + Math.imul(c, D) | 0, f = f + Math.imul(m, C) | 0, i = i + Math.imul(m, J) | 0, i = i + Math.imul(p, C) | 0, n = n + Math.imul(p, J) | 0;
            var Mt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, f = Math.imul(B, O), i = Math.imul(B, K), i = i + Math.imul(S, O) | 0, n = Math.imul(S, K), f = f + Math.imul(_, F) | 0, i = i + Math.imul(_, H) | 0, i = i + Math.imul(A, F) | 0, n = n + Math.imul(A, H) | 0, f = f + Math.imul(w, P) | 0, i = i + Math.imul(w, D) | 0, i = i + Math.imul(y, P) | 0, n = n + Math.imul(y, D) | 0, f = f + Math.imul(g, C) | 0, i = i + Math.imul(g, J) | 0, i = i + Math.imul(c, C) | 0, n = n + Math.imul(c, J) | 0, f = f + Math.imul(m, U) | 0, i = i + Math.imul(m, W) | 0, i = i + Math.imul(p, U) | 0, n = n + Math.imul(p, W) | 0;
            var gt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, f = Math.imul(k, O), i = Math.imul(k, K), i = i + Math.imul(q, O) | 0, n = Math.imul(q, K), f = f + Math.imul(B, F) | 0, i = i + Math.imul(B, H) | 0, i = i + Math.imul(S, F) | 0, n = n + Math.imul(S, H) | 0, f = f + Math.imul(_, P) | 0, i = i + Math.imul(_, D) | 0, i = i + Math.imul(A, P) | 0, n = n + Math.imul(A, D) | 0, f = f + Math.imul(w, C) | 0, i = i + Math.imul(w, J) | 0, i = i + Math.imul(y, C) | 0, n = n + Math.imul(y, J) | 0, f = f + Math.imul(g, U) | 0, i = i + Math.imul(g, W) | 0, i = i + Math.imul(c, U) | 0, n = n + Math.imul(c, W) | 0, f = f + Math.imul(m, G) | 0, i = i + Math.imul(m, Q) | 0, i = i + Math.imul(p, G) | 0, n = n + Math.imul(p, Q) | 0;
            var ct = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, f = Math.imul(R, O), i = Math.imul(R, K), i = i + Math.imul(Z, O) | 0, n = Math.imul(Z, K), f = f + Math.imul(k, F) | 0, i = i + Math.imul(k, H) | 0, i = i + Math.imul(q, F) | 0, n = n + Math.imul(q, H) | 0, f = f + Math.imul(B, P) | 0, i = i + Math.imul(B, D) | 0, i = i + Math.imul(S, P) | 0, n = n + Math.imul(S, D) | 0, f = f + Math.imul(_, C) | 0, i = i + Math.imul(_, J) | 0, i = i + Math.imul(A, C) | 0, n = n + Math.imul(A, J) | 0, f = f + Math.imul(w, U) | 0, i = i + Math.imul(w, W) | 0, i = i + Math.imul(y, U) | 0, n = n + Math.imul(y, W) | 0, f = f + Math.imul(g, G) | 0, i = i + Math.imul(g, Q) | 0, i = i + Math.imul(c, G) | 0, n = n + Math.imul(c, Q) | 0, f = f + Math.imul(m, V) | 0, i = i + Math.imul(m, X) | 0, i = i + Math.imul(p, V) | 0, n = n + Math.imul(p, X) | 0;
            var wt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, f = Math.imul(T, O), i = Math.imul(T, K), i = i + Math.imul(L, O) | 0, n = Math.imul(L, K), f = f + Math.imul(R, F) | 0, i = i + Math.imul(R, H) | 0, i = i + Math.imul(Z, F) | 0, n = n + Math.imul(Z, H) | 0, f = f + Math.imul(k, P) | 0, i = i + Math.imul(k, D) | 0, i = i + Math.imul(q, P) | 0, n = n + Math.imul(q, D) | 0, f = f + Math.imul(B, C) | 0, i = i + Math.imul(B, J) | 0, i = i + Math.imul(S, C) | 0, n = n + Math.imul(S, J) | 0, f = f + Math.imul(_, U) | 0, i = i + Math.imul(_, W) | 0, i = i + Math.imul(A, U) | 0, n = n + Math.imul(A, W) | 0, f = f + Math.imul(w, G) | 0, i = i + Math.imul(w, Q) | 0, i = i + Math.imul(y, G) | 0, n = n + Math.imul(y, Q) | 0, f = f + Math.imul(g, V) | 0, i = i + Math.imul(g, X) | 0, i = i + Math.imul(c, V) | 0, n = n + Math.imul(c, X) | 0, f = f + Math.imul(m, Y) | 0, i = i + Math.imul(m, $) | 0, i = i + Math.imul(p, Y) | 0, n = n + Math.imul(p, $) | 0;
            var yt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, f = Math.imul(z, O), i = Math.imul(z, K), i = i + Math.imul(I, O) | 0, n = Math.imul(I, K), f = f + Math.imul(T, F) | 0, i = i + Math.imul(T, H) | 0, i = i + Math.imul(L, F) | 0, n = n + Math.imul(L, H) | 0, f = f + Math.imul(R, P) | 0, i = i + Math.imul(R, D) | 0, i = i + Math.imul(Z, P) | 0, n = n + Math.imul(Z, D) | 0, f = f + Math.imul(k, C) | 0, i = i + Math.imul(k, J) | 0, i = i + Math.imul(q, C) | 0, n = n + Math.imul(q, J) | 0, f = f + Math.imul(B, U) | 0, i = i + Math.imul(B, W) | 0, i = i + Math.imul(S, U) | 0, n = n + Math.imul(S, W) | 0, f = f + Math.imul(_, G) | 0, i = i + Math.imul(_, Q) | 0, i = i + Math.imul(A, G) | 0, n = n + Math.imul(A, Q) | 0, f = f + Math.imul(w, V) | 0, i = i + Math.imul(w, X) | 0, i = i + Math.imul(y, V) | 0, n = n + Math.imul(y, X) | 0, f = f + Math.imul(g, Y) | 0, i = i + Math.imul(g, $) | 0, i = i + Math.imul(c, Y) | 0, n = n + Math.imul(c, $) | 0, f = f + Math.imul(m, j) | 0, i = i + Math.imul(m, tt) | 0, i = i + Math.imul(p, j) | 0, n = n + Math.imul(p, tt) | 0;
            var xt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, f = Math.imul(N, O), i = Math.imul(N, K), i = i + Math.imul(E, O) | 0, n = Math.imul(E, K), f = f + Math.imul(z, F) | 0, i = i + Math.imul(z, H) | 0, i = i + Math.imul(I, F) | 0, n = n + Math.imul(I, H) | 0, f = f + Math.imul(T, P) | 0, i = i + Math.imul(T, D) | 0, i = i + Math.imul(L, P) | 0, n = n + Math.imul(L, D) | 0, f = f + Math.imul(R, C) | 0, i = i + Math.imul(R, J) | 0, i = i + Math.imul(Z, C) | 0, n = n + Math.imul(Z, J) | 0, f = f + Math.imul(k, U) | 0, i = i + Math.imul(k, W) | 0, i = i + Math.imul(q, U) | 0, n = n + Math.imul(q, W) | 0, f = f + Math.imul(B, G) | 0, i = i + Math.imul(B, Q) | 0, i = i + Math.imul(S, G) | 0, n = n + Math.imul(S, Q) | 0, f = f + Math.imul(_, V) | 0, i = i + Math.imul(_, X) | 0, i = i + Math.imul(A, V) | 0, n = n + Math.imul(A, X) | 0, f = f + Math.imul(w, Y) | 0, i = i + Math.imul(w, $) | 0, i = i + Math.imul(y, Y) | 0, n = n + Math.imul(y, $) | 0, f = f + Math.imul(g, j) | 0, i = i + Math.imul(g, tt) | 0, i = i + Math.imul(c, j) | 0, n = n + Math.imul(c, tt) | 0, f = f + Math.imul(m, it) | 0, i = i + Math.imul(m, rt) | 0, i = i + Math.imul(p, it) | 0, n = n + Math.imul(p, rt) | 0;
            var bt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, f = Math.imul(N, F), i = Math.imul(N, H), i = i + Math.imul(E, F) | 0, n = Math.imul(E, H), f = f + Math.imul(z, P) | 0, i = i + Math.imul(z, D) | 0, i = i + Math.imul(I, P) | 0, n = n + Math.imul(I, D) | 0, f = f + Math.imul(T, C) | 0, i = i + Math.imul(T, J) | 0, i = i + Math.imul(L, C) | 0, n = n + Math.imul(L, J) | 0, f = f + Math.imul(R, U) | 0, i = i + Math.imul(R, W) | 0, i = i + Math.imul(Z, U) | 0, n = n + Math.imul(Z, W) | 0, f = f + Math.imul(k, G) | 0, i = i + Math.imul(k, Q) | 0, i = i + Math.imul(q, G) | 0, n = n + Math.imul(q, Q) | 0, f = f + Math.imul(B, V) | 0, i = i + Math.imul(B, X) | 0, i = i + Math.imul(S, V) | 0, n = n + Math.imul(S, X) | 0, f = f + Math.imul(_, Y) | 0, i = i + Math.imul(_, $) | 0, i = i + Math.imul(A, Y) | 0, n = n + Math.imul(A, $) | 0, f = f + Math.imul(w, j) | 0, i = i + Math.imul(w, tt) | 0, i = i + Math.imul(y, j) | 0, n = n + Math.imul(y, tt) | 0, f = f + Math.imul(g, it) | 0, i = i + Math.imul(g, rt) | 0, i = i + Math.imul(c, it) | 0, n = n + Math.imul(c, rt) | 0;
            var _t = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, f = Math.imul(N, P), i = Math.imul(N, D), i = i + Math.imul(E, P) | 0, n = Math.imul(E, D), f = f + Math.imul(z, C) | 0, i = i + Math.imul(z, J) | 0, i = i + Math.imul(I, C) | 0, n = n + Math.imul(I, J) | 0, f = f + Math.imul(T, U) | 0, i = i + Math.imul(T, W) | 0, i = i + Math.imul(L, U) | 0, n = n + Math.imul(L, W) | 0, f = f + Math.imul(R, G) | 0, i = i + Math.imul(R, Q) | 0, i = i + Math.imul(Z, G) | 0, n = n + Math.imul(Z, Q) | 0, f = f + Math.imul(k, V) | 0, i = i + Math.imul(k, X) | 0, i = i + Math.imul(q, V) | 0, n = n + Math.imul(q, X) | 0, f = f + Math.imul(B, Y) | 0, i = i + Math.imul(B, $) | 0, i = i + Math.imul(S, Y) | 0, n = n + Math.imul(S, $) | 0, f = f + Math.imul(_, j) | 0, i = i + Math.imul(_, tt) | 0, i = i + Math.imul(A, j) | 0, n = n + Math.imul(A, tt) | 0, f = f + Math.imul(w, it) | 0, i = i + Math.imul(w, rt) | 0, i = i + Math.imul(y, it) | 0, n = n + Math.imul(y, rt) | 0;
            var At = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, f = Math.imul(N, C), i = Math.imul(N, J), i = i + Math.imul(E, C) | 0, n = Math.imul(E, J), f = f + Math.imul(z, U) | 0, i = i + Math.imul(z, W) | 0, i = i + Math.imul(I, U) | 0, n = n + Math.imul(I, W) | 0, f = f + Math.imul(T, G) | 0, i = i + Math.imul(T, Q) | 0, i = i + Math.imul(L, G) | 0, n = n + Math.imul(L, Q) | 0, f = f + Math.imul(R, V) | 0, i = i + Math.imul(R, X) | 0, i = i + Math.imul(Z, V) | 0, n = n + Math.imul(Z, X) | 0, f = f + Math.imul(k, Y) | 0, i = i + Math.imul(k, $) | 0, i = i + Math.imul(q, Y) | 0, n = n + Math.imul(q, $) | 0, f = f + Math.imul(B, j) | 0, i = i + Math.imul(B, tt) | 0, i = i + Math.imul(S, j) | 0, n = n + Math.imul(S, tt) | 0, f = f + Math.imul(_, it) | 0, i = i + Math.imul(_, rt) | 0, i = i + Math.imul(A, it) | 0, n = n + Math.imul(A, rt) | 0;
            var Bt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, f = Math.imul(N, U), i = Math.imul(N, W), i = i + Math.imul(E, U) | 0, n = Math.imul(E, W), f = f + Math.imul(z, G) | 0, i = i + Math.imul(z, Q) | 0, i = i + Math.imul(I, G) | 0, n = n + Math.imul(I, Q) | 0, f = f + Math.imul(T, V) | 0, i = i + Math.imul(T, X) | 0, i = i + Math.imul(L, V) | 0, n = n + Math.imul(L, X) | 0, f = f + Math.imul(R, Y) | 0, i = i + Math.imul(R, $) | 0, i = i + Math.imul(Z, Y) | 0, n = n + Math.imul(Z, $) | 0, f = f + Math.imul(k, j) | 0, i = i + Math.imul(k, tt) | 0, i = i + Math.imul(q, j) | 0, n = n + Math.imul(q, tt) | 0, f = f + Math.imul(B, it) | 0, i = i + Math.imul(B, rt) | 0, i = i + Math.imul(S, it) | 0, n = n + Math.imul(S, rt) | 0;
            var St = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, f = Math.imul(N, G), i = Math.imul(N, Q), i = i + Math.imul(E, G) | 0, n = Math.imul(E, Q), f = f + Math.imul(z, V) | 0, i = i + Math.imul(z, X) | 0, i = i + Math.imul(I, V) | 0, n = n + Math.imul(I, X) | 0, f = f + Math.imul(T, Y) | 0, i = i + Math.imul(T, $) | 0, i = i + Math.imul(L, Y) | 0, n = n + Math.imul(L, $) | 0, f = f + Math.imul(R, j) | 0, i = i + Math.imul(R, tt) | 0, i = i + Math.imul(Z, j) | 0, n = n + Math.imul(Z, tt) | 0, f = f + Math.imul(k, it) | 0, i = i + Math.imul(k, rt) | 0, i = i + Math.imul(q, it) | 0, n = n + Math.imul(q, rt) | 0;
            var kt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, f = Math.imul(N, V), i = Math.imul(N, X), i = i + Math.imul(E, V) | 0, n = Math.imul(E, X), f = f + Math.imul(z, Y) | 0, i = i + Math.imul(z, $) | 0, i = i + Math.imul(I, Y) | 0, n = n + Math.imul(I, $) | 0, f = f + Math.imul(T, j) | 0, i = i + Math.imul(T, tt) | 0, i = i + Math.imul(L, j) | 0, n = n + Math.imul(L, tt) | 0, f = f + Math.imul(R, it) | 0, i = i + Math.imul(R, rt) | 0, i = i + Math.imul(Z, it) | 0, n = n + Math.imul(Z, rt) | 0;
            var qt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, f = Math.imul(N, Y), i = Math.imul(N, $), i = i + Math.imul(E, Y) | 0, n = Math.imul(E, $), f = f + Math.imul(z, j) | 0, i = i + Math.imul(z, tt) | 0, i = i + Math.imul(I, j) | 0, n = n + Math.imul(I, tt) | 0, f = f + Math.imul(T, it) | 0, i = i + Math.imul(T, rt) | 0, i = i + Math.imul(L, it) | 0, n = n + Math.imul(L, rt) | 0;
            var Rt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, f = Math.imul(N, j), i = Math.imul(N, tt), i = i + Math.imul(E, j) | 0, n = Math.imul(E, tt), f = f + Math.imul(z, it) | 0, i = i + Math.imul(z, rt) | 0, i = i + Math.imul(I, it) | 0, n = n + Math.imul(I, rt) | 0;
            var Zt = (u + f | 0) + ((i & 8191) << 13) | 0;
            u = (n + (i >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, f = Math.imul(N, it), i = Math.imul(N, rt), i = i + Math.imul(E, it) | 0, n = Math.imul(E, rt);
            var Tt = (u + f | 0) + ((i & 8191) << 13) | 0;
            return u = (n + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, a[0] = dt, a[1] = mt, a[2] = pt, a[3] = Mt, a[4] = gt, a[5] = ct, a[6] = wt, a[7] = yt, a[8] = xt, a[9] = bt, a[10] = _t, a[11] = At, a[12] = Bt, a[13] = St, a[14] = kt, a[15] = qt, a[16] = Rt, a[17] = Zt, a[18] = Tt, u !== 0 && (a[19] = u, e.length++), e;
        };
        Math.imul || (Ht = Ft);
        function vi(o, t, r) {
            r.negative = t.negative ^ o.negative, r.length = o.length + t.length;
            for(var e = 0, h = 0, s = 0; s < r.length - 1; s++){
                var a = h;
                h = 0;
                for(var u = e & 67108863, f = Math.min(s, t.length - 1), i = Math.max(0, s - o.length + 1); i <= f; i++){
                    var n = s - i, d = o.words[n] | 0, m = t.words[i] | 0, p = d * m, M = p & 67108863;
                    a = a + (p / 67108864 | 0) | 0, M = M + u | 0, u = M & 67108863, a = a + (M >>> 26) | 0, h += a >>> 26, a &= 67108863;
                }
                r.words[s] = u, e = a, a = h;
            }
            return e !== 0 ? r.words[s] = e : r.length--, r.strip();
        }
        function Pt(o, t, r) {
            var e = new nt;
            return e.mulp(o, t, r);
        }
        l.prototype.mulTo = function(t, r) {
            var e, h = this.length + t.length;
            return this.length === 10 && t.length === 10 ? e = Ht(this, t, r) : h < 63 ? e = Ft(this, t, r) : h < 1024 ? e = vi(this, t, r) : e = Pt(this, t, r), e;
        };
        function nt(o, t) {
            this.x = o, this.y = t;
        }
        nt.prototype.makeRBT = function(t) {
            for(var r = new Array(t), e = l.prototype._countBits(t) - 1, h = 0; h < t; h++)r[h] = this.revBin(h, e, t);
            return r;
        }, nt.prototype.revBin = function(t, r, e) {
            if (t === 0 || t === e - 1) return t;
            for(var h = 0, s = 0; s < r; s++)h |= (t & 1) << r - s - 1, t >>= 1;
            return h;
        }, nt.prototype.permute = function(t, r, e, h, s, a) {
            for(var u = 0; u < a; u++)h[u] = r[t[u]], s[u] = e[t[u]];
        }, nt.prototype.transform = function(t, r, e, h, s, a) {
            this.permute(a, t, r, e, h, s);
            for(var u = 1; u < s; u <<= 1)for(var f = u << 1, i = Math.cos(2 * Math.PI / f), n = Math.sin(2 * Math.PI / f), d = 0; d < s; d += f)for(var m = i, p = n, M = 0; M < u; M++){
                var g = e[d + M], c = h[d + M], st = e[d + M + u], w = h[d + M + u], y = m * st - p * w;
                w = m * w + p * st, st = y, e[d + M] = g + st, h[d + M] = c + w, e[d + M + u] = g - st, h[d + M + u] = c - w, M !== f && (y = i * m - n * p, p = i * p + n * m, m = y);
            }
        }, nt.prototype.guessLen13b = function(t, r) {
            var e = Math.max(r, t) | 1, h = e & 1, s = 0;
            for(e = e / 2 | 0; e; e = e >>> 1)s++;
            return 1 << s + 1 + h;
        }, nt.prototype.conjugate = function(t, r, e) {
            if (!(e <= 1)) for(var h = 0; h < e / 2; h++){
                var s = t[h];
                t[h] = t[e - h - 1], t[e - h - 1] = s, s = r[h], r[h] = -r[e - h - 1], r[e - h - 1] = -s;
            }
        }, nt.prototype.normalize13b = function(t, r) {
            for(var e = 0, h = 0; h < r / 2; h++){
                var s = Math.round(t[2 * h + 1] / r) * 8192 + Math.round(t[2 * h] / r) + e;
                t[h] = s & 67108863, s < 67108864 ? e = 0 : e = s / 67108864 | 0;
            }
            return t;
        }, nt.prototype.convert13b = function(t, r, e, h) {
            for(var s = 0, a = 0; a < r; a++)s = s + (t[a] | 0), e[2 * a] = s & 8191, s = s >>> 13, e[2 * a + 1] = s & 8191, s = s >>> 13;
            for(a = 2 * r; a < h; ++a)e[a] = 0;
            v(s === 0), v((s & ~8191) == 0);
        }, nt.prototype.stub = function(t) {
            for(var r = new Array(t), e = 0; e < t; e++)r[e] = 0;
            return r;
        }, nt.prototype.mulp = function(t, r, e) {
            var h = 2 * this.guessLen13b(t.length, r.length), s = this.makeRBT(h), a = this.stub(h), u = new Array(h), f = new Array(h), i = new Array(h), n = new Array(h), d = new Array(h), m = new Array(h), p = e.words;
            p.length = h, this.convert13b(t.words, t.length, u, h), this.convert13b(r.words, r.length, n, h), this.transform(u, a, f, i, h, s), this.transform(n, a, d, m, h, s);
            for(var M = 0; M < h; M++){
                var g = f[M] * d[M] - i[M] * m[M];
                i[M] = f[M] * m[M] + i[M] * d[M], f[M] = g;
            }
            return this.conjugate(f, i, h), this.transform(f, i, p, a, h, s), this.conjugate(p, a, h), this.normalize13b(p, h), e.negative = t.negative ^ r.negative, e.length = t.length + r.length, e.strip();
        }, l.prototype.mul = function(t) {
            var r = new l(null);
            return r.words = new Array(this.length + t.length), this.mulTo(t, r);
        }, l.prototype.mulf = function(t) {
            var r = new l(null);
            return r.words = new Array(this.length + t.length), Pt(this, t, r);
        }, l.prototype.imul = function(t) {
            return this.clone().mulTo(t, this);
        }, l.prototype.imuln = function(t) {
            v(typeof t == "number"), v(t < 67108864);
            for(var r = 0, e = 0; e < this.length; e++){
                var h = (this.words[e] | 0) * t, s = (h & 67108863) + (r & 67108863);
                r >>= 26, r += h / 67108864 | 0, r += s >>> 26, this.words[e] = s & 67108863;
            }
            return r !== 0 && (this.words[e] = r, this.length++), this;
        }, l.prototype.muln = function(t) {
            return this.clone().imuln(t);
        }, l.prototype.sqr = function() {
            return this.mul(this);
        }, l.prototype.isqr = function() {
            return this.imul(this.clone());
        }, l.prototype.pow = function(t) {
            var r = ui(t);
            if (r.length === 0) return new l(1);
            for(var e = this, h = 0; h < r.length && r[h] === 0; h++, e = e.sqr());
            if (++h < r.length) for(var s = e.sqr(); h < r.length; h++, s = s.sqr())r[h] !== 0 && (e = e.mul(s));
            return e;
        }, l.prototype.iushln = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26, h = 67108863 >>> 26 - r << 26 - r, s;
            if (r !== 0) {
                var a = 0;
                for(s = 0; s < this.length; s++){
                    var u = this.words[s] & h, f = (this.words[s] | 0) - u << r;
                    this.words[s] = f | a, a = u >>> 26 - r;
                }
                a && (this.words[s] = a, this.length++);
            }
            if (e !== 0) {
                for(s = this.length - 1; s >= 0; s--)this.words[s + e] = this.words[s];
                for(s = 0; s < e; s++)this.words[s] = 0;
                this.length += e;
            }
            return this.strip();
        }, l.prototype.ishln = function(t) {
            return v(this.negative === 0), this.iushln(t);
        }, l.prototype.iushrn = function(t, r, e) {
            v(typeof t == "number" && t >= 0);
            var h;
            r ? h = (r - r % 26) / 26 : h = 0;
            var s = t % 26, a = Math.min((t - s) / 26, this.length), u = 67108863 ^ 67108863 >>> s << s, f = e;
            if (h -= a, h = Math.max(0, h), f) {
                for(var i = 0; i < a; i++)f.words[i] = this.words[i];
                f.length = a;
            }
            if (a !== 0) if (this.length > a) for(this.length -= a, i = 0; i < this.length; i++)this.words[i] = this.words[i + a];
            else this.words[0] = 0, this.length = 1;
            var n = 0;
            for(i = this.length - 1; i >= 0 && (n !== 0 || i >= h); i--){
                var d = this.words[i] | 0;
                this.words[i] = n << 26 - s | d >>> s, n = d & u;
            }
            return f && n !== 0 && (f.words[f.length++] = n), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
        }, l.prototype.ishrn = function(t, r, e) {
            return v(this.negative === 0), this.iushrn(t, r, e);
        }, l.prototype.shln = function(t) {
            return this.clone().ishln(t);
        }, l.prototype.ushln = function(t) {
            return this.clone().iushln(t);
        }, l.prototype.shrn = function(t) {
            return this.clone().ishrn(t);
        }, l.prototype.ushrn = function(t) {
            return this.clone().iushrn(t);
        }, l.prototype.testn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26, h = 1 << r;
            if (this.length <= e) return !1;
            var s = this.words[e];
            return !!(s & h);
        }, l.prototype.imaskn = function(t) {
            v(typeof t == "number" && t >= 0);
            var r = t % 26, e = (t - r) / 26;
            if (v(this.negative === 0, "imaskn works only with positive numbers"), this.length <= e) return this;
            if (r !== 0 && e++, this.length = Math.min(e, this.length), r !== 0) {
                var h = 67108863 ^ 67108863 >>> r << r;
                this.words[this.length - 1] &= h;
            }
            return this.strip();
        }, l.prototype.maskn = function(t) {
            return this.clone().imaskn(t);
        }, l.prototype.iaddn = function(t) {
            return v(typeof t == "number"), v(t < 67108864), t < 0 ? this.isubn(-t) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < t ? (this.words[0] = t - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t);
        }, l.prototype._iaddn = function(t) {
            this.words[0] += t;
            for(var r = 0; r < this.length && this.words[r] >= 67108864; r++)this.words[r] -= 67108864, r === this.length - 1 ? this.words[r + 1] = 1 : this.words[r + 1]++;
            return this.length = Math.max(this.length, r + 1), this;
        }, l.prototype.isubn = function(t) {
            if (v(typeof t == "number"), v(t < 67108864), t < 0) return this.iaddn(-t);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
            if (this.words[0] -= t, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else for(var r = 0; r < this.length && this.words[r] < 0; r++)this.words[r] += 67108864, this.words[r + 1] -= 1;
            return this.strip();
        }, l.prototype.addn = function(t) {
            return this.clone().iaddn(t);
        }, l.prototype.subn = function(t) {
            return this.clone().isubn(t);
        }, l.prototype.iabs = function() {
            return this.negative = 0, this;
        }, l.prototype.abs = function() {
            return this.clone().iabs();
        }, l.prototype._ishlnsubmul = function(t, r, e) {
            var h = t.length + e, s;
            this._expand(h);
            var a, u = 0;
            for(s = 0; s < t.length; s++){
                a = (this.words[s + e] | 0) + u;
                var f = (t.words[s] | 0) * r;
                a -= f & 67108863, u = (a >> 26) - (f / 67108864 | 0), this.words[s + e] = a & 67108863;
            }
            for(; s < this.length - e; s++)a = (this.words[s + e] | 0) + u, u = a >> 26, this.words[s + e] = a & 67108863;
            if (u === 0) return this.strip();
            for(v(u === -1), u = 0, s = 0; s < this.length; s++)a = -(this.words[s] | 0) + u, u = a >> 26, this.words[s] = a & 67108863;
            return this.negative = 1, this.strip();
        }, l.prototype._wordDiv = function(t, r) {
            var e = this.length - t.length, h = this.clone(), s = t, a = s.words[s.length - 1] | 0, u = this._countBits(a);
            e = 26 - u, e !== 0 && (s = s.ushln(e), h.iushln(e), a = s.words[s.length - 1] | 0);
            var f = h.length - s.length, i;
            if (r !== "mod") {
                i = new l(null), i.length = f + 1, i.words = new Array(i.length);
                for(var n = 0; n < i.length; n++)i.words[n] = 0;
            }
            var d = h.clone()._ishlnsubmul(s, 1, f);
            d.negative === 0 && (h = d, i && (i.words[f] = 1));
            for(var m = f - 1; m >= 0; m--){
                var p = (h.words[s.length + m] | 0) * 67108864 + (h.words[s.length + m - 1] | 0);
                for(p = Math.min(p / a | 0, 67108863), h._ishlnsubmul(s, p, m); h.negative !== 0;)p--, h.negative = 0, h._ishlnsubmul(s, 1, m), h.isZero() || (h.negative ^= 1);
                i && (i.words[m] = p);
            }
            return i && i.strip(), h.strip(), r !== "div" && e !== 0 && h.iushrn(e), {
                div: i || null,
                mod: h
            };
        }, l.prototype.divmod = function(t, r, e) {
            if (v(!t.isZero()), this.isZero()) return {
                div: new l(0),
                mod: new l(0)
            };
            var h, s, a;
            return this.negative !== 0 && t.negative === 0 ? (a = this.neg().divmod(t, r), r !== "mod" && (h = a.div.neg()), r !== "div" && (s = a.mod.neg(), e && s.negative !== 0 && s.iadd(t)), {
                div: h,
                mod: s
            }) : this.negative === 0 && t.negative !== 0 ? (a = this.divmod(t.neg(), r), r !== "mod" && (h = a.div.neg()), {
                div: h,
                mod: a.mod
            }) : (this.negative & t.negative) != 0 ? (a = this.neg().divmod(t.neg(), r), r !== "div" && (s = a.mod.neg(), e && s.negative !== 0 && s.isub(t)), {
                div: a.div,
                mod: s
            }) : t.length > this.length || this.cmp(t) < 0 ? {
                div: new l(0),
                mod: this
            } : t.length === 1 ? r === "div" ? {
                div: this.divn(t.words[0]),
                mod: null
            } : r === "mod" ? {
                div: null,
                mod: new l(this.modn(t.words[0]))
            } : {
                div: this.divn(t.words[0]),
                mod: new l(this.modn(t.words[0]))
            } : this._wordDiv(t, r);
        }, l.prototype.div = function(t) {
            return this.divmod(t, "div", !1).div;
        }, l.prototype.mod = function(t) {
            return this.divmod(t, "mod", !1).mod;
        }, l.prototype.umod = function(t) {
            return this.divmod(t, "mod", !0).mod;
        }, l.prototype.divRound = function(t) {
            var r = this.divmod(t);
            if (r.mod.isZero()) return r.div;
            var e = r.div.negative !== 0 ? r.mod.isub(t) : r.mod, h = t.ushrn(1), s = t.andln(1), a = e.cmp(h);
            return a < 0 || s === 1 && a === 0 ? r.div : r.div.negative !== 0 ? r.div.isubn(1) : r.div.iaddn(1);
        }, l.prototype.modn = function(t) {
            v(t <= 67108863);
            for(var r = (1 << 26) % t, e = 0, h = this.length - 1; h >= 0; h--)e = (r * e + (this.words[h] | 0)) % t;
            return e;
        }, l.prototype.idivn = function(t) {
            v(t <= 67108863);
            for(var r = 0, e = this.length - 1; e >= 0; e--){
                var h = (this.words[e] | 0) + r * 67108864;
                this.words[e] = h / t | 0, r = h % t;
            }
            return this.strip();
        }, l.prototype.divn = function(t) {
            return this.clone().idivn(t);
        }, l.prototype.egcd = function(t) {
            v(t.negative === 0), v(!t.isZero());
            var r = this, e = t.clone();
            r.negative !== 0 ? r = r.umod(t) : r = r.clone();
            for(var h = new l(1), s = new l(0), a = new l(0), u = new l(1), f = 0; r.isEven() && e.isEven();)r.iushrn(1), e.iushrn(1), ++f;
            for(var i = e.clone(), n = r.clone(); !r.isZero();){
                for(var d = 0, m = 1; (r.words[0] & m) == 0 && d < 26; ++d, m <<= 1);
                if (d > 0) for(r.iushrn(d); d-- > 0;)(h.isOdd() || s.isOdd()) && (h.iadd(i), s.isub(n)), h.iushrn(1), s.iushrn(1);
                for(var p = 0, M = 1; (e.words[0] & M) == 0 && p < 26; ++p, M <<= 1);
                if (p > 0) for(e.iushrn(p); p-- > 0;)(a.isOdd() || u.isOdd()) && (a.iadd(i), u.isub(n)), a.iushrn(1), u.iushrn(1);
                r.cmp(e) >= 0 ? (r.isub(e), h.isub(a), s.isub(u)) : (e.isub(r), a.isub(h), u.isub(s));
            }
            return {
                a,
                b: u,
                gcd: e.iushln(f)
            };
        }, l.prototype._invmp = function(t) {
            v(t.negative === 0), v(!t.isZero());
            var r = this, e = t.clone();
            r.negative !== 0 ? r = r.umod(t) : r = r.clone();
            for(var h = new l(1), s = new l(0), a = e.clone(); r.cmpn(1) > 0 && e.cmpn(1) > 0;){
                for(var u = 0, f = 1; (r.words[0] & f) == 0 && u < 26; ++u, f <<= 1);
                if (u > 0) for(r.iushrn(u); u-- > 0;)h.isOdd() && h.iadd(a), h.iushrn(1);
                for(var i = 0, n = 1; (e.words[0] & n) == 0 && i < 26; ++i, n <<= 1);
                if (i > 0) for(e.iushrn(i); i-- > 0;)s.isOdd() && s.iadd(a), s.iushrn(1);
                r.cmp(e) >= 0 ? (r.isub(e), h.isub(s)) : (e.isub(r), s.isub(h));
            }
            var d;
            return r.cmpn(1) === 0 ? d = h : d = s, d.cmpn(0) < 0 && d.iadd(t), d;
        }, l.prototype.gcd = function(t) {
            if (this.isZero()) return t.abs();
            if (t.isZero()) return this.abs();
            var r = this.clone(), e = t.clone();
            r.negative = 0, e.negative = 0;
            for(var h = 0; r.isEven() && e.isEven(); h++)r.iushrn(1), e.iushrn(1);
            do {
                for(; r.isEven();)r.iushrn(1);
                for(; e.isEven();)e.iushrn(1);
                var s = r.cmp(e);
                if (s < 0) {
                    var a = r;
                    r = e, e = a;
                } else if (s === 0 || e.cmpn(1) === 0) break;
                r.isub(e);
            }while (!0)
            return e.iushln(h);
        }, l.prototype.invm = function(t) {
            return this.egcd(t).a.umod(t);
        }, l.prototype.isEven = function() {
            return (this.words[0] & 1) == 0;
        }, l.prototype.isOdd = function() {
            return (this.words[0] & 1) == 1;
        }, l.prototype.andln = function(t) {
            return this.words[0] & t;
        }, l.prototype.bincn = function(t) {
            v(typeof t == "number");
            var r = t % 26, e = (t - r) / 26, h = 1 << r;
            if (this.length <= e) return this._expand(e + 1), this.words[e] |= h, this;
            for(var s = h, a = e; s !== 0 && a < this.length; a++){
                var u = this.words[a] | 0;
                u += s, s = u >>> 26, u &= 67108863, this.words[a] = u;
            }
            return s !== 0 && (this.words[a] = s, this.length++), this;
        }, l.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0;
        }, l.prototype.cmpn = function(t) {
            var r = t < 0;
            if (this.negative !== 0 && !r) return -1;
            if (this.negative === 0 && r) return 1;
            this.strip();
            var e;
            if (this.length > 1) e = 1;
            else {
                r && (t = -t), v(t <= 67108863, "Number is too big");
                var h = this.words[0] | 0;
                e = h === t ? 0 : h < t ? -1 : 1;
            }
            return this.negative !== 0 ? -e | 0 : e;
        }, l.prototype.cmp = function(t) {
            if (this.negative !== 0 && t.negative === 0) return -1;
            if (this.negative === 0 && t.negative !== 0) return 1;
            var r = this.ucmp(t);
            return this.negative !== 0 ? -r | 0 : r;
        }, l.prototype.ucmp = function(t) {
            if (this.length > t.length) return 1;
            if (this.length < t.length) return -1;
            for(var r = 0, e = this.length - 1; e >= 0; e--){
                var h = this.words[e] | 0, s = t.words[e] | 0;
                if (h !== s) {
                    h < s ? r = -1 : h > s && (r = 1);
                    break;
                }
            }
            return r;
        }, l.prototype.gtn = function(t) {
            return this.cmpn(t) === 1;
        }, l.prototype.gt = function(t) {
            return this.cmp(t) === 1;
        }, l.prototype.gten = function(t) {
            return this.cmpn(t) >= 0;
        }, l.prototype.gte = function(t) {
            return this.cmp(t) >= 0;
        }, l.prototype.ltn = function(t) {
            return this.cmpn(t) === -1;
        }, l.prototype.lt = function(t) {
            return this.cmp(t) === -1;
        }, l.prototype.lten = function(t) {
            return this.cmpn(t) <= 0;
        }, l.prototype.lte = function(t) {
            return this.cmp(t) <= 0;
        }, l.prototype.eqn = function(t) {
            return this.cmpn(t) === 0;
        }, l.prototype.eq = function(t) {
            return this.cmp(t) === 0;
        }, l.red = function(t) {
            return new b(t);
        }, l.prototype.toRed = function(t) {
            return v(!this.red, "Already a number in reduction context"), v(this.negative === 0, "red works only with positives"), t.convertTo(this)._forceRed(t);
        }, l.prototype.fromRed = function() {
            return v(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, l.prototype._forceRed = function(t) {
            return this.red = t, this;
        }, l.prototype.forceRed = function(t) {
            return v(!this.red, "Already a number in reduction context"), this._forceRed(t);
        }, l.prototype.redAdd = function(t) {
            return v(this.red, "redAdd works only with red numbers"), this.red.add(this, t);
        }, l.prototype.redIAdd = function(t) {
            return v(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t);
        }, l.prototype.redSub = function(t) {
            return v(this.red, "redSub works only with red numbers"), this.red.sub(this, t);
        }, l.prototype.redISub = function(t) {
            return v(this.red, "redISub works only with red numbers"), this.red.isub(this, t);
        }, l.prototype.redShl = function(t) {
            return v(this.red, "redShl works only with red numbers"), this.red.shl(this, t);
        }, l.prototype.redMul = function(t) {
            return v(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t);
        }, l.prototype.redIMul = function(t) {
            return v(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t);
        }, l.prototype.redSqr = function() {
            return v(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, l.prototype.redISqr = function() {
            return v(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, l.prototype.redSqrt = function() {
            return v(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, l.prototype.redInvm = function() {
            return v(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, l.prototype.redNeg = function() {
            return v(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, l.prototype.redPow = function(t) {
            return v(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t);
        };
        var ut = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function ht(o, t) {
            this.name = o, this.p = new l(t, 16), this.n = this.p.bitLength(), this.k = new l(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        ht.prototype._tmp = function() {
            var t = new l(null);
            return t.words = new Array(Math.ceil(this.n / 13)), t;
        }, ht.prototype.ireduce = function(t) {
            var r = t, e;
            do this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), e = r.bitLength();
            while (e > this.n)
            var h = e < this.n ? -1 : r.ucmp(this.p);
            return h === 0 ? (r.words[0] = 0, r.length = 1) : h > 0 ? r.isub(this.p) : r.strip !== void 0 ? r.strip() : r._strip(), r;
        }, ht.prototype.split = function(t, r) {
            t.iushrn(this.n, 0, r);
        }, ht.prototype.imulK = function(t) {
            return t.imul(this.k);
        };
        function lt() {
            ht.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        ft(lt, ht), lt.prototype.split = function(t, r) {
            for(var e = 4194303, h = Math.min(t.length, 9), s = 0; s < h; s++)r.words[s] = t.words[s];
            if (r.length = h, t.length <= 9) {
                t.words[0] = 0, t.length = 1;
                return;
            }
            var a = t.words[9];
            for(r.words[r.length++] = a & e, s = 10; s < t.length; s++){
                var u = t.words[s] | 0;
                t.words[s - 10] = (u & e) << 4 | a >>> 22, a = u;
            }
            a >>>= 22, t.words[s - 10] = a, a === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9;
        }, lt.prototype.imulK = function(t) {
            t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
            for(var r = 0, e = 0; e < t.length; e++){
                var h = t.words[e] | 0;
                r += h * 977, t.words[e] = r & 67108863, r = h * 64 + (r / 67108864 | 0);
            }
            return t.words[t.length - 1] === 0 && (t.length--, t.words[t.length - 1] === 0 && t.length--), t;
        };
        function Dt() {
            ht.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        ft(Dt, ht);
        function Ct() {
            ht.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        ft(Ct, ht);
        function vt() {
            ht.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        ft(vt, ht), vt.prototype.imulK = function(t) {
            for(var r = 0, e = 0; e < t.length; e++){
                var h = (t.words[e] | 0) * 19 + r, s = h & 67108863;
                h >>>= 26, t.words[e] = s, r = h;
            }
            return r !== 0 && (t.words[t.length++] = r), t;
        }, l._prime = function(t) {
            if (ut[t]) return ut[t];
            var r;
            if (t === "k256") r = new lt;
            else if (t === "p224") r = new Dt;
            else if (t === "p192") r = new Ct;
            else if (t === "p25519") r = new vt;
            else throw new Error("Unknown prime " + t);
            return ut[t] = r, r;
        };
        function b(o) {
            if (typeof o == "string") {
                var t = l._prime(o);
                this.m = t.p, this.prime = t;
            } else v(o.gtn(1), "modulus must be greater than 1"), this.m = o, this.prime = null;
        }
        b.prototype._verify1 = function(t) {
            v(t.negative === 0, "red works only with positives"), v(t.red, "red works only with red numbers");
        }, b.prototype._verify2 = function(t, r) {
            v((t.negative | r.negative) == 0, "red works only with positives"), v(t.red && t.red === r.red, "red works only with red numbers");
        }, b.prototype.imod = function(t) {
            return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this);
        }, b.prototype.neg = function(t) {
            return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
        }, b.prototype.add = function(t, r) {
            this._verify2(t, r);
            var e = t.add(r);
            return e.cmp(this.m) >= 0 && e.isub(this.m), e._forceRed(this);
        }, b.prototype.iadd = function(t, r) {
            this._verify2(t, r);
            var e = t.iadd(r);
            return e.cmp(this.m) >= 0 && e.isub(this.m), e;
        }, b.prototype.sub = function(t, r) {
            this._verify2(t, r);
            var e = t.sub(r);
            return e.cmpn(0) < 0 && e.iadd(this.m), e._forceRed(this);
        }, b.prototype.isub = function(t, r) {
            this._verify2(t, r);
            var e = t.isub(r);
            return e.cmpn(0) < 0 && e.iadd(this.m), e;
        }, b.prototype.shl = function(t, r) {
            return this._verify1(t), this.imod(t.ushln(r));
        }, b.prototype.imul = function(t, r) {
            return this._verify2(t, r), this.imod(t.imul(r));
        }, b.prototype.mul = function(t, r) {
            return this._verify2(t, r), this.imod(t.mul(r));
        }, b.prototype.isqr = function(t) {
            return this.imul(t, t.clone());
        }, b.prototype.sqr = function(t) {
            return this.mul(t, t);
        }, b.prototype.sqrt = function(t) {
            if (t.isZero()) return t.clone();
            var r = this.m.andln(3);
            if (v(r % 2 == 1), r === 3) {
                var e = this.m.add(new l(1)).iushrn(2);
                return this.pow(t, e);
            }
            for(var h = this.m.subn(1), s = 0; !h.isZero() && h.andln(1) === 0;)s++, h.iushrn(1);
            v(!h.isZero());
            var a = new l(1).toRed(this), u = a.redNeg(), f = this.m.subn(1).iushrn(1), i = this.m.bitLength();
            for(i = new l(2 * i * i).toRed(this); this.pow(i, f).cmp(u) !== 0;)i.redIAdd(u);
            for(var n = this.pow(i, h), d = this.pow(t, h.addn(1).iushrn(1)), m = this.pow(t, h), p = s; m.cmp(a) !== 0;){
                for(var M = m, g = 0; M.cmp(a) !== 0; g++)M = M.redSqr();
                v(g < p);
                var c = this.pow(n, new l(1).iushln(p - g - 1));
                d = d.redMul(c), n = c.redSqr(), m = m.redMul(n), p = g;
            }
            return d;
        }, b.prototype.invm = function(t) {
            var r = t._invmp(this.m);
            return r.negative !== 0 ? (r.negative = 0, this.imod(r).redNeg()) : this.imod(r);
        }, b.prototype.pow = function(t, r) {
            if (r.isZero()) return new l(1).toRed(this);
            if (r.cmpn(1) === 0) return t.clone();
            var e = 4, h = new Array(1 << e);
            h[0] = new l(1).toRed(this), h[1] = t;
            for(var s = 2; s < h.length; s++)h[s] = this.mul(h[s - 1], t);
            var a = h[0], u = 0, f = 0, i = r.bitLength() % 26;
            for(i === 0 && (i = 26), s = r.length - 1; s >= 0; s--){
                for(var n = r.words[s], d = i - 1; d >= 0; d--){
                    var m = n >> d & 1;
                    if (a !== h[0] && (a = this.sqr(a)), m === 0 && u === 0) {
                        f = 0;
                        continue;
                    }
                    u <<= 1, u |= m, f++, !(f !== e && (s !== 0 || d !== 0)) && (a = this.mul(a, h[u]), f = 0, u = 0);
                }
                i = 26;
            }
            return a;
        }, b.prototype.convertTo = function(t) {
            var r = t.umod(this.m);
            return r === t ? r.clone() : r;
        }, b.prototype.convertFrom = function(t) {
            var r = t.clone();
            return r.red = null, r;
        }, l.mont = function(t) {
            return new ot(t);
        };
        function ot(o) {
            b.call(this, o), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new l(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        ft(ot, b), ot.prototype.convertTo = function(t) {
            return this.imod(t.ushln(this.shift));
        }, ot.prototype.convertFrom = function(t) {
            var r = this.imod(t.mul(this.rinv));
            return r.red = null, r;
        }, ot.prototype.imul = function(t, r) {
            if (t.isZero() || r.isZero()) return t.words[0] = 0, t.length = 1, t;
            var e = t.imul(r), h = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s = e.isub(h).iushrn(this.shift), a = s;
            return s.cmp(this.m) >= 0 ? a = s.isub(this.m) : s.cmpn(0) < 0 && (a = s.iadd(this.m)), a._forceRed(this);
        }, ot.prototype.mul = function(t, r) {
            if (t.isZero() || r.isZero()) return new l(0)._forceRed(this);
            var e = t.mul(r), h = e.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s = e.isub(h).iushrn(this.shift), a = s;
            return s.cmp(this.m) >= 0 ? a = s.isub(this.m) : s.cmpn(0) < 0 && (a = s.iadd(this.m)), a._forceRed(this);
        }, ot.prototype.invm = function(t) {
            var r = this.imod(t._invmp(this.m).mul(this.r2));
            return r._forceRed(this);
        };
    })(typeof zt == "undefined" || zt, oi);
});
var bi = si(It()), _i = si(It()), { BN: Bi  } = bi;
var export_default = _i.default;
var s = Object.create;
var a = Object.defineProperty;
var c = Object.getOwnPropertyDescriptor;
var w = Object.getOwnPropertyNames;
var y = Object.getPrototypeOf, B = Object.prototype.hasOwnProperty;
var h = (r)=>a(r, "__esModule", {
        value: !0
    });
var A = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var E = (r, e, f)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of w(e))!B.call(r, o) && o !== "default" && a(r, o, {
        get: ()=>e[o],
        enumerable: !(f = c(e, o)) || f.enumerable
    });
    return r;
}, p = (r)=>E(h(a(r != null ? s(y(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var m = A((l, i)=>{
    var u = export_default, t = u.Buffer;
    function b(r, e) {
        for(var f in r)e[f] = r[f];
    }
    t.from && t.alloc && t.allocUnsafe && t.allocUnsafeSlow ? i.exports = u : (b(u, l), l.Buffer = n);
    function n(r, e, f) {
        return t(r, e, f);
    }
    n.prototype = Object.create(t.prototype);
    b(t, n);
    n.from = function(r, e, f) {
        if (typeof r == "number") throw new TypeError("Argument must not be a number");
        return t(r, e, f);
    };
    n.alloc = function(r, e, f) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        var o = t(r);
        return e !== void 0 ? typeof f == "string" ? o.fill(e, f) : o.fill(e) : o.fill(0), o;
    };
    n.allocUnsafe = function(r) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        return t(r);
    };
    n.allocUnsafeSlow = function(r) {
        if (typeof r != "number") throw new TypeError("Argument must be a number");
        return u.SlowBuffer(r);
    };
});
var S = p(m()), T = p(m()), { Buffer: g  } = S;
var export_default = T.default;
var P = Object.create;
var d = Object.defineProperty;
var T = Object.getOwnPropertyDescriptor;
var F = Object.getOwnPropertyNames;
var I = Object.getPrototypeOf, K = Object.prototype.hasOwnProperty;
var o = (t, e)=>d(t, "name", {
        value: e,
        configurable: !0
    });
var W = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var $ = (t, e, n, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let i of F(e))!K.call(t, i) && i !== n && d(t, i, {
        get: ()=>e[i],
        enumerable: !(r = T(e, i)) || r.enumerable
    });
    return t;
};
var y = (t, e, n)=>(n = t != null ? P(I(t)) : {}, $(e || !t || !t.__esModule ? d(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t));
var m = W((J, h)=>{
    "use strict";
    var c = typeof Reflect == "object" ? Reflect : null, g = c && typeof c.apply == "function" ? c.apply : o(function(e, n, r) {
        return Function.prototype.apply.call(e, n, r);
    }, "ReflectApply"), v;
    c && typeof c.ownKeys == "function" ? v = c.ownKeys : Object.getOwnPropertySymbols ? v = o(function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    }, "ReflectOwnKeys") : v = o(function(e) {
        return Object.getOwnPropertyNames(e);
    }, "ReflectOwnKeys");
    function S(t) {
        console && console.warn && console.warn(t);
    }
    o(S, "ProcessEmitWarning");
    var w = Number.isNaN || o(function(e) {
        return e !== e;
    }, "NumberIsNaN");
    function f() {
        f.init.call(this);
    }
    o(f, "EventEmitter");
    h.exports = f;
    h.exports.once = q;
    f.EventEmitter = f;
    f.prototype._events = void 0;
    f.prototype._eventsCount = 0;
    f.prototype._maxListeners = void 0;
    var _ = 10;
    function p(t) {
        if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    o(p, "checkListener");
    Object.defineProperty(f, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return _;
        },
        set: function(t) {
            if (typeof t != "number" || t < 0 || w(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            _ = t;
        }
    });
    f.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    };
    f.prototype.setMaxListeners = o(function(e) {
        if (typeof e != "number" || e < 0 || w(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this;
    }, "setMaxListeners");
    function b(t) {
        return t._maxListeners === void 0 ? f.defaultMaxListeners : t._maxListeners;
    }
    o(b, "_getMaxListeners");
    f.prototype.getMaxListeners = o(function() {
        return b(this);
    }, "getMaxListeners");
    f.prototype.emit = o(function(e) {
        for(var n = [], r = 1; r < arguments.length; r++)n.push(arguments[r]);
        var i = e === "error", u = this._events;
        if (u !== void 0) i = i && u.error === void 0;
        else if (!i) return !1;
        if (i) {
            var s;
            if (n.length > 0 && (s = n[0]), s instanceof Error) throw s;
            var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
            throw a.context = s, a;
        }
        var l = u[e];
        if (l === void 0) return !1;
        if (typeof l == "function") g(l, this, n);
        else for(var L = l.length, A = j(l, L), r = 0; r < L; ++r)g(A[r], this, n);
        return !0;
    }, "emit");
    function E(t, e, n, r) {
        var i, u, s;
        if (p(n), u = t._events, u === void 0 ? (u = t._events = Object.create(null), t._eventsCount = 0) : (u.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), u = t._events), s = u[e]), s === void 0) s = u[e] = n, ++t._eventsCount;
        else if (typeof s == "function" ? s = u[e] = r ? [
            n,
            s
        ] : [
            s,
            n
        ] : r ? s.unshift(n) : s.push(n), i = b(t), i > 0 && s.length > i && !s.warned) {
            s.warned = !0;
            var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = s.length, S(a);
        }
        return t;
    }
    o(E, "_addListener");
    f.prototype.addListener = o(function(e, n) {
        return E(this, e, n, !1);
    }, "addListener");
    f.prototype.on = f.prototype.addListener;
    f.prototype.prependListener = o(function(e, n) {
        return E(this, e, n, !0);
    }, "prependListener");
    function U() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    o(U, "onceWrapper");
    function O(t, e, n) {
        var r = {
            fired: !1,
            wrapFn: void 0,
            target: t,
            type: e,
            listener: n
        }, i = U.bind(r);
        return i.listener = n, r.wrapFn = i, i;
    }
    o(O, "_onceWrap");
    f.prototype.once = o(function(e, n) {
        return p(n), this.on(e, O(this, e, n)), this;
    }, "once");
    f.prototype.prependOnceListener = o(function(e, n) {
        return p(n), this.prependListener(e, O(this, e, n)), this;
    }, "prependOnceListener");
    f.prototype.removeListener = o(function(e, n) {
        var r, i, u, s, a;
        if (p(n), i = this._events, i === void 0) return this;
        if (r = i[e], r === void 0) return this;
        if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
        else if (typeof r != "function") {
            for(u = -1, s = r.length - 1; s >= 0; s--)if (r[s] === n || r[s].listener === n) {
                a = r[s].listener, u = s;
                break;
            }
            if (u < 0) return this;
            u === 0 ? r.shift() : k(r, u), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || n);
        }
        return this;
    }, "removeListener");
    f.prototype.off = f.prototype.removeListener;
    f.prototype.removeAllListeners = o(function(e) {
        var n, r, i;
        if (r = this._events, r === void 0) return this;
        if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
        if (arguments.length === 0) {
            var u = Object.keys(r), s;
            for(i = 0; i < u.length; ++i)s = u[i], s !== "removeListener" && this.removeAllListeners(s);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
        }
        if (n = r[e], typeof n == "function") this.removeListener(e, n);
        else if (n !== void 0) for(i = n.length - 1; i >= 0; i--)this.removeListener(e, n[i]);
        return this;
    }, "removeAllListeners");
    function x(t, e, n) {
        var r = t._events;
        if (r === void 0) return [];
        var i = r[e];
        return i === void 0 ? [] : typeof i == "function" ? n ? [
            i.listener || i
        ] : [
            i
        ] : n ? H(i) : j(i, i.length);
    }
    o(x, "_listeners");
    f.prototype.listeners = o(function(e) {
        return x(this, e, !0);
    }, "listeners");
    f.prototype.rawListeners = o(function(e) {
        return x(this, e, !1);
    }, "rawListeners");
    f.listenerCount = function(t, e) {
        return typeof t.listenerCount == "function" ? t.listenerCount(e) : C.call(t, e);
    };
    f.prototype.listenerCount = C;
    function C(t) {
        var e = this._events;
        if (e !== void 0) {
            var n = e[t];
            if (typeof n == "function") return 1;
            if (n !== void 0) return n.length;
        }
        return 0;
    }
    o(C, "listenerCount");
    f.prototype.eventNames = o(function() {
        return this._eventsCount > 0 ? v(this._events) : [];
    }, "eventNames");
    function j(t, e) {
        for(var n = new Array(e), r = 0; r < e; ++r)n[r] = t[r];
        return n;
    }
    o(j, "arrayClone");
    function k(t, e) {
        for(; e + 1 < t.length; e++)t[e] = t[e + 1];
        t.pop();
    }
    o(k, "spliceOne");
    function H(t) {
        for(var e = new Array(t.length), n = 0; n < e.length; ++n)e[n] = t[n].listener || t[n];
        return e;
    }
    o(H, "unwrapListeners");
    function q(t, e) {
        return new Promise(function(n, r) {
            function i(s) {
                t.removeListener(e, u), r(s);
            }
            o(i, "errorListener");
            function u() {
                typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
            }
            o(u, "resolver"), R(t, e, u, {
                once: !0
            }), e !== "error" && z(t, i, {
                once: !0
            });
        });
    }
    o(q, "once");
    function z(t, e, n) {
        typeof t.on == "function" && R(t, "error", e, n);
    }
    o(z, "addErrorHandlerIfEventEmitter");
    function R(t, e, n, r) {
        if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
        else if (typeof t.addEventListener == "function") t.addEventListener(e, o(function i(u) {
            r.once && t.removeEventListener(e, i), n(u);
        }, "wrapListener"));
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
    o(R, "eventTargetAgnosticAddListener");
});
var N = y(m()), M = y(m()), { EventEmitter: Q , init: V , listenerCount: X , once: Y  } = M, { default: B , ...D } = M, Z = (N.default ?? B) ?? D;
const events = new Q();
events.setMaxListeners(1 << 10);
let cachedSetTimeout;
let cachedClearTimeout;
function defaultSetTimeout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimeout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimeout;
    }
    try {
        if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fn) {
    if (cachedSetTimeout === setTimeout) {
        return setTimeout(fn, 0);
    }
    if ((cachedSetTimeout === defaultSetTimeout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fn, 0);
    }
    try {
        return cachedSetTimeout(fn, 0);
    } catch (e) {
        try {
            return cachedSetTimeout.call(null, fn, 0);
        } catch (e1) {
            return cachedSetTimeout.call(this, fn, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            return cachedClearTimeout.call(null, marker);
        } catch (e1) {
            return cachedClearTimeout.call(this, marker);
        }
    }
}
let queue = [];
let queueIndex = -1;
let currentQueue;
let draining = false;
function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}
function drainQueue() {
    if (draining) {
        return;
    }
    let timeout = runTimeout(cleanUpNextTick);
    draining = true;
    let len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len){
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
class Item {
    constructor(fn, array){
        this.fn = fn;
        this.array = array;
    }
    run() {
        this.fn.apply(null, this.array);
    }
}
const deno = typeof Deno !== "undefined";
const __default = {
    title: deno ? "deno" : "browser",
    browser: true,
    env: deno ? new Proxy({}, {
        get (_target, prop) {
            return Deno.env.get(String(prop));
        },
        ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
        getOwnPropertyDescriptor: (_target, name)=>{
            const e = Deno.env.toObject();
            if (name in Deno.env.toObject()) {
                const o = {
                    enumerable: true,
                    configurable: true
                };
                if (typeof name === "string") {
                    o.value = e[name];
                }
                return o;
            }
        },
        set (_target, prop, value) {
            Deno.env.set(String(prop), String(value));
            return value;
        }
    }) : {},
    argv: deno ? Deno.args ?? [] : [],
    pid: deno ? Deno.pid ?? 0 : 0,
    version: "v16.14.0",
    versions: {
        node: "16.14.0",
        v8: "9.4.146.24-node.20",
        uv: "1.43.0",
        zlib: "1.2.11",
        brotli: "1.0.9",
        ares: "1.18.1",
        modules: "93",
        nghttp2: "1.45.1",
        napi: "8",
        llhttp: "6.0.4",
        openssl: "1.1.1m+quic",
        cldr: "40.0",
        icu: "70.1",
        tz: "2021a3",
        unicode: "14.0",
        ...deno ? Deno.version ?? {
            deno: "1.0.0-denodeploy.beta-4"
        } : {}
    },
    on: (...args)=>events.on(...args),
    addListener: (...args)=>events.addListener(...args),
    once: (...args)=>events.once(...args),
    off: (...args)=>events.off(...args),
    removeListener: (...args)=>events.removeListener(...args),
    removeAllListeners: (...args)=>events.removeAllListeners(...args),
    emit: (...args)=>events.emit(...args),
    prependListener: (...args)=>events.prependListener(...args),
    prependOnceListener: (...args)=>events.prependOnceListener(...args),
    listeners: ()=>[],
    emitWarning: ()=>{
        throw new Error("process.emitWarning is not supported");
    },
    binding: ()=>{
        throw new Error("process.binding is not supported");
    },
    cwd: ()=>deno ? Deno.cwd?.() ?? "/" : "/",
    chdir: (path)=>{
        if (deno) {
            Deno.chdir(path);
        } else {
            throw new Error("process.chdir is not supported");
        }
    },
    umask: ()=>deno ? Deno.umask ?? 0 : 0,
    nextTick: function(fn) {
        let args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for(let i = 1; i < arguments.length; i++){
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fn, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
};
__default.env.NODE_ENV = "production";
var __global$ = window;
var l = Object.create;
var a = Object.defineProperty;
var i = Object.getOwnPropertyDescriptor;
var m = Object.getOwnPropertyNames;
var c = Object.getPrototypeOf, p = Object.prototype.hasOwnProperty;
var y = (r)=>a(r, "__esModule", {
        value: !0
    });
var d = (r, o)=>()=>(o || r((o = {
            exports: {}
        }).exports, o), o.exports);
var v = (r, o, t)=>{
    if (o && typeof o == "object" || typeof o == "function") for (let e of m(o))!p.call(r, e) && e !== "default" && a(r, e, {
        get: ()=>o[e],
        enumerable: !(t = i(o, e)) || t.enumerable
    });
    return r;
}, w = (r)=>v(y(a(r != null ? l(c(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var u = d((T, s)=>{
    "use strict";
    var f = 65536, x = 4294967295;
    function B() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var g = export_default.Buffer, n = __global$.crypto || __global$.msCrypto;
    n && n.getRandomValues ? s.exports = h : s.exports = B;
    function h(r, o) {
        if (r > x) throw new RangeError("requested too many random bytes");
        var t = g.allocUnsafe(r);
        if (r > 0) if (r > f) for(var e = 0; e < r; e += f)n.getRandomValues(t.slice(e, e + f));
        else n.getRandomValues(t);
        return typeof o == "function" ? __default.nextTick(function() {
            o(null, t);
        }) : t;
    }
});
var E = w(u());
var export_default = E.default;
var h = Object.create;
var d = Object.defineProperty;
var q = Object.getOwnPropertyDescriptor;
var v = Object.getOwnPropertyNames;
var B = Object.getPrototypeOf, L = Object.prototype.hasOwnProperty;
var P = (e)=>d(e, "__esModule", {
        value: !0
    });
var j = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var k = (e, r, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let o of v(r))!L.call(e, o) && o !== "default" && d(e, o, {
        get: ()=>r[o],
        enumerable: !(n = q(r, o)) || n.enumerable
    });
    return e;
}, A = (e)=>k(P(d(e != null ? h(B(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var s = j((D, i)=>{
    var u = export_default, E = export_default;
    function N(e) {
        var r = a(e), n = r.toRed(u.mont(e.modulus)).redPow(new u(e.publicExponent)).fromRed();
        return {
            blinder: n,
            unblinder: r.invm(e.modulus)
        };
    }
    function a(e) {
        var r = e.modulus.byteLength(), n;
        do n = new u(E(r));
        while (n.cmp(e.modulus) >= 0 || !n.umod(e.prime1) || !n.umod(e.prime2))
        return n;
    }
    function b(e, r) {
        var n = N(r), o = r.modulus.byteLength(), m = new u(e).mul(n.blinder).umod(r.modulus), f = m.toRed(u.mont(r.prime1)), c = m.toRed(u.mont(r.prime2)), w = r.coefficient, y = r.prime1, R = r.prime2, x = f.redPow(r.exponent1).fromRed(), t = c.redPow(r.exponent2).fromRed(), g = x.isub(t).imul(w).umod(y).imul(R);
        return t.iadd(g).imul(n.unblinder).umod(r.modulus).toArrayLike(ut, "be", o);
    }
    b.getr = a;
    i.exports = b;
});
var z = A(s());
var export_default = z.default;
var N = Object.create;
var p = Object.defineProperty;
var M = Object.getOwnPropertyDescriptor;
var A = Object.getOwnPropertyNames;
var P = Object.getPrototypeOf, T = Object.prototype.hasOwnProperty;
var F = (t)=>p(t, "__esModule", {
        value: !0
    });
var I = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var K = (t, e, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let r of A(e))!T.call(t, r) && r !== "default" && p(t, r, {
        get: ()=>e[r],
        enumerable: !(n = M(e, r)) || n.enumerable
    });
    return t;
}, L = (t)=>K(F(p(t != null ? N(P(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var h = I((G, d)=>{
    "use strict";
    var a = typeof Reflect == "object" ? Reflect : null, y = a && typeof a.apply == "function" ? a.apply : function(e, n, r) {
        return Function.prototype.apply.call(e, n, r);
    }, l;
    a && typeof a.ownKeys == "function" ? l = a.ownKeys : Object.getOwnPropertySymbols ? l = function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : l = function(e) {
        return Object.getOwnPropertyNames(e);
    };
    function W(t) {
        console && console.warn && console.warn(t);
    }
    var g = Number.isNaN || function(e) {
        return e !== e;
    };
    function o() {
        o.init.call(this);
    }
    d.exports = o;
    d.exports.once = H;
    o.EventEmitter = o;
    o.prototype._events = void 0;
    o.prototype._eventsCount = 0;
    o.prototype._maxListeners = void 0;
    var _ = 10;
    function v(t) {
        if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(o, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return _;
        },
        set: function(t) {
            if (typeof t != "number" || t < 0 || g(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            _ = t;
        }
    });
    o.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    };
    o.prototype.setMaxListeners = function(e) {
        if (typeof e != "number" || e < 0 || g(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this;
    };
    function w(t) {
        return t._maxListeners === void 0 ? o.defaultMaxListeners : t._maxListeners;
    }
    o.prototype.getMaxListeners = function() {
        return w(this);
    };
    o.prototype.emit = function(e) {
        for(var n = [], r = 1; r < arguments.length; r++)n.push(arguments[r]);
        var i = e === "error", f = this._events;
        if (f !== void 0) i = i && f.error === void 0;
        else if (!i) return !1;
        if (i) {
            var s;
            if (n.length > 0 && (s = n[0]), s instanceof Error) throw s;
            var u = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
            throw u.context = s, u;
        }
        var c = f[e];
        if (c === void 0) return !1;
        if (typeof c == "function") y(c, this, n);
        else for(var m = c.length, R = C(c, m), r = 0; r < m; ++r)y(R[r], this, n);
        return !0;
    };
    function b(t, e, n, r) {
        var i, f, s;
        if (v(n), f = t._events, f === void 0 ? (f = t._events = Object.create(null), t._eventsCount = 0) : (f.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), f = t._events), s = f[e]), s === void 0) s = f[e] = n, ++t._eventsCount;
        else if (typeof s == "function" ? s = f[e] = r ? [
            n,
            s
        ] : [
            s,
            n
        ] : r ? s.unshift(n) : s.push(n), i = w(t), i > 0 && s.length > i && !s.warned) {
            s.warned = !0;
            var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = s.length, W(u);
        }
        return t;
    }
    o.prototype.addListener = function(e, n) {
        return b(this, e, n, !1);
    };
    o.prototype.on = o.prototype.addListener;
    o.prototype.prependListener = function(e, n) {
        return b(this, e, n, !0);
    };
    function S() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function E(t, e, n) {
        var r = {
            fired: !1,
            wrapFn: void 0,
            target: t,
            type: e,
            listener: n
        }, i = S.bind(r);
        return i.listener = n, r.wrapFn = i, i;
    }
    o.prototype.once = function(e, n) {
        return v(n), this.on(e, E(this, e, n)), this;
    };
    o.prototype.prependOnceListener = function(e, n) {
        return v(n), this.prependListener(e, E(this, e, n)), this;
    };
    o.prototype.removeListener = function(e, n) {
        var r, i, f, s, u;
        if (v(n), i = this._events, i === void 0) return this;
        if (r = i[e], r === void 0) return this;
        if (r === n || r.listener === n) --this._eventsCount == 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
        else if (typeof r != "function") {
            for(f = -1, s = r.length - 1; s >= 0; s--)if (r[s] === n || r[s].listener === n) {
                u = r[s].listener, f = s;
                break;
            }
            if (f < 0) return this;
            f === 0 ? r.shift() : U(r, f), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || n);
        }
        return this;
    };
    o.prototype.off = o.prototype.removeListener;
    o.prototype.removeAllListeners = function(e) {
        var n, r, i;
        if (r = this._events, r === void 0) return this;
        if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete r[e]), this;
        if (arguments.length === 0) {
            var f = Object.keys(r), s;
            for(i = 0; i < f.length; ++i)s = f[i], s !== "removeListener" && this.removeAllListeners(s);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
        }
        if (n = r[e], typeof n == "function") this.removeListener(e, n);
        else if (n !== void 0) for(i = n.length - 1; i >= 0; i--)this.removeListener(e, n[i]);
        return this;
    };
    function O(t, e, n) {
        var r = t._events;
        if (r === void 0) return [];
        var i = r[e];
        return i === void 0 ? [] : typeof i == "function" ? n ? [
            i.listener || i
        ] : [
            i
        ] : n ? k(i) : C(i, i.length);
    }
    o.prototype.listeners = function(e) {
        return O(this, e, !0);
    };
    o.prototype.rawListeners = function(e) {
        return O(this, e, !1);
    };
    o.listenerCount = function(t, e) {
        return typeof t.listenerCount == "function" ? t.listenerCount(e) : x.call(t, e);
    };
    o.prototype.listenerCount = x;
    function x(t) {
        var e = this._events;
        if (e !== void 0) {
            var n = e[t];
            if (typeof n == "function") return 1;
            if (n !== void 0) return n.length;
        }
        return 0;
    }
    o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? l(this._events) : [];
    };
    function C(t, e) {
        for(var n = new Array(e), r = 0; r < e; ++r)n[r] = t[r];
        return n;
    }
    function U(t, e) {
        for(; e + 1 < t.length; e++)t[e] = t[e + 1];
        t.pop();
    }
    function k(t) {
        for(var e = new Array(t.length), n = 0; n < e.length; ++n)e[n] = t[n].listener || t[n];
        return e;
    }
    function H(t, e) {
        return new Promise(function(n, r) {
            function i(s) {
                t.removeListener(e, f), r(s);
            }
            function f() {
                typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
            }
            j(t, e, f, {
                once: !0
            }), e !== "error" && q(t, i, {
                once: !0
            });
        });
    }
    function q(t, e, n) {
        typeof t.on == "function" && j(t, "error", e, n);
    }
    function j(t, e, n, r) {
        if (typeof t.on == "function") r.once ? t.once(e, n) : t.on(e, n);
        else if (typeof t.addEventListener == "function") t.addEventListener(e, function i(f) {
            r.once && t.removeEventListener(e, i), n(f);
        });
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
});
var z = L(h()), B = L(h()), { once: J  } = z;
var export_default = B.default;
var f = Object.create;
var i = Object.defineProperty;
var u = Object.getOwnPropertyDescriptor;
var a = Object.getOwnPropertyNames;
var c = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty;
var s = (t)=>i(t, "__esModule", {
        value: !0
    });
var y = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var b = (t, e, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of a(e))!l.call(t, o) && o !== "default" && i(t, o, {
        get: ()=>e[o],
        enumerable: !(n = u(e, o)) || n.enumerable
    });
    return t;
}, h = (t)=>b(s(i(t != null ? f(c(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var r = y((v, p)=>{
    typeof Object.create == "function" ? p.exports = function(e, n) {
        n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    } : p.exports = function(e, n) {
        if (n) {
            e.super_ = n;
            var o = function() {};
            o.prototype = n.prototype, e.prototype = new o, e.prototype.constructor = e;
        }
    };
});
var x = h(r());
var export_default = x.default;
var b = Object.create;
var n = Object.defineProperty;
var u = Object.getOwnPropertyDescriptor;
var c = Object.getOwnPropertyNames;
var i = Object.getPrototypeOf, p = Object.prototype.hasOwnProperty;
var m = (t)=>n(t, "__esModule", {
        value: !0
    });
var O = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var j = (t, e, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of c(e))!p.call(t, o) && o !== "default" && n(t, o, {
        get: ()=>e[o],
        enumerable: !(r = u(e, o)) || r.enumerable
    });
    return t;
}, g = (t)=>j(m(n(t != null ? b(i(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var a = O((h, y)=>{
    "use strict";
    y.exports = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {}, r = Symbol("test"), o = Object(r);
        if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]") return !1;
        var f = 42;
        e[r] = f;
        for(r in e)return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(e);
        if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var l = Object.getOwnPropertyDescriptor(e, r);
            if (l.value !== f || l.enumerable !== !0) return !1;
        }
        return !0;
    };
});
var S = g(a());
var export_default = S.default;
var m = Object.create;
var r = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var i = Object.getOwnPropertyNames;
var n = Object.getPrototypeOf, u = Object.prototype.hasOwnProperty;
var S = (s)=>r(s, "__esModule", {
        value: !0
    });
var b = (s, t)=>()=>(t || s((t = {
            exports: {}
        }).exports, t), t.exports);
var f = (s, t, o)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let a of i(t))!u.call(s, a) && a !== "default" && r(s, a, {
        get: ()=>t[a],
        enumerable: !(o = g(t, a)) || o.enumerable
    });
    return s;
}, y = (s)=>f(S(r(s != null ? m(n(s)) : {}, "default", s && s.__esModule && "default" in s ? {
        get: ()=>s.default,
        enumerable: !0
    } : {
        value: s,
        enumerable: !0
    })), s);
var h = b((x, e)=>{
    "use strict";
    var T = export_default;
    e.exports = function() {
        return T() && !!Symbol.toStringTag;
    };
});
var c = y(h());
var export_default = c.default;
var p = Object.create;
var f = Object.defineProperty;
var c = Object.getOwnPropertyDescriptor;
var O = Object.getOwnPropertyNames;
var S = Object.getPrototypeOf, j = Object.prototype.hasOwnProperty;
var g = (t)=>f(t, "__esModule", {
        value: !0
    });
var y = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var v = (t, e, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of O(e))!j.call(t, o) && o !== "default" && f(t, o, {
        get: ()=>e[o],
        enumerable: !(r = c(e, o)) || r.enumerable
    });
    return t;
}, h = (t)=>v(g(f(t != null ? p(S(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var b = y((N, a)=>{
    "use strict";
    a.exports = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {}, r = Symbol("test"), o = Object(r);
        if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]") return !1;
        var n = 42;
        e[r] = n;
        for(r in e)return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var s = Object.getOwnPropertySymbols(e);
        if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var l = Object.getOwnPropertyDescriptor(e, r);
            if (l.value !== n || l.enumerable !== !0) return !1;
        }
        return !0;
    };
});
var m = y((d, i)=>{
    "use strict";
    var u = typeof Symbol != "undefined" && Symbol, w = b();
    i.exports = function() {
        return typeof u != "function" || typeof Symbol != "function" || typeof u("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : w();
    };
});
var P = h(m());
var export_default = P.default;
var h = Object.create;
var c = Object.defineProperty;
var m = Object.getOwnPropertyDescriptor;
var j = Object.getOwnPropertyNames;
var x = Object.getPrototypeOf, F = Object.prototype.hasOwnProperty;
var S = (t)=>c(t, "__esModule", {
        value: !0
    });
var s = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var w = (t, r, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of j(r))!F.call(t, e) && e !== "default" && c(t, e, {
        get: ()=>r[e],
        enumerable: !(n = m(r, e)) || n.enumerable
    });
    return t;
}, A = (t)=>w(S(c(t != null ? h(x(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var y = s((G, f)=>{
    "use strict";
    var E = "Function.prototype.bind called on incompatible ", u = Array.prototype.slice, O = Object.prototype.toString, R = "[object Function]";
    f.exports = function(r) {
        var n = this;
        if (typeof n != "function" || O.call(n) !== R) throw new TypeError(E + n);
        for(var e = u.call(arguments, 1), o, d = function() {
            if (this instanceof o) {
                var a = n.apply(this, e.concat(u.call(arguments)));
                return Object(a) === a ? a : this;
            } else return n.apply(r, e.concat(u.call(arguments)));
        }, g = Math.max(0, n.length - e.length), l = [], i = 0; i < g; i++)l.push("$" + i);
        if (o = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(d), n.prototype) {
            var p = function() {};
            p.prototype = n.prototype, o.prototype = new p, p.prototype = null;
        }
        return o;
    };
});
var v = s((L, b)=>{
    "use strict";
    var M = y();
    b.exports = Function.prototype.bind || M;
});
var T = A(v());
var export_default = T.default;
var i = Object.create;
var o = Object.defineProperty;
var l = Object.getOwnPropertyDescriptor;
var p = Object.getOwnPropertyNames;
var s = Object.getPrototypeOf, u = Object.prototype.hasOwnProperty;
var b = (t)=>o(t, "__esModule", {
        value: !0
    });
var f = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var h = (t, r, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of p(r))!u.call(t, e) && e !== "default" && o(t, e, {
        get: ()=>r[e],
        enumerable: !(n = l(r, e)) || n.enumerable
    });
    return t;
}, x = (t)=>h(b(o(t != null ? i(s(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var c = f((m, a)=>{
    "use strict";
    var y = export_default;
    a.exports = y.call(Function.call, Object.prototype.hasOwnProperty);
});
var O = x(c());
var export_default = O.default;
var _ = Object.create;
var U = Object.defineProperty;
var C = Object.getOwnPropertyDescriptor;
var M = Object.getOwnPropertyNames;
var j = Object.getPrototypeOf, W = Object.prototype.hasOwnProperty;
var D = (e)=>U(e, "__esModule", {
        value: !0
    });
var $ = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var J = (e, t, n)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let o of M(t))!W.call(e, o) && o !== "default" && U(e, o, {
        get: ()=>t[o],
        enumerable: !(n = C(t, o)) || n.enumerable
    });
    return e;
}, V = (e)=>J(D(U(e != null ? _(j(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var k = $((er, T)=>{
    "use strict";
    var r, v = SyntaxError, B = Function, l = TypeError, x = function(e) {
        try {
            return B('"use strict"; return (' + e + ").constructor;")();
        } catch (t) {}
    }, f = Object.getOwnPropertyDescriptor;
    if (f) try {
        f({}, "");
    } catch (e) {
        f = null;
    }
    var N = function() {
        throw new l;
    }, q = f ? function() {
        try {
            return arguments.callee, N;
        } catch (e) {
            try {
                return f(arguments, "callee").get;
            } catch (t) {
                return N;
            }
        }
    }() : N, u = export_default(), c = Object.getPrototypeOf || function(e) {
        return e.__proto__;
    }, A = {}, z = typeof Uint8Array == "undefined" ? r : c(Uint8Array), d = {
        "%AggregateError%": typeof AggregateError == "undefined" ? r : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? r : ArrayBuffer,
        "%ArrayIteratorPrototype%": u ? c([][Symbol.iterator]()) : r,
        "%AsyncFromSyncIteratorPrototype%": r,
        "%AsyncFunction%": A,
        "%AsyncGenerator%": A,
        "%AsyncGeneratorFunction%": A,
        "%AsyncIteratorPrototype%": A,
        "%Atomics%": typeof Atomics == "undefined" ? r : Atomics,
        "%BigInt%": typeof BigInt == "undefined" ? r : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView == "undefined" ? r : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array == "undefined" ? r : Float32Array,
        "%Float64Array%": typeof Float64Array == "undefined" ? r : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? r : FinalizationRegistry,
        "%Function%": B,
        "%GeneratorFunction%": A,
        "%Int8Array%": typeof Int8Array == "undefined" ? r : Int8Array,
        "%Int16Array%": typeof Int16Array == "undefined" ? r : Int16Array,
        "%Int32Array%": typeof Int32Array == "undefined" ? r : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": u ? c(c([][Symbol.iterator]())) : r,
        "%JSON%": typeof JSON == "object" ? JSON : r,
        "%Map%": typeof Map == "undefined" ? r : Map,
        "%MapIteratorPrototype%": typeof Map == "undefined" || !u ? r : c(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise == "undefined" ? r : Promise,
        "%Proxy%": typeof Proxy == "undefined" ? r : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect == "undefined" ? r : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set == "undefined" ? r : Set,
        "%SetIteratorPrototype%": typeof Set == "undefined" || !u ? r : c(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? r : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": u ? c(""[Symbol.iterator]()) : r,
        "%Symbol%": u ? Symbol : r,
        "%SyntaxError%": v,
        "%ThrowTypeError%": q,
        "%TypedArray%": z,
        "%TypeError%": l,
        "%Uint8Array%": typeof Uint8Array == "undefined" ? r : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? r : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array == "undefined" ? r : Uint16Array,
        "%Uint32Array%": typeof Uint32Array == "undefined" ? r : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap == "undefined" ? r : WeakMap,
        "%WeakRef%": typeof WeakRef == "undefined" ? r : WeakRef,
        "%WeakSet%": typeof WeakSet == "undefined" ? r : WeakSet
    }, L = function e(t) {
        var n;
        if (t === "%AsyncFunction%") n = x("async function () {}");
        else if (t === "%GeneratorFunction%") n = x("function* () {}");
        else if (t === "%AsyncGeneratorFunction%") n = x("async function* () {}");
        else if (t === "%AsyncGenerator%") {
            var o = e("%AsyncGeneratorFunction%");
            o && (n = o.prototype);
        } else if (t === "%AsyncIteratorPrototype%") {
            var a = e("%AsyncGenerator%");
            a && (n = c(a.prototype));
        }
        return d[t] = n, n;
    }, O = {
        "%ArrayBufferPrototype%": [
            "ArrayBuffer",
            "prototype"
        ],
        "%ArrayPrototype%": [
            "Array",
            "prototype"
        ],
        "%ArrayProto_entries%": [
            "Array",
            "prototype",
            "entries"
        ],
        "%ArrayProto_forEach%": [
            "Array",
            "prototype",
            "forEach"
        ],
        "%ArrayProto_keys%": [
            "Array",
            "prototype",
            "keys"
        ],
        "%ArrayProto_values%": [
            "Array",
            "prototype",
            "values"
        ],
        "%AsyncFunctionPrototype%": [
            "AsyncFunction",
            "prototype"
        ],
        "%AsyncGenerator%": [
            "AsyncGeneratorFunction",
            "prototype"
        ],
        "%AsyncGeneratorPrototype%": [
            "AsyncGeneratorFunction",
            "prototype",
            "prototype"
        ],
        "%BooleanPrototype%": [
            "Boolean",
            "prototype"
        ],
        "%DataViewPrototype%": [
            "DataView",
            "prototype"
        ],
        "%DatePrototype%": [
            "Date",
            "prototype"
        ],
        "%ErrorPrototype%": [
            "Error",
            "prototype"
        ],
        "%EvalErrorPrototype%": [
            "EvalError",
            "prototype"
        ],
        "%Float32ArrayPrototype%": [
            "Float32Array",
            "prototype"
        ],
        "%Float64ArrayPrototype%": [
            "Float64Array",
            "prototype"
        ],
        "%FunctionPrototype%": [
            "Function",
            "prototype"
        ],
        "%Generator%": [
            "GeneratorFunction",
            "prototype"
        ],
        "%GeneratorPrototype%": [
            "GeneratorFunction",
            "prototype",
            "prototype"
        ],
        "%Int8ArrayPrototype%": [
            "Int8Array",
            "prototype"
        ],
        "%Int16ArrayPrototype%": [
            "Int16Array",
            "prototype"
        ],
        "%Int32ArrayPrototype%": [
            "Int32Array",
            "prototype"
        ],
        "%JSONParse%": [
            "JSON",
            "parse"
        ],
        "%JSONStringify%": [
            "JSON",
            "stringify"
        ],
        "%MapPrototype%": [
            "Map",
            "prototype"
        ],
        "%NumberPrototype%": [
            "Number",
            "prototype"
        ],
        "%ObjectPrototype%": [
            "Object",
            "prototype"
        ],
        "%ObjProto_toString%": [
            "Object",
            "prototype",
            "toString"
        ],
        "%ObjProto_valueOf%": [
            "Object",
            "prototype",
            "valueOf"
        ],
        "%PromisePrototype%": [
            "Promise",
            "prototype"
        ],
        "%PromiseProto_then%": [
            "Promise",
            "prototype",
            "then"
        ],
        "%Promise_all%": [
            "Promise",
            "all"
        ],
        "%Promise_reject%": [
            "Promise",
            "reject"
        ],
        "%Promise_resolve%": [
            "Promise",
            "resolve"
        ],
        "%RangeErrorPrototype%": [
            "RangeError",
            "prototype"
        ],
        "%ReferenceErrorPrototype%": [
            "ReferenceError",
            "prototype"
        ],
        "%RegExpPrototype%": [
            "RegExp",
            "prototype"
        ],
        "%SetPrototype%": [
            "Set",
            "prototype"
        ],
        "%SharedArrayBufferPrototype%": [
            "SharedArrayBuffer",
            "prototype"
        ],
        "%StringPrototype%": [
            "String",
            "prototype"
        ],
        "%SymbolPrototype%": [
            "Symbol",
            "prototype"
        ],
        "%SyntaxErrorPrototype%": [
            "SyntaxError",
            "prototype"
        ],
        "%TypedArrayPrototype%": [
            "TypedArray",
            "prototype"
        ],
        "%TypeErrorPrototype%": [
            "TypeError",
            "prototype"
        ],
        "%Uint8ArrayPrototype%": [
            "Uint8Array",
            "prototype"
        ],
        "%Uint8ClampedArrayPrototype%": [
            "Uint8ClampedArray",
            "prototype"
        ],
        "%Uint16ArrayPrototype%": [
            "Uint16Array",
            "prototype"
        ],
        "%Uint32ArrayPrototype%": [
            "Uint32Array",
            "prototype"
        ],
        "%URIErrorPrototype%": [
            "URIError",
            "prototype"
        ],
        "%WeakMapPrototype%": [
            "WeakMap",
            "prototype"
        ],
        "%WeakSetPrototype%": [
            "WeakSet",
            "prototype"
        ]
    }, I = export_default, F = export_default, Y = I.call(Function.call, Array.prototype.concat), H = I.call(Function.apply, Array.prototype.splice), G = I.call(Function.call, String.prototype.replace), b = I.call(Function.call, String.prototype.slice), K = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Q = /\\(\\)?/g, X = function(t) {
        var n = b(t, 0, 1), o = b(t, -1);
        if (n === "%" && o !== "%") throw new v("invalid intrinsic syntax, expected closing `%`");
        if (o === "%" && n !== "%") throw new v("invalid intrinsic syntax, expected opening `%`");
        var a = [];
        return G(t, K, function(i, s, y, g) {
            a[a.length] = y ? G(g, Q, "$1") : s || i;
        }), a;
    }, Z = function(t, n) {
        var o = t, a;
        if (F(O, o) && (a = O[o], o = "%" + a[0] + "%"), F(d, o)) {
            var i = d[o];
            if (i === A && (i = L(o)), typeof i == "undefined" && !n) throw new l("intrinsic " + t + " exists, but is not available. Please file an issue!");
            return {
                alias: a,
                name: o,
                value: i
            };
        }
        throw new v("intrinsic " + t + " does not exist!");
    };
    T.exports = function(t, n) {
        if (typeof t != "string" || t.length === 0) throw new l("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof n != "boolean") throw new l('"allowMissing" argument must be a boolean');
        var o = X(t), a = o.length > 0 ? o[0] : "", i = Z("%" + a + "%", n), s = i.name, y = i.value, g = !1, R = i.alias;
        R && (a = R[0], H(o, Y([
            0,
            1
        ], R)));
        for(var S = 1, P = !0; S < o.length; S += 1){
            var p = o[S], E = b(p, 0, 1), m = b(p, -1);
            if ((E === '"' || E === "'" || E === "`" || m === '"' || m === "'" || m === "`") && E !== m) throw new v("property names with quotes must have matching quotes");
            if ((p === "constructor" || !P) && (g = !0), a += "." + p, s = "%" + a + "%", F(d, s)) y = d[s];
            else if (y != null) {
                if (!(p in y)) {
                    if (!n) throw new l("base intrinsic for " + t + " exists, but the property is not available.");
                    return;
                }
                if (f && S + 1 >= o.length) {
                    var h = f(y, p);
                    P = !!h, P && "get" in h && !("originalValue" in h.get) ? y = h.get : y = y[p];
                } else P = F(y, p), y = y[p];
                P && !g && (d[s] = y);
            }
        }
        return y;
    };
});
var rr = V(k());
var export_default = rr.default;
var B = Object.create;
var p = Object.defineProperty;
var O = Object.getOwnPropertyDescriptor;
var m = Object.getOwnPropertyNames;
var q = Object.getPrototypeOf, P = Object.prototype.hasOwnProperty;
var I = (r)=>p(r, "__esModule", {
        value: !0
    });
var o = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var j = (r, t, n)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let e of m(t))!P.call(r, e) && e !== "default" && p(r, e, {
        get: ()=>t[e],
        enumerable: !(n = O(t, e)) || n.enumerable
    });
    return r;
}, D = (r)=>j(I(p(r != null ? B(q(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var g = o((M, l)=>{
    "use strict";
    var u = export_default, a = export_default, f = a("%Function.prototype.apply%"), s = a("%Function.prototype.call%"), v = a("%Reflect.apply%", !0) || u.call(s, f), y = a("%Object.getOwnPropertyDescriptor%", !0), i = a("%Object.defineProperty%", !0), F = a("%Math.max%");
    if (i) try {
        i({}, "a", {
            value: 1
        });
    } catch (r) {
        i = null;
    }
    l.exports = function(t) {
        var n = v(u, s, arguments);
        if (y && i) {
            var e = y(n, "length");
            e.configurable && i(n, "length", {
                value: 1 + F(0, t.length - (arguments.length - 1))
            });
        }
        return n;
    };
    var d = function() {
        return v(u, f, arguments);
    };
    i ? i(l.exports, "apply", {
        value: d
    }) : l.exports.apply = d;
});
var h = o((R, b)=>{
    "use strict";
    var x = export_default, $ = g(), G = $(x("String.prototype.indexOf"));
    b.exports = function(t, n) {
        var e = x(t, !!n);
        return typeof e == "function" && G(t, ".prototype.") > -1 ? $(e) : e;
    };
});
var w = D(h());
var export_default = w.default;
var m = Object.create;
var o = Object.defineProperty;
var f = Object.getOwnPropertyDescriptor;
var b = Object.getOwnPropertyNames;
var p = Object.getPrototypeOf, d = Object.prototype.hasOwnProperty;
var y = (r)=>o(r, "__esModule", {
        value: !0
    });
var A = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var S = (r, t, i)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let n of b(t))!d.call(r, n) && n !== "default" && o(r, n, {
        get: ()=>t[n],
        enumerable: !(i = f(t, n)) || i.enumerable
    });
    return r;
}, j = (r)=>S(y(o(r != null ? m(p(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var c = A((B, a)=>{
    "use strict";
    var l = export_default(), h = export_default, s = h("Object.prototype.toString"), e = function(t) {
        return l && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : s(t) === "[object Arguments]";
    }, u = function(t) {
        return e(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && s(t) !== "[object Array]" && s(t.callee) === "[object Function]";
    }, T = function() {
        return e(arguments);
    }();
    e.isLegacyArguments = u;
    a.exports = T ? e : u;
});
var q = j(c());
var export_default = q.default;
var s = Object.create;
var o = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var l = Object.getOwnPropertyNames;
var p = Object.getPrototypeOf, v = Object.prototype.hasOwnProperty;
var y = (t)=>o(t, "__esModule", {
        value: !0
    });
var S = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var h = (t, r, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of l(r))!v.call(t, e) && e !== "default" && o(t, e, {
        get: ()=>r[e],
        enumerable: !(n = g(r, e)) || n.enumerable
    });
    return t;
}, G = (t)=>h(y(o(t != null ? s(p(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var c = S((m, f)=>{
    "use strict";
    var b = Object.prototype.toString, d = Function.prototype.toString, j = /^\s*(?:function)?\*/, u = export_default(), i = Object.getPrototypeOf, x = function() {
        if (!u) return !1;
        try {
            return Function("return function*() {}")();
        } catch (t) {}
    }, a;
    f.exports = function(r) {
        if (typeof r != "function") return !1;
        if (j.test(d.call(r))) return !0;
        if (!u) {
            var n = b.call(r);
            return n === "[object GeneratorFunction]";
        }
        if (!i) return !1;
        if (typeof a == "undefined") {
            var e = x();
            a = e ? i(e) : !1;
        }
        return i(r) === a;
    };
});
var O = G(c());
var export_default = O.default;
var p = Object.create;
var s = Object.defineProperty;
var a = Object.getOwnPropertyDescriptor;
var g = Object.getOwnPropertyNames;
var l = Object.getPrototypeOf, u = Object.prototype.hasOwnProperty;
var O = (r)=>s(r, "__esModule", {
        value: !0
    });
var h = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var y = (r, t, c)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let e of g(t))!u.call(r, e) && e !== "default" && s(r, e, {
        get: ()=>t[e],
        enumerable: !(c = a(t, e)) || c.enumerable
    });
    return r;
}, D = (r)=>y(O(s(r != null ? p(l(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var o = h((w, n)=>{
    "use strict";
    var P = export_default, i = P("%Object.getOwnPropertyDescriptor%");
    if (i) try {
        i([], "length");
    } catch (r) {
        i = null;
    }
    n.exports = i;
});
var b = D(o());
var export_default = b.default;
var i = Object.create;
var n = Object.defineProperty;
var h = Object.getOwnPropertyDescriptor;
var s = Object.getOwnPropertyNames;
var u = Object.getPrototypeOf, v = Object.prototype.hasOwnProperty;
var w = (t)=>n(t, "__esModule", {
        value: !0
    });
var y = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var O = (t, r, a)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of s(r))!v.call(t, e) && e !== "default" && n(t, e, {
        get: ()=>r[e],
        enumerable: !(a = h(r, e)) || a.enumerable
    });
    return t;
}, g = (t)=>O(w(n(t != null ? i(u(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var p = y((x, f)=>{
    var m = Object.prototype.hasOwnProperty, E = Object.prototype.toString;
    f.exports = function(r, a, e) {
        if (E.call(a) !== "[object Function]") throw new TypeError("iterator must be a function");
        var l = r.length;
        if (l === +l) for(var o = 0; o < l; o++)a.call(e, r[o], o, r);
        else for(var c in r)m.call(r, c) && a.call(e, r[c], c, r);
    };
});
var S = g(p());
var export_default = S.default;
var __global$ = window;
var A = Object.create;
var y = Object.defineProperty;
var i = Object.getOwnPropertyDescriptor;
var s = Object.getOwnPropertyNames;
var f = Object.getPrototypeOf, p = Object.prototype.hasOwnProperty;
var u = (r)=>y(r, "__esModule", {
        value: !0
    });
var g = (r, a)=>()=>(a || r((a = {
            exports: {}
        }).exports, a), a.exports);
var v = (r, a, t)=>{
    if (a && typeof a == "object" || typeof a == "function") for (let n of s(a))!p.call(r, n) && n !== "default" && y(r, n, {
        get: ()=>a[n],
        enumerable: !(t = i(a, n)) || t.enumerable
    });
    return r;
}, U = (r)=>v(u(y(r != null ? A(f(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var o = g((I, l)=>{
    "use strict";
    var e = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
    ];
    l.exports = function() {
        for(var a = [], t = 0; t < e.length; t++)typeof __global$[e[t]] == "function" && (a[a.length] = e[t]);
        return a;
    };
});
var b = U(o());
var export_default = b.default;
var __global$ = window;
var S = Object.create;
var f = Object.defineProperty;
var b = Object.getOwnPropertyDescriptor;
var T = Object.getOwnPropertyNames;
var d = Object.getPrototypeOf, O = Object.prototype.hasOwnProperty;
var h = (r)=>f(r, "__esModule", {
        value: !0
    });
var m = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var A = (r, t, a)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let e of T(t))!O.call(r, e) && e !== "default" && f(r, e, {
        get: ()=>t[e],
        enumerable: !(a = b(t, e)) || a.enumerable
    });
    return r;
}, q = (r)=>A(h(f(r != null ? S(d(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var v = m((k, p)=>{
    "use strict";
    var g = export_default, x = export_default, y = export_default, P = y("Object.prototype.toString"), s = export_default(), c = x(), j = y("Array.prototype.indexOf", !0) || function(t, a) {
        for(var e = 0; e < t.length; e += 1)if (t[e] === a) return e;
        return -1;
    }, $ = y("String.prototype.slice"), u = {}, o = export_default, l = Object.getPrototypeOf;
    s && o && l && g(c, function(r) {
        var t = new __global$[r];
        if (Symbol.toStringTag in t) {
            var a = l(t), e = o(a, Symbol.toStringTag);
            if (!e) {
                var i = l(a);
                e = o(i, Symbol.toStringTag);
            }
            u[r] = e.get;
        }
    });
    var w = function(t) {
        var a = !1;
        return g(u, function(e, i) {
            if (!a) try {
                a = e.call(t) === i;
            } catch (D) {}
        }), a;
    };
    p.exports = function(t) {
        if (!t || typeof t != "object") return !1;
        if (!s || !(Symbol.toStringTag in t)) {
            var a = $(P(t), 8, -1);
            return j(c, a) > -1;
        }
        return o ? w(t) : !1;
    };
});
var B = q(v());
var export_default = B.default;
var __global$ = window;
var S = Object.create;
var n = Object.defineProperty;
var b = Object.getOwnPropertyDescriptor;
var T = Object.getOwnPropertyNames;
var h = Object.getPrototypeOf, d = Object.prototype.hasOwnProperty;
var m = (r)=>n(r, "__esModule", {
        value: !0
    });
var q = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var O = (r, t, e)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let a of T(t))!d.call(r, a) && a !== "default" && n(r, a, {
        get: ()=>t[a],
        enumerable: !(e = b(t, a)) || e.enumerable
    });
    return r;
}, A = (r)=>O(m(n(r != null ? S(h(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var p = q((k, v)=>{
    "use strict";
    var g = export_default, w = export_default, s = export_default, P = s("Object.prototype.toString"), c = export_default(), j = w(), x = s("String.prototype.slice"), u = {}, y = export_default, l = Object.getPrototypeOf;
    c && y && l && g(j, function(r) {
        if (typeof __global$[r] == "function") {
            var t = new __global$[r];
            if (Symbol.toStringTag in t) {
                var e = l(t), a = y(e, Symbol.toStringTag);
                if (!a) {
                    var o = l(e);
                    a = y(o, Symbol.toStringTag);
                }
                u[r] = a.get;
            }
        }
    });
    var B = function(t) {
        var e = !1;
        return g(u, function(a, o) {
            if (!e) try {
                var f = a.call(t);
                f === o && (e = f);
            } catch (E) {}
        }), e;
    }, D = export_default;
    v.exports = function(t) {
        return D(t) ? !c || !(Symbol.toStringTag in t) ? x(P(t), 8, -1) : B(t) : !1;
    };
});
var $ = A(p());
var export_default = $.default;
__default.env.NODE_ENV = "production";
var he = Object.create;
var C = Object.defineProperty;
var Ae = Object.getOwnPropertyDescriptor;
var we = Object.getOwnPropertyNames;
var Se = Object.getPrototypeOf, Oe = Object.prototype.hasOwnProperty;
var je = (e)=>C(e, "__esModule", {
        value: !0
    });
var R = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var Be = (e, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of we(r))!Oe.call(e, n) && n !== "default" && C(e, n, {
        get: ()=>r[n],
        enumerable: !(t = Ae(r, n)) || t.enumerable
    });
    return e;
}, x = (e)=>Be(je(C(e != null ? he(Se(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var ue = R((o)=>{
    "use strict";
    var ke = export_default, Pe = export_default, l = export_default, L = export_default;
    function b(e) {
        return e.call.bind(e);
    }
    var K = typeof BigInt != "undefined", Q = typeof Symbol != "undefined", y = b(Object.prototype.toString), Ee = b(Number.prototype.valueOf), De = b(String.prototype.valueOf), ve = b(Boolean.prototype.valueOf);
    K && (X = b(BigInt.prototype.valueOf));
    var X;
    Q && (Y = b(Symbol.prototype.valueOf));
    var Y;
    function w(e, r) {
        if (typeof e != "object") return !1;
        try {
            return r(e), !0;
        } catch (t) {
            return !1;
        }
    }
    o.isArgumentsObject = ke;
    o.isGeneratorFunction = Pe;
    o.isTypedArray = L;
    function Ue(e) {
        return typeof Promise != "undefined" && e instanceof Promise || e !== null && typeof e == "object" && typeof e.then == "function" && typeof e.catch == "function";
    }
    o.isPromise = Ue;
    function Me(e) {
        return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(e) : L(e) || re(e);
    }
    o.isArrayBufferView = Me;
    function Ie(e) {
        return l(e) === "Uint8Array";
    }
    o.isUint8Array = Ie;
    function Ne(e) {
        return l(e) === "Uint8ClampedArray";
    }
    o.isUint8ClampedArray = Ne;
    function ze(e) {
        return l(e) === "Uint16Array";
    }
    o.isUint16Array = ze;
    function Fe(e) {
        return l(e) === "Uint32Array";
    }
    o.isUint32Array = Fe;
    function Te(e) {
        return l(e) === "Int8Array";
    }
    o.isInt8Array = Te;
    function We(e) {
        return l(e) === "Int16Array";
    }
    o.isInt16Array = We;
    function Ce(e) {
        return l(e) === "Int32Array";
    }
    o.isInt32Array = Ce;
    function Re(e) {
        return l(e) === "Float32Array";
    }
    o.isFloat32Array = Re;
    function Ve(e) {
        return l(e) === "Float64Array";
    }
    o.isFloat64Array = Ve;
    function _e(e) {
        return l(e) === "BigInt64Array";
    }
    o.isBigInt64Array = _e;
    function $e(e) {
        return l(e) === "BigUint64Array";
    }
    o.isBigUint64Array = $e;
    function k(e) {
        return y(e) === "[object Map]";
    }
    k.working = typeof Map != "undefined" && k(new Map);
    function Ge(e) {
        return typeof Map == "undefined" ? !1 : k.working ? k(e) : e instanceof Map;
    }
    o.isMap = Ge;
    function P(e) {
        return y(e) === "[object Set]";
    }
    P.working = typeof Set != "undefined" && P(new Set);
    function qe(e) {
        return typeof Set == "undefined" ? !1 : P.working ? P(e) : e instanceof Set;
    }
    o.isSet = qe;
    function E(e) {
        return y(e) === "[object WeakMap]";
    }
    E.working = typeof WeakMap != "undefined" && E(new WeakMap);
    function He(e) {
        return typeof WeakMap == "undefined" ? !1 : E.working ? E(e) : e instanceof WeakMap;
    }
    o.isWeakMap = He;
    function V(e) {
        return y(e) === "[object WeakSet]";
    }
    V.working = typeof WeakSet != "undefined" && V(new WeakSet);
    function Je(e) {
        return V(e);
    }
    o.isWeakSet = Je;
    function D(e) {
        return y(e) === "[object ArrayBuffer]";
    }
    D.working = typeof ArrayBuffer != "undefined" && D(new ArrayBuffer);
    function ee(e) {
        return typeof ArrayBuffer == "undefined" ? !1 : D.working ? D(e) : e instanceof ArrayBuffer;
    }
    o.isArrayBuffer = ee;
    function v(e) {
        return y(e) === "[object DataView]";
    }
    v.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && v(new DataView(new ArrayBuffer(1), 0, 1));
    function re(e) {
        return typeof DataView == "undefined" ? !1 : v.working ? v(e) : e instanceof DataView;
    }
    o.isDataView = re;
    var _ = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;
    function S(e) {
        return y(e) === "[object SharedArrayBuffer]";
    }
    function te(e) {
        return typeof _ == "undefined" ? !1 : (typeof S.working == "undefined" && (S.working = S(new _)), S.working ? S(e) : e instanceof _);
    }
    o.isSharedArrayBuffer = te;
    function Ze(e) {
        return y(e) === "[object AsyncFunction]";
    }
    o.isAsyncFunction = Ze;
    function xe(e) {
        return y(e) === "[object Map Iterator]";
    }
    o.isMapIterator = xe;
    function Le(e) {
        return y(e) === "[object Set Iterator]";
    }
    o.isSetIterator = Le;
    function Ke(e) {
        return y(e) === "[object Generator]";
    }
    o.isGeneratorObject = Ke;
    function Qe(e) {
        return y(e) === "[object WebAssembly.Module]";
    }
    o.isWebAssemblyCompiledModule = Qe;
    function ne(e) {
        return w(e, Ee);
    }
    o.isNumberObject = ne;
    function ie(e) {
        return w(e, De);
    }
    o.isStringObject = ie;
    function oe(e) {
        return w(e, ve);
    }
    o.isBooleanObject = oe;
    function fe(e) {
        return K && w(e, X);
    }
    o.isBigIntObject = fe;
    function se(e) {
        return Q && w(e, Y);
    }
    o.isSymbolObject = se;
    function Xe(e) {
        return ne(e) || ie(e) || oe(e) || fe(e) || se(e);
    }
    o.isBoxedPrimitive = Xe;
    function Ye(e) {
        return typeof Uint8Array != "undefined" && (ee(e) || te(e));
    }
    o.isAnyArrayBuffer = Ye;
    [
        "isProxy",
        "isExternal",
        "isModuleNamespaceObject"
    ].forEach(function(e) {
        Object.defineProperty(o, e, {
            enumerable: !1,
            value: function() {
                throw new Error(e + " is not supported in userland");
            }
        });
    });
});
var ce = R((hr, ae)=>{
    ae.exports = function(r) {
        return r && typeof r == "object" && typeof r.copy == "function" && typeof r.fill == "function" && typeof r.readUInt8 == "function";
    };
});
var Z = R((f)=>{
    var pe = Object.getOwnPropertyDescriptors || function(r) {
        for(var t = Object.keys(r), n = {}, u = 0; u < t.length; u++)n[t[u]] = Object.getOwnPropertyDescriptor(r, t[u]);
        return n;
    }, er = /%[sdj%]/g;
    f.format = function(e) {
        if (!z(e)) {
            for(var r = [], t = 0; t < arguments.length; t++)r.push(d(arguments[t]));
            return r.join(" ");
        }
        for(var t = 1, n = arguments, u = n.length, a = String(e).replace(er, function(s) {
            if (s === "%%") return "%";
            if (t >= u) return s;
            switch(s){
                case "%s":
                    return String(n[t++]);
                case "%d":
                    return Number(n[t++]);
                case "%j":
                    try {
                        return JSON.stringify(n[t++]);
                    } catch (c) {
                        return "[Circular]";
                    }
                default:
                    return s;
            }
        }), i = n[t]; t < u; i = n[++t])N(i) || !h(i) ? a += " " + i : a += " " + d(i);
        return a;
    };
    f.deprecate = function(e, r) {
        if (typeof __default != "undefined" && __default.noDeprecation === !0) return e;
        if (typeof __default == "undefined") return function() {
            return f.deprecate(e, r).apply(this, arguments);
        };
        var t = !1;
        function n() {
            if (!t) {
                if (__default.throwDeprecation) throw new Error(r);
                __default.traceDeprecation ? console.trace(r) : console.error(r), t = !0;
            }
            return e.apply(this, arguments);
        }
        return n;
    };
    var U = {}, ye = /^$/;
    __default.env.NODE_DEBUG && (M = __default.env.NODE_DEBUG, M = M.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ye = new RegExp("^" + M + "$", "i"));
    var M;
    f.debuglog = function(e) {
        if (e = e.toUpperCase(), !U[e]) if (ye.test(e)) {
            var r = __default.pid;
            U[e] = function() {
                var t = f.format.apply(f, arguments);
                console.error("%s %d: %s", e, r, t);
            };
        } else U[e] = function() {};
        return U[e];
    };
    function d(e, r) {
        var t = {
            seen: [],
            stylize: tr
        };
        return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), q(r) ? t.showHidden = r : r && f._extend(t, r), g(t.showHidden) && (t.showHidden = !1), g(t.depth) && (t.depth = 2), g(t.colors) && (t.colors = !1), g(t.customInspect) && (t.customInspect = !0), t.colors && (t.stylize = rr), I(t, e, t.depth);
    }
    f.inspect = d;
    d.colors = {
        bold: [
            1,
            22
        ],
        italic: [
            3,
            23
        ],
        underline: [
            4,
            24
        ],
        inverse: [
            7,
            27
        ],
        white: [
            37,
            39
        ],
        grey: [
            90,
            39
        ],
        black: [
            30,
            39
        ],
        blue: [
            34,
            39
        ],
        cyan: [
            36,
            39
        ],
        green: [
            32,
            39
        ],
        magenta: [
            35,
            39
        ],
        red: [
            31,
            39
        ],
        yellow: [
            33,
            39
        ]
    };
    d.styles = {
        special: "cyan",
        number: "yellow",
        boolean: "yellow",
        undefined: "grey",
        null: "bold",
        string: "green",
        date: "magenta",
        regexp: "red"
    };
    function rr(e, r) {
        var t = d.styles[r];
        return t ? "[" + d.colors[t][0] + "m" + e + "[" + d.colors[t][1] + "m" : e;
    }
    function tr(e, r) {
        return e;
    }
    function nr(e) {
        var r = {};
        return e.forEach(function(t, n) {
            r[t] = !0;
        }), r;
    }
    function I(e, r, t) {
        if (e.customInspect && r && T(r.inspect) && r.inspect !== f.inspect && !(r.constructor && r.constructor.prototype === r)) {
            var n = r.inspect(t, e);
            return z(n) || (n = I(e, n, t)), n;
        }
        var u = ir(e, r);
        if (u) return u;
        var a = Object.keys(r), i = nr(a);
        if (e.showHidden && (a = Object.getOwnPropertyNames(r)), j(r) && (a.indexOf("message") >= 0 || a.indexOf("description") >= 0)) return $(r);
        if (a.length === 0) {
            if (T(r)) {
                var s = r.name ? ": " + r.name : "";
                return e.stylize("[Function" + s + "]", "special");
            }
            if (O(r)) return e.stylize(RegExp.prototype.toString.call(r), "regexp");
            if (F(r)) return e.stylize(Date.prototype.toString.call(r), "date");
            if (j(r)) return $(r);
        }
        var c = "", p = !1, B = [
            "{",
            "}"
        ];
        if (le(r) && (p = !0, B = [
            "[",
            "]"
        ]), T(r)) {
            var me = r.name ? ": " + r.name : "";
            c = " [Function" + me + "]";
        }
        if (O(r) && (c = " " + RegExp.prototype.toString.call(r)), F(r) && (c = " " + Date.prototype.toUTCString.call(r)), j(r) && (c = " " + $(r)), a.length === 0 && (!p || r.length == 0)) return B[0] + c + B[1];
        if (t < 0) return O(r) ? e.stylize(RegExp.prototype.toString.call(r), "regexp") : e.stylize("[Object]", "special");
        e.seen.push(r);
        var W;
        return p ? W = or(e, r, t, i, a) : W = a.map(function(be) {
            return G(e, r, t, i, be, p);
        }), e.seen.pop(), fr(W, c, B);
    }
    function ir(e, r) {
        if (g(r)) return e.stylize("undefined", "undefined");
        if (z(r)) {
            var t = "'" + JSON.stringify(r).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e.stylize(t, "string");
        }
        if (de(r)) return e.stylize("" + r, "number");
        if (q(r)) return e.stylize("" + r, "boolean");
        if (N(r)) return e.stylize("null", "null");
    }
    function $(e) {
        return "[" + Error.prototype.toString.call(e) + "]";
    }
    function or(e, r, t, n, u) {
        for(var a = [], i = 0, s = r.length; i < s; ++i)ge(r, String(i)) ? a.push(G(e, r, t, n, String(i), !0)) : a.push("");
        return u.forEach(function(c) {
            c.match(/^\d+$/) || a.push(G(e, r, t, n, c, !0));
        }), a;
    }
    function G(e, r, t, n, u, a) {
        var i, s, c;
        if (c = Object.getOwnPropertyDescriptor(r, u) || {
            value: r[u]
        }, c.get ? c.set ? s = e.stylize("[Getter/Setter]", "special") : s = e.stylize("[Getter]", "special") : c.set && (s = e.stylize("[Setter]", "special")), ge(n, u) || (i = "[" + u + "]"), s || (e.seen.indexOf(c.value) < 0 ? (N(t) ? s = I(e, c.value, null) : s = I(e, c.value, t - 1), s.indexOf(`
`) > -1 && (a ? s = s.split(`
`).map(function(p) {
            return "  " + p;
        }).join(`
`).substr(2) : s = `
` + s.split(`
`).map(function(p) {
            return "   " + p;
        }).join(`
`))) : s = e.stylize("[Circular]", "special")), g(i)) {
            if (a && u.match(/^\d+$/)) return s;
            i = JSON.stringify("" + u), i.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (i = i.substr(1, i.length - 2), i = e.stylize(i, "name")) : (i = i.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), i = e.stylize(i, "string"));
        }
        return i + ": " + s;
    }
    function fr(e, r, t) {
        var n = 0, u = e.reduce(function(a, i) {
            return n++, i.indexOf(`
`) >= 0 && n++, a + i.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        return u > 60 ? t[0] + (r === "" ? "" : r + `
 `) + " " + e.join(`,
  `) + " " + t[1] : t[0] + r + " " + e.join(", ") + " " + t[1];
    }
    f.types = ue();
    function le(e) {
        return Array.isArray(e);
    }
    f.isArray = le;
    function q(e) {
        return typeof e == "boolean";
    }
    f.isBoolean = q;
    function N(e) {
        return e === null;
    }
    f.isNull = N;
    function sr(e) {
        return e == null;
    }
    f.isNullOrUndefined = sr;
    function de(e) {
        return typeof e == "number";
    }
    f.isNumber = de;
    function z(e) {
        return typeof e == "string";
    }
    f.isString = z;
    function ur(e) {
        return typeof e == "symbol";
    }
    f.isSymbol = ur;
    function g(e) {
        return e === void 0;
    }
    f.isUndefined = g;
    function O(e) {
        return h(e) && H(e) === "[object RegExp]";
    }
    f.isRegExp = O;
    f.types.isRegExp = O;
    function h(e) {
        return typeof e == "object" && e !== null;
    }
    f.isObject = h;
    function F(e) {
        return h(e) && H(e) === "[object Date]";
    }
    f.isDate = F;
    f.types.isDate = F;
    function j(e) {
        return h(e) && (H(e) === "[object Error]" || e instanceof Error);
    }
    f.isError = j;
    f.types.isNativeError = j;
    function T(e) {
        return typeof e == "function";
    }
    f.isFunction = T;
    function ar(e) {
        return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || typeof e == "undefined";
    }
    f.isPrimitive = ar;
    f.isBuffer = ce();
    function H(e) {
        return Object.prototype.toString.call(e);
    }
    function J(e) {
        return e < 10 ? "0" + e.toString(10) : e.toString(10);
    }
    var cr = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ];
    function pr() {
        var e = new Date, r = [
            J(e.getHours()),
            J(e.getMinutes()),
            J(e.getSeconds())
        ].join(":");
        return [
            e.getDate(),
            cr[e.getMonth()],
            r
        ].join(" ");
    }
    f.log = function() {
        console.log("%s - %s", pr(), f.format.apply(f, arguments));
    };
    f.inherits = export_default;
    f._extend = function(e, r) {
        if (!r || !h(r)) return e;
        for(var t = Object.keys(r), n = t.length; n--;)e[t[n]] = r[t[n]];
        return e;
    };
    function ge(e, r) {
        return Object.prototype.hasOwnProperty.call(e, r);
    }
    var m = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
    f.promisify = function(r) {
        if (typeof r != "function") throw new TypeError('The "original" argument must be of type Function');
        if (m && r[m]) {
            var t = r[m];
            if (typeof t != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(t, m, {
                value: t,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }), t;
        }
        function t() {
            for(var n, u, a = new Promise(function(c, p) {
                n = c, u = p;
            }), i = [], s = 0; s < arguments.length; s++)i.push(arguments[s]);
            i.push(function(c, p) {
                c ? u(c) : n(p);
            });
            try {
                r.apply(this, i);
            } catch (c) {
                u(c);
            }
            return a;
        }
        return Object.setPrototypeOf(t, Object.getPrototypeOf(r)), m && Object.defineProperty(t, m, {
            value: t,
            enumerable: !1,
            writable: !1,
            configurable: !0
        }), Object.defineProperties(t, pe(r));
    };
    f.promisify.custom = m;
    function yr(e, r) {
        if (!e) {
            var t = new Error("Promise was rejected with a falsy value");
            t.reason = e, e = t;
        }
        return r(e);
    }
    function lr(e) {
        if (typeof e != "function") throw new TypeError('The "original" argument must be of type Function');
        function r() {
            for(var t = [], n = 0; n < arguments.length; n++)t.push(arguments[n]);
            var u = t.pop();
            if (typeof u != "function") throw new TypeError("The last argument must be of type Function");
            var a = this, i = function() {
                return u.apply(a, arguments);
            };
            e.apply(this, t).then(function(s) {
                __default.nextTick(i.bind(null, null, s));
            }, function(s) {
                __default.nextTick(yr.bind(null, s, i));
            });
        }
        return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), Object.defineProperties(r, pe(e)), r;
    }
    f.callbackify = lr;
});
var dr = x(Z()), gr = x(Z()), { format: wr , deprecate: Sr , debuglog: Or , inspect: jr , types: Br , isArray: kr , isBoolean: Pr , isNull: Er , isNullOrUndefined: Dr , isNumber: vr , isString: Ur , isSymbol: Mr , isUndefined: Ir , isRegExp: Nr , isObject: zr , isDate: Fr , isError: Tr , isFunction: Wr , isPrimitive: Cr , isBuffer: Rr , log: Vr , inherits: _r , _extend: $r , promisify: Gr , callbackify: qr  } = dr;
var export_default = gr.default;
var __global$ = window;
var c = Object.create;
var o = Object.defineProperty;
var f = Object.getOwnPropertyDescriptor;
var u = Object.getOwnPropertyNames;
var p = Object.getPrototypeOf, d = Object.prototype.hasOwnProperty;
var g = (e)=>o(e, "__esModule", {
        value: !0
    });
var b = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var m = (e, r, i)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of u(r))!d.call(e, t) && t !== "default" && o(e, t, {
        get: ()=>r[t],
        enumerable: !(i = f(r, t)) || i.enumerable
    });
    return e;
}, l = (e)=>m(g(o(e != null ? c(p(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var n = b((S, s)=>{
    s.exports = y;
    function y(e, r) {
        if (a("noDeprecation")) return e;
        var i = !1;
        function t() {
            if (!i) {
                if (a("throwDeprecation")) throw new Error(r);
                a("traceDeprecation") ? console.trace(r) : console.warn(r), i = !0;
            }
            return e.apply(this, arguments);
        }
        return t;
    }
    function a(e) {
        try {
            if (!__global$.localStorage) return !1;
        } catch (i) {
            return !1;
        }
        var r = __global$.localStorage[e];
        return r == null ? !1 : String(r).toLowerCase() === "true";
    }
});
var w = l(n()), h = l(n()), { format: v , deprecate: D , debuglog: _ , inspect: E , types: N , isArray: B , isBoolean: O , isNull: U , isNullOrUndefined: j , isNumber: k , isString: A , isSymbol: C , isUndefined: F , isRegExp: L , isObject: P , isDate: R , isError: q , isFunction: z , isPrimitive: G , isBuffer: H , log: I , inherits: J , _extend: K , promisify: M , callbackify: Q  } = w;
var export_default = h.default;
var f = Object.create;
var n = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var N = Object.getOwnPropertyNames;
var x = Object.getPrototypeOf, C = Object.prototype.hasOwnProperty;
var p = (t)=>n(t, "__esModule", {
        value: !0
    });
var w = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var S = (t, e, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let s of N(e))!C.call(t, s) && s !== "default" && n(t, s, {
        get: ()=>e[s],
        enumerable: !(r = g(e, s)) || r.enumerable
    });
    return t;
}, c = (t)=>S(p(n(t != null ? f(x(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var o = w((u)=>{
    "use strict";
    var l = export_default.Buffer, d = l.isEncoding || function(t) {
        switch(t = "" + t, t && t.toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
                return !0;
            default:
                return !1;
        }
    };
    function T(t) {
        if (!t) return "utf8";
        for(var e;;)switch(t){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return t;
            default:
                if (e) return;
                t = ("" + t).toLowerCase(), e = !0;
        }
    }
    function E(t) {
        var e = T(t);
        if (typeof e != "string" && (l.isEncoding === d || !d(t))) throw new Error("Unknown encoding: " + t);
        return e || t;
    }
    u.StringDecoder = a;
    function a(t) {
        this.encoding = E(t);
        var e;
        switch(this.encoding){
            case "utf16le":
                this.text = D, this.end = _, e = 4;
                break;
            case "utf8":
                this.fillLast = k, e = 4;
                break;
            case "base64":
                this.text = F, this.end = z, e = 3;
                break;
            default:
                this.write = U, this.end = j;
                return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = l.allocUnsafe(e);
    }
    a.prototype.write = function(t) {
        if (t.length === 0) return "";
        var e, r;
        if (this.lastNeed) {
            if (e = this.fillLast(t), e === void 0) return "";
            r = this.lastNeed, this.lastNeed = 0;
        } else r = 0;
        return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    a.prototype.end = B;
    a.prototype.text = L;
    a.prototype.fillLast = function(t) {
        if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function h(t) {
        return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2;
    }
    function y(t, e, r) {
        var s = e.length - 1;
        if (s < r) return 0;
        var i = h(e[s]);
        return i >= 0 ? (i > 0 && (t.lastNeed = i - 1), i) : --s < r || i === -2 ? 0 : (i = h(e[s]), i >= 0 ? (i > 0 && (t.lastNeed = i - 2), i) : --s < r || i === -2 ? 0 : (i = h(e[s]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : t.lastNeed = i - 3), i) : 0));
    }
    function m(t, e, r) {
        if ((e[0] & 192) != 128) return t.lastNeed = 0, "\uFFFD";
        if (t.lastNeed > 1 && e.length > 1) {
            if ((e[1] & 192) != 128) return t.lastNeed = 1, "\uFFFD";
            if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) != 128) return t.lastNeed = 2, "\uFFFD";
        }
    }
    function k(t) {
        var e = this.lastTotal - this.lastNeed, r = m(this, t, e);
        if (r !== void 0) return r;
        if (this.lastNeed <= t.length) return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function L(t, e) {
        var r = y(this, t, e);
        if (!this.lastNeed) return t.toString("utf8", e);
        this.lastTotal = r;
        var s = t.length - (r - this.lastNeed);
        return t.copy(this.lastChar, 0, s), t.toString("utf8", e, s);
    }
    function B(t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + "\uFFFD" : e;
    }
    function D(t, e) {
        if ((t.length - e) % 2 == 0) {
            var r = t.toString("utf16le", e);
            if (r) {
                var s = r.charCodeAt(r.length - 1);
                if (s >= 55296 && s <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
            }
            return r;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function _(t) {
        var e = t && t.length ? this.write(t) : "";
        if (this.lastNeed) {
            var r = this.lastTotal - this.lastNeed;
            return e + this.lastChar.toString("utf16le", 0, r);
        }
        return e;
    }
    function F(t, e) {
        var r = (t.length - e) % 3;
        return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function z(t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function U(t) {
        return t.toString(this.encoding);
    }
    function j(t) {
        return t && t.length ? this.write(t) : "";
    }
});
var q = c(o()), A = c(o()), { StringDecoder: G  } = q;
var export_default = A.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var mt = Object.create;
var fe = Object.defineProperty;
var Mt = Object.getOwnPropertyDescriptor;
var At = Object.getOwnPropertyNames;
var Ot = Object.getPrototypeOf, Lt = Object.prototype.hasOwnProperty;
var Dt = (e)=>fe(e, "__esModule", {
        value: !0
    });
var c = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var qt = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of At(t))!Lt.call(e, i) && i !== "default" && fe(e, i, {
        get: ()=>t[i],
        enumerable: !(r = Mt(t, i)) || r.enumerable
    });
    return e;
}, qe = (e)=>qt(Dt(fe(e != null ? mt(Ot(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var oe = c((vi, Pe)=>{
    Pe.exports = export_default.EventEmitter;
});
var je = c((wi, Ce)=>{
    "use strict";
    function Ne(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function Pt(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Ne(Object(r), !0).forEach(function(i) {
                Nt(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ne(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function Nt(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function xt(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function xe(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function Ct(e, t, r) {
        return t && xe(e.prototype, t), r && xe(e, r), e;
    }
    var jt = export_default, Y = jt.Buffer, It = export_default, le = It.inspect, kt = le && le.custom || "inspect";
    function Wt(e, t, r) {
        Y.prototype.copy.call(e, t, r);
    }
    Ce.exports = function() {
        function e() {
            xt(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return Ct(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return Y.alloc(0);
                    for(var i = Y.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)Wt(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, o = r > f.length ? f.length : r;
                        if (o === f.length ? a += f : a += f.slice(0, r), r -= o, r === 0) {
                            o === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(o));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = Y.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, o = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, o), r -= o, r === 0) {
                            o === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(o));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: kt,
                value: function(r, i) {
                    return le(this, Pt({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var se = c((Ri, ke)=>{
    "use strict";
    function Ut(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __default.nextTick(ue, this, e)) : __default.nextTick(ue, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? __default.nextTick(K, r) : (r._writableState.errorEmitted = !0, __default.nextTick(Ie, r, a)) : __default.nextTick(Ie, r, a) : t ? (__default.nextTick(K, r), t(a)) : __default.nextTick(K, r);
        }), this);
    }
    function Ie(e, t) {
        ue(e, t), K(e);
    }
    function K(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Bt() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function ue(e, t) {
        e.emit("error", t);
    }
    function Ft(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    ke.exports = {
        destroy: Ut,
        undestroy: Bt,
        errorOrDestroy: Ft
    };
});
var O = c((Ei, Be)=>{
    "use strict";
    function Ht(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var We = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, o) {
            return typeof t == "string" ? t : t(a, f, o);
        }
        var n = function(a) {
            Ht(f, a);
            function f(o, d, p) {
                return a.call(this, i(o, d, p)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, We[e] = n;
    }
    function Ue(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function Gt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Vt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Yt(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && Gt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (Vt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(Ue(t, "type"));
        else {
            var a = Yt(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(Ue(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Be.exports.codes = We;
});
var de = c((Si, Fe)=>{
    "use strict";
    var Kt = O().codes.ERR_INVALID_OPT_VALUE;
    function $t(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Xt(e, t, r, i) {
        var n = $t(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new Kt(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    Fe.exports = {
        getHighWaterMark: Xt
    };
});
var pe = c((Ti, $e)=>{
    "use strict";
    $e.exports = s;
    function He(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            Er(t, e);
        };
    }
    var C;
    s.WritableState = U;
    var zt = {
        deprecate: export_default
    }, Ge = oe(), $ = export_default.Buffer, Jt = __global$.Uint8Array || function() {};
    function Qt(e) {
        return $.from(e);
    }
    function Zt(e) {
        return $.isBuffer(e) || e instanceof Jt;
    }
    var he = se(), er = de(), tr = er.getHighWaterMark, S = O().codes, rr = S.ERR_INVALID_ARG_TYPE, ir = S.ERR_METHOD_NOT_IMPLEMENTED, nr = S.ERR_MULTIPLE_CALLBACK, ar = S.ERR_STREAM_CANNOT_PIPE, fr = S.ERR_STREAM_DESTROYED, or = S.ERR_STREAM_NULL_VALUES, lr = S.ERR_STREAM_WRITE_AFTER_END, ur = S.ERR_UNKNOWN_ENCODING, j = he.errorOrDestroy;
    export_default(s, Ge);
    function sr() {}
    function U(e, t, r) {
        C = C || L(), e = e || {}, typeof r != "boolean" && (r = t instanceof C), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = tr(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            gr(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new He(this);
    }
    U.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(U.prototype, "buffer", {
                get: zt.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var X;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (X = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return X.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof U;
        }
    })) : X = function(t) {
        return t instanceof this;
    };
    function s(e) {
        C = C || L();
        var t = this instanceof C;
        if (!t && !X.call(s, this)) return new s(e);
        this._writableState = new U(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), Ge.call(this);
    }
    s.prototype.pipe = function() {
        j(this, new ar);
    };
    function dr(e, t) {
        var r = new lr;
        j(e, r), __default.nextTick(t, r);
    }
    function hr(e, t, r, i) {
        var n;
        return r === null ? n = new or : typeof r != "string" && !t.objectMode && (n = new rr("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (j(e, n), __default.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && Zt(e);
        return a && !$.isBuffer(e) && (e = Qt(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = sr), i.ending ? dr(this, r) : (a || hr(this, i, e, r)) && (i.pendingcb++, n = pr(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Ye(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new ur(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function cr(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = $.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function pr(e, t, r, i, n, a) {
        if (!r) {
            var f = cr(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var o = t.objectMode ? 1 : i.length;
        t.length += o;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var p = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, p ? p.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else ce(e, t, !1, o, i, n, a);
        return d;
    }
    function ce(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new fr("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function br(e, t, r, i, n) {
        --t.pendingcb, r ? (__default.nextTick(n, i), __default.nextTick(B, e, t), e._writableState.errorEmitted = !0, j(e, i)) : (n(i), e._writableState.errorEmitted = !0, j(e, i), B(e, t));
    }
    function _r(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function gr(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new nr;
        if (_r(r), t) br(e, r, i, t, n);
        else {
            var a = Ke(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ye(e, r), i ? __default.nextTick(Ve, e, r, a, n) : Ve(e, r, a, n);
        }
    }
    function Ve(e, t, r, i) {
        r || yr(e, t), t.pendingcb--, i(), B(e, t);
    }
    function yr(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function Ye(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, o = !0; r;)n[f] = r, r.isBuf || (o = !1), r = r.next, f += 1;
            n.allBuffers = o, ce(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new He(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, p = r.encoding, v = r.callback, w = t.objectMode ? 1 : d.length;
                if (ce(e, t, !1, w, d, p, v), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new ir("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || Rr(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function Ke(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function vr(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && j(e, r), t.prefinished = !0, e.emit("prefinish"), B(e, t);
        });
    }
    function wr(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, __default.nextTick(vr, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function B(e, t) {
        var r = Ke(t);
        if (r && (wr(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function Rr(e, t, r) {
        t.ending = !0, B(e, t), r && (t.finished ? __default.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function Er(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = he.destroy;
    s.prototype._undestroy = he.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var L = c((mi, ze)=>{
    "use strict";
    var Sr = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    ze.exports = y;
    var Xe = ge(), be = pe();
    export_default(y, Xe);
    for(_e = Sr(be.prototype), z = 0; z < _e.length; z++)J = _e[z], y.prototype[J] || (y.prototype[J] = be.prototype[J]);
    var _e, J, z;
    function y(e) {
        if (!(this instanceof y)) return new y(e);
        Xe.call(this, e), be.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", Tr)));
    }
    Object.defineProperty(y.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(y.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(y.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function Tr() {
        this._writableState.ended || __default.nextTick(mr, this);
    }
    function mr(e) {
        e.end();
    }
    Object.defineProperty(y.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var Q = c((Mi, Ze)=>{
    "use strict";
    var Je = O().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Mr(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function Ar() {}
    function Or(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function Qe(e, t, r) {
        if (typeof t == "function") return Qe(e, null, t);
        t || (t = {}), r = Mr(r || Ar);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || o();
        }, f = e._writableState && e._writableState.finished, o = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, p = function() {
            i = !1, d = !0, n || r.call(e);
        }, v = function(g) {
            r.call(e, g);
        }, w = function() {
            var g;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (g = new Je), r.call(e, g);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (g = new Je), r.call(e, g);
        }, A = function() {
            e.req.on("finish", o);
        };
        return Or(e) ? (e.on("complete", o), e.on("abort", w), e.req ? A() : e.on("request", A)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", p), e.on("finish", o), t.error !== !1 && e.on("error", v), e.on("close", w), function() {
            e.removeListener("complete", o), e.removeListener("abort", w), e.removeListener("request", A), e.req && e.req.removeListener("finish", o), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", o), e.removeListener("end", p), e.removeListener("error", v), e.removeListener("close", w);
        };
    }
    Ze.exports = Qe;
});
var tt = c((Ai, et)=>{
    "use strict";
    var Z;
    function T(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var Lr = Q(), m = Symbol("lastResolve"), D = Symbol("lastReject"), F = Symbol("error"), ee = Symbol("ended"), q = Symbol("lastPromise"), ye = Symbol("handlePromise"), P = Symbol("stream");
    function M(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function Dr(e) {
        var t = e[m];
        if (t !== null) {
            var r = e[P].read();
            r !== null && (e[q] = null, e[m] = null, e[D] = null, t(M(r, !1)));
        }
    }
    function qr(e) {
        __default.nextTick(Dr, e);
    }
    function Pr(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[ee]) {
                    r(M(void 0, !0));
                    return;
                }
                t[ye](r, i);
            }, i);
        };
    }
    var Nr = Object.getPrototypeOf(function() {}), xr = Object.setPrototypeOf((Z = {
        get stream () {
            return this[P];
        },
        next: function() {
            var t = this, r = this[F];
            if (r !== null) return Promise.reject(r);
            if (this[ee]) return Promise.resolve(M(void 0, !0));
            if (this[P].destroyed) return new Promise(function(f, o) {
                __default.nextTick(function() {
                    t[F] ? o(t[F]) : f(M(void 0, !0));
                });
            });
            var i = this[q], n;
            if (i) n = new Promise(Pr(i, this));
            else {
                var a = this[P].read();
                if (a !== null) return Promise.resolve(M(a, !1));
                n = new Promise(this[ye]);
            }
            return this[q] = n, n;
        }
    }, T(Z, Symbol.asyncIterator, function() {
        return this;
    }), T(Z, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[P].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(M(void 0, !0));
            });
        });
    }), Z), Nr), Cr = function(t) {
        var r, i = Object.create(xr, (r = {}, T(r, P, {
            value: t,
            writable: !0
        }), T(r, m, {
            value: null,
            writable: !0
        }), T(r, D, {
            value: null,
            writable: !0
        }), T(r, F, {
            value: null,
            writable: !0
        }), T(r, ee, {
            value: t._readableState.endEmitted,
            writable: !0
        }), T(r, ye, {
            value: function(a, f) {
                var o = i[P].read();
                o ? (i[q] = null, i[m] = null, i[D] = null, a(M(o, !1))) : (i[m] = a, i[D] = f);
            },
            writable: !0
        }), r));
        return i[q] = null, Lr(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[D];
                a !== null && (i[q] = null, i[m] = null, i[D] = null, a(n)), i[F] = n;
                return;
            }
            var f = i[m];
            f !== null && (i[q] = null, i[m] = null, i[D] = null, f(M(void 0, !0))), i[ee] = !0;
        }), t.on("readable", qr.bind(null, i)), i;
    };
    et.exports = Cr;
});
var it = c((Oi, rt)=>{
    rt.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var ge = c((Di, ct)=>{
    "use strict";
    ct.exports = u;
    var I;
    u.ReadableState = at;
    var Li = export_default.EventEmitter, nt = function(t, r) {
        return t.listeners(r).length;
    }, H = oe(), te = export_default.Buffer, jr = __global$.Uint8Array || function() {};
    function Ir(e) {
        return te.from(e);
    }
    function kr(e) {
        return te.isBuffer(e) || e instanceof jr;
    }
    var ve = export_default, l;
    ve && ve.debuglog ? l = ve.debuglog("stream") : l = function() {};
    var Wr = je(), we = se(), Ur = de(), Br = Ur.getHighWaterMark, re = O().codes, Fr = re.ERR_INVALID_ARG_TYPE, Hr = re.ERR_STREAM_PUSH_AFTER_EOF, Gr = re.ERR_METHOD_NOT_IMPLEMENTED, Vr = re.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, k, Re, Ee;
    export_default(u, H);
    var G = we.errorOrDestroy, Se = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function Yr(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function at(e, t, r) {
        I = I || L(), e = e || {}, typeof r != "boolean" && (r = t instanceof I), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Br(this, e, "readableHighWaterMark", r), this.buffer = new Wr, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (k || (k = export_default.StringDecoder), this.decoder = new k(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (I = I || L(), !(this instanceof u)) return new u(e);
        var t = this instanceof I;
        this._readableState = new at(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), H.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = we.destroy;
    u.prototype._undestroy = we.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = te.from(e, t), t = ""), i = !0), ft(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return ft(this, e, null, !0, !1);
    };
    function ft(e, t, r, i, n) {
        l("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, Xr(e, a);
        else {
            var f;
            if (n || (f = Kr(a, t)), f) G(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== te.prototype && (t = Ir(t)), i) a.endEmitted ? G(e, new Vr) : Te(e, a, t, !0);
            else if (a.ended) G(e, new Hr);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? Te(e, a, t, !1) : me(e, a)) : Te(e, a, t, !1);
            }
            else i || (a.reading = !1, me(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function Te(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ie(e)), me(e, t);
    }
    function Kr(e, t) {
        var r;
        return !kr(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Fr("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        k || (k = export_default.StringDecoder);
        var t = new k(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var ot = 1073741824;
    function $r(e) {
        return e >= ot ? e = ot : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function lt(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = $r(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        l("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return l("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Ae(this) : ie(this), null;
        if (e = lt(e, t), e === 0 && t.ended) return t.length === 0 && Ae(this), null;
        var i = t.needReadable;
        l("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, l("length less than watermark", i)), t.ended || t.reading ? (i = !1, l("reading or ended", i)) : i && (l("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = lt(r, t)));
        var n;
        return e > 0 ? n = dt(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && Ae(this)), n !== null && this.emit("data", n), n;
    };
    function Xr(e, t) {
        if (l("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? ie(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, ut(e)));
        }
    }
    function ie(e) {
        var t = e._readableState;
        l("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (l("emitReadable", t.flowing), t.emittedReadable = !0, __default.nextTick(ut, e));
    }
    function ut(e) {
        var t = e._readableState;
        l("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, Me(e);
    }
    function me(e, t) {
        t.readingMore || (t.readingMore = !0, __default.nextTick(zr, e, t));
    }
    function zr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (l("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        G(this, new Gr("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== __default.stdout && e !== __default.stderr, a = n ? o : W;
        i.endEmitted ? __default.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(N, x) {
            l("onunpipe"), N === r && x && x.hasUnpiped === !1 && (x.hasUnpiped = !0, v());
        }
        function o() {
            l("onend"), e.end();
        }
        var d = Jr(r);
        e.on("drain", d);
        var p = !1;
        function v() {
            l("cleanup"), e.removeListener("close", R), e.removeListener("finish", g), e.removeListener("drain", d), e.removeListener("error", A), e.removeListener("unpipe", f), r.removeListener("end", o), r.removeListener("end", W), r.removeListener("data", w), p = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", w);
        function w(N) {
            l("ondata");
            var x = e.write(N);
            l("dest.write", x), x === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && ht(i.pipes, e) !== -1) && !p && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function A(N) {
            l("onerror", N), W(), e.removeListener("error", A), nt(e, "error") === 0 && G(e, N);
        }
        Yr(e, "error", A);
        function R() {
            e.removeListener("finish", g), W();
        }
        e.once("close", R);
        function g() {
            l("onfinish"), e.removeListener("close", R), W();
        }
        e.once("finish", g);
        function W() {
            l("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (l("pipe resume"), r.resume()), e;
    };
    function Jr(e) {
        return function() {
            var r = e._readableState;
            l("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && nt(e, "data") && (r.flowing = !0, Me(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = ht(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = H.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, l("on readable", i.length, i.reading), i.length ? ie(this) : i.reading || __default.nextTick(Qr, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = H.prototype.removeListener.call(this, e, t);
        return e === "readable" && __default.nextTick(st, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = H.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && __default.nextTick(st, this), t;
    };
    function st(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function Qr(e) {
        l("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (l("resume"), e.flowing = !e.readableListening, Zr(this, e)), e.paused = !1, this;
    };
    function Zr(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, __default.nextTick(ei, e, t));
    }
    function ei(e, t) {
        l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), Me(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function Me(e) {
        var t = e._readableState;
        for(l("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (l("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (l("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var o = t.push(f);
                o || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(o) {
            return function() {
                return e[o].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < Se.length; a++)e.on(Se[a], this.emit.bind(this, Se[a]));
        return this._read = function(f) {
            l("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return Re === void 0 && (Re = tt()), Re(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = dt;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function dt(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function Ae(e) {
        var t = e._readableState;
        l("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, __default.nextTick(ti, t, e));
    }
    function ti(e, t) {
        if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return Ee === void 0 && (Ee = it()), Ee(u, e, t);
    });
    function ht(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var Oe = c((qi, bt)=>{
    "use strict";
    bt.exports = E;
    var ne = O().codes, ri = ne.ERR_METHOD_NOT_IMPLEMENTED, ii = ne.ERR_MULTIPLE_CALLBACK, ni = ne.ERR_TRANSFORM_ALREADY_TRANSFORMING, ai = ne.ERR_TRANSFORM_WITH_LENGTH_0, ae = L();
    export_default(E, ae);
    function fi(e, t) {
        var r = this._transformState;
        r.transforming = !1;
        var i = r.writecb;
        if (i === null) return this.emit("error", new ii);
        r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
    function E(e) {
        if (!(this instanceof E)) return new E(e);
        ae.call(this, e), this._transformState = {
            afterTransform: fi.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", oi);
    }
    function oi() {
        var e = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
            pt(e, t, r);
        }) : pt(this, null, null);
    }
    E.prototype.push = function(e, t) {
        return this._transformState.needTransform = !1, ae.prototype.push.call(this, e, t);
    };
    E.prototype._transform = function(e, t, r) {
        r(new ri("_transform()"));
    };
    E.prototype._write = function(e, t, r) {
        var i = this._transformState;
        if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
            var n = this._readableState;
            (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
        }
    };
    E.prototype._read = function(e) {
        var t = this._transformState;
        t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
    };
    E.prototype._destroy = function(e, t) {
        ae.prototype._destroy.call(this, e, function(r) {
            t(r);
        });
    };
    function pt(e, t, r) {
        if (t) return e.emit("error", t);
        if (r != null && e.push(r), e._writableState.length) throw new ai;
        if (e._transformState.transforming) throw new ni;
        return e.push(null);
    }
});
var yt = c((Pi, gt)=>{
    "use strict";
    gt.exports = V;
    var _t = Oe();
    export_default(V, _t);
    function V(e) {
        if (!(this instanceof V)) return new V(e);
        _t.call(this, e);
    }
    V.prototype._transform = function(e, t, r) {
        r(null, e);
    };
});
var St = c((Ni, Et)=>{
    "use strict";
    var Le;
    function li(e) {
        var t = !1;
        return function() {
            t || (t = !0, e.apply(void 0, arguments));
        };
    }
    var vt = O().codes, ui = vt.ERR_MISSING_ARGS, si = vt.ERR_STREAM_DESTROYED;
    function wt(e) {
        if (e) throw e;
    }
    function di(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function hi(e, t, r, i) {
        i = li(i);
        var n = !1;
        e.on("close", function() {
            n = !0;
        }), Le === void 0 && (Le = Q()), Le(e, {
            readable: t,
            writable: r
        }, function(f) {
            if (f) return i(f);
            n = !0, i();
        });
        var a = !1;
        return function(f) {
            if (!n && !a) {
                if (a = !0, di(e)) return e.abort();
                if (typeof e.destroy == "function") return e.destroy();
                i(f || new si("pipe"));
            }
        };
    }
    function Rt(e) {
        e();
    }
    function ci(e, t) {
        return e.pipe(t);
    }
    function pi(e) {
        return !e.length || typeof e[e.length - 1] != "function" ? wt : e.pop();
    }
    function bi() {
        for(var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r];
        var i = pi(t);
        if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new ui("streams");
        var n, a = t.map(function(f, o) {
            var d = o < t.length - 1, p = o > 0;
            return hi(f, d, p, function(v) {
                n || (n = v), v && a.forEach(Rt), !d && (a.forEach(Rt), i(n));
            });
        });
        return t.reduce(ci);
    }
    Et.exports = bi;
});
var De = c((_, Tt)=>{
    _ = Tt.exports = ge();
    _.Stream = _;
    _.Readable = _;
    _.Writable = pe();
    _.Duplex = L();
    _.Transform = Oe();
    _.PassThrough = yt();
    _.finished = Q();
    _.pipeline = St();
});
var _i = qe(De()), gi = qe(De()), { Stream: xi , Readable: Ci , Writable: ji , Duplex: Ii , Transform: ki , PassThrough: Wi , finished: Ui , pipeline: Bi  } = _i;
var export_default = gi.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var at = Object.create;
var ee = Object.defineProperty;
var ft = Object.getOwnPropertyDescriptor;
var lt = Object.getOwnPropertyNames;
var ot = Object.getPrototypeOf, ut = Object.prototype.hasOwnProperty;
var st = (e)=>ee(e, "__esModule", {
        value: !0
    });
var p = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var dt = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of lt(t))!ut.call(e, i) && i !== "default" && ee(e, i, {
        get: ()=>t[i],
        enumerable: !(r = ft(t, i)) || r.enumerable
    });
    return e;
}, ht = (e)=>dt(st(ee(e != null ? at(ot(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var te = p((Wr, we)=>{
    we.exports = export_default.EventEmitter;
});
var me = p((Ur, Se)=>{
    "use strict";
    function Ee(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function ct(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Ee(Object(r), !0).forEach(function(i) {
                bt(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ee(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function bt(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function pt(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Re(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function _t(e, t, r) {
        return t && Re(e.prototype, t), r && Re(e, r), e;
    }
    var gt = export_default, H = gt.Buffer, yt = export_default, re = yt.inspect, vt = re && re.custom || "inspect";
    function wt(e, t, r) {
        H.prototype.copy.call(e, t, r);
    }
    Se.exports = function() {
        function e() {
            pt(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return _t(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return H.alloc(0);
                    for(var i = H.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)wt(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, l = r > f.length ? f.length : r;
                        if (l === f.length ? a += f : a += f.slice(0, r), r -= l, r === 0) {
                            l === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(l));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = H.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, l = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, l), r -= l, r === 0) {
                            l === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(l));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: vt,
                value: function(r, i) {
                    return re(this, ct({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var ne = p((Br, Me)=>{
    "use strict";
    function Et(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __default.nextTick(ie, this, e)) : __default.nextTick(ie, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? __default.nextTick(V, r) : (r._writableState.errorEmitted = !0, __default.nextTick(Te, r, a)) : __default.nextTick(Te, r, a) : t ? (__default.nextTick(V, r), t(a)) : __default.nextTick(V, r);
        }), this);
    }
    function Te(e, t) {
        ie(e, t), V(e);
    }
    function V(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Rt() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function ie(e, t) {
        e.emit("error", t);
    }
    function St(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    Me.exports = {
        destroy: Et,
        undestroy: Rt,
        errorOrDestroy: St
    };
});
var k = p((Fr, Le)=>{
    "use strict";
    function mt(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var Oe = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, l) {
            return typeof t == "string" ? t : t(a, f, l);
        }
        var n = function(a) {
            mt(f, a);
            function f(l, d, c) {
                return a.call(this, i(l, d, c)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, Oe[e] = n;
    }
    function Ae(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function Tt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Mt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Ot(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && Tt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (Mt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(Ae(t, "type"));
        else {
            var a = Ot(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(Ae(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Le.exports.codes = Oe;
});
var ae = p((Hr, Pe)=>{
    "use strict";
    var At = k().codes.ERR_INVALID_OPT_VALUE;
    function Lt(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Pt(e, t, r, i) {
        var n = Lt(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new At(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    Pe.exports = {
        getHighWaterMark: Pt
    };
});
var Ce = p((Vr, Ne)=>{
    "use strict";
    var De = k().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Dt(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function qt() {}
    function Nt(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function qe(e, t, r) {
        if (typeof t == "function") return qe(e, null, t);
        t || (t = {}), r = Dt(r || qt);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || l();
        }, f = e._writableState && e._writableState.finished, l = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, c = function() {
            i = !1, d = !0, n || r.call(e);
        }, A = function(_) {
            r.call(e, _);
        }, y = function() {
            var _;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (_ = new De), r.call(e, _);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (_ = new De), r.call(e, _);
        }, m = function() {
            e.req.on("finish", l);
        };
        return Nt(e) ? (e.on("complete", l), e.on("abort", y), e.req ? m() : e.on("request", m)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", c), e.on("finish", l), t.error !== !1 && e.on("error", A), e.on("close", y), function() {
            e.removeListener("complete", l), e.removeListener("abort", y), e.removeListener("request", m), e.req && e.req.removeListener("finish", l), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", l), e.removeListener("end", c), e.removeListener("error", A), e.removeListener("close", y);
        };
    }
    Ne.exports = qe;
});
var xe = p((Gr, je)=>{
    "use strict";
    var G;
    function w(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var Ct = Ce(), E = Symbol("lastResolve"), T = Symbol("lastReject"), I = Symbol("error"), Y = Symbol("ended"), M = Symbol("lastPromise"), fe = Symbol("handlePromise"), O = Symbol("stream");
    function R(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function jt(e) {
        var t = e[E];
        if (t !== null) {
            var r = e[O].read();
            r !== null && (e[M] = null, e[E] = null, e[T] = null, t(R(r, !1)));
        }
    }
    function xt(e) {
        __default.nextTick(jt, e);
    }
    function kt(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[Y]) {
                    r(R(void 0, !0));
                    return;
                }
                t[fe](r, i);
            }, i);
        };
    }
    var It = Object.getPrototypeOf(function() {}), Wt = Object.setPrototypeOf((G = {
        get stream () {
            return this[O];
        },
        next: function() {
            var t = this, r = this[I];
            if (r !== null) return Promise.reject(r);
            if (this[Y]) return Promise.resolve(R(void 0, !0));
            if (this[O].destroyed) return new Promise(function(f, l) {
                __default.nextTick(function() {
                    t[I] ? l(t[I]) : f(R(void 0, !0));
                });
            });
            var i = this[M], n;
            if (i) n = new Promise(kt(i, this));
            else {
                var a = this[O].read();
                if (a !== null) return Promise.resolve(R(a, !1));
                n = new Promise(this[fe]);
            }
            return this[M] = n, n;
        }
    }, w(G, Symbol.asyncIterator, function() {
        return this;
    }), w(G, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[O].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(R(void 0, !0));
            });
        });
    }), G), It), Ut = function(t) {
        var r, i = Object.create(Wt, (r = {}, w(r, O, {
            value: t,
            writable: !0
        }), w(r, E, {
            value: null,
            writable: !0
        }), w(r, T, {
            value: null,
            writable: !0
        }), w(r, I, {
            value: null,
            writable: !0
        }), w(r, Y, {
            value: t._readableState.endEmitted,
            writable: !0
        }), w(r, fe, {
            value: function(a, f) {
                var l = i[O].read();
                l ? (i[M] = null, i[E] = null, i[T] = null, a(R(l, !1))) : (i[E] = a, i[T] = f);
            },
            writable: !0
        }), r));
        return i[M] = null, Ct(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[T];
                a !== null && (i[M] = null, i[E] = null, i[T] = null, a(n)), i[I] = n;
                return;
            }
            var f = i[E];
            f !== null && (i[M] = null, i[E] = null, i[T] = null, f(R(void 0, !0))), i[Y] = !0;
        }), t.on("readable", xt.bind(null, i)), i;
    };
    je.exports = Ut;
});
var Ie = p((Yr, ke)=>{
    ke.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var Xe = p(($r, $e)=>{
    "use strict";
    $e.exports = u;
    var D;
    u.ReadableState = Ue;
    var Kr = export_default.EventEmitter, We = function(t, r) {
        return t.listeners(r).length;
    }, W = te(), K = export_default.Buffer, Bt = __global$.Uint8Array || function() {};
    function Ft(e) {
        return K.from(e);
    }
    function Ht(e) {
        return K.isBuffer(e) || e instanceof Bt;
    }
    var le = export_default, o;
    le && le.debuglog ? o = le.debuglog("stream") : o = function() {};
    var Vt = me(), oe = ne(), Gt = ae(), Yt = Gt.getHighWaterMark, $ = k().codes, Kt = $.ERR_INVALID_ARG_TYPE, $t = $.ERR_STREAM_PUSH_AFTER_EOF, Xt = $.ERR_METHOD_NOT_IMPLEMENTED, zt = $.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, q, ue, se;
    export_default(u, W);
    var U = oe.errorOrDestroy, de = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function Jt(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function Ue(e, t, r) {
        D = D || N(), e = e || {}, typeof r != "boolean" && (r = t instanceof D), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Yt(this, e, "readableHighWaterMark", r), this.buffer = new Vt, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (q || (q = export_default.StringDecoder), this.decoder = new q(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (D = D || N(), !(this instanceof u)) return new u(e);
        var t = this instanceof D;
        this._readableState = new Ue(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), W.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = oe.destroy;
    u.prototype._undestroy = oe.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = K.from(e, t), t = ""), i = !0), Be(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return Be(this, e, null, !0, !1);
    };
    function Be(e, t, r, i, n) {
        o("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, er(e, a);
        else {
            var f;
            if (n || (f = Qt(a, t)), f) U(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== K.prototype && (t = Ft(t)), i) a.endEmitted ? U(e, new zt) : he(e, a, t, !0);
            else if (a.ended) U(e, new $t);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? he(e, a, t, !1) : ce(e, a)) : he(e, a, t, !1);
            }
            else i || (a.reading = !1, ce(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function he(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && X(e)), ce(e, t);
    }
    function Qt(e, t) {
        var r;
        return !Ht(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Kt("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        q || (q = export_default.StringDecoder);
        var t = new q(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var Fe = 1073741824;
    function Zt(e) {
        return e >= Fe ? e = Fe : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function He(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = Zt(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        o("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? pe(this) : X(this), null;
        if (e = He(e, t), e === 0 && t.ended) return t.length === 0 && pe(this), null;
        var i = t.needReadable;
        o("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, o("length less than watermark", i)), t.ended || t.reading ? (i = !1, o("reading or ended", i)) : i && (o("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = He(r, t)));
        var n;
        return e > 0 ? n = Ye(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && pe(this)), n !== null && this.emit("data", n), n;
    };
    function er(e, t) {
        if (o("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? X(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, Ve(e)));
        }
    }
    function X(e) {
        var t = e._readableState;
        o("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o("emitReadable", t.flowing), t.emittedReadable = !0, __default.nextTick(Ve, e));
    }
    function Ve(e) {
        var t = e._readableState;
        o("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, be(e);
    }
    function ce(e, t) {
        t.readingMore || (t.readingMore = !0, __default.nextTick(tr, e, t));
    }
    function tr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (o("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        U(this, new Xt("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, o("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== __default.stdout && e !== __default.stderr, a = n ? l : x;
        i.endEmitted ? __default.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(L, P) {
            o("onunpipe"), L === r && P && P.hasUnpiped === !1 && (P.hasUnpiped = !0, A());
        }
        function l() {
            o("onend"), e.end();
        }
        var d = rr(r);
        e.on("drain", d);
        var c = !1;
        function A() {
            o("cleanup"), e.removeListener("close", v), e.removeListener("finish", _), e.removeListener("drain", d), e.removeListener("error", m), e.removeListener("unpipe", f), r.removeListener("end", l), r.removeListener("end", x), r.removeListener("data", y), c = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", y);
        function y(L) {
            o("ondata");
            var P = e.write(L);
            o("dest.write", P), P === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && Ke(i.pipes, e) !== -1) && !c && (o("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function m(L) {
            o("onerror", L), x(), e.removeListener("error", m), We(e, "error") === 0 && U(e, L);
        }
        Jt(e, "error", m);
        function v() {
            e.removeListener("finish", _), x();
        }
        e.once("close", v);
        function _() {
            o("onfinish"), e.removeListener("close", v), x();
        }
        e.once("finish", _);
        function x() {
            o("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (o("pipe resume"), r.resume()), e;
    };
    function rr(e) {
        return function() {
            var r = e._readableState;
            o("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && We(e, "data") && (r.flowing = !0, be(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = Ke(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = W.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o("on readable", i.length, i.reading), i.length ? X(this) : i.reading || __default.nextTick(ir, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = W.prototype.removeListener.call(this, e, t);
        return e === "readable" && __default.nextTick(Ge, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = W.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && __default.nextTick(Ge, this), t;
    };
    function Ge(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function ir(e) {
        o("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (o("resume"), e.flowing = !e.readableListening, nr(this, e)), e.paused = !1, this;
    };
    function nr(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, __default.nextTick(ar, e, t));
    }
    function ar(e, t) {
        o("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), be(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return o("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (o("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function be(e) {
        var t = e._readableState;
        for(o("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (o("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (o("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var l = t.push(f);
                l || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(l) {
            return function() {
                return e[l].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < de.length; a++)e.on(de[a], this.emit.bind(this, de[a]));
        return this._read = function(f) {
            o("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return ue === void 0 && (ue = xe()), ue(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = Ye;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function Ye(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function pe(e) {
        var t = e._readableState;
        o("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, __default.nextTick(fr, t, e));
    }
    function fr(e, t) {
        if (o("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return se === void 0 && (se = Ie()), se(u, e, t);
    });
    function Ke(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var rt = p((Xr, tt)=>{
    "use strict";
    tt.exports = s;
    function ze(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            Nr(t, e);
        };
    }
    var C;
    s.WritableState = B;
    var lr = {
        deprecate: export_default
    }, Je = te(), z = export_default.Buffer, or = __global$.Uint8Array || function() {};
    function ur(e) {
        return z.from(e);
    }
    function sr(e) {
        return z.isBuffer(e) || e instanceof or;
    }
    var _e = ne(), dr = ae(), hr = dr.getHighWaterMark, S = k().codes, cr = S.ERR_INVALID_ARG_TYPE, br = S.ERR_METHOD_NOT_IMPLEMENTED, pr = S.ERR_MULTIPLE_CALLBACK, _r = S.ERR_STREAM_CANNOT_PIPE, gr = S.ERR_STREAM_DESTROYED, yr = S.ERR_STREAM_NULL_VALUES, vr = S.ERR_STREAM_WRITE_AFTER_END, wr = S.ERR_UNKNOWN_ENCODING, j = _e.errorOrDestroy;
    export_default(s, Je);
    function Er() {}
    function B(e, t, r) {
        C = C || N(), e = e || {}, typeof r != "boolean" && (r = t instanceof C), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = hr(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            Ar(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new ze(this);
    }
    B.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(B.prototype, "buffer", {
                get: lr.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var J;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (J = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return J.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof B;
        }
    })) : J = function(t) {
        return t instanceof this;
    };
    function s(e) {
        C = C || N();
        var t = this instanceof C;
        if (!t && !J.call(s, this)) return new s(e);
        this._writableState = new B(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), Je.call(this);
    }
    s.prototype.pipe = function() {
        j(this, new _r);
    };
    function Rr(e, t) {
        var r = new vr;
        j(e, r), __default.nextTick(t, r);
    }
    function Sr(e, t, r, i) {
        var n;
        return r === null ? n = new yr : typeof r != "string" && !t.objectMode && (n = new cr("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (j(e, n), __default.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && sr(e);
        return a && !z.isBuffer(e) && (e = ur(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = Er), i.ending ? Rr(this, r) : (a || Sr(this, i, e, r)) && (i.pendingcb++, n = Tr(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Ze(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new wr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function mr(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = z.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function Tr(e, t, r, i, n, a) {
        if (!r) {
            var f = mr(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var l = t.objectMode ? 1 : i.length;
        t.length += l;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var c = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else ge(e, t, !1, l, i, n, a);
        return d;
    }
    function ge(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new gr("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function Mr(e, t, r, i, n) {
        --t.pendingcb, r ? (__default.nextTick(n, i), __default.nextTick(F, e, t), e._writableState.errorEmitted = !0, j(e, i)) : (n(i), e._writableState.errorEmitted = !0, j(e, i), F(e, t));
    }
    function Or(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Ar(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new pr;
        if (Or(r), t) Mr(e, r, i, t, n);
        else {
            var a = et(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ze(e, r), i ? __default.nextTick(Qe, e, r, a, n) : Qe(e, r, a, n);
        }
    }
    function Qe(e, t, r, i) {
        r || Lr(e, t), t.pendingcb--, i(), F(e, t);
    }
    function Lr(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function Ze(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, l = !0; r;)n[f] = r, r.isBuf || (l = !1), r = r.next, f += 1;
            n.allBuffers = l, ge(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new ze(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, c = r.encoding, A = r.callback, y = t.objectMode ? 1 : d.length;
                if (ge(e, t, !1, y, d, c, A), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new br("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || qr(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function et(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function Pr(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && j(e, r), t.prefinished = !0, e.emit("prefinish"), F(e, t);
        });
    }
    function Dr(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, __default.nextTick(Pr, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function F(e, t) {
        var r = et(t);
        if (r && (Dr(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function qr(e, t, r) {
        t.ending = !0, F(e, t), r && (t.finished ? __default.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function Nr(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = _e.destroy;
    s.prototype._undestroy = _e.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var N = p((zr, nt)=>{
    "use strict";
    var Cr = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    nt.exports = g;
    var it = Xe(), ye = rt();
    export_default(g, it);
    for(ve = Cr(ye.prototype), Q = 0; Q < ve.length; Q++)Z = ve[Q], g.prototype[Z] || (g.prototype[Z] = ye.prototype[Z]);
    var ve, Z, Q;
    function g(e) {
        if (!(this instanceof g)) return new g(e);
        it.call(this, e), ye.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", jr)));
    }
    Object.defineProperty(g.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(g.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(g.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function jr() {
        this._writableState.ended || __default.nextTick(xr, this);
    }
    function xr(e) {
        e.end();
    }
    Object.defineProperty(g.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var kr = ht(N());
var export_default = kr.default;
var D = Object.create;
var p = Object.defineProperty;
var P = Object.getOwnPropertyDescriptor;
var U = Object.getOwnPropertyNames;
var C = Object.getPrototypeOf, F = Object.prototype.hasOwnProperty;
var G = (n)=>p(n, "__esModule", {
        value: !0
    });
var T = (n, e)=>()=>(e || n((e = {
            exports: {}
        }).exports, e), e.exports);
var H = (n, e, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of U(e))!F.call(n, o) && o !== "default" && p(n, o, {
        get: ()=>e[o],
        enumerable: !(r = P(e, o)) || r.enumerable
    });
    return n;
}, V = (n)=>H(G(p(n != null ? D(C(n)) : {}, "default", n && n.__esModule && "default" in n ? {
        get: ()=>n.default,
        enumerable: !0
    } : {
        value: n,
        enumerable: !0
    })), n);
var S = T((on, g)=>{
    "use strict";
    function W(n, e) {
        n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e;
    }
    var A = {};
    function c(n, e, r) {
        r || (r = Error);
        function o(i, f, u) {
            return typeof e == "string" ? e : e(i, f, u);
        }
        var t = function(i) {
            W(f, i);
            function f(u, l, a) {
                return i.call(this, o(u, l, a)) || this;
            }
            return f;
        }(r);
        t.prototype.name = r.name, t.prototype.code = n, A[n] = t;
    }
    function h(n, e) {
        if (Array.isArray(n)) {
            var r = n.length;
            return n = n.map(function(o) {
                return String(o);
            }), r > 2 ? "one of ".concat(e, " ").concat(n.slice(0, r - 1).join(", "), ", or ") + n[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(n[0], " or ").concat(n[1]) : "of ".concat(e, " ").concat(n[0]);
        } else return "of ".concat(e, " ").concat(String(n));
    }
    function Y(n, e, r) {
        return n.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function j(n, e, r) {
        return (r === void 0 || r > n.length) && (r = n.length), n.substring(r - e.length, r) === e;
    }
    function K(n, e, r) {
        return typeof r != "number" && (r = 0), r + e.length > n.length ? !1 : n.indexOf(e, r) !== -1;
    }
    c("ERR_INVALID_OPT_VALUE", function(n, e) {
        return 'The value "' + e + '" is invalid for option "' + n + '"';
    }, TypeError);
    c("ERR_INVALID_ARG_TYPE", function(n, e, r) {
        var o;
        typeof e == "string" && Y(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
        var t;
        if (j(n, " argument")) t = "The ".concat(n, " ").concat(o, " ").concat(h(e, "type"));
        else {
            var i = K(n, ".") ? "property" : "argument";
            t = 'The "'.concat(n, '" ').concat(i, " ").concat(o, " ").concat(h(e, "type"));
        }
        return t += ". Received type ".concat(typeof r), t;
    }, TypeError);
    c("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    c("ERR_METHOD_NOT_IMPLEMENTED", function(n) {
        return "The " + n + " method is not implemented";
    });
    c("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    c("ERR_STREAM_DESTROYED", function(n) {
        return "Cannot call " + n + " after a stream was destroyed";
    });
    c("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    c("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    c("ERR_STREAM_WRITE_AFTER_END", "write after end");
    c("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    c("ERR_UNKNOWN_ENCODING", function(n) {
        return "Unknown encoding: " + n;
    }, TypeError);
    c("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    g.exports.codes = A;
});
var M = T((tn, L)=>{
    "use strict";
    var b = S().codes.ERR_STREAM_PREMATURE_CLOSE;
    function $(n) {
        var e = !1;
        return function() {
            if (!e) {
                e = !0;
                for(var r = arguments.length, o = new Array(r), t = 0; t < r; t++)o[t] = arguments[t];
                n.apply(this, o);
            }
        };
    }
    function z() {}
    function J(n) {
        return n.setHeader && typeof n.abort == "function";
    }
    function w(n, e, r) {
        if (typeof e == "function") return w(n, null, e);
        e || (e = {}), r = $(r || z);
        var o = e.readable || e.readable !== !1 && n.readable, t = e.writable || e.writable !== !1 && n.writable, i = function() {
            n.writable || u();
        }, f = n._writableState && n._writableState.finished, u = function() {
            t = !1, f = !0, o || r.call(n);
        }, l = n._readableState && n._readableState.endEmitted, a = function() {
            o = !1, l = !0, t || r.call(n);
        }, R = function(E) {
            r.call(n, E);
        }, _ = function() {
            var E;
            if (o && !l) return (!n._readableState || !n._readableState.ended) && (E = new b), r.call(n, E);
            if (t && !f) return (!n._writableState || !n._writableState.ended) && (E = new b), r.call(n, E);
        }, v = function() {
            n.req.on("finish", u);
        };
        return J(n) ? (n.on("complete", u), n.on("abort", _), n.req ? v() : n.on("request", v)) : t && !n._writableState && (n.on("end", i), n.on("close", i)), n.on("end", a), n.on("finish", u), e.error !== !1 && n.on("error", R), n.on("close", _), function() {
            n.removeListener("complete", u), n.removeListener("abort", _), n.removeListener("request", v), n.req && n.req.removeListener("finish", u), n.removeListener("end", i), n.removeListener("close", i), n.removeListener("finish", u), n.removeListener("end", a), n.removeListener("error", R), n.removeListener("close", _);
        };
    }
    L.exports = w;
});
var I = T((fn, q)=>{
    "use strict";
    var y;
    function Q(n) {
        var e = !1;
        return function() {
            e || (e = !0, n.apply(void 0, arguments));
        };
    }
    var N = S().codes, X = N.ERR_MISSING_ARGS, Z = N.ERR_STREAM_DESTROYED;
    function O(n) {
        if (n) throw n;
    }
    function B(n) {
        return n.setHeader && typeof n.abort == "function";
    }
    function x(n, e, r, o) {
        o = Q(o);
        var t = !1;
        n.on("close", function() {
            t = !0;
        }), y === void 0 && (y = M()), y(n, {
            readable: e,
            writable: r
        }, function(f) {
            if (f) return o(f);
            t = !0, o();
        });
        var i = !1;
        return function(f) {
            if (!t && !i) {
                if (i = !0, B(n)) return n.abort();
                if (typeof n.destroy == "function") return n.destroy();
                o(f || new Z("pipe"));
            }
        };
    }
    function s(n) {
        n();
    }
    function k(n, e) {
        return n.pipe(e);
    }
    function m(n) {
        return !n.length || typeof n[n.length - 1] != "function" ? O : n.pop();
    }
    function nn() {
        for(var n = arguments.length, e = new Array(n), r = 0; r < n; r++)e[r] = arguments[r];
        var o = m(e);
        if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new X("streams");
        var t, i = e.map(function(f, u) {
            var l = u < e.length - 1, a = u > 0;
            return x(f, l, a, function(R) {
                t || (t = R), R && i.forEach(s), !l && (i.forEach(s), o(t));
            });
        });
        return e.reduce(k);
    }
    q.exports = nn;
});
var en = V(I());
var export_default = en.default;
var N = Object.create;
var v = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var s = Object.getOwnPropertyNames;
var O = Object.getPrototypeOf, P = Object.prototype.hasOwnProperty;
var U = (n)=>v(n, "__esModule", {
        value: !0
    });
var S = (n, e)=>()=>(e || n((e = {
            exports: {}
        }).exports, e), e.exports);
var q = (n, e, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let o of s(e))!P.call(n, o) && o !== "default" && v(n, o, {
        get: ()=>e[o],
        enumerable: !(r = g(e, o)) || r.enumerable
    });
    return n;
}, I = (n)=>q(U(v(n != null ? N(O(n)) : {}, "default", n && n.__esModule && "default" in n ? {
        get: ()=>n.default,
        enumerable: !0
    } : {
        value: n,
        enumerable: !0
    })), n);
var b = S((Y, L)=>{
    "use strict";
    function D(n, e) {
        n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e;
    }
    var A = {};
    function i(n, e, r) {
        r || (r = Error);
        function o(f, c, u) {
            return typeof e == "string" ? e : e(f, c, u);
        }
        var t = function(f) {
            D(c, f);
            function c(u, E, R) {
                return f.call(this, o(u, E, R)) || this;
            }
            return c;
        }(r);
        t.prototype.name = r.name, t.prototype.code = n, A[n] = t;
    }
    function y(n, e) {
        if (Array.isArray(n)) {
            var r = n.length;
            return n = n.map(function(o) {
                return String(o);
            }), r > 2 ? "one of ".concat(e, " ").concat(n.slice(0, r - 1).join(", "), ", or ") + n[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(n[0], " or ").concat(n[1]) : "of ".concat(e, " ").concat(n[0]);
        } else return "of ".concat(e, " ").concat(String(n));
    }
    function C(n, e, r) {
        return n.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function F(n, e, r) {
        return (r === void 0 || r > n.length) && (r = n.length), n.substring(r - e.length, r) === e;
    }
    function V(n, e, r) {
        return typeof r != "number" && (r = 0), r + e.length > n.length ? !1 : n.indexOf(e, r) !== -1;
    }
    i("ERR_INVALID_OPT_VALUE", function(n, e) {
        return 'The value "' + e + '" is invalid for option "' + n + '"';
    }, TypeError);
    i("ERR_INVALID_ARG_TYPE", function(n, e, r) {
        var o;
        typeof e == "string" && C(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
        var t;
        if (F(n, " argument")) t = "The ".concat(n, " ").concat(o, " ").concat(y(e, "type"));
        else {
            var f = V(n, ".") ? "property" : "argument";
            t = 'The "'.concat(n, '" ').concat(f, " ").concat(o, " ").concat(y(e, "type"));
        }
        return t += ". Received type ".concat(typeof r), t;
    }, TypeError);
    i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    i("ERR_METHOD_NOT_IMPLEMENTED", function(n) {
        return "The " + n + " method is not implemented";
    });
    i("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    i("ERR_STREAM_DESTROYED", function(n) {
        return "Cannot call " + n + " after a stream was destroyed";
    });
    i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    i("ERR_STREAM_WRITE_AFTER_END", "write after end");
    i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    i("ERR_UNKNOWN_ENCODING", function(n) {
        return "Unknown encoding: " + n;
    }, TypeError);
    i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    L.exports.codes = A;
});
var M = S((z, w)=>{
    "use strict";
    var h = b().codes.ERR_STREAM_PREMATURE_CLOSE;
    function H(n) {
        var e = !1;
        return function() {
            if (!e) {
                e = !0;
                for(var r = arguments.length, o = new Array(r), t = 0; t < r; t++)o[t] = arguments[t];
                n.apply(this, o);
            }
        };
    }
    function W() {}
    function j(n) {
        return n.setHeader && typeof n.abort == "function";
    }
    function p(n, e, r) {
        if (typeof e == "function") return p(n, null, e);
        e || (e = {}), r = H(r || W);
        var o = e.readable || e.readable !== !1 && n.readable, t = e.writable || e.writable !== !1 && n.writable, f = function() {
            n.writable || u();
        }, c = n._writableState && n._writableState.finished, u = function() {
            t = !1, c = !0, o || r.call(n);
        }, E = n._readableState && n._readableState.endEmitted, R = function() {
            o = !1, E = !0, t || r.call(n);
        }, T = function(l) {
            r.call(n, l);
        }, _ = function() {
            var l;
            if (o && !E) return (!n._readableState || !n._readableState.ended) && (l = new h), r.call(n, l);
            if (t && !c) return (!n._writableState || !n._writableState.ended) && (l = new h), r.call(n, l);
        }, d = function() {
            n.req.on("finish", u);
        };
        return j(n) ? (n.on("complete", u), n.on("abort", _), n.req ? d() : n.on("request", d)) : t && !n._writableState && (n.on("end", f), n.on("close", f)), n.on("end", R), n.on("finish", u), e.error !== !1 && n.on("error", T), n.on("close", _), function() {
            n.removeListener("complete", u), n.removeListener("abort", _), n.removeListener("request", d), n.req && n.req.removeListener("finish", u), n.removeListener("end", f), n.removeListener("close", f), n.removeListener("finish", u), n.removeListener("end", R), n.removeListener("error", T), n.removeListener("close", _);
        };
    }
    w.exports = p;
});
var G = I(M());
var export_default = G.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var at = Object.create;
var ee = Object.defineProperty;
var ft = Object.getOwnPropertyDescriptor;
var lt = Object.getOwnPropertyNames;
var ot = Object.getPrototypeOf, ut = Object.prototype.hasOwnProperty;
var st = (e)=>ee(e, "__esModule", {
        value: !0
    });
var p = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var dt = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of lt(t))!ut.call(e, i) && i !== "default" && ee(e, i, {
        get: ()=>t[i],
        enumerable: !(r = ft(t, i)) || r.enumerable
    });
    return e;
}, ht = (e)=>dt(st(ee(e != null ? at(ot(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var te = p((Wr, Ee)=>{
    Ee.exports = export_default.EventEmitter;
});
var Te = p((Ur, me)=>{
    "use strict";
    function Re(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function ct(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Re(Object(r), !0).forEach(function(i) {
                bt(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Re(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function bt(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function pt(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Se(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function _t(e, t, r) {
        return t && Se(e.prototype, t), r && Se(e, r), e;
    }
    var gt = export_default, H = gt.Buffer, yt = export_default, re = yt.inspect, vt = re && re.custom || "inspect";
    function wt(e, t, r) {
        H.prototype.copy.call(e, t, r);
    }
    me.exports = function() {
        function e() {
            pt(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return _t(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return H.alloc(0);
                    for(var i = H.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)wt(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, l = r > f.length ? f.length : r;
                        if (l === f.length ? a += f : a += f.slice(0, r), r -= l, r === 0) {
                            l === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(l));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = H.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, l = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, l), r -= l, r === 0) {
                            l === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(l));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: vt,
                value: function(r, i) {
                    return re(this, ct({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var ne = p((Br, Oe)=>{
    "use strict";
    function Et(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __default.nextTick(ie, this, e)) : __default.nextTick(ie, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? __default.nextTick(V, r) : (r._writableState.errorEmitted = !0, __default.nextTick(Me, r, a)) : __default.nextTick(Me, r, a) : t ? (__default.nextTick(V, r), t(a)) : __default.nextTick(V, r);
        }), this);
    }
    function Me(e, t) {
        ie(e, t), V(e);
    }
    function V(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Rt() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function ie(e, t) {
        e.emit("error", t);
    }
    function St(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    Oe.exports = {
        destroy: Et,
        undestroy: Rt,
        errorOrDestroy: St
    };
});
var x = p((Fr, Pe)=>{
    "use strict";
    function mt(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var Ae = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, l) {
            return typeof t == "string" ? t : t(a, f, l);
        }
        var n = function(a) {
            mt(f, a);
            function f(l, d, c) {
                return a.call(this, i(l, d, c)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, Ae[e] = n;
    }
    function Le(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function Tt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Mt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Ot(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && Tt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (Mt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(Le(t, "type"));
        else {
            var a = Ot(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(Le(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Pe.exports.codes = Ae;
});
var ae = p((Hr, De)=>{
    "use strict";
    var At = x().codes.ERR_INVALID_OPT_VALUE;
    function Lt(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Pt(e, t, r, i) {
        var n = Lt(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new At(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    De.exports = {
        getHighWaterMark: Pt
    };
});
var Ie = p((Vr, ke)=>{
    "use strict";
    ke.exports = s;
    function qe(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            ir(t, e);
        };
    }
    var D;
    s.WritableState = k;
    var Dt = {
        deprecate: export_default
    }, Ne = te(), G = export_default.Buffer, qt = __global$.Uint8Array || function() {};
    function Nt(e) {
        return G.from(e);
    }
    function Ct(e) {
        return G.isBuffer(e) || e instanceof qt;
    }
    var fe = ne(), jt = ae(), xt = jt.getHighWaterMark, w = x().codes, kt = w.ERR_INVALID_ARG_TYPE, It = w.ERR_METHOD_NOT_IMPLEMENTED, Wt = w.ERR_MULTIPLE_CALLBACK, Ut = w.ERR_STREAM_CANNOT_PIPE, Bt = w.ERR_STREAM_DESTROYED, Ft = w.ERR_STREAM_NULL_VALUES, Ht = w.ERR_STREAM_WRITE_AFTER_END, Vt = w.ERR_UNKNOWN_ENCODING, q = fe.errorOrDestroy;
    export_default(s, Ne);
    function Gt() {}
    function k(e, t, r) {
        D = D || W(), e = e || {}, typeof r != "boolean" && (r = t instanceof D), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = xt(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            Qt(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new qe(this);
    }
    k.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(k.prototype, "buffer", {
                get: Dt.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var Y;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Y = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return Y.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof k;
        }
    })) : Y = function(t) {
        return t instanceof this;
    };
    function s(e) {
        D = D || W();
        var t = this instanceof D;
        if (!t && !Y.call(s, this)) return new s(e);
        this._writableState = new k(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), Ne.call(this);
    }
    s.prototype.pipe = function() {
        q(this, new Ut);
    };
    function Yt(e, t) {
        var r = new Ht;
        q(e, r), __default.nextTick(t, r);
    }
    function Kt(e, t, r, i) {
        var n;
        return r === null ? n = new Ft : typeof r != "string" && !t.objectMode && (n = new kt("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (q(e, n), __default.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && Ct(e);
        return a && !G.isBuffer(e) && (e = Nt(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = Gt), i.ending ? Yt(this, r) : (a || Kt(this, i, e, r)) && (i.pendingcb++, n = Xt(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && je(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new Vt(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function $t(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = G.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function Xt(e, t, r, i, n, a) {
        if (!r) {
            var f = $t(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var l = t.objectMode ? 1 : i.length;
        t.length += l;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var c = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else le(e, t, !1, l, i, n, a);
        return d;
    }
    function le(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new Bt("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function zt(e, t, r, i, n) {
        --t.pendingcb, r ? (__default.nextTick(n, i), __default.nextTick(I, e, t), e._writableState.errorEmitted = !0, q(e, i)) : (n(i), e._writableState.errorEmitted = !0, q(e, i), I(e, t));
    }
    function Jt(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Qt(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new Wt;
        if (Jt(r), t) zt(e, r, i, t, n);
        else {
            var a = xe(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && je(e, r), i ? __default.nextTick(Ce, e, r, a, n) : Ce(e, r, a, n);
        }
    }
    function Ce(e, t, r, i) {
        r || Zt(e, t), t.pendingcb--, i(), I(e, t);
    }
    function Zt(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function je(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, l = !0; r;)n[f] = r, r.isBuf || (l = !1), r = r.next, f += 1;
            n.allBuffers = l, le(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new qe(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, c = r.encoding, A = r.callback, y = t.objectMode ? 1 : d.length;
                if (le(e, t, !1, y, d, c, A), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new It("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || rr(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function xe(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function er(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && q(e, r), t.prefinished = !0, e.emit("prefinish"), I(e, t);
        });
    }
    function tr(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, __default.nextTick(er, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function I(e, t) {
        var r = xe(t);
        if (r && (tr(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function rr(e, t, r) {
        t.ending = !0, I(e, t), r && (t.finished ? __default.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function ir(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = fe.destroy;
    s.prototype._undestroy = fe.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var W = p((Gr, Ue)=>{
    "use strict";
    var nr = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    Ue.exports = g;
    var We = se(), oe = Ie();
    export_default(g, We);
    for(ue = nr(oe.prototype), K = 0; K < ue.length; K++)$ = ue[K], g.prototype[$] || (g.prototype[$] = oe.prototype[$]);
    var ue, $, K;
    function g(e) {
        if (!(this instanceof g)) return new g(e);
        We.call(this, e), oe.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ar)));
    }
    Object.defineProperty(g.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(g.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(g.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function ar() {
        this._writableState.ended || __default.nextTick(fr, this);
    }
    function fr(e) {
        e.end();
    }
    Object.defineProperty(g.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var Ve = p((Yr, He)=>{
    "use strict";
    var Be = x().codes.ERR_STREAM_PREMATURE_CLOSE;
    function lr(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function or() {}
    function ur(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function Fe(e, t, r) {
        if (typeof t == "function") return Fe(e, null, t);
        t || (t = {}), r = lr(r || or);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || l();
        }, f = e._writableState && e._writableState.finished, l = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, c = function() {
            i = !1, d = !0, n || r.call(e);
        }, A = function(_) {
            r.call(e, _);
        }, y = function() {
            var _;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (_ = new Be), r.call(e, _);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (_ = new Be), r.call(e, _);
        }, m = function() {
            e.req.on("finish", l);
        };
        return ur(e) ? (e.on("complete", l), e.on("abort", y), e.req ? m() : e.on("request", m)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", c), e.on("finish", l), t.error !== !1 && e.on("error", A), e.on("close", y), function() {
            e.removeListener("complete", l), e.removeListener("abort", y), e.removeListener("request", m), e.req && e.req.removeListener("finish", l), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", l), e.removeListener("end", c), e.removeListener("error", A), e.removeListener("close", y);
        };
    }
    He.exports = Fe;
});
var Ye = p((Kr, Ge)=>{
    "use strict";
    var X;
    function E(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var sr = Ve(), R = Symbol("lastResolve"), T = Symbol("lastReject"), U = Symbol("error"), z = Symbol("ended"), M = Symbol("lastPromise"), de = Symbol("handlePromise"), O = Symbol("stream");
    function S(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function dr(e) {
        var t = e[R];
        if (t !== null) {
            var r = e[O].read();
            r !== null && (e[M] = null, e[R] = null, e[T] = null, t(S(r, !1)));
        }
    }
    function hr(e) {
        __default.nextTick(dr, e);
    }
    function cr(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[z]) {
                    r(S(void 0, !0));
                    return;
                }
                t[de](r, i);
            }, i);
        };
    }
    var br = Object.getPrototypeOf(function() {}), pr = Object.setPrototypeOf((X = {
        get stream () {
            return this[O];
        },
        next: function() {
            var t = this, r = this[U];
            if (r !== null) return Promise.reject(r);
            if (this[z]) return Promise.resolve(S(void 0, !0));
            if (this[O].destroyed) return new Promise(function(f, l) {
                __default.nextTick(function() {
                    t[U] ? l(t[U]) : f(S(void 0, !0));
                });
            });
            var i = this[M], n;
            if (i) n = new Promise(cr(i, this));
            else {
                var a = this[O].read();
                if (a !== null) return Promise.resolve(S(a, !1));
                n = new Promise(this[de]);
            }
            return this[M] = n, n;
        }
    }, E(X, Symbol.asyncIterator, function() {
        return this;
    }), E(X, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[O].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(S(void 0, !0));
            });
        });
    }), X), br), _r = function(t) {
        var r, i = Object.create(pr, (r = {}, E(r, O, {
            value: t,
            writable: !0
        }), E(r, R, {
            value: null,
            writable: !0
        }), E(r, T, {
            value: null,
            writable: !0
        }), E(r, U, {
            value: null,
            writable: !0
        }), E(r, z, {
            value: t._readableState.endEmitted,
            writable: !0
        }), E(r, de, {
            value: function(a, f) {
                var l = i[O].read();
                l ? (i[M] = null, i[R] = null, i[T] = null, a(S(l, !1))) : (i[R] = a, i[T] = f);
            },
            writable: !0
        }), r));
        return i[M] = null, sr(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[T];
                a !== null && (i[M] = null, i[R] = null, i[T] = null, a(n)), i[U] = n;
                return;
            }
            var f = i[R];
            f !== null && (i[M] = null, i[R] = null, i[T] = null, f(S(void 0, !0))), i[z] = !0;
        }), t.on("readable", hr.bind(null, i)), i;
    };
    Ge.exports = _r;
});
var $e = p(($r, Ke)=>{
    Ke.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var se = p((zr, nt)=>{
    "use strict";
    nt.exports = u;
    var N;
    u.ReadableState = ze;
    var Xr = export_default.EventEmitter, Xe = function(t, r) {
        return t.listeners(r).length;
    }, B = te(), J = export_default.Buffer, gr = __global$.Uint8Array || function() {};
    function yr(e) {
        return J.from(e);
    }
    function vr(e) {
        return J.isBuffer(e) || e instanceof gr;
    }
    var he = export_default, o;
    he && he.debuglog ? o = he.debuglog("stream") : o = function() {};
    var wr = Te(), ce = ne(), Er = ae(), Rr = Er.getHighWaterMark, Q = x().codes, Sr = Q.ERR_INVALID_ARG_TYPE, mr = Q.ERR_STREAM_PUSH_AFTER_EOF, Tr = Q.ERR_METHOD_NOT_IMPLEMENTED, Mr = Q.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, C, be, pe;
    export_default(u, B);
    var F = ce.errorOrDestroy, _e = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function Or(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function ze(e, t, r) {
        N = N || W(), e = e || {}, typeof r != "boolean" && (r = t instanceof N), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Rr(this, e, "readableHighWaterMark", r), this.buffer = new wr, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (C || (C = export_default.StringDecoder), this.decoder = new C(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (N = N || W(), !(this instanceof u)) return new u(e);
        var t = this instanceof N;
        this._readableState = new ze(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), B.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = ce.destroy;
    u.prototype._undestroy = ce.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = J.from(e, t), t = ""), i = !0), Je(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return Je(this, e, null, !0, !1);
    };
    function Je(e, t, r, i, n) {
        o("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, Pr(e, a);
        else {
            var f;
            if (n || (f = Ar(a, t)), f) F(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== J.prototype && (t = yr(t)), i) a.endEmitted ? F(e, new Mr) : ge(e, a, t, !0);
            else if (a.ended) F(e, new mr);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? ge(e, a, t, !1) : ye(e, a)) : ge(e, a, t, !1);
            }
            else i || (a.reading = !1, ye(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function ge(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && Z(e)), ye(e, t);
    }
    function Ar(e, t) {
        var r;
        return !vr(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Sr("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        C || (C = export_default.StringDecoder);
        var t = new C(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var Qe = 1073741824;
    function Lr(e) {
        return e >= Qe ? e = Qe : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Ze(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = Lr(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        o("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? we(this) : Z(this), null;
        if (e = Ze(e, t), e === 0 && t.ended) return t.length === 0 && we(this), null;
        var i = t.needReadable;
        o("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, o("length less than watermark", i)), t.ended || t.reading ? (i = !1, o("reading or ended", i)) : i && (o("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Ze(r, t)));
        var n;
        return e > 0 ? n = rt(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && we(this)), n !== null && this.emit("data", n), n;
    };
    function Pr(e, t) {
        if (o("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? Z(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, et(e)));
        }
    }
    function Z(e) {
        var t = e._readableState;
        o("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o("emitReadable", t.flowing), t.emittedReadable = !0, __default.nextTick(et, e));
    }
    function et(e) {
        var t = e._readableState;
        o("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, ve(e);
    }
    function ye(e, t) {
        t.readingMore || (t.readingMore = !0, __default.nextTick(Dr, e, t));
    }
    function Dr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (o("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        F(this, new Tr("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, o("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== __default.stdout && e !== __default.stderr, a = n ? l : j;
        i.endEmitted ? __default.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(L, P) {
            o("onunpipe"), L === r && P && P.hasUnpiped === !1 && (P.hasUnpiped = !0, A());
        }
        function l() {
            o("onend"), e.end();
        }
        var d = qr(r);
        e.on("drain", d);
        var c = !1;
        function A() {
            o("cleanup"), e.removeListener("close", v), e.removeListener("finish", _), e.removeListener("drain", d), e.removeListener("error", m), e.removeListener("unpipe", f), r.removeListener("end", l), r.removeListener("end", j), r.removeListener("data", y), c = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", y);
        function y(L) {
            o("ondata");
            var P = e.write(L);
            o("dest.write", P), P === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && it(i.pipes, e) !== -1) && !c && (o("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function m(L) {
            o("onerror", L), j(), e.removeListener("error", m), Xe(e, "error") === 0 && F(e, L);
        }
        Or(e, "error", m);
        function v() {
            e.removeListener("finish", _), j();
        }
        e.once("close", v);
        function _() {
            o("onfinish"), e.removeListener("close", v), j();
        }
        e.once("finish", _);
        function j() {
            o("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (o("pipe resume"), r.resume()), e;
    };
    function qr(e) {
        return function() {
            var r = e._readableState;
            o("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Xe(e, "data") && (r.flowing = !0, ve(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = it(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = B.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o("on readable", i.length, i.reading), i.length ? Z(this) : i.reading || __default.nextTick(Nr, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = B.prototype.removeListener.call(this, e, t);
        return e === "readable" && __default.nextTick(tt, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = B.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && __default.nextTick(tt, this), t;
    };
    function tt(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function Nr(e) {
        o("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (o("resume"), e.flowing = !e.readableListening, Cr(this, e)), e.paused = !1, this;
    };
    function Cr(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, __default.nextTick(jr, e, t));
    }
    function jr(e, t) {
        o("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), ve(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return o("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (o("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function ve(e) {
        var t = e._readableState;
        for(o("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (o("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (o("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var l = t.push(f);
                l || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(l) {
            return function() {
                return e[l].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < _e.length; a++)e.on(_e[a], this.emit.bind(this, _e[a]));
        return this._read = function(f) {
            o("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return be === void 0 && (be = Ye()), be(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = rt;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function rt(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function we(e) {
        var t = e._readableState;
        o("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, __default.nextTick(xr, t, e));
    }
    function xr(e, t) {
        if (o("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return pe === void 0 && (pe = $e()), pe(u, e, t);
    });
    function it(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var kr = ht(se());
var export_default = kr.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var at = Object.create;
var ee = Object.defineProperty;
var ft = Object.getOwnPropertyDescriptor;
var lt = Object.getOwnPropertyNames;
var ot = Object.getPrototypeOf, ut = Object.prototype.hasOwnProperty;
var st = (e)=>ee(e, "__esModule", {
        value: !0
    });
var p = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var dt = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of lt(t))!ut.call(e, i) && i !== "default" && ee(e, i, {
        get: ()=>t[i],
        enumerable: !(r = ft(t, i)) || r.enumerable
    });
    return e;
}, ht = (e)=>dt(st(ee(e != null ? at(ot(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var te = p((Wr, Ee)=>{
    Ee.exports = export_default.EventEmitter;
});
var ie = p((Ur, Se)=>{
    "use strict";
    function ct(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __default.nextTick(re, this, e)) : __default.nextTick(re, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? __default.nextTick(H, r) : (r._writableState.errorEmitted = !0, __default.nextTick(Re, r, a)) : __default.nextTick(Re, r, a) : t ? (__default.nextTick(H, r), t(a)) : __default.nextTick(H, r);
        }), this);
    }
    function Re(e, t) {
        re(e, t), H(e);
    }
    function H(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function bt() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function re(e, t) {
        e.emit("error", t);
    }
    function pt(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    Se.exports = {
        destroy: ct,
        undestroy: bt,
        errorOrDestroy: pt
    };
});
var x = p((Br, Me)=>{
    "use strict";
    function _t(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var me = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, l) {
            return typeof t == "string" ? t : t(a, f, l);
        }
        var n = function(a) {
            _t(f, a);
            function f(l, d, c) {
                return a.call(this, i(l, d, c)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, me[e] = n;
    }
    function Te(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function gt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function yt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function vt(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && gt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (yt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(Te(t, "type"));
        else {
            var a = vt(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(Te(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Me.exports.codes = me;
});
var ne = p((Fr, Oe)=>{
    "use strict";
    var wt = x().codes.ERR_INVALID_OPT_VALUE;
    function Et(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Rt(e, t, r, i) {
        var n = Et(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new wt(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    Oe.exports = {
        getHighWaterMark: Rt
    };
});
var De = p((Hr, Pe)=>{
    "use strict";
    function Ae(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function St(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Ae(Object(r), !0).forEach(function(i) {
                mt(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ae(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function mt(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function Tt(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Le(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function Mt(e, t, r) {
        return t && Le(e.prototype, t), r && Le(e, r), e;
    }
    var Ot = export_default, V = Ot.Buffer, At = export_default, ae = At.inspect, Lt = ae && ae.custom || "inspect";
    function Pt(e, t, r) {
        V.prototype.copy.call(e, t, r);
    }
    Pe.exports = function() {
        function e() {
            Tt(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return Mt(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return V.alloc(0);
                    for(var i = V.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)Pt(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, l = r > f.length ? f.length : r;
                        if (l === f.length ? a += f : a += f.slice(0, r), r -= l, r === 0) {
                            l === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(l));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = V.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, l = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, l), r -= l, r === 0) {
                            l === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(l));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: Lt,
                value: function(r, i) {
                    return ae(this, St({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var je = p((Vr, Ce)=>{
    "use strict";
    var qe = x().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Dt(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function qt() {}
    function Nt(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function Ne(e, t, r) {
        if (typeof t == "function") return Ne(e, null, t);
        t || (t = {}), r = Dt(r || qt);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || l();
        }, f = e._writableState && e._writableState.finished, l = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, c = function() {
            i = !1, d = !0, n || r.call(e);
        }, A = function(_) {
            r.call(e, _);
        }, y = function() {
            var _;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (_ = new qe), r.call(e, _);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (_ = new qe), r.call(e, _);
        }, m = function() {
            e.req.on("finish", l);
        };
        return Nt(e) ? (e.on("complete", l), e.on("abort", y), e.req ? m() : e.on("request", m)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", c), e.on("finish", l), t.error !== !1 && e.on("error", A), e.on("close", y), function() {
            e.removeListener("complete", l), e.removeListener("abort", y), e.removeListener("request", m), e.req && e.req.removeListener("finish", l), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", l), e.removeListener("end", c), e.removeListener("error", A), e.removeListener("close", y);
        };
    }
    Ce.exports = Ne;
});
var ke = p((Gr, xe)=>{
    "use strict";
    var G;
    function w(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var Ct = je(), E = Symbol("lastResolve"), T = Symbol("lastReject"), k = Symbol("error"), Y = Symbol("ended"), M = Symbol("lastPromise"), fe = Symbol("handlePromise"), O = Symbol("stream");
    function R(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function jt(e) {
        var t = e[E];
        if (t !== null) {
            var r = e[O].read();
            r !== null && (e[M] = null, e[E] = null, e[T] = null, t(R(r, !1)));
        }
    }
    function xt(e) {
        __default.nextTick(jt, e);
    }
    function kt(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[Y]) {
                    r(R(void 0, !0));
                    return;
                }
                t[fe](r, i);
            }, i);
        };
    }
    var It = Object.getPrototypeOf(function() {}), Wt = Object.setPrototypeOf((G = {
        get stream () {
            return this[O];
        },
        next: function() {
            var t = this, r = this[k];
            if (r !== null) return Promise.reject(r);
            if (this[Y]) return Promise.resolve(R(void 0, !0));
            if (this[O].destroyed) return new Promise(function(f, l) {
                __default.nextTick(function() {
                    t[k] ? l(t[k]) : f(R(void 0, !0));
                });
            });
            var i = this[M], n;
            if (i) n = new Promise(kt(i, this));
            else {
                var a = this[O].read();
                if (a !== null) return Promise.resolve(R(a, !1));
                n = new Promise(this[fe]);
            }
            return this[M] = n, n;
        }
    }, w(G, Symbol.asyncIterator, function() {
        return this;
    }), w(G, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[O].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(R(void 0, !0));
            });
        });
    }), G), It), Ut = function(t) {
        var r, i = Object.create(Wt, (r = {}, w(r, O, {
            value: t,
            writable: !0
        }), w(r, E, {
            value: null,
            writable: !0
        }), w(r, T, {
            value: null,
            writable: !0
        }), w(r, k, {
            value: null,
            writable: !0
        }), w(r, Y, {
            value: t._readableState.endEmitted,
            writable: !0
        }), w(r, fe, {
            value: function(a, f) {
                var l = i[O].read();
                l ? (i[M] = null, i[E] = null, i[T] = null, a(R(l, !1))) : (i[E] = a, i[T] = f);
            },
            writable: !0
        }), r));
        return i[M] = null, Ct(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[T];
                a !== null && (i[M] = null, i[E] = null, i[T] = null, a(n)), i[k] = n;
                return;
            }
            var f = i[E];
            f !== null && (i[M] = null, i[E] = null, i[T] = null, f(R(void 0, !0))), i[Y] = !0;
        }), t.on("readable", xt.bind(null, i)), i;
    };
    xe.exports = Ut;
});
var We = p((Yr, Ie)=>{
    Ie.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var ze = p(($r, Xe)=>{
    "use strict";
    Xe.exports = u;
    var D;
    u.ReadableState = Be;
    var Kr = export_default.EventEmitter, Ue = function(t, r) {
        return t.listeners(r).length;
    }, I = te(), K = export_default.Buffer, Bt = __global$.Uint8Array || function() {};
    function Ft(e) {
        return K.from(e);
    }
    function Ht(e) {
        return K.isBuffer(e) || e instanceof Bt;
    }
    var le = export_default, o;
    le && le.debuglog ? o = le.debuglog("stream") : o = function() {};
    var Vt = De(), oe = ie(), Gt = ne(), Yt = Gt.getHighWaterMark, $ = x().codes, Kt = $.ERR_INVALID_ARG_TYPE, $t = $.ERR_STREAM_PUSH_AFTER_EOF, Xt = $.ERR_METHOD_NOT_IMPLEMENTED, zt = $.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, q, ue, se;
    export_default(u, I);
    var W = oe.errorOrDestroy, de = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function Jt(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function Be(e, t, r) {
        D = D || U(), e = e || {}, typeof r != "boolean" && (r = t instanceof D), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Yt(this, e, "readableHighWaterMark", r), this.buffer = new Vt, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (q || (q = export_default.StringDecoder), this.decoder = new q(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (D = D || U(), !(this instanceof u)) return new u(e);
        var t = this instanceof D;
        this._readableState = new Be(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), I.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = oe.destroy;
    u.prototype._undestroy = oe.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = K.from(e, t), t = ""), i = !0), Fe(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return Fe(this, e, null, !0, !1);
    };
    function Fe(e, t, r, i, n) {
        o("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, er(e, a);
        else {
            var f;
            if (n || (f = Qt(a, t)), f) W(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== K.prototype && (t = Ft(t)), i) a.endEmitted ? W(e, new zt) : he(e, a, t, !0);
            else if (a.ended) W(e, new $t);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? he(e, a, t, !1) : ce(e, a)) : he(e, a, t, !1);
            }
            else i || (a.reading = !1, ce(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function he(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && X(e)), ce(e, t);
    }
    function Qt(e, t) {
        var r;
        return !Ht(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Kt("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        q || (q = export_default.StringDecoder);
        var t = new q(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var He = 1073741824;
    function Zt(e) {
        return e >= He ? e = He : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Ve(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = Zt(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        o("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? pe(this) : X(this), null;
        if (e = Ve(e, t), e === 0 && t.ended) return t.length === 0 && pe(this), null;
        var i = t.needReadable;
        o("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, o("length less than watermark", i)), t.ended || t.reading ? (i = !1, o("reading or ended", i)) : i && (o("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Ve(r, t)));
        var n;
        return e > 0 ? n = Ke(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && pe(this)), n !== null && this.emit("data", n), n;
    };
    function er(e, t) {
        if (o("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? X(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, Ge(e)));
        }
    }
    function X(e) {
        var t = e._readableState;
        o("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o("emitReadable", t.flowing), t.emittedReadable = !0, __default.nextTick(Ge, e));
    }
    function Ge(e) {
        var t = e._readableState;
        o("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, be(e);
    }
    function ce(e, t) {
        t.readingMore || (t.readingMore = !0, __default.nextTick(tr, e, t));
    }
    function tr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (o("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        W(this, new Xt("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, o("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== __default.stdout && e !== __default.stderr, a = n ? l : j;
        i.endEmitted ? __default.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(L, P) {
            o("onunpipe"), L === r && P && P.hasUnpiped === !1 && (P.hasUnpiped = !0, A());
        }
        function l() {
            o("onend"), e.end();
        }
        var d = rr(r);
        e.on("drain", d);
        var c = !1;
        function A() {
            o("cleanup"), e.removeListener("close", v), e.removeListener("finish", _), e.removeListener("drain", d), e.removeListener("error", m), e.removeListener("unpipe", f), r.removeListener("end", l), r.removeListener("end", j), r.removeListener("data", y), c = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", y);
        function y(L) {
            o("ondata");
            var P = e.write(L);
            o("dest.write", P), P === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && $e(i.pipes, e) !== -1) && !c && (o("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function m(L) {
            o("onerror", L), j(), e.removeListener("error", m), Ue(e, "error") === 0 && W(e, L);
        }
        Jt(e, "error", m);
        function v() {
            e.removeListener("finish", _), j();
        }
        e.once("close", v);
        function _() {
            o("onfinish"), e.removeListener("close", v), j();
        }
        e.once("finish", _);
        function j() {
            o("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (o("pipe resume"), r.resume()), e;
    };
    function rr(e) {
        return function() {
            var r = e._readableState;
            o("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Ue(e, "data") && (r.flowing = !0, be(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = $e(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = I.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o("on readable", i.length, i.reading), i.length ? X(this) : i.reading || __default.nextTick(ir, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = I.prototype.removeListener.call(this, e, t);
        return e === "readable" && __default.nextTick(Ye, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = I.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && __default.nextTick(Ye, this), t;
    };
    function Ye(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function ir(e) {
        o("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (o("resume"), e.flowing = !e.readableListening, nr(this, e)), e.paused = !1, this;
    };
    function nr(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, __default.nextTick(ar, e, t));
    }
    function ar(e, t) {
        o("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), be(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return o("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (o("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function be(e) {
        var t = e._readableState;
        for(o("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (o("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (o("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var l = t.push(f);
                l || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(l) {
            return function() {
                return e[l].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < de.length; a++)e.on(de[a], this.emit.bind(this, de[a]));
        return this._read = function(f) {
            o("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return ue === void 0 && (ue = ke()), ue(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = Ke;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function Ke(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function pe(e) {
        var t = e._readableState;
        o("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, __default.nextTick(fr, t, e));
    }
    function fr(e, t) {
        if (o("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return se === void 0 && (se = We()), se(u, e, t);
    });
    function $e(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var U = p((Xr, Qe)=>{
    "use strict";
    var lr = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    Qe.exports = g;
    var Je = ze(), _e = ye();
    export_default(g, Je);
    for(ge = lr(_e.prototype), z = 0; z < ge.length; z++)J = ge[z], g.prototype[J] || (g.prototype[J] = _e.prototype[J]);
    var ge, J, z;
    function g(e) {
        if (!(this instanceof g)) return new g(e);
        Je.call(this, e), _e.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", or)));
    }
    Object.defineProperty(g.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(g.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(g.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function or() {
        this._writableState.ended || __default.nextTick(ur, this);
    }
    function ur(e) {
        e.end();
    }
    Object.defineProperty(g.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var ye = p((zr, nt)=>{
    "use strict";
    nt.exports = s;
    function Ze(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            xr(t, e);
        };
    }
    var N;
    s.WritableState = B;
    var sr = {
        deprecate: export_default
    }, et = te(), Q = export_default.Buffer, dr = __global$.Uint8Array || function() {};
    function hr(e) {
        return Q.from(e);
    }
    function cr(e) {
        return Q.isBuffer(e) || e instanceof dr;
    }
    var ve = ie(), br = ne(), pr = br.getHighWaterMark, S = x().codes, _r = S.ERR_INVALID_ARG_TYPE, gr = S.ERR_METHOD_NOT_IMPLEMENTED, yr = S.ERR_MULTIPLE_CALLBACK, vr = S.ERR_STREAM_CANNOT_PIPE, wr = S.ERR_STREAM_DESTROYED, Er = S.ERR_STREAM_NULL_VALUES, Rr = S.ERR_STREAM_WRITE_AFTER_END, Sr = S.ERR_UNKNOWN_ENCODING, C = ve.errorOrDestroy;
    export_default(s, et);
    function mr() {}
    function B(e, t, r) {
        N = N || U(), e = e || {}, typeof r != "boolean" && (r = t instanceof N), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = pr(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            Dr(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ze(this);
    }
    B.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(B.prototype, "buffer", {
                get: sr.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var Z;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Z = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return Z.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof B;
        }
    })) : Z = function(t) {
        return t instanceof this;
    };
    function s(e) {
        N = N || U();
        var t = this instanceof N;
        if (!t && !Z.call(s, this)) return new s(e);
        this._writableState = new B(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), et.call(this);
    }
    s.prototype.pipe = function() {
        C(this, new vr);
    };
    function Tr(e, t) {
        var r = new Rr;
        C(e, r), __default.nextTick(t, r);
    }
    function Mr(e, t, r, i) {
        var n;
        return r === null ? n = new Er : typeof r != "string" && !t.objectMode && (n = new _r("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (C(e, n), __default.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && cr(e);
        return a && !Q.isBuffer(e) && (e = hr(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = mr), i.ending ? Tr(this, r) : (a || Mr(this, i, e, r)) && (i.pendingcb++, n = Ar(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && rt(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new Sr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function Or(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = Q.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function Ar(e, t, r, i, n, a) {
        if (!r) {
            var f = Or(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var l = t.objectMode ? 1 : i.length;
        t.length += l;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var c = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else we(e, t, !1, l, i, n, a);
        return d;
    }
    function we(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new wr("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function Lr(e, t, r, i, n) {
        --t.pendingcb, r ? (__default.nextTick(n, i), __default.nextTick(F, e, t), e._writableState.errorEmitted = !0, C(e, i)) : (n(i), e._writableState.errorEmitted = !0, C(e, i), F(e, t));
    }
    function Pr(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Dr(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new yr;
        if (Pr(r), t) Lr(e, r, i, t, n);
        else {
            var a = it(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && rt(e, r), i ? __default.nextTick(tt, e, r, a, n) : tt(e, r, a, n);
        }
    }
    function tt(e, t, r, i) {
        r || qr(e, t), t.pendingcb--, i(), F(e, t);
    }
    function qr(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function rt(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, l = !0; r;)n[f] = r, r.isBuf || (l = !1), r = r.next, f += 1;
            n.allBuffers = l, we(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new Ze(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, c = r.encoding, A = r.callback, y = t.objectMode ? 1 : d.length;
                if (we(e, t, !1, y, d, c, A), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new gr("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || jr(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function it(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function Nr(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && C(e, r), t.prefinished = !0, e.emit("prefinish"), F(e, t);
        });
    }
    function Cr(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, __default.nextTick(Nr, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function F(e, t) {
        var r = it(t);
        if (r && (Cr(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function jr(e, t, r) {
        t.ending = !0, F(e, t), r && (t.finished ? __default.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function xr(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = ve.destroy;
    s.prototype._undestroy = ve.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var kr = ht(ye());
var export_default = kr.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var dt = Object.create;
var ie = Object.defineProperty;
var ht = Object.getOwnPropertyDescriptor;
var ct = Object.getOwnPropertyNames;
var pt = Object.getPrototypeOf, bt = Object.prototype.hasOwnProperty;
var _t = (e)=>ie(e, "__esModule", {
        value: !0
    });
var p = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var gt = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of ct(t))!bt.call(e, i) && i !== "default" && ie(e, i, {
        get: ()=>t[i],
        enumerable: !(r = ht(t, i)) || r.enumerable
    });
    return e;
}, yt = (e)=>gt(_t(ie(e != null ? dt(pt(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var N = p((Jr, Te)=>{
    "use strict";
    function vt(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var Se = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, l) {
            return typeof t == "string" ? t : t(a, f, l);
        }
        var n = function(a) {
            vt(f, a);
            function f(l, d, c) {
                return a.call(this, i(l, d, c)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, Se[e] = n;
    }
    function me(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function wt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Rt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Et(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && wt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (Rt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(me(t, "type"));
        else {
            var a = Et(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(me(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Te.exports.codes = Se;
});
var ne = p((Qr, Me)=>{
    Me.exports = export_default.EventEmitter;
});
var Pe = p((Zr, Le)=>{
    "use strict";
    function Oe(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function St(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Oe(Object(r), !0).forEach(function(i) {
                mt(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Oe(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function mt(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function Tt(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Ae(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function Mt(e, t, r) {
        return t && Ae(e.prototype, t), r && Ae(e, r), e;
    }
    var Ot = export_default, V = Ot.Buffer, At = export_default, ae = At.inspect, Lt = ae && ae.custom || "inspect";
    function Pt(e, t, r) {
        V.prototype.copy.call(e, t, r);
    }
    Le.exports = function() {
        function e() {
            Tt(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return Mt(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return V.alloc(0);
                    for(var i = V.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)Pt(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, l = r > f.length ? f.length : r;
                        if (l === f.length ? a += f : a += f.slice(0, r), r -= l, r === 0) {
                            l === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(l));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = V.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, l = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, l), r -= l, r === 0) {
                            l === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(l));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: Lt,
                value: function(r, i) {
                    return ae(this, St({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var le = p((ei, Ne)=>{
    "use strict";
    function Dt(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __default.nextTick(fe, this, e)) : __default.nextTick(fe, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? __default.nextTick(G, r) : (r._writableState.errorEmitted = !0, __default.nextTick(De, r, a)) : __default.nextTick(De, r, a) : t ? (__default.nextTick(G, r), t(a)) : __default.nextTick(G, r);
        }), this);
    }
    function De(e, t) {
        fe(e, t), G(e);
    }
    function G(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Nt() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function fe(e, t) {
        e.emit("error", t);
    }
    function qt(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    Ne.exports = {
        destroy: Dt,
        undestroy: Nt,
        errorOrDestroy: qt
    };
});
var oe = p((ti, qe)=>{
    "use strict";
    var Ct = N().codes.ERR_INVALID_OPT_VALUE;
    function kt(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function xt(e, t, r, i) {
        var n = kt(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new Ct(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    qe.exports = {
        getHighWaterMark: xt
    };
});
var je = p((ri, xe)=>{
    "use strict";
    var Ce = N().codes.ERR_STREAM_PREMATURE_CLOSE;
    function jt(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function It() {}
    function Wt(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function ke(e, t, r) {
        if (typeof t == "function") return ke(e, null, t);
        t || (t = {}), r = jt(r || It);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || l();
        }, f = e._writableState && e._writableState.finished, l = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, c = function() {
            i = !1, d = !0, n || r.call(e);
        }, L = function(_) {
            r.call(e, _);
        }, y = function() {
            var _;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (_ = new Ce), r.call(e, _);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (_ = new Ce), r.call(e, _);
        }, T = function() {
            e.req.on("finish", l);
        };
        return Wt(e) ? (e.on("complete", l), e.on("abort", y), e.req ? T() : e.on("request", T)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", c), e.on("finish", l), t.error !== !1 && e.on("error", L), e.on("close", y), function() {
            e.removeListener("complete", l), e.removeListener("abort", y), e.removeListener("request", T), e.req && e.req.removeListener("finish", l), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", l), e.removeListener("end", c), e.removeListener("error", L), e.removeListener("close", y);
        };
    }
    xe.exports = ke;
});
var We = p((ii, Ie)=>{
    "use strict";
    var Y;
    function R(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var Ut = je(), E = Symbol("lastResolve"), M = Symbol("lastReject"), W = Symbol("error"), K = Symbol("ended"), O = Symbol("lastPromise"), ue = Symbol("handlePromise"), A = Symbol("stream");
    function S(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function Bt(e) {
        var t = e[E];
        if (t !== null) {
            var r = e[A].read();
            r !== null && (e[O] = null, e[E] = null, e[M] = null, t(S(r, !1)));
        }
    }
    function Ft(e) {
        __default.nextTick(Bt, e);
    }
    function Ht(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[K]) {
                    r(S(void 0, !0));
                    return;
                }
                t[ue](r, i);
            }, i);
        };
    }
    var Vt = Object.getPrototypeOf(function() {}), Gt = Object.setPrototypeOf((Y = {
        get stream () {
            return this[A];
        },
        next: function() {
            var t = this, r = this[W];
            if (r !== null) return Promise.reject(r);
            if (this[K]) return Promise.resolve(S(void 0, !0));
            if (this[A].destroyed) return new Promise(function(f, l) {
                __default.nextTick(function() {
                    t[W] ? l(t[W]) : f(S(void 0, !0));
                });
            });
            var i = this[O], n;
            if (i) n = new Promise(Ht(i, this));
            else {
                var a = this[A].read();
                if (a !== null) return Promise.resolve(S(a, !1));
                n = new Promise(this[ue]);
            }
            return this[O] = n, n;
        }
    }, R(Y, Symbol.asyncIterator, function() {
        return this;
    }), R(Y, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[A].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(S(void 0, !0));
            });
        });
    }), Y), Vt), Yt = function(t) {
        var r, i = Object.create(Gt, (r = {}, R(r, A, {
            value: t,
            writable: !0
        }), R(r, E, {
            value: null,
            writable: !0
        }), R(r, M, {
            value: null,
            writable: !0
        }), R(r, W, {
            value: null,
            writable: !0
        }), R(r, K, {
            value: t._readableState.endEmitted,
            writable: !0
        }), R(r, ue, {
            value: function(a, f) {
                var l = i[A].read();
                l ? (i[O] = null, i[E] = null, i[M] = null, a(S(l, !1))) : (i[E] = a, i[M] = f);
            },
            writable: !0
        }), r));
        return i[O] = null, Ut(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[M];
                a !== null && (i[O] = null, i[E] = null, i[M] = null, a(n)), i[W] = n;
                return;
            }
            var f = i[E];
            f !== null && (i[O] = null, i[E] = null, i[M] = null, f(S(void 0, !0))), i[K] = !0;
        }), t.on("readable", Ft.bind(null, i)), i;
    };
    Ie.exports = Yt;
});
var Be = p((ni, Ue)=>{
    Ue.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var Qe = p((fi, Je)=>{
    "use strict";
    Je.exports = u;
    var q;
    u.ReadableState = He;
    var ai = export_default.EventEmitter, Fe = function(t, r) {
        return t.listeners(r).length;
    }, U = ne(), $ = export_default.Buffer, Kt = __global$.Uint8Array || function() {};
    function $t(e) {
        return $.from(e);
    }
    function Xt(e) {
        return $.isBuffer(e) || e instanceof Kt;
    }
    var se = export_default, o;
    se && se.debuglog ? o = se.debuglog("stream") : o = function() {};
    var zt = Pe(), de = le(), Jt = oe(), Qt = Jt.getHighWaterMark, X = N().codes, Zt = X.ERR_INVALID_ARG_TYPE, er = X.ERR_STREAM_PUSH_AFTER_EOF, tr = X.ERR_METHOD_NOT_IMPLEMENTED, rr = X.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, C, he, ce;
    export_default(u, U);
    var B = de.errorOrDestroy, pe = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function ir(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function He(e, t, r) {
        q = q || k(), e = e || {}, typeof r != "boolean" && (r = t instanceof q), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = Qt(this, e, "readableHighWaterMark", r), this.buffer = new zt, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (C || (C = export_default.StringDecoder), this.decoder = new C(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (q = q || k(), !(this instanceof u)) return new u(e);
        var t = this instanceof q;
        this._readableState = new He(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), U.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = de.destroy;
    u.prototype._undestroy = de.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = $.from(e, t), t = ""), i = !0), Ve(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return Ve(this, e, null, !0, !1);
    };
    function Ve(e, t, r, i, n) {
        o("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, fr(e, a);
        else {
            var f;
            if (n || (f = nr(a, t)), f) B(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== $.prototype && (t = $t(t)), i) a.endEmitted ? B(e, new rr) : be(e, a, t, !0);
            else if (a.ended) B(e, new er);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? be(e, a, t, !1) : _e(e, a)) : be(e, a, t, !1);
            }
            else i || (a.reading = !1, _e(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function be(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && z(e)), _e(e, t);
    }
    function nr(e, t) {
        var r;
        return !Xt(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Zt("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        C || (C = export_default.StringDecoder);
        var t = new C(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var Ge = 1073741824;
    function ar(e) {
        return e >= Ge ? e = Ge : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Ye(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = ar(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        o("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? ye(this) : z(this), null;
        if (e = Ye(e, t), e === 0 && t.ended) return t.length === 0 && ye(this), null;
        var i = t.needReadable;
        o("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, o("length less than watermark", i)), t.ended || t.reading ? (i = !1, o("reading or ended", i)) : i && (o("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Ye(r, t)));
        var n;
        return e > 0 ? n = Xe(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && ye(this)), n !== null && this.emit("data", n), n;
    };
    function fr(e, t) {
        if (o("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? z(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, Ke(e)));
        }
    }
    function z(e) {
        var t = e._readableState;
        o("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o("emitReadable", t.flowing), t.emittedReadable = !0, __default.nextTick(Ke, e));
    }
    function Ke(e) {
        var t = e._readableState;
        o("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, ge(e);
    }
    function _e(e, t) {
        t.readingMore || (t.readingMore = !0, __default.nextTick(lr, e, t));
    }
    function lr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (o("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        B(this, new tr("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, o("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== __default.stdout && e !== __default.stderr, a = n ? l : I;
        i.endEmitted ? __default.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(P, D) {
            o("onunpipe"), P === r && D && D.hasUnpiped === !1 && (D.hasUnpiped = !0, L());
        }
        function l() {
            o("onend"), e.end();
        }
        var d = or(r);
        e.on("drain", d);
        var c = !1;
        function L() {
            o("cleanup"), e.removeListener("close", v), e.removeListener("finish", _), e.removeListener("drain", d), e.removeListener("error", T), e.removeListener("unpipe", f), r.removeListener("end", l), r.removeListener("end", I), r.removeListener("data", y), c = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", y);
        function y(P) {
            o("ondata");
            var D = e.write(P);
            o("dest.write", D), D === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && ze(i.pipes, e) !== -1) && !c && (o("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function T(P) {
            o("onerror", P), I(), e.removeListener("error", T), Fe(e, "error") === 0 && B(e, P);
        }
        ir(e, "error", T);
        function v() {
            e.removeListener("finish", _), I();
        }
        e.once("close", v);
        function _() {
            o("onfinish"), e.removeListener("close", v), I();
        }
        e.once("finish", _);
        function I() {
            o("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (o("pipe resume"), r.resume()), e;
    };
    function or(e) {
        return function() {
            var r = e._readableState;
            o("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Fe(e, "data") && (r.flowing = !0, ge(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = ze(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = U.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o("on readable", i.length, i.reading), i.length ? z(this) : i.reading || __default.nextTick(ur, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = U.prototype.removeListener.call(this, e, t);
        return e === "readable" && __default.nextTick($e, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = U.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && __default.nextTick($e, this), t;
    };
    function $e(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function ur(e) {
        o("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (o("resume"), e.flowing = !e.readableListening, sr(this, e)), e.paused = !1, this;
    };
    function sr(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, __default.nextTick(dr, e, t));
    }
    function dr(e, t) {
        o("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), ge(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return o("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (o("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function ge(e) {
        var t = e._readableState;
        for(o("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (o("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (o("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var l = t.push(f);
                l || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(l) {
            return function() {
                return e[l].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < pe.length; a++)e.on(pe[a], this.emit.bind(this, pe[a]));
        return this._read = function(f) {
            o("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return he === void 0 && (he = We()), he(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = Xe;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function Xe(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function ye(e) {
        var t = e._readableState;
        o("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, __default.nextTick(hr, t, e));
    }
    function hr(e, t) {
        if (o("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return ce === void 0 && (ce = Be()), ce(u, e, t);
    });
    function ze(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var at = p((li, nt)=>{
    "use strict";
    nt.exports = s;
    function Ze(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            Wr(t, e);
        };
    }
    var x;
    s.WritableState = F;
    var cr = {
        deprecate: export_default
    }, et = ne(), J = export_default.Buffer, pr = __global$.Uint8Array || function() {};
    function br(e) {
        return J.from(e);
    }
    function _r(e) {
        return J.isBuffer(e) || e instanceof pr;
    }
    var ve = le(), gr = oe(), yr = gr.getHighWaterMark, m = N().codes, vr = m.ERR_INVALID_ARG_TYPE, wr = m.ERR_METHOD_NOT_IMPLEMENTED, Rr = m.ERR_MULTIPLE_CALLBACK, Er = m.ERR_STREAM_CANNOT_PIPE, Sr = m.ERR_STREAM_DESTROYED, mr = m.ERR_STREAM_NULL_VALUES, Tr = m.ERR_STREAM_WRITE_AFTER_END, Mr = m.ERR_UNKNOWN_ENCODING, j = ve.errorOrDestroy;
    export_default(s, et);
    function Or() {}
    function F(e, t, r) {
        x = x || k(), e = e || {}, typeof r != "boolean" && (r = t instanceof x), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = yr(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            Cr(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ze(this);
    }
    F.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(F.prototype, "buffer", {
                get: cr.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var Q;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Q = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return Q.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof F;
        }
    })) : Q = function(t) {
        return t instanceof this;
    };
    function s(e) {
        x = x || k();
        var t = this instanceof x;
        if (!t && !Q.call(s, this)) return new s(e);
        this._writableState = new F(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), et.call(this);
    }
    s.prototype.pipe = function() {
        j(this, new Er);
    };
    function Ar(e, t) {
        var r = new Tr;
        j(e, r), __default.nextTick(t, r);
    }
    function Lr(e, t, r, i) {
        var n;
        return r === null ? n = new mr : typeof r != "string" && !t.objectMode && (n = new vr("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (j(e, n), __default.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && _r(e);
        return a && !J.isBuffer(e) && (e = br(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = Or), i.ending ? Ar(this, r) : (a || Lr(this, i, e, r)) && (i.pendingcb++, n = Dr(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && rt(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new Mr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function Pr(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = J.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function Dr(e, t, r, i, n, a) {
        if (!r) {
            var f = Pr(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var l = t.objectMode ? 1 : i.length;
        t.length += l;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var c = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else we(e, t, !1, l, i, n, a);
        return d;
    }
    function we(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new Sr("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function Nr(e, t, r, i, n) {
        --t.pendingcb, r ? (__default.nextTick(n, i), __default.nextTick(H, e, t), e._writableState.errorEmitted = !0, j(e, i)) : (n(i), e._writableState.errorEmitted = !0, j(e, i), H(e, t));
    }
    function qr(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Cr(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new Rr;
        if (qr(r), t) Nr(e, r, i, t, n);
        else {
            var a = it(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && rt(e, r), i ? __default.nextTick(tt, e, r, a, n) : tt(e, r, a, n);
        }
    }
    function tt(e, t, r, i) {
        r || kr(e, t), t.pendingcb--, i(), H(e, t);
    }
    function kr(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function rt(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, l = !0; r;)n[f] = r, r.isBuf || (l = !1), r = r.next, f += 1;
            n.allBuffers = l, we(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new Ze(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, c = r.encoding, L = r.callback, y = t.objectMode ? 1 : d.length;
                if (we(e, t, !1, y, d, c, L), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new wr("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || Ir(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function it(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function xr(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && j(e, r), t.prefinished = !0, e.emit("prefinish"), H(e, t);
        });
    }
    function jr(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, __default.nextTick(xr, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function H(e, t) {
        var r = it(t);
        if (r && (jr(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function Ir(e, t, r) {
        t.ending = !0, H(e, t), r && (t.finished ? __default.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function Wr(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = ve.destroy;
    s.prototype._undestroy = ve.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var k = p((oi, lt)=>{
    "use strict";
    var Ur = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    lt.exports = g;
    var ft = Qe(), Re = at();
    export_default(g, ft);
    for(Ee = Ur(Re.prototype), Z = 0; Z < Ee.length; Z++)ee = Ee[Z], g.prototype[ee] || (g.prototype[ee] = Re.prototype[ee]);
    var Ee, ee, Z;
    function g(e) {
        if (!(this instanceof g)) return new g(e);
        ft.call(this, e), Re.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", Br)));
    }
    Object.defineProperty(g.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(g.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(g.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function Br() {
        this._writableState.ended || __default.nextTick(Fr, this);
    }
    function Fr(e) {
        e.end();
    }
    Object.defineProperty(g.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var st = p((ui, ut)=>{
    "use strict";
    ut.exports = w;
    var te = N().codes, Hr = te.ERR_METHOD_NOT_IMPLEMENTED, Vr = te.ERR_MULTIPLE_CALLBACK, Gr = te.ERR_TRANSFORM_ALREADY_TRANSFORMING, Yr = te.ERR_TRANSFORM_WITH_LENGTH_0, re = k();
    export_default(w, re);
    function Kr(e, t) {
        var r = this._transformState;
        r.transforming = !1;
        var i = r.writecb;
        if (i === null) return this.emit("error", new Vr);
        r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
    function w(e) {
        if (!(this instanceof w)) return new w(e);
        re.call(this, e), this._transformState = {
            afterTransform: Kr.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", $r);
    }
    function $r() {
        var e = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
            ot(e, t, r);
        }) : ot(this, null, null);
    }
    w.prototype.push = function(e, t) {
        return this._transformState.needTransform = !1, re.prototype.push.call(this, e, t);
    };
    w.prototype._transform = function(e, t, r) {
        r(new Hr("_transform()"));
    };
    w.prototype._write = function(e, t, r) {
        var i = this._transformState;
        if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
            var n = this._readableState;
            (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
        }
    };
    w.prototype._read = function(e) {
        var t = this._transformState;
        t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
    };
    w.prototype._destroy = function(e, t) {
        re.prototype._destroy.call(this, e, function(r) {
            t(r);
        });
    };
    function ot(e, t, r) {
        if (t) return e.emit("error", t);
        if (r != null && e.push(r), e._writableState.length) throw new Yr;
        if (e._transformState.transforming) throw new Gr;
        return e.push(null);
    }
});
var Xr = yt(st());
var export_default = Xr.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var bt = Object.create;
var ne = Object.defineProperty;
var _t = Object.getOwnPropertyDescriptor;
var gt = Object.getOwnPropertyNames;
var yt = Object.getPrototypeOf, vt = Object.prototype.hasOwnProperty;
var wt = (e)=>ne(e, "__esModule", {
        value: !0
    });
var c = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var Rt = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of gt(t))!vt.call(e, i) && i !== "default" && ne(e, i, {
        get: ()=>t[i],
        enumerable: !(r = _t(t, i)) || r.enumerable
    });
    return e;
}, Et = (e)=>Rt(wt(ne(e != null ? bt(yt(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var q = c((ti, Me)=>{
    "use strict";
    function St(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var me = {};
    function b(e, t, r) {
        r || (r = Error);
        function i(a, f, l) {
            return typeof t == "string" ? t : t(a, f, l);
        }
        var n = function(a) {
            St(f, a);
            function f(l, d, p) {
                return a.call(this, i(l, d, p)) || this;
            }
            return f;
        }(r);
        n.prototype.name = r.name, n.prototype.code = e, me[e] = n;
    }
    function Te(e, t) {
        if (Array.isArray(e)) {
            var r = e.length;
            return e = e.map(function(i) {
                return String(i);
            }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } else return "of ".concat(t, " ").concat(String(e));
    }
    function mt(e, t, r) {
        return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Tt(e, t, r) {
        return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Mt(e, t, r) {
        return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
    }
    b("ERR_INVALID_OPT_VALUE", function(e, t) {
        return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    b("ERR_INVALID_ARG_TYPE", function(e, t, r) {
        var i;
        typeof t == "string" && mt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
        var n;
        if (Tt(e, " argument")) n = "The ".concat(e, " ").concat(i, " ").concat(Te(t, "type"));
        else {
            var a = Mt(e, ".") ? "property" : "argument";
            n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(Te(t, "type"));
        }
        return n += ". Received type ".concat(typeof r), n;
    }, TypeError);
    b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    b("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
        return "The " + e + " method is not implemented";
    });
    b("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    b("ERR_STREAM_DESTROYED", function(e) {
        return "Cannot call " + e + " after a stream was destroyed";
    });
    b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    b("ERR_STREAM_WRITE_AFTER_END", "write after end");
    b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    b("ERR_UNKNOWN_ENCODING", function(e) {
        return "Unknown encoding: " + e;
    }, TypeError);
    b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    Me.exports.codes = me;
});
var ae = c((ri, Oe)=>{
    Oe.exports = export_default.EventEmitter;
});
var De = c((ii, Pe)=>{
    "use strict";
    function Ae(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), r.push.apply(r, i);
        }
        return r;
    }
    function Ot(e) {
        for(var t = 1; t < arguments.length; t++){
            var r = arguments[t] != null ? arguments[t] : {};
            t % 2 ? Ae(Object(r), !0).forEach(function(i) {
                At(e, i, r[i]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ae(Object(r)).forEach(function(i) {
                Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
            });
        }
        return e;
    }
    function At(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    function Lt(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
    }
    function Le(e, t) {
        for(var r = 0; r < t.length; r++){
            var i = t[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
        }
    }
    function Pt(e, t, r) {
        return t && Le(e.prototype, t), r && Le(e, r), e;
    }
    var Dt = export_default, G = Dt.Buffer, qt = export_default, fe = qt.inspect, Nt = fe && fe.custom || "inspect";
    function Ct(e, t, r) {
        G.prototype.copy.call(e, t, r);
    }
    Pe.exports = function() {
        function e() {
            Lt(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return Pt(e, [
            {
                key: "push",
                value: function(r) {
                    var i = {
                        data: r,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
                }
            },
            {
                key: "unshift",
                value: function(r) {
                    var i = {
                        data: r,
                        next: this.head
                    };
                    this.length === 0 && (this.tail = i), this.head = i, ++this.length;
                }
            },
            {
                key: "shift",
                value: function() {
                    if (this.length !== 0) {
                        var r = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
                    }
                }
            },
            {
                key: "clear",
                value: function() {
                    this.head = this.tail = null, this.length = 0;
                }
            },
            {
                key: "join",
                value: function(r) {
                    if (this.length === 0) return "";
                    for(var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data;
                    return n;
                }
            },
            {
                key: "concat",
                value: function(r) {
                    if (this.length === 0) return G.alloc(0);
                    for(var i = G.allocUnsafe(r >>> 0), n = this.head, a = 0; n;)Ct(n.data, i, a), a += n.data.length, n = n.next;
                    return i;
                }
            },
            {
                key: "consume",
                value: function(r, i) {
                    var n;
                    return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
                }
            },
            {
                key: "first",
                value: function() {
                    return this.head.data;
                }
            },
            {
                key: "_getString",
                value: function(r) {
                    var i = this.head, n = 1, a = i.data;
                    for(r -= a.length; i = i.next;){
                        var f = i.data, l = r > f.length ? f.length : r;
                        if (l === f.length ? a += f : a += f.slice(0, r), r -= l, r === 0) {
                            l === f.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = f.slice(l));
                            break;
                        }
                        ++n;
                    }
                    return this.length -= n, a;
                }
            },
            {
                key: "_getBuffer",
                value: function(r) {
                    var i = G.allocUnsafe(r), n = this.head, a = 1;
                    for(n.data.copy(i), r -= n.data.length; n = n.next;){
                        var f = n.data, l = r > f.length ? f.length : r;
                        if (f.copy(i, i.length - r, 0, l), r -= l, r === 0) {
                            l === f.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = f.slice(l));
                            break;
                        }
                        ++a;
                    }
                    return this.length -= a, i;
                }
            },
            {
                key: Nt,
                value: function(r, i) {
                    return fe(this, Ot({}, i, {
                        depth: 0,
                        customInspect: !1
                    }));
                }
            }
        ]), e;
    }();
});
var oe = c((ni, Ne)=>{
    "use strict";
    function kt(e, t) {
        var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
        return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, __default.nextTick(le, this, e)) : __default.nextTick(le, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
            !t && a ? r._writableState ? r._writableState.errorEmitted ? __default.nextTick(Y, r) : (r._writableState.errorEmitted = !0, __default.nextTick(qe, r, a)) : __default.nextTick(qe, r, a) : t ? (__default.nextTick(Y, r), t(a)) : __default.nextTick(Y, r);
        }), this);
    }
    function qe(e, t) {
        le(e, t), Y(e);
    }
    function Y(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function xt() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
    }
    function le(e, t) {
        e.emit("error", t);
    }
    function jt(e, t) {
        var r = e._readableState, i = e._writableState;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    Ne.exports = {
        destroy: kt,
        undestroy: xt,
        errorOrDestroy: jt
    };
});
var ue = c((ai, Ce)=>{
    "use strict";
    var It = q().codes.ERR_INVALID_OPT_VALUE;
    function Wt(e, t, r) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Ut(e, t, r, i) {
        var n = Wt(t, i, r);
        if (n != null) {
            if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
                var a = i ? r : "highWaterMark";
                throw new It(a, n);
            }
            return Math.floor(n);
        }
        return e.objectMode ? 16 : 16 * 1024;
    }
    Ce.exports = {
        getHighWaterMark: Ut
    };
});
var Ie = c((fi, je)=>{
    "use strict";
    var ke = q().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Bt(e) {
        var t = !1;
        return function() {
            if (!t) {
                t = !0;
                for(var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n];
                e.apply(this, i);
            }
        };
    }
    function Ft() {}
    function Ht(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    function xe(e, t, r) {
        if (typeof t == "function") return xe(e, null, t);
        t || (t = {}), r = Bt(r || Ft);
        var i = t.readable || t.readable !== !1 && e.readable, n = t.writable || t.writable !== !1 && e.writable, a = function() {
            e.writable || l();
        }, f = e._writableState && e._writableState.finished, l = function() {
            n = !1, f = !0, i || r.call(e);
        }, d = e._readableState && e._readableState.endEmitted, p = function() {
            i = !1, d = !0, n || r.call(e);
        }, L = function(_) {
            r.call(e, _);
        }, y = function() {
            var _;
            if (i && !d) return (!e._readableState || !e._readableState.ended) && (_ = new ke), r.call(e, _);
            if (n && !f) return (!e._writableState || !e._writableState.ended) && (_ = new ke), r.call(e, _);
        }, T = function() {
            e.req.on("finish", l);
        };
        return Ht(e) ? (e.on("complete", l), e.on("abort", y), e.req ? T() : e.on("request", T)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", p), e.on("finish", l), t.error !== !1 && e.on("error", L), e.on("close", y), function() {
            e.removeListener("complete", l), e.removeListener("abort", y), e.removeListener("request", T), e.req && e.req.removeListener("finish", l), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", l), e.removeListener("end", p), e.removeListener("error", L), e.removeListener("close", y);
        };
    }
    je.exports = xe;
});
var Ue = c((li, We)=>{
    "use strict";
    var K;
    function R(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e;
    }
    var Vt = Ie(), E = Symbol("lastResolve"), M = Symbol("lastReject"), W = Symbol("error"), $ = Symbol("ended"), O = Symbol("lastPromise"), se = Symbol("handlePromise"), A = Symbol("stream");
    function S(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function Gt(e) {
        var t = e[E];
        if (t !== null) {
            var r = e[A].read();
            r !== null && (e[O] = null, e[E] = null, e[M] = null, t(S(r, !1)));
        }
    }
    function Yt(e) {
        __default.nextTick(Gt, e);
    }
    function Kt(e, t) {
        return function(r, i) {
            e.then(function() {
                if (t[$]) {
                    r(S(void 0, !0));
                    return;
                }
                t[se](r, i);
            }, i);
        };
    }
    var $t = Object.getPrototypeOf(function() {}), Xt = Object.setPrototypeOf((K = {
        get stream () {
            return this[A];
        },
        next: function() {
            var t = this, r = this[W];
            if (r !== null) return Promise.reject(r);
            if (this[$]) return Promise.resolve(S(void 0, !0));
            if (this[A].destroyed) return new Promise(function(f, l) {
                __default.nextTick(function() {
                    t[W] ? l(t[W]) : f(S(void 0, !0));
                });
            });
            var i = this[O], n;
            if (i) n = new Promise(Kt(i, this));
            else {
                var a = this[A].read();
                if (a !== null) return Promise.resolve(S(a, !1));
                n = new Promise(this[se]);
            }
            return this[O] = n, n;
        }
    }, R(K, Symbol.asyncIterator, function() {
        return this;
    }), R(K, "return", function() {
        var t = this;
        return new Promise(function(r, i) {
            t[A].destroy(null, function(n) {
                if (n) {
                    i(n);
                    return;
                }
                r(S(void 0, !0));
            });
        });
    }), K), $t), zt = function(t) {
        var r, i = Object.create(Xt, (r = {}, R(r, A, {
            value: t,
            writable: !0
        }), R(r, E, {
            value: null,
            writable: !0
        }), R(r, M, {
            value: null,
            writable: !0
        }), R(r, W, {
            value: null,
            writable: !0
        }), R(r, $, {
            value: t._readableState.endEmitted,
            writable: !0
        }), R(r, se, {
            value: function(a, f) {
                var l = i[A].read();
                l ? (i[O] = null, i[E] = null, i[M] = null, a(S(l, !1))) : (i[E] = a, i[M] = f);
            },
            writable: !0
        }), r));
        return i[O] = null, Vt(t, function(n) {
            if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var a = i[M];
                a !== null && (i[O] = null, i[E] = null, i[M] = null, a(n)), i[W] = n;
                return;
            }
            var f = i[E];
            f !== null && (i[O] = null, i[E] = null, i[M] = null, f(S(void 0, !0))), i[$] = !0;
        }), t.on("readable", Yt.bind(null, i)), i;
    };
    We.exports = zt;
});
var Fe = c((oi, Be)=>{
    Be.exports = function() {
        throw new Error("Readable.from is not available in the browser");
    };
});
var Ze = c((si, Qe)=>{
    "use strict";
    Qe.exports = u;
    var N;
    u.ReadableState = Ve;
    var ui = export_default.EventEmitter, He = function(t, r) {
        return t.listeners(r).length;
    }, U = ae(), X = export_default.Buffer, Jt = __global$.Uint8Array || function() {};
    function Qt(e) {
        return X.from(e);
    }
    function Zt(e) {
        return X.isBuffer(e) || e instanceof Jt;
    }
    var de = export_default, o;
    de && de.debuglog ? o = de.debuglog("stream") : o = function() {};
    var er = De(), he = oe(), tr = ue(), rr = tr.getHighWaterMark, z = q().codes, ir = z.ERR_INVALID_ARG_TYPE, nr = z.ERR_STREAM_PUSH_AFTER_EOF, ar = z.ERR_METHOD_NOT_IMPLEMENTED, fr = z.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, C, ce, pe;
    export_default(u, U);
    var B = he.errorOrDestroy, be = [
        "error",
        "close",
        "destroy",
        "pause",
        "resume"
    ];
    function lr(e, t, r) {
        if (typeof e.prependListener == "function") return e.prependListener(t, r);
        !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [
            r,
            e._events[t]
        ];
    }
    function Ve(e, t, r) {
        N = N || k(), e = e || {}, typeof r != "boolean" && (r = t instanceof N), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = rr(this, e, "readableHighWaterMark", r), this.buffer = new er, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (C || (C = export_default.StringDecoder), this.decoder = new C(e.encoding), this.encoding = e.encoding);
    }
    function u(e) {
        if (N = N || k(), !(this instanceof u)) return new u(e);
        var t = this instanceof N;
        this._readableState = new Ve(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), U.call(this);
    }
    Object.defineProperty(u.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 ? !1 : this._readableState.destroyed;
        },
        set: function(t) {
            !this._readableState || (this._readableState.destroyed = t);
        }
    });
    u.prototype.destroy = he.destroy;
    u.prototype._undestroy = he.undestroy;
    u.prototype._destroy = function(e, t) {
        t(e);
    };
    u.prototype.push = function(e, t) {
        var r = this._readableState, i;
        return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = X.from(e, t), t = ""), i = !0), Ge(this, e, t, !1, i);
    };
    u.prototype.unshift = function(e) {
        return Ge(this, e, null, !0, !1);
    };
    function Ge(e, t, r, i, n) {
        o("readableAddChunk", t);
        var a = e._readableState;
        if (t === null) a.reading = !1, sr(e, a);
        else {
            var f;
            if (n || (f = or(a, t)), f) B(e, f);
            else if (a.objectMode || t && t.length > 0) if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== X.prototype && (t = Qt(t)), i) a.endEmitted ? B(e, new fr) : _e(e, a, t, !0);
            else if (a.ended) B(e, new nr);
            else {
                if (a.destroyed) return !1;
                a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? _e(e, a, t, !1) : ge(e, a)) : _e(e, a, t, !1);
            }
            else i || (a.reading = !1, ge(e, a));
        }
        return !a.ended && (a.length < a.highWaterMark || a.length === 0);
    }
    function _e(e, t, r, i) {
        t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && J(e)), ge(e, t);
    }
    function or(e, t) {
        var r;
        return !Zt(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new ir("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t)), r;
    }
    u.prototype.isPaused = function() {
        return this._readableState.flowing === !1;
    };
    u.prototype.setEncoding = function(e) {
        C || (C = export_default.StringDecoder);
        var t = new C(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        for(var r = this._readableState.buffer.head, i = ""; r !== null;)i += t.write(r.data), r = r.next;
        return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
    };
    var Ye = 1073741824;
    function ur(e) {
        return e >= Ye ? e = Ye : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Ke(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = ur(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
    }
    u.prototype.read = function(e) {
        o("read", e), e = parseInt(e, 10);
        var t = this._readableState, r = e;
        if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? ve(this) : J(this), null;
        if (e = Ke(e, t), e === 0 && t.ended) return t.length === 0 && ve(this), null;
        var i = t.needReadable;
        o("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, o("length less than watermark", i)), t.ended || t.reading ? (i = !1, o("reading or ended", i)) : i && (o("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Ke(r, t)));
        var n;
        return e > 0 ? n = ze(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && ve(this)), n !== null && this.emit("data", n), n;
    };
    function sr(e, t) {
        if (o("onEofChunk"), !t.ended) {
            if (t.decoder) {
                var r = t.decoder.end();
                r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
            }
            t.ended = !0, t.sync ? J(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, $e(e)));
        }
    }
    function J(e) {
        var t = e._readableState;
        o("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o("emitReadable", t.flowing), t.emittedReadable = !0, __default.nextTick($e, e));
    }
    function $e(e) {
        var t = e._readableState;
        o("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, ye(e);
    }
    function ge(e, t) {
        t.readingMore || (t.readingMore = !0, __default.nextTick(dr, e, t));
    }
    function dr(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            var r = t.length;
            if (o("maybeReadMore read 0"), e.read(0), r === t.length) break;
        }
        t.readingMore = !1;
    }
    u.prototype._read = function(e) {
        B(this, new ar("_read()"));
    };
    u.prototype.pipe = function(e, t) {
        var r = this, i = this._readableState;
        switch(i.pipesCount){
            case 0:
                i.pipes = e;
                break;
            case 1:
                i.pipes = [
                    i.pipes,
                    e
                ];
                break;
            default:
                i.pipes.push(e);
                break;
        }
        i.pipesCount += 1, o("pipe count=%d opts=%j", i.pipesCount, t);
        var n = (!t || t.end !== !1) && e !== __default.stdout && e !== __default.stderr, a = n ? l : I;
        i.endEmitted ? __default.nextTick(a) : r.once("end", a), e.on("unpipe", f);
        function f(P, D) {
            o("onunpipe"), P === r && D && D.hasUnpiped === !1 && (D.hasUnpiped = !0, L());
        }
        function l() {
            o("onend"), e.end();
        }
        var d = hr(r);
        e.on("drain", d);
        var p = !1;
        function L() {
            o("cleanup"), e.removeListener("close", v), e.removeListener("finish", _), e.removeListener("drain", d), e.removeListener("error", T), e.removeListener("unpipe", f), r.removeListener("end", l), r.removeListener("end", I), r.removeListener("data", y), p = !0, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && d();
        }
        r.on("data", y);
        function y(P) {
            o("ondata");
            var D = e.write(P);
            o("dest.write", D), D === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && Je(i.pipes, e) !== -1) && !p && (o("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
        }
        function T(P) {
            o("onerror", P), I(), e.removeListener("error", T), He(e, "error") === 0 && B(e, P);
        }
        lr(e, "error", T);
        function v() {
            e.removeListener("finish", _), I();
        }
        e.once("close", v);
        function _() {
            o("onfinish"), e.removeListener("close", v), I();
        }
        e.once("finish", _);
        function I() {
            o("unpipe"), r.unpipe(e);
        }
        return e.emit("pipe", r), i.flowing || (o("pipe resume"), r.resume()), e;
    };
    function hr(e) {
        return function() {
            var r = e._readableState;
            o("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && He(e, "data") && (r.flowing = !0, ye(e));
        };
    }
    u.prototype.unpipe = function(e) {
        var t = this._readableState, r = {
            hasUnpiped: !1
        };
        if (t.pipesCount === 0) return this;
        if (t.pipesCount === 1) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
        if (!e) {
            var i = t.pipes, n = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for(var a = 0; a < n; a++)i[a].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        var f = Je(t.pipes, e);
        return f === -1 ? this : (t.pipes.splice(f, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    u.prototype.on = function(e, t) {
        var r = U.prototype.on.call(this, e, t), i = this._readableState;
        return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o("on readable", i.length, i.reading), i.length ? J(this) : i.reading || __default.nextTick(cr, this)), r;
    };
    u.prototype.addListener = u.prototype.on;
    u.prototype.removeListener = function(e, t) {
        var r = U.prototype.removeListener.call(this, e, t);
        return e === "readable" && __default.nextTick(Xe, this), r;
    };
    u.prototype.removeAllListeners = function(e) {
        var t = U.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && __default.nextTick(Xe, this), t;
    };
    function Xe(e) {
        var t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
    }
    function cr(e) {
        o("readable nexttick read 0"), e.read(0);
    }
    u.prototype.resume = function() {
        var e = this._readableState;
        return e.flowing || (o("resume"), e.flowing = !e.readableListening, pr(this, e)), e.paused = !1, this;
    };
    function pr(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, __default.nextTick(br, e, t));
    }
    function br(e, t) {
        o("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), ye(e), t.flowing && !t.reading && e.read(0);
    }
    u.prototype.pause = function() {
        return o("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (o("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
    };
    function ye(e) {
        var t = e._readableState;
        for(o("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    u.prototype.wrap = function(e) {
        var t = this, r = this._readableState, i = !1;
        e.on("end", function() {
            if (o("wrapped end"), r.decoder && !r.ended) {
                var f = r.decoder.end();
                f && f.length && t.push(f);
            }
            t.push(null);
        }), e.on("data", function(f) {
            if (o("wrapped data"), r.decoder && (f = r.decoder.write(f)), !(r.objectMode && f == null) && !(!r.objectMode && (!f || !f.length))) {
                var l = t.push(f);
                l || (i = !0, e.pause());
            }
        });
        for(var n in e)this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(l) {
            return function() {
                return e[l].apply(e, arguments);
            };
        }(n));
        for(var a = 0; a < be.length; a++)e.on(be[a], this.emit.bind(this, be[a]));
        return this._read = function(f) {
            o("wrapped _read", f), i && (i = !1, e.resume());
        }, this;
    };
    typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
        return ce === void 0 && (ce = Ue()), ce(this);
    });
    Object.defineProperty(u.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._readableState.highWaterMark;
        }
    });
    Object.defineProperty(u.prototype, "readableBuffer", {
        enumerable: !1,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    });
    Object.defineProperty(u.prototype, "readableFlowing", {
        enumerable: !1,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(t) {
            this._readableState && (this._readableState.flowing = t);
        }
    });
    u._fromList = ze;
    Object.defineProperty(u.prototype, "readableLength", {
        enumerable: !1,
        get: function() {
            return this._readableState.length;
        }
    });
    function ze(e, t) {
        if (t.length === 0) return null;
        var r;
        return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function ve(e) {
        var t = e._readableState;
        o("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, __default.nextTick(_r, t, e));
    }
    function _r(e, t) {
        if (o("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
            var r = t._writableState;
            (!r || r.autoDestroy && r.finished) && t.destroy();
        }
    }
    typeof Symbol == "function" && (u.from = function(e, t) {
        return pe === void 0 && (pe = Fe()), pe(u, e, t);
    });
    function Je(e, t) {
        for(var r = 0, i = e.length; r < i; r++)if (e[r] === t) return r;
        return -1;
    }
});
var ft = c((di, at)=>{
    "use strict";
    at.exports = s;
    function et(e) {
        var t = this;
        this.next = null, this.entry = null, this.finish = function() {
            Hr(t, e);
        };
    }
    var x;
    s.WritableState = F;
    var gr = {
        deprecate: export_default
    }, tt = ae(), Q = export_default.Buffer, yr = __global$.Uint8Array || function() {};
    function vr(e) {
        return Q.from(e);
    }
    function wr(e) {
        return Q.isBuffer(e) || e instanceof yr;
    }
    var we = oe(), Rr = ue(), Er = Rr.getHighWaterMark, m = q().codes, Sr = m.ERR_INVALID_ARG_TYPE, mr = m.ERR_METHOD_NOT_IMPLEMENTED, Tr = m.ERR_MULTIPLE_CALLBACK, Mr = m.ERR_STREAM_CANNOT_PIPE, Or = m.ERR_STREAM_DESTROYED, Ar = m.ERR_STREAM_NULL_VALUES, Lr = m.ERR_STREAM_WRITE_AFTER_END, Pr = m.ERR_UNKNOWN_ENCODING, j = we.errorOrDestroy;
    export_default(s, tt);
    function Dr() {}
    function F(e, t, r) {
        x = x || k(), e = e || {}, typeof r != "boolean" && (r = t instanceof x), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = Er(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        var i = e.decodeStrings === !1;
        this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(n) {
            Ir(t, n);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new et(this);
    }
    F.prototype.getBuffer = function() {
        for(var t = this.bufferedRequest, r = []; t;)r.push(t), t = t.next;
        return r;
    };
    (function() {
        try {
            Object.defineProperty(F.prototype, "buffer", {
                get: gr.deprecate(function() {
                    return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
        } catch (e) {}
    })();
    var Z;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Z = Function.prototype[Symbol.hasInstance], Object.defineProperty(s, Symbol.hasInstance, {
        value: function(t) {
            return Z.call(this, t) ? !0 : this !== s ? !1 : t && t._writableState instanceof F;
        }
    })) : Z = function(t) {
        return t instanceof this;
    };
    function s(e) {
        x = x || k();
        var t = this instanceof x;
        if (!t && !Z.call(s, this)) return new s(e);
        this._writableState = new F(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), tt.call(this);
    }
    s.prototype.pipe = function() {
        j(this, new Mr);
    };
    function qr(e, t) {
        var r = new Lr;
        j(e, r), __default.nextTick(t, r);
    }
    function Nr(e, t, r, i) {
        var n;
        return r === null ? n = new Ar : typeof r != "string" && !t.objectMode && (n = new Sr("chunk", [
            "string",
            "Buffer"
        ], r)), n ? (j(e, n), __default.nextTick(i, n), !1) : !0;
    }
    s.prototype.write = function(e, t, r) {
        var i = this._writableState, n = !1, a = !i.objectMode && wr(e);
        return a && !Q.isBuffer(e) && (e = vr(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = Dr), i.ending ? qr(this, r) : (a || Nr(this, i, e, r)) && (i.pendingcb++, n = kr(this, i, a, e, t, r)), n;
    };
    s.prototype.cork = function() {
        this._writableState.corked++;
    };
    s.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && it(this, e));
    };
    s.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = t.toLowerCase()), !([
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw"
        ].indexOf((t + "").toLowerCase()) > -1)) throw new Pr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(s.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    function Cr(e, t, r) {
        return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = Q.from(t, r)), t;
    }
    Object.defineProperty(s.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    function kr(e, t, r, i, n, a) {
        if (!r) {
            var f = Cr(t, i, n);
            i !== f && (r = !0, n = "buffer", i = f);
        }
        var l = t.objectMode ? 1 : i.length;
        t.length += l;
        var d = t.length < t.highWaterMark;
        if (d || (t.needDrain = !0), t.writing || t.corked) {
            var p = t.lastBufferedRequest;
            t.lastBufferedRequest = {
                chunk: i,
                encoding: n,
                isBuf: r,
                callback: a,
                next: null
            }, p ? p.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
        } else Re(e, t, !1, l, i, n, a);
        return d;
    }
    function Re(e, t, r, i, n, a, f) {
        t.writelen = i, t.writecb = f, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new Or("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1;
    }
    function xr(e, t, r, i, n) {
        --t.pendingcb, r ? (__default.nextTick(n, i), __default.nextTick(H, e, t), e._writableState.errorEmitted = !0, j(e, i)) : (n(i), e._writableState.errorEmitted = !0, j(e, i), H(e, t));
    }
    function jr(e) {
        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Ir(e, t) {
        var r = e._writableState, i = r.sync, n = r.writecb;
        if (typeof n != "function") throw new Tr;
        if (jr(r), t) xr(e, r, i, t, n);
        else {
            var a = nt(r) || e.destroyed;
            !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && it(e, r), i ? __default.nextTick(rt, e, r, a, n) : rt(e, r, a, n);
        }
    }
    function rt(e, t, r, i) {
        r || Wr(e, t), t.pendingcb--, i(), H(e, t);
    }
    function Wr(e, t) {
        t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
    }
    function it(e, t) {
        t.bufferProcessing = !0;
        var r = t.bufferedRequest;
        if (e._writev && r && r.next) {
            var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
            a.entry = r;
            for(var f = 0, l = !0; r;)n[f] = r, r.isBuf || (l = !1), r = r.next, f += 1;
            n.allBuffers = l, Re(e, t, !0, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new et(t), t.bufferedRequestCount = 0;
        } else {
            for(; r;){
                var d = r.chunk, p = r.encoding, L = r.callback, y = t.objectMode ? 1 : d.length;
                if (Re(e, t, !1, y, d, p, L), r = r.next, t.bufferedRequestCount--, t.writing) break;
            }
            r === null && (t.lastBufferedRequest = null);
        }
        t.bufferedRequest = r, t.bufferProcessing = !1;
    }
    s.prototype._write = function(e, t, r) {
        r(new mr("_write()"));
    };
    s.prototype._writev = null;
    s.prototype.end = function(e, t, r) {
        var i = this._writableState;
        return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || Fr(this, i, r), this;
    };
    Object.defineProperty(s.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function nt(e) {
        return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function Ur(e, t) {
        e._final(function(r) {
            t.pendingcb--, r && j(e, r), t.prefinished = !0, e.emit("prefinish"), H(e, t);
        });
    }
    function Br(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, __default.nextTick(Ur, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function H(e, t) {
        var r = nt(t);
        if (r && (Br(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
            var i = e._readableState;
            (!i || i.autoDestroy && i.endEmitted) && e.destroy();
        }
        return r;
    }
    function Fr(e, t, r) {
        t.ending = !0, H(e, t), r && (t.finished ? __default.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
    }
    function Hr(e, t, r) {
        var i = e.entry;
        for(e.entry = null; i;){
            var n = i.callback;
            t.pendingcb--, n(r), i = i.next;
        }
        t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(s.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._writableState === void 0 ? !1 : this._writableState.destroyed;
        },
        set: function(t) {
            !this._writableState || (this._writableState.destroyed = t);
        }
    });
    s.prototype.destroy = we.destroy;
    s.prototype._undestroy = we.undestroy;
    s.prototype._destroy = function(e, t) {
        t(e);
    };
});
var k = c((hi, ot)=>{
    "use strict";
    var Vr = Object.keys || function(e) {
        var t = [];
        for(var r in e)t.push(r);
        return t;
    };
    ot.exports = g;
    var lt = Ze(), Ee = ft();
    export_default(g, lt);
    for(Se = Vr(Ee.prototype), ee = 0; ee < Se.length; ee++)te = Se[ee], g.prototype[te] || (g.prototype[te] = Ee.prototype[te]);
    var Se, te, ee;
    function g(e) {
        if (!(this instanceof g)) return new g(e);
        lt.call(this, e), Ee.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", Gr)));
    }
    Object.defineProperty(g.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
            return this._writableState.highWaterMark;
        }
    });
    Object.defineProperty(g.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
            return this._writableState && this._writableState.getBuffer();
        }
    });
    Object.defineProperty(g.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
            return this._writableState.length;
        }
    });
    function Gr() {
        this._writableState.ended || __default.nextTick(Yr, this);
    }
    function Yr(e) {
        e.end();
    }
    Object.defineProperty(g.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(t) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
        }
    });
});
var dt = c((ci, st)=>{
    "use strict";
    st.exports = w;
    var re = q().codes, Kr = re.ERR_METHOD_NOT_IMPLEMENTED, $r = re.ERR_MULTIPLE_CALLBACK, Xr = re.ERR_TRANSFORM_ALREADY_TRANSFORMING, zr = re.ERR_TRANSFORM_WITH_LENGTH_0, ie = k();
    export_default(w, ie);
    function Jr(e, t) {
        var r = this._transformState;
        r.transforming = !1;
        var i = r.writecb;
        if (i === null) return this.emit("error", new $r);
        r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
        var n = this._readableState;
        n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
    function w(e) {
        if (!(this instanceof w)) return new w(e);
        ie.call(this, e), this._transformState = {
            afterTransform: Jr.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Qr);
    }
    function Qr() {
        var e = this;
        typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
            ut(e, t, r);
        }) : ut(this, null, null);
    }
    w.prototype.push = function(e, t) {
        return this._transformState.needTransform = !1, ie.prototype.push.call(this, e, t);
    };
    w.prototype._transform = function(e, t, r) {
        r(new Kr("_transform()"));
    };
    w.prototype._write = function(e, t, r) {
        var i = this._transformState;
        if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
            var n = this._readableState;
            (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
        }
    };
    w.prototype._read = function(e) {
        var t = this._transformState;
        t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
    };
    w.prototype._destroy = function(e, t) {
        ie.prototype._destroy.call(this, e, function(r) {
            t(r);
        });
    };
    function ut(e, t, r) {
        if (t) return e.emit("error", t);
        if (r != null && e.push(r), e._writableState.length) throw new zr;
        if (e._transformState.transforming) throw new Xr;
        return e.push(null);
    }
});
var pt = c((pi, ct)=>{
    "use strict";
    ct.exports = V;
    var ht = dt();
    export_default(V, ht);
    function V(e) {
        if (!(this instanceof V)) return new V(e);
        ht.call(this, e);
    }
    V.prototype._transform = function(e, t, r) {
        r(null, e);
    };
});
var Zr = Et(pt());
var export_default = Zr.default;
var h = Object.create;
var m = Object.defineProperty;
var _ = Object.getOwnPropertyDescriptor;
var q = Object.getOwnPropertyNames;
var L = Object.getPrototypeOf, j = Object.prototype.hasOwnProperty;
var w = (e)=>m(e, "__esModule", {
        value: !0
    });
var y = (e, i)=>()=>(i || e((i = {
            exports: {}
        }).exports, i), i.exports);
var E = (e, i, r)=>{
    if (i && typeof i == "object" || typeof i == "function") for (let o of q(i))!j.call(e, o) && o !== "default" && m(e, o, {
        get: ()=>i[o],
        enumerable: !(r = _(i, o)) || r.enumerable
    });
    return e;
}, x = (e)=>E(w(m(e != null ? h(L(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var v = y((C, p)=>{
    p.exports = n;
    var f = export_default.EventEmitter, S = export_default;
    S(n, f);
    n.Readable = export_default;
    n.Writable = export_default;
    n.Duplex = export_default;
    n.Transform = export_default;
    n.PassThrough = export_default;
    n.finished = export_default;
    n.pipeline = export_default;
    n.Stream = n;
    function n() {
        f.call(this);
    }
    n.prototype.pipe = function(e, i) {
        var r = this;
        function o(u) {
            e.writable && e.write(u) === !1 && r.pause && r.pause();
        }
        r.on("data", o);
        function b() {
            r.readable && r.resume && r.resume();
        }
        e.on("drain", b), !e._isStdio && (!i || i.end !== !1) && (r.on("end", d), r.on("close", c));
        var s = !1;
        function d() {
            s || (s = !0, e.end());
        }
        function c() {
            s || (s = !0, typeof e.destroy == "function" && e.destroy());
        }
        function l(u) {
            if (t(), f.listenerCount(this, "error") === 0) throw u;
        }
        r.on("error", l), e.on("error", l);
        function t() {
            r.removeListener("data", o), e.removeListener("drain", b), r.removeListener("end", d), r.removeListener("close", c), r.removeListener("error", l), e.removeListener("error", l), r.removeListener("end", t), r.removeListener("close", t), e.removeListener("close", t);
        }
        return r.on("end", t), r.on("close", t), e.on("close", t), e.emit("pipe", r), e;
    };
});
var g = x(v());
var export_default = g.default;
var _ = Object.create;
var s = Object.defineProperty;
var d = Object.getOwnPropertyDescriptor;
var c = Object.getOwnPropertyNames;
var l = Object.getPrototypeOf, g = Object.prototype.hasOwnProperty;
var y = (t)=>s(t, "__esModule", {
        value: !0
    });
var w = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var v = (t, r, e)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of c(r))!g.call(t, i) && i !== "default" && s(t, i, {
        get: ()=>r[i],
        enumerable: !(e = d(r, i)) || e.enumerable
    });
    return t;
}, D = (t)=>v(y(s(t != null ? _(l(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var u = w((T, f)=>{
    var h = export_default.Buffer, a = export_default.Transform, m = export_default.StringDecoder, A = export_default;
    function n(t) {
        a.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A(n, a);
    n.prototype.update = function(t, r, e) {
        typeof t == "string" && (t = h.from(t, r));
        var i = this._update(t);
        return this.hashMode ? this : (e && (i = this._toString(i, e)), i);
    };
    n.prototype.setAutoPadding = function() {};
    n.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
    };
    n.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
    };
    n.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
    };
    n.prototype._transform = function(t, r, e) {
        var i;
        try {
            this.hashMode ? this._update(t) : this.push(this._update(t));
        } catch (p) {
            i = p;
        } finally{
            e(i);
        }
    };
    n.prototype._flush = function(t) {
        var r;
        try {
            this.push(this.__final());
        } catch (e) {
            r = e;
        }
        t(r);
    };
    n.prototype._finalOrDigest = function(t) {
        var r = this.__final() || h.alloc(0);
        return t && (r = this._toString(r, t, !0)), r;
    };
    n.prototype._toString = function(t, r, e) {
        if (this._decoder || (this._decoder = new m(r), this._encoding = r), this._encoding !== r) throw new Error("can't switch encodings");
        var i = this._decoder.write(t);
        return e && (i += this._decoder.end()), i;
    };
    f.exports = n;
});
var S = D(u());
var export_default = S.default;
var p = Object.create;
var l = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var b = Object.getOwnPropertyNames;
var d = Object.getPrototypeOf, w = Object.prototype.hasOwnProperty;
var k = (t)=>l(t, "__esModule", {
        value: !0
    });
var m = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var v = (t, e, r)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let i of b(e))!w.call(t, i) && i !== "default" && l(t, i, {
        get: ()=>e[i],
        enumerable: !(r = g(e, i)) || r.enumerable
    });
    return t;
}, y = (t)=>v(k(l(t != null ? p(d(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var c = m((x, a)=>{
    "use strict";
    var n = export_default.Buffer, _ = export_default.Transform, O = export_default;
    function z(t, e) {
        if (!n.isBuffer(t) && typeof t != "string") throw new TypeError(e + " must be a string or a buffer");
    }
    function s(t) {
        _.call(this), this._block = n.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [
            0,
            0,
            0,
            0
        ], this._finalized = !1;
    }
    O(s, _);
    s.prototype._transform = function(t, e, r) {
        var i = null;
        try {
            this.update(t, e);
        } catch (o) {
            i = o;
        }
        r(i);
    };
    s.prototype._flush = function(t) {
        var e = null;
        try {
            this.push(this.digest());
        } catch (r) {
            e = r;
        }
        t(e);
    };
    s.prototype.update = function(t, e) {
        if (z(t, "Data"), this._finalized) throw new Error("Digest already called");
        n.isBuffer(t) || (t = n.from(t, e));
        for(var r = this._block, i = 0; this._blockOffset + t.length - i >= this._blockSize;){
            for(var o = this._blockOffset; o < this._blockSize;)r[o++] = t[i++];
            this._update(), this._blockOffset = 0;
        }
        for(; i < t.length;)r[this._blockOffset++] = t[i++];
        for(var h = 0, f = t.length * 8; f > 0; ++h)this._length[h] += f, f = this._length[h] / 4294967296 | 0, f > 0 && (this._length[h] -= 4294967296 * f);
        return this;
    };
    s.prototype._update = function() {
        throw new Error("_update is not implemented");
    };
    s.prototype.digest = function(t) {
        if (this._finalized) throw new Error("Digest already called");
        this._finalized = !0;
        var e = this._digest();
        t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
        for(var r = 0; r < 4; ++r)this._length[r] = 0;
        return e;
    };
    s.prototype._digest = function() {
        throw new Error("_digest is not implemented");
    };
    a.exports = s;
});
var B = y(c());
var export_default = B.default;
var v = Object.create;
var _ = Object.defineProperty;
var p = Object.getOwnPropertyDescriptor;
var I = Object.getOwnPropertyNames;
var w = Object.getPrototypeOf, E = Object.prototype.hasOwnProperty;
var L = (t)=>_(t, "__esModule", {
        value: !0
    });
var O = (t, i)=>()=>(i || t((i = {
            exports: {}
        }).exports, i), i.exports);
var g = (t, i, e)=>{
    if (i && typeof i == "object" || typeof i == "function") for (let f of I(i))!E.call(t, f) && f !== "default" && _(t, f, {
        get: ()=>i[f],
        enumerable: !(e = p(i, f)) || e.enumerable
    });
    return t;
}, q = (t)=>g(L(_(t != null ? v(w(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var k = O((H, l)=>{
    "use strict";
    var y = export_default, u = export_default, A = export_default.Buffer, B = new Array(16);
    function h() {
        u.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    y(h, u);
    h.prototype._update = function() {
        for(var t = B, i = 0; i < 16; ++i)t[i] = this._block.readInt32LE(i * 4);
        var e = this._a, f = this._b, x = this._c, a = this._d;
        e = c(e, f, x, a, t[0], 3614090360, 7), a = c(a, e, f, x, t[1], 3905402710, 12), x = c(x, a, e, f, t[2], 606105819, 17), f = c(f, x, a, e, t[3], 3250441966, 22), e = c(e, f, x, a, t[4], 4118548399, 7), a = c(a, e, f, x, t[5], 1200080426, 12), x = c(x, a, e, f, t[6], 2821735955, 17), f = c(f, x, a, e, t[7], 4249261313, 22), e = c(e, f, x, a, t[8], 1770035416, 7), a = c(a, e, f, x, t[9], 2336552879, 12), x = c(x, a, e, f, t[10], 4294925233, 17), f = c(f, x, a, e, t[11], 2304563134, 22), e = c(e, f, x, a, t[12], 1804603682, 7), a = c(a, e, f, x, t[13], 4254626195, 12), x = c(x, a, e, f, t[14], 2792965006, 17), f = c(f, x, a, e, t[15], 1236535329, 22), e = s(e, f, x, a, t[1], 4129170786, 5), a = s(a, e, f, x, t[6], 3225465664, 9), x = s(x, a, e, f, t[11], 643717713, 14), f = s(f, x, a, e, t[0], 3921069994, 20), e = s(e, f, x, a, t[5], 3593408605, 5), a = s(a, e, f, x, t[10], 38016083, 9), x = s(x, a, e, f, t[15], 3634488961, 14), f = s(f, x, a, e, t[4], 3889429448, 20), e = s(e, f, x, a, t[9], 568446438, 5), a = s(a, e, f, x, t[14], 3275163606, 9), x = s(x, a, e, f, t[3], 4107603335, 14), f = s(f, x, a, e, t[8], 1163531501, 20), e = s(e, f, x, a, t[13], 2850285829, 5), a = s(a, e, f, x, t[2], 4243563512, 9), x = s(x, a, e, f, t[7], 1735328473, 14), f = s(f, x, a, e, t[12], 2368359562, 20), e = r(e, f, x, a, t[5], 4294588738, 4), a = r(a, e, f, x, t[8], 2272392833, 11), x = r(x, a, e, f, t[11], 1839030562, 16), f = r(f, x, a, e, t[14], 4259657740, 23), e = r(e, f, x, a, t[1], 2763975236, 4), a = r(a, e, f, x, t[4], 1272893353, 11), x = r(x, a, e, f, t[7], 4139469664, 16), f = r(f, x, a, e, t[10], 3200236656, 23), e = r(e, f, x, a, t[13], 681279174, 4), a = r(a, e, f, x, t[0], 3936430074, 11), x = r(x, a, e, f, t[3], 3572445317, 16), f = r(f, x, a, e, t[6], 76029189, 23), e = r(e, f, x, a, t[9], 3654602809, 4), a = r(a, e, f, x, t[12], 3873151461, 11), x = r(x, a, e, f, t[15], 530742520, 16), f = r(f, x, a, e, t[2], 3299628645, 23), e = d(e, f, x, a, t[0], 4096336452, 6), a = d(a, e, f, x, t[7], 1126891415, 10), x = d(x, a, e, f, t[14], 2878612391, 15), f = d(f, x, a, e, t[5], 4237533241, 21), e = d(e, f, x, a, t[12], 1700485571, 6), a = d(a, e, f, x, t[3], 2399980690, 10), x = d(x, a, e, f, t[10], 4293915773, 15), f = d(f, x, a, e, t[1], 2240044497, 21), e = d(e, f, x, a, t[8], 1873313359, 6), a = d(a, e, f, x, t[15], 4264355552, 10), x = d(x, a, e, f, t[6], 2734768916, 15), f = d(f, x, a, e, t[13], 1309151649, 21), e = d(e, f, x, a, t[4], 4149444226, 6), a = d(a, e, f, x, t[11], 3174756917, 10), x = d(x, a, e, f, t[2], 718787259, 15), f = d(f, x, a, e, t[9], 3951481745, 21), this._a = this._a + e | 0, this._b = this._b + f | 0, this._c = this._c + x | 0, this._d = this._d + a | 0;
    };
    h.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t = A.allocUnsafe(16);
        return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function n(t, i) {
        return t << i | t >>> 32 - i;
    }
    function c(t, i, e, f, x, a, b) {
        return n(t + (i & e | ~i & f) + x + a | 0, b) + i | 0;
    }
    function s(t, i, e, f, x, a, b) {
        return n(t + (i & f | e & ~f) + x + a | 0, b) + i | 0;
    }
    function r(t, i, e, f, x, a, b) {
        return n(t + (i ^ e ^ f) + x + a | 0, b) + i | 0;
    }
    function d(t, i, e, f, x, a, b) {
        return n(t + (e ^ (i | ~f)) + x + a | 0, b) + i | 0;
    }
    l.exports = h;
});
var U = q(k());
var export_default = U.default;
var B = Object.create;
var v = Object.defineProperty;
var k = Object.getOwnPropertyDescriptor;
var M = Object.getOwnPropertyNames;
var q = Object.getPrototypeOf, w = Object.prototype.hasOwnProperty;
var x = (r)=>v(r, "__esModule", {
        value: !0
    });
var E = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var _ = (r, e, l)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let f of M(e))!w.call(r, f) && f !== "default" && v(r, f, {
        get: ()=>e[f],
        enumerable: !(l = k(e, f)) || l.enumerable
    });
    return r;
}, j = (r)=>_(x(v(r != null ? B(q(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var c = E((T, b)=>{
    var a = export_default.Buffer, D = export_default;
    function K(r, e, l, f) {
        if (a.isBuffer(r) || (r = a.from(r, "binary")), e && (a.isBuffer(e) || (e = a.from(e, "binary")), e.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length");
        for(var o = l / 8, y = a.alloc(o), u = a.alloc(f || 0), t = a.alloc(0); o > 0 || f > 0;){
            var n = new D;
            n.update(t), n.update(r), e && n.update(e), t = n.digest();
            var i = 0;
            if (o > 0) {
                var h = y.length - o;
                i = Math.min(o, t.length), t.copy(y, h, 0, i), o -= i;
            }
            if (i < t.length && f > 0) {
                var p = u.length - f, g = Math.min(f, t.length - i);
                t.copy(u, p, i, i + g), f -= g;
            }
        }
        return t.fill(0), {
            key: y,
            iv: u
        };
    }
    b.exports = K;
});
var P = j(c());
var export_default = P.default;
var l = Object.create;
var o = Object.defineProperty;
var x = Object.getOwnPropertyDescriptor;
var g = Object.getOwnPropertyNames;
var v = Object.getPrototypeOf, m = Object.prototype.hasOwnProperty;
var p = (r)=>o(r, "__esModule", {
        value: !0
    });
var b = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var c = (r, e, t)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let f of g(e))!m.call(r, f) && f !== "default" && o(r, f, {
        get: ()=>e[f],
        enumerable: !(t = x(e, f)) || t.enumerable
    });
    return r;
}, d = (r)=>c(p(o(r != null ? l(v(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var h = b((B, a)=>{
    a.exports = function(e, t) {
        for(var f = Math.min(e.length, t.length), u = new ut(f), n = 0; n < f; ++n)u[n] = e[n] ^ t[n];
        return u;
    };
});
var s = d(h());
var export_default = s.default;
var Ge = Object.create;
var O = Object.defineProperty;
var ze = Object.getOwnPropertyDescriptor;
var He = Object.getOwnPropertyNames;
var Ke = Object.getPrototypeOf, Le = Object.prototype.hasOwnProperty;
var Pe = (e)=>O(e, "__esModule", {
        value: !0
    });
var l = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var Ze = (e, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of He(r))!Le.call(e, i) && i !== "default" && O(e, i, {
        get: ()=>r[i],
        enumerable: !(t = ze(r, i)) || t.enumerable
    });
    return e;
}, ae = (e)=>Ze(Pe(O(e != null ? Ge(Ke(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var ce = l((M)=>{
    M.encrypt = function(e, r) {
        return e._cipher.encryptBlock(r);
    };
    M.decrypt = function(e, r) {
        return e._cipher.decryptBlock(r);
    };
});
var he = l((G)=>{
    var ne = export_default;
    G.encrypt = function(e, r) {
        var t = ne(r, e._prev);
        return e._prev = e._cipher.encryptBlock(t), e._prev;
    };
    G.decrypt = function(e, r) {
        var t = e._prev;
        e._prev = r;
        var i = e._cipher.decryptBlock(r);
        return ne(i, t);
    };
});
var se = l((pe)=>{
    var U = export_default.Buffer, We = export_default;
    function oe(e, r, t) {
        var i = r.length, a = We(r, e._cache);
        return e._cache = e._cache.slice(i), e._prev = U.concat([
            e._prev,
            t ? r : a
        ]), a;
    }
    pe.encrypt = function(e, r, t) {
        for(var i = U.allocUnsafe(0), a; r.length;)if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = U.allocUnsafe(0)), e._cache.length <= r.length) a = e._cache.length, i = U.concat([
            i,
            oe(e, r.slice(0, a), t)
        ]), r = r.slice(a);
        else {
            i = U.concat([
                i,
                oe(e, r, t)
            ]);
            break;
        }
        return i;
    };
});
var ue = l((fe)=>{
    var z = export_default.Buffer;
    function Je(e, r, t) {
        var i = e._cipher.encryptBlock(e._prev), a = i[0] ^ r;
        return e._prev = z.concat([
            e._prev.slice(1),
            z.from([
                t ? r : a
            ])
        ]), a;
    }
    fe.encrypt = function(e, r, t) {
        for(var i = r.length, a = z.allocUnsafe(i), c = -1; ++c < i;)a[c] = Je(e, r[c], t);
        return a;
    };
});
var le = l((ve)=>{
    var D = export_default.Buffer;
    function Qe(e, r, t) {
        for(var i, a = -1, c = 8, n = 0, h, s; ++a < c;)i = e._cipher.encryptBlock(e._prev), h = r & 1 << 7 - a ? 128 : 0, s = i[0] ^ h, n += (s & 128) >> a % 8, e._prev = Ye(e._prev, t ? h : s);
        return n;
    }
    function Ye(e, r) {
        var t = e.length, i = -1, a = D.allocUnsafe(e.length);
        for(e = D.concat([
            e,
            D.from([
                r
            ])
        ]); ++i < t;)a[i] = e[i] << 1 | e[i + 1] >> 7;
        return a;
    }
    ve.encrypt = function(e, r, t) {
        for(var i = r.length, a = D.allocUnsafe(i), c = -1; ++c < i;)a[c] = Qe(e, r[c], t);
        return a;
    };
});
var ye = l((_e)=>{
    var $e = export_default;
    function je(e) {
        return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
    }
    _e.encrypt = function(e, r) {
        for(; e._cache.length < r.length;)e._cache = ut.concat([
            e._cache,
            je(e)
        ]);
        var t = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), $e(r, t);
    };
});
var H = l((zr, de)=>{
    function er(e) {
        for(var r = e.length, t; r--;)if (t = e.readUInt8(r), t === 255) e.writeUInt8(0, r);
        else {
            t++, e.writeUInt8(t, r);
            break;
        }
    }
    de.exports = er;
});
var L = l((me)=>{
    var rr = export_default, ge = export_default.Buffer, tr = H();
    function ir(e) {
        var r = e._cipher.encryptBlockRaw(e._prev);
        return tr(e._prev), r;
    }
    var K = 16;
    me.encrypt = function(e, r) {
        var t = Math.ceil(r.length / K), i = e._cache.length;
        e._cache = ge.concat([
            e._cache,
            ge.allocUnsafe(t * K)
        ]);
        for(var a = 0; a < t; a++){
            var c = ir(e), n = i + a * K;
            e._cache.writeUInt32BE(c[0], n + 0), e._cache.writeUInt32BE(c[1], n + 4), e._cache.writeUInt32BE(c[2], n + 8), e._cache.writeUInt32BE(c[3], n + 12);
        }
        var h = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), rr(r, h);
    };
});
var P = l((Kr, ar)=>{
    ar.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
});
var W = l((Lr, Be)=>{
    var cr = {
        ECB: ce(),
        CBC: he(),
        CFB: se(),
        CFB8: ue(),
        CFB1: le(),
        OFB: ye(),
        CTR: L(),
        GCM: L()
    }, F = P();
    for(Z in F)F[Z].module = cr[F[Z].mode];
    var Z;
    Be.exports = F;
});
var I = l((Pr, Ee)=>{
    var R = export_default.Buffer;
    function J(e) {
        R.isBuffer(e) || (e = R.from(e));
        for(var r = e.length / 4 | 0, t = new Array(r), i = 0; i < r; i++)t[i] = e.readUInt32BE(i * 4);
        return t;
    }
    function Q(e) {
        for(var r = 0; r < e.length; e++)e[r] = 0;
    }
    function we(e, r, t, i, a) {
        for(var c = t[0], n = t[1], h = t[2], s = t[3], p = e[0] ^ r[0], u = e[1] ^ r[1], y = e[2] ^ r[2], d = e[3] ^ r[3], f, C, b, x, w = 4, ie = 1; ie < a; ie++)f = c[p >>> 24] ^ n[u >>> 16 & 255] ^ h[y >>> 8 & 255] ^ s[d & 255] ^ r[w++], C = c[u >>> 24] ^ n[y >>> 16 & 255] ^ h[d >>> 8 & 255] ^ s[p & 255] ^ r[w++], b = c[y >>> 24] ^ n[d >>> 16 & 255] ^ h[p >>> 8 & 255] ^ s[u & 255] ^ r[w++], x = c[d >>> 24] ^ n[p >>> 16 & 255] ^ h[u >>> 8 & 255] ^ s[y & 255] ^ r[w++], p = f, u = C, y = b, d = x;
        return f = (i[p >>> 24] << 24 | i[u >>> 16 & 255] << 16 | i[y >>> 8 & 255] << 8 | i[d & 255]) ^ r[w++], C = (i[u >>> 24] << 24 | i[y >>> 16 & 255] << 16 | i[d >>> 8 & 255] << 8 | i[p & 255]) ^ r[w++], b = (i[y >>> 24] << 24 | i[d >>> 16 & 255] << 16 | i[p >>> 8 & 255] << 8 | i[u & 255]) ^ r[w++], x = (i[d >>> 24] << 24 | i[p >>> 16 & 255] << 16 | i[u >>> 8 & 255] << 8 | i[y & 255]) ^ r[w++], f = f >>> 0, C = C >>> 0, b = b >>> 0, x = x >>> 0, [
            f,
            C,
            b,
            x
        ];
    }
    var nr = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], v = function() {
        for(var e = new Array(256), r = 0; r < 256; r++)r < 128 ? e[r] = r << 1 : e[r] = r << 1 ^ 283;
        for(var t = [], i = [], a = [
            [],
            [],
            [],
            []
        ], c = [
            [],
            [],
            [],
            []
        ], n = 0, h = 0, s = 0; s < 256; ++s){
            var p = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;
            p = p >>> 8 ^ p & 255 ^ 99, t[n] = p, i[p] = n;
            var u = e[n], y = e[u], d = e[y], f = e[p] * 257 ^ p * 16843008;
            a[0][n] = f << 24 | f >>> 8, a[1][n] = f << 16 | f >>> 16, a[2][n] = f << 8 | f >>> 24, a[3][n] = f, f = d * 16843009 ^ y * 65537 ^ u * 257 ^ n * 16843008, c[0][p] = f << 24 | f >>> 8, c[1][p] = f << 16 | f >>> 16, c[2][p] = f << 8 | f >>> 24, c[3][p] = f, n === 0 ? n = h = 1 : (n = u ^ e[e[e[d ^ u]]], h ^= e[e[h]]);
        }
        return {
            SBOX: t,
            INV_SBOX: i,
            SUB_MIX: a,
            INV_SUB_MIX: c
        };
    }();
    function g(e) {
        this._key = J(e), this._reset();
    }
    g.blockSize = 4 * 4;
    g.keySize = 256 / 8;
    g.prototype.blockSize = g.blockSize;
    g.prototype.keySize = g.keySize;
    g.prototype._reset = function() {
        for(var e = this._key, r = e.length, t = r + 6, i = (t + 1) * 4, a = [], c = 0; c < r; c++)a[c] = e[c];
        for(c = r; c < i; c++){
            var n = a[c - 1];
            c % r == 0 ? (n = n << 8 | n >>> 24, n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255], n ^= nr[c / r | 0] << 24) : r > 6 && c % r == 4 && (n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255]), a[c] = a[c - r] ^ n;
        }
        for(var h = [], s = 0; s < i; s++){
            var p = i - s, u = a[p - (s % 4 ? 0 : 4)];
            s < 4 || p <= 4 ? h[s] = u : h[s] = v.INV_SUB_MIX[0][v.SBOX[u >>> 24]] ^ v.INV_SUB_MIX[1][v.SBOX[u >>> 16 & 255]] ^ v.INV_SUB_MIX[2][v.SBOX[u >>> 8 & 255]] ^ v.INV_SUB_MIX[3][v.SBOX[u & 255]];
        }
        this._nRounds = t, this._keySchedule = a, this._invKeySchedule = h;
    };
    g.prototype.encryptBlockRaw = function(e) {
        return e = J(e), we(e, this._keySchedule, v.SUB_MIX, v.SBOX, this._nRounds);
    };
    g.prototype.encryptBlock = function(e) {
        var r = this.encryptBlockRaw(e), t = R.allocUnsafe(16);
        return t.writeUInt32BE(r[0], 0), t.writeUInt32BE(r[1], 4), t.writeUInt32BE(r[2], 8), t.writeUInt32BE(r[3], 12), t;
    };
    g.prototype.decryptBlock = function(e) {
        e = J(e);
        var r = e[1];
        e[1] = e[3], e[3] = r;
        var t = we(e, this._invKeySchedule, v.INV_SUB_MIX, v.INV_SBOX, this._nRounds), i = R.allocUnsafe(16);
        return i.writeUInt32BE(t[0], 0), i.writeUInt32BE(t[3], 4), i.writeUInt32BE(t[2], 8), i.writeUInt32BE(t[1], 12), i;
    };
    g.prototype.scrub = function() {
        Q(this._keySchedule), Q(this._invKeySchedule), Q(this._key);
    };
    Ee.exports.AES = g;
});
var xe = l((Zr, be)=>{
    var S = export_default.Buffer, hr = S.alloc(16, 0);
    function or(e) {
        return [
            e.readUInt32BE(0),
            e.readUInt32BE(4),
            e.readUInt32BE(8),
            e.readUInt32BE(12)
        ];
    }
    function Ce(e) {
        var r = S.allocUnsafe(16);
        return r.writeUInt32BE(e[0] >>> 0, 0), r.writeUInt32BE(e[1] >>> 0, 4), r.writeUInt32BE(e[2] >>> 0, 8), r.writeUInt32BE(e[3] >>> 0, 12), r;
    }
    function k(e) {
        this.h = e, this.state = S.alloc(16, 0), this.cache = S.allocUnsafe(0);
    }
    k.prototype.ghash = function(e) {
        for(var r = -1; ++r < e.length;)this.state[r] ^= e[r];
        this._multiply();
    };
    k.prototype._multiply = function() {
        for(var e = or(this.h), r = [
            0,
            0,
            0,
            0
        ], t, i, a, c = -1; ++c < 128;){
            for(i = (this.state[~~(c / 8)] & 1 << 7 - c % 8) != 0, i && (r[0] ^= e[0], r[1] ^= e[1], r[2] ^= e[2], r[3] ^= e[3]), a = (e[3] & 1) != 0, t = 3; t > 0; t--)e[t] = e[t] >>> 1 | (e[t - 1] & 1) << 31;
            e[0] = e[0] >>> 1, a && (e[0] = e[0] ^ 225 << 24);
        }
        this.state = Ce(r);
    };
    k.prototype.update = function(e) {
        this.cache = S.concat([
            this.cache,
            e
        ]);
        for(var r; this.cache.length >= 16;)r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(r);
    };
    k.prototype.final = function(e, r) {
        return this.cache.length && this.ghash(S.concat([
            this.cache,
            hr
        ], 16)), this.ghash(Ce([
            0,
            e,
            0,
            r
        ])), this.state;
    };
    be.exports = k;
});
var Y = l((Wr, Ue)=>{
    var pr = I(), _ = export_default.Buffer, Se = export_default, sr = export_default, Ae = xe(), fr = export_default, ur = H();
    function vr(e, r) {
        var t = 0;
        e.length !== r.length && t++;
        for(var i = Math.min(e.length, r.length), a = 0; a < i; ++a)t += e[a] ^ r[a];
        return t;
    }
    function lr(e, r, t) {
        if (r.length === 12) return e._finID = _.concat([
            r,
            _.from([
                0,
                0,
                0,
                1
            ])
        ]), _.concat([
            r,
            _.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var i = new Ae(t), a = r.length, c = a % 16;
        i.update(r), c && (c = 16 - c, i.update(_.alloc(c, 0))), i.update(_.alloc(8, 0));
        var n = a * 8, h = _.alloc(8);
        h.writeUIntBE(n, 0, 8), i.update(h), e._finID = i.state;
        var s = _.from(e._finID);
        return ur(s), s;
    }
    function E(e, r, t, i) {
        Se.call(this);
        var a = _.alloc(4, 0);
        this._cipher = new pr.AES(r);
        var c = this._cipher.encryptBlock(a);
        this._ghash = new Ae(c), t = lr(this, t, c), this._prev = _.from(t), this._cache = _.allocUnsafe(0), this._secCache = _.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
    }
    sr(E, Se);
    E.prototype._update = function(e) {
        if (!this._called && this._alen) {
            var r = 16 - this._alen % 16;
            r < 16 && (r = _.alloc(r, 0), this._ghash.update(r));
        }
        this._called = !0;
        var t = this._mode.encrypt(this, e);
        return this._decrypt ? this._ghash.update(e) : this._ghash.update(t), this._len += e.length, t;
    };
    E.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var e = fr(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && vr(e, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = e, this._cipher.scrub();
    };
    E.prototype.getAuthTag = function() {
        if (this._decrypt || !_.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    };
    E.prototype.setAuthTag = function(r) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = r;
    };
    E.prototype.setAAD = function(r) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(r), this._alen += r.length;
    };
    Ue.exports = E;
});
var j = l((Jr, ke)=>{
    var _r = I(), $ = export_default.Buffer, Ie = export_default, yr = export_default;
    function X(e, r, t, i) {
        Ie.call(this), this._cipher = new _r.AES(r), this._prev = $.from(t), this._cache = $.allocUnsafe(0), this._secCache = $.allocUnsafe(0), this._decrypt = i, this._mode = e;
    }
    yr(X, Ie);
    X.prototype._update = function(e) {
        return this._mode.encrypt(this, e, this._decrypt);
    };
    X.prototype._final = function() {
        this._cipher.scrub();
    };
    ke.exports = X;
});
var Fe = l((ee)=>{
    var qe = W(), dr = Y(), B = export_default.Buffer, gr = j(), Te = export_default, mr = I(), Br = export_default, wr = export_default;
    function q(e, r, t) {
        Te.call(this), this._cache = new N, this._cipher = new mr.AES(r), this._prev = B.from(t), this._mode = e, this._autopadding = !0;
    }
    wr(q, Te);
    q.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get();)t = this._mode.encrypt(this, r), i.push(t);
        return B.concat(i);
    };
    var Er = B.alloc(16, 16);
    q.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
        if (!e.equals(Er)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    q.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function N() {
        this.cache = B.allocUnsafe(0);
    }
    N.prototype.add = function(e) {
        this.cache = B.concat([
            this.cache,
            e
        ]);
    };
    N.prototype.get = function() {
        if (this.cache.length > 15) {
            var e = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), e;
        }
        return null;
    };
    N.prototype.flush = function() {
        for(var e = 16 - this.cache.length, r = B.allocUnsafe(e), t = -1; ++t < e;)r.writeUInt8(e, t);
        return B.concat([
            this.cache,
            r
        ]);
    };
    function De(e, r, t) {
        var i = qe[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof r == "string" && (r = B.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        if (typeof t == "string" && (t = B.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        return i.type === "stream" ? new gr(i.module, r, t) : i.type === "auth" ? new dr(i.module, r, t) : new q(i.module, r, t);
    }
    function Cr(e, r) {
        var t = qe[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Br(r, !1, t.key, t.iv);
        return De(e, i.key, i.iv);
    }
    ee.createCipheriv = De;
    ee.createCipher = Cr;
});
var Ve = l((re)=>{
    var br = Y(), A = export_default.Buffer, Re = W(), xr = j(), Xe = export_default, Sr = I(), Ar = export_default, Ur = export_default;
    function T(e, r, t) {
        Xe.call(this), this._cache = new V, this._last = void 0, this._cipher = new Sr.AES(r), this._prev = A.from(t), this._mode = e, this._autopadding = !0;
    }
    Ur(T, Xe);
    T.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get(this._autopadding);)t = this._mode.decrypt(this, r), i.push(t);
        return A.concat(i);
    };
    T.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return Ir(this._mode.decrypt(this, e));
        if (e) throw new Error("data not multiple of block length");
    };
    T.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function V() {
        this.cache = A.allocUnsafe(0);
    }
    V.prototype.add = function(e) {
        this.cache = A.concat([
            this.cache,
            e
        ]);
    };
    V.prototype.get = function(e) {
        var r;
        if (e) {
            if (this.cache.length > 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        } else if (this.cache.length >= 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        return null;
    };
    V.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function Ir(e) {
        var r = e[15];
        if (r < 1 || r > 16) throw new Error("unable to decrypt data");
        for(var t = -1; ++t < r;)if (e[t + (16 - r)] !== r) throw new Error("unable to decrypt data");
        if (r !== 16) return e.slice(0, 16 - r);
    }
    function Ne(e, r, t) {
        var i = Re[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof t == "string" && (t = A.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        if (typeof r == "string" && (r = A.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        return i.type === "stream" ? new xr(i.module, r, t, !0) : i.type === "auth" ? new br(i.module, r, t, !0) : new T(i.module, r, t);
    }
    function kr(e, r) {
        var t = Re[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Ar(r, !1, t.key, t.iv);
        return Ne(e, i.key, i.iv);
    }
    re.createDecipher = kr;
    re.createDecipheriv = Ne;
});
var te = l((m)=>{
    var Oe = Fe(), Me = Ve(), qr = P();
    function Tr() {
        return Object.keys(qr);
    }
    m.createCipher = m.Cipher = Oe.createCipher;
    m.createCipheriv = m.Cipheriv = Oe.createCipheriv;
    m.createDecipher = m.Decipher = Me.createDecipher;
    m.createDecipheriv = m.Decipheriv = Me.createDecipheriv;
    m.listCiphers = m.getCiphers = Tr;
});
var Dr = ae(te()), Fr = ae(te()), { createCipher: jr , Cipher: et , createCipheriv: rt , Cipheriv: tt , createDecipher: it , Decipher: at , createDecipheriv: ct , Decipheriv: nt , listCiphers: ht , getCiphers: ot  } = Dr;
var export_default = Fr.default;
var o = Object.create;
var a = Object.defineProperty;
var s = Object.getOwnPropertyDescriptor;
var f = Object.getOwnPropertyNames;
var i = Object.getPrototypeOf, m = Object.prototype.hasOwnProperty;
var p = (e)=>a(e, "__esModule", {
        value: !0
    });
var h = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var x = (e, r, d)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of f(r))!m.call(e, t) && t !== "default" && a(e, t, {
        get: ()=>r[t],
        enumerable: !(d = s(r, t)) || d.enumerable
    });
    return e;
}, g = (e)=>x(p(a(e != null ? o(i(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var n = h((v, u)=>{
    var j = export_default;
    u.exports = function(e) {
        return new j().update(e).digest();
    };
});
var l = g(n());
var export_default = l.default;
var H = Object.create;
var L = Object.defineProperty;
var M = Object.getOwnPropertyDescriptor;
var P = Object.getOwnPropertyNames;
var Y = Object.getPrototypeOf, C = Object.prototype.hasOwnProperty;
var F = (t)=>L(t, "__esModule", {
        value: !0
    });
var G = (t, r)=>()=>(r || t((r = {
            exports: {}
        }).exports, r), r.exports);
var J = (t, r, a)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let s of P(r))!C.call(t, s) && s !== "default" && L(t, s, {
        get: ()=>r[s],
        enumerable: !(a = M(r, s)) || a.enumerable
    });
    return t;
}, K = (t)=>J(F(L(t != null ? H(Y(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var U = G((V, z)=>{
    "use strict";
    var g = export_default.Buffer, N = export_default, q = export_default, Q = new Array(16), d = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], x = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], k = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], p = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ], w = [
        0,
        1518500249,
        1859775393,
        2400959708,
        2840853838
    ], E = [
        1352829926,
        1548603684,
        1836072691,
        2053994217,
        0
    ];
    function I() {
        q.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    N(I, q);
    I.prototype._update = function() {
        for(var t = Q, r = 0; r < 16; ++r)t[r] = this._block.readInt32LE(r * 4);
        for(var a = this._a | 0, s = this._b | 0, h = this._c | 0, i = this._d | 0, f = this._e | 0, _ = this._a | 0, n = this._b | 0, c = this._c | 0, o = this._d | 0, l = this._e | 0, e = 0; e < 80; e += 1){
            var b, v;
            e < 16 ? (b = y(a, s, h, i, f, t[d[e]], w[0], k[e]), v = m(_, n, c, o, l, t[x[e]], E[0], p[e])) : e < 32 ? (b = A(a, s, h, i, f, t[d[e]], w[1], k[e]), v = R(_, n, c, o, l, t[x[e]], E[1], p[e])) : e < 48 ? (b = B(a, s, h, i, f, t[d[e]], w[2], k[e]), v = B(_, n, c, o, l, t[x[e]], E[2], p[e])) : e < 64 ? (b = R(a, s, h, i, f, t[d[e]], w[3], k[e]), v = A(_, n, c, o, l, t[x[e]], E[3], p[e])) : (b = m(a, s, h, i, f, t[d[e]], w[4], k[e]), v = y(_, n, c, o, l, t[x[e]], E[4], p[e])), a = f, f = i, i = u(h, 10), h = s, s = b, _ = l, l = o, o = u(c, 10), c = n, n = v;
        }
        var D = this._b + h + o | 0;
        this._b = this._c + i + l | 0, this._c = this._d + f + _ | 0, this._d = this._e + a + n | 0, this._e = this._a + s + c | 0, this._a = D;
    };
    I.prototype._digest = function() {
        this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var t = g.alloc ? g.alloc(20) : new g(20);
        return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function u(t, r) {
        return t << r | t >>> 32 - r;
    }
    function y(t, r, a, s, h, i, f, _) {
        return u(t + (r ^ a ^ s) + i + f | 0, _) + h | 0;
    }
    function A(t, r, a, s, h, i, f, _) {
        return u(t + (r & a | ~r & s) + i + f | 0, _) + h | 0;
    }
    function B(t, r, a, s, h, i, f, _) {
        return u(t + ((r | ~a) ^ s) + i + f | 0, _) + h | 0;
    }
    function R(t, r, a, s, h, i, f, _) {
        return u(t + (r & s | a & ~s) + i + f | 0, _) + h | 0;
    }
    function m(t, r, a, s, h, i, f, _) {
        return u(t + (r ^ (a | ~s)) + i + f | 0, _) + h | 0;
    }
    z.exports = I;
});
var S = K(U());
var export_default = S.default;
var k0 = Object.create;
var L = Object.defineProperty;
var H0 = Object.getOwnPropertyDescriptor;
var m0 = Object.getOwnPropertyNames;
var U0 = Object.getPrototypeOf, z0 = Object.prototype.hasOwnProperty;
var G0 = (t)=>L(t, "__esModule", {
        value: !0
    });
var w = (t, h)=>()=>(h || t((h = {
            exports: {}
        }).exports, h), h.exports);
var K0 = (t, h, r)=>{
    if (h && typeof h == "object" || typeof h == "function") for (let e of m0(h))!z0.call(t, e) && e !== "default" && L(t, e, {
        get: ()=>h[e],
        enumerable: !(r = H0(h, e)) || r.enumerable
    });
    return t;
}, Z = (t)=>K0(G0(L(t != null ? k0(U0(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var I = w((Dt, T)=>{
    var $ = export_default.Buffer;
    function z(t, h) {
        this._block = $.alloc(t), this._finalSize = h, this._blockSize = t, this._len = 0;
    }
    z.prototype.update = function(t, h) {
        typeof t == "string" && (h = h || "utf8", t = $.from(t, h));
        for(var r = this._block, e = this._blockSize, a = t.length, f = this._len, s = 0; s < a;){
            for(var i = f % e, x = Math.min(a - s, e - i), c = 0; c < x; c++)r[i + c] = t[s + c];
            f += x, s += x, f % e == 0 && this._update(r);
        }
        return this._len += a, this;
    };
    z.prototype.digest = function(t) {
        var h = this._len % this._blockSize;
        this._block[h] = 128, this._block.fill(0, h + 1), h >= this._finalSize && (this._update(this._block), this._block.fill(0));
        var r = this._len * 8;
        if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4);
        else {
            var e = (r & 4294967295) >>> 0, a = (r - e) / 4294967296;
            this._block.writeUInt32BE(a, this._blockSize - 8), this._block.writeUInt32BE(e, this._blockSize - 4);
        }
        this._update(this._block);
        var f = this._hash();
        return t ? f.toString(t) : f;
    };
    z.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
    };
    T.exports = z;
});
var t0 = w((St, j)=>{
    var L0 = export_default, W = I(), J0 = export_default.Buffer, M0 = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
    ], N0 = new Array(80);
    function k() {
        this.init(), this._w = N0, W.call(this, 64, 56);
    }
    L0(k, W);
    k.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function O0(t) {
        return t << 5 | t >>> 27;
    }
    function P0(t) {
        return t << 30 | t >>> 2;
    }
    function Q0(t, h, r, e) {
        return t === 0 ? h & r | ~h & e : t === 2 ? h & r | h & e | r & e : h ^ r ^ e;
    }
    k.prototype._update = function(t) {
        for(var h = this._w, r = this._a | 0, e = this._b | 0, a = this._c | 0, f = this._d | 0, s = this._e | 0, i = 0; i < 16; ++i)h[i] = t.readInt32BE(i * 4);
        for(; i < 80; ++i)h[i] = h[i - 3] ^ h[i - 8] ^ h[i - 14] ^ h[i - 16];
        for(var x = 0; x < 80; ++x){
            var c = ~~(x / 20), _ = O0(r) + Q0(c, e, a, f) + s + h[x] + M0[c] | 0;
            s = f, f = a, a = P0(e), e = r, r = _;
        }
        this._a = r + this._a | 0, this._b = e + this._b | 0, this._c = a + this._c | 0, this._d = f + this._d | 0, this._e = s + this._e | 0;
    };
    k.prototype._hash = function() {
        var t = J0.allocUnsafe(20);
        return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    j.exports = k;
});
var e0 = w((kt, r0)=>{
    var R0 = export_default, h0 = I(), V0 = export_default.Buffer, X0 = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
    ], Y0 = new Array(80);
    function H() {
        this.init(), this._w = Y0, h0.call(this, 64, 56);
    }
    R0(H, h0);
    H.prototype.init = function() {
        return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function Z0(t) {
        return t << 1 | t >>> 31;
    }
    function $0(t) {
        return t << 5 | t >>> 27;
    }
    function T0(t) {
        return t << 30 | t >>> 2;
    }
    function W0(t, h, r, e) {
        return t === 0 ? h & r | ~h & e : t === 2 ? h & r | h & e | r & e : h ^ r ^ e;
    }
    H.prototype._update = function(t) {
        for(var h = this._w, r = this._a | 0, e = this._b | 0, a = this._c | 0, f = this._d | 0, s = this._e | 0, i = 0; i < 16; ++i)h[i] = t.readInt32BE(i * 4);
        for(; i < 80; ++i)h[i] = Z0(h[i - 3] ^ h[i - 8] ^ h[i - 14] ^ h[i - 16]);
        for(var x = 0; x < 80; ++x){
            var c = ~~(x / 20), _ = $0(r) + W0(c, e, a, f) + s + h[x] + X0[c] | 0;
            s = f, f = a, a = T0(e), e = r, r = _;
        }
        this._a = r + this._a | 0, this._b = e + this._b | 0, this._c = a + this._c | 0, this._d = f + this._d | 0, this._e = s + this._e | 0;
    };
    H.prototype._hash = function() {
        var t = V0.allocUnsafe(20);
        return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    r0.exports = H;
});
var J = w((Ht, a0)=>{
    var j0 = export_default, i0 = I(), tt = export_default.Buffer, ht = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ], rt = new Array(64);
    function m() {
        this.init(), this._w = rt, i0.call(this, 64, 56);
    }
    j0(m, i0);
    m.prototype.init = function() {
        return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function et(t, h, r) {
        return r ^ t & (h ^ r);
    }
    function it(t, h, r) {
        return t & h | r & (t | h);
    }
    function at(t) {
        return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function st(t) {
        return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function ft(t) {
        return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function _t(t) {
        return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    m.prototype._update = function(t) {
        for(var h = this._w, r = this._a | 0, e = this._b | 0, a = this._c | 0, f = this._d | 0, s = this._e | 0, i = this._f | 0, x = this._g | 0, c = this._h | 0, _ = 0; _ < 16; ++_)h[_] = t.readInt32BE(_ * 4);
        for(; _ < 64; ++_)h[_] = _t(h[_ - 2]) + h[_ - 7] + ft(h[_ - 15]) + h[_ - 16] | 0;
        for(var v = 0; v < 64; ++v){
            var B = c + st(s) + et(s, i, x) + ht[v] + h[v] | 0, C = at(r) + it(r, e, a) | 0;
            c = x, x = i, i = s, s = f + B | 0, f = a, a = e, e = r, r = B + C | 0;
        }
        this._a = r + this._a | 0, this._b = e + this._b | 0, this._c = a + this._c | 0, this._d = f + this._d | 0, this._e = s + this._e | 0, this._f = i + this._f | 0, this._g = x + this._g | 0, this._h = c + this._h | 0;
    };
    m.prototype._hash = function() {
        var t = tt.allocUnsafe(32);
        return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    a0.exports = m;
});
var f0 = w((mt, s0)=>{
    var xt = export_default, ct = J(), nt = I(), bt = export_default.Buffer, ut = new Array(64);
    function G() {
        this.init(), this._w = ut, nt.call(this, 64, 56);
    }
    xt(G, ct);
    G.prototype.init = function() {
        return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    G.prototype._hash = function() {
        var t = bt.allocUnsafe(28);
        return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    s0.exports = G;
});
var M = w((Ut, o0)=>{
    var ot = export_default, _0 = I(), dt = export_default.Buffer, x0 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ], vt = new Array(160);
    function U() {
        this.init(), this._w = vt, _0.call(this, 128, 112);
    }
    ot(U, _0);
    U.prototype.init = function() {
        return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function c0(t, h, r) {
        return r ^ t & (h ^ r);
    }
    function n0(t, h, r) {
        return t & h | r & (t | h);
    }
    function b0(t, h) {
        return (t >>> 28 | h << 4) ^ (h >>> 2 | t << 30) ^ (h >>> 7 | t << 25);
    }
    function u0(t, h) {
        return (t >>> 14 | h << 18) ^ (t >>> 18 | h << 14) ^ (h >>> 9 | t << 23);
    }
    function lt(t, h) {
        return (t >>> 1 | h << 31) ^ (t >>> 8 | h << 24) ^ t >>> 7;
    }
    function Bt(t, h) {
        return (t >>> 1 | h << 31) ^ (t >>> 8 | h << 24) ^ (t >>> 7 | h << 25);
    }
    function pt(t, h) {
        return (t >>> 19 | h << 13) ^ (h >>> 29 | t << 3) ^ t >>> 6;
    }
    function Et(t, h) {
        return (t >>> 19 | h << 13) ^ (h >>> 29 | t << 3) ^ (t >>> 6 | h << 26);
    }
    function b(t, h) {
        return t >>> 0 < h >>> 0 ? 1 : 0;
    }
    U.prototype._update = function(t) {
        for(var h = this._w, r = this._ah | 0, e = this._bh | 0, a = this._ch | 0, f = this._dh | 0, s = this._eh | 0, i = this._fh | 0, x = this._gh | 0, c = this._hh | 0, _ = this._al | 0, v = this._bl | 0, B = this._cl | 0, C = this._dl | 0, p = this._el | 0, F = this._fl | 0, q = this._gl | 0, y = this._hl | 0, n = 0; n < 32; n += 2)h[n] = t.readInt32BE(n * 4), h[n + 1] = t.readInt32BE(n * 4 + 4);
        for(; n < 160; n += 2){
            var D = h[n - 15 * 2], S = h[n - 15 * 2 + 1], B0 = lt(D, S), O = Bt(S, D);
            D = h[n - 2 * 2], S = h[n - 2 * 2 + 1];
            var p0 = pt(D, S), P = Et(S, D), E0 = h[n - 7 * 2], w0 = h[n - 7 * 2 + 1], C0 = h[n - 16 * 2], Q = h[n - 16 * 2 + 1], d = O + w0 | 0, A = B0 + E0 + b(d, O) | 0;
            d = d + P | 0, A = A + p0 + b(d, P) | 0, d = d + Q | 0, A = A + C0 + b(d, Q) | 0, h[n] = A, h[n + 1] = d;
        }
        for(var g = 0; g < 160; g += 2){
            A = h[g], d = h[g + 1];
            var A0 = n0(r, e, a), I0 = n0(_, v, B), g0 = b0(r, _), R = b0(_, r), F0 = u0(s, p), q0 = u0(p, s), y0 = x0[g], V = x0[g + 1], D0 = c0(s, i, x), X = c0(p, F, q), u = y + q0 | 0, E = c + F0 + b(u, y) | 0;
            u = u + X | 0, E = E + D0 + b(u, X) | 0, u = u + V | 0, E = E + y0 + b(u, V) | 0, u = u + d | 0, E = E + A + b(u, d) | 0;
            var Y = R + I0 | 0, S0 = g0 + A0 + b(Y, R) | 0;
            c = x, y = q, x = i, q = F, i = s, F = p, p = C + u | 0, s = f + E + b(p, C) | 0, f = a, C = B, a = e, B = v, e = r, v = _, _ = u + Y | 0, r = E + S0 + b(_, u) | 0;
        }
        this._al = this._al + _ | 0, this._bl = this._bl + v | 0, this._cl = this._cl + B | 0, this._dl = this._dl + C | 0, this._el = this._el + p | 0, this._fl = this._fl + F | 0, this._gl = this._gl + q | 0, this._hl = this._hl + y | 0, this._ah = this._ah + r + b(this._al, _) | 0, this._bh = this._bh + e + b(this._bl, v) | 0, this._ch = this._ch + a + b(this._cl, B) | 0, this._dh = this._dh + f + b(this._dl, C) | 0, this._eh = this._eh + s + b(this._el, p) | 0, this._fh = this._fh + i + b(this._fl, F) | 0, this._gh = this._gh + x + b(this._gl, q) | 0, this._hh = this._hh + c + b(this._hl, y) | 0;
    };
    U.prototype._hash = function() {
        var t = dt.allocUnsafe(64);
        function h(r, e, a) {
            t.writeInt32BE(r, a), t.writeInt32BE(e, a + 4);
        }
        return h(this._ah, this._al, 0), h(this._bh, this._bl, 8), h(this._ch, this._cl, 16), h(this._dh, this._dl, 24), h(this._eh, this._el, 32), h(this._fh, this._fl, 40), h(this._gh, this._gl, 48), h(this._hh, this._hl, 56), t;
    };
    o0.exports = U;
});
var v0 = w((zt, d0)=>{
    var wt = export_default, Ct = M(), At = I(), It = export_default.Buffer, gt = new Array(160);
    function K() {
        this.init(), this._w = gt, At.call(this, 128, 112);
    }
    wt(K, Ct);
    K.prototype.init = function() {
        return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    K.prototype._hash = function() {
        var t = It.allocUnsafe(48);
        function h(r, e, a) {
            t.writeInt32BE(r, a), t.writeInt32BE(e, a + 4);
        }
        return h(this._ah, this._al, 0), h(this._bh, this._bl, 8), h(this._ch, this._cl, 16), h(this._dh, this._dl, 24), h(this._eh, this._el, 32), h(this._fh, this._fl, 40), t;
    };
    d0.exports = K;
});
var N = w((l, l0)=>{
    var l = l0.exports = function(h) {
        h = h.toLowerCase();
        var r = l[h];
        if (!r) throw new Error(h + " is not supported (we accept pull requests)");
        return new r;
    };
    l.sha = t0();
    l.sha1 = e0();
    l.sha224 = f0();
    l.sha256 = J();
    l.sha384 = v0();
    l.sha512 = M();
});
var Ft = Z(N()), qt = Z(N()), { sha: Gt , sha1: Kt , sha224: Lt , sha256: Jt , sha384: Mt , sha512: Nt  } = Ft;
var export_default = qt.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var __setImmediate$ = (cb, ...args)=>setTimeout(cb, 0, ...args);
var W = Object.create;
var S = Object.defineProperty;
var Y = Object.getOwnPropertyDescriptor;
var $ = Object.getOwnPropertyNames;
var j = Object.getPrototypeOf, rr = Object.prototype.hasOwnProperty;
var er = (r)=>S(r, "__esModule", {
        value: !0
    });
var p = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var or = (r, e, t)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let n of $(e))!rr.call(r, n) && n !== "default" && S(r, n, {
        get: ()=>e[n],
        enumerable: !(t = Y(e, n)) || t.enumerable
    });
    return r;
}, K = (r)=>or(er(S(r != null ? W(j(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var x = p((Br, F)=>{
    var tr = Math.pow(2, 30) - 1;
    F.exports = function(r, e) {
        if (typeof r != "number") throw new TypeError("Iterations not a number");
        if (r < 0) throw new TypeError("Bad iterations");
        if (typeof e != "number") throw new TypeError("Key length not a number");
        if (e < 0 || e > tr || e !== e) throw new TypeError("Bad key length");
    };
});
var E = p((wr, L)=>{
    var b;
    __default && __default.browser ? b = "utf-8" : __default && __default.version ? (U = parseInt(__default.version.split(".")[0].slice(1), 10), b = U >= 6 ? "utf-8" : "binary") : b = "utf-8";
    var U;
    L.exports = b;
});
var g = p((yr, M)=>{
    var P = export_default.Buffer;
    M.exports = function(r, e, t) {
        if (P.isBuffer(r)) return r;
        if (typeof r == "string") return P.from(r, e);
        if (ArrayBuffer.isView(r)) return P.from(r.buffer);
        throw new TypeError(t + " must be a string, a Buffer, a typed array or a DataView");
    };
});
var A = p((qr, O)=>{
    var nr = export_default, ar = export_default, fr = export_default, s = export_default.Buffer, ur = x(), _ = E(), C = g(), ir = s.alloc(128), d = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
    };
    function N(r, e, t) {
        var n = sr(r), o = r === "sha512" || r === "sha384" ? 128 : 64;
        e.length > o ? e = n(e) : e.length < o && (e = s.concat([
            e,
            ir
        ], o));
        for(var a = s.allocUnsafe(o + d[r]), u = s.allocUnsafe(o + d[r]), f = 0; f < o; f++)a[f] = e[f] ^ 54, u[f] = e[f] ^ 92;
        var i = s.allocUnsafe(o + t + 4);
        a.copy(i, 0, 0, o), this.ipad1 = i, this.ipad2 = a, this.opad = u, this.alg = r, this.blocksize = o, this.hash = n, this.size = d[r];
    }
    N.prototype.run = function(r, e) {
        r.copy(e, this.blocksize);
        var t = this.hash(e);
        return t.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function sr(r) {
        function e(n) {
            return fr(r).update(n).digest();
        }
        function t(n) {
            return new ar().update(n).digest();
        }
        return r === "rmd160" || r === "ripemd160" ? t : r === "md5" ? nr : e;
    }
    function cr(r, e, t, n, o) {
        ur(t, n), r = C(r, _, "Password"), e = C(e, _, "Salt"), o = o || "sha1";
        var a = new N(o, r, e.length), u = s.allocUnsafe(n), f = s.allocUnsafe(e.length + 4);
        e.copy(f, 0, 0, e.length);
        for(var i = 0, B = d[o], V = Math.ceil(n / B), w = 1; w <= V; w++){
            f.writeUInt32BE(w, e.length);
            for(var y = a.run(f, a.ipad1), q = y, I = 1; I < t; I++){
                q = a.run(q, a.ipad2);
                for(var v = 0; v < B; v++)y[v] ^= q[v];
            }
            y.copy(u, i), i += B;
        }
        return u;
    }
    O.exports = cr;
});
var Q = p((Sr, J)=>{
    var R = export_default.Buffer, hr = x(), k = E(), Z = A(), X = g(), m, l = __global$.crypto && __global$.crypto.subtle, pr = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
    }, H = [];
    function lr(r) {
        if (__default && !__default.browser || !l || !l.importKey || !l.deriveBits) return Promise.resolve(!1);
        if (H[r] !== void 0) return H[r];
        m = m || R.alloc(8);
        var e = G(m, m, 10, 128, r).then(function() {
            return !0;
        }).catch(function() {
            return !1;
        });
        return H[r] = e, e;
    }
    var c;
    function T() {
        return c || (__default && __default.nextTick ? c = __default.nextTick : __global$.queueMicrotask ? c = __global$.queueMicrotask : __setImmediate$ ? c = __setImmediate$ : c = __global$.setTimeout, c);
    }
    function G(r, e, t, n, o) {
        return l.importKey("raw", r, {
            name: "PBKDF2"
        }, !1, [
            "deriveBits"
        ]).then(function(a) {
            return l.deriveBits({
                name: "PBKDF2",
                salt: e,
                iterations: t,
                hash: {
                    name: o
                }
            }, a, n << 3);
        }).then(function(a) {
            return R.from(a);
        });
    }
    function vr(r, e) {
        r.then(function(t) {
            T()(function() {
                e(null, t);
            });
        }, function(t) {
            T()(function() {
                e(t);
            });
        });
    }
    J.exports = function(r, e, t, n, o, a) {
        typeof o == "function" && (a = o, o = void 0), o = o || "sha1";
        var u = pr[o.toLowerCase()];
        if (!u || typeof __global$.Promise != "function") {
            T()(function() {
                var f;
                try {
                    f = Z(r, e, t, n, o);
                } catch (i) {
                    return a(i);
                }
                a(null, f);
            });
            return;
        }
        if (hr(t, n), r = X(r, k, "Password"), e = X(e, k, "Salt"), typeof a != "function") throw new Error("No callback provided to pbkdf2");
        vr(lr(u).then(function(f) {
            return f ? G(r, e, t, n, u) : Z(r, e, t, n, o);
        }), a);
    };
});
var D = p((z)=>{
    z.pbkdf2 = Q();
    z.pbkdf2Sync = A();
});
var br = K(D()), dr = K(D()), { pbkdf2Sync: Er , pbkdf2: Pr  } = br;
var export_default = dr.default;
__default.env.NODE_ENV = "production";
var c = Object.create;
var p = Object.defineProperty;
var g = Object.getOwnPropertyDescriptor;
var h = Object.getOwnPropertyNames;
var m = Object.getPrototypeOf, b = Object.prototype.hasOwnProperty;
var l = (e)=>p(e, "__esModule", {
        value: !0
    });
var T = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var S = (e, r, o)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of h(r))!b.call(e, n) && n !== "default" && p(e, n, {
        get: ()=>r[n],
        enumerable: !(o = g(r, n)) || o.enumerable
    });
    return e;
}, k = (e)=>S(l(p(e != null ? c(m(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var s = T((L, y)=>{
    "use strict";
    var u = export_default, i = u.Buffer, t = {}, f;
    for(f in u)!u.hasOwnProperty(f) || f === "SlowBuffer" || f === "Buffer" || (t[f] = u[f]);
    var a = t.Buffer = {};
    for(f in i)!i.hasOwnProperty(f) || f === "allocUnsafe" || f === "allocUnsafeSlow" || (a[f] = i[f]);
    t.Buffer.prototype = i.prototype;
    (!a.from || a.from === Uint8Array.from) && (a.from = function(e, r, o) {
        if (typeof e == "number") throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
        if (e && typeof e.length == "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
        return i(e, r, o);
    });
    a.alloc || (a.alloc = function(e, r, o) {
        if (typeof e != "number") throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
        if (e < 0 || e >= 2 * (1 << 30)) throw new RangeError('The value "' + e + '" is invalid for option "size"');
        var n = i(e);
        return !r || r.length === 0 ? n.fill(0) : typeof o == "string" ? n.fill(r, o) : n.fill(r), n;
    });
    if (!t.kStringMaxLength) try {
        t.kStringMaxLength = __default.binding("buffer").kStringMaxLength;
    } catch (e) {}
    t.constants || (t.constants = {
        MAX_LENGTH: t.kMaxLength
    }, t.kStringMaxLength && (t.constants.MAX_STRING_LENGTH = t.kStringMaxLength));
    y.exports = t;
});
var x = k(s());
var export_default = x.default;
var f = Object.create;
var s = Object.defineProperty;
var l = Object.getOwnPropertyDescriptor;
var u = Object.getOwnPropertyNames;
var w = Object.getPrototypeOf, c = Object.prototype.hasOwnProperty;
var d = (r)=>s(r, "__esModule", {
        value: !0
    });
var m = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var E = (r, e, i)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of u(e))!c.call(r, t) && t !== "default" && s(r, t, {
        get: ()=>e[t],
        enumerable: !(i = l(e, t)) || i.enumerable
    });
    return r;
}, h = (r)=>E(d(s(r != null ? f(w(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var n = m((x, a)=>{
    a.exports = o;
    function o(r, e) {
        if (!r) throw new Error(e || "Assertion failed");
    }
    o.equal = function(e, i, t) {
        if (e != i) throw new Error(t || "Assertion failed: " + e + " != " + i);
    };
});
var p = h(n());
var export_default = p.default;
var Se = Object.create;
var O = Object.defineProperty;
var je = Object.getOwnPropertyDescriptor;
var Be = Object.getOwnPropertyNames;
var we = Object.getPrototypeOf, De = Object.prototype.hasOwnProperty;
var ve = (o)=>O(o, "__esModule", {
        value: !0
    });
var h = (o, e)=>()=>(e || o((e = {
            exports: {}
        }).exports, e), e.exports);
var qe = (o, e, t)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let r of Be(e))!De.call(o, r) && r !== "default" && O(o, r, {
        get: ()=>e[r],
        enumerable: !(t = je(e, r)) || t.enumerable
    });
    return o;
}, ke = (o)=>qe(ve(O(o != null ? Se(we(o)) : {}, "default", o && o.__esModule && "default" in o ? {
        get: ()=>o.default,
        enumerable: !0
    } : {
        value: o,
        enumerable: !0
    })), o);
var k = h((J)=>{
    "use strict";
    var Ce = export_default;
    function y(o) {
        this._reporterState = {
            obj: null,
            path: [],
            options: o || {},
            errors: []
        };
    }
    J.Reporter = y;
    y.prototype.isError = function(e) {
        return e instanceof S;
    };
    y.prototype.save = function() {
        let e = this._reporterState;
        return {
            obj: e.obj,
            pathLen: e.path.length
        };
    };
    y.prototype.restore = function(e) {
        let t = this._reporterState;
        t.obj = e.obj, t.path = t.path.slice(0, e.pathLen);
    };
    y.prototype.enterKey = function(e) {
        return this._reporterState.path.push(e);
    };
    y.prototype.exitKey = function(e) {
        let t = this._reporterState;
        t.path = t.path.slice(0, e - 1);
    };
    y.prototype.leaveKey = function(e, t, r) {
        let n = this._reporterState;
        this.exitKey(e), n.obj !== null && (n.obj[t] = r);
    };
    y.prototype.path = function() {
        return this._reporterState.path.join("/");
    };
    y.prototype.enterObject = function() {
        let e = this._reporterState, t = e.obj;
        return e.obj = {}, t;
    };
    y.prototype.leaveObject = function(e) {
        let t = this._reporterState, r = t.obj;
        return t.obj = e, r;
    };
    y.prototype.error = function(e) {
        let t, r = this._reporterState, n = e instanceof S;
        if (n ? t = e : t = new S(r.path.map(function(s) {
            return "[" + JSON.stringify(s) + "]";
        }).join(""), e.message || e, e.stack), !r.options.partial) throw t;
        return n || r.errors.push(t), t;
    };
    y.prototype.wrapResult = function(e) {
        let t = this._reporterState;
        return t.options.partial ? {
            result: this.isError(e) ? null : e,
            errors: t.errors
        } : e;
    };
    function S(o, e) {
        this.path = o, this.rethrow(e);
    }
    Ce(S, Error);
    S.prototype.rethrow = function(e) {
        if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, S), !this.stack) try {
            throw new Error(this.message);
        } catch (t) {
            this.stack = t.stack;
        }
        return this;
    };
});
var w = h((A)=>{
    "use strict";
    var Ue = export_default, C = k().Reporter, j = export_default.Buffer;
    function g(o, e) {
        if (C.call(this, e), !j.isBuffer(o)) {
            this.error("Input not Buffer");
            return;
        }
        this.base = o, this.offset = 0, this.length = o.length;
    }
    Ue(g, C);
    A.DecoderBuffer = g;
    g.isDecoderBuffer = function(e) {
        return e instanceof g ? !0 : typeof e == "object" && j.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    g.prototype.save = function() {
        return {
            offset: this.offset,
            reporter: C.prototype.save.call(this)
        };
    };
    g.prototype.restore = function(e) {
        let t = new g(this.base);
        return t.offset = e.offset, t.length = this.offset, this.offset = e.offset, C.prototype.restore.call(this, e.reporter), t;
    };
    g.prototype.isEmpty = function() {
        return this.offset === this.length;
    };
    g.prototype.readUInt8 = function(e) {
        return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun");
    };
    g.prototype.skip = function(e, t) {
        if (!(this.offset + e <= this.length)) return this.error(t || "DecoderBuffer overrun");
        let r = new g(this.base);
        return r._reporterState = this._reporterState, r.offset = this.offset, r.length = this.offset + e, this.offset += e, r;
    };
    g.prototype.raw = function(e) {
        return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function B(o, e) {
        if (Array.isArray(o)) this.length = 0, this.value = o.map(function(t) {
            return B.isEncoderBuffer(t) || (t = new B(t, e)), this.length += t.length, t;
        }, this);
        else if (typeof o == "number") {
            if (!(0 <= o && o <= 255)) return e.error("non-byte EncoderBuffer value");
            this.value = o, this.length = 1;
        } else if (typeof o == "string") this.value = o, this.length = j.byteLength(o);
        else if (j.isBuffer(o)) this.value = o, this.length = o.length;
        else return e.error("Unsupported type: " + typeof o);
    }
    A.EncoderBuffer = B;
    B.isEncoderBuffer = function(e) {
        return e instanceof B ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    B.prototype.join = function(e, t) {
        return e || (e = j.alloc(this.length)), t || (t = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(r) {
            r.join(e, t), t += r.length;
        }) : (typeof this.value == "number" ? e[t] = this.value : typeof this.value == "string" ? e.write(this.value, t) : j.isBuffer(this.value) && this.value.copy(e, t), t += this.length)), e;
    };
});
var U = h((Xe, Z)=>{
    "use strict";
    var Ne = k().Reporter, Te = w().EncoderBuffer, Oe = w().DecoderBuffer, d = export_default, V = [
        "seq",
        "seqof",
        "set",
        "setof",
        "objid",
        "bool",
        "gentime",
        "utctime",
        "null_",
        "enum",
        "int",
        "objDesc",
        "bitstr",
        "bmpstr",
        "charstr",
        "genstr",
        "graphstr",
        "ia5str",
        "iso646str",
        "numstr",
        "octstr",
        "printstr",
        "t61str",
        "unistr",
        "utf8str",
        "videostr"
    ], Ae = [
        "key",
        "obj",
        "use",
        "optional",
        "explicit",
        "implicit",
        "def",
        "choice",
        "any",
        "contains"
    ].concat(V), Ie = [
        "_peekTag",
        "_decodeTag",
        "_use",
        "_decodeStr",
        "_decodeObjid",
        "_decodeTime",
        "_decodeNull",
        "_decodeInt",
        "_decodeBool",
        "_decodeList",
        "_encodeComposite",
        "_encodeStr",
        "_encodeObjid",
        "_encodeTime",
        "_encodeNull",
        "_encodeInt",
        "_encodeBool"
    ];
    function f(o, e, t) {
        let r = {};
        this._baseState = r, r.name = t, r.enc = o, r.parent = e || null, r.children = null, r.tag = null, r.args = null, r.reverseArgs = null, r.choice = null, r.optional = !1, r.any = !1, r.obj = !1, r.use = null, r.useDecoder = null, r.key = null, r.default = null, r.explicit = null, r.implicit = null, r.contains = null, r.parent || (r.children = [], this._wrap());
    }
    Z.exports = f;
    var Re = [
        "enc",
        "parent",
        "children",
        "tag",
        "args",
        "reverseArgs",
        "choice",
        "optional",
        "any",
        "obj",
        "use",
        "alteredUse",
        "key",
        "default",
        "explicit",
        "implicit",
        "contains"
    ];
    f.prototype.clone = function() {
        let e = this._baseState, t = {};
        Re.forEach(function(n) {
            t[n] = e[n];
        });
        let r = new this.constructor(t.parent);
        return r._baseState = t, r;
    };
    f.prototype._wrap = function() {
        let e = this._baseState;
        Ae.forEach(function(t) {
            this[t] = function() {
                let n = new this.constructor(this);
                return e.children.push(n), n[t].apply(n, arguments);
            };
        }, this);
    };
    f.prototype._init = function(e) {
        let t = this._baseState;
        d(t.parent === null), e.call(this), t.children = t.children.filter(function(r) {
            return r._baseState.parent === this;
        }, this), d.equal(t.children.length, 1, "Root node can have only one child");
    };
    f.prototype._useArgs = function(e) {
        let t = this._baseState, r = e.filter(function(n) {
            return n instanceof this.constructor;
        }, this);
        e = e.filter(function(n) {
            return !(n instanceof this.constructor);
        }, this), r.length !== 0 && (d(t.children === null), t.children = r, r.forEach(function(n) {
            n._baseState.parent = this;
        }, this)), e.length !== 0 && (d(t.args === null), t.args = e, t.reverseArgs = e.map(function(n) {
            if (typeof n != "object" || n.constructor !== Object) return n;
            let s = {};
            return Object.keys(n).forEach(function(i) {
                i == (i | 0) && (i |= 0);
                let c = n[i];
                s[c] = i;
            }), s;
        }));
    };
    Ie.forEach(function(o) {
        f.prototype[o] = function() {
            let t = this._baseState;
            throw new Error(o + " not implemented for encoding: " + t.enc);
        };
    });
    V.forEach(function(o) {
        f.prototype[o] = function() {
            let t = this._baseState, r = Array.prototype.slice.call(arguments);
            return d(t.tag === null), t.tag = o, this._useArgs(r), this;
        };
    });
    f.prototype.use = function(e) {
        d(e);
        let t = this._baseState;
        return d(t.use === null), t.use = e, this;
    };
    f.prototype.optional = function() {
        let e = this._baseState;
        return e.optional = !0, this;
    };
    f.prototype.def = function(e) {
        let t = this._baseState;
        return d(t.default === null), t.default = e, t.optional = !0, this;
    };
    f.prototype.explicit = function(e) {
        let t = this._baseState;
        return d(t.explicit === null && t.implicit === null), t.explicit = e, this;
    };
    f.prototype.implicit = function(e) {
        let t = this._baseState;
        return d(t.explicit === null && t.implicit === null), t.implicit = e, this;
    };
    f.prototype.obj = function() {
        let e = this._baseState, t = Array.prototype.slice.call(arguments);
        return e.obj = !0, t.length !== 0 && this._useArgs(t), this;
    };
    f.prototype.key = function(e) {
        let t = this._baseState;
        return d(t.key === null), t.key = e, this;
    };
    f.prototype.any = function() {
        let e = this._baseState;
        return e.any = !0, this;
    };
    f.prototype.choice = function(e) {
        let t = this._baseState;
        return d(t.choice === null), t.choice = e, this._useArgs(Object.keys(e).map(function(r) {
            return e[r];
        })), this;
    };
    f.prototype.contains = function(e) {
        let t = this._baseState;
        return d(t.use === null), t.contains = e, this;
    };
    f.prototype._decode = function(e, t) {
        let r = this._baseState;
        if (r.parent === null) return e.wrapResult(r.children[0]._decode(e, t));
        let n = r.default, s = !0, i = null;
        if (r.key !== null && (i = e.enterKey(r.key)), r.optional) {
            let l = null;
            if (r.explicit !== null ? l = r.explicit : r.implicit !== null ? l = r.implicit : r.tag !== null && (l = r.tag), l === null && !r.any) {
                let u = e.save();
                try {
                    r.choice === null ? this._decodeGeneric(r.tag, e, t) : this._decodeChoice(e, t), s = !0;
                } catch (a) {
                    s = !1;
                }
                e.restore(u);
            } else if (s = this._peekTag(e, l, r.any), e.isError(s)) return s;
        }
        let c;
        if (r.obj && s && (c = e.enterObject()), s) {
            if (r.explicit !== null) {
                let u1 = this._decodeTag(e, r.explicit);
                if (e.isError(u1)) return u1;
                e = u1;
            }
            let l1 = e.offset;
            if (r.use === null && r.choice === null) {
                let u2;
                r.any && (u2 = e.save());
                let a1 = this._decodeTag(e, r.implicit !== null ? r.implicit : r.tag, r.any);
                if (e.isError(a1)) return a1;
                r.any ? n = e.raw(u2) : e = a1;
            }
            if (t && t.track && r.tag !== null && t.track(e.path(), l1, e.length, "tagged"), t && t.track && r.tag !== null && t.track(e.path(), e.offset, e.length, "content"), r.any || (r.choice === null ? n = this._decodeGeneric(r.tag, e, t) : n = this._decodeChoice(e, t)), e.isError(n)) return n;
            if (!r.any && r.choice === null && r.children !== null && r.children.forEach(function(a) {
                a._decode(e, t);
            }), r.contains && (r.tag === "octstr" || r.tag === "bitstr")) {
                let u3 = new Oe(n);
                n = this._getUse(r.contains, e._reporterState.obj)._decode(u3, t);
            }
        }
        return r.obj && s && (n = e.leaveObject(c)), r.key !== null && (n !== null || s === !0) ? e.leaveKey(i, r.key, n) : i !== null && e.exitKey(i), n;
    };
    f.prototype._decodeGeneric = function(e, t, r) {
        let n = this._baseState;
        return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(t, e, n.args[0], r) : /str$/.test(e) ? this._decodeStr(t, e, r) : e === "objid" && n.args ? this._decodeObjid(t, n.args[0], n.args[1], r) : e === "objid" ? this._decodeObjid(t, null, null, r) : e === "gentime" || e === "utctime" ? this._decodeTime(t, e, r) : e === "null_" ? this._decodeNull(t, r) : e === "bool" ? this._decodeBool(t, r) : e === "objDesc" ? this._decodeStr(t, e, r) : e === "int" || e === "enum" ? this._decodeInt(t, n.args && n.args[0], r) : n.use !== null ? this._getUse(n.use, t._reporterState.obj)._decode(t, r) : t.error("unknown tag: " + e);
    };
    f.prototype._getUse = function(e, t) {
        let r = this._baseState;
        return r.useDecoder = this._use(e, t), d(r.useDecoder._baseState.parent === null), r.useDecoder = r.useDecoder._baseState.children[0], r.implicit !== r.useDecoder._baseState.implicit && (r.useDecoder = r.useDecoder.clone(), r.useDecoder._baseState.implicit = r.implicit), r.useDecoder;
    };
    f.prototype._decodeChoice = function(e, t) {
        let r = this._baseState, n = null, s = !1;
        return Object.keys(r.choice).some(function(i) {
            let c = e.save(), l = r.choice[i];
            try {
                let u = l._decode(e, t);
                if (e.isError(u)) return !1;
                n = {
                    type: i,
                    value: u
                }, s = !0;
            } catch (u1) {
                return e.restore(c), !1;
            }
            return !0;
        }, this), s ? n : e.error("Choice not matched");
    };
    f.prototype._createEncoderBuffer = function(e) {
        return new Te(e, this.reporter);
    };
    f.prototype._encode = function(e, t, r) {
        let n = this._baseState;
        if (n.default !== null && n.default === e) return;
        let s = this._encodeValue(e, t, r);
        if (s !== void 0 && !this._skipDefault(s, t, r)) return s;
    };
    f.prototype._encodeValue = function(e, t, r) {
        let n = this._baseState;
        if (n.parent === null) return n.children[0]._encode(e, t || new Ne);
        let s = null;
        if (this.reporter = t, n.optional && e === void 0) if (n.default !== null) e = n.default;
        else return;
        let i = null, c = !1;
        if (n.any) s = this._createEncoderBuffer(e);
        else if (n.choice) s = this._encodeChoice(e, t);
        else if (n.contains) i = this._getUse(n.contains, r)._encode(e, t), c = !0;
        else if (n.children) i = n.children.map(function(l) {
            if (l._baseState.tag === "null_") return l._encode(null, t, e);
            if (l._baseState.key === null) return t.error("Child should have a key");
            let u = t.enterKey(l._baseState.key);
            if (typeof e != "object") return t.error("Child expected, but input is not object");
            let a = l._encode(e[l._baseState.key], t, e);
            return t.leaveKey(u), a;
        }, this).filter(function(l) {
            return l;
        }), i = this._createEncoderBuffer(i);
        else if (n.tag === "seqof" || n.tag === "setof") {
            if (!(n.args && n.args.length === 1)) return t.error("Too many args for : " + n.tag);
            if (!Array.isArray(e)) return t.error("seqof/setof, but data is not Array");
            let l = this.clone();
            l._baseState.implicit = null, i = this._createEncoderBuffer(e.map(function(u) {
                let a = this._baseState;
                return this._getUse(a.args[0], e)._encode(u, t);
            }, l));
        } else n.use !== null ? s = this._getUse(n.use, r)._encode(e, t) : (i = this._encodePrimitive(n.tag, e), c = !0);
        if (!n.any && n.choice === null) {
            let l1 = n.implicit !== null ? n.implicit : n.tag, u = n.implicit === null ? "universal" : "context";
            l1 === null ? n.use === null && t.error("Tag could be omitted only for .use()") : n.use === null && (s = this._encodeComposite(l1, c, u, i));
        }
        return n.explicit !== null && (s = this._encodeComposite(n.explicit, !1, "context", s)), s;
    };
    f.prototype._encodeChoice = function(e, t) {
        let r = this._baseState, n = r.choice[e.type];
        return n || d(!1, e.type + " not found in " + JSON.stringify(Object.keys(r.choice))), n._encode(e.value, t);
    };
    f.prototype._encodePrimitive = function(e, t) {
        let r = this._baseState;
        if (/str$/.test(e)) return this._encodeStr(t, e);
        if (e === "objid" && r.args) return this._encodeObjid(t, r.reverseArgs[0], r.args[1]);
        if (e === "objid") return this._encodeObjid(t, null, null);
        if (e === "gentime" || e === "utctime") return this._encodeTime(t, e);
        if (e === "null_") return this._encodeNull();
        if (e === "int" || e === "enum") return this._encodeInt(t, r.args && r.reverseArgs[0]);
        if (e === "bool") return this._encodeBool(t);
        if (e === "objDesc") return this._encodeStr(t, e);
        throw new Error("Unsupported tag: " + e);
    };
    f.prototype._isNumstr = function(e) {
        return /^[0-9 ]*$/.test(e);
    };
    f.prototype._isPrintstr = function(e) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
});
var N = h((x)=>{
    "use strict";
    function H(o) {
        let e = {};
        return Object.keys(o).forEach(function(t) {
            (t | 0) == t && (t = t | 0);
            let r = o[t];
            e[r] = t;
        }), e;
    }
    x.tagClass = {
        0: "universal",
        1: "application",
        2: "context",
        3: "private"
    };
    x.tagClassByName = H(x.tagClass);
    x.tag = {
        0: "end",
        1: "bool",
        2: "int",
        3: "bitstr",
        4: "octstr",
        5: "null_",
        6: "objid",
        7: "objDesc",
        8: "external",
        9: "real",
        10: "enum",
        11: "embed",
        12: "utf8str",
        13: "relativeOid",
        16: "seq",
        17: "set",
        18: "numstr",
        19: "printstr",
        20: "t61str",
        21: "videostr",
        22: "ia5str",
        23: "utctime",
        24: "gentime",
        25: "graphstr",
        26: "iso646str",
        27: "genstr",
        28: "unistr",
        29: "charstr",
        30: "bmpstr"
    };
    x.tagByName = H(x.tag);
});
var R = h((tt, W)=>{
    "use strict";
    var Pe = export_default, E = export_default.Buffer, Y = U(), I = N();
    function Q(o) {
        this.enc = "der", this.name = o.name, this.entity = o, this.tree = new m, this.tree._init(o.body);
    }
    W.exports = Q;
    Q.prototype.encode = function(e, t) {
        return this.tree._encode(e, t).join();
    };
    function m(o) {
        Y.call(this, "der", o);
    }
    Pe(m, Y);
    m.prototype._encodeComposite = function(e, t, r, n) {
        let s = Ke(e, t, r, this.reporter);
        if (n.length < 128) {
            let l = E.alloc(2);
            return l[0] = s, l[1] = n.length, this._createEncoderBuffer([
                l,
                n
            ]);
        }
        let i = 1;
        for(let l1 = n.length; l1 >= 256; l1 >>= 8)i++;
        let c = E.alloc(1 + 1 + i);
        c[0] = s, c[1] = 128 | i;
        for(let l2 = 1 + i, u = n.length; u > 0; l2--, u >>= 8)c[l2] = u & 255;
        return this._createEncoderBuffer([
            c,
            n
        ]);
    };
    m.prototype._encodeStr = function(e, t) {
        if (t === "bitstr") return this._createEncoderBuffer([
            e.unused | 0,
            e.data
        ]);
        if (t === "bmpstr") {
            let r = E.alloc(e.length * 2);
            for(let n = 0; n < e.length; n++)r.writeUInt16BE(e.charCodeAt(n), n * 2);
            return this._createEncoderBuffer(r);
        } else return t === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : t === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t) ? this._createEncoderBuffer(e) : t === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + t + " unsupported");
    };
    m.prototype._encodeObjid = function(e, t, r) {
        if (typeof e == "string") {
            if (!t) return this.reporter.error("string objid given, but no values map found");
            if (!t.hasOwnProperty(e)) return this.reporter.error("objid not found in values map");
            e = t[e].split(/[\s.]+/g);
            for(let c = 0; c < e.length; c++)e[c] |= 0;
        } else if (Array.isArray(e)) {
            e = e.slice();
            for(let c1 = 0; c1 < e.length; c1++)e[c1] |= 0;
        }
        if (!Array.isArray(e)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
        if (!r) {
            if (e[1] >= 40) return this.reporter.error("Second objid identifier OOB");
            e.splice(0, 2, e[0] * 40 + e[1]);
        }
        let n = 0;
        for(let c2 = 0; c2 < e.length; c2++){
            let l = e[c2];
            for(n++; l >= 128; l >>= 7)n++;
        }
        let s = E.alloc(n), i = s.length - 1;
        for(let c3 = e.length - 1; c3 >= 0; c3--){
            let l1 = e[c3];
            for(s[i--] = l1 & 127; (l1 >>= 7) > 0;)s[i--] = 128 | l1 & 127;
        }
        return this._createEncoderBuffer(s);
    };
    function b(o) {
        return o < 10 ? "0" + o : o;
    }
    m.prototype._encodeTime = function(e, t) {
        let r, n = new Date(e);
        return t === "gentime" ? r = [
            b(n.getUTCFullYear()),
            b(n.getUTCMonth() + 1),
            b(n.getUTCDate()),
            b(n.getUTCHours()),
            b(n.getUTCMinutes()),
            b(n.getUTCSeconds()),
            "Z"
        ].join("") : t === "utctime" ? r = [
            b(n.getUTCFullYear() % 100),
            b(n.getUTCMonth() + 1),
            b(n.getUTCDate()),
            b(n.getUTCHours()),
            b(n.getUTCMinutes()),
            b(n.getUTCSeconds()),
            "Z"
        ].join("") : this.reporter.error("Encoding " + t + " time is not supported yet"), this._encodeStr(r, "octstr");
    };
    m.prototype._encodeNull = function() {
        return this._createEncoderBuffer("");
    };
    m.prototype._encodeInt = function(e, t) {
        if (typeof e == "string") {
            if (!t) return this.reporter.error("String int or enum given, but no values map");
            if (!t.hasOwnProperty(e)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
            e = t[e];
        }
        if (typeof e != "number" && !E.isBuffer(e)) {
            let s = e.toArray();
            !e.sign && s[0] & 128 && s.unshift(0), e = E.from(s);
        }
        if (E.isBuffer(e)) {
            let s1 = e.length;
            e.length === 0 && s1++;
            let i = E.alloc(s1);
            return e.copy(i), e.length === 0 && (i[0] = 0), this._createEncoderBuffer(i);
        }
        if (e < 128) return this._createEncoderBuffer(e);
        if (e < 256) return this._createEncoderBuffer([
            0,
            e
        ]);
        let r = 1;
        for(let s2 = e; s2 >= 256; s2 >>= 8)r++;
        let n = new Array(r);
        for(let s3 = n.length - 1; s3 >= 0; s3--)n[s3] = e & 255, e >>= 8;
        return n[0] & 128 && n.unshift(0), this._createEncoderBuffer(E.from(n));
    };
    m.prototype._encodeBool = function(e) {
        return this._createEncoderBuffer(e ? 255 : 0);
    };
    m.prototype._use = function(e, t) {
        return typeof e == "function" && (e = e(t)), e._getEncoder("der").tree;
    };
    m.prototype._skipDefault = function(e, t, r) {
        let n = this._baseState, s;
        if (n.default === null) return !1;
        let i = e.join();
        if (n.defaultBuffer === void 0 && (n.defaultBuffer = this._encodeValue(n.default, t, r).join()), i.length !== n.defaultBuffer.length) return !1;
        for(s = 0; s < i.length; s++)if (i[s] !== n.defaultBuffer[s]) return !1;
        return !0;
    };
    function Ke(o, e, t, r) {
        let n;
        if (o === "seqof" ? o = "seq" : o === "setof" && (o = "set"), I.tagByName.hasOwnProperty(o)) n = I.tagByName[o];
        else if (typeof o == "number" && (o | 0) === o) n = o;
        else return r.error("Unknown tag: " + o);
        return n >= 31 ? r.error("Multi-octet tag encoding unsupported") : (e || (n |= 32), n |= I.tagClassByName[t || "universal"] << 6, n);
    }
});
var ee = h((rt, X)=>{
    "use strict";
    var Me = export_default, P = R();
    function K(o) {
        P.call(this, o), this.enc = "pem";
    }
    Me(K, P);
    X.exports = K;
    K.prototype.encode = function(e, t) {
        let n = P.prototype.encode.call(this, e).toString("base64"), s = [
            "-----BEGIN " + t.label + "-----"
        ];
        for(let i = 0; i < n.length; i += 64)s.push(n.slice(i, i + 64));
        return s.push("-----END " + t.label + "-----"), s.join(`
`);
    };
});
var M = h((re)=>{
    "use strict";
    var te = re;
    te.der = R();
    te.pem = ee();
});
var G = h((ot, le)=>{
    "use strict";
    var Fe = export_default, Ge = export_default, ne = w().DecoderBuffer, oe = U(), se = N();
    function ie(o) {
        this.enc = "der", this.name = o.name, this.entity = o, this.tree = new _, this.tree._init(o.body);
    }
    le.exports = ie;
    ie.prototype.decode = function(e, t) {
        return ne.isDecoderBuffer(e) || (e = new ne(e, t)), this.tree._decode(e, t);
    };
    function _(o) {
        oe.call(this, "der", o);
    }
    Fe(_, oe);
    _.prototype._peekTag = function(e, t, r) {
        if (e.isEmpty()) return !1;
        let n = e.save(), s = F(e, 'Failed to peek tag: "' + t + '"');
        return e.isError(s) ? s : (e.restore(n), s.tag === t || s.tagStr === t || s.tagStr + "of" === t || r);
    };
    _.prototype._decodeTag = function(e, t, r) {
        let n = F(e, 'Failed to decode tag of "' + t + '"');
        if (e.isError(n)) return n;
        let s = ce(e, n.primitive, 'Failed to get length of "' + t + '"');
        if (e.isError(s)) return s;
        if (!r && n.tag !== t && n.tagStr !== t && n.tagStr + "of" !== t) return e.error('Failed to match tag: "' + t + '"');
        if (n.primitive || s !== null) return e.skip(s, 'Failed to match body of: "' + t + '"');
        let i = e.save(), c = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
        return e.isError(c) ? c : (s = e.offset - i.offset, e.restore(i), e.skip(s, 'Failed to match body of: "' + t + '"'));
    };
    _.prototype._skipUntilEnd = function(e, t) {
        for(;;){
            let r = F(e, t);
            if (e.isError(r)) return r;
            let n = ce(e, r.primitive, t);
            if (e.isError(n)) return n;
            let s;
            if (r.primitive || n !== null ? s = e.skip(n) : s = this._skipUntilEnd(e, t), e.isError(s)) return s;
            if (r.tagStr === "end") break;
        }
    };
    _.prototype._decodeList = function(e, t, r, n) {
        let s = [];
        for(; !e.isEmpty();){
            let i = this._peekTag(e, "end");
            if (e.isError(i)) return i;
            let c = r.decode(e, "der", n);
            if (e.isError(c) && i) break;
            s.push(c);
        }
        return s;
    };
    _.prototype._decodeStr = function(e, t) {
        if (t === "bitstr") {
            let r = e.readUInt8();
            return e.isError(r) ? r : {
                unused: r,
                data: e.raw()
            };
        } else if (t === "bmpstr") {
            let r1 = e.raw();
            if (r1.length % 2 == 1) return e.error("Decoding of string type: bmpstr length mismatch");
            let n = "";
            for(let s = 0; s < r1.length / 2; s++)n += String.fromCharCode(r1.readUInt16BE(s * 2));
            return n;
        } else if (t === "numstr") {
            let r2 = e.raw().toString("ascii");
            return this._isNumstr(r2) ? r2 : e.error("Decoding of string type: numstr unsupported characters");
        } else {
            if (t === "octstr") return e.raw();
            if (t === "objDesc") return e.raw();
            if (t === "printstr") {
                let r3 = e.raw().toString("ascii");
                return this._isPrintstr(r3) ? r3 : e.error("Decoding of string type: printstr unsupported characters");
            } else return /str$/.test(t) ? e.raw().toString() : e.error("Decoding of string type: " + t + " unsupported");
        }
    };
    _.prototype._decodeObjid = function(e, t, r) {
        let n, s = [], i = 0, c = 0;
        for(; !e.isEmpty();)c = e.readUInt8(), i <<= 7, i |= c & 127, (c & 128) == 0 && (s.push(i), i = 0);
        c & 128 && s.push(i);
        let l = s[0] / 40 | 0, u = s[0] % 40;
        if (r ? n = s : n = [
            l,
            u
        ].concat(s.slice(1)), t) {
            let a = t[n.join(" ")];
            a === void 0 && (a = t[n.join(".")]), a !== void 0 && (n = a);
        }
        return n;
    };
    _.prototype._decodeTime = function(e, t) {
        let r = e.raw().toString(), n, s, i, c, l, u;
        if (t === "gentime") n = r.slice(0, 4) | 0, s = r.slice(4, 6) | 0, i = r.slice(6, 8) | 0, c = r.slice(8, 10) | 0, l = r.slice(10, 12) | 0, u = r.slice(12, 14) | 0;
        else if (t === "utctime") n = r.slice(0, 2) | 0, s = r.slice(2, 4) | 0, i = r.slice(4, 6) | 0, c = r.slice(6, 8) | 0, l = r.slice(8, 10) | 0, u = r.slice(10, 12) | 0, n < 70 ? n = 2e3 + n : n = 1900 + n;
        else return e.error("Decoding " + t + " time is not supported yet");
        return Date.UTC(n, s - 1, i, c, l, u, 0);
    };
    _.prototype._decodeNull = function() {
        return null;
    };
    _.prototype._decodeBool = function(e) {
        let t = e.readUInt8();
        return e.isError(t) ? t : t !== 0;
    };
    _.prototype._decodeInt = function(e, t) {
        let r = e.raw(), n = new Ge(r);
        return t && (n = t[n.toString(10)] || n), n;
    };
    _.prototype._use = function(e, t) {
        return typeof e == "function" && (e = e(t)), e._getDecoder("der").tree;
    };
    function F(o, e) {
        let t = o.readUInt8(e);
        if (o.isError(t)) return t;
        let r = se.tagClass[t >> 6], n = (t & 32) == 0;
        if ((t & 31) == 31) {
            let i = t;
            for(t = 0; (i & 128) == 128;){
                if (i = o.readUInt8(e), o.isError(i)) return i;
                t <<= 7, t |= i & 127;
            }
        } else t &= 31;
        let s = se.tag[t];
        return {
            cls: r,
            primitive: n,
            tag: t,
            tagStr: s
        };
    }
    function ce(o, e, t) {
        let r = o.readUInt8(t);
        if (o.isError(r)) return r;
        if (!e && r === 128) return null;
        if ((r & 128) == 0) return r;
        let n = r & 127;
        if (n > 4) return o.error("length octect is too long");
        r = 0;
        for(let s = 0; s < n; s++){
            r <<= 8;
            let i = o.readUInt8(t);
            if (o.isError(i)) return i;
            r |= i;
        }
        return r;
    }
});
var fe = h((st, ue)=>{
    "use strict";
    var Le = export_default, $e = export_default.Buffer, L = G();
    function $(o) {
        L.call(this, o), this.enc = "pem";
    }
    Le($, L);
    ue.exports = $;
    $.prototype.decode = function(e, t) {
        let r = e.toString().split(/[\r\n]+/g), n = t.label.toUpperCase(), s = /^-----(BEGIN|END) ([^-]+)-----$/, i = -1, c = -1;
        for(let a = 0; a < r.length; a++){
            let q = r[a].match(s);
            if (q !== null && q[2] === n) if (i === -1) {
                if (q[1] !== "BEGIN") break;
                i = a;
            } else {
                if (q[1] !== "END") break;
                c = a;
                break;
            }
        }
        if (i === -1 || c === -1) throw new Error("PEM section not found for: " + n);
        let l = r.slice(i + 1, c).join("");
        l.replace(/[^a-z0-9+/=]+/gi, "");
        let u = $e.from(l, "base64");
        return L.prototype.decode.call(this, u, t);
    };
});
var z = h((de)=>{
    "use strict";
    var ae = de;
    ae.der = G();
    ae.pem = fe();
});
var pe = h((he)=>{
    "use strict";
    var ze = M(), Je = z(), Ve = export_default, Ze = he;
    Ze.define = function(e, t) {
        return new D(e, t);
    };
    function D(o, e) {
        this.name = o, this.body = e, this.decoders = {}, this.encoders = {};
    }
    D.prototype._createNamed = function(e) {
        let t = this.name;
        function r(n) {
            this._initNamed(n, t);
        }
        return Ve(r, e), r.prototype._initNamed = function(s, i) {
            e.call(this, s, i);
        }, new r(this);
    };
    D.prototype._getDecoder = function(e) {
        return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(Je[e])), this.decoders[e];
    };
    D.prototype.decode = function(e, t, r) {
        return this._getDecoder(t).decode(e, r);
    };
    D.prototype._getEncoder = function(e) {
        return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(ze[e])), this.encoders[e];
    };
    D.prototype.encode = function(e, t, r) {
        return this._getEncoder(t).encode(e, r);
    };
});
var ye = h((_e)=>{
    "use strict";
    var T = _e;
    T.Reporter = k().Reporter;
    T.DecoderBuffer = w().DecoderBuffer;
    T.EncoderBuffer = w().EncoderBuffer;
    T.Node = U();
});
var me = h((be)=>{
    "use strict";
    var ge = be;
    ge._reverse = function(e) {
        let t = {};
        return Object.keys(e).forEach(function(r) {
            (r | 0) == r && (r = r | 0);
            let n = e[r];
            t[n] = r;
        }), t;
    };
    ge.der = N();
});
var xe = h((Ee)=>{
    "use strict";
    var v = Ee;
    v.bignum = export_default;
    v.define = pe().define;
    v.base = ye();
    v.constants = me();
    v.decoders = z();
    v.encoders = M();
});
var He = ke(xe());
var export_default = He.default;
var B = Object.create;
var k = Object.defineProperty;
var N = Object.getOwnPropertyDescriptor;
var V = Object.getOwnPropertyNames;
var Y = Object.getPrototypeOf, _ = Object.prototype.hasOwnProperty;
var U = (e)=>k(e, "__esModule", {
        value: !0
    });
var v = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var F = (e, r, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let s of V(r))!_.call(e, s) && s !== "default" && k(e, s, {
        get: ()=>r[s],
        enumerable: !(n = N(r, s)) || n.enumerable
    });
    return e;
}, z = (e)=>F(U(k(e != null ? B(Y(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var q = v((ke, E)=>{
    "use strict";
    var o = export_default, j = o.define("Time", function() {
        this.choice({
            utcTime: this.utctime(),
            generalTime: this.gentime()
        });
    }), G = o.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), m = o.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), L = o.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(m), this.key("subjectPublicKey").bitstr());
    }), X = o.define("RelativeDistinguishedName", function() {
        this.setof(G);
    }), H = o.define("RDNSequence", function() {
        this.seqof(X);
    }), g = o.define("Name", function() {
        this.choice({
            rdnSequence: this.use(H)
        });
    }), $ = o.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(j), this.key("notAfter").use(j));
    }), J = o.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr());
    }), M = o.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(m), this.key("issuer").use(g), this.key("validity").use($), this.key("subject").use(g), this.key("subjectPublicKeyInfo").use(L), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(J).optional());
    }), O = o.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(M), this.key("signatureAlgorithm").use(m), this.key("signatureValue").bitstr());
    });
    E.exports = O;
});
var I = v((y)=>{
    "use strict";
    var c = export_default;
    y.certificate = q();
    var Q = c.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    y.RSAPrivateKey = Q;
    var W = c.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    y.RSAPublicKey = W;
    var Z = c.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(A), this.key("subjectPublicKey").bitstr());
    });
    y.PublicKey = Z;
    var A = c.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), ee = c.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(A), this.key("subjectPrivateKey").octstr());
    });
    y.PrivateKey = ee;
    var ie = c.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    y.EncryptedPrivateKey = ie;
    var te = c.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    y.DSAPrivateKey = te;
    y.DSAparam = c.define("DSAparam", function() {
        this.int();
    });
    var re = c.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(se), this.key("publicKey").optional().explicit(1).bitstr());
    });
    y.ECPrivateKey = re;
    var se = c.define("ECParameters", function() {
        this.choice({
            namedCurve: this.objid()
        });
    });
    y.signature = c.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
    });
});
var S = v((Ke, ae)=>{
    ae.exports = {
        "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
        "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
        "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
        "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
        "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
        "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
        "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
        "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
        "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
        "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
        "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
        "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
});
var C = v((Pe, R)=>{
    var ne = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, oe = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, ce = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, ye = export_default, ue = export_default, l = export_default.Buffer;
    R.exports = function(e, r) {
        var n = e.toString(), s = n.match(ne), t;
        if (s) {
            var i = "aes" + s[1], p = l.from(s[2], "hex"), b = l.from(s[3].replace(/[\r\n]/g, ""), "base64"), f = ye(r, p.slice(0, 8), parseInt(s[1], 10)).key, d = [], P = ue.createDecipheriv(i, f, p);
            d.push(P.update(b)), d.push(P.final()), t = l.concat(d);
        } else {
            var u = n.match(ce);
            t = l.from(u[2].replace(/[\r\n]/g, ""), "base64");
        }
        var w = n.match(oe)[1];
        return {
            tag: w,
            data: t
        };
    };
});
var D = v((je, T)=>{
    var a = I(), he = S(), de = C(), ve = export_default, pe = export_default, K = export_default.Buffer;
    T.exports = x;
    function x(e) {
        var r;
        typeof e == "object" && !K.isBuffer(e) && (r = e.passphrase, e = e.key), typeof e == "string" && (e = K.from(e));
        var n = de(e, r), s = n.tag, t = n.data, u, i;
        switch(s){
            case "CERTIFICATE":
                i = a.certificate.decode(t, "der").tbsCertificate.subjectPublicKeyInfo;
            case "PUBLIC KEY":
                switch(i || (i = a.PublicKey.decode(t, "der")), u = i.algorithm.algorithm.join("."), u){
                    case "1.2.840.113549.1.1.1":
                        return a.RSAPublicKey.decode(i.subjectPublicKey.data, "der");
                    case "1.2.840.10045.2.1":
                        return i.subjectPrivateKey = i.subjectPublicKey, {
                            type: "ec",
                            data: i
                        };
                    case "1.2.840.10040.4.1":
                        return i.algorithm.params.pub_key = a.DSAparam.decode(i.subjectPublicKey.data, "der"), {
                            type: "dsa",
                            data: i.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + u);
                }
            case "ENCRYPTED PRIVATE KEY":
                t = a.EncryptedPrivateKey.decode(t, "der"), t = fe(t, r);
            case "PRIVATE KEY":
                switch(i = a.PrivateKey.decode(t, "der"), u = i.algorithm.algorithm.join("."), u){
                    case "1.2.840.113549.1.1.1":
                        return a.RSAPrivateKey.decode(i.subjectPrivateKey, "der");
                    case "1.2.840.10045.2.1":
                        return {
                            curve: i.algorithm.curve,
                            privateKey: a.ECPrivateKey.decode(i.subjectPrivateKey, "der").privateKey
                        };
                    case "1.2.840.10040.4.1":
                        return i.algorithm.params.priv_key = a.DSAparam.decode(i.subjectPrivateKey, "der"), {
                            type: "dsa",
                            params: i.algorithm.params
                        };
                    default:
                        throw new Error("unknown key id " + u);
                }
            case "RSA PUBLIC KEY":
                return a.RSAPublicKey.decode(t, "der");
            case "RSA PRIVATE KEY":
                return a.RSAPrivateKey.decode(t, "der");
            case "DSA PRIVATE KEY":
                return {
                    type: "dsa",
                    params: a.DSAPrivateKey.decode(t, "der")
                };
            case "EC PRIVATE KEY":
                return t = a.ECPrivateKey.decode(t, "der"), {
                    curve: t.parameters.value,
                    privateKey: t.privateKey
                };
            default:
                throw new Error("unknown key type " + s);
        }
    }
    x.signature = a.signature;
    function fe(e, r) {
        var n = e.algorithm.decrypt.kde.kdeparams.salt, s = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), t = he[e.algorithm.decrypt.cipher.algo.join(".")], u = e.algorithm.decrypt.cipher.iv, i = e.subjectPrivateKey, p = parseInt(t.split("-")[1], 10) / 8, b = pe.pbkdf2Sync(r, n, s, p, "sha1"), f = ve.createDecipheriv(t, b, u), d = [];
        return d.push(f.update(i)), d.push(f.final()), K.concat(d);
    }
});
var le = z(D());
var export_default = le.default;
var p = Object.create;
var h = Object.defineProperty;
var d = Object.getOwnPropertyDescriptor;
var c = Object.getOwnPropertyNames;
var f = Object.getPrototypeOf, m = Object.prototype.hasOwnProperty;
var q = (e)=>h(e, "__esModule", {
        value: !0
    });
var v = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var _ = (e, r, a)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of c(r))!m.call(e, t) && t !== "default" && h(e, t, {
        get: ()=>r[t],
        enumerable: !(a = d(r, t)) || a.enumerable
    });
    return e;
}, w = (e)=>_(q(h(e != null ? p(f(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var o = v((b, u)=>{
    "use strict";
    var j = export_default, x = export_default, y = export_default, D = export_default, n = export_default;
    function s(e) {
        n.call(this, "digest"), this._hash = e;
    }
    j(s, n);
    s.prototype._update = function(e) {
        this._hash.update(e);
    };
    s.prototype._final = function() {
        return this._hash.digest();
    };
    u.exports = function(r) {
        return r = r.toLowerCase(), r === "md5" ? new x : r === "rmd160" || r === "ripemd160" ? new y : new s(D(r));
    };
});
var H = w(o());
var export_default = H.default;
var B = Object.create;
var p = Object.defineProperty;
var U = Object.getOwnPropertyDescriptor;
var C = Object.getOwnPropertyNames;
var E = Object.getPrototypeOf, H = Object.prototype.hasOwnProperty;
var R = (a)=>p(a, "__esModule", {
        value: !0
    });
var v = (a, r)=>()=>(r || a((r = {
            exports: {}
        }).exports, r), r.exports);
var z = (a, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let e of C(r))!H.call(a, e) && e !== "default" && p(a, e, {
        get: ()=>r[e],
        enumerable: !(t = U(r, e)) || t.enumerable
    });
    return a;
}, L = (a)=>z(R(p(a != null ? B(E(a)) : {}, "default", a && a.__esModule && "default" in a ? {
        get: ()=>a.default,
        enumerable: !0
    } : {
        value: a,
        enumerable: !0
    })), a);
var q = v((A, m)=>{
    "use strict";
    var O = export_default, h = export_default.Buffer, l = export_default, S = h.alloc(128), o = 64;
    function c(a, r) {
        l.call(this, "digest"), typeof r == "string" && (r = h.from(r)), this._alg = a, this._key = r, r.length > o ? r = a(r) : r.length < o && (r = h.concat([
            r,
            S
        ], o));
        for(var t = this._ipad = h.allocUnsafe(o), e = this._opad = h.allocUnsafe(o), s = 0; s < o; s++)t[s] = r[s] ^ 54, e[s] = r[s] ^ 92;
        this._hash = [
            t
        ];
    }
    O(c, l);
    c.prototype._update = function(a) {
        this._hash.push(a);
    };
    c.prototype._final = function() {
        var a = this._alg(h.concat(this._hash));
        return this._alg(h.concat([
            this._opad,
            a
        ]));
    };
    m.exports = c;
});
var x = v((F, w)=>{
    "use strict";
    var Z = export_default, j = q(), g = export_default, f = export_default.Buffer, D = export_default, d = export_default, _ = export_default, I = f.alloc(128);
    function u(a, r) {
        g.call(this, "digest"), typeof r == "string" && (r = f.from(r));
        var t = a === "sha512" || a === "sha384" ? 128 : 64;
        if (this._alg = a, this._key = r, r.length > t) {
            var e = a === "rmd160" ? new d : _(a);
            r = e.update(r).digest();
        } else r.length < t && (r = f.concat([
            r,
            I
        ], t));
        for(var s = this._ipad = f.allocUnsafe(t), b = this._opad = f.allocUnsafe(t), n = 0; n < t; n++)s[n] = r[n] ^ 54, b[n] = r[n] ^ 92;
        this._hash = a === "rmd160" ? new d : _(a), this._hash.update(s);
    }
    Z(u, g);
    u.prototype._update = function(a) {
        this._hash.update(a);
    };
    u.prototype._final = function() {
        var a = this._hash.digest(), r = this._alg === "rmd160" ? new d : _(this._alg);
        return r.update(this._opad).update(a).digest();
    };
    w.exports = function(r, t) {
        return r = r.toLowerCase(), r === "rmd160" || r === "ripemd160" ? new u("rmd160", t) : r === "md5" ? new j(D, t) : new u(r, t);
    };
});
var M = L(x());
var export_default = M.default;
var r = Object.create;
var i = Object.defineProperty;
var H = Object.getOwnPropertyDescriptor;
var c = Object.getOwnPropertyNames;
var e = Object.getPrototypeOf, t = Object.prototype.hasOwnProperty;
var D = (s)=>i(s, "__esModule", {
        value: !0
    });
var n = (s, a)=>()=>(a || s((a = {
            exports: {}
        }).exports, a), a.exports);
var R = (s, a, d)=>{
    if (a && typeof a == "object" || typeof a == "function") for (let h of c(a))!t.call(s, h) && h !== "default" && i(s, h, {
        get: ()=>a[h],
        enumerable: !(d = H(a, h)) || d.enumerable
    });
    return s;
}, o = (s)=>R(D(i(s != null ? r(e(s)) : {}, "default", s && s.__esModule && "default" in s ? {
        get: ()=>s.default,
        enumerable: !0
    } : {
        value: s,
        enumerable: !0
    })), s);
var A = n((E, W)=>{
    W.exports = {
        sha224WithRSAEncryption: {
            sign: "rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        "RSA-SHA224": {
            sign: "ecdsa/rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        sha256WithRSAEncryption: {
            sign: "rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        "RSA-SHA256": {
            sign: "ecdsa/rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        sha384WithRSAEncryption: {
            sign: "rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        "RSA-SHA384": {
            sign: "ecdsa/rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        sha512WithRSAEncryption: {
            sign: "rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA512": {
            sign: "ecdsa/rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA1": {
            sign: "rsa",
            hash: "sha1",
            id: "3021300906052b0e03021a05000414"
        },
        "ecdsa-with-SHA1": {
            sign: "ecdsa",
            hash: "sha1",
            id: ""
        },
        sha256: {
            sign: "ecdsa",
            hash: "sha256",
            id: ""
        },
        sha224: {
            sign: "ecdsa",
            hash: "sha224",
            id: ""
        },
        sha384: {
            sign: "ecdsa",
            hash: "sha384",
            id: ""
        },
        sha512: {
            sign: "ecdsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-SHA1": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        DSA: {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-WITH-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-WITH-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-WITH-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-WITH-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-RIPEMD160": {
            sign: "dsa",
            hash: "rmd160",
            id: ""
        },
        ripemd160WithRSA: {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        "RSA-RIPEMD160": {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        md5WithRSAEncryption: {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        },
        "RSA-MD5": {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        }
    };
});
var g = n((y, S)=>{
    S.exports = A();
});
var m = o(g());
var export_default = m.default;
var F = Object.create;
var w = Object.defineProperty;
var G = Object.getOwnPropertyDescriptor;
var H = Object.getOwnPropertyNames;
var J = Object.getPrototypeOf, L = Object.prototype.hasOwnProperty;
var Q = (p)=>w(p, "__esModule", {
        value: !0
    });
var _ = (p, t)=>()=>(t || p((t = {
            exports: {}
        }).exports, t), t.exports);
var R = (p, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let e of H(t))!L.call(p, e) && e !== "default" && w(p, e, {
        get: ()=>t[e],
        enumerable: !(r = G(t, e)) || r.enumerable
    });
    return p;
}, D = (p)=>R(Q(w(p != null ? F(J(p)) : {}, "default", p && p.__esModule && "default" in p ? {
        get: ()=>p.default,
        enumerable: !0
    } : {
        value: p,
        enumerable: !0
    })), p);
var B = _((c)=>{
    "use strict";
    c.readUInt32BE = function(t, r) {
        var e = t[0 + r] << 24 | t[1 + r] << 16 | t[2 + r] << 8 | t[3 + r];
        return e >>> 0;
    };
    c.writeUInt32BE = function(t, r, e) {
        t[0 + e] = r >>> 24, t[1 + e] = r >>> 16 & 255, t[2 + e] = r >>> 8 & 255, t[3 + e] = r & 255;
    };
    c.ip = function(t, r, e, n) {
        for(var a = 0, s = 0, u = 6; u >= 0; u -= 2){
            for(var i = 0; i <= 24; i += 8)a <<= 1, a |= r >>> i + u & 1;
            for(var i = 0; i <= 24; i += 8)a <<= 1, a |= t >>> i + u & 1;
        }
        for(var u = 6; u >= 0; u -= 2){
            for(var i = 1; i <= 25; i += 8)s <<= 1, s |= r >>> i + u & 1;
            for(var i = 1; i <= 25; i += 8)s <<= 1, s |= t >>> i + u & 1;
        }
        e[n + 0] = a >>> 0, e[n + 1] = s >>> 0;
    };
    c.rip = function(t, r, e, n) {
        for(var a = 0, s = 0, u = 0; u < 4; u++)for(var i = 24; i >= 0; i -= 8)a <<= 1, a |= r >>> i + u & 1, a <<= 1, a |= t >>> i + u & 1;
        for(var u = 4; u < 8; u++)for(var i = 24; i >= 0; i -= 8)s <<= 1, s |= r >>> i + u & 1, s <<= 1, s |= t >>> i + u & 1;
        e[n + 0] = a >>> 0, e[n + 1] = s >>> 0;
    };
    c.pc1 = function(t, r, e, n) {
        for(var a = 0, s = 0, u = 7; u >= 5; u--){
            for(var i = 0; i <= 24; i += 8)a <<= 1, a |= r >> i + u & 1;
            for(var i = 0; i <= 24; i += 8)a <<= 1, a |= t >> i + u & 1;
        }
        for(var i = 0; i <= 24; i += 8)a <<= 1, a |= r >> i + u & 1;
        for(var u = 1; u <= 3; u++){
            for(var i = 0; i <= 24; i += 8)s <<= 1, s |= r >> i + u & 1;
            for(var i = 0; i <= 24; i += 8)s <<= 1, s |= t >> i + u & 1;
        }
        for(var i = 0; i <= 24; i += 8)s <<= 1, s |= t >> i + u & 1;
        e[n + 0] = a >>> 0, e[n + 1] = s >>> 0;
    };
    c.r28shl = function(t, r) {
        return t << r & 268435455 | t >>> 28 - r;
    };
    var m = [
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
    ];
    c.pc2 = function(t, r, e, n) {
        for(var a = 0, s = 0, u = m.length >>> 1, i = 0; i < u; i++)a <<= 1, a |= t >>> m[i] & 1;
        for(var i = u; i < m.length; i++)s <<= 1, s |= r >>> m[i] & 1;
        e[n + 0] = a >>> 0, e[n + 1] = s >>> 0;
    };
    c.expand = function(t, r, e) {
        var n = 0, a = 0;
        n = (t & 1) << 5 | t >>> 27;
        for(var s = 23; s >= 15; s -= 4)n <<= 6, n |= t >>> s & 63;
        for(var s = 11; s >= 3; s -= 4)a |= t >>> s & 63, a <<= 6;
        a |= (t & 31) << 1 | t >>> 31, r[e + 0] = n >>> 0, r[e + 1] = a >>> 0;
    };
    var C = [
        14,
        0,
        4,
        15,
        13,
        7,
        1,
        4,
        2,
        14,
        15,
        2,
        11,
        13,
        8,
        1,
        3,
        10,
        10,
        6,
        6,
        12,
        12,
        11,
        5,
        9,
        9,
        5,
        0,
        3,
        7,
        8,
        4,
        15,
        1,
        12,
        14,
        8,
        8,
        2,
        13,
        4,
        6,
        9,
        2,
        1,
        11,
        7,
        15,
        5,
        12,
        11,
        9,
        3,
        7,
        14,
        3,
        10,
        10,
        0,
        5,
        6,
        0,
        13,
        15,
        3,
        1,
        13,
        8,
        4,
        14,
        7,
        6,
        15,
        11,
        2,
        3,
        8,
        4,
        14,
        9,
        12,
        7,
        0,
        2,
        1,
        13,
        10,
        12,
        6,
        0,
        9,
        5,
        11,
        10,
        5,
        0,
        13,
        14,
        8,
        7,
        10,
        11,
        1,
        10,
        3,
        4,
        15,
        13,
        4,
        1,
        2,
        5,
        11,
        8,
        6,
        12,
        7,
        6,
        12,
        9,
        0,
        3,
        5,
        2,
        14,
        15,
        9,
        10,
        13,
        0,
        7,
        9,
        0,
        14,
        9,
        6,
        3,
        3,
        4,
        15,
        6,
        5,
        10,
        1,
        2,
        13,
        8,
        12,
        5,
        7,
        14,
        11,
        12,
        4,
        11,
        2,
        15,
        8,
        1,
        13,
        1,
        6,
        10,
        4,
        13,
        9,
        0,
        8,
        6,
        15,
        9,
        3,
        8,
        0,
        7,
        11,
        4,
        1,
        15,
        2,
        14,
        12,
        3,
        5,
        11,
        10,
        5,
        14,
        2,
        7,
        12,
        7,
        13,
        13,
        8,
        14,
        11,
        3,
        5,
        0,
        6,
        6,
        15,
        9,
        0,
        10,
        3,
        1,
        4,
        2,
        7,
        8,
        2,
        5,
        12,
        11,
        1,
        12,
        10,
        4,
        14,
        15,
        9,
        10,
        3,
        6,
        15,
        9,
        0,
        0,
        6,
        12,
        10,
        11,
        1,
        7,
        13,
        13,
        8,
        15,
        9,
        1,
        4,
        3,
        5,
        14,
        11,
        5,
        12,
        2,
        7,
        8,
        2,
        4,
        14,
        2,
        14,
        12,
        11,
        4,
        2,
        1,
        12,
        7,
        4,
        10,
        7,
        11,
        13,
        6,
        1,
        8,
        5,
        5,
        0,
        3,
        15,
        15,
        10,
        13,
        3,
        0,
        9,
        14,
        8,
        9,
        6,
        4,
        11,
        2,
        8,
        1,
        12,
        11,
        7,
        10,
        1,
        13,
        14,
        7,
        2,
        8,
        13,
        15,
        6,
        9,
        15,
        12,
        0,
        5,
        9,
        6,
        10,
        3,
        4,
        0,
        5,
        14,
        3,
        12,
        10,
        1,
        15,
        10,
        4,
        15,
        2,
        9,
        7,
        2,
        12,
        6,
        9,
        8,
        5,
        0,
        6,
        13,
        1,
        3,
        13,
        4,
        14,
        14,
        0,
        7,
        11,
        5,
        3,
        11,
        8,
        9,
        4,
        14,
        3,
        15,
        2,
        5,
        12,
        2,
        9,
        8,
        5,
        12,
        15,
        3,
        10,
        7,
        11,
        0,
        14,
        4,
        1,
        10,
        7,
        1,
        6,
        13,
        0,
        11,
        8,
        6,
        13,
        4,
        13,
        11,
        0,
        2,
        11,
        14,
        7,
        15,
        4,
        0,
        9,
        8,
        1,
        13,
        10,
        3,
        14,
        12,
        3,
        9,
        5,
        7,
        12,
        5,
        2,
        10,
        15,
        6,
        8,
        1,
        6,
        1,
        6,
        4,
        11,
        11,
        13,
        13,
        8,
        12,
        1,
        3,
        4,
        7,
        10,
        14,
        7,
        10,
        9,
        15,
        5,
        6,
        0,
        8,
        15,
        0,
        14,
        5,
        2,
        9,
        3,
        2,
        12,
        13,
        1,
        2,
        15,
        8,
        13,
        4,
        8,
        6,
        10,
        15,
        3,
        11,
        7,
        1,
        4,
        10,
        12,
        9,
        5,
        3,
        6,
        14,
        11,
        5,
        0,
        0,
        14,
        12,
        9,
        7,
        2,
        7,
        2,
        11,
        1,
        4,
        14,
        1,
        7,
        9,
        4,
        12,
        10,
        14,
        8,
        2,
        13,
        0,
        15,
        6,
        12,
        10,
        9,
        13,
        0,
        15,
        3,
        3,
        5,
        5,
        6,
        8,
        11
    ];
    c.substitute = function(t, r) {
        for(var e = 0, n = 0; n < 4; n++){
            var a = t >>> 18 - n * 6 & 63, s = C[n * 64 + a];
            e <<= 4, e |= s;
        }
        for(var n = 0; n < 4; n++){
            var a = r >>> 18 - n * 6 & 63, s = C[4 * 64 + n * 64 + a];
            e <<= 4, e |= s;
        }
        return e >>> 0;
    };
    var U = [
        16,
        25,
        12,
        11,
        3,
        20,
        4,
        15,
        31,
        17,
        9,
        6,
        27,
        14,
        1,
        22,
        30,
        24,
        8,
        18,
        0,
        5,
        29,
        23,
        13,
        19,
        2,
        26,
        10,
        21,
        28,
        7
    ];
    c.permute = function(t) {
        for(var r = 0, e = 0; e < U.length; e++)r <<= 1, r |= t >>> U[e] & 1;
        return r >>> 0;
    };
    c.padSplit = function(t, r, e) {
        for(var n = t.toString(2); n.length < r;)n = "0" + n;
        for(var a = [], s = 0; s < r; s += e)a.push(n.slice(s, s + e));
        return a.join(" ");
    };
});
var S = _((ct, A)=>{
    "use strict";
    var W = export_default;
    function f(p) {
        this.options = p, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    A.exports = f;
    f.prototype._init = function() {};
    f.prototype.update = function(t) {
        return t.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(t) : this._updateEncrypt(t);
    };
    f.prototype._buffer = function(t, r) {
        for(var e = Math.min(this.buffer.length - this.bufferOff, t.length - r), n = 0; n < e; n++)this.buffer[this.bufferOff + n] = t[r + n];
        return this.bufferOff += e, e;
    };
    f.prototype._flushBuffer = function(t, r) {
        return this._update(this.buffer, 0, t, r), this.bufferOff = 0, this.blockSize;
    };
    f.prototype._updateEncrypt = function(t) {
        var r = 0, e = 0, n = (this.bufferOff + t.length) / this.blockSize | 0, a = new Array(n * this.blockSize);
        this.bufferOff !== 0 && (r += this._buffer(t, r), this.bufferOff === this.buffer.length && (e += this._flushBuffer(a, e)));
        for(var s = t.length - (t.length - r) % this.blockSize; r < s; r += this.blockSize)this._update(t, r, a, e), e += this.blockSize;
        for(; r < t.length; r++, this.bufferOff++)this.buffer[this.bufferOff] = t[r];
        return a;
    };
    f.prototype._updateDecrypt = function(t) {
        for(var r = 0, e = 0, n = Math.ceil((this.bufferOff + t.length) / this.blockSize) - 1, a = new Array(n * this.blockSize); n > 0; n--)r += this._buffer(t, r), e += this._flushBuffer(a, e);
        return r += this._buffer(t, r), a;
    };
    f.prototype.final = function(t) {
        var r;
        t && (r = this.update(t));
        var e;
        return this.type === "encrypt" ? e = this._finalEncrypt() : e = this._finalDecrypt(), r ? r.concat(e) : e;
    };
    f.prototype._pad = function(t, r) {
        if (r === 0) return !1;
        for(; r < t.length;)t[r++] = 0;
        return !0;
    };
    f.prototype._finalEncrypt = function() {
        if (!this._pad(this.buffer, this.bufferOff)) return [];
        var t = new Array(this.blockSize);
        return this._update(this.buffer, 0, t, 0), t;
    };
    f.prototype._unpad = function(t) {
        return t;
    };
    f.prototype._finalDecrypt = function() {
        W.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var t = new Array(this.blockSize);
        return this._flushBuffer(t, 0), this._unpad(t);
    };
});
var z = _((ft, K)=>{
    "use strict";
    var O = export_default, X = export_default, o = B(), j = S();
    function Y() {
        this.tmp = new Array(2), this.keys = null;
    }
    function h(p) {
        j.call(this, p);
        var t = new Y;
        this._desState = t, this.deriveKeys(t, p.key);
    }
    X(h, j);
    K.exports = h;
    h.create = function(t) {
        return new h(t);
    };
    var Z = [
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        1
    ];
    h.prototype.deriveKeys = function(t, r) {
        t.keys = new Array(16 * 2), O.equal(r.length, this.blockSize, "Invalid key length");
        var e = o.readUInt32BE(r, 0), n = o.readUInt32BE(r, 4);
        o.pc1(e, n, t.tmp, 0), e = t.tmp[0], n = t.tmp[1];
        for(var a = 0; a < t.keys.length; a += 2){
            var s = Z[a >>> 1];
            e = o.r28shl(e, s), n = o.r28shl(n, s), o.pc2(e, n, t.keys, a);
        }
    };
    h.prototype._update = function(t, r, e, n) {
        var a = this._desState, s = o.readUInt32BE(t, r), u = o.readUInt32BE(t, r + 4);
        o.ip(s, u, a.tmp, 0), s = a.tmp[0], u = a.tmp[1], this.type === "encrypt" ? this._encrypt(a, s, u, a.tmp, 0) : this._decrypt(a, s, u, a.tmp, 0), s = a.tmp[0], u = a.tmp[1], o.writeUInt32BE(e, s, n), o.writeUInt32BE(e, u, n + 4);
    };
    h.prototype._pad = function(t, r) {
        for(var e = t.length - r, n = r; n < t.length; n++)t[n] = e;
        return !0;
    };
    h.prototype._unpad = function(t) {
        for(var r = t[t.length - 1], e = t.length - r; e < t.length; e++)O.equal(t[e], r);
        return t.slice(0, t.length - r);
    };
    h.prototype._encrypt = function(t, r, e, n, a) {
        for(var s = r, u = e, i = 0; i < t.keys.length; i += 2){
            var b = t.keys[i], k = t.keys[i + 1];
            o.expand(u, t.tmp, 0), b ^= t.tmp[0], k ^= t.tmp[1];
            var E = o.substitute(b, k), x = o.permute(E), q = u;
            u = (s ^ x) >>> 0, s = q;
        }
        o.rip(u, s, n, a);
    };
    h.prototype._decrypt = function(t, r, e, n, a) {
        for(var s = e, u = r, i = t.keys.length - 2; i >= 0; i -= 2){
            var b = t.keys[i], k = t.keys[i + 1];
            o.expand(s, t.tmp, 0), b ^= t.tmp[0], k ^= t.tmp[1];
            var E = o.substitute(b, k), x = o.permute(E), q = s;
            s = (u ^ x) >>> 0, u = q;
        }
        o.rip(s, u, n, a);
    };
});
var M = _((T)=>{
    "use strict";
    var $ = export_default, tt = export_default, g = {};
    function rt(p) {
        $.equal(p.length, 8, "Invalid IV length"), this.iv = new Array(8);
        for(var t = 0; t < this.iv.length; t++)this.iv[t] = p[t];
    }
    function et(p) {
        function t(a) {
            p.call(this, a), this._cbcInit();
        }
        tt(t, p);
        for(var r = Object.keys(g), e = 0; e < r.length; e++){
            var n = r[e];
            t.prototype[n] = g[n];
        }
        return t.create = function(s) {
            return new t(s);
        }, t;
    }
    T.instantiate = et;
    g._cbcInit = function() {
        var t = new rt(this.options.iv);
        this._cbcState = t;
    };
    g._update = function(t, r, e, n) {
        var a = this._cbcState, s = this.constructor.super_.prototype, u = a.iv;
        if (this.type === "encrypt") {
            for(var i = 0; i < this.blockSize; i++)u[i] ^= t[r + i];
            s._update.call(this, u, 0, e, n);
            for(var i = 0; i < this.blockSize; i++)u[i] = e[n + i];
        } else {
            s._update.call(this, t, r, e, n);
            for(var i = 0; i < this.blockSize; i++)e[n + i] ^= u[i];
            for(var i = 0; i < this.blockSize; i++)u[i] = t[r + i];
        }
    };
});
var V = _((vt, P)=>{
    "use strict";
    var it = export_default, nt = export_default, N = S(), v = z();
    function at(p, t) {
        it.equal(t.length, 24, "Invalid key length");
        var r = t.slice(0, 8), e = t.slice(8, 16), n = t.slice(16, 24);
        p === "encrypt" ? this.ciphers = [
            v.create({
                type: "encrypt",
                key: r
            }),
            v.create({
                type: "decrypt",
                key: e
            }),
            v.create({
                type: "encrypt",
                key: n
            })
        ] : this.ciphers = [
            v.create({
                type: "decrypt",
                key: n
            }),
            v.create({
                type: "encrypt",
                key: e
            }),
            v.create({
                type: "decrypt",
                key: r
            })
        ];
    }
    function y(p) {
        N.call(this, p);
        var t = new at(this.type, this.options.key);
        this._edeState = t;
    }
    nt(y, N);
    P.exports = y;
    y.create = function(t) {
        return new y(t);
    };
    y.prototype._update = function(t, r, e, n) {
        var a = this._edeState;
        a.ciphers[0]._update(t, r, e, n), a.ciphers[1]._update(e, n, e, n), a.ciphers[2]._update(e, n, e, n);
    };
    y.prototype._pad = v.prototype._pad;
    y.prototype._unpad = v.prototype._unpad;
});
var I = _((d)=>{
    "use strict";
    d.utils = B();
    d.Cipher = S();
    d.DES = z();
    d.CBC = M();
    d.EDE = V();
});
var pt = D(I()), st = D(I()), { utils: yt , Cipher: _t , DES: dt , CBC: bt , EDE: kt  } = pt;
var export_default = st.default;
var E = Object.create;
var u = Object.defineProperty;
var b = Object.getOwnPropertyDescriptor;
var m = Object.getOwnPropertyNames;
var h = Object.getPrototypeOf, B = Object.prototype.hasOwnProperty;
var C = (e)=>u(e, "__esModule", {
        value: !0
    });
var l = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var D = (e, r, f)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of m(r))!B.call(e, i) && i !== "default" && u(e, i, {
        get: ()=>r[i],
        enumerable: !(f = b(r, i)) || f.enumerable
    });
    return e;
}, _ = (e)=>D(C(u(e != null ? E(h(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var y = l((w, p)=>{
    var v = export_default, s = export_default, q = export_default, t = export_default.Buffer, a = {
        "des-ede3-cbc": s.CBC.instantiate(s.EDE),
        "des-ede3": s.EDE,
        "des-ede-cbc": s.CBC.instantiate(s.EDE),
        "des-ede": s.EDE,
        "des-cbc": s.CBC.instantiate(s.DES),
        "des-ecb": s.DES
    };
    a.des = a["des-cbc"];
    a.des3 = a["des-ede3-cbc"];
    p.exports = o;
    q(o, v);
    function o(e) {
        v.call(this);
        var r = e.mode.toLowerCase(), f = a[r], i;
        e.decrypt ? i = "decrypt" : i = "encrypt";
        var d = e.key;
        t.isBuffer(d) || (d = t.from(d)), (r === "des-ede" || r === "des-ede-cbc") && (d = t.concat([
            d,
            d.slice(0, 8)
        ]));
        var c = e.iv;
        t.isBuffer(c) || (c = t.from(c)), this._des = f.create({
            key: d,
            iv: c,
            type: i
        });
    }
    o.prototype._update = function(e) {
        return t.from(this._des.update(e));
    };
    o.prototype._final = function() {
        return t.from(this._des.final());
    };
});
var k = _(y());
var export_default = k.default;
var Ge = Object.create;
var O = Object.defineProperty;
var ze = Object.getOwnPropertyDescriptor;
var He = Object.getOwnPropertyNames;
var Ke = Object.getPrototypeOf, Le = Object.prototype.hasOwnProperty;
var Pe = (e)=>O(e, "__esModule", {
        value: !0
    });
var l = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var Ze = (e, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let i of He(r))!Le.call(e, i) && i !== "default" && O(e, i, {
        get: ()=>r[i],
        enumerable: !(t = ze(r, i)) || t.enumerable
    });
    return e;
}, ae = (e)=>Ze(Pe(O(e != null ? Ge(Ke(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var ce = l((M)=>{
    M.encrypt = function(e, r) {
        return e._cipher.encryptBlock(r);
    };
    M.decrypt = function(e, r) {
        return e._cipher.decryptBlock(r);
    };
});
var he = l((G)=>{
    var ne = export_default;
    G.encrypt = function(e, r) {
        var t = ne(r, e._prev);
        return e._prev = e._cipher.encryptBlock(t), e._prev;
    };
    G.decrypt = function(e, r) {
        var t = e._prev;
        e._prev = r;
        var i = e._cipher.decryptBlock(r);
        return ne(i, t);
    };
});
var se = l((pe)=>{
    var U = export_default.Buffer, We = export_default;
    function oe(e, r, t) {
        var i = r.length, a = We(r, e._cache);
        return e._cache = e._cache.slice(i), e._prev = U.concat([
            e._prev,
            t ? r : a
        ]), a;
    }
    pe.encrypt = function(e, r, t) {
        for(var i = U.allocUnsafe(0), a; r.length;)if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = U.allocUnsafe(0)), e._cache.length <= r.length) a = e._cache.length, i = U.concat([
            i,
            oe(e, r.slice(0, a), t)
        ]), r = r.slice(a);
        else {
            i = U.concat([
                i,
                oe(e, r, t)
            ]);
            break;
        }
        return i;
    };
});
var ue = l((fe)=>{
    var z = export_default.Buffer;
    function Je(e, r, t) {
        var i = e._cipher.encryptBlock(e._prev), a = i[0] ^ r;
        return e._prev = z.concat([
            e._prev.slice(1),
            z.from([
                t ? r : a
            ])
        ]), a;
    }
    fe.encrypt = function(e, r, t) {
        for(var i = r.length, a = z.allocUnsafe(i), c = -1; ++c < i;)a[c] = Je(e, r[c], t);
        return a;
    };
});
var le = l((ve)=>{
    var D = export_default.Buffer;
    function Qe(e, r, t) {
        for(var i, a = -1, c = 8, n = 0, h, s; ++a < c;)i = e._cipher.encryptBlock(e._prev), h = r & 1 << 7 - a ? 128 : 0, s = i[0] ^ h, n += (s & 128) >> a % 8, e._prev = Ye(e._prev, t ? h : s);
        return n;
    }
    function Ye(e, r) {
        var t = e.length, i = -1, a = D.allocUnsafe(e.length);
        for(e = D.concat([
            e,
            D.from([
                r
            ])
        ]); ++i < t;)a[i] = e[i] << 1 | e[i + 1] >> 7;
        return a;
    }
    ve.encrypt = function(e, r, t) {
        for(var i = r.length, a = D.allocUnsafe(i), c = -1; ++c < i;)a[c] = Qe(e, r[c], t);
        return a;
    };
});
var ye = l((_e)=>{
    var $e = export_default;
    function je(e) {
        return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
    }
    _e.encrypt = function(e, r) {
        for(; e._cache.length < r.length;)e._cache = ut.concat([
            e._cache,
            je(e)
        ]);
        var t = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), $e(r, t);
    };
});
var H = l((zr, de)=>{
    function er(e) {
        for(var r = e.length, t; r--;)if (t = e.readUInt8(r), t === 255) e.writeUInt8(0, r);
        else {
            t++, e.writeUInt8(t, r);
            break;
        }
    }
    de.exports = er;
});
var L = l((me)=>{
    var rr = export_default, ge = export_default.Buffer, tr = H();
    function ir(e) {
        var r = e._cipher.encryptBlockRaw(e._prev);
        return tr(e._prev), r;
    }
    var K = 16;
    me.encrypt = function(e, r) {
        var t = Math.ceil(r.length / K), i = e._cache.length;
        e._cache = ge.concat([
            e._cache,
            ge.allocUnsafe(t * K)
        ]);
        for(var a = 0; a < t; a++){
            var c = ir(e), n = i + a * K;
            e._cache.writeUInt32BE(c[0], n + 0), e._cache.writeUInt32BE(c[1], n + 4), e._cache.writeUInt32BE(c[2], n + 8), e._cache.writeUInt32BE(c[3], n + 12);
        }
        var h = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), rr(r, h);
    };
});
var P = l((Kr, ar)=>{
    ar.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
});
var W = l((Lr, Be)=>{
    var cr = {
        ECB: ce(),
        CBC: he(),
        CFB: se(),
        CFB8: ue(),
        CFB1: le(),
        OFB: ye(),
        CTR: L(),
        GCM: L()
    }, F = P();
    for(Z in F)F[Z].module = cr[F[Z].mode];
    var Z;
    Be.exports = F;
});
var I = l((Pr, Ee)=>{
    var R = export_default.Buffer;
    function J(e) {
        R.isBuffer(e) || (e = R.from(e));
        for(var r = e.length / 4 | 0, t = new Array(r), i = 0; i < r; i++)t[i] = e.readUInt32BE(i * 4);
        return t;
    }
    function Q(e) {
        for(var r = 0; r < e.length; e++)e[r] = 0;
    }
    function we(e, r, t, i, a) {
        for(var c = t[0], n = t[1], h = t[2], s = t[3], p = e[0] ^ r[0], u = e[1] ^ r[1], y = e[2] ^ r[2], d = e[3] ^ r[3], f, C, b, x, w = 4, ie = 1; ie < a; ie++)f = c[p >>> 24] ^ n[u >>> 16 & 255] ^ h[y >>> 8 & 255] ^ s[d & 255] ^ r[w++], C = c[u >>> 24] ^ n[y >>> 16 & 255] ^ h[d >>> 8 & 255] ^ s[p & 255] ^ r[w++], b = c[y >>> 24] ^ n[d >>> 16 & 255] ^ h[p >>> 8 & 255] ^ s[u & 255] ^ r[w++], x = c[d >>> 24] ^ n[p >>> 16 & 255] ^ h[u >>> 8 & 255] ^ s[y & 255] ^ r[w++], p = f, u = C, y = b, d = x;
        return f = (i[p >>> 24] << 24 | i[u >>> 16 & 255] << 16 | i[y >>> 8 & 255] << 8 | i[d & 255]) ^ r[w++], C = (i[u >>> 24] << 24 | i[y >>> 16 & 255] << 16 | i[d >>> 8 & 255] << 8 | i[p & 255]) ^ r[w++], b = (i[y >>> 24] << 24 | i[d >>> 16 & 255] << 16 | i[p >>> 8 & 255] << 8 | i[u & 255]) ^ r[w++], x = (i[d >>> 24] << 24 | i[p >>> 16 & 255] << 16 | i[u >>> 8 & 255] << 8 | i[y & 255]) ^ r[w++], f = f >>> 0, C = C >>> 0, b = b >>> 0, x = x >>> 0, [
            f,
            C,
            b,
            x
        ];
    }
    var nr = [
        0,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54
    ], v = function() {
        for(var e = new Array(256), r = 0; r < 256; r++)r < 128 ? e[r] = r << 1 : e[r] = r << 1 ^ 283;
        for(var t = [], i = [], a = [
            [],
            [],
            [],
            []
        ], c = [
            [],
            [],
            [],
            []
        ], n = 0, h = 0, s = 0; s < 256; ++s){
            var p = h ^ h << 1 ^ h << 2 ^ h << 3 ^ h << 4;
            p = p >>> 8 ^ p & 255 ^ 99, t[n] = p, i[p] = n;
            var u = e[n], y = e[u], d = e[y], f = e[p] * 257 ^ p * 16843008;
            a[0][n] = f << 24 | f >>> 8, a[1][n] = f << 16 | f >>> 16, a[2][n] = f << 8 | f >>> 24, a[3][n] = f, f = d * 16843009 ^ y * 65537 ^ u * 257 ^ n * 16843008, c[0][p] = f << 24 | f >>> 8, c[1][p] = f << 16 | f >>> 16, c[2][p] = f << 8 | f >>> 24, c[3][p] = f, n === 0 ? n = h = 1 : (n = u ^ e[e[e[d ^ u]]], h ^= e[e[h]]);
        }
        return {
            SBOX: t,
            INV_SBOX: i,
            SUB_MIX: a,
            INV_SUB_MIX: c
        };
    }();
    function g(e) {
        this._key = J(e), this._reset();
    }
    g.blockSize = 4 * 4;
    g.keySize = 256 / 8;
    g.prototype.blockSize = g.blockSize;
    g.prototype.keySize = g.keySize;
    g.prototype._reset = function() {
        for(var e = this._key, r = e.length, t = r + 6, i = (t + 1) * 4, a = [], c = 0; c < r; c++)a[c] = e[c];
        for(c = r; c < i; c++){
            var n = a[c - 1];
            c % r == 0 ? (n = n << 8 | n >>> 24, n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255], n ^= nr[c / r | 0] << 24) : r > 6 && c % r == 4 && (n = v.SBOX[n >>> 24] << 24 | v.SBOX[n >>> 16 & 255] << 16 | v.SBOX[n >>> 8 & 255] << 8 | v.SBOX[n & 255]), a[c] = a[c - r] ^ n;
        }
        for(var h = [], s = 0; s < i; s++){
            var p = i - s, u = a[p - (s % 4 ? 0 : 4)];
            s < 4 || p <= 4 ? h[s] = u : h[s] = v.INV_SUB_MIX[0][v.SBOX[u >>> 24]] ^ v.INV_SUB_MIX[1][v.SBOX[u >>> 16 & 255]] ^ v.INV_SUB_MIX[2][v.SBOX[u >>> 8 & 255]] ^ v.INV_SUB_MIX[3][v.SBOX[u & 255]];
        }
        this._nRounds = t, this._keySchedule = a, this._invKeySchedule = h;
    };
    g.prototype.encryptBlockRaw = function(e) {
        return e = J(e), we(e, this._keySchedule, v.SUB_MIX, v.SBOX, this._nRounds);
    };
    g.prototype.encryptBlock = function(e) {
        var r = this.encryptBlockRaw(e), t = R.allocUnsafe(16);
        return t.writeUInt32BE(r[0], 0), t.writeUInt32BE(r[1], 4), t.writeUInt32BE(r[2], 8), t.writeUInt32BE(r[3], 12), t;
    };
    g.prototype.decryptBlock = function(e) {
        e = J(e);
        var r = e[1];
        e[1] = e[3], e[3] = r;
        var t = we(e, this._invKeySchedule, v.INV_SUB_MIX, v.INV_SBOX, this._nRounds), i = R.allocUnsafe(16);
        return i.writeUInt32BE(t[0], 0), i.writeUInt32BE(t[3], 4), i.writeUInt32BE(t[2], 8), i.writeUInt32BE(t[1], 12), i;
    };
    g.prototype.scrub = function() {
        Q(this._keySchedule), Q(this._invKeySchedule), Q(this._key);
    };
    Ee.exports.AES = g;
});
var xe = l((Zr, be)=>{
    var S = export_default.Buffer, hr = S.alloc(16, 0);
    function or(e) {
        return [
            e.readUInt32BE(0),
            e.readUInt32BE(4),
            e.readUInt32BE(8),
            e.readUInt32BE(12)
        ];
    }
    function Ce(e) {
        var r = S.allocUnsafe(16);
        return r.writeUInt32BE(e[0] >>> 0, 0), r.writeUInt32BE(e[1] >>> 0, 4), r.writeUInt32BE(e[2] >>> 0, 8), r.writeUInt32BE(e[3] >>> 0, 12), r;
    }
    function k(e) {
        this.h = e, this.state = S.alloc(16, 0), this.cache = S.allocUnsafe(0);
    }
    k.prototype.ghash = function(e) {
        for(var r = -1; ++r < e.length;)this.state[r] ^= e[r];
        this._multiply();
    };
    k.prototype._multiply = function() {
        for(var e = or(this.h), r = [
            0,
            0,
            0,
            0
        ], t, i, a, c = -1; ++c < 128;){
            for(i = (this.state[~~(c / 8)] & 1 << 7 - c % 8) != 0, i && (r[0] ^= e[0], r[1] ^= e[1], r[2] ^= e[2], r[3] ^= e[3]), a = (e[3] & 1) != 0, t = 3; t > 0; t--)e[t] = e[t] >>> 1 | (e[t - 1] & 1) << 31;
            e[0] = e[0] >>> 1, a && (e[0] = e[0] ^ 225 << 24);
        }
        this.state = Ce(r);
    };
    k.prototype.update = function(e) {
        this.cache = S.concat([
            this.cache,
            e
        ]);
        for(var r; this.cache.length >= 16;)r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(r);
    };
    k.prototype.final = function(e, r) {
        return this.cache.length && this.ghash(S.concat([
            this.cache,
            hr
        ], 16)), this.ghash(Ce([
            0,
            e,
            0,
            r
        ])), this.state;
    };
    be.exports = k;
});
var Y = l((Wr, Ue)=>{
    var pr = I(), _ = export_default.Buffer, Se = export_default, sr = export_default, Ae = xe(), fr = export_default, ur = H();
    function vr(e, r) {
        var t = 0;
        e.length !== r.length && t++;
        for(var i = Math.min(e.length, r.length), a = 0; a < i; ++a)t += e[a] ^ r[a];
        return t;
    }
    function lr(e, r, t) {
        if (r.length === 12) return e._finID = _.concat([
            r,
            _.from([
                0,
                0,
                0,
                1
            ])
        ]), _.concat([
            r,
            _.from([
                0,
                0,
                0,
                2
            ])
        ]);
        var i = new Ae(t), a = r.length, c = a % 16;
        i.update(r), c && (c = 16 - c, i.update(_.alloc(c, 0))), i.update(_.alloc(8, 0));
        var n = a * 8, h = _.alloc(8);
        h.writeUIntBE(n, 0, 8), i.update(h), e._finID = i.state;
        var s = _.from(e._finID);
        return ur(s), s;
    }
    function E(e, r, t, i) {
        Se.call(this);
        var a = _.alloc(4, 0);
        this._cipher = new pr.AES(r);
        var c = this._cipher.encryptBlock(a);
        this._ghash = new Ae(c), t = lr(this, t, c), this._prev = _.from(t), this._cache = _.allocUnsafe(0), this._secCache = _.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
    }
    sr(E, Se);
    E.prototype._update = function(e) {
        if (!this._called && this._alen) {
            var r = 16 - this._alen % 16;
            r < 16 && (r = _.alloc(r, 0), this._ghash.update(r));
        }
        this._called = !0;
        var t = this._mode.encrypt(this, e);
        return this._decrypt ? this._ghash.update(e) : this._ghash.update(t), this._len += e.length, t;
    };
    E.prototype._final = function() {
        if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
        var e = fr(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && vr(e, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = e, this._cipher.scrub();
    };
    E.prototype.getAuthTag = function() {
        if (this._decrypt || !_.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
    };
    E.prototype.setAuthTag = function(r) {
        if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = r;
    };
    E.prototype.setAAD = function(r) {
        if (this._called) throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(r), this._alen += r.length;
    };
    Ue.exports = E;
});
var j = l((Jr, ke)=>{
    var _r = I(), $ = export_default.Buffer, Ie = export_default, yr = export_default;
    function X(e, r, t, i) {
        Ie.call(this), this._cipher = new _r.AES(r), this._prev = $.from(t), this._cache = $.allocUnsafe(0), this._secCache = $.allocUnsafe(0), this._decrypt = i, this._mode = e;
    }
    yr(X, Ie);
    X.prototype._update = function(e) {
        return this._mode.encrypt(this, e, this._decrypt);
    };
    X.prototype._final = function() {
        this._cipher.scrub();
    };
    ke.exports = X;
});
var Fe = l((ee)=>{
    var qe = W(), dr = Y(), B = export_default.Buffer, gr = j(), Te = export_default, mr = I(), Br = export_default, wr = export_default;
    function q(e, r, t) {
        Te.call(this), this._cache = new N, this._cipher = new mr.AES(r), this._prev = B.from(t), this._mode = e, this._autopadding = !0;
    }
    wr(q, Te);
    q.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get();)t = this._mode.encrypt(this, r), i.push(t);
        return B.concat(i);
    };
    var Er = B.alloc(16, 16);
    q.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
        if (!e.equals(Er)) throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    q.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function N() {
        this.cache = B.allocUnsafe(0);
    }
    N.prototype.add = function(e) {
        this.cache = B.concat([
            this.cache,
            e
        ]);
    };
    N.prototype.get = function() {
        if (this.cache.length > 15) {
            var e = this.cache.slice(0, 16);
            return this.cache = this.cache.slice(16), e;
        }
        return null;
    };
    N.prototype.flush = function() {
        for(var e = 16 - this.cache.length, r = B.allocUnsafe(e), t = -1; ++t < e;)r.writeUInt8(e, t);
        return B.concat([
            this.cache,
            r
        ]);
    };
    function De(e, r, t) {
        var i = qe[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof r == "string" && (r = B.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        if (typeof t == "string" && (t = B.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        return i.type === "stream" ? new gr(i.module, r, t) : i.type === "auth" ? new dr(i.module, r, t) : new q(i.module, r, t);
    }
    function Cr(e, r) {
        var t = qe[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Br(r, !1, t.key, t.iv);
        return De(e, i.key, i.iv);
    }
    ee.createCipheriv = De;
    ee.createCipher = Cr;
});
var Ve = l((re)=>{
    var br = Y(), A = export_default.Buffer, Re = W(), xr = j(), Xe = export_default, Sr = I(), Ar = export_default, Ur = export_default;
    function T(e, r, t) {
        Xe.call(this), this._cache = new V, this._last = void 0, this._cipher = new Sr.AES(r), this._prev = A.from(t), this._mode = e, this._autopadding = !0;
    }
    Ur(T, Xe);
    T.prototype._update = function(e) {
        this._cache.add(e);
        for(var r, t, i = []; r = this._cache.get(this._autopadding);)t = this._mode.decrypt(this, r), i.push(t);
        return A.concat(i);
    };
    T.prototype._final = function() {
        var e = this._cache.flush();
        if (this._autopadding) return Ir(this._mode.decrypt(this, e));
        if (e) throw new Error("data not multiple of block length");
    };
    T.prototype.setAutoPadding = function(e) {
        return this._autopadding = !!e, this;
    };
    function V() {
        this.cache = A.allocUnsafe(0);
    }
    V.prototype.add = function(e) {
        this.cache = A.concat([
            this.cache,
            e
        ]);
    };
    V.prototype.get = function(e) {
        var r;
        if (e) {
            if (this.cache.length > 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        } else if (this.cache.length >= 16) return r = this.cache.slice(0, 16), this.cache = this.cache.slice(16), r;
        return null;
    };
    V.prototype.flush = function() {
        if (this.cache.length) return this.cache;
    };
    function Ir(e) {
        var r = e[15];
        if (r < 1 || r > 16) throw new Error("unable to decrypt data");
        for(var t = -1; ++t < r;)if (e[t + (16 - r)] !== r) throw new Error("unable to decrypt data");
        if (r !== 16) return e.slice(0, 16 - r);
    }
    function Ne(e, r, t) {
        var i = Re[e.toLowerCase()];
        if (!i) throw new TypeError("invalid suite type");
        if (typeof t == "string" && (t = A.from(t)), i.mode !== "GCM" && t.length !== i.iv) throw new TypeError("invalid iv length " + t.length);
        if (typeof r == "string" && (r = A.from(r)), r.length !== i.key / 8) throw new TypeError("invalid key length " + r.length);
        return i.type === "stream" ? new xr(i.module, r, t, !0) : i.type === "auth" ? new br(i.module, r, t, !0) : new T(i.module, r, t);
    }
    function kr(e, r) {
        var t = Re[e.toLowerCase()];
        if (!t) throw new TypeError("invalid suite type");
        var i = Ar(r, !1, t.key, t.iv);
        return Ne(e, i.key, i.iv);
    }
    re.createDecipher = kr;
    re.createDecipheriv = Ne;
});
var te = l((m)=>{
    var Oe = Fe(), Me = Ve(), qr = P();
    function Tr() {
        return Object.keys(qr);
    }
    m.createCipher = m.Cipher = Oe.createCipher;
    m.createCipheriv = m.Cipheriv = Oe.createCipheriv;
    m.createDecipher = m.Decipher = Me.createDecipher;
    m.createDecipheriv = m.Decipheriv = Me.createDecipheriv;
    m.listCiphers = m.getCiphers = Tr;
});
var Dr = ae(te()), Fr = ae(te()), { createCipher: jr , Cipher: et , createCipheriv: rt , Cipheriv: tt , createDecipher: it , Decipher: at , createDecipheriv: ct , Decipheriv: nt , listCiphers: ht , getCiphers: ot  } = Dr;
var export_default = Fr.default;
var N = Object.create;
var B = Object.defineProperty;
var D = Object.getOwnPropertyDescriptor;
var H = Object.getOwnPropertyNames;
var J = Object.getPrototypeOf, K = Object.prototype.hasOwnProperty;
var L = (e)=>B(e, "__esModule", {
        value: !0
    });
var p = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var Q = (e, r, t)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let c of H(r))!K.call(e, c) && c !== "default" && B(e, c, {
        get: ()=>r[c],
        enumerable: !(t = D(r, c)) || t.enumerable
    });
    return e;
}, V = (e)=>Q(L(B(e != null ? N(J(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var E = p((_)=>{
    _.encrypt = function(e, r) {
        return e._cipher.encryptBlock(r);
    };
    _.decrypt = function(e, r) {
        return e._cipher.decryptBlock(r);
    };
});
var f = p((b)=>{
    var S = export_default;
    b.encrypt = function(e, r) {
        var t = S(r, e._prev);
        return e._prev = e._cipher.encryptBlock(t), e._prev;
    };
    b.decrypt = function(e, r) {
        var t = e._prev;
        e._prev = r;
        var c = e._cipher.decryptBlock(r);
        return S(c, t);
    };
});
var g = p((s)=>{
    var h = export_default.Buffer, W = export_default;
    function A(e, r, t) {
        var c = r.length, a = W(r, e._cache);
        return e._cache = e._cache.slice(c), e._prev = h.concat([
            e._prev,
            t ? r : a
        ]), a;
    }
    s.encrypt = function(e, r, t) {
        for(var c = h.allocUnsafe(0), a; r.length;)if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = h.allocUnsafe(0)), e._cache.length <= r.length) a = e._cache.length, c = h.concat([
            c,
            A(e, r.slice(0, a), t)
        ]), r = r.slice(a);
        else {
            c = h.concat([
                c,
                A(e, r, t)
            ]);
            break;
        }
        return c;
    };
});
var F = p((q)=>{
    var k = export_default.Buffer;
    function X(e, r, t) {
        var c = e._cipher.encryptBlock(e._prev), a = c[0] ^ r;
        return e._prev = k.concat([
            e._prev.slice(1),
            k.from([
                t ? r : a
            ])
        ]), a;
    }
    q.encrypt = function(e, r, t) {
        for(var c = r.length, a = k.allocUnsafe(c), i = -1; ++i < c;)a[i] = X(e, r[i], t);
        return a;
    };
});
var x = p((w)=>{
    var y = export_default.Buffer;
    function Y(e, r, t) {
        for(var c, a = -1, i = 8, o = 0, v, m; ++a < i;)c = e._cipher.encryptBlock(e._prev), v = r & 1 << 7 - a ? 128 : 0, m = c[0] ^ v, o += (m & 128) >> a % 8, e._prev = Z(e._prev, t ? v : m);
        return o;
    }
    function Z(e, r) {
        var t = e.length, c = -1, a = y.allocUnsafe(e.length);
        for(e = y.concat([
            e,
            y.from([
                r
            ])
        ]); ++c < t;)a[c] = e[c] << 1 | e[c + 1] >> 7;
        return a;
    }
    w.encrypt = function(e, r, t) {
        for(var c = r.length, a = y.allocUnsafe(c), i = -1; ++i < c;)a[i] = Y(e, r[i], t);
        return a;
    };
});
var I = p((U)=>{
    var $ = export_default;
    function P(e) {
        return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
    }
    U.encrypt = function(e, r) {
        for(; e._cache.length < r.length;)e._cache = ut.concat([
            e._cache,
            P(e)
        ]);
        var t = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), $(r, t);
    };
});
var R = p((Be, M)=>{
    function ee(e) {
        for(var r = e.length, t; r--;)if (t = e.readUInt8(r), t === 255) e.writeUInt8(0, r);
        else {
            t++, e.writeUInt8(t, r);
            break;
        }
    }
    M.exports = ee;
});
var d = p((O)=>{
    var re = export_default, G = export_default.Buffer, ce = R();
    function te(e) {
        var r = e._cipher.encryptBlockRaw(e._prev);
        return ce(e._prev), r;
    }
    var C = 16;
    O.encrypt = function(e, r) {
        var t = Math.ceil(r.length / C), c = e._cache.length;
        e._cache = G.concat([
            e._cache,
            G.allocUnsafe(t * C)
        ]);
        for(var a = 0; a < t; a++){
            var i = te(e), o = c + a * C;
            e._cache.writeUInt32BE(i[0], o + 0), e._cache.writeUInt32BE(i[1], o + 4), e._cache.writeUInt32BE(i[2], o + 8), e._cache.writeUInt32BE(i[3], o + 12);
        }
        var v = e._cache.slice(0, r.length);
        return e._cache = e._cache.slice(r.length), re(r, v);
    };
});
var T = p((be, ae)=>{
    ae.exports = {
        "aes-128-ecb": {
            cipher: "AES",
            key: 128,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-192-ecb": {
            cipher: "AES",
            key: 192,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-256-ecb": {
            cipher: "AES",
            key: 256,
            iv: 0,
            mode: "ECB",
            type: "block"
        },
        "aes-128-cbc": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-192-cbc": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-256-cbc": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes128: {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes192: {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        aes256: {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CBC",
            type: "block"
        },
        "aes-128-cfb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-192-cfb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-256-cfb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB",
            type: "stream"
        },
        "aes-128-cfb8": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-192-cfb8": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-256-cfb8": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB8",
            type: "stream"
        },
        "aes-128-cfb1": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-192-cfb1": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-256-cfb1": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CFB1",
            type: "stream"
        },
        "aes-128-ofb": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-192-ofb": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-256-ofb": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "OFB",
            type: "stream"
        },
        "aes-128-ctr": {
            cipher: "AES",
            key: 128,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-192-ctr": {
            cipher: "AES",
            key: 192,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-256-ctr": {
            cipher: "AES",
            key: 256,
            iv: 16,
            mode: "CTR",
            type: "stream"
        },
        "aes-128-gcm": {
            cipher: "AES",
            key: 128,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-192-gcm": {
            cipher: "AES",
            key: 192,
            iv: 12,
            mode: "GCM",
            type: "auth"
        },
        "aes-256-gcm": {
            cipher: "AES",
            key: 256,
            iv: 12,
            mode: "GCM",
            type: "auth"
        }
    };
});
var z = p((ke, j)=>{
    var ie = {
        ECB: E(),
        CBC: f(),
        CFB: g(),
        CFB8: F(),
        CFB1: x(),
        OFB: I(),
        CTR: d(),
        GCM: d()
    }, u = T();
    for(l in u)u[l].module = ie[u[l].mode];
    var l;
    j.exports = u;
});
var pe = V(z());
var export_default = pe.default;
var b = Object.create;
var r = Object.defineProperty;
var k = Object.getOwnPropertyDescriptor;
var t = Object.getOwnPropertyNames;
var v = Object.getPrototypeOf, f = Object.prototype.hasOwnProperty;
var m = (e)=>r(e, "__esModule", {
        value: !0
    });
var a = (e, d)=>()=>(d || e((d = {
            exports: {}
        }).exports, d), d.exports);
var p = (e, d, c)=>{
    if (d && typeof d == "object" || typeof d == "function") for (let o of t(d))!f.call(e, o) && o !== "default" && r(e, o, {
        get: ()=>d[o],
        enumerable: !(c = k(d, o)) || c.enumerable
    });
    return e;
}, y = (e)=>p(m(r(e != null ? b(v(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var i = a((s)=>{
    s["des-ecb"] = {
        key: 8,
        iv: 0
    };
    s["des-cbc"] = s.des = {
        key: 8,
        iv: 8
    };
    s["des-ede3-cbc"] = s.des3 = {
        key: 24,
        iv: 8
    };
    s["des-ede3"] = {
        key: 24,
        iv: 0
    };
    s["des-ede-cbc"] = {
        key: 16,
        iv: 8
    };
    s["des-ede"] = {
        key: 16,
        iv: 0
    };
});
var w = y(i()), x = y(i()), { des: n , des3: u  } = w;
var export_default = x.default;
var k = Object.create;
var v = Object.defineProperty;
var l = Object.getOwnPropertyDescriptor;
var D = Object.getOwnPropertyNames;
var b = Object.getPrototypeOf, L = Object.prototype.hasOwnProperty;
var m = (e)=>v(e, "__esModule", {
        value: !0
    });
var q = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var E = (e, r, i)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let p of D(r))!L.call(e, p) && p !== "default" && v(e, p, {
        get: ()=>r[p],
        enumerable: !(i = l(r, p)) || i.enumerable
    });
    return e;
}, f = (e)=>E(m(v(e != null ? k(b(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var y = q((o)=>{
    var s = export_default, n = export_default, c = export_default, a = export_default, w = export_default;
    function g(e, r) {
        e = e.toLowerCase();
        var i, p;
        if (c[e]) i = c[e].key, p = c[e].iv;
        else if (a[e]) i = a[e].key * 8, p = a[e].iv;
        else throw new TypeError("invalid suite type");
        var t = w(r, !1, i, p);
        return C(e, t.key, t.iv);
    }
    function T(e, r) {
        e = e.toLowerCase();
        var i, p;
        if (c[e]) i = c[e].key, p = c[e].iv;
        else if (a[e]) i = a[e].key * 8, p = a[e].iv;
        else throw new TypeError("invalid suite type");
        var t = w(r, !1, i, p);
        return d(e, t.key, t.iv);
    }
    function C(e, r, i) {
        if (e = e.toLowerCase(), c[e]) return n.createCipheriv(e, r, i);
        if (a[e]) return new s({
            key: r,
            iv: i,
            mode: e
        });
        throw new TypeError("invalid suite type");
    }
    function d(e, r, i) {
        if (e = e.toLowerCase(), c[e]) return n.createDecipheriv(e, r, i);
        if (a[e]) return new s({
            key: r,
            iv: i,
            mode: e,
            decrypt: !0
        });
        throw new TypeError("invalid suite type");
    }
    function _() {
        return Object.keys(a).concat(n.getCiphers());
    }
    o.createCipher = o.Cipher = g;
    o.createCipheriv = o.Cipheriv = C;
    o.createDecipher = o.Decipher = T;
    o.createDecipheriv = o.Decipheriv = d;
    o.listCiphers = o.getCiphers = _;
});
var x = f(y()), M = f(y()), { createCipher: S , Cipher: z , createCipheriv: A , Cipheriv: B , createDecipher: F , Decipher: G , createDecipheriv: H , Decipheriv: I , listCiphers: J , getCiphers: K  } = x;
var export_default = M.default;
__default.env.NODE_ENV = "production";
var __global$ = window;
var T = Object.create;
var a = Object.defineProperty;
var U = Object.getOwnPropertyDescriptor;
var b = Object.getOwnPropertyNames;
var A = Object.getPrototypeOf, S = Object.prototype.hasOwnProperty;
var k = (r)=>a(r, "__esModule", {
        value: !0
    });
var M = (r, n)=>()=>(n || r((n = {
            exports: {}
        }).exports, n), n.exports);
var R = (r, n, e)=>{
    if (n && typeof n == "object" || typeof n == "function") for (let t of b(n))!S.call(r, t) && t !== "default" && a(r, t, {
        get: ()=>n[t],
        enumerable: !(e = U(n, t)) || e.enumerable
    });
    return r;
}, y = (r)=>R(k(a(r != null ? T(A(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var i = M((o)=>{
    "use strict";
    function p() {
        throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var w = export_default, c = export_default, f = w.Buffer, d = w.kMaxLength, l = __global$.crypto || __global$.msCrypto, g = Math.pow(2, 32) - 1;
    function h(r, n) {
        if (typeof r != "number" || r !== r) throw new TypeError("offset must be a number");
        if (r > g || r < 0) throw new TypeError("offset must be a uint32");
        if (r > d || r > n) throw new RangeError("offset out of range");
    }
    function s(r, n, e) {
        if (typeof r != "number" || r !== r) throw new TypeError("size must be a number");
        if (r > g || r < 0) throw new TypeError("size must be a uint32");
        if (r + n > e || r > d) throw new RangeError("buffer too small");
    }
    l && l.getRandomValues || !__default.browser ? (o.randomFill = q, o.randomFillSync = L) : (o.randomFill = p, o.randomFillSync = p);
    function q(r, n, e, t) {
        if (!f.isBuffer(r) && !(r instanceof __global$.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof n == "function") t = n, n = 0, e = r.length;
        else if (typeof e == "function") t = e, e = r.length - n;
        else if (typeof t != "function") throw new TypeError('"cb" argument must be a function');
        return h(n, r.length), s(e, n, r.length), E(r, n, e, t);
    }
    function E(r, n, e, t) {
        if (__default.browser) {
            var F = r.buffer, v = new Uint8Array(F, n, e);
            if (l.getRandomValues(v), t) {
                __default.nextTick(function() {
                    t(null, r);
                });
                return;
            }
            return r;
        }
        if (t) {
            c(e, function(u, x) {
                if (u) return t(u);
                x.copy(r, n), t(null, r);
            });
            return;
        }
        var B = c(e);
        return B.copy(r, n), r;
    }
    function L(r, n, e) {
        if (typeof n == "undefined" && (n = 0), !f.isBuffer(r) && !(r instanceof __global$.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        return h(n, r.length), e === void 0 && (e = r.length - n), s(e, n, r.length), E(r, n, e);
    }
});
var V = y(i()), _ = y(i()), { randomFill: O , randomFillSync: j  } = V;
var export_default = _.default;
var I = Object.create;
var d = Object.defineProperty;
var Z = Object.getOwnPropertyDescriptor;
var C = Object.getOwnPropertyNames;
var F = Object.getPrototypeOf, G = Object.prototype.hasOwnProperty;
var J = (e)=>d(e, "__esModule", {
        value: !0
    });
var v = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var O = (e, r, a)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let n of C(r))!G.call(e, n) && n !== "default" && d(e, n, {
        get: ()=>r[n],
        enumerable: !(a = Z(r, n)) || a.enumerable
    });
    return e;
}, k = (e)=>O(J(d(e != null ? I(F(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var g = v((vr, B)=>{
    var Q = export_default, w = export_default.Buffer;
    B.exports = function(e, r) {
        for(var a = w.alloc(0), n = 0, t; a.length < r;)t = T(n++), a = w.concat([
            a,
            Q("sha1").update(e).update(t).digest()
        ]);
        return a.slice(0, r);
    };
    function T(e) {
        var r = w.allocUnsafe(4);
        return r.writeUInt32BE(e, 0), r;
    }
});
var y = v((hr, D)=>{
    D.exports = function(r, a) {
        for(var n = r.length, t = -1; ++t < n;)r[t] ^= a[t];
        return r;
    };
});
var b = v((dr, P)=>{
    var L = export_default, V = export_default.Buffer;
    function W(e, r) {
        return V.from(e.toRed(L.mont(r.modulus)).redPow(new L(r.publicExponent)).fromRed().toArray());
    }
    P.exports = W;
});
var N = v((wr, j)=>{
    var X = export_default, m = export_default, Y = export_default, H = g(), S = y(), q = export_default, $ = b(), K = export_default, f = export_default.Buffer;
    j.exports = function(r, a, n) {
        var t;
        r.padding ? t = r.padding : n ? t = 1 : t = 4;
        var i = X(r), o;
        if (t === 4) o = rr(i, a);
        else if (t === 1) o = er(i, a, n);
        else if (t === 3) {
            if (o = new q(a), o.cmp(i.modulus) >= 0) throw new Error("data too long for modulus");
        } else throw new Error("unknown padding");
        return n ? K(o, i) : $(o, i);
    };
    function rr(e, r) {
        var a = e.modulus.byteLength(), n = r.length, t = Y("sha1").update(f.alloc(0)).digest(), i = t.length, o = 2 * i;
        if (n > a - o - 2) throw new Error("message too long");
        var c = f.alloc(a - n - o - 2), l = a - i - 1, s = m(i), x = S(f.concat([
            t,
            c,
            f.alloc(1, 1),
            r
        ], l), H(s, l)), A = S(s, H(x, i));
        return new q(f.concat([
            f.alloc(1),
            A,
            x
        ], a));
    }
    function er(e, r, a) {
        var n = r.length, t = e.modulus.byteLength();
        if (n > t - 11) throw new Error("message too long");
        var i;
        return a ? i = f.alloc(t - n - 3, 255) : i = tr(t - n - 3), new q(f.concat([
            f.from([
                0,
                a ? 1 : 2
            ]),
            i,
            f.alloc(1),
            r
        ], t));
    }
    function tr(e) {
        for(var r = f.allocUnsafe(e), a = 0, n = m(e * 2), t = 0, i; a < e;)t === n.length && (n = m(e * 2), t = 0), i = n[t++], i && (r[a++] = i);
        return r;
    }
});
var z = v((gr, _)=>{
    var ar = export_default, U = g(), M = y(), R = export_default, nr = export_default, ir = export_default, or = b(), h = export_default.Buffer;
    _.exports = function(r, a, n) {
        var t;
        r.padding ? t = r.padding : n ? t = 1 : t = 4;
        var i = ar(r), o = i.modulus.byteLength();
        if (a.length > o || new R(a).cmp(i.modulus) >= 0) throw new Error("decryption error");
        var c;
        n ? c = or(new R(a), i) : c = nr(a, i);
        var l = h.alloc(o - c.length);
        if (c = h.concat([
            l,
            c
        ], o), t === 4) return ur(i, c);
        if (t === 1) return cr(i, c, n);
        if (t === 3) return c;
        throw new Error("unknown padding");
    };
    function ur(e, r) {
        var a = e.modulus.byteLength(), n = ir("sha1").update(h.alloc(0)).digest(), t = n.length;
        if (r[0] !== 0) throw new Error("decryption error");
        var i = r.slice(1, t + 1), o = r.slice(t + 1), c = M(i, U(o, t)), l = M(o, U(c, a - t - 1));
        if (fr(n, l.slice(0, t))) throw new Error("decryption error");
        for(var s = t; l[s] === 0;)s++;
        if (l[s++] !== 1) throw new Error("decryption error");
        return l.slice(s);
    }
    function cr(e, r, a) {
        for(var n = r.slice(0, 2), t = 2, i = 0; r[t++] !== 0;)if (t >= r.length) {
            i++;
            break;
        }
        var o = r.slice(2, t - 1);
        if ((n.toString("hex") !== "0002" && !a || n.toString("hex") !== "0001" && a) && i++, o.length < 8 && i++, i) throw new Error("decryption error");
        return r.slice(t);
    }
    function fr(e, r) {
        e = h.from(e), r = h.from(r);
        var a = 0, n = e.length;
        e.length !== r.length && (a++, n = Math.min(e.length, r.length));
        for(var t = -1; ++t < n;)a += e[t] ^ r[t];
        return a;
    }
});
var E = v((p)=>{
    p.publicEncrypt = N();
    p.privateDecrypt = z();
    p.privateEncrypt = function(r, a) {
        return p.publicEncrypt(r, a, !0);
    };
    p.publicDecrypt = function(r, a) {
        return p.privateDecrypt(r, a, !0);
    };
});
var lr = k(E()), sr = k(E()), { publicEncrypt: br , privateDecrypt: mr , privateEncrypt: qr , publicDecrypt: Er  } = lr;
var export_default = sr.default;
var rr = Object.create;
var e0 = Object.defineProperty;
var tr = Object.getOwnPropertyDescriptor;
var er = Object.getOwnPropertyNames;
var ar = Object.getPrototypeOf, hr = Object.prototype.hasOwnProperty;
var ir = (r)=>e0(r, "__esModule", {
        value: !0
    });
var p = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var sr = (r, t, i)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let a of er(t))!hr.call(r, a) && a !== "default" && e0(r, a, {
        get: ()=>t[a],
        enumerable: !(i = tr(t, a)) || i.enumerable
    });
    return r;
}, m0 = (r)=>sr(ir(e0(r != null ? rr(ar(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var g = p((o)=>{
    "use strict";
    var nr = export_default, fr = export_default;
    o.inherits = fr;
    function cr(r, t) {
        return (r.charCodeAt(t) & 64512) != 55296 || t < 0 || t + 1 >= r.length ? !1 : (r.charCodeAt(t + 1) & 64512) == 56320;
    }
    function ur(r, t) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var i = [];
        if (typeof r == "string") if (t) {
            if (t === "hex") for(r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 != 0 && (r = "0" + r), e = 0; e < r.length; e += 2)i.push(parseInt(r[e] + r[e + 1], 16));
        } else for(var a = 0, e = 0; e < r.length; e++){
            var h = r.charCodeAt(e);
            h < 128 ? i[a++] = h : h < 2048 ? (i[a++] = h >> 6 | 192, i[a++] = h & 63 | 128) : cr(r, e) ? (h = 65536 + ((h & 1023) << 10) + (r.charCodeAt(++e) & 1023), i[a++] = h >> 18 | 240, i[a++] = h >> 12 & 63 | 128, i[a++] = h >> 6 & 63 | 128, i[a++] = h & 63 | 128) : (i[a++] = h >> 12 | 224, i[a++] = h >> 6 & 63 | 128, i[a++] = h & 63 | 128);
        }
        else for(e = 0; e < r.length; e++)i[e] = r[e] | 0;
        return i;
    }
    o.toArray = ur;
    function xr(r) {
        for(var t = "", i = 0; i < r.length; i++)t += q0(r[i].toString(16));
        return t;
    }
    o.toHex = xr;
    function S0(r) {
        var t = r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (r & 255) << 24;
        return t >>> 0;
    }
    o.htonl = S0;
    function or(r, t) {
        for(var i = "", a = 0; a < r.length; a++){
            var e = r[a];
            t === "little" && (e = S0(e)), i += H0(e.toString(16));
        }
        return i;
    }
    o.toHex32 = or;
    function q0(r) {
        return r.length === 1 ? "0" + r : r;
    }
    o.zero2 = q0;
    function H0(r) {
        return r.length === 7 ? "0" + r : r.length === 6 ? "00" + r : r.length === 5 ? "000" + r : r.length === 4 ? "0000" + r : r.length === 3 ? "00000" + r : r.length === 2 ? "000000" + r : r.length === 1 ? "0000000" + r : r;
    }
    o.zero8 = H0;
    function vr(r, t, i, a) {
        var e = i - t;
        nr(e % 4 == 0);
        for(var h = new Array(e / 4), s = 0, n = t; s < h.length; s++, n += 4){
            var c;
            a === "big" ? c = r[n] << 24 | r[n + 1] << 16 | r[n + 2] << 8 | r[n + 3] : c = r[n + 3] << 24 | r[n + 2] << 16 | r[n + 1] << 8 | r[n], h[s] = c >>> 0;
        }
        return h;
    }
    o.join32 = vr;
    function lr(r, t) {
        for(var i = new Array(r.length * 4), a = 0, e = 0; a < r.length; a++, e += 4){
            var h = r[a];
            t === "big" ? (i[e] = h >>> 24, i[e + 1] = h >>> 16 & 255, i[e + 2] = h >>> 8 & 255, i[e + 3] = h & 255) : (i[e + 3] = h >>> 24, i[e + 2] = h >>> 16 & 255, i[e + 1] = h >>> 8 & 255, i[e] = h & 255);
        }
        return i;
    }
    o.split32 = lr;
    function dr(r, t) {
        return r >>> t | r << 32 - t;
    }
    o.rotr32 = dr;
    function br(r, t) {
        return r << t | r >>> 32 - t;
    }
    o.rotl32 = br;
    function _r(r, t) {
        return r + t >>> 0;
    }
    o.sum32 = _r;
    function pr(r, t, i) {
        return r + t + i >>> 0;
    }
    o.sum32_3 = pr;
    function gr(r, t, i, a) {
        return r + t + i + a >>> 0;
    }
    o.sum32_4 = gr;
    function mr(r, t, i, a, e) {
        return r + t + i + a + e >>> 0;
    }
    o.sum32_5 = mr;
    function Sr(r, t, i, a) {
        var e = r[t], h = r[t + 1], s = a + h >>> 0, n = (s < a ? 1 : 0) + i + e;
        r[t] = n >>> 0, r[t + 1] = s;
    }
    o.sum64 = Sr;
    function qr(r, t, i, a) {
        var e = t + a >>> 0, h = (e < t ? 1 : 0) + r + i;
        return h >>> 0;
    }
    o.sum64_hi = qr;
    function Hr(r, t, i, a) {
        var e = t + a;
        return e >>> 0;
    }
    o.sum64_lo = Hr;
    function Ar(r, t, i, a, e, h, s, n) {
        var c = 0, f = t;
        f = f + a >>> 0, c += f < t ? 1 : 0, f = f + h >>> 0, c += f < h ? 1 : 0, f = f + n >>> 0, c += f < n ? 1 : 0;
        var x = r + i + e + s + c;
        return x >>> 0;
    }
    o.sum64_4_hi = Ar;
    function zr(r, t, i, a, e, h, s, n) {
        var c = t + a + h + n;
        return c >>> 0;
    }
    o.sum64_4_lo = zr;
    function Br(r, t, i, a, e, h, s, n, c, f) {
        var x = 0, u = t;
        u = u + a >>> 0, x += u < t ? 1 : 0, u = u + h >>> 0, x += u < h ? 1 : 0, u = u + n >>> 0, x += u < n ? 1 : 0, u = u + f >>> 0, x += u < f ? 1 : 0;
        var v = r + i + e + s + c + x;
        return v >>> 0;
    }
    o.sum64_5_hi = Br;
    function yr(r, t, i, a, e, h, s, n, c, f) {
        var x = t + a + h + n + f;
        return x >>> 0;
    }
    o.sum64_5_lo = yr;
    function Cr(r, t, i) {
        var a = t << 32 - i | r >>> i;
        return a >>> 0;
    }
    o.rotr64_hi = Cr;
    function Lr(r, t, i) {
        var a = r << 32 - i | t >>> i;
        return a >>> 0;
    }
    o.rotr64_lo = Lr;
    function Wr(r, t, i) {
        return r >>> i;
    }
    o.shr64_hi = Wr;
    function kr(r, t, i) {
        var a = r << 32 - i | t >>> i;
        return a >>> 0;
    }
    o.shr64_lo = kr;
});
var K = p((z0)=>{
    "use strict";
    var A0 = g(), Dr = export_default;
    function w() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    z0.BlockHash = w;
    w.prototype.update = function(t, i) {
        if (t = A0.toArray(t, i), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
            t = this.pending;
            var a = t.length % this._delta8;
            this.pending = t.slice(t.length - a, t.length), this.pending.length === 0 && (this.pending = null), t = A0.join32(t, 0, t.length - a, this.endian);
            for(var e = 0; e < t.length; e += this._delta32)this._update(t, e, e + this._delta32);
        }
        return this;
    };
    w.prototype.digest = function(t) {
        return this.update(this._pad()), Dr(this.pending === null), this._digest(t);
    };
    w.prototype._pad = function() {
        var t = this.pendingTotal, i = this._delta8, a = i - (t + this.padLength) % i, e = new Array(a + this.padLength);
        e[0] = 128;
        for(var h = 1; h < a; h++)e[h] = 0;
        if (t <<= 3, this.endian === "big") {
            for(var s = 8; s < this.padLength; s++)e[h++] = 0;
            e[h++] = 0, e[h++] = 0, e[h++] = 0, e[h++] = 0, e[h++] = t >>> 24 & 255, e[h++] = t >>> 16 & 255, e[h++] = t >>> 8 & 255, e[h++] = t & 255;
        } else for(e[h++] = t & 255, e[h++] = t >>> 8 & 255, e[h++] = t >>> 16 & 255, e[h++] = t >>> 24 & 255, e[h++] = 0, e[h++] = 0, e[h++] = 0, e[h++] = 0, s = 8; s < this.padLength; s++)e[h++] = 0;
        return e;
    };
});
var a0 = p((C)=>{
    "use strict";
    var Fr = g(), q = Fr.rotr32;
    function Er(r, t, i, a) {
        if (r === 0) return B0(t, i, a);
        if (r === 1 || r === 3) return C0(t, i, a);
        if (r === 2) return y0(t, i, a);
    }
    C.ft_1 = Er;
    function B0(r, t, i) {
        return r & t ^ ~r & i;
    }
    C.ch32 = B0;
    function y0(r, t, i) {
        return r & t ^ r & i ^ t & i;
    }
    C.maj32 = y0;
    function C0(r, t, i) {
        return r ^ t ^ i;
    }
    C.p32 = C0;
    function Kr(r) {
        return q(r, 2) ^ q(r, 13) ^ q(r, 22);
    }
    C.s0_256 = Kr;
    function Ir(r) {
        return q(r, 6) ^ q(r, 11) ^ q(r, 25);
    }
    C.s1_256 = Ir;
    function Pr(r) {
        return q(r, 7) ^ q(r, 18) ^ r >>> 3;
    }
    C.g0_256 = Pr;
    function Mr(r) {
        return q(r, 17) ^ q(r, 19) ^ r >>> 10;
    }
    C.g1_256 = Mr;
});
var k0 = p((Kt, W0)=>{
    "use strict";
    var I = g(), Rr = K(), Gr = a0(), h0 = I.rotl32, Y = I.sum32, Jr = I.sum32_5, Nr = Gr.ft_1, L0 = Rr.BlockHash, Or = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
    ];
    function H() {
        if (!(this instanceof H)) return new H;
        L0.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.W = new Array(80);
    }
    I.inherits(H, L0);
    W0.exports = H;
    H.blockSize = 512;
    H.outSize = 160;
    H.hmacStrength = 80;
    H.padLength = 64;
    H.prototype._update = function(t, i) {
        for(var a = this.W, e = 0; e < 16; e++)a[e] = t[i + e];
        for(; e < a.length; e++)a[e] = h0(a[e - 3] ^ a[e - 8] ^ a[e - 14] ^ a[e - 16], 1);
        var h = this.h[0], s = this.h[1], n = this.h[2], c = this.h[3], f = this.h[4];
        for(e = 0; e < a.length; e++){
            var x = ~~(e / 20), u = Jr(h0(h, 5), Nr(x, s, n, c), f, a[e], Or[x]);
            f = c, c = n, n = h0(s, 30), s = h, h = u;
        }
        this.h[0] = Y(this.h[0], h), this.h[1] = Y(this.h[1], s), this.h[2] = Y(this.h[2], n), this.h[3] = Y(this.h[3], c), this.h[4] = Y(this.h[4], f);
    };
    H.prototype._digest = function(t) {
        return t === "hex" ? I.toHex32(this.h, "big") : I.split32(this.h, "big");
    };
});
var i0 = p((It, F0)=>{
    "use strict";
    var P = g(), Qr = K(), M = a0(), Ur = export_default, m = P.sum32, Vr = P.sum32_4, Xr = P.sum32_5, Yr = M.ch32, Zr = M.maj32, $r = M.s0_256, jr = M.s1_256, wr = M.g0_256, Tr = M.g1_256, D0 = Qr.BlockHash, rt = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
    ];
    function A() {
        if (!(this instanceof A)) return new A;
        D0.call(this), this.h = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
        ], this.k = rt, this.W = new Array(64);
    }
    P.inherits(A, D0);
    F0.exports = A;
    A.blockSize = 512;
    A.outSize = 256;
    A.hmacStrength = 192;
    A.padLength = 64;
    A.prototype._update = function(t, i) {
        for(var a = this.W, e = 0; e < 16; e++)a[e] = t[i + e];
        for(; e < a.length; e++)a[e] = Vr(Tr(a[e - 2]), a[e - 7], wr(a[e - 15]), a[e - 16]);
        var h = this.h[0], s = this.h[1], n = this.h[2], c = this.h[3], f = this.h[4], x = this.h[5], u = this.h[6], v = this.h[7];
        for(Ur(this.k.length === a.length), e = 0; e < a.length; e++){
            var l = Xr(v, jr(f), Yr(f, x, u), this.k[e], a[e]), _ = m($r(h), Zr(h, s, n));
            v = u, u = x, x = f, f = m(c, l), c = n, n = s, s = h, h = m(l, _);
        }
        this.h[0] = m(this.h[0], h), this.h[1] = m(this.h[1], s), this.h[2] = m(this.h[2], n), this.h[3] = m(this.h[3], c), this.h[4] = m(this.h[4], f), this.h[5] = m(this.h[5], x), this.h[6] = m(this.h[6], u), this.h[7] = m(this.h[7], v);
    };
    A.prototype._digest = function(t) {
        return t === "hex" ? P.toHex32(this.h, "big") : P.split32(this.h, "big");
    };
});
var I0 = p((Pt, K0)=>{
    "use strict";
    var s0 = g(), E0 = i0();
    function L() {
        if (!(this instanceof L)) return new L;
        E0.call(this), this.h = [
            3238371032,
            914150663,
            812702999,
            4144912697,
            4290775857,
            1750603025,
            1694076839,
            3204075428
        ];
    }
    s0.inherits(L, E0);
    K0.exports = L;
    L.blockSize = 512;
    L.outSize = 224;
    L.hmacStrength = 192;
    L.padLength = 64;
    L.prototype._digest = function(t) {
        return t === "hex" ? s0.toHex32(this.h.slice(0, 7), "big") : s0.split32(this.h.slice(0, 7), "big");
    };
});
var c0 = p((Mt, G0)=>{
    "use strict";
    var b = g(), tt = K(), et = export_default, z = b.rotr64_hi, B = b.rotr64_lo, P0 = b.shr64_hi, M0 = b.shr64_lo, k = b.sum64, n0 = b.sum64_hi, f0 = b.sum64_lo, at = b.sum64_4_hi, ht = b.sum64_4_lo, it = b.sum64_5_hi, st = b.sum64_5_lo, R0 = tt.BlockHash, nt = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
    ];
    function S() {
        if (!(this instanceof S)) return new S;
        R0.call(this), this.h = [
            1779033703,
            4089235720,
            3144134277,
            2227873595,
            1013904242,
            4271175723,
            2773480762,
            1595750129,
            1359893119,
            2917565137,
            2600822924,
            725511199,
            528734635,
            4215389547,
            1541459225,
            327033209
        ], this.k = nt, this.W = new Array(160);
    }
    b.inherits(S, R0);
    G0.exports = S;
    S.blockSize = 1024;
    S.outSize = 512;
    S.hmacStrength = 192;
    S.padLength = 128;
    S.prototype._prepareBlock = function(t, i) {
        for(var a = this.W, e = 0; e < 32; e++)a[e] = t[i + e];
        for(; e < a.length; e += 2){
            var h = pt(a[e - 4], a[e - 3]), s = gt(a[e - 4], a[e - 3]), n = a[e - 14], c = a[e - 13], f = bt(a[e - 30], a[e - 29]), x = _t(a[e - 30], a[e - 29]), u = a[e - 32], v = a[e - 31];
            a[e] = at(h, s, n, c, f, x, u, v), a[e + 1] = ht(h, s, n, c, f, x, u, v);
        }
    };
    S.prototype._update = function(t, i) {
        this._prepareBlock(t, i);
        var a = this.W, e = this.h[0], h = this.h[1], s = this.h[2], n = this.h[3], c = this.h[4], f = this.h[5], x = this.h[6], u = this.h[7], v = this.h[8], l = this.h[9], _ = this.h[10], J = this.h[11], N = this.h[12], O = this.h[13], r0 = this.h[14], t0 = this.h[15];
        et(this.k.length === a.length);
        for(var F = 0; F < a.length; F += 2){
            var Q = r0, U = t0, V = lt(v, l), X = dt(v, l), o0 = ft(v, l, _, J, N, O), v0 = ct(v, l, _, J, N, O), l0 = this.k[F], d0 = this.k[F + 1], b0 = a[F], _0 = a[F + 1], $ = it(Q, U, V, X, o0, v0, l0, d0, b0, _0), j = st(Q, U, V, X, o0, v0, l0, d0, b0, _0);
            Q = ot(e, h), U = vt(e, h), V = ut(e, h, s, n, c, f), X = xt(e, h, s, n, c, f);
            var p0 = n0(Q, U, V, X), g0 = f0(Q, U, V, X);
            r0 = N, t0 = O, N = _, O = J, _ = v, J = l, v = n0(x, u, $, j), l = f0(u, u, $, j), x = c, u = f, c = s, f = n, s = e, n = h, e = n0($, j, p0, g0), h = f0($, j, p0, g0);
        }
        k(this.h, 0, e, h), k(this.h, 2, s, n), k(this.h, 4, c, f), k(this.h, 6, x, u), k(this.h, 8, v, l), k(this.h, 10, _, J), k(this.h, 12, N, O), k(this.h, 14, r0, t0);
    };
    S.prototype._digest = function(t) {
        return t === "hex" ? b.toHex32(this.h, "big") : b.split32(this.h, "big");
    };
    function ft(r, t, i, a, e) {
        var h = r & i ^ ~r & e;
        return h < 0 && (h += 4294967296), h;
    }
    function ct(r, t, i, a, e, h) {
        var s = t & a ^ ~t & h;
        return s < 0 && (s += 4294967296), s;
    }
    function ut(r, t, i, a, e) {
        var h = r & i ^ r & e ^ i & e;
        return h < 0 && (h += 4294967296), h;
    }
    function xt(r, t, i, a, e, h) {
        var s = t & a ^ t & h ^ a & h;
        return s < 0 && (s += 4294967296), s;
    }
    function ot(r, t) {
        var i = z(r, t, 28), a = z(t, r, 2), e = z(t, r, 7), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function vt(r, t) {
        var i = B(r, t, 28), a = B(t, r, 2), e = B(t, r, 7), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function lt(r, t) {
        var i = z(r, t, 14), a = z(r, t, 18), e = z(t, r, 9), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function dt(r, t) {
        var i = B(r, t, 14), a = B(r, t, 18), e = B(t, r, 9), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function bt(r, t) {
        var i = z(r, t, 1), a = z(r, t, 8), e = P0(r, t, 7), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function _t(r, t) {
        var i = B(r, t, 1), a = B(r, t, 8), e = M0(r, t, 7), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function pt(r, t) {
        var i = z(r, t, 19), a = z(t, r, 29), e = P0(r, t, 6), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
    function gt(r, t) {
        var i = B(r, t, 19), a = B(t, r, 29), e = M0(r, t, 6), h = i ^ a ^ e;
        return h < 0 && (h += 4294967296), h;
    }
});
var O0 = p((Rt, N0)=>{
    "use strict";
    var u0 = g(), J0 = c0();
    function W() {
        if (!(this instanceof W)) return new W;
        J0.call(this), this.h = [
            3418070365,
            3238371032,
            1654270250,
            914150663,
            2438529370,
            812702999,
            355462360,
            4144912697,
            1731405415,
            4290775857,
            2394180231,
            1750603025,
            3675008525,
            1694076839,
            1203062813,
            3204075428
        ];
    }
    u0.inherits(W, J0);
    N0.exports = W;
    W.blockSize = 1024;
    W.outSize = 384;
    W.hmacStrength = 192;
    W.padLength = 128;
    W.prototype._digest = function(t) {
        return t === "hex" ? u0.toHex32(this.h.slice(0, 12), "big") : u0.split32(this.h.slice(0, 12), "big");
    };
});
var Q0 = p((R)=>{
    "use strict";
    R.sha1 = k0();
    R.sha224 = I0();
    R.sha256 = i0();
    R.sha384 = O0();
    R.sha512 = c0();
});
var $0 = p((Z0)=>{
    "use strict";
    var D = g(), mt = K(), T = D.rotl32, U0 = D.sum32, Z = D.sum32_3, V0 = D.sum32_4, X0 = mt.BlockHash;
    function y() {
        if (!(this instanceof y)) return new y;
        X0.call(this), this.h = [
            1732584193,
            4023233417,
            2562383102,
            271733878,
            3285377520
        ], this.endian = "little";
    }
    D.inherits(y, X0);
    Z0.ripemd160 = y;
    y.blockSize = 512;
    y.outSize = 160;
    y.hmacStrength = 192;
    y.padLength = 64;
    y.prototype._update = function(t, i) {
        for(var a = this.h[0], e = this.h[1], h = this.h[2], s = this.h[3], n = this.h[4], c = a, f = e, x = h, u = s, v = n, l = 0; l < 80; l++){
            var _ = U0(T(V0(a, Y0(l, e, h, s), t[Ht[l] + i], St(l)), zt[l]), n);
            a = n, n = s, s = T(h, 10), h = e, e = _, _ = U0(T(V0(c, Y0(79 - l, f, x, u), t[At[l] + i], qt(l)), Bt[l]), v), c = v, v = u, u = T(x, 10), x = f, f = _;
        }
        _ = Z(this.h[1], h, u), this.h[1] = Z(this.h[2], s, v), this.h[2] = Z(this.h[3], n, c), this.h[3] = Z(this.h[4], a, f), this.h[4] = Z(this.h[0], e, x), this.h[0] = _;
    };
    y.prototype._digest = function(t) {
        return t === "hex" ? D.toHex32(this.h, "little") : D.split32(this.h, "little");
    };
    function Y0(r, t, i, a) {
        return r <= 15 ? t ^ i ^ a : r <= 31 ? t & i | ~t & a : r <= 47 ? (t | ~i) ^ a : r <= 63 ? t & a | i & ~a : t ^ (i | ~a);
    }
    function St(r) {
        return r <= 15 ? 0 : r <= 31 ? 1518500249 : r <= 47 ? 1859775393 : r <= 63 ? 2400959708 : 2840853838;
    }
    function qt(r) {
        return r <= 15 ? 1352829926 : r <= 31 ? 1548603684 : r <= 47 ? 1836072691 : r <= 63 ? 2053994217 : 0;
    }
    var Ht = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
    ], At = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
    ], zt = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
    ], Bt = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
    ];
});
var w0 = p((Nt, j0)=>{
    "use strict";
    var yt = g(), Ct = export_default;
    function G(r, t, i) {
        if (!(this instanceof G)) return new G(r, t, i);
        this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(yt.toArray(t, i));
    }
    j0.exports = G;
    G.prototype._init = function(t) {
        t.length > this.blockSize && (t = new this.Hash().update(t).digest()), Ct(t.length <= this.blockSize);
        for(var i = t.length; i < this.blockSize; i++)t.push(0);
        for(i = 0; i < t.length; i++)t[i] ^= 54;
        for(this.inner = new this.Hash().update(t), i = 0; i < t.length; i++)t[i] ^= 106;
        this.outer = new this.Hash().update(t);
    };
    G.prototype.update = function(t, i) {
        return this.inner.update(t, i), this;
    };
    G.prototype.digest = function(t) {
        return this.outer.update(this.inner.digest()), this.outer.digest(t);
    };
});
var x0 = p((T0)=>{
    var d = T0;
    d.utils = g();
    d.common = K();
    d.sha = Q0();
    d.ripemd = $0();
    d.hmac = w0();
    d.sha1 = d.sha.sha1;
    d.sha256 = d.sha.sha256;
    d.sha224 = d.sha.sha224;
    d.sha384 = d.sha.sha384;
    d.sha512 = d.sha.sha512;
    d.ripemd160 = d.ripemd.ripemd160;
});
var Lt = m0(x0()), Wt = m0(x0()), { utils: Qt , common: Ut , sha: Vt , ripemd: Xt , hmac: Yt , sha1: Zt , sha256: $t , sha224: jt , sha384: wt , sha512: Tt , ripemd160: re  } = Lt;
var export_default = Wt.default;
var p = Object.create;
var i = Object.defineProperty;
var x = Object.getOwnPropertyDescriptor;
var y = Object.getOwnPropertyNames;
var A = Object.getPrototypeOf, z = Object.prototype.hasOwnProperty;
var d = (r)=>i(r, "__esModule", {
        value: !0
    });
var s = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var H = (r, e, n)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let t of y(e))!z.call(r, t) && t !== "default" && i(r, t, {
        get: ()=>e[t],
        enumerable: !(n = x(e, t)) || n.enumerable
    });
    return r;
}, C = (r)=>H(d(i(r != null ? p(A(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var v = s((h)=>{
    "use strict";
    var f = h;
    function I(r, e) {
        if (Array.isArray(r)) return r.slice();
        if (!r) return [];
        var n = [];
        if (typeof r != "string") {
            for(var t = 0; t < r.length; t++)n[t] = r[t] | 0;
            return n;
        }
        if (e === "hex") {
            r = r.replace(/[^a-z0-9]+/ig, ""), r.length % 2 != 0 && (r = "0" + r);
            for(var t = 0; t < r.length; t += 2)n.push(parseInt(r[t] + r[t + 1], 16));
        } else for(var t = 0; t < r.length; t++){
            var u = r.charCodeAt(t), a = u >> 8, o = u & 255;
            a ? n.push(a, o) : n.push(o);
        }
        return n;
    }
    f.toArray = I;
    function l(r) {
        return r.length === 1 ? "0" + r : r;
    }
    f.zero2 = l;
    function c(r) {
        for(var e = "", n = 0; n < r.length; n++)e += l(r[n].toString(16));
        return e;
    }
    f.toHex = c;
    f.encode = function(e, n) {
        return n === "hex" ? c(e) : e;
    };
});
var S = C(v());
var export_default = S.default;
var y = Object.create;
var u = Object.defineProperty;
var f = Object.getOwnPropertyDescriptor;
var _ = Object.getOwnPropertyNames;
var g = Object.getPrototypeOf, v = Object.prototype.hasOwnProperty;
var V = (t)=>u(t, "__esModule", {
        value: !0
    });
var d = (t, e)=>()=>(e || t((e = {
            exports: {}
        }).exports, e), e.exports);
var x = (t, e, s)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let i of _(e))!v.call(t, i) && i !== "default" && u(t, i, {
        get: ()=>e[i],
        enumerable: !(s = f(e, i)) || s.enumerable
    });
    return t;
}, A = (t)=>x(V(u(t != null ? y(g(t)) : {}, "default", t && t.__esModule && "default" in t ? {
        get: ()=>t.default,
        enumerable: !0
    } : {
        value: t,
        enumerable: !0
    })), t);
var m = d((q, c)=>{
    "use strict";
    var w = export_default, a = export_default, p = export_default;
    function h(t) {
        if (!(this instanceof h)) return new h(t);
        this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var e = a.toArray(t.entropy, t.entropyEnc || "hex"), s = a.toArray(t.nonce, t.nonceEnc || "hex"), i = a.toArray(t.pers, t.persEnc || "hex");
        p(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, s, i);
    }
    c.exports = h;
    h.prototype._init = function(e, s, i) {
        var n = e.concat(s).concat(i);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for(var r = 0; r < this.V.length; r++)this.K[r] = 0, this.V[r] = 1;
        this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    h.prototype._hmac = function() {
        return new w.hmac(this.hash, this.K);
    };
    h.prototype._update = function(e) {
        var s = this._hmac().update(this.V).update([
            0
        ]);
        e && (s = s.update(e)), this.K = s.digest(), this.V = this._hmac().update(this.V).digest(), !!e && (this.K = this._hmac().update(this.V).update([
            1
        ]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    h.prototype.reseed = function(e, s, i, n) {
        typeof s != "string" && (n = i, i = s, s = null), e = a.toArray(e, s), i = a.toArray(i, n), p(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(i || [])), this._reseed = 1;
    };
    h.prototype.generate = function(e, s, i, n) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        typeof s != "string" && (n = i, i = s, s = null), i && (i = a.toArray(i, n || "hex"), this._update(i));
        for(var r = []; r.length < e;)this.V = this._hmac().update(this.V).digest(), r = r.concat(this.V);
        var l = r.slice(0, e);
        return this._update(i), this._reseed++, a.encode(l, s);
    };
});
var K = A(m());
var export_default = K.default;
var o = Object.create;
var vf = Object.create;
var u = Object.create;
var m = Object.create;
var F = Object.create;
var G = Object.create;
var _ = Object.create;
var n = Object.defineProperty;
var h = Object.getOwnPropertyDescriptor;
var v = Object.getOwnPropertyNames;
var g = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty;
var m = (e)=>n(e, "__esModule", {
        value: !0
    });
var P = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var b = (e, t, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of v(t))!l.call(e, i) && i !== "default" && n(e, i, {
        get: ()=>t[i],
        enumerable: !(r = h(t, i)) || r.enumerable
    });
    return e;
}, B = (e)=>b(m(n(e != null ? o(g(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var le = Object.defineProperty;
var lf = Object.getOwnPropertyDescriptor;
var pf = Object.getOwnPropertyNames;
var yf = Object.getPrototypeOf, mf = Object.prototype.hasOwnProperty;
var Sf = (d)=>le(d, "__esModule", {
        value: !0
    });
var M = (d, e)=>()=>(e || d((e = {
            exports: {}
        }).exports, e), e.exports);
var gf = (d, e, f)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let r of pf(e))!mf.call(d, r) && r !== "default" && le(d, r, {
        get: ()=>e[r],
        enumerable: !(f = lf(e, r)) || f.enumerable
    });
    return d;
}, Af = (d)=>gf(Sf(le(d != null ? vf(yf(d)) : {}, "default", d && d.__esModule && "default" in d ? {
        get: ()=>d.default,
        enumerable: !0
    } : {
        value: d,
        enumerable: !0
    })), d);
var Pe = M((Zf, xf)=>{
    xf.exports = {
        name: "elliptic",
        version: "6.5.4",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
            "lib"
        ],
        scripts: {
            lint: "eslint lib test",
            "lint:fix": "npm run lint -- --fix",
            unit: "istanbul test _mocha --reporter=spec test/index.js",
            test: "npm run lint && npm run unit",
            version: "grunt dist && git add dist/"
        },
        repository: {
            type: "git",
            url: "git@github.com:indutny/elliptic"
        },
        keywords: [
            "EC",
            "Elliptic",
            "curve",
            "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
            url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
            brfs: "^2.0.2",
            coveralls: "^3.1.0",
            eslint: "^7.6.0",
            grunt: "^1.2.1",
            "grunt-browserify": "^5.3.0",
            "grunt-cli": "^1.3.2",
            "grunt-contrib-connect": "^3.0.0",
            "grunt-contrib-copy": "^1.0.0",
            "grunt-contrib-uglify": "^5.0.0",
            "grunt-mocha-istanbul": "^5.0.2",
            "grunt-saucelabs": "^9.0.1",
            istanbul: "^0.4.5",
            mocha: "^8.0.1"
        },
        dependencies: {
            "bn.js": "^4.11.9",
            brorand: "^1.1.0",
            "hash.js": "^1.0.0",
            "hmac-drbg": "^1.0.1",
            inherits: "^2.0.4",
            "minimalistic-assert": "^1.0.1",
            "minimalistic-crypto-utils": "^1.0.1"
        }
    };
});
var z = M((ze)=>{
    "use strict";
    var B = ze, If = export_default, wf = export_default, fe = export_default;
    B.assert = wf;
    B.toArray = fe.toArray;
    B.zero2 = fe.zero2;
    B.toHex = fe.toHex;
    B.encode = fe.encode;
    function Mf(d, e, f) {
        var r = new Array(Math.max(d.bitLength(), f) + 1);
        r.fill(0);
        for(var a = 1 << e + 1, c = d.clone(), i = 0; i < r.length; i++){
            var t, b = c.andln(a - 1);
            c.isOdd() ? (b > (a >> 1) - 1 ? t = (a >> 1) - b : t = b, c.isubn(t)) : t = 0, r[i] = t, c.iushrn(1);
        }
        return r;
    }
    B.getNAF = Mf;
    function qf(d, e) {
        var f = [
            [],
            []
        ];
        d = d.clone(), e = e.clone();
        for(var r = 0, a = 0, c; d.cmpn(-r) > 0 || e.cmpn(-a) > 0;){
            var i = d.andln(3) + r & 3, t = e.andln(3) + a & 3;
            i === 3 && (i = -1), t === 3 && (t = -1);
            var b;
            (i & 1) == 0 ? b = 0 : (c = d.andln(7) + r & 7, (c === 3 || c === 5) && t === 2 ? b = -i : b = i), f[0].push(b);
            var s;
            (t & 1) == 0 ? s = 0 : (c = e.andln(7) + a & 7, (c === 3 || c === 5) && i === 2 ? s = -t : s = t), f[1].push(s), 2 * r === b + 1 && (r = 1 - r), 2 * a === s + 1 && (a = 1 - a), d.iushrn(1), e.iushrn(1);
        }
        return f;
    }
    B.getJSF = qf;
    function _f(d, e, f) {
        var r = "_" + e;
        d.prototype[e] = function() {
            return this[r] !== void 0 ? this[r] : this[r] = f.call(this);
        };
    }
    B.cachedProperty = _f;
    function Pf(d) {
        return typeof d == "string" ? B.toArray(d, "hex") : d;
    }
    B.parseBytes = Pf;
    function zf(d) {
        return new If(d, "hex", "le");
    }
    B.intFromLE = zf;
});
var Q = M((Qf, Re)=>{
    "use strict";
    var X = export_default, $ = z(), de = $.getNAF, Rf = $.getJSF, re = $.assert;
    function L(d, e) {
        this.type = d, this.p = new X(e.p, 16), this.red = e.prime ? X.red(e.prime) : X.mont(this.p), this.zero = new X(0).toRed(this.red), this.one = new X(1).toRed(this.red), this.two = new X(2).toRed(this.red), this.n = e.n && new X(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var f = this.n && this.p.div(this.n);
        !f || f.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
    }
    Re.exports = L;
    L.prototype.point = function() {
        throw new Error("Not implemented");
    };
    L.prototype.validate = function() {
        throw new Error("Not implemented");
    };
    L.prototype._fixedNafMul = function(e, f) {
        re(e.precomputed);
        var r = e._getDoubles(), a = de(f, 1, this._bitLength), c = (1 << r.step + 1) - (r.step % 2 == 0 ? 2 : 1);
        c /= 3;
        var i = [], t, b;
        for(t = 0; t < a.length; t += r.step){
            b = 0;
            for(var s = t + r.step - 1; s >= t; s--)b = (b << 1) + a[s];
            i.push(b);
        }
        for(var n = this.jpoint(null, null, null), u = this.jpoint(null, null, null), o = c; o > 0; o--){
            for(t = 0; t < i.length; t++)b = i[t], b === o ? u = u.mixedAdd(r.points[t]) : b === -o && (u = u.mixedAdd(r.points[t].neg()));
            n = n.add(u);
        }
        return n.toP();
    };
    L.prototype._wnafMul = function(e, f) {
        var r = 4, a = e._getNAFPoints(r);
        r = a.wnd;
        for(var c = a.points, i = de(f, r, this._bitLength), t = this.jpoint(null, null, null), b = i.length - 1; b >= 0; b--){
            for(var s = 0; b >= 0 && i[b] === 0; b--)s++;
            if (b >= 0 && s++, t = t.dblp(s), b < 0) break;
            var n = i[b];
            re(n !== 0), e.type === "affine" ? n > 0 ? t = t.mixedAdd(c[n - 1 >> 1]) : t = t.mixedAdd(c[-n - 1 >> 1].neg()) : n > 0 ? t = t.add(c[n - 1 >> 1]) : t = t.add(c[-n - 1 >> 1].neg());
        }
        return e.type === "affine" ? t.toP() : t;
    };
    L.prototype._wnafMulAdd = function(e, f, r, a, c) {
        var i = this._wnafT1, t = this._wnafT2, b = this._wnafT3, s = 0, n, u, o;
        for(n = 0; n < a; n++){
            o = f[n];
            var v = o._getNAFPoints(e);
            i[n] = v.wnd, t[n] = v.points;
        }
        for(n = a - 1; n >= 1; n -= 2){
            var h = n - 1, l = n;
            if (i[h] !== 1 || i[l] !== 1) {
                b[h] = de(r[h], i[h], this._bitLength), b[l] = de(r[l], i[l], this._bitLength), s = Math.max(b[h].length, s), s = Math.max(b[l].length, s);
                continue;
            }
            var S = [
                f[h],
                null,
                null,
                f[l]
            ];
            f[h].y.cmp(f[l].y) === 0 ? (S[1] = f[h].add(f[l]), S[2] = f[h].toJ().mixedAdd(f[l].neg())) : f[h].y.cmp(f[l].y.redNeg()) === 0 ? (S[1] = f[h].toJ().mixedAdd(f[l]), S[2] = f[h].add(f[l].neg())) : (S[1] = f[h].toJ().mixedAdd(f[l]), S[2] = f[h].toJ().mixedAdd(f[l].neg()));
            var p = [
                -3,
                -1,
                -5,
                -7,
                0,
                7,
                5,
                1,
                3
            ], P = Rf(r[h], r[l]);
            for(s = Math.max(P[0].length, s), b[h] = new Array(s), b[l] = new Array(s), u = 0; u < s; u++){
                var D = P[0][u] | 0, he = P[1][u] | 0;
                b[h][u] = p[(D + 1) * 3 + (he + 1)], b[l][u] = 0, t[h] = S;
            }
        }
        var j = this.jpoint(null, null, null), V = this._wnafT4;
        for(n = s; n >= 0; n--){
            for(var ve = 0; n >= 0;){
                var _e = !0;
                for(u = 0; u < a; u++)V[u] = b[u][n] | 0, V[u] !== 0 && (_e = !1);
                if (!_e) break;
                ve++, n--;
            }
            if (n >= 0 && ve++, j = j.dblp(ve), n < 0) break;
            for(u = 0; u < a; u++){
                var Z = V[u];
                Z !== 0 && (Z > 0 ? o = t[u][Z - 1 >> 1] : Z < 0 && (o = t[u][-Z - 1 >> 1].neg()), o.type === "affine" ? j = j.mixedAdd(o) : j = j.add(o));
            }
        }
        for(n = 0; n < a; n++)t[n] = null;
        return c ? j : j.toP();
    };
    function R(d, e) {
        this.curve = d, this.type = e, this.precomputed = null;
    }
    L.BasePoint = R;
    R.prototype.eq = function() {
        throw new Error("Not implemented");
    };
    R.prototype.validate = function() {
        return this.curve.validate(this);
    };
    L.prototype.decodePoint = function(e, f) {
        e = $.toArray(e, f);
        var r = this.p.byteLength();
        if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 == 2 * r) {
            e[0] === 6 ? re(e[e.length - 1] % 2 == 0) : e[0] === 7 && re(e[e.length - 1] % 2 == 1);
            var a = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
            return a;
        } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
        throw new Error("Unknown point format");
    };
    R.prototype.encodeCompressed = function(e) {
        return this.encode(e, !0);
    };
    R.prototype._encode = function(e) {
        var f = this.curve.p.byteLength(), r = this.getX().toArray("be", f);
        return e ? [
            this.getY().isEven() ? 2 : 3
        ].concat(r) : [
            4
        ].concat(r, this.getY().toArray("be", f));
    };
    R.prototype.encode = function(e, f) {
        return $.encode(this._encode(f), e);
    };
    R.prototype.precompute = function(e) {
        if (this.precomputed) return this;
        var f = {
            doubles: null,
            naf: null,
            beta: null
        };
        return f.naf = this._getNAFPoints(8), f.doubles = this._getDoubles(4, e), f.beta = this._getBeta(), this.precomputed = f, this;
    };
    R.prototype._hasDoubles = function(e) {
        if (!this.precomputed) return !1;
        var f = this.precomputed.doubles;
        return f ? f.points.length >= Math.ceil((e.bitLength() + 1) / f.step) : !1;
    };
    R.prototype._getDoubles = function(e, f) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
        for(var r = [
            this
        ], a = this, c = 0; c < f; c += e){
            for(var i = 0; i < e; i++)a = a.dbl();
            r.push(a);
        }
        return {
            step: e,
            points: r
        };
    };
    R.prototype._getNAFPoints = function(e) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
        for(var f = [
            this
        ], r = (1 << e) - 1, a = r === 1 ? null : this.dbl(), c = 1; c < r; c++)f[c] = f[c - 1].add(a);
        return {
            wnd: e,
            points: f
        };
    };
    R.prototype._getBeta = function() {
        return null;
    };
    R.prototype.dblp = function(e) {
        for(var f = this, r = 0; r < e; r++)f = f.dbl();
        return f;
    };
});
var Ee = M((ed, Ne)=>{
    "use strict";
    var Nf = z(), m = export_default, pe = export_default, k = Q(), Ef = Nf.assert;
    function N(d) {
        k.call(this, "short", d), this.a = new m(d.a, 16).toRed(this.red), this.b = new m(d.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(d), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    pe(N, k);
    Ne.exports = N;
    N.prototype._getEndomorphism = function(e) {
        if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var f, r;
            if (e.beta) f = new m(e.beta, 16).toRed(this.red);
            else {
                var a = this._getEndoRoots(this.p);
                f = a[0].cmp(a[1]) < 0 ? a[0] : a[1], f = f.toRed(this.red);
            }
            if (e.lambda) r = new m(e.lambda, 16);
            else {
                var c = this._getEndoRoots(this.n);
                this.g.mul(c[0]).x.cmp(this.g.x.redMul(f)) === 0 ? r = c[0] : (r = c[1], Ef(this.g.mul(r).x.cmp(this.g.x.redMul(f)) === 0));
            }
            var i;
            return e.basis ? i = e.basis.map(function(t) {
                return {
                    a: new m(t.a, 16),
                    b: new m(t.b, 16)
                };
            }) : i = this._getEndoBasis(r), {
                beta: f,
                lambda: r,
                basis: i
            };
        }
    };
    N.prototype._getEndoRoots = function(e) {
        var f = e === this.p ? this.red : m.mont(e), r = new m(2).toRed(f).redInvm(), a = r.redNeg(), c = new m(3).toRed(f).redNeg().redSqrt().redMul(r), i = a.redAdd(c).fromRed(), t = a.redSub(c).fromRed();
        return [
            i,
            t
        ];
    };
    N.prototype._getEndoBasis = function(e) {
        for(var f = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, a = this.n.clone(), c = new m(1), i = new m(0), t = new m(0), b = new m(1), s, n, u, o, v, h, l, S = 0, p, P; r.cmpn(0) !== 0;){
            var D = a.div(r);
            p = a.sub(D.mul(r)), P = t.sub(D.mul(c));
            var he = b.sub(D.mul(i));
            if (!u && p.cmp(f) < 0) s = l.neg(), n = c, u = p.neg(), o = P;
            else if (u && ++S == 2) break;
            l = p, a = r, r = p, t = c, c = P, b = i, i = he;
        }
        v = p.neg(), h = P;
        var j = u.sqr().add(o.sqr()), V = v.sqr().add(h.sqr());
        return V.cmp(j) >= 0 && (v = s, h = n), u.negative && (u = u.neg(), o = o.neg()), v.negative && (v = v.neg(), h = h.neg()), [
            {
                a: u,
                b: o
            },
            {
                a: v,
                b: h
            }
        ];
    };
    N.prototype._endoSplit = function(e) {
        var f = this.endo.basis, r = f[0], a = f[1], c = a.b.mul(e).divRound(this.n), i = r.b.neg().mul(e).divRound(this.n), t = c.mul(r.a), b = i.mul(a.a), s = c.mul(r.b), n = i.mul(a.b), u = e.sub(t).sub(b), o = s.add(n).neg();
        return {
            k1: u,
            k2: o
        };
    };
    N.prototype.pointFromX = function(e, f) {
        e = new m(e, 16), e.red || (e = e.toRed(this.red));
        var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), a = r.redSqrt();
        if (a.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error("invalid point");
        var c = a.fromRed().isOdd();
        return (f && !c || !f && c) && (a = a.redNeg()), this.point(e, a);
    };
    N.prototype.validate = function(e) {
        if (e.inf) return !0;
        var f = e.x, r = e.y, a = this.a.redMul(f), c = f.redSqr().redMul(f).redIAdd(a).redIAdd(this.b);
        return r.redSqr().redISub(c).cmpn(0) === 0;
    };
    N.prototype._endoWnafMulAdd = function(e, f, r) {
        for(var a = this._endoWnafT1, c = this._endoWnafT2, i = 0; i < e.length; i++){
            var t = this._endoSplit(f[i]), b = e[i], s = b._getBeta();
            t.k1.negative && (t.k1.ineg(), b = b.neg(!0)), t.k2.negative && (t.k2.ineg(), s = s.neg(!0)), a[i * 2] = b, a[i * 2 + 1] = s, c[i * 2] = t.k1, c[i * 2 + 1] = t.k2;
        }
        for(var n = this._wnafMulAdd(1, a, c, i * 2, r), u = 0; u < i * 2; u++)a[u] = null, c[u] = null;
        return n;
    };
    function A(d, e, f, r) {
        k.BasePoint.call(this, d, "affine"), e === null && f === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new m(e, 16), this.y = new m(f, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
    }
    pe(A, k.BasePoint);
    N.prototype.point = function(e, f, r) {
        return new A(this, e, f, r);
    };
    N.prototype.pointFromJSON = function(e, f) {
        return A.fromJSON(this, e, f);
    };
    A.prototype._getBeta = function() {
        if (!!this.curve.endo) {
            var e = this.precomputed;
            if (e && e.beta) return e.beta;
            var f = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
            if (e) {
                var r = this.curve, a = function(c) {
                    return r.point(c.x.redMul(r.endo.beta), c.y);
                };
                e.beta = f, f.precomputed = {
                    beta: null,
                    naf: e.naf && {
                        wnd: e.naf.wnd,
                        points: e.naf.points.map(a)
                    },
                    doubles: e.doubles && {
                        step: e.doubles.step,
                        points: e.doubles.points.map(a)
                    }
                };
            }
            return f;
        }
    };
    A.prototype.toJSON = function() {
        return this.precomputed ? [
            this.x,
            this.y,
            this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }
        ] : [
            this.x,
            this.y
        ];
    };
    A.fromJSON = function(e, f, r) {
        typeof f == "string" && (f = JSON.parse(f));
        var a = e.point(f[0], f[1], r);
        if (!f[2]) return a;
        function c(t) {
            return e.point(t[0], t[1], r);
        }
        var i = f[2];
        return a.precomputed = {
            beta: null,
            doubles: i.doubles && {
                step: i.doubles.step,
                points: [
                    a
                ].concat(i.doubles.points.map(c))
            },
            naf: i.naf && {
                wnd: i.naf.wnd,
                points: [
                    a
                ].concat(i.naf.points.map(c))
            }
        }, a;
    };
    A.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    A.prototype.isInfinity = function() {
        return this.inf;
    };
    A.prototype.add = function(e) {
        if (this.inf) return e;
        if (e.inf) return this;
        if (this.eq(e)) return this.dbl();
        if (this.neg().eq(e)) return this.curve.point(null, null);
        if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
        var f = this.y.redSub(e.y);
        f.cmpn(0) !== 0 && (f = f.redMul(this.x.redSub(e.x).redInvm()));
        var r = f.redSqr().redISub(this.x).redISub(e.x), a = f.redMul(this.x.redSub(r)).redISub(this.y);
        return this.curve.point(r, a);
    };
    A.prototype.dbl = function() {
        if (this.inf) return this;
        var e = this.y.redAdd(this.y);
        if (e.cmpn(0) === 0) return this.curve.point(null, null);
        var f = this.curve.a, r = this.x.redSqr(), a = e.redInvm(), c = r.redAdd(r).redIAdd(r).redIAdd(f).redMul(a), i = c.redSqr().redISub(this.x.redAdd(this.x)), t = c.redMul(this.x.redSub(i)).redISub(this.y);
        return this.curve.point(i, t);
    };
    A.prototype.getX = function() {
        return this.x.fromRed();
    };
    A.prototype.getY = function() {
        return this.y.fromRed();
    };
    A.prototype.mul = function(e) {
        return e = new m(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([
            this
        ], [
            e
        ]) : this.curve._wnafMul(this, e);
    };
    A.prototype.mulAdd = function(e, f, r) {
        var a = [
            this,
            f
        ], c = [
            e,
            r
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(a, c) : this.curve._wnafMulAdd(1, a, c, 2);
    };
    A.prototype.jmulAdd = function(e, f, r) {
        var a = [
            this,
            f
        ], c = [
            e,
            r
        ];
        return this.curve.endo ? this.curve._endoWnafMulAdd(a, c, !0) : this.curve._wnafMulAdd(1, a, c, 2, !0);
    };
    A.prototype.eq = function(e) {
        return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    A.prototype.neg = function(e) {
        if (this.inf) return this;
        var f = this.curve.point(this.x, this.y.redNeg());
        if (e && this.precomputed) {
            var r = this.precomputed, a = function(c) {
                return c.neg();
            };
            f.precomputed = {
                naf: r.naf && {
                    wnd: r.naf.wnd,
                    points: r.naf.points.map(a)
                },
                doubles: r.doubles && {
                    step: r.doubles.step,
                    points: r.doubles.points.map(a)
                }
            };
        }
        return f;
    };
    A.prototype.toJ = function() {
        if (this.inf) return this.curve.jpoint(null, null, null);
        var e = this.curve.jpoint(this.x, this.y, this.curve.one);
        return e;
    };
    function w(d, e, f, r) {
        k.BasePoint.call(this, d, "jacobian"), e === null && f === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new m(0)) : (this.x = new m(e, 16), this.y = new m(f, 16), this.z = new m(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    pe(w, k.BasePoint);
    N.prototype.jpoint = function(e, f, r) {
        return new w(this, e, f, r);
    };
    w.prototype.toP = function() {
        if (this.isInfinity()) return this.curve.point(null, null);
        var e = this.z.redInvm(), f = e.redSqr(), r = this.x.redMul(f), a = this.y.redMul(f).redMul(e);
        return this.curve.point(r, a);
    };
    w.prototype.neg = function() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    w.prototype.add = function(e) {
        if (this.isInfinity()) return e;
        if (e.isInfinity()) return this;
        var f = e.z.redSqr(), r = this.z.redSqr(), a = this.x.redMul(f), c = e.x.redMul(r), i = this.y.redMul(f.redMul(e.z)), t = e.y.redMul(r.redMul(this.z)), b = a.redSub(c), s = i.redSub(t);
        if (b.cmpn(0) === 0) return s.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var n = b.redSqr(), u = n.redMul(b), o = a.redMul(n), v = s.redSqr().redIAdd(u).redISub(o).redISub(o), h = s.redMul(o.redISub(v)).redISub(i.redMul(u)), l = this.z.redMul(e.z).redMul(b);
        return this.curve.jpoint(v, h, l);
    };
    w.prototype.mixedAdd = function(e) {
        if (this.isInfinity()) return e.toJ();
        if (e.isInfinity()) return this;
        var f = this.z.redSqr(), r = this.x, a = e.x.redMul(f), c = this.y, i = e.y.redMul(f).redMul(this.z), t = r.redSub(a), b = c.redSub(i);
        if (t.cmpn(0) === 0) return b.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
        var s = t.redSqr(), n = s.redMul(t), u = r.redMul(s), o = b.redSqr().redIAdd(n).redISub(u).redISub(u), v = b.redMul(u.redISub(o)).redISub(c.redMul(n)), h = this.z.redMul(t);
        return this.curve.jpoint(o, v, h);
    };
    w.prototype.dblp = function(e) {
        if (e === 0) return this;
        if (this.isInfinity()) return this;
        if (!e) return this.dbl();
        var f;
        if (this.curve.zeroA || this.curve.threeA) {
            var r = this;
            for(f = 0; f < e; f++)r = r.dbl();
            return r;
        }
        var a = this.curve.a, c = this.curve.tinv, i = this.x, t = this.y, b = this.z, s = b.redSqr().redSqr(), n = t.redAdd(t);
        for(f = 0; f < e; f++){
            var u = i.redSqr(), o = n.redSqr(), v = o.redSqr(), h = u.redAdd(u).redIAdd(u).redIAdd(a.redMul(s)), l = i.redMul(o), S = h.redSqr().redISub(l.redAdd(l)), p = l.redISub(S), P = h.redMul(p);
            P = P.redIAdd(P).redISub(v);
            var D = n.redMul(b);
            f + 1 < e && (s = s.redMul(v)), i = S, b = D, n = P;
        }
        return this.curve.jpoint(i, n.redMul(c), b);
    };
    w.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    w.prototype._zeroDbl = function() {
        var e, f, r;
        if (this.zOne) {
            var a = this.x.redSqr(), c = this.y.redSqr(), i = c.redSqr(), t = this.x.redAdd(c).redSqr().redISub(a).redISub(i);
            t = t.redIAdd(t);
            var b = a.redAdd(a).redIAdd(a), s = b.redSqr().redISub(t).redISub(t), n = i.redIAdd(i);
            n = n.redIAdd(n), n = n.redIAdd(n), e = s, f = b.redMul(t.redISub(s)).redISub(n), r = this.y.redAdd(this.y);
        } else {
            var u = this.x.redSqr(), o = this.y.redSqr(), v = o.redSqr(), h = this.x.redAdd(o).redSqr().redISub(u).redISub(v);
            h = h.redIAdd(h);
            var l = u.redAdd(u).redIAdd(u), S = l.redSqr(), p = v.redIAdd(v);
            p = p.redIAdd(p), p = p.redIAdd(p), e = S.redISub(h).redISub(h), f = l.redMul(h.redISub(e)).redISub(p), r = this.y.redMul(this.z), r = r.redIAdd(r);
        }
        return this.curve.jpoint(e, f, r);
    };
    w.prototype._threeDbl = function() {
        var e, f, r;
        if (this.zOne) {
            var a = this.x.redSqr(), c = this.y.redSqr(), i = c.redSqr(), t = this.x.redAdd(c).redSqr().redISub(a).redISub(i);
            t = t.redIAdd(t);
            var b = a.redAdd(a).redIAdd(a).redIAdd(this.curve.a), s = b.redSqr().redISub(t).redISub(t);
            e = s;
            var n = i.redIAdd(i);
            n = n.redIAdd(n), n = n.redIAdd(n), f = b.redMul(t.redISub(s)).redISub(n), r = this.y.redAdd(this.y);
        } else {
            var u = this.z.redSqr(), o = this.y.redSqr(), v = this.x.redMul(o), h = this.x.redSub(u).redMul(this.x.redAdd(u));
            h = h.redAdd(h).redIAdd(h);
            var l = v.redIAdd(v);
            l = l.redIAdd(l);
            var S = l.redAdd(l);
            e = h.redSqr().redISub(S), r = this.y.redAdd(this.z).redSqr().redISub(o).redISub(u);
            var p = o.redSqr();
            p = p.redIAdd(p), p = p.redIAdd(p), p = p.redIAdd(p), f = h.redMul(l.redISub(e)).redISub(p);
        }
        return this.curve.jpoint(e, f, r);
    };
    w.prototype._dbl = function() {
        var e = this.curve.a, f = this.x, r = this.y, a = this.z, c = a.redSqr().redSqr(), i = f.redSqr(), t = r.redSqr(), b = i.redAdd(i).redIAdd(i).redIAdd(e.redMul(c)), s = f.redAdd(f);
        s = s.redIAdd(s);
        var n = s.redMul(t), u = b.redSqr().redISub(n.redAdd(n)), o = n.redISub(u), v = t.redSqr();
        v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
        var h = b.redMul(o).redISub(v), l = r.redAdd(r).redMul(a);
        return this.curve.jpoint(u, h, l);
    };
    w.prototype.trpl = function() {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var e = this.x.redSqr(), f = this.y.redSqr(), r = this.z.redSqr(), a = f.redSqr(), c = e.redAdd(e).redIAdd(e), i = c.redSqr(), t = this.x.redAdd(f).redSqr().redISub(e).redISub(a);
        t = t.redIAdd(t), t = t.redAdd(t).redIAdd(t), t = t.redISub(i);
        var b = t.redSqr(), s = a.redIAdd(a);
        s = s.redIAdd(s), s = s.redIAdd(s), s = s.redIAdd(s);
        var n = c.redIAdd(t).redSqr().redISub(i).redISub(b).redISub(s), u = f.redMul(n);
        u = u.redIAdd(u), u = u.redIAdd(u);
        var o = this.x.redMul(b).redISub(u);
        o = o.redIAdd(o), o = o.redIAdd(o);
        var v = this.y.redMul(n.redMul(s.redISub(n)).redISub(t.redMul(b)));
        v = v.redIAdd(v), v = v.redIAdd(v), v = v.redIAdd(v);
        var h = this.z.redAdd(t).redSqr().redISub(r).redISub(b);
        return this.curve.jpoint(o, v, h);
    };
    w.prototype.mul = function(e, f) {
        return e = new m(e, f), this.curve._wnafMul(this, e);
    };
    w.prototype.eq = function(e) {
        if (e.type === "affine") return this.eq(e.toJ());
        if (this === e) return !0;
        var f = this.z.redSqr(), r = e.z.redSqr();
        if (this.x.redMul(r).redISub(e.x.redMul(f)).cmpn(0) !== 0) return !1;
        var a = f.redMul(this.z), c = r.redMul(e.z);
        return this.y.redMul(c).redISub(e.y.redMul(a)).cmpn(0) === 0;
    };
    w.prototype.eqXToP = function(e) {
        var f = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(f);
        if (this.x.cmp(r) === 0) return !0;
        for(var a = e.clone(), c = this.curve.redN.redMul(f);;){
            if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0) return !1;
            if (r.redIAdd(c), this.x.cmp(r) === 0) return !0;
        }
    };
    w.prototype.inspect = function() {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    w.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    };
});
var Fe = M((fd, je)=>{
    "use strict";
    var W = export_default, Be = export_default, ae = Q(), Bf = z();
    function H(d) {
        ae.call(this, "mont", d), this.a = new W(d.a, 16).toRed(this.red), this.b = new W(d.b, 16).toRed(this.red), this.i4 = new W(4).toRed(this.red).redInvm(), this.two = new W(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    Be(H, ae);
    je.exports = H;
    H.prototype.validate = function(e) {
        var f = e.normalize().x, r = f.redSqr(), a = r.redMul(f).redAdd(r.redMul(this.a)).redAdd(f), c = a.redSqrt();
        return c.redSqr().cmp(a) === 0;
    };
    function x(d, e, f) {
        ae.BasePoint.call(this, d, "projective"), e === null && f === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new W(e, 16), this.z = new W(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    Be(x, ae.BasePoint);
    H.prototype.decodePoint = function(e, f) {
        return this.point(Bf.toArray(e, f), 1);
    };
    H.prototype.point = function(e, f) {
        return new x(this, e, f);
    };
    H.prototype.pointFromJSON = function(e) {
        return x.fromJSON(this, e);
    };
    x.prototype.precompute = function() {};
    x.prototype._encode = function() {
        return this.getX().toArray("be", this.curve.p.byteLength());
    };
    x.fromJSON = function(e, f) {
        return new x(e, f[0], f[1] || e.one);
    };
    x.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    x.prototype.isInfinity = function() {
        return this.z.cmpn(0) === 0;
    };
    x.prototype.dbl = function() {
        var e = this.x.redAdd(this.z), f = e.redSqr(), r = this.x.redSub(this.z), a = r.redSqr(), c = f.redSub(a), i = f.redMul(a), t = c.redMul(a.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(i, t);
    };
    x.prototype.add = function() {
        throw new Error("Not supported on Montgomery curve");
    };
    x.prototype.diffAdd = function(e, f) {
        var r = this.x.redAdd(this.z), a = this.x.redSub(this.z), c = e.x.redAdd(e.z), i = e.x.redSub(e.z), t = i.redMul(r), b = c.redMul(a), s = f.z.redMul(t.redAdd(b).redSqr()), n = f.x.redMul(t.redISub(b).redSqr());
        return this.curve.point(s, n);
    };
    x.prototype.mul = function(e) {
        for(var f = e.clone(), r = this, a = this.curve.point(null, null), c = this, i = []; f.cmpn(0) !== 0; f.iushrn(1))i.push(f.andln(1));
        for(var t = i.length - 1; t >= 0; t--)i[t] === 0 ? (r = r.diffAdd(a, c), a = a.dbl()) : (a = r.diffAdd(a, c), r = r.dbl());
        return a;
    };
    x.prototype.mulAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    };
    x.prototype.jumlAdd = function() {
        throw new Error("Not supported on Montgomery curve");
    };
    x.prototype.eq = function(e) {
        return this.getX().cmp(e.getX()) === 0;
    };
    x.prototype.normalize = function() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    x.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    };
});
var Ce = M((dd, Le)=>{
    "use strict";
    var jf = z(), O = export_default, Oe = export_default, te = Q(), Ff = jf.assert;
    function F(d) {
        this.twisted = (d.a | 0) != 1, this.mOneA = this.twisted && (d.a | 0) == -1, this.extended = this.mOneA, te.call(this, "edwards", d), this.a = new O(d.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new O(d.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new O(d.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Ff(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (d.c | 0) == 1;
    }
    Oe(F, te);
    Le.exports = F;
    F.prototype._mulA = function(e) {
        return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    F.prototype._mulC = function(e) {
        return this.oneC ? e : this.c.redMul(e);
    };
    F.prototype.jpoint = function(e, f, r, a) {
        return this.point(e, f, r, a);
    };
    F.prototype.pointFromX = function(e, f) {
        e = new O(e, 16), e.red || (e = e.toRed(this.red));
        var r = e.redSqr(), a = this.c2.redSub(this.a.redMul(r)), c = this.one.redSub(this.c2.redMul(this.d).redMul(r)), i = a.redMul(c.redInvm()), t = i.redSqrt();
        if (t.redSqr().redSub(i).cmp(this.zero) !== 0) throw new Error("invalid point");
        var b = t.fromRed().isOdd();
        return (f && !b || !f && b) && (t = t.redNeg()), this.point(e, t);
    };
    F.prototype.pointFromY = function(e, f) {
        e = new O(e, 16), e.red || (e = e.toRed(this.red));
        var r = e.redSqr(), a = r.redSub(this.c2), c = r.redMul(this.d).redMul(this.c2).redSub(this.a), i = a.redMul(c.redInvm());
        if (i.cmp(this.zero) === 0) {
            if (f) throw new Error("invalid point");
            return this.point(this.zero, e);
        }
        var t = i.redSqrt();
        if (t.redSqr().redSub(i).cmp(this.zero) !== 0) throw new Error("invalid point");
        return t.fromRed().isOdd() !== f && (t = t.redNeg()), this.point(t, e);
    };
    F.prototype.validate = function(e) {
        if (e.isInfinity()) return !0;
        e.normalize();
        var f = e.x.redSqr(), r = e.y.redSqr(), a = f.redMul(this.a).redAdd(r), c = this.c2.redMul(this.one.redAdd(this.d.redMul(f).redMul(r)));
        return a.cmp(c) === 0;
    };
    function y(d, e, f, r, a) {
        te.BasePoint.call(this, d, "projective"), e === null && f === null && r === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new O(e, 16), this.y = new O(f, 16), this.z = r ? new O(r, 16) : this.curve.one, this.t = a && new O(a, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    Oe(y, te.BasePoint);
    F.prototype.pointFromJSON = function(e) {
        return y.fromJSON(this, e);
    };
    F.prototype.point = function(e, f, r, a) {
        return new y(this, e, f, r, a);
    };
    y.fromJSON = function(e, f) {
        return new y(e, f[0], f[1], f[2]);
    };
    y.prototype.inspect = function() {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    y.prototype.isInfinity = function() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    y.prototype._extDbl = function() {
        var e = this.x.redSqr(), f = this.y.redSqr(), r = this.z.redSqr();
        r = r.redIAdd(r);
        var a = this.curve._mulA(e), c = this.x.redAdd(this.y).redSqr().redISub(e).redISub(f), i = a.redAdd(f), t = i.redSub(r), b = a.redSub(f), s = c.redMul(t), n = i.redMul(b), u = c.redMul(b), o = t.redMul(i);
        return this.curve.point(s, n, o, u);
    };
    y.prototype._projDbl = function() {
        var e = this.x.redAdd(this.y).redSqr(), f = this.x.redSqr(), r = this.y.redSqr(), a, c, i, t, b, s;
        if (this.curve.twisted) {
            t = this.curve._mulA(f);
            var n = t.redAdd(r);
            this.zOne ? (a = e.redSub(f).redSub(r).redMul(n.redSub(this.curve.two)), c = n.redMul(t.redSub(r)), i = n.redSqr().redSub(n).redSub(n)) : (b = this.z.redSqr(), s = n.redSub(b).redISub(b), a = e.redSub(f).redISub(r).redMul(s), c = n.redMul(t.redSub(r)), i = n.redMul(s));
        } else t = f.redAdd(r), b = this.curve._mulC(this.z).redSqr(), s = t.redSub(b).redSub(b), a = this.curve._mulC(e.redISub(t)).redMul(s), c = this.curve._mulC(t).redMul(f.redISub(r)), i = t.redMul(s);
        return this.curve.point(a, c, i);
    };
    y.prototype.dbl = function() {
        return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    y.prototype._extAdd = function(e) {
        var f = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), r = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), a = this.t.redMul(this.curve.dd).redMul(e.t), c = this.z.redMul(e.z.redAdd(e.z)), i = r.redSub(f), t = c.redSub(a), b = c.redAdd(a), s = r.redAdd(f), n = i.redMul(t), u = b.redMul(s), o = i.redMul(s), v = t.redMul(b);
        return this.curve.point(n, u, v, o);
    };
    y.prototype._projAdd = function(e) {
        var f = this.z.redMul(e.z), r = f.redSqr(), a = this.x.redMul(e.x), c = this.y.redMul(e.y), i = this.curve.d.redMul(a).redMul(c), t = r.redSub(i), b = r.redAdd(i), s = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(a).redISub(c), n = f.redMul(t).redMul(s), u, o;
        return this.curve.twisted ? (u = f.redMul(b).redMul(c.redSub(this.curve._mulA(a))), o = t.redMul(b)) : (u = f.redMul(b).redMul(c.redSub(a)), o = this.curve._mulC(t).redMul(b)), this.curve.point(n, u, o);
    };
    y.prototype.add = function(e) {
        return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    y.prototype.mul = function(e) {
        return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    y.prototype.mulAdd = function(e, f, r) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            e,
            r
        ], 2, !1);
    };
    y.prototype.jmulAdd = function(e, f, r) {
        return this.curve._wnafMulAdd(1, [
            this,
            f
        ], [
            e,
            r
        ], 2, !0);
    };
    y.prototype.normalize = function() {
        if (this.zOne) return this;
        var e = this.z.redInvm();
        return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
    };
    y.prototype.neg = function() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    y.prototype.getX = function() {
        return this.normalize(), this.x.fromRed();
    };
    y.prototype.getY = function() {
        return this.normalize(), this.y.fromRed();
    };
    y.prototype.eq = function(e) {
        return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    y.prototype.eqXToP = function(e) {
        var f = e.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(f) === 0) return !0;
        for(var r = e.clone(), a = this.curve.redN.redMul(this.z);;){
            if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
            if (f.redIAdd(a), this.x.cmp(f) === 0) return !0;
        }
    };
    y.prototype.toP = y.prototype.normalize;
    y.prototype.mixedAdd = y.prototype.add;
});
var ye = M((Je)=>{
    "use strict";
    var ce = Je;
    ce.base = Q();
    ce.short = Ee();
    ce.mont = Fe();
    ce.edwards = Ce();
});
var Xe = M((ad, De)=>{
    De.exports = {
        doubles: {
            step: 4,
            points: [
                [
                    "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                    "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
                ],
                [
                    "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                    "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
                ],
                [
                    "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                    "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
                ],
                [
                    "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                    "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
                ],
                [
                    "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                    "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
                ],
                [
                    "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                    "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
                ],
                [
                    "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                    "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
                ],
                [
                    "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                    "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
                ],
                [
                    "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                    "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
                ],
                [
                    "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                    "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
                ],
                [
                    "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                    "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
                ],
                [
                    "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                    "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
                ],
                [
                    "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                    "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
                ],
                [
                    "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                    "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
                ],
                [
                    "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                    "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
                ],
                [
                    "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                    "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
                ],
                [
                    "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                    "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
                ],
                [
                    "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                    "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
                ],
                [
                    "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                    "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
                ],
                [
                    "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                    "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
                ],
                [
                    "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                    "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
                ],
                [
                    "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                    "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
                ],
                [
                    "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                    "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
                ],
                [
                    "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                    "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
                ],
                [
                    "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                    "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
                ],
                [
                    "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                    "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
                ],
                [
                    "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                    "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
                ],
                [
                    "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                    "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
                ],
                [
                    "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                    "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
                ],
                [
                    "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                    "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
                ],
                [
                    "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                    "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
                ],
                [
                    "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                    "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
                ],
                [
                    "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                    "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
                ],
                [
                    "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                    "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
                ],
                [
                    "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                    "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
                ],
                [
                    "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                    "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
                ],
                [
                    "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                    "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
                ],
                [
                    "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                    "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
                ],
                [
                    "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                    "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
                ],
                [
                    "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                    "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
                ],
                [
                    "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                    "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
                ],
                [
                    "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                    "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
                ],
                [
                    "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                    "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
                ],
                [
                    "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                    "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
                ],
                [
                    "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                    "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
                ],
                [
                    "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                    "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
                ],
                [
                    "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                    "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
                ],
                [
                    "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                    "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
                ],
                [
                    "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                    "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
                ],
                [
                    "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                    "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
                ],
                [
                    "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                    "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
                ],
                [
                    "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                    "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
                ],
                [
                    "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                    "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
                ],
                [
                    "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                    "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
                ],
                [
                    "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                    "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
                ],
                [
                    "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                    "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
                ],
                [
                    "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                    "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
                ],
                [
                    "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                    "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
                ],
                [
                    "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                    "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
                ],
                [
                    "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                    "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
                ],
                [
                    "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                    "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
                ],
                [
                    "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                    "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
                ],
                [
                    "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                    "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
                ],
                [
                    "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                    "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
                ],
                [
                    "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                    "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
                ]
            ]
        },
        naf: {
            wnd: 7,
            points: [
                [
                    "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                    "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
                ],
                [
                    "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                    "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
                ],
                [
                    "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                    "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
                ],
                [
                    "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                    "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
                ],
                [
                    "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                    "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
                ],
                [
                    "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                    "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
                ],
                [
                    "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                    "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
                ],
                [
                    "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                    "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
                ],
                [
                    "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                    "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
                ],
                [
                    "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                    "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
                ],
                [
                    "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                    "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
                ],
                [
                    "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                    "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
                ],
                [
                    "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                    "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
                ],
                [
                    "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                    "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
                ],
                [
                    "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                    "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
                ],
                [
                    "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                    "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
                ],
                [
                    "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                    "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
                ],
                [
                    "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                    "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
                ],
                [
                    "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                    "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
                ],
                [
                    "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                    "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
                ],
                [
                    "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                    "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
                ],
                [
                    "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                    "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
                ],
                [
                    "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                    "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
                ],
                [
                    "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                    "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
                ],
                [
                    "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                    "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
                ],
                [
                    "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                    "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
                ],
                [
                    "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                    "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
                ],
                [
                    "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                    "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
                ],
                [
                    "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                    "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
                ],
                [
                    "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                    "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
                ],
                [
                    "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                    "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
                ],
                [
                    "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                    "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
                ],
                [
                    "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                    "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
                ],
                [
                    "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                    "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
                ],
                [
                    "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                    "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
                ],
                [
                    "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                    "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
                ],
                [
                    "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                    "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
                ],
                [
                    "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                    "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
                ],
                [
                    "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                    "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
                ],
                [
                    "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                    "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
                ],
                [
                    "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                    "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
                ],
                [
                    "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                    "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
                ],
                [
                    "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                    "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
                ],
                [
                    "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                    "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
                ],
                [
                    "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                    "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
                ],
                [
                    "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                    "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
                ],
                [
                    "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                    "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
                ],
                [
                    "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                    "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
                ],
                [
                    "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                    "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
                ],
                [
                    "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                    "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
                ],
                [
                    "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                    "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
                ],
                [
                    "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                    "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
                ],
                [
                    "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                    "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
                ],
                [
                    "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                    "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
                ],
                [
                    "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                    "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
                ],
                [
                    "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                    "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
                ],
                [
                    "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                    "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
                ],
                [
                    "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                    "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
                ],
                [
                    "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                    "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
                ],
                [
                    "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                    "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
                ],
                [
                    "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                    "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
                ],
                [
                    "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                    "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
                ],
                [
                    "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                    "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
                ],
                [
                    "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                    "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
                ],
                [
                    "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                    "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
                ],
                [
                    "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                    "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
                ],
                [
                    "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                    "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
                ],
                [
                    "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                    "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
                ],
                [
                    "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                    "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
                ],
                [
                    "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                    "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
                ],
                [
                    "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                    "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
                ],
                [
                    "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                    "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
                ],
                [
                    "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                    "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
                ],
                [
                    "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                    "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
                ],
                [
                    "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                    "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
                ],
                [
                    "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                    "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
                ],
                [
                    "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                    "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
                ],
                [
                    "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                    "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
                ],
                [
                    "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                    "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
                ],
                [
                    "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                    "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
                ],
                [
                    "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                    "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
                ],
                [
                    "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                    "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
                ],
                [
                    "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                    "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
                ],
                [
                    "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                    "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
                ],
                [
                    "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                    "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
                ],
                [
                    "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                    "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
                ],
                [
                    "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                    "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
                ],
                [
                    "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                    "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
                ],
                [
                    "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                    "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
                ],
                [
                    "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                    "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
                ],
                [
                    "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                    "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
                ],
                [
                    "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                    "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
                ],
                [
                    "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                    "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
                ],
                [
                    "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                    "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
                ],
                [
                    "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                    "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
                ],
                [
                    "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                    "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
                ],
                [
                    "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                    "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
                ],
                [
                    "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                    "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
                ],
                [
                    "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                    "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
                ],
                [
                    "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                    "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
                ],
                [
                    "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                    "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
                ],
                [
                    "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                    "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
                ],
                [
                    "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                    "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
                ],
                [
                    "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                    "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
                ],
                [
                    "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                    "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
                ],
                [
                    "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                    "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
                ],
                [
                    "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                    "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
                ],
                [
                    "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                    "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
                ],
                [
                    "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                    "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
                ],
                [
                    "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                    "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
                ],
                [
                    "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                    "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
                ],
                [
                    "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                    "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
                ],
                [
                    "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                    "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
                ],
                [
                    "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                    "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
                ],
                [
                    "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                    "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
                ],
                [
                    "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                    "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
                ],
                [
                    "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                    "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
                ],
                [
                    "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                    "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
                ],
                [
                    "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                    "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
                ],
                [
                    "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                    "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
                ],
                [
                    "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                    "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
                ],
                [
                    "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                    "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
                ],
                [
                    "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                    "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
                ],
                [
                    "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                    "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
                ],
                [
                    "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                    "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
                ],
                [
                    "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                    "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
                ],
                [
                    "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                    "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
                ]
            ]
        }
    };
});
var ie = M((Ke)=>{
    "use strict";
    var me = Ke, C = export_default, Se = ye(), Of = z(), Te = Of.assert;
    function Ye(d) {
        d.type === "short" ? this.curve = new Se.short(d) : d.type === "edwards" ? this.curve = new Se.edwards(d) : this.curve = new Se.mont(d), this.g = this.curve.g, this.n = this.curve.n, this.hash = d.hash, Te(this.g.validate(), "Invalid curve"), Te(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    me.PresetCurve = Ye;
    function J(d, e) {
        Object.defineProperty(me, d, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                var f = new Ye(e);
                return Object.defineProperty(me, d, {
                    configurable: !0,
                    enumerable: !0,
                    value: f
                }), f;
            }
        });
    }
    J("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: C.sha256,
        gRed: !1,
        g: [
            "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
            "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
    });
    J("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: C.sha256,
        gRed: !1,
        g: [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
            "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
    });
    J("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: C.sha256,
        gRed: !1,
        g: [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
    });
    J("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: C.sha384,
        gRed: !1,
        g: [
            "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
            "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
    });
    J("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: C.sha512,
        gRed: !1,
        g: [
            "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
            "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
    });
    J("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: C.sha256,
        gRed: !1,
        g: [
            "9"
        ]
    });
    J("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: C.sha256,
        gRed: !1,
        g: [
            "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
            "6666666666666666666666666666666666666666666666666666666666666658"
        ]
    });
    var ge;
    try {
        ge = Xe();
    } catch (d) {
        ge = void 0;
    }
    J("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: C.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
            {
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }
        ],
        gRed: !1,
        g: [
            "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
            ge
        ]
    });
});
var We = M((cd, ke)=>{
    "use strict";
    var Lf = export_default, Cf = z(), Ae = Cf.assert;
    function q(d, e) {
        this.ec = d, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ke.exports = q;
    q.fromPublic = function(e, f, r) {
        return f instanceof q ? f : new q(e, {
            pub: f,
            pubEnc: r
        });
    };
    q.fromPrivate = function(e, f, r) {
        return f instanceof q ? f : new q(e, {
            priv: f,
            privEnc: r
        });
    };
    q.prototype.validate = function() {
        var e = this.getPublic();
        return e.isInfinity() ? {
            result: !1,
            reason: "Invalid public key"
        } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
            result: !0,
            reason: null
        } : {
            result: !1,
            reason: "Public key * N != O"
        } : {
            result: !1,
            reason: "Public key is not a point"
        };
    };
    q.prototype.getPublic = function(e, f) {
        return typeof e == "string" && (f = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), f ? this.pub.encode(f, e) : this.pub;
    };
    q.prototype.getPrivate = function(e) {
        return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    q.prototype._importPrivate = function(e, f) {
        this.priv = new Lf(e, f || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    q.prototype._importPublic = function(e, f) {
        if (e.x || e.y) {
            this.ec.curve.type === "mont" ? Ae(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Ae(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
            return;
        }
        this.pub = this.ec.curve.decodePoint(e, f);
    };
    q.prototype.derive = function(e) {
        return e.validate() || Ae(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    q.prototype.sign = function(e, f, r) {
        return this.ec.sign(e, this, f, r);
    };
    q.prototype.verify = function(e, f) {
        return this.ec.verify(e, f, this);
    };
    q.prototype.inspect = function() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
});
var Ge = M((id, Ue)=>{
    "use strict";
    var be = export_default, xe = z(), Jf = xe.assert;
    function ne(d, e) {
        if (d instanceof ne) return d;
        this._importDER(d, e) || (Jf(d.r && d.s, "Signature without r or s"), this.r = new be(d.r, 16), this.s = new be(d.s, 16), d.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = d.recoveryParam);
    }
    Ue.exports = ne;
    function Df() {
        this.place = 0;
    }
    function Ie(d, e) {
        var f = d[e.place++];
        if (!(f & 128)) return f;
        var r = f & 15;
        if (r === 0 || r > 4) return !1;
        for(var a = 0, c = 0, i = e.place; c < r; c++, i++)a <<= 8, a |= d[i], a >>>= 0;
        return a <= 127 ? !1 : (e.place = i, a);
    }
    function He(d) {
        for(var e = 0, f = d.length - 1; !d[e] && !(d[e + 1] & 128) && e < f;)e++;
        return e === 0 ? d : d.slice(e);
    }
    ne.prototype._importDER = function(e, f) {
        e = xe.toArray(e, f);
        var r = new Df;
        if (e[r.place++] !== 48) return !1;
        var a = Ie(e, r);
        if (a === !1 || a + r.place !== e.length || e[r.place++] !== 2) return !1;
        var c = Ie(e, r);
        if (c === !1) return !1;
        var i = e.slice(r.place, c + r.place);
        if (r.place += c, e[r.place++] !== 2) return !1;
        var t = Ie(e, r);
        if (t === !1 || e.length !== t + r.place) return !1;
        var b = e.slice(r.place, t + r.place);
        if (i[0] === 0) if (i[1] & 128) i = i.slice(1);
        else return !1;
        if (b[0] === 0) if (b[1] & 128) b = b.slice(1);
        else return !1;
        return this.r = new be(i), this.s = new be(b), this.recoveryParam = null, !0;
    };
    function we(d, e) {
        if (e < 128) {
            d.push(e);
            return;
        }
        var f = 1 + (Math.log(e) / Math.LN2 >>> 3);
        for(d.push(f | 128); --f;)d.push(e >>> (f << 3) & 255);
        d.push(e);
    }
    ne.prototype.toDER = function(e) {
        var f = this.r.toArray(), r = this.s.toArray();
        for(f[0] & 128 && (f = [
            0
        ].concat(f)), r[0] & 128 && (r = [
            0
        ].concat(r)), f = He(f), r = He(r); !r[0] && !(r[1] & 128);)r = r.slice(1);
        var a = [
            2
        ];
        we(a, f.length), a = a.concat(f), a.push(2), we(a, r.length);
        var c = a.concat(r), i = [
            48
        ];
        return we(i, c.length), i = i.concat(c), xe.encode(i, e);
    };
});
var a = Object.defineProperty;
var y = Object.getOwnPropertyDescriptor;
var l = Object.getOwnPropertyNames;
var c = Object.getPrototypeOf, m = Object.prototype.hasOwnProperty;
var _ = (r)=>a(r, "__esModule", {
        value: !0
    });
var w = (r, t)=>()=>(t || r((t = {
            exports: {}
        }).exports, t), t.exports);
var h = (r, t, e)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let n of l(t))!m.call(r, n) && n !== "default" && a(r, n, {
        get: ()=>t[n],
        enumerable: !(e = y(t, n)) || e.enumerable
    });
    return r;
}, i = (r)=>h(_(a(r != null ? u(c(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var s = Object.defineProperty;
var _ = Object.getOwnPropertyDescriptor;
var C = Object.getOwnPropertyNames;
var u = Object.getPrototypeOf, H = Object.prototype.hasOwnProperty;
var E = (r)=>s(r, "__esModule", {
        value: !0
    });
var S = (r, i)=>()=>(i || r((i = {
            exports: {}
        }).exports, i), i.exports);
var d = (r, i, D)=>{
    if (i && typeof i == "object" || typeof i == "function") for (let c of C(i))!H.call(r, c) && c !== "default" && s(r, c, {
        get: ()=>i[c],
        enumerable: !(D = _(i, c)) || D.enumerable
    });
    return r;
}, h = (r)=>d(E(s(r != null ? m(u(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var l = Object.defineProperty;
var C = Object.getOwnPropertyDescriptor;
var O = Object.getOwnPropertyNames;
var V = Object.getPrototypeOf, L = Object.prototype.hasOwnProperty;
var M = (e)=>l(e, "__esModule", {
        value: !0
    });
var s = (e, f)=>()=>(f || e((f = {
            exports: {}
        }).exports, f), f.exports);
var F = (e, f, a)=>{
    if (f && typeof f == "object" || typeof f == "function") for (let c of O(f))!L.call(e, c) && c !== "default" && l(e, c, {
        get: ()=>f[c],
        enumerable: !(a = C(f, c)) || a.enumerable
    });
    return e;
}, g = (e)=>F(M(l(e != null ? G(V(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var h = Object.defineProperty;
var q = Object.getOwnPropertyDescriptor;
var y = Object.getOwnPropertyNames;
var M = Object.getPrototypeOf, L = Object.prototype.hasOwnProperty;
var S = (e)=>h(e, "__esModule", {
        value: !0
    });
var D = (e, r)=>()=>(r || e((r = {
            exports: {}
        }).exports, r), r.exports);
var P = (e, r, n)=>{
    if (r && typeof r == "object" || typeof r == "function") for (let t of y(r))!L.call(e, t) && t !== "default" && h(e, t, {
        get: ()=>r[t],
        enumerable: !(n = q(r, t)) || n.enumerable
    });
    return e;
}, j = (e)=>P(S(h(e != null ? _(M(e)) : {}, "default", e && e.__esModule && "default" in e ? {
        get: ()=>e.default,
        enumerable: !0
    } : {
        value: e,
        enumerable: !0
    })), e);
var p = w((b, f)=>{
    var s;
    f.exports = function(t) {
        return s || (s = new o(null)), s.generate(t);
    };
    function o(r) {
        this.rand = r;
    }
    f.exports.Rand = o;
    o.prototype.generate = function(t) {
        return this._rand(t);
    };
    o.prototype._rand = function(t) {
        if (this.rand.getBytes) return this.rand.getBytes(t);
        for(var e = new Uint8Array(t), n = 0; n < e.length; n++)e[n] = this.rand.getByte();
        return e;
    };
    if (typeof self == "object") self.crypto && self.crypto.getRandomValues ? o.prototype._rand = function(t) {
        var e = new Uint8Array(t);
        return self.crypto.getRandomValues(e), e;
    } : self.msCrypto && self.msCrypto.getRandomValues ? o.prototype._rand = function(t) {
        var e = new Uint8Array(t);
        return self.msCrypto.getRandomValues(e), e;
    } : typeof window == "object" && (o.prototype._rand = function() {
        throw new Error("Not implemented yet");
    });
    else try {
        if (d = export_default, typeof d.randomBytes != "function") throw new Error("Not supported");
        o.prototype._rand = function(t) {
            return d.randomBytes(t);
        };
    } catch (r) {}
    var d;
});
var R = i(p()), v = i(p()), { Rand: x  } = R;
var export_default = v.default;
var R = D((C, g)=>{
    var v = export_default, z = export_default;
    function u(e) {
        this.rand = e || new z.Rand;
    }
    g.exports = u;
    u.create = function(r) {
        return new u(r);
    };
    u.prototype._randbelow = function(r) {
        var n = r.bitLength(), t = Math.ceil(n / 8);
        do var d = new v(this.rand.generate(t));
        while (d.cmp(r) >= 0)
        return d;
    };
    u.prototype._randrange = function(r, n) {
        var t = n.sub(r);
        return r.add(this._randbelow(t));
    };
    u.prototype.test = function(r, n, t) {
        var d = r.bitLength(), c = v.mont(r), p = new v(1).toRed(c);
        n || (n = Math.max(1, d / 48 | 0));
        for(var i = r.subn(1), f = 0; !i.testn(f); f++);
        for(var b = r.shrn(f), m = i.toRed(c), l = !0; n > 0; n--){
            var a = this._randrange(new v(2), i);
            t && t(a);
            var o = a.toRed(c).redPow(b);
            if (!(o.cmp(p) === 0 || o.cmp(m) === 0)) {
                for(var s = 1; s < f; s++){
                    if (o = o.redSqr(), o.cmp(p) === 0) return !1;
                    if (o.cmp(m) === 0) break;
                }
                if (s === f) return !1;
            }
        }
        return l;
    };
    u.prototype.getDivisor = function(r, n) {
        var t = r.bitLength(), d = v.mont(r), c = new v(1).toRed(d);
        n || (n = Math.max(1, t / 48 | 0));
        for(var p = r.subn(1), i = 0; !p.testn(i); i++);
        for(var f = r.shrn(i), b = p.toRed(d); n > 0; n--){
            var m = this._randrange(new v(2), p), l = r.gcd(m);
            if (l.cmpn(1) !== 0) return l;
            var a = m.toRed(d).redPow(f);
            if (!(a.cmp(c) === 0 || a.cmp(b) === 0)) {
                for(var o = 1; o < i; o++){
                    if (a = a.redSqr(), a.cmp(c) === 0) return a.fromRed().subn(1).gcd(r);
                    if (a.cmp(b) === 0) break;
                }
                if (o === i) return a = a.redSqr(), a.fromRed().subn(1).gcd(r);
            }
        }
        return !1;
    };
});
var A = j(R());
var export_default = A.default;
var y = s((he, R)=>{
    var I = export_default;
    R.exports = _;
    _.simpleSieve = h;
    _.fermatTest = w;
    var b = export_default, W = new b(24), U = export_default, P = new U, A = new b(1), p = new b(2), Y = new b(5), oe = new b(16), le = new b(8), X = new b(10), j = new b(3), pe = new b(7), k = new b(11), H = new b(4), ve = new b(12), v = null;
    function z() {
        if (v !== null) return v;
        var e = 1048576, f = [];
        f[0] = 2;
        for(var a = 1, c = 3; c < e; c += 2){
            for(var d = Math.ceil(Math.sqrt(c)), i = 0; i < a && f[i] <= d && c % f[i] != 0; i++);
            a !== i && f[i] <= d || (f[a++] = c);
        }
        return v = f, f;
    }
    function h(e) {
        for(var f = z(), a = 0; a < f.length; a++)if (e.modn(f[a]) === 0) return e.cmpn(f[a]) === 0;
        return !0;
    }
    function w(e) {
        var f = b.mont(e);
        return p.toRed(f).redPow(e.subn(1)).fromRed().cmpn(1) === 0;
    }
    function _(e, f) {
        if (e < 16) return f === 2 || f === 5 ? new b([
            140,
            123
        ]) : new b([
            140,
            39
        ]);
        f = new b(f);
        for(var a, c;;){
            for(a = new b(I(Math.ceil(e / 8))); a.bitLength() > e;)a.ishrn(1);
            if (a.isEven() && a.iadd(A), a.testn(1) || a.iadd(p), f.cmp(p)) {
                if (!f.cmp(Y)) for(; a.mod(X).cmp(j);)a.iadd(H);
            } else for(; a.mod(W).cmp(k);)a.iadd(H);
            if (c = a.shrn(1), h(c) && h(a) && w(c) && w(a) && P.test(c) && P.test(a)) return a;
        }
    }
});
var D = s((we, J)=>{
    J.exports = {
        modp1: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
        },
        modp2: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
        },
        modp5: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
        },
        modp14: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
        },
        modp15: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
        },
        modp16: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
        },
        modp17: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
        },
        modp18: {
            gen: "02",
            prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
        }
    };
});
var S = s((_e, N)=>{
    var r = export_default, Q = export_default, T = new Q, Z = new r(24), $ = new r(11), ee = new r(10), fe = new r(3), ae = new r(7), x = y(), ce = export_default;
    N.exports = t;
    function de(e, f) {
        return f = f || "utf8", ut.isBuffer(e) || (e = new ut(e, f)), this._pub = new r(e), this;
    }
    function be(e, f) {
        return f = f || "utf8", ut.isBuffer(e) || (e = new ut(e, f)), this._priv = new r(e), this;
    }
    var m = {};
    function re(e, f) {
        var a = f.toString("hex"), c = [
            a,
            e.toString(16)
        ].join("_");
        if (c in m) return m[c];
        var d = 0;
        if (e.isEven() || !x.simpleSieve || !x.fermatTest(e) || !T.test(e)) return d += 1, a === "02" || a === "05" ? d += 8 : d += 4, m[c] = d, d;
        T.test(e.shrn(1)) || (d += 2);
        var i;
        switch(a){
            case "02":
                e.mod(Z).cmp($) && (d += 8);
                break;
            case "05":
                i = e.mod(ee), i.cmp(fe) && i.cmp(ae) && (d += 8);
                break;
            default:
                d += 4;
        }
        return m[c] = d, d;
    }
    function t(e, f, a) {
        this.setGenerator(f), this.__prime = new r(e), this._prime = r.mont(this.__prime), this._primeLen = e.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, a ? (this.setPublicKey = de, this.setPrivateKey = be) : this._primeCode = 8;
    }
    Object.defineProperty(t.prototype, "verifyError", {
        enumerable: !0,
        get: function() {
            return typeof this._primeCode != "number" && (this._primeCode = re(this.__prime, this.__gen)), this._primeCode;
        }
    });
    t.prototype.generateKeys = function() {
        return this._priv || (this._priv = new r(ce(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    t.prototype.computeSecret = function(e) {
        e = new r(e), e = e.toRed(this._prime);
        var f = e.redPow(this._priv).fromRed(), a = new ut(f.toArray()), c = this.getPrime();
        if (a.length < c.length) {
            var d = new ut(c.length - a.length);
            d.fill(0), a = ut.concat([
                d,
                a
            ]);
        }
        return a;
    };
    t.prototype.getPublicKey = function(f) {
        return o(this._pub, f);
    };
    t.prototype.getPrivateKey = function(f) {
        return o(this._priv, f);
    };
    t.prototype.getPrime = function(e) {
        return o(this.__prime, e);
    };
    t.prototype.getGenerator = function(e) {
        return o(this._gen, e);
    };
    t.prototype.setGenerator = function(e, f) {
        return f = f || "utf8", ut.isBuffer(e) || (e = new ut(e, f)), this.__gen = e, this._gen = new r(e), this;
    };
    function o(e, f) {
        var a = new ut(e.toArray());
        return f ? a.toString(f) : a;
    }
});
var B = s((u)=>{
    var ie = y(), q = D(), E = S();
    function te(e) {
        var f = new ut(q[e].prime, "hex"), a = new ut(q[e].gen, "hex");
        return new E(f, a);
    }
    var ne = {
        binary: !0,
        hex: !0,
        base64: !0
    };
    function K(e, f, a, c) {
        return ut.isBuffer(f) || ne[f] === void 0 ? K(e, "binary", f, a) : (f = f || "binary", c = c || "binary", a = a || new ut([
            2
        ]), ut.isBuffer(a) || (a = new ut(a, c)), typeof e == "number" ? new E(ie(e, a), a, !0) : (ut.isBuffer(e) || (e = new ut(e, f)), new E(e, a, !0)));
    }
    u.DiffieHellmanGroup = u.createDiffieHellmanGroup = u.getDiffieHellman = te;
    u.createDiffieHellman = u.DiffieHellman = K;
});
var ue = g(B()), se = g(B()), { DiffieHellmanGroup: Ee , createDiffieHellmanGroup: Be , getDiffieHellman: ge , createDiffieHellman: Pe , DiffieHellman: He  } = ue;
var export_default = se.default;
var R = Object.defineProperty;
var O = Object.getOwnPropertyDescriptor;
var z = Object.getOwnPropertyNames;
var G = Object.getPrototypeOf, J = Object.prototype.hasOwnProperty;
var Q = (r)=>R(r, "__esModule", {
        value: !0
    });
var l = (r, e)=>()=>(e || r((e = {
            exports: {}
        }).exports, e), e.exports);
var X = (r, e, t)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let a of z(e))!J.call(r, a) && a !== "default" && R(r, a, {
        get: ()=>e[a],
        enumerable: !(t = O(e, a)) || t.enumerable
    });
    return r;
}, q = (r)=>X(Q(R(r != null ? F(G(r)) : {}, "default", r && r.__esModule && "default" in r ? {
        get: ()=>r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
var E = l((wr, Y)=>{
    Y.exports = {
        "1.3.132.0.10": "secp256k1",
        "1.3.132.0.33": "p224",
        "1.2.840.10045.3.1.1": "p192",
        "1.2.840.10045.3.1.7": "p256",
        "1.3.132.0.34": "p384",
        "1.3.132.0.35": "p521"
    };
});
var Qe = M((bd, $e)=>{
    "use strict";
    var T = export_default, Ve = export_default, Xf = z(), Me = ie(), Tf = export_default, Ze = Xf.assert, qe = We(), se = Ge();
    function E(d) {
        if (!(this instanceof E)) return new E(d);
        typeof d == "string" && (Ze(Object.prototype.hasOwnProperty.call(Me, d), "Unknown curve " + d), d = Me[d]), d instanceof Me.PresetCurve && (d = {
            curve: d
        }), this.curve = d.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = d.curve.g, this.g.precompute(d.curve.n.bitLength() + 1), this.hash = d.hash || d.curve.hash;
    }
    $e.exports = E;
    E.prototype.keyPair = function(e) {
        return new qe(this, e);
    };
    E.prototype.keyFromPrivate = function(e, f) {
        return qe.fromPrivate(this, e, f);
    };
    E.prototype.keyFromPublic = function(e, f) {
        return qe.fromPublic(this, e, f);
    };
    E.prototype.genKeyPair = function(e) {
        e || (e = {});
        for(var f = new Ve({
            hash: this.hash,
            pers: e.pers,
            persEnc: e.persEnc || "utf8",
            entropy: e.entropy || Tf(this.hash.hmacStrength),
            entropyEnc: e.entropy && e.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), r = this.n.byteLength(), a = this.n.sub(new T(2));;){
            var c = new T(f.generate(r));
            if (!(c.cmp(a) > 0)) return c.iaddn(1), this.keyFromPrivate(c);
        }
    };
    E.prototype._truncateToN = function(e, f) {
        var r = e.byteLength() * 8 - this.n.bitLength();
        return r > 0 && (e = e.ushrn(r)), !f && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    E.prototype.sign = function(e, f, r, a) {
        typeof r == "object" && (a = r, r = null), a || (a = {}), f = this.keyFromPrivate(f, r), e = this._truncateToN(new T(e, 16));
        for(var c = this.n.byteLength(), i = f.getPrivate().toArray("be", c), t = e.toArray("be", c), b = new Ve({
            hash: this.hash,
            entropy: i,
            nonce: t,
            pers: a.pers,
            persEnc: a.persEnc || "utf8"
        }), s = this.n.sub(new T(1)), n = 0;; n++){
            var u = a.k ? a.k(n) : new T(b.generate(this.n.byteLength()));
            if (u = this._truncateToN(u, !0), !(u.cmpn(1) <= 0 || u.cmp(s) >= 0)) {
                var o = this.g.mul(u);
                if (!o.isInfinity()) {
                    var v = o.getX(), h = v.umod(this.n);
                    if (h.cmpn(0) !== 0) {
                        var l = u.invm(this.n).mul(h.mul(f.getPrivate()).iadd(e));
                        if (l = l.umod(this.n), l.cmpn(0) !== 0) {
                            var S = (o.getY().isOdd() ? 1 : 0) | (v.cmp(h) !== 0 ? 2 : 0);
                            return a.canonical && l.cmp(this.nh) > 0 && (l = this.n.sub(l), S ^= 1), new se({
                                r: h,
                                s: l,
                                recoveryParam: S
                            });
                        }
                    }
                }
            }
        }
    };
    E.prototype.verify = function(e, f, r, a) {
        e = this._truncateToN(new T(e, 16)), r = this.keyFromPublic(r, a), f = new se(f, "hex");
        var c = f.r, i = f.s;
        if (c.cmpn(1) < 0 || c.cmp(this.n) >= 0 || i.cmpn(1) < 0 || i.cmp(this.n) >= 0) return !1;
        var t = i.invm(this.n), b = t.mul(e).umod(this.n), s = t.mul(c).umod(this.n), n;
        return this.curve._maxwellTrick ? (n = this.g.jmulAdd(b, r.getPublic(), s), n.isInfinity() ? !1 : n.eqXToP(c)) : (n = this.g.mulAdd(b, r.getPublic(), s), n.isInfinity() ? !1 : n.getX().umod(this.n).cmp(c) === 0);
    };
    E.prototype.recoverPubKey = function(d, e, f, r) {
        Ze((3 & f) === f, "The recovery param is more than two bits"), e = new se(e, r);
        var a = this.n, c = new T(d), i = e.r, t = e.s, b = f & 1, s = f >> 1;
        if (i.cmp(this.curve.p.umod(this.curve.n)) >= 0 && s) throw new Error("Unable to find sencond key candinate");
        s ? i = this.curve.pointFromX(i.add(this.curve.n), b) : i = this.curve.pointFromX(i, b);
        var n = e.r.invm(a), u = a.sub(c).mul(n).umod(a), o = t.mul(n).umod(a);
        return this.g.mulAdd(u, i, o);
    };
    E.prototype.getKeyRecoveryParam = function(d, e, f, r) {
        if (e = new se(e, r), e.recoveryParam !== null) return e.recoveryParam;
        for(var a = 0; a < 4; a++){
            var c;
            try {
                c = this.recoverPubKey(d, e, a);
            } catch (i) {
                continue;
            }
            if (c.eq(f)) return a;
        }
        throw new Error("Unable to find valid recovery factor");
    };
});
var rf = M((nd, df)=>{
    "use strict";
    var ee = z(), ef = ee.assert, ff = ee.parseBytes, U = ee.cachedProperty;
    function I(d, e) {
        this.eddsa = d, this._secret = ff(e.secret), d.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = ff(e.pub);
    }
    I.fromPublic = function(e, f) {
        return f instanceof I ? f : new I(e, {
            pub: f
        });
    };
    I.fromSecret = function(e, f) {
        return f instanceof I ? f : new I(e, {
            secret: f
        });
    };
    I.prototype.secret = function() {
        return this._secret;
    };
    U(I, "pubBytes", function() {
        return this.eddsa.encodePoint(this.pub());
    });
    U(I, "pub", function() {
        return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    U(I, "privBytes", function() {
        var e = this.eddsa, f = this.hash(), r = e.encodingLength - 1, a = f.slice(0, e.encodingLength);
        return a[0] &= 248, a[r] &= 127, a[r] |= 64, a;
    });
    U(I, "priv", function() {
        return this.eddsa.decodeInt(this.privBytes());
    });
    U(I, "hash", function() {
        return this.eddsa.hash().update(this.secret()).digest();
    });
    U(I, "messagePrefix", function() {
        return this.hash().slice(this.eddsa.encodingLength);
    });
    I.prototype.sign = function(e) {
        return ef(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    I.prototype.verify = function(e, f) {
        return this.eddsa.verify(e, f, this);
    };
    I.prototype.getSecret = function(e) {
        return ef(this._secret, "KeyPair is public only"), ee.encode(this.secret(), e);
    };
    I.prototype.getPublic = function(e) {
        return ee.encode(this.pubBytes(), e);
    };
    df.exports = I;
});
var tf = M((sd, af)=>{
    "use strict";
    var Yf = export_default, ue = z(), Kf = ue.assert, oe = ue.cachedProperty, kf = ue.parseBytes;
    function Y(d, e) {
        this.eddsa = d, typeof e != "object" && (e = kf(e)), Array.isArray(e) && (e = {
            R: e.slice(0, d.encodingLength),
            S: e.slice(d.encodingLength)
        }), Kf(e.R && e.S, "Signature without R or S"), d.isPoint(e.R) && (this._R = e.R), e.S instanceof Yf && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    oe(Y, "S", function() {
        return this.eddsa.decodeInt(this.Sencoded());
    });
    oe(Y, "R", function() {
        return this.eddsa.decodePoint(this.Rencoded());
    });
    oe(Y, "Rencoded", function() {
        return this.eddsa.encodePoint(this.R());
    });
    oe(Y, "Sencoded", function() {
        return this.eddsa.encodeInt(this.S());
    });
    Y.prototype.toBytes = function() {
        return this.Rencoded().concat(this.Sencoded());
    };
    Y.prototype.toHex = function() {
        return ue.encode(this.toBytes(), "hex").toUpperCase();
    };
    af.exports = Y;
});
var uf = M((ud, sf)=>{
    "use strict";
    var Wf = export_default, Hf = ie(), G = z(), Uf = G.assert, cf = G.parseBytes, bf = rf(), nf = tf();
    function _(d) {
        if (Uf(d === "ed25519", "only tested with ed25519 so far"), !(this instanceof _)) return new _(d);
        d = Hf[d].curve, this.curve = d, this.g = d.g, this.g.precompute(d.n.bitLength() + 1), this.pointClass = d.point().constructor, this.encodingLength = Math.ceil(d.n.bitLength() / 8), this.hash = Wf.sha512;
    }
    sf.exports = _;
    _.prototype.sign = function(e, f) {
        e = cf(e);
        var r = this.keyFromSecret(f), a = this.hashInt(r.messagePrefix(), e), c = this.g.mul(a), i = this.encodePoint(c), t = this.hashInt(i, r.pubBytes(), e).mul(r.priv()), b = a.add(t).umod(this.curve.n);
        return this.makeSignature({
            R: c,
            S: b,
            Rencoded: i
        });
    };
    _.prototype.verify = function(e, f, r) {
        e = cf(e), f = this.makeSignature(f);
        var a = this.keyFromPublic(r), c = this.hashInt(f.Rencoded(), a.pubBytes(), e), i = this.g.mul(f.S()), t = f.R().add(a.pub().mul(c));
        return t.eq(i);
    };
    _.prototype.hashInt = function() {
        for(var e = this.hash(), f = 0; f < arguments.length; f++)e.update(arguments[f]);
        return G.intFromLE(e.digest()).umod(this.curve.n);
    };
    _.prototype.keyFromPublic = function(e) {
        return bf.fromPublic(this, e);
    };
    _.prototype.keyFromSecret = function(e) {
        return bf.fromSecret(this, e);
    };
    _.prototype.makeSignature = function(e) {
        return e instanceof nf ? e : new nf(this, e);
    };
    _.prototype.encodePoint = function(e) {
        var f = e.getY().toArray("le", this.encodingLength);
        return f[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, f;
    };
    _.prototype.decodePoint = function(e) {
        e = G.parseBytes(e);
        var f = e.length - 1, r = e.slice(0, f).concat(e[f] & ~128), a = (e[f] & 128) != 0, c = G.intFromLE(r);
        return this.curve.pointFromY(c, a);
    };
    _.prototype.encodeInt = function(e) {
        return e.toArray("le", this.encodingLength);
    };
    _.prototype.decodeInt = function(e) {
        return G.intFromLE(e);
    };
    _.prototype.isPoint = function(e) {
        return e instanceof this.pointClass;
    };
});
var hf = M((of)=>{
    "use strict";
    var K = of;
    K.version = Pe().version;
    K.utils = z();
    K.rand = export_default;
    K.curve = ye();
    K.curves = ie();
    K.ec = Qe();
    K.eddsa = uf();
});
var Gf = Af(hf());
var export_default = Gf.default;
var j = l((Sr, A)=>{
    var o = export_default.Buffer, p = export_default, Z = export_default, $ = export_default.ec, S = export_default, rr = export_default, er = E();
    function ar(r, e, t, a, n) {
        var s = rr(e);
        if (s.curve) {
            if (a !== "ecdsa" && a !== "ecdsa/rsa") throw new Error("wrong private key type");
            return tr(r, s);
        } else if (s.type === "dsa") {
            if (a !== "dsa") throw new Error("wrong private key type");
            return ir(r, s, t);
        } else if (a !== "rsa" && a !== "ecdsa/rsa") throw new Error("wrong private key type");
        r = o.concat([
            n,
            r
        ]);
        for(var c = s.modulus.byteLength(), i = [
            0,
            1
        ]; r.length + i.length + 1 < c;)i.push(255);
        i.push(0);
        for(var h = -1; ++h < r.length;)i.push(r[h]);
        var d = Z(i, s);
        return d;
    }
    function tr(r, e) {
        var t = er[e.curve.join(".")];
        if (!t) throw new Error("unknown curve " + e.curve.join("."));
        var a = new $(t), n = a.keyFromPrivate(e.privateKey), s = n.sign(r);
        return o.from(s.toDER());
    }
    function ir(r, e, t) {
        for(var a = e.params.priv_key, n = e.params.p, s = e.params.q, c = e.params.g, i = new S(0), h, d = H(r, s).mod(s), f = !1, v = W(a, s, r, t); f === !1;)h = x(s, v, t), i = hr(c, h, n, s), f = h.invm(s).imul(d.add(a.mul(i))).mod(s), f.cmpn(0) === 0 && (f = !1, i = new S(0));
        return sr(i, f);
    }
    function sr(r, e) {
        r = r.toArray(), e = e.toArray(), r[0] & 128 && (r = [
            0
        ].concat(r)), e[0] & 128 && (e = [
            0
        ].concat(e));
        var t = r.length + e.length + 4, a = [
            48,
            t,
            2,
            r.length
        ];
        return a = a.concat(r, [
            2,
            e.length
        ], e), o.from(a);
    }
    function W(r, e, t, a) {
        if (r = o.from(r.toArray()), r.length < e.byteLength()) {
            var n = o.alloc(e.byteLength() - r.length);
            r = o.concat([
                n,
                r
            ]);
        }
        var s = t.length, c = nr(t, e), i = o.alloc(s);
        i.fill(1);
        var h = o.alloc(s);
        return h = p(a, h).update(i).update(o.from([
            0
        ])).update(r).update(c).digest(), i = p(a, h).update(i).digest(), h = p(a, h).update(i).update(o.from([
            1
        ])).update(r).update(c).digest(), i = p(a, h).update(i).digest(), {
            k: h,
            v: i
        };
    }
    function H(r, e) {
        var t = new S(r), a = (r.length << 3) - e.bitLength();
        return a > 0 && t.ishrn(a), t;
    }
    function nr(r, e) {
        r = H(r, e), r = r.mod(e);
        var t = o.from(r.toArray());
        if (t.length < e.byteLength()) {
            var a = o.alloc(e.byteLength() - t.length);
            t = o.concat([
                a,
                t
            ]);
        }
        return t;
    }
    function x(r, e, t) {
        var a, n;
        do {
            for(a = o.alloc(0); a.length * 8 < r.bitLength();)e.v = p(t, e.k).update(e.v).digest(), a = o.concat([
                a,
                e.v
            ]);
            n = H(a, r), e.k = p(t, e.k).update(e.v).update(o.from([
                0
            ])).digest(), e.v = p(t, e.k).update(e.v).digest();
        }while (n.cmp(r) !== -1)
        return n;
    }
    function hr(r, e, t, a) {
        return r.toRed(S.mont(t)).redPow(e).fromRed().mod(a);
    }
    A.exports = ar;
    A.exports.getKey = W;
    A.exports.makeKey = x;
});
var I = l((Ar, B)=>{
    var k = export_default.Buffer, m = export_default, or = export_default.ec, L = export_default, dr = E();
    function ur(r, e, t, a, n) {
        var s = L(t);
        if (s.type === "ec") {
            if (a !== "ecdsa" && a !== "ecdsa/rsa") throw new Error("wrong public key type");
            return cr(r, e, s);
        } else if (s.type === "dsa") {
            if (a !== "dsa") throw new Error("wrong public key type");
            return fr(r, e, s);
        } else if (a !== "rsa" && a !== "ecdsa/rsa") throw new Error("wrong public key type");
        e = k.concat([
            n,
            e
        ]);
        for(var c = s.modulus.byteLength(), i = [
            1
        ], h = 0; e.length + i.length + 2 < c;)i.push(255), h++;
        i.push(0);
        for(var d = -1; ++d < e.length;)i.push(e[d]);
        i = k.from(i);
        var f = m.mont(s.modulus);
        r = new m(r).toRed(f), r = r.redPow(new m(s.publicExponent)), r = k.from(r.fromRed().toArray());
        var v = h < 8 ? 1 : 0;
        for(c = Math.min(r.length, i.length), r.length !== i.length && (v = 1), d = -1; ++d < c;)v |= r[d] ^ i[d];
        return v === 0;
    }
    function cr(r, e, t) {
        var a = dr[t.data.algorithm.curve.join(".")];
        if (!a) throw new Error("unknown curve " + t.data.algorithm.curve.join("."));
        var n = new or(a), s = t.data.subjectPrivateKey.data;
        return n.verify(e, r, s);
    }
    function fr(r, e, t) {
        var a = t.data.p, n = t.data.q, s = t.data.g, c = t.data.pub_key, i = L.signature.decode(r, "der"), h = i.s, d = i.r;
        V(h, n), V(d, n);
        var f = m.mont(a), v = h.invm(n), U = s.toRed(f).redPow(new m(e).mul(v).mod(n)).fromRed().mul(c.toRed(f).redPow(d.mul(v).mod(n)).fromRed()).mod(a).mod(n);
        return U.cmp(d) === 0;
    }
    function V(r, e) {
        if (r.cmpn(0) <= 0) throw new Error("invalid sig");
        if (r.cmp(e) >= e) throw new Error("invalid sig");
    }
    B.exports = ur;
});
var K = l((_r, vr)=>{
    vr.exports = {
        sha224WithRSAEncryption: {
            sign: "rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        "RSA-SHA224": {
            sign: "ecdsa/rsa",
            hash: "sha224",
            id: "302d300d06096086480165030402040500041c"
        },
        sha256WithRSAEncryption: {
            sign: "rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        "RSA-SHA256": {
            sign: "ecdsa/rsa",
            hash: "sha256",
            id: "3031300d060960864801650304020105000420"
        },
        sha384WithRSAEncryption: {
            sign: "rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        "RSA-SHA384": {
            sign: "ecdsa/rsa",
            hash: "sha384",
            id: "3041300d060960864801650304020205000430"
        },
        sha512WithRSAEncryption: {
            sign: "rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA512": {
            sign: "ecdsa/rsa",
            hash: "sha512",
            id: "3051300d060960864801650304020305000440"
        },
        "RSA-SHA1": {
            sign: "rsa",
            hash: "sha1",
            id: "3021300906052b0e03021a05000414"
        },
        "ecdsa-with-SHA1": {
            sign: "ecdsa",
            hash: "sha1",
            id: ""
        },
        sha256: {
            sign: "ecdsa",
            hash: "sha256",
            id: ""
        },
        sha224: {
            sign: "ecdsa",
            hash: "sha224",
            id: ""
        },
        sha384: {
            sign: "ecdsa",
            hash: "sha384",
            id: ""
        },
        sha512: {
            sign: "ecdsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-SHA1": {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        DSA: {
            sign: "dsa",
            hash: "sha1",
            id: ""
        },
        "DSA-WITH-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-SHA224": {
            sign: "dsa",
            hash: "sha224",
            id: ""
        },
        "DSA-WITH-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-SHA256": {
            sign: "dsa",
            hash: "sha256",
            id: ""
        },
        "DSA-WITH-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-SHA384": {
            sign: "dsa",
            hash: "sha384",
            id: ""
        },
        "DSA-WITH-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-SHA512": {
            sign: "dsa",
            hash: "sha512",
            id: ""
        },
        "DSA-RIPEMD160": {
            sign: "dsa",
            hash: "rmd160",
            id: ""
        },
        ripemd160WithRSA: {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        "RSA-RIPEMD160": {
            sign: "rsa",
            hash: "rmd160",
            id: "3021300906052b2403020105000414"
        },
        md5WithRSAEncryption: {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        },
        "RSA-MD5": {
            sign: "rsa",
            hash: "md5",
            id: "3020300c06082a864886f70d020505000410"
        }
    };
});
var D = l((br, T)=>{
    var _ = export_default.Buffer, P = export_default, b = export_default, M = export_default, pr = j(), gr = I(), g = K();
    Object.keys(g).forEach(function(r) {
        g[r].id = _.from(g[r].id, "hex"), g[r.toLowerCase()] = g[r];
    });
    function y(r) {
        b.Writable.call(this);
        var e = g[r];
        if (!e) throw new Error("Unknown message digest");
        this._hashType = e.hash, this._hash = P(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    M(y, b.Writable);
    y.prototype._write = function(e, t, a) {
        this._hash.update(e), a();
    };
    y.prototype.update = function(e, t) {
        return typeof e == "string" && (e = _.from(e, t)), this._hash.update(e), this;
    };
    y.prototype.sign = function(e, t) {
        this.end();
        var a = this._hash.digest(), n = pr(a, e, this._hashType, this._signType, this._tag);
        return t ? n.toString(t) : n;
    };
    function w(r) {
        b.Writable.call(this);
        var e = g[r];
        if (!e) throw new Error("Unknown message digest");
        this._hash = P(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    M(w, b.Writable);
    w.prototype._write = function(e, t, a) {
        this._hash.update(e), a();
    };
    w.prototype.update = function(e, t) {
        return typeof e == "string" && (e = _.from(e, t)), this._hash.update(e), this;
    };
    w.prototype.verify = function(e, t, a) {
        typeof t == "string" && (t = _.from(t, a)), this.end();
        var n = this._hash.digest();
        return gr(t, n, e, this._signType, this._tag);
    };
    function C(r) {
        return new y(r);
    }
    function N(r) {
        return new w(r);
    }
    T.exports = {
        Sign: C,
        Verify: N,
        createSign: C,
        createVerify: N
    };
});
var lr = q(D()), mr = q(D()), { createSign: Rr , Sign: Er , createVerify: Hr , Verify: kr  } = lr;
var export_default = mr.default;
var a = P((d, c)=>{
    var k = export_default, w = export_default;
    c.exports = function(t) {
        return new s(t);
    };
    var u = {
        secp256k1: {
            name: "secp256k1",
            byteLength: 32
        },
        secp224r1: {
            name: "p224",
            byteLength: 28
        },
        prime256v1: {
            name: "p256",
            byteLength: 32
        },
        prime192v1: {
            name: "p192",
            byteLength: 24
        },
        ed25519: {
            name: "ed25519",
            byteLength: 32
        },
        secp384r1: {
            name: "p384",
            byteLength: 48
        },
        secp521r1: {
            name: "p521",
            byteLength: 66
        }
    };
    u.p224 = u.secp224r1;
    u.p256 = u.secp256r1 = u.prime256v1;
    u.p192 = u.secp192r1 = u.prime192v1;
    u.p384 = u.secp384r1;
    u.p521 = u.secp521r1;
    function s(e) {
        this.curveType = u[e], this.curveType || (this.curveType = {
            name: e
        }), this.curve = new k.ec(this.curveType.name), this.keys = void 0;
    }
    s.prototype.generateKeys = function(e, t) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(e, t);
    };
    s.prototype.computeSecret = function(e, t, r) {
        t = t || "utf8", ut.isBuffer(e) || (e = new ut(e, t));
        var i = this.curve.keyFromPublic(e).getPublic(), f = i.mul(this.keys.getPrivate()).getX();
        return p(f, r, this.curveType.byteLength);
    };
    s.prototype.getPublicKey = function(e, t) {
        var r = this.keys.getPublic(t === "compressed", !0);
        return t === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), p(r, e);
    };
    s.prototype.getPrivateKey = function(e) {
        return p(this.keys.getPrivate(), e);
    };
    s.prototype.setPublicKey = function(e, t) {
        return t = t || "utf8", ut.isBuffer(e) || (e = new ut(e, t)), this.keys._importPublic(e), this;
    };
    s.prototype.setPrivateKey = function(e, t) {
        t = t || "utf8", ut.isBuffer(e) || (e = new ut(e, t));
        var r = new w(e);
        return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function p(e, t, r) {
        Array.isArray(e) || (e = e.toArray());
        var i = new ut(e);
        if (r && i.length < r) {
            var f = new ut(r - i.length);
            f.fill(0), i = ut.concat([
                f,
                i
            ]);
        }
        return t ? i.toString(t) : i;
    }
});
var K = B(a());
var export_default = K.default;
var f = S((e)=>{
    "use strict";
    e.randomBytes = e.rng = e.pseudoRandomBytes = e.prng = export_default;
    e.createHash = e.Hash = export_default;
    e.createHmac = e.Hmac = export_default;
    var N = export_default, v = Object.keys(N), b = [
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "md5",
        "rmd160"
    ].concat(v);
    e.getHashes = function() {
        return b;
    };
    var o = export_default;
    e.pbkdf2 = o.pbkdf2;
    e.pbkdf2Sync = o.pbkdf2Sync;
    var t = export_default;
    e.Cipher = t.Cipher;
    e.createCipher = t.createCipher;
    e.Cipheriv = t.Cipheriv;
    e.createCipheriv = t.createCipheriv;
    e.Decipher = t.Decipher;
    e.createDecipher = t.createDecipher;
    e.Decipheriv = t.Decipheriv;
    e.createDecipheriv = t.createDecipheriv;
    e.getCiphers = t.getCiphers;
    e.listCiphers = t.listCiphers;
    var p = export_default;
    e.DiffieHellmanGroup = p.DiffieHellmanGroup;
    e.createDiffieHellmanGroup = p.createDiffieHellmanGroup;
    e.getDiffieHellman = p.getDiffieHellman;
    e.createDiffieHellman = p.createDiffieHellman;
    e.DiffieHellman = p.DiffieHellman;
    var n = export_default;
    e.createSign = n.createSign;
    e.Sign = n.Sign;
    e.createVerify = n.createVerify;
    e.Verify = n.Verify;
    e.createECDH = export_default;
    var l = export_default;
    e.publicEncrypt = l.publicEncrypt;
    e.privateEncrypt = l.privateEncrypt;
    e.publicDecrypt = l.publicDecrypt;
    e.privateDecrypt = l.privateDecrypt;
    var y = export_default;
    e.randomFill = y.randomFill;
    e.randomFillSync = y.randomFillSync;
    e.createCredentials = function() {
        throw new Error([
            "sorry, createCredentials is not implemented yet",
            "we accept pull requests",
            "https://github.com/crypto-browserify/crypto-browserify"
        ].join(`
`));
    };
    e.constants = {
        DH_CHECK_P_NOT_SAFE_PRIME: 2,
        DH_CHECK_P_NOT_PRIME: 1,
        DH_UNABLE_TO_CHECK_GENERATOR: 4,
        DH_NOT_SUITABLE_GENERATOR: 8,
        NPN_ENABLED: 1,
        ALPN_ENABLED: 1,
        RSA_PKCS1_PADDING: 1,
        RSA_SSLV23_PADDING: 2,
        RSA_NO_PADDING: 3,
        RSA_PKCS1_OAEP_PADDING: 4,
        RSA_X931_PADDING: 5,
        RSA_PKCS1_PSS_PADDING: 6,
        POINT_CONVERSION_COMPRESSED: 2,
        POINT_CONVERSION_UNCOMPRESSED: 4,
        POINT_CONVERSION_HYBRID: 6
    };
});
var g = h(f()), P = h(f()), { randomBytes: R , rng: I , pseudoRandomBytes: G , prng: q , createHash: w , Hash: T , createHmac: V , Hmac: B , getHashes: k , pbkdf2: F , pbkdf2Sync: K , Cipher: L , createCipher: M , Cipheriv: U , createCipheriv: j , Decipher: x , createDecipher: X , Decipheriv: Y , createDecipheriv: z , getCiphers: J , listCiphers: Q , DiffieHellmanGroup: W , createDiffieHellmanGroup: Z , getDiffieHellman: $ , createDiffieHellman: ee , DiffieHellman: re , createSign: ie , Sign: ae , createVerify: te , Verify: ce , createECDH: pe , publicEncrypt: ne , privateEncrypt: le , publicDecrypt: se , privateDecrypt: fe , randomFill: De , randomFillSync: he , createCredentials: oe , constants: ye  } = g;
var export_default = P.default;
const codes = {};
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
const _isFunctionLike = (value)=>value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
Symbol("kHandle");
Symbol("kKeyObject");
Symbol("kKeyType");
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object";
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isUint8Array(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Uint8Array]";
}
const { isDate , isArgumentsObject , isBigIntObject , isBooleanObject , isNumberObject , isStringObject , isSymbolObject , isNativeError , isRegExp , isAsyncFunction , isGeneratorFunction , isGeneratorObject , isPromise , isMap , isSet , isMapIterator , isSetIterator , isWeakMap , isWeakSet , isArrayBuffer , isDataView , isSharedArrayBuffer , isModuleNamespaceObject , isAnyArrayBuffer , isBoxedPrimitive ,  } = mod;
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
new Set();
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn1(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn1, Object.getPrototypeOf(original));
    Object.defineProperty(fn1, kCustomPromisifiedSymbol, {
        value: fn1,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn1, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer.from(b, b.offset, b.byteLength);
    }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(let i1 = 0; i1 < list.length; i1++){
        const buf = list[i1];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i1}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i1]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer.byteLength = byteLength;
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer.prototype);
    return buffer;
}
function _utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = readUInt16BE;
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = readUInt32BE;
Buffer.prototype.readBigUint64LE = Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUint64BE = Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUint64LE = Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUint64BE = Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
globalThis.atob;
globalThis.Blob;
globalThis.btoa;
const isCryptoKey = (key)=>key instanceof CryptoKey;
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
    const size = buffers.reduce((acc, { length  })=>acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer)=>{
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}
const encodeBase64 = (input)=>{
    let unencoded = input;
    if (typeof unencoded === 'string') {
        unencoded = encoder.encode(unencoded);
    }
    const CHUNK_SIZE = 0x8000;
    const arr = [];
    for(let i = 0; i < unencoded.length; i += CHUNK_SIZE){
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + 0x8000)));
    }
    return btoa(arr.join(''));
};
const encode = (input)=>{
    return encodeBase64(input).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};
class JOSEError extends Error {
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
    code = 'ERR_JOSE_GENERIC';
    constructor(message){
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class JOSENotSupported extends JOSEError {
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
    code = 'ERR_JOSE_NOT_SUPPORTED';
}
class JWSInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWS_INVALID';
    }
    code = 'ERR_JWS_INVALID';
}
class JWTInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWT_INVALID';
    }
    code = 'ERR_JWT_INVALID';
}
crypto.getRandomValues.bind(crypto);
function isCloudflareWorkers() {
    return typeof WebSocketPair === 'function';
}
function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
    switch(alg){
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected)=>key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        } else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            {
                if (!isAlgorithm(key.algorithm, 'HMAC')) throw unusable('HMAC');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'RS256':
        case 'RS384':
        case 'RS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5')) throw unusable('RSASSA-PKCS1-v1_5');
                const expected1 = parseInt(alg.slice(2), 10);
                const actual1 = getHashLength(key.algorithm.hash);
                if (actual1 !== expected1) throw unusable(`SHA-${expected1}`, 'algorithm.hash');
                break;
            }
        case 'PS256':
        case 'PS384':
        case 'PS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-PSS')) throw unusable('RSA-PSS');
                const expected2 = parseInt(alg.slice(2), 10);
                const actual2 = getHashLength(key.algorithm.hash);
                if (actual2 !== expected2) throw unusable(`SHA-${expected2}`, 'algorithm.hash');
                break;
            }
        case isCloudflareWorkers() && 'EdDSA':
            {
                if (!isAlgorithm(key.algorithm, 'NODE-ED25519')) throw unusable('NODE-ED25519');
                break;
            }
        case 'ES256':
        case 'ES384':
        case 'ES512':
            {
                if (!isAlgorithm(key.algorithm, 'ECDSA')) throw unusable('ECDSA');
                const expected3 = getNamedCurve(alg);
                const actual3 = key.algorithm.namedCurve;
                if (actual3 !== expected3) throw unusable(expected3, 'algorithm.namedCurve');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
const __default = (actual, ...types)=>{
    let msg = 'Key must be ';
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    } else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    } else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    } else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
};
const types = [
    'CryptoKey'
];
const __default = (key)=>{
    return isCryptoKey(key);
};
const isDisjoint = (...headers)=>{
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources){
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters){
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}
const __default = (alg, key)=>{
    if (alg.startsWith('RS') || alg.startsWith('PS')) {
        const { modulusLength  } = key.algorithm;
        if (typeof modulusLength !== 'number' || modulusLength < 2048) {
            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
    }
};
const __default = (b64, descriptor)=>{
    const newlined = (b64.match(/.{1,64}/g) || []).join('\n');
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
};
const findOid = (keyData, oid, from = 0)=>{
    if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(0x06);
    }
    let i = keyData.indexOf(oid[0], from);
    if (i === -1) return false;
    const sub = keyData.subarray(i, i + oid.length);
    if (sub.length !== oid.length) return false;
    return sub.every((value, index)=>value === oid[index]) || findOid(keyData, oid, i + 1);
};
const symmetricTypeCheck = (key)=>{
    if (key instanceof Uint8Array) return;
    if (!__default(key)) {
        throw new TypeError(__default(key, ...types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (key, usage)=>{
    if (!__default(key)) {
        throw new TypeError(__default(key, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage)=>{
    const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(key);
    } else {
        asymmetricTypeCheck(key, usage);
    }
};
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([
            ...Object.entries(recognizedOption),
            ...recognizedDefault.entries()
        ]);
    } else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit){
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}
Symbol();
function subtleDsa(alg, algorithm) {
    const hash = `SHA-${alg.slice(-3)}`;
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            return {
                hash,
                name: 'HMAC'
            };
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                hash,
                name: 'RSA-PSS',
                saltLength: alg.slice(-3) >> 3
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                hash,
                name: 'RSASSA-PKCS1-v1_5'
            };
        case 'ES256':
        case 'ES384':
        case 'ES512':
            return {
                hash,
                name: 'ECDSA',
                namedCurve: algorithm.namedCurve
            };
        case isCloudflareWorkers() && 'EdDSA':
            const { namedCurve  } = algorithm;
            return {
                name: namedCurve,
                namedCurve
            };
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}
function getCryptoKey(alg, key, usage) {
    if (isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError(__default(key, ...types));
        }
        return crypto.subtle.importKey('raw', key, {
            hash: `SHA-${alg.slice(-3)}`,
            name: 'HMAC'
        }, false, [
            usage
        ]);
    }
    throw new TypeError(__default(key, ...types, 'Uint8Array'));
}
const __default = (date)=>Math.floor(date.getTime() / 1000);
const hour = 60 * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
const __default = (str)=>{
    const matched = REGEX.exec(str);
    if (!matched) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch(unit){
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            return Math.round(value);
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            return Math.round(value * 60);
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            return Math.round(value * hour);
        case 'day':
        case 'days':
        case 'd':
            return Math.round(value * day);
        case 'week':
        case 'weeks':
        case 'w':
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
};
const sign = async (alg, key, data)=>{
    const cryptoKey = await getCryptoKey(alg, key, 'sign');
    __default(alg, cryptoKey);
    const signature = await crypto.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
    return new Uint8Array(signature);
};
class FlattenedSign {
    _payload;
    _protectedHeader;
    _unprotectedHeader;
    constructor(payload){
        if (!(payload instanceof Uint8Array)) {
            throw new TypeError('payload must be an instance of Uint8Array');
        }
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
            throw new TypeError('setProtectedHeader can only be called once');
        }
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
            throw new TypeError('setUnprotectedHeader can only be called once');
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
        }
        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {
            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
        }
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader
        };
        const extensions = validateCrit(JWSInvalid, new Map([
            [
                'b64',
                true
            ]
        ]), options?.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') {
                throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
            }
        }
        const { alg  } = joseHeader;
        if (typeof alg !== 'string' || !alg) {
            throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        checkKeyType(alg, key, 'sign');
        let payload = this._payload;
        if (b64) {
            payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
            protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
            protectedHeader = encoder.encode('');
        }
        const data = concat(protectedHeader, encoder.encode('.'), payload);
        const signature = await sign(alg, key, data);
        const jws = {
            signature: encode(signature),
            payload: ''
        };
        if (b64) {
            jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
            jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
            jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
    }
}
class CompactSign {
    _flattened;
    constructor(payload){
        this._flattened = new FlattenedSign(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) {
            throw new TypeError('use the flattened module for creating JWS with b64: false');
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}
class ProduceJWT {
    _payload;
    constructor(payload){
        if (!isObject(payload)) {
            throw new TypeError('JWT Claims Set MUST be an object');
        }
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = {
            ...this._payload,
            iss: issuer
        };
        return this;
    }
    setSubject(subject) {
        this._payload = {
            ...this._payload,
            sub: subject
        };
        return this;
    }
    setAudience(audience) {
        this._payload = {
            ...this._payload,
            aud: audience
        };
        return this;
    }
    setJti(jwtId) {
        this._payload = {
            ...this._payload,
            jti: jwtId
        };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === 'number') {
            this._payload = {
                ...this._payload,
                nbf: input
            };
        } else {
            this._payload = {
                ...this._payload,
                nbf: __default(new Date()) + __default(input)
            };
        }
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === 'number') {
            this._payload = {
                ...this._payload,
                exp: input
            };
        } else {
            this._payload = {
                ...this._payload,
                exp: __default(new Date()) + __default(input)
            };
        }
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === 'undefined') {
            this._payload = {
                ...this._payload,
                iat: __default(new Date())
            };
        } else {
            this._payload = {
                ...this._payload,
                iat: input
            };
        }
        return this;
    }
}
class SignJWT extends ProduceJWT {
    _protectedHeader;
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray(this._protectedHeader?.crit) && this._protectedHeader.crit.includes('b64') && this._protectedHeader.b64 === false) {
            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
        }
        return sig.sign(key, options);
    }
}
'use strict';
const WebPushConstants = {};
const supportedContentEncodings = {
    AES_GCM: 'aesgcm',
    AES_128_GCM: 'aes128gcm'
};
WebPushConstants.supportedContentEncodings = supportedContentEncodings;
'use strict';
const DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;
const MAX_EXPIRATION_SECONDS = 24 * 60 * 60;
function generateVAPIDKeys() {
    const curve = export_default('prime256v1');
    curve.generateKeys();
    let publicKeyBuffer = curve.getPublicKey();
    let privateKeyBuffer = curve.getPrivateKey();
    if (privateKeyBuffer.length < 32) {
        const padding = Buffer.alloc(32 - privateKeyBuffer.length);
        padding.fill(0);
        privateKeyBuffer = Buffer.concat([
            padding,
            privateKeyBuffer
        ]);
    }
    if (publicKeyBuffer.length < 65) {
        const padding1 = Buffer.alloc(65 - publicKeyBuffer.length);
        padding1.fill(0);
        publicKeyBuffer = Buffer.concat([
            padding1,
            publicKeyBuffer
        ]);
    }
    return {
        publicKey: encode(publicKeyBuffer.toString()),
        privateKey: encode(privateKeyBuffer.toString())
    };
}
function validateSubject(subject) {
    if (!subject) {
        throw new Error('No subject set in vapidDetails.subject.');
    }
    if (typeof subject !== 'string' || subject.length === 0) {
        throw new Error('The subject value must be a string containing a URL or ' + 'mailto: address. ' + subject);
    }
    if (subject.indexOf('mailto:') !== 0) {
        const subjectParseResult = parse(subject, false, false);
        if (!subjectParseResult.hostname) {
            throw new Error('Vapid subject is not a url or mailto url. ' + subject);
        }
    }
}
function validatePublicKey(publicKey) {
    if (!publicKey) {
        throw new Error('No key set vapidDetails.publicKey');
    }
    if (typeof publicKey !== 'string') {
        throw new Error('Vapid public key is must be a URL safe Base 64 ' + 'encoded string.');
    }
    if (!isUrlSafeBase64(publicKey)) {
        throw new Error('Vapid public key must be a URL safe Base 64 (without "=")');
    }
    publicKey = decode(publicKey);
    if (publicKey.length !== 65) {
        throw new Error('Vapid public key should be 65 bytes long when decoded.');
    }
}
function validatePrivateKey(privateKey) {
    if (!privateKey) {
        throw new Error('No key set in vapidDetails.privateKey');
    }
    if (typeof privateKey !== 'string') {
        throw new Error('Vapid private key must be a URL safe Base 64 ' + 'encoded string.');
    }
    if (!isUrlSafeBase64(privateKey)) {
        throw new Error('Vapid private key must be a URL safe Base 64 (without "=")');
    }
    privateKey = decode(privateKey);
    if (privateKey.length !== 32) {
        throw new Error('Vapid private key should be 32 bytes long when decoded.');
    }
}
function getFutureExpirationTimestamp(numSeconds) {
    const futureExp = new Date();
    futureExp.setSeconds(futureExp.getSeconds() + numSeconds);
    return Math.floor(futureExp.getTime() / 1000);
}
function validateExpiration(expiration) {
    if (!Number.isInteger(expiration)) {
        throw new Error('`expiration` value must be a number');
    }
    if (expiration < 0) {
        throw new Error('`expiration` must be a positive integer');
    }
    const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);
    if (expiration >= maxExpirationTimestamp) {
        throw new Error('`expiration` value is greater than maximum of 24 hours');
    }
}
async function getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {
    if (!audience) {
        throw new Error('No audience could be generated for VAPID.');
    }
    if (typeof audience !== 'string' || audience.length === 0) {
        throw new Error('The audience value must be a string containing the ' + 'origin of a push service. ' + audience);
    }
    const audienceParseResult = parse(audience, false, false);
    if (!audienceParseResult.hostname) {
        throw new Error('VAPID audience is not a url. ' + audience);
    }
    validateSubject(subject);
    validatePublicKey(publicKey);
    validatePrivateKey(privateKey);
    privateKey = decode(privateKey);
    if (expiration) {
        validateExpiration(expiration);
    } else {
        expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);
    }
    const header = {
        typ: 'JWT',
        alg: 'ES256'
    };
    const jwtPayload = {
        aud: audience,
        exp: expiration,
        sub: subject
    };
    const jwt = await new SignJWT(jwtPayload).setProtectedHeader(header).sign(new __default.TextEncoder().encode(__default(privateKey, 'EC PRIVATE KEY')));
    if (contentEncoding === supportedContentEncodings.AES_128_GCM) {
        return {
            Authorization: 'vapid t=' + jwt + ', k=' + publicKey
        };
    }
    if (contentEncoding === supportedContentEncodings.AES_GCM) {
        return {
            Authorization: 'WebPush ' + jwt,
            'Crypto-Key': 'p256ecdsa=' + publicKey
        };
    }
    throw new Error('Unsupported encoding type specified.');
}
'use strict';
const importMeta = {
    url: "file:///Users/mcharlton/OtherCode/deno-web-push/src/ece.ts",
    main: false
};
const AES_GCM = 'aes-128-gcm';
const PAD_SIZE = {
    aes128gcm: 1,
    aesgcm: 2
};
const TAG_LENGTH = 16;
const KEY_LENGTH = 16;
const SHA_256_LENGTH = 32;
const MODE_ENCRYPT = 'encrypt';
const MODE_DECRYPT = 'decrypt';
let keylog;
if (importMeta.env?.ECE_KEYLOG === '1') {
    keylog = function(m, k) {
        console.warn(m + ' [' + k.length + ']: ' + encode(k));
        return k;
    };
} else {
    keylog = function(m, k) {
        return k;
    };
}
function decode(b) {
    if (typeof b === 'string') {
        return decode(b);
    }
    return b;
}
function HMAC_hash(key, input) {
    const hmac = createHmac('sha256', key);
    hmac.update(input);
    return hmac.digest();
}
function HKDF_extract(salt, ikm) {
    keylog('salt', salt);
    keylog('ikm', ikm);
    return keylog('extract', HMAC_hash(salt, ikm));
}
function HKDF_expand(prk, info, l) {
    keylog('prk', prk);
    keylog('info', info);
    let output = Buffer.alloc(0);
    let T = Buffer.alloc(0);
    info = Buffer.from(info, 'ascii');
    let counter = 0;
    const cbuf = Buffer.alloc(1);
    while(output.length < l){
        cbuf.writeUIntBE(++counter, 0, 1);
        T = HMAC_hash(prk, Buffer.concat([
            T,
            info,
            cbuf
        ]));
        output = Buffer.concat([
            output,
            T
        ]);
    }
    return keylog('expand', output.slice(0, l));
}
function HKDF(salt, ikm, info, len) {
    return HKDF_expand(HKDF_extract(salt, ikm), info, len);
}
function info(base, context) {
    const result = Buffer.concat([
        Buffer.from('Content-Encoding: ' + base + '\0', 'ascii'),
        context, 
    ]);
    keylog('info ' + base, result);
    return result;
}
function lengthPrefix(buffer) {
    const b = Buffer.concat([
        Buffer.alloc(2),
        buffer
    ]);
    b.writeUIntBE(buffer.length, 0, 2);
    return b;
}
function extractDH(header, mode) {
    const key = header.privateKey;
    let senderPubKey, receiverPubKey;
    if (mode === MODE_ENCRYPT) {
        senderPubKey = key.getPublicKey();
        receiverPubKey = header.dh;
    } else if (mode === MODE_DECRYPT) {
        senderPubKey = header.dh;
        receiverPubKey = key.getPublicKey();
    } else {
        throw new Error('Unknown mode only ' + MODE_ENCRYPT + ' and ' + MODE_DECRYPT + ' supported');
    }
    return {
        secret: key.computeSecret(header.dh),
        context: Buffer.concat([
            Buffer.from(header.keylabel, 'ascii'),
            Buffer.from([
                0
            ]),
            lengthPrefix(receiverPubKey),
            lengthPrefix(senderPubKey)
        ])
    };
}
function extractSecretAndContext(header, mode) {
    let result = {
        secret: null,
        context: Buffer.alloc(0)
    };
    if (header.key) {
        result.secret = header.key;
        if (result.secret !== null && result.secret.length !== 16) {
            throw new Error('An explicit key must be ' + 16 + ' bytes');
        }
    } else if (header.dh) {
        result = extractDH(header, mode);
    } else if (header.keyid !== undefined) {
        result.secret = header.keymap[header.keyid];
    }
    if (!result.secret) {
        throw new Error('Unable to determine key');
    }
    keylog('secret', result.secret);
    keylog('context', result.context);
    if (header.authSecret) {
        result.secret = HKDF(header.authSecret, result.secret, info('auth', Buffer.alloc(0)), SHA_256_LENGTH);
        keylog('authsecret', result.secret);
    }
    return result;
}
function webpushSecret(header, mode) {
    if (!header.authSecret) {
        throw new Error('No authentication secret for webpush');
    }
    keylog('authsecret', header.authSecret);
    let remotePubKey, senderPubKey, receiverPubKey;
    if (mode === MODE_ENCRYPT) {
        senderPubKey = header.privateKey.getPublicKey();
        remotePubKey = receiverPubKey = header.dh;
    } else if (mode === MODE_DECRYPT) {
        remotePubKey = senderPubKey = header.keyid;
        receiverPubKey = header.privateKey.getPublicKey();
    } else {
        throw new Error('Unknown mode only ' + MODE_ENCRYPT + ' and ' + MODE_DECRYPT + ' supported');
    }
    keylog('remote pubkey', remotePubKey);
    keylog('sender pubkey', senderPubKey);
    keylog('receiver pubkey', receiverPubKey);
    return keylog('secret dh', HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer.concat([
        Buffer.from('WebPush: info\0'),
        receiverPubKey,
        senderPubKey, 
    ]), 32));
}
function extractSecret(header, mode, keyLookupCallback) {
    if (keyLookupCallback) {
        if (!isFunction(keyLookupCallback)) {
            throw new Error('Callback is not a function');
        }
    }
    if (header.key) {
        if (header.key.length !== 16) {
            throw new Error('An explicit key must be ' + 16 + ' bytes');
        }
        return keylog('secret key', header.key);
    }
    if (!header.privateKey) {
        let key;
        if (!keyLookupCallback) {
            key = header.keymap && header.keymap[header.keyid];
        } else {
            key = keyLookupCallback(header.keyid);
        }
        if (!key) {
            throw new Error('No saved key (keyid: "' + header.keyid + '")');
        }
        return key;
    }
    return webpushSecret(header, mode);
}
function deriveKeyAndNonce(header, mode, lookupKeyCallback) {
    if (!header.salt) {
        throw new Error('must include a salt parameter for ' + header.version);
    }
    let keyInfo;
    let nonceInfo;
    let secret;
    if (header.version === 'aesgcm') {
        const s = extractSecretAndContext(header, mode, lookupKeyCallback);
        keyInfo = info('aesgcm', s.context);
        nonceInfo = info('nonce', s.context);
        secret = s.secret;
    } else if (header.version === 'aes128gcm') {
        keyInfo = Buffer.from('Content-Encoding: aes128gcm\0');
        nonceInfo = Buffer.from('Content-Encoding: nonce\0');
        secret = extractSecret(header, mode, lookupKeyCallback);
    } else {
        throw new Error('Unable to set context for mode ' + header.version);
    }
    const prk = HKDF_extract(header.salt, secret);
    const result = {
        key: HKDF_expand(prk, keyInfo, 16),
        nonce: HKDF_expand(prk, nonceInfo, 12)
    };
    keylog('key', result.key);
    keylog('nonce base', result.nonce);
    return result;
}
function parseParams(params) {
    const header = {};
    header.version = params.version || 'aes128gcm';
    header.rs = parseInt(params.rs, 10);
    if (isNaN(header.rs)) {
        header.rs = 4096;
    }
    const overhead = PAD_SIZE[header.version];
    if (header.version === 'aes128gcm') {
        overhead += TAG_LENGTH;
    }
    if (header.rs <= overhead) {
        throw new Error('The rs parameter has to be greater than ' + overhead);
    }
    if (params.salt) {
        header.salt = decode(params.salt);
        if (header.salt.length !== 16) {
            throw new Error('The salt parameter must be ' + 16 + ' bytes');
        }
    }
    header.keyid = params.keyid;
    if (params.key) {
        header.key = decode(params.key);
    } else {
        header.privateKey = params.privateKey;
        if (!header.privateKey) {
            header.keymap = params.keymap;
        }
        if (header.version !== 'aes128gcm') {
            header.keylabel = params.keylabel || 'P-256';
        }
        if (params.dh) {
            header.dh = decode(params.dh);
        }
    }
    if (params.authSecret) {
        header.authSecret = decode(params.authSecret);
    }
    return header;
}
function generateNonce(base, counter) {
    const nonce = Buffer.from(base);
    const m = nonce.readUIntBE(nonce.length - 6, 6);
    const x = ((m ^ counter) & 0xffffff) + ((m / 0x1000000 ^ counter / 0x1000000) & 0xffffff) * 0x1000000;
    nonce.writeUIntBE(x, nonce.length - 6, 6);
    keylog('nonce' + counter, nonce);
    return nonce;
}
function encryptRecord(key, counter, buffer, pad, header, last) {
    keylog('encrypt', buffer);
    pad = pad || 0;
    const nonce = generateNonce(key.nonce, counter);
    const gcm = createCipheriv(AES_GCM, key.key, nonce);
    const ciphertext = [];
    const padSize = PAD_SIZE[header.version];
    const padding = Buffer.alloc(pad + padSize);
    padding.fill(0);
    if (header.version !== 'aes128gcm') {
        padding.writeUIntBE(pad, 0, padSize);
        keylog('padding', padding);
        ciphertext.push(gcm.update(padding));
        ciphertext.push(gcm.update(buffer));
        if (!last && padding.length + buffer.length < header.rs) {
            throw new Error('Unable to pad to record size');
        }
    } else {
        ciphertext.push(gcm.update(buffer));
        padding.writeUIntBE(last ? 2 : 1, 0, 1);
        keylog('padding', padding);
        ciphertext.push(gcm.update(padding));
    }
    gcm.final();
    const tag = gcm.getAuthTag();
    if (tag.length !== 16) {
        throw new Error('invalid tag generated');
    }
    ciphertext.push(tag);
    return keylog('encrypted', Buffer.concat(ciphertext));
}
function writeHeader(header) {
    const ints = Buffer.alloc(5);
    const keyid = Buffer.from(header.keyid || []);
    if (keyid.length > 255) {
        throw new Error('keyid is too large');
    }
    ints.writeUIntBE(header.rs, 0, 4);
    ints.writeUIntBE(keyid.length, 4, 1);
    return Buffer.concat([
        header.salt,
        ints,
        keyid
    ]);
}
function encrypt(buffer, params, keyLookupCallback) {
    if (!Buffer.isBuffer(buffer)) {
        throw new Error('buffer argument must be a Buffer');
    }
    const header = parseParams(params);
    if (!header.salt) {
        header.salt = export_default(KEY_LENGTH);
    }
    let result;
    if (header.version === 'aes128gcm') {
        if (header.privateKey && !header.keyid) {
            header.keyid = header.privateKey.getPublicKey();
        }
        result = writeHeader(header);
    } else {
        result = Buffer.alloc(0);
    }
    const key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);
    let start = 0;
    const padSize = PAD_SIZE[header.version];
    let overhead = padSize;
    if (header.version === 'aes128gcm') {
        overhead += TAG_LENGTH;
    }
    let pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);
    let counter = 0;
    let last = false;
    while(!last){
        let recordPad = Math.min(header.rs - overhead - 1, pad);
        if (header.version !== 'aes128gcm') {
            recordPad = Math.min((1 << padSize * 8) - 1, recordPad);
        }
        if (pad > 0 && recordPad === 0) {
            ++recordPad;
        }
        pad -= recordPad;
        const end = start + header.rs - overhead - recordPad;
        if (header.version !== 'aes128gcm') {
            last = end > buffer.length;
        } else {
            last = end >= buffer.length;
        }
        last = last && pad <= 0;
        const block = encryptRecord(key, counter, buffer.slice(start, end), recordPad, header, last);
        result = Buffer.concat([
            result,
            block
        ]);
        start = end;
        ++counter;
    }
    return result;
}
function isFunction(object) {
    return typeof object === 'function';
}
'use strict';
const encrypt = function(userPublicKey, userAuth, payload, contentEncoding) {
    if (!userPublicKey) {
        throw new Error('No user public key provided for encryption.');
    }
    if (typeof userPublicKey !== 'string') {
        throw new Error('The subscription p256dh value must be a string.');
    }
    if (decode(userPublicKey).length !== 65) {
        throw new Error('The subscription p256dh value should be 65 bytes long.');
    }
    if (!userAuth) {
        throw new Error('No user auth provided for encryption.');
    }
    if (typeof userAuth !== 'string') {
        throw new Error('The subscription auth key must be a string.');
    }
    if (decode(userAuth).length < 16) {
        throw new Error('The subscription auth key should be at least 16 ' + 'bytes long');
    }
    if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
        throw new Error('Payload must be either a string or a Node Buffer.');
    }
    if (typeof payload === 'string' || payload instanceof String) {
        payload = Buffer.from(payload);
    }
    const localCurve = export_default('prime256v1');
    const localPublicKey = localCurve.generateKeys();
    const salt = encode(export_default(16).toString());
    const cipherText = encrypt(payload, {
        version: contentEncoding,
        dh: userPublicKey,
        privateKey: localCurve,
        salt: salt,
        authSecret: userAuth
    });
    return {
        localPublicKey: localPublicKey,
        salt: salt,
        cipherText: cipherText
    };
};
'use strict';
const DEFAULT_TTL = 2419200;
let gcmAPIKey = '';
let vapidDetails;
function WebPushLib() {}
WebPushLib.prototype.setGCMAPIKey = function(apiKey) {
    if (apiKey === null) {
        gcmAPIKey = null;
        return;
    }
    if (typeof apiKey === 'undefined' || typeof apiKey !== 'string' || apiKey.length === 0) {
        throw new Error('The GCM API Key should be a non-empty string or null.');
    }
    gcmAPIKey = apiKey;
};
WebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {
    if (arguments.length === 1 && arguments[0] === null) {
        vapidDetails = null;
        return;
    }
    validateSubject(subject);
    validatePublicKey(publicKey);
    validatePrivateKey(privateKey);
    vapidDetails = {
        subject: subject,
        publicKey: publicKey,
        privateKey: privateKey
    };
};
WebPushLib.prototype.generateRequestDetails = async function(subscription, payload, options) {
    if (!subscription || !subscription.endpoint) {
        throw new Error('You must pass in a subscription with at least ' + 'an endpoint.');
    }
    if (typeof subscription.endpoint !== 'string' || subscription.endpoint.length === 0) {
        throw new Error('The subscription endpoint must be a string with ' + 'a valid URL.');
    }
    if (payload) {
        if (typeof subscription !== 'object' || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {
            throw new Error('To send a message with a payload, the ' + "subscription must have 'auth' and 'p256dh' keys.");
        }
    }
    let currentGCMAPIKey = gcmAPIKey;
    let currentVapidDetails = vapidDetails;
    let timeToLive = DEFAULT_TTL;
    let extraHeaders = {};
    let contentEncoding = WebPushConstants.supportedContentEncodings.AES_128_GCM;
    let proxy;
    let agent;
    let timeout;
    if (options) {
        const validOptionKeys = [
            'headers',
            'gcmAPIKey',
            'vapidDetails',
            'TTL',
            'contentEncoding',
            'proxy',
            'agent',
            'timeout', 
        ];
        const optionKeys = Object.keys(options);
        for(let i = 0; i < optionKeys.length; i += 1){
            const optionKey = optionKeys[i];
            if (validOptionKeys.indexOf(optionKey) === -1) {
                throw new Error("'" + optionKey + "' is an invalid option. " + "The valid options are ['" + validOptionKeys.join("', '") + "'].");
            }
        }
        if (options.headers) {
            extraHeaders = options.headers;
            let duplicates = Object.keys(extraHeaders).filter(function(header) {
                return typeof options[header] !== 'undefined';
            });
            if (duplicates.length > 0) {
                throw new Error('Duplicated headers defined [' + duplicates.join(',') + ']. Please either define the header in the' + "top level options OR in the 'headers' key.");
            }
        }
        if (options.gcmAPIKey) {
            currentGCMAPIKey = options.gcmAPIKey;
        }
        if (options.vapidDetails !== undefined) {
            currentVapidDetails = options.vapidDetails;
        }
        if (options.TTL !== undefined) {
            timeToLive = Number(options.TTL);
            if (timeToLive < 0) {
                throw new Error('TTL should be a number and should be at least 0');
            }
        }
        if (options.contentEncoding) {
            if (options.contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM || options.contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {
                contentEncoding = options.contentEncoding;
            } else {
                throw new Error('Unsupported content encoding specified.');
            }
        }
        if (options.proxy) {
            if (typeof options.proxy === 'string' || typeof options.proxy.host === 'string') {
                proxy = options.proxy;
            } else {
                console.warn('Attempt to use proxy option, but invalid type it should be a string or proxy options object.');
            }
        }
        if (options.agent) {
            if (options.agent instanceof Agent) {
                if (proxy) {
                    console.warn('Agent option will be ignored because proxy option is defined.');
                }
                agent = options.agent;
            } else {
                console.warn('Wrong type for the agent option, it should be an instance of https.Agent.');
            }
        }
        if (typeof options.timeout === 'number') {
            timeout = options.timeout;
        }
    }
    if (typeof timeToLive === 'undefined') {
        timeToLive = DEFAULT_TTL;
    }
    const requestDetails = {
        method: 'POST',
        headers: {
            TTL: timeToLive
        }
    };
    Object.keys(extraHeaders).forEach(function(header) {
        requestDetails.headers[header] = extraHeaders[header];
    });
    let requestPayload = null;
    if (payload) {
        const encrypted = encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);
        requestDetails.headers['Content-Length'] = encrypted.cipherText.length;
        requestDetails.headers['Content-Type'] = 'application/octet-stream';
        if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {
            requestDetails.headers['Content-Encoding'] = WebPushConstants.supportedContentEncodings.AES_128_GCM;
        } else if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {
            requestDetails.headers['Content-Encoding'] = WebPushConstants.supportedContentEncodings.AES_GCM;
            requestDetails.headers.Encryption = 'salt=' + encrypted.salt;
            requestDetails.headers['Crypto-Key'] = 'dh=' + encode(encrypted.localPublicKey);
        }
        requestPayload = encrypted.cipherText;
    } else {
        requestDetails.headers['Content-Length'] = 0;
    }
    const isGCM = subscription.endpoint.indexOf('https://android.googleapis.com/gcm/send') === 0;
    const isFCM = subscription.endpoint.indexOf('https://fcm.googleapis.com/fcm/send') === 0;
    if (isGCM) {
        if (!currentGCMAPIKey) {
            console.warn('Attempt to send push notification to GCM endpoint, ' + 'but no GCM key is defined. Please use setGCMApiKey() or add ' + "'gcmAPIKey' as an option.");
        } else {
            requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;
        }
    } else if (currentVapidDetails) {
        const parsedUrl = parse(subscription.endpoint);
        const audience = parsedUrl.protocol + '//' + parsedUrl.host;
        const vapidHeaders = await getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);
        requestDetails.headers.Authorization = vapidHeaders.Authorization;
        if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {
            if (requestDetails.headers['Crypto-Key']) {
                requestDetails.headers['Crypto-Key'] += ';' + vapidHeaders['Crypto-Key'];
            } else {
                requestDetails.headers['Crypto-Key'] = vapidHeaders['Crypto-Key'];
            }
        }
    } else if (isFCM && currentGCMAPIKey) {
        requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;
    }
    requestDetails.body = requestPayload;
    requestDetails.endpoint = subscription.endpoint;
    if (proxy) {
        requestDetails.proxy = proxy;
    }
    if (agent) {
        requestDetails.agent = agent;
    }
    if (timeout) {
        requestDetails.timeout = timeout;
    }
    return requestDetails;
};
WebPushLib.prototype.sendNotification = function(subscription, payload, options) {
    let requestDetails;
    try {
        requestDetails = this.generateRequestDetails(subscription, payload, options);
    } catch (err) {
        return Promise.reject(err);
    }
    return new Promise(async function(resolve, reject) {
        const httpsOptions = {};
        const urlParts = parse(requestDetails.endpoint, false, false);
        httpsOptions.hostname = urlParts.hostname;
        httpsOptions.port = urlParts.port;
        httpsOptions.path = urlParts.path;
        httpsOptions.headers = requestDetails.headers;
        httpsOptions.method = requestDetails.method;
        if (requestDetails.timeout) {
            httpsOptions.timeout = requestDetails.timeout;
        }
        if (requestDetails.agent) {
            httpsOptions.agent = requestDetails.agent;
        }
        if (requestDetails.body) {
            httpsOptions.body = requestDetails.body;
        }
        const pushResponse = await fetch(requestDetails.endpoint, httpsOptions).catch((e)=>{
            reject(e);
        });
        if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {
            reject(new WebPushError('Received unexpected response code', pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));
        } else {
            const responseText1 = await pushResponse.text();
            resolve({
                statusCode: pushResponse.statusCode,
                body: responseText1,
                headers: pushResponse.headers
            });
        }
    });
};
'use strict';
export { getVapidHeaders as getVapidHeaders, generateVAPIDKeys as generateVAPIDKeys };
export { encrypt as encrypt };
export { supportedContentEncodings as supportedContentEncodings };
const webPush = new WebPushLib();
export { WebPushError as WebPushError };
const setGCMAPIKey = webPush.setGCMAPIKey;
const setVapidDetails = webPush.setVapidDetails;
const generateRequestDetails = webPush.generateRequestDetails;
const sendNotification = webPush.sendNotification;
export { setGCMAPIKey as setGCMAPIKey };
export { setVapidDetails as setVapidDetails };
export { generateRequestDetails as generateRequestDetails };
export { sendNotification as sendNotification };
